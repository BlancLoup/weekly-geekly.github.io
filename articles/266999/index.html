<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Encapsulation of interfaces. We make API in C ++ convenient and understandable.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In due time, I wrote a series of articles for the Hacker magazine for the ‚ÄúAcademy C ++‚Äù column, in which I described interesting possibilities of usi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Encapsulation of interfaces. We make API in C ++ convenient and understandable.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b14/68f/0b7/b1468f0b733fdc6934602b3f7fba0017.jpg" align="left">  In due time, I wrote a series of articles for the Hacker magazine for the ‚ÄúAcademy C ++‚Äù column, in which I described interesting possibilities of using C ++.  The cycle has long been completed, but I am still often asked how exactly the emulation of dynamic typing in the <a href="http://habrahabr.ru/company/xakep/blog/257891/">first article</a> works.  The fact is that when I started the cycle, I did not know exactly what was needed and what was not, and I missed a number of necessary facts in the description.  In vain!  There is nothing superfluous in the training material.  Today I will explain in detail exactly how a beautiful high-level API is obtained in terms of the most common C ++: just classes, methods and data. <br><a name="habracut"></a><br><h3>  What is it for </h3><br>  As a rule, something fast is written in C ++, but not always easy to use.  In the process of developing any product, general functionality is provided with a more or less well-designed interface for working with product entities.  C ++ language strongly encourages pointers and links to base classes, which multiply and complicate the code, wrapped in all sorts of "smart" pointers and generate kilometer-long lines in any reference to such a design! <br>  Agree, it is hardly convenient to use this: <br><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;base_class&gt;&gt;&gt;</code> </pre> <br>  Especially if for each element of the vector an operation of a class of successor is needed, that is, the method is not included in the above-mentioned base_class.  What, can not find the base_class in the construction a little higher?  And I talked about! <br>  For ease of use of working with the base class, the easiest way to select the essence of working with it and encapsulate the interface into it as a simple pointer to the class data. <br><br><h3>  Base class interface </h3><br>  To simplify the narrative as much as possible, there will be many examples, and we will not go far from the code.  The code itself will be attached to the article, and here it will not be lost anywhere else.  So, I propose to form the base class as a data object, let's simplify it as much as possible: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); //     ,  <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> virtual ~<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); //    unique_ptr //  <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(const <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (const <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another); //   <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> is_null() const; //      <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> data; //     const data* get_data() const; //     const <span class="hljs-type"><span class="hljs-type">char</span></span>* data_class() const; protected: //    <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(data* new_data); <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>(data* new_data); //       <span class="hljs-type"><span class="hljs-type">void</span></span> assert_not_null(const <span class="hljs-type"><span class="hljs-type">char</span></span>* file, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>) const; private: //    std::unique_ptr&lt;data&gt; m_data; };</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What we previously used as an interface to the base class turns into object :: data - the most important class, which is no longer visible anywhere outside. <br>  In fact, in object, as in object :: data, there should be basic operations for which that base_class was wound up.  But we will not need them in the description, and without that there will be many interesting things. <br>  In its minimal form, the data class of an object looks easier than ever: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:data { public: //      virtual data* clone</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     virtual const char* class_name() const = 0; };</span></span></code> </pre><br><br>  The only method that we really need in the base class is to clone the data of the corresponding heir.  And, as you can see, the interface class is fine without the clone () method, the object itself and all of its descendants use the usual copy constructors.  This is where we come to the most important thing - inheritance from the encapsulated base class. <br><br><h3>  Double inheritance </h3><br>  For heirs, we need to select a pair of entities.  Let's develop a computer game where we will have spaceships and asteroids.  Accordingly, we need two pairs of classes for work: asteroid and spaceship. <br>  Let's add a unique method to the classes of successors: let asteroids be distinguished by an integer identifier, and the spacecraft are identified by a unique name: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> asteroid : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: //       asteroid(<span class="hljs-type"><span class="hljs-type">int</span></span> identifier); //   asteroid(const asteroid&amp; another); asteroid&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (const asteroid&amp; another); //     "" asteroid(const <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another); asteroid&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (const <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another); //   - <span class="hljs-type"><span class="hljs-type">int</span></span> get_identifier() const; //    <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> data; private: //     (!)   data* m_data; }; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> spaceship : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: //      spaceship(const <span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-type"><span class="hljs-type">name</span></span>); //    spaceship(const spaceship&amp; another); spaceship&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (const spaceship&amp; another); //     "" spaceship(const <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another); spaceship&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (const <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another); //    " " const <span class="hljs-type"><span class="hljs-type">char</span></span>* get_name() const; //    <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> data; private: //    (!)    data* m_data; };</code> </pre><br><br>  Please note that although the ancestor of the object performs the role of the container, there is a reference in the successors to the contents of the object, but of the desired type.  The inheritance of the main classes should also be duplicated for the data classes (I will show below what this is for): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> asteroid::data : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::data { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: //       data(<span class="hljs-type"><span class="hljs-type">int</span></span> identifier); //       <span class="hljs-type"><span class="hljs-type">int</span></span> get_identifier() const; //     ! virtual <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::data* clone() const override; //       virtual const <span class="hljs-type"><span class="hljs-type">char</span></span>* class_name() const override; private: //   asteroid     <span class="hljs-type"><span class="hljs-type">int</span></span> m_identifier; }; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> spaceship::data : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::data { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: //  ,        data(const <span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-type"><span class="hljs-type">name</span></span>); //       spaceship::data const <span class="hljs-type"><span class="hljs-type">char</span></span>* get_name() const; //     ! virtual <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::data* clone() const override; //      virtual const <span class="hljs-type"><span class="hljs-type">char</span></span>* class_name() const override; private: //       #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;string&gt; std::string m_name; };</code> </pre><br><br>  Now we‚Äôll go through the implementation in more detail, and everything will immediately fall into place. <br><br><h3>  Implementation methods </h3><br>  Creating an instance of type directly by the default constructor will mean creating an object with a null value. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>() { } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::~<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>() { } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>* new_data) : m_data(new_data) { } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another) : m_data(another.is_null() ? nullptr : another.m_data-&gt;clone()) { } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&amp; another) { m_data.reset(another.is_null() ? nullptr : another.m_data-&gt;clone()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } bool <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::is_null() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !m_data; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::get_data() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char* <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::data_class() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_null() ? <span class="hljs-string"><span class="hljs-string">"null"</span></span> : m_data-&gt;class_name(); } void <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::reset(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>* new_data) { m_data.reset(new_data); } void <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>::assert_not_null(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char* file, int line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null()) { std::stringstream output; output &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Assert 'object is not null' failed at file: '"</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' line: "</span></span> &lt;&lt; line; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(output.str()); } }</code> </pre><br><br>  Now the most important thing is how instances of inheritance classes are initialized: <br><br><pre> <code class="hljs pgsql">asteroid::asteroid(<span class="hljs-type"><span class="hljs-type">int</span></span> identifier) : <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(m_data = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> asteroid::data(identifier)) { } spaceship::spaceship(const <span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-type"><span class="hljs-type">name</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(m_data = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> spaceship::data(<span class="hljs-type"><span class="hljs-type">name</span></span>)) { }</code> </pre><br><br>  As you can see from these few lines, we immediately kill a flock of hares with one volley of a phase blaster: <br><ol><li>  we get the creation of the heirs with the preservation of the reference to the data in a special container class by the usual constructor; </li><li>  the container class is also the base class for all others, all the basic work of storing the interface is done in the base class; </li><li>  a descendant class has an interface for working with the data class of the corresponding class in m_data; </li><li>  we work with the most common classes, not by reference, getting all the benefits of C ++ automation working with instances of classes. </li></ol><br><br>  Of course, when accessing data, the corresponding class will use its own heir interface, while checking the data for null: <br><br><pre> <code class="hljs php">int asteroid::get_identifier() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert_not_null(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__LINE__</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data-&gt;get_identifier(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char* spaceship::get_name() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert_not_null(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__LINE__</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data-&gt;get_name(); }</code> </pre><br><br>  A simple example that will work like a clock: <br><br><pre> <code class="hljs scala"> asteroid aster(<span class="hljs-number"><span class="hljs-number">12345</span></span>); spaceship ship(<span class="hljs-string"><span class="hljs-string">"Alfa-Romeo"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_aster</span></span></span><span class="hljs-class"> </span></span>= asteroid(<span class="hljs-number"><span class="hljs-number">67890</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_ship</span></span></span><span class="hljs-class"> </span></span>= spaceship(<span class="hljs-string"><span class="hljs-string">"Omega-Juliette"</span></span>);</code> </pre><br><br>  Checking: <br><blockquote>  Test for null: <br>  aster.is_null (): false <br>  ship.is_null (): false <br>  obj.is_null (): true <br>  obj_aster.is_null (): false <br>  obj_ship.is_null (): false <br><br>  Test for data class: <br>  aster.data_class (): asteroid <br>  ship.data_class (): spaceship <br>  obj.data_class (): null <br>  obj_aster.data_class (): asteroid <br>  obj_ship.data_class (): spaceship <br><br>  Test identification: <br>  aster.get_identifier (): 12345 <br>  ship.get_name (): Alfa-Romeo <br></blockquote><br><br>  Doesn‚Äôt it resemble high-level languages: C #, Java, Python, etc.?  The only difficulty will be getting back the interface of the heirs packed in the object.  Now we will learn how to extract into the asteroid and spaceship instances what was previously packed into the object. <br><br><h3>  Way up </h3><br>  All we need is to overload the constructor of the class of heirs, though the initialization itself will not work very well: <br><br><pre> <code class="hljs cpp">asteroid::asteroid(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asteroid&amp; another) : object(m_data = another.is_null() ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;asteroid::data*&gt;(another.get_data()-&gt;clone())) { } asteroid&amp; asteroid::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asteroid&amp; another) { reset(m_data = another.is_null() ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;asteroid::data*&gt;(another.get_data()-&gt;clone())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } asteroid::asteroid(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object&amp; another) : object(m_data = (<span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asteroid::data*&gt;(another.get_data()) ? <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;asteroid::data*&gt;(another.get_data()-&gt;clone()) : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)) { } asteroid&amp; asteroid::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object&amp; another) { reset(m_data = (<span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asteroid::data*&gt;(another.get_data()) ? <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;asteroid::data*&gt;(another.get_data()-&gt;clone()) : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><br><pre> <code class="hljs cpp">spaceship::spaceship(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spaceship&amp; another) : object(m_data = another.is_null() ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;spaceship::data*&gt;(another.get_data()-&gt;clone())) { } spaceship&amp; spaceship::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spaceship&amp; another) { reset(m_data = another.is_null() ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;spaceship::data*&gt;(another.get_data()-&gt;clone())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } spaceship::spaceship(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object&amp; another) : object(m_data = (<span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spaceship::data*&gt;(another.get_data()) ? <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;spaceship::data*&gt;(another.get_data()-&gt;clone()) : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)) { } spaceship&amp; spaceship::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object&amp; another) { reset(m_data = (<span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spaceship::data*&gt;(another.get_data()) ? <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;spaceship::data*&gt;(another.get_data()-&gt;clone()) : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><br>  As you can see, you will have to use dynamic_cast here, simply because you have to go up the hierarchy of data classes.  It looks massive, but the result is worth it: <br><br><pre> <code class="hljs scala"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_aster</span></span></span><span class="hljs-class"> </span></span>= asteroid(<span class="hljs-number"><span class="hljs-number">67890</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_ship</span></span></span><span class="hljs-class"> </span></span>= spaceship(<span class="hljs-string"><span class="hljs-string">"Omega-Juliette"</span></span>); asteroid aster_obj = obj_aster; spaceship ship_obj = obj_ship;</code> </pre><br><br>  Checking: <br><blockquote>  Test for null: <br>  aster_obj.is_null (): false <br>  ship_obj.is_null (): false <br><br>  Test for data class: <br>  aster_obj.data_class (): asteroid <br>  ship_obj.data_class (): spaceship <br><br>  Test identification: <br>  aster_obj.get_identifier (): 67890 <br>  ship_obj.get_name (): Omega-Juliette <br></blockquote><br><br>  Roundtrip.  Like Tolkien, only much shorter. <br>  Do not forget to test also assignment statements: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">aster</span></span> = asteroid(<span class="hljs-number"><span class="hljs-number">335577</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">ship</span></span> = spaceship(<span class="hljs-string"><span class="hljs-string">"Ramambahara"</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">obj</span></span> = object(); <span class="hljs-attribute"><span class="hljs-attribute">obj_aster</span></span> = asteroid(<span class="hljs-number"><span class="hljs-number">446688</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">obj_ship</span></span> = spaceship(<span class="hljs-string"><span class="hljs-string">"Mamburu"</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">aster_obj</span></span> = obj_aster; <span class="hljs-attribute"><span class="hljs-attribute">ship_obj</span></span> = obj_ship;</code> </pre><br><br>  And check again: <br><blockquote>  Test for null: <br>  aster.is_null (): false <br>  ship.is_null (): false <br>  obj.is_null (): true <br>  obj_aster.is_null (): false <br>  obj_ship.is_null (): false <br>  aster_obj.is_null (): false <br>  ship_obj.is_null (): false <br><br>  Test for data class: <br>  aster.data_class (): asteroid <br>  ship.data_class (): spaceship <br>  obj.data_class (): null <br>  obj_aster.data_class (): asteroid <br>  obj_ship.data_class (): spaceship <br>  aster_obj.data_class (): asteroid <br>  ship_obj.data_class (): spaceship <br><br>  Test identification: <br>  aster.get_identifier (): 335577 <br>  ship.get_name (): Ramambahara <br>  aster_obj.get_identifier (): 446688 <br>  ship_obj.get_name (): Mamburu <br></blockquote><br><br>  Everything works as it should!  Below is a <a href="https://github.com/qualab/interfaces">link to GitHub with sources</a> . <br><br><h3>  PROFIT! </h3><br>  What we have?  This is not Pimpl, for Pimpl there is too much polymorphism, and the name ‚Äúimplementation pointer‚Äù is not the most successful.  In C ++, the implementation is already separate from the class declaration, in .cpp files, Pimpl allows you to remove the data in the implementation.  Here, the data are not just hidden in the implementation, they constitute a hierarchy tree, while mirroring the hierarchy of interface classes.  In addition, we get the encapsulation of null values ‚Äã‚Äãand we can embed the validity logic of null values ‚Äã‚Äãin the inheritance classes.  All classes easily juggle with data - both their own and the whole chain of ancestors and heirs, while the syntax itself will be simple and concise. <br>  Want to make it easy in your library's API?  Now nothing bothers you.  As for the replicas that C ++ is very complex and you cannot make high-level logic on it - please, you can combine arrays of such objects, not worse than C # or Java, and the transformations will be even simpler.  You can make your classes easy to use, without having to store pointers to the base class, messing with factories, in general, you can no longer emulate ordinary constructors and assignment operators in any way. <br><br><h3>  useful links </h3><br>  With the article are the source code <a href="https://github.com/qualab/interfaces">posted on GitHub.</a> <br>  Sources are supplemented with a couple of methods that simplify testing and allow you to more quickly understand how data transfer between objects works. <br>  I will also leave a link to the <a href="http://habrahabr.ru/company/xakep/blog/257891/">series of articles "Academy C ++"</a> for the magazine "Hacker". </div><p>Source: <a href="https://habr.com/ru/post/266999/">https://habr.com/ru/post/266999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266987/index.html">ABBYY helps to digitize rare editions of the Sakhalin Library</a></li>
<li><a href="../266991/index.html">Restricting Access to Web Applications in Synology DSM</a></li>
<li><a href="../266993/index.html">Cleaning Dropbox backup storage by cron</a></li>
<li><a href="../266995/index.html">Home server for work and not only. The organization of the workplace of a lazy engineer</a></li>
<li><a href="../266997/index.html">The digest of interesting materials from the world of Drupal # 13</a></li>
<li><a href="../267001/index.html">Adaptive design alone is not enough: we need adaptive performance.</a></li>
<li><a href="../267003/index.html">Reinforced.Typings - more details</a></li>
<li><a href="../267007/index.html">How I ran a poster for Jewish events</a></li>
<li><a href="../267009/index.html">Publishing logs in Elasticsearch - life without regular expressions and without logstash</a></li>
<li><a href="../267011/index.html">RailsClub 2015: Interview with Ivan Nemytchenko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>