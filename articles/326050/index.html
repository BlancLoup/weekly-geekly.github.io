<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplify working with CloudKit, or synchronization in the spirit of Zen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Cloud synchronization is a regular trend of the last few years. If you are developing for one or several Apple platforms (iOS, macOS, t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplify working with CloudKit, or synchronization in the spirit of Zen</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  Cloud synchronization is a regular trend of the last few years.  If you are developing for one or several Apple platforms (iOS, macOS, tvOS, watchOS) and the task is to implement synchronization functionality between applications, then you have a very handy tool, or even a whole service - CloudKit. <br><br>  Our team constantly has to screw up the functionality of data synchronization with CloudKit, including in projects that use CoreData as a data warehouse.  Therefore, the idea arose, and then the idea was implemented - to write a universal interface for synchronization. <br><br>  CloudKit is not just a framework.  This is a full BaaS (Backend as a Service), i.e.  comprehensive service with a full-fledged infrastructure, including cloud storage, push notifications, access policies and much more, as well as offering a universal cross-platform program interface (API). <br><div style="text-align:center;"><img src="https://habrastorage.org/files/7dd/f7e/f8a/7ddf7ef8a2a44072b4a1fac9a1a98696.png"></div><a name="habracut"></a><br>  CloudKit is easy to use and relatively affordable.  Just for being a member of the <a href="https://developer.apple.com/">Apple Developer Program</a> , at your disposal for free: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  10Gb storage for resources </li><li>  100MB for the database </li><li>  2GB of traffic per day </li><li>  40 requests per second </li></ul><br>  And these numbers can be increased if there is such a need.  It is worth noting that CloudKit does not use the user's iCloud storage.  The latter is used only for authentication. <br><br>  This article is not an advertisement for CloudKit or even another review of the basics of working with it.  There will be nothing about setting up a project, configuring the App ID in your developer profile, creating a CK container or Record Type in the CloudKit dashboard.  In addition, not only the backend component remains outside the article, but also the entire software component directly related to the CloudKit API.  If you would like to understand exactly the basics of working with CloudKit, then there are already excellent introductory articles for this, to repeat which makes no sense. <br><br><ul><li>  <a href="https://www.raywenderlich.com/134694/cloudkit-tutorial-getting-started">CloudKit Tutorial: Getting Started</a> </li><li>  <a href="http://nshipster.com/cloudkit/">Cloud kit</a> </li><li>  <a href="https://yalantis.com/blog/work-cloudkit/">How to Work With CloudKit</a> </li><li>  <a href="http://www.appcoda.com/cloudkit-introduction-tutorial/">Working with CloudKit in iOS 8</a> </li></ul><br>  This article is in a sense the next step. <br><br>  When you are already familiar with something that you have been using for a long time, sooner or later the question arises: how to automate the process, make it even more convenient and more unified?  This is how design patterns came about.  This is how our framework, which makes it easier to work with CloudKit - ZenCloudKit, which has already been successfully applied in a number of projects, arose.  About him, namely, about the new technical way of working with CloudKit, and will be discussed further. <br><br><h3>  Universal interface </h3><br>  Creating the framework, our ultimate goal was to implement such an interface that would be compatible with CoreData entities, allowing us to synchronize ‚Äî save, delete and retrieve data ‚Äî with a minimum of effort, taking into account the existing database connections, regardless of the complexity of the existing architecture. <br><br>  The framework is written in Swift 3 and it is Swift-developers who are fully able to experience the benefits of its use.  For Objective-C, a fully-fledged bridge is possible, but for obvious reasons, similar things will look in it redundant and more cumbersome to implement.  The code examples in this article will be written in Swift. <br><br>  Let us turn to the review, in parallel considering the example of implementation. <br><br><h3>  Implementation example </h3><br>  Consider as an introduction some typical synchronization operations: save and delete methods.  The final implementation is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c4e/cbe/0e8/c4ecbe0e891b4a33ad46ff9fa38a5af3.png"></div><br><br>  What is going on here? <br><br>  Suppose we have an <b>event</b> object with an <b>entity</b> property, where the <b>entity</b> is an NSManagedObject.  This NSManagedObject, like any database object, has fields, some of which are properties, some are links, <i>reference</i> , to other NSManagedObject objects, forming one-to-one or one-to-many links. <br><br>  To save this object (or delete the corresponding one) synchronously or asynchronously to the CloudKit database, while forwarding all the connections, the proxy object is used - iCloud, which contains the appropriate methods.  It is enough to call entity.iCloud.save () (asynchronous) or entity.iCloud.saveAndWait () (synchronous saving) so that all fields of the entity are recorded in the corresponding fields of the CloudKit object, and the unique UUID from the newly saved CKRecord (i.e. string The recordName property of the CKRecordID object) was automatically written back to the specially designated field of the entity object, thereby forming a link between the local and remote object. <br><br>  If you have never used CloudKit and it all sounds incomprehensible, then it is easier to say that any entity has .iCloud.save () and this is enough to keep both the object and all its connections.  No more sets of identical methods for different entities and dirt in the client code.  Convenient, isn't it? <br><br><h3>  Setting up sync objects </h3><br>  In order for this to work, you must fulfill several conditions. <br><br>  The work is based on the widely used property mapping scheme, which is used in many libraries, in various web parsers (such as RestKit), etc.  Mapping is implemented in the classical manner - by means of KVC, which is supported only by the heirs of NSObject.  Hence, the first condition: <br><br>  1) Each synchronized object must be an NSObject descendant (for example, NSManagedObject is an excellent choice). <br><br>  2) Each synchronized object must implement the ZKEntity protocol, which looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7e8/abf/e87/7e8abfe874d64a0c995df2aa330651ca.png"></div><br><br>  If you work with CoreData, then you need to implement directly in your (sub-) class: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e34/11d/602/e3411d602b714ee5846f5c369ac8a2c5.png"></div><br><br>  As can be seen from the protocol, the required fields are recordType and mappingDictionary.  Consider both. <br><br>  <b>// REQUIRED (required fields)</b> <br><br>  1) <b>recordType</b> - the corresponding record type, Record Type, in CloudKit. <br><br>  Example: the Person class contains the recordType = ‚ÄúPerson‚Äù property.  After the save () call on its instance, an entry will be made in the CloudKit dashboard in this table (‚ÄúPerson‚Äù). <br><br>  Implementation: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recordType = <span class="hljs-string"><span class="hljs-string">"Person"</span></span></code> </pre> <br>  2) <b>mappingDictionary</b> - property mapping dictionary. <br>  Scheme: [local key: remote key (field in the CloudKit table)]. <br><br>  Example: the Person class contains the fields firstName and lastName.  To save them to the Person table in CloudKit with the same names, you need to write the following: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">static</span></span> var mappingDictionary = [ <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> : ‚ÄúfirstName‚Äù, ‚Äú<span class="hljs-literal"><span class="hljs-literal">last</span></span>Name‚Äù : ‚Äú<span class="hljs-literal"><span class="hljs-literal">last</span></span>Name‚Äù ]</code> </pre> <br><br>  <b>// OPTIONAL (optional fields)</b> <br><br>  The remaining protocol fields are optional, <br><br>  3) <b>syncIdKey</b> is the name of a local property that will store the ID of the remote object.  ID - is the passport of the object, necessary for communication local &lt;-&gt; remote. <br><br>  The field is conditionally optional.  When initializing the controller framework, which will be described below, it is possible to specify the name of the property for all entities.  However, specified individually in the class of the entity, it has a higher priority and it will be checked first at parsing.  And only then, if the implementation is empty, the universal key will be used (see below). <br><br>  Implementation: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncId: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"cloudID"</span></span></code> </pre> <br>  <b>changeDateKey</b> is the name of a local property that will hold the date the object was changed.  Another utility property required for synchronization. <br><br>  Similar to the previous one, it is conditionally optional.  It is possible to omit the implementation and specify the name of the property for all synchronized objects during the initialization of ZenCloudKit (see below). <br><br>  Implementation: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> changeDateKey: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"changeDate"</span></span></code> </pre> <br>  <b>references</b> is a dictionary containing keys that implement the * -c-one connection. <br>  Scheme: [‚Äúlocal key‚Äù: ‚Äúremote key‚Äù] <br><br>  The requirement here is that the property ‚Äúlocal key‚Äù with its type has a class that satisfies the basic requirements (inherits NSObject and implements the ZKEntity protocol). <br><br>  When you call save () on a local object, ZenCloudKit will also try to save everything associated with it. <br><br>  Implementation: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> references : [<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>] = [<span class="hljs-string"><span class="hljs-string">"homeAddress"</span></span> : <span class="hljs-string"><span class="hljs-string">"address"</span></span>]</code> </pre> <br>  <b>referenceLists</b> is a dictionary containing an array of ZKRefList objects, each of which carries information about a specific * -to-many relationship: the type of objects and the name of the key for which you need to query and save this list. <br><br>  Schema: ZKRefList (entityType: ZKEntity.Type, <br>  localSource: a local property that returns an array of ZKEntity objects, <br>  remoteKey: key in CloudKit for storing an array of links (CKReference)) <br><br>  Implementation: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> referenceLists: [<span class="hljs-type"><span class="hljs-type">ZKRefList</span></span>] = [<span class="hljs-type"><span class="hljs-type">ZKRefList</span></span>(entityType: <span class="hljs-type"><span class="hljs-type">Course</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, localSource: <span class="hljs-string"><span class="hljs-string">"courseReferences"</span></span>, remoteKey: <span class="hljs-string"><span class="hljs-string">"courses"</span></span>)]</code> </pre> <br><br>  <b>courseReferences</b> is a user-defined property that returns an array of ZKEntity objects that you would like to keep and links to which should be placed in the list of links of the root object. <br><br>  Code (continued): <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> courseReferences : [<span class="hljs-type"><span class="hljs-type">Course</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.courses?.allObjects <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? [<span class="hljs-type"><span class="hljs-type">Course</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mutableSetValue(forKey: <span class="hljs-string"><span class="hljs-string">"courses"</span></span>).removeAllObjects() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mutableSetValue(forKey: <span class="hljs-string"><span class="hljs-string">"courses"</span></span>).addObjects(from: newValue!) } }</code> </pre> <br>  Implementing the appropriate setter is also necessary so that the application can save objects derived from CloudKit.  Thus, the localSource field of the ZKRefList object is essentially a reference to a handler (handler) that controls input and output operations. <br><br>  <b>isWeak</b> is an optional flag that, when set (true), indicates that any other object that refers to an instance of this type forms a weak link (analogy with the weak modifier) ‚Äã‚Äãin CloudKit.  This means that the record of it will be deleted in cascade, as soon as the object that contains the link to it is deleted. <br><br>  Example: there is an object A that refers to object B. <br><br>  If you set B.isWeak = true, object A will be saved to CloudKit with a ‚Äúweak link‚Äù to B. Object B will be deleted automatically as soon as you delete object A. <br><br>  This flag is an implementation of the CloudKit native API and appeals to the CKReference constructor with the .deleteSelf flag: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">CKReference</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.init</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">record</span></span>: &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">CKRecord</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">action</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.deleteSelf</span></span>)</code> </pre> <br>  Therefore, the removal mechanics is entirely the prerogative of CloudKit, while the framework simply offers a more user-friendly interface.  In the future, this functionality can be expanded so that cascade deletion can be configured for different entities. <br><br>  Implementation: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isWeak = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  <b>referencePlaceholder</b> is a property that, when declared, avoids the nil value when an object is received from CloudKit, replacing it with a default value. <br><br>  If it is assumed that the CoreData entity object should always contain some value other than nil as a reference to another object, then whenever this object is absent from CloudKit during synchronization, the local property can be automatically set to a default value. <br><br>  Example: there is a class A with property b and, mirroring to it, the same Record Type in CloudKit. <br><br>  CloudKit has an object A, which is absent locally and has an empty reference to B (the value is absent).  In a typical scenario, as a result of synchronization, you would get an object A whose property b would be nil.  But with the default value set in the local class ( <b>referencePlaceholder =</b> ...), ZenCloudKit will automatically assign the value you specify to property b: <br><br>  Ab = referencePlaceholder, <br><br>  where the latter is an instance of B. <br><br>  So, as a result of a full synchronization cycle, objects with full links will always be created in your application, even if they were kept empty on all other devices. <br><br>  Implementation: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> referencePlaceholder: <span class="hljs-type"><span class="hljs-type">ZKEntity</span></span> = <span class="hljs-type"><span class="hljs-type">B</span></span>.defaultInstance()</code> </pre> <br>  Please note that the referencePlaceholder is specified in the target class.  If it is necessary that property b of object A does not turn out to be nil (Ab! = Nil), then it is in class B that you must implement referencePlaceholder, and not in the root class A, which we received as a result of synchronization. <br><br>  <b>// SUMMARY</b> <br><br>  At the time of this writing, this is all the functionality supported by ZKEntity.  Summarize the above again as a concrete example. <br><br>  Suppose there is an Event class: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2ea/91c/cae/2ea91ccaeb304839b1a551ad2162433d.png"></div><br>  A ZKEntity implementation might look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a01/e88/170/a01e88170bdb4641955cd071630526b4.png"></div><br><br>  Here: <br><br><ul><li>  dictionary for mapping properties. </li><li>  link mapping dictionary (optional) </li><li>  CloudKit Record Type </li></ul><br>  Omitted syncIdKey and changeDateKey.  In the example, they correspond to the syncID and changeDate properties.  Since similar properties (changeDate, syncID) are present in the interface of other classes, they were recorded in the initialization phase of ZenCloudKit (which will be discussed later) as universal, so the private implementation was omitted. <br><br><h3>  Configuring the controller and delegate </h3><br>  After the entities have been configured, you need to initialize the controller and assign its delegate.  This can be done in various ways, but the best thing to do is to allocate a separate class for this and write the called initializer. <br><br>  For starters, you can create a global variable that will store a link to a static controller instance. <br><br><img src="https://habrastorage.org/files/3ad/e87/469/3ade874692bc4e3084a237b874b5a62e.png"><br><br>  The delegate class will need to implement the following protocol: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a2a/c25/436/a2ac2543643b408d85a05bec43ff92de.png"></div><br><br>  Before considering each method separately, let's look at the version of the finished implementation (with the exception of the zenSyncDIdFinish method). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4c3/6c6/e6a/4c36c6e6a2a54de2a72365dd50d7c4e2.png"></div><br><br>  The CloudKitPresenter class in the example is a ZenCloudKit delegate.  Here is the initialization and call call-functions necessary to implement the full synchronization cycle.  A full synchronization cycle is a sequence of offscreen operations in which local and remote objects are compared in terms of change time and updated at both ends.  For this, for each type, i.e.  for each registered ZKEntity entity, the framework must provide three functions that implement the creation, request for an object by ID (fetch) and request for all available objects, respectively.  In each of the three functions, the ZKEntity class (ofType T: ZKEntity.Type) acts as a parameter.  As a result of execution, ZenCloudKit expects to receive objects of this particular type. <br><br>  <b>zenAllEntities (ofType T: ZKEntity.Type)</b> <br>  - expects to receive an array of all T-type entities <br><br>  <b>zenCreateEntity (ofType T: ZKEntity.Type)</b> <br>  - expects to receive a new copy of T. <br><br>  <b>zenFetchEntity (ofType T: ZKEntity.Type, syncId: String)</b> <br>  - expects to get an existing instance of T on the given syncId (or nil if there is none). <br><br>  For example, if you work with the entities Person and Home, then the parameter T in these functions will be equal to one of these two types.  Your task is to provide a result for each of them (a new object, an existing one and everything).  This can be done either by performing type checking and writing code for each, or using interface polymorphism. <br><br>  In the given example, for the implementation of the above operations, standard MagicalRecord methods are used to search for the existing one, create a new one and query all objects that work as extension-methods (or category methods, to put it in the spirit of Objective-C) for NSManagedObject.  This greatly simplifies implementation.  The code becomes universal, since there is no need to do a type-check for each T case. <br><br>  Functions are a concrete implementation of generic abstraction, although, strictly speaking, generalizations in the function signature are not used for purposes of compatibility with Objective-C. <br><br>  The last function uses the T.predicateForId (...) instruction.  This is the extension method provided by ZenCloudKit, which returns the correct search predicate for a given type of T by the given syncId (to avoid a hard code and the associated possible errors in the name of the property that locally stores the ID). <br><br>  <b>zenEntityDidSaveToCloud (entity: ZKEntity, record: CKRecord ?, error: Error?)</b> <br>  - Called every time you save to CloudKit.  In this phase, the entity has already received the remote object ID, so here you can, for example, save the main database context. <br><br>  The delegate implements a private singleton (sharedInstance is not visible to the client).  In order to initialize both the controller and its delegate, it is enough to call the method somewhere from the outside at the right time: <br><br><img src="https://habrastorage.org/files/381/66c/71d/38166c71d7774cb2aff2acda86839ef4.png"><br><br>  In the initialization method, the framework is configured: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/34f/673/4d3/34f6734d32c246f8b17abf45b39ac02f.png"></div><br><br>  Standard parameters for CloudKit are set: <br><br><ul><li>  container name </li><li>  database type (ofType: .public / .private) </li></ul><br>  This is followed by the syncIdKey and changeDateKey keys already discussed above ‚Äî the names of the properties that store the ID of the entries and the date of the change.  It should be noted that these values ‚Äã‚Äãcan be left blank (nil).  In this case, when calling the appropriate methods on ZKEntity instances (for example, save ()), ZenCloudKit will look for their implementation among the declarations of each class.  Conversely, it is sufficient to specify these keys only here in order to omit the specific implementation.  If both public and private implementation are empty, then calling cloudKit.setup () will generate an error in the log, and synchronization will not work. <br><br>  In the entities parameter we pass an array of all the types we are going to work with. <br><br>  ignoreKeys is an array of string keys that, upon detecting which, ZenCloudKit should ignore the object (for example, do not save or delete it). <br><br>  deviceId - device ID.  A very important parameter if several devices are involved in synchronization.  The developer should take care of the uniqueness of this parameter.  As standard, the Hardware UUID is taken, but other options are possible. <br><br>  <b>// RECAP</b> <br><br>  The implementation of the settings described so far is a necessary and sufficient condition for the basic functionality provided by the iCloud proxy to work, which, in turn, implements the ZKEntityFunctions protocol: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/230/dc1/7a8/230dc17a849f4db1ae0b006be68a2517.png"></div><br>  With the exception of the update () function, the purpose of which is to update a local object from a remote object, represented in the code as CKRecord.  This function should be used in the delegate's zenSyncDIdFinish method, which is called at the end of the full synchronization cycle, which, in turn, is started as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/781/f38/0a1/781f380a1f78436cb21f2ee48ee99e22.png"></div><br>  The first option is synchronization in standard mode.  Each subsequent synchronization cycle is fixed by ZenCloudKit;  if successful, the last sync date is saved (the framework takes care of all this).  Saving the date is very important: it allows you to select only those objects whose date of change is later than the date of the last successful cycle.  Otherwise, if, say, you have 100 objects in the database, then each cycle would include a meaningless check of long-synchronized, unchanging objects.  It is completely unnecessary and, moreover, resource-intensive operation. <br><br>  The second option is forced synchronization (forced: true).  There may be times when data integrity is compromised.  Then you can forcefully check each synchronized object, ignoring the date of the last successful cycle, and update the data locally and remotely.  Local objects will be updated by what lies in CloudKit (if for some reason this has not happened before).  And in CloudKit, local objects can be saved, which also for some reason have not been saved.  Depending on the specifics of your application, you yourself can determine where to force synchronization (for example, when starting, during a long idle time, or to take this function to the settings).  In general, there is no need for this call and, most likely, you will not have to resort to it. <br><br>  Calling the syncEntities () method at the controller level does the same only for all registered entities.  The specific parameter accepts specific types that you would like to synchronize (nil - if you want to apply to all). <br><br>  It remains to analyze the zenSyncDIdFinish method, the signature of which looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/870/4b3/a82/8704b3a82c7f4e63b2b462cd9d1cdd9b.png"></div><br>  Options: <br><br>  <b>T</b> - the type of entity whose objects you want to create or update. <br><br>  <b>newRecords</b> , <b>updatedRecords</b> - arrays of CKRecord, objects that need to be created or updated locally.  The reference point when searching for a local match is a unique ID, which is stored as standard in the CKRecord.recordID.recordName property.  The entity, among the objects of which you need to look for matches and an instance of which to create, is T. <br><br>  <b>DeletedRecords</b> is an array of <b>ZKDeleteInfo</b> objects, each of which stores information about the object to be deleted: the local ZKEntity type and object ID.  These objects can be of different types, so it is not necessary to focus on type T in this case.  The type of the object to be deleted should be viewed in the entityType property, and the object ID in the syncId property of the ZKDeleteInfo object.  The class looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aff/103/aef/aff103aef5f04a088d0618879a5ebac6.png"></div><br>  ZenCloudKit generates this list before completing the deletion by sending it to the zenSyncDidFinish handler in the deletedRecords array so that you can perform the necessary local cleanup.  Once locally everything is successfully removed, you need to call the callback method finishSync ().  If this is not done, then no changes will be made to the CloudKit database.  Such a scheme is adopted for security reasons: only by making sure that the local database is updated, you call the finalizer - finishSync (). <br><br>  <b>Always call finishSync () at the end of synchronization.</b> <br><br>  This applies not only to the deletion phase described above, but also to the creation and update phases. <br><br>  To summarize, consider a fragment of the implementation of the zenSyncDIdFinish function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/47e/134/1b3/47e1341b3aeb47929a778fa6e06ae3ea.png"></div><br>  Immediately after this fragment should follow: <br><br>  - call finishSync () <br>  - UI update functions that would reflect the changed state of the database (if required). <br><br>  With the following instructions: <br><br><img src="https://habrastorage.org/files/61b/cd9/155/61bcd91558804f34b6dd6aca05f9728c.png"><br><br>  we fill the fields of the local object with the fields CKRecord, which is available to us as an argument in one of the arrays.  The fetchReferences flag allows you to load all links.  By loading links, we mean the actual loading of the corresponding objects (listed in the <b>references</b> and <b>referenceLists</b> arrays described in the ZKEntity protocol) from CloudKit and their binding to this <b>entity</b> .  If, when loading a connection, it is found that the corresponding local object does not exist ( <b>zenFetchEntity == nil</b> ), it will be automatically created in the local database by calling the delegate's <b>zenCreateEntity</b> method. <br><br>  If the formation of these links implies a change in the UI, you need to take care of this additionally (updateEntity - in terms of filling links - works asynchronously and you should not wait for its execution).  In the <b>ZKRefList</b> handler <b>,</b> this can be done in the setter, as already mentioned: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/efd/e42/efe/efde42efedaa4f4fb3123fbb0d42cd92.png"></div><br>  Here the following happens: <br><br>  When receiving * -to-many connections (as a result of calling updateEntity with the flag fetchReferences = true), an array of Teacher objects gets into the setter teacherReferences.  In the main thread, we update this list at the root NSManagedObject, and then call the UI update methods. <br><br>  Mapping connections * -to-one (an array of references containing the name of the properties-links to other entities ZKEntity) does not imply handlers (get / set), so if you want to track the formation of these connections, you need to resort to a similar method - as keys in the references array to specify handlers and override their getter and setter ‚Äî either use ReactiveCocoa or other means to monitor the properties. <br><br>  Working with links seems rich in nuances, and this is true, but these nuances are a natural consequence of the binding and automation of the work of two systems - CoreData and CloudKit. <br><br>  If you need to have more direct control over linking, updating UI, or other sync-related processes, you can combine the ZenCloudKit and the native CloudKit API at your own discretion.  In the zenSyncDidFinish method, arrays of CKRecord objects are passed, which, in addition to properties, contain CKReference objects.  This means that you can customize the parsing, as well as manually download the objects that you need. <br><br>  This completes the ZenCloudKit setup. <br><br><h3>  Nuances of use </h3><br>  The standard way to access the framework functionality is through an instance (singleton) of the ZenCloudKit controller: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ffc/c94/d57/ffcc94d572654ef29d41638da1e1c6e5.png"></div><br>  As arguments, all the same instances and classes of ZKEntity. <br>  The abbreviated version (through the .iCloud proxy class) is currently available only in Swift. <br><br><h3>  Push notifications </h3><br>  Handling push notifications can also be transferred to ZenCloudKit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/834/089/798/83408979812346a791598baf060c682b.png"></div><br>  The result of his work is a call to the zenSyncDIdFinish delegate method, with one of the three filled arrays (newRecords, updatedRecords, deletedRecords), which automatically leads to updating the database and the UI (if you took care of this in the body of this function).  Let me remind you that the usual scenario of handling push notifications involves a number of fairly monotonous actions: checking the type of notification (CKNotification), the reason for the notification (queryNotificationReason), parsing - determining the entity to which the notification relates, and only then calling the appropriate handler.  ZenCloudKit takes it all on itself. <br><br><h3>  Synchronization lock </h3><br>  Sooner or later, your application code will be filled with .save () or .delete () instructions in different places.         (    ),            - ,       : <br><br><img src="https://habrastorage.org/files/323/cd3/d3e/323cd3d3eaba47f8b3a7a212df0940e1.png"><br><br>  ,   ,   false.     . <br><br><h3>  </h3><br>      . /  debugMode        (  true): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4dc/44a/76c/4dc44a76c223471a810d152ed98f3325.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/55a/9dc/627/55a9dc627add455ebcb1d014a0db256e.png"></div><br>  : <br><br>      ZenCloudKit         Record Type,  query-   modifiedDate (CKRecord).       .  ,          Device  DeleteQueue.      ,      .  ‚Äî    ‚Äî     -   ,       (   ‚Äî  ).  ,        ,   DeleteQueue   .     ,             . <br><br><h3>  Security </h3><br>      ZenCloudKit  . <br>     CloudKit     : (1)     ,    ‚Äî (2) .  ,         15   (       ),       .     CloudKit    :       (fetch),  nil,          (   ).  ,   ,           CloudKit.    (. GCD),  ,   CloudKit API    ,    ,      QoS  CKQueryOperation. <br><br>        ZenCloudKit,           ZKEntity,       .   15  ‚Äî  3    ( 5 ),     , ‚Äú  ‚Äù      5 ,  - .        (DoS). <br><br><h3>  Conclusion </h3><br>         .         ,     .    ‚Äî         CloudKit,      CoreData.              . <br><br>        (,         ,    ).    : ,      CKAssets (    ). <br><br>       -   .        ZenCloudKit     -   ,             . </div><p>Source: <a href="https://habr.com/ru/post/326050/">https://habr.com/ru/post/326050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326036/index.html">PHP Digest number 106 - the latest news, materials and tools (March 26 - April 9, 2017)</a></li>
<li><a href="../326040/index.html">php-cs-fixer: Writing Your Fixer</a></li>
<li><a href="../326044/index.html">Tools for the remote development team</a></li>
<li><a href="../326046/index.html">Everything new is well forgotten old</a></li>
<li><a href="../326048/index.html">Games for HTC Vive that can already be played</a></li>
<li><a href="../326052/index.html">The book "Swift. Basics of developing applications for iOS and macOS. 3rd ed. supplemented and revised "</a></li>
<li><a href="../326054/index.html">Azure microservice application</a></li>
<li><a href="../326056/index.html">The dark side of using CSS polyfills</a></li>
<li><a href="../326058/index.html">Not only cash desk: how the IT infrastructure of modern stores is arranged</a></li>
<li><a href="../326060/index.html">How to make Telegram and Telephony even faster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>