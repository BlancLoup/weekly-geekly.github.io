<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deep immersion in the WPF rendering system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The translation of this article pushed me to the discussion of the posts ‚ÄúWhy is WPF alive?‚Äù And ‚ÄúSeven years of WPF: what has changed?‚Äù The original ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deep immersion in the WPF rendering system</h1><div class="post__text post__text-html js-mediator-article"> <i>The translation of this article pushed me to the discussion of the posts <a href="http://habrahabr.ru/company/geekfamily/blog/253341/">‚ÄúWhy is WPF alive?‚Äù</a> And <a href="http://habrahabr.ru/post/165273/">‚ÄúSeven years of WPF: what has changed?‚Äù</a> The original article was written in 2011, when Silverlight was still alive, but the WPF information has not lost its relevance.</i> <br><br>  At first I did not want to publish this article.  It seemed to me that it was impolite - one should speak either well or nothing about the dead.  But a few conversations with people whose opinion I really appreciate made me change my mind.  Having put a lot of effort into the Microsoft platform, developers need to be aware of the internal features of its work, so that, having come to a dead end, they can understand the causes of the incident and formulate suggestions to the platform developers more accurately.  I think WPF and Silverlight are good technologies, but ... If you‚Äôve followed my Twitter for the past few months, then some of the comments may have seemed to you to be a baseless attack on the performance of WPF and Silverlight.  Why did I write this?  After all, in the end, I have invested thousands and thousands of hours of my own time over many years, promoting the platform, developing libraries, helping community members, and so on.  I am definitely personally interested.  I want the platform to be better. <br><br><img src="https://habrastorage.org/files/82d/b5e/62d/82db5e62d4524237975836e5b2bceea9.png"><br><a name="habracut"></a><br>  <b>Performance, Productivity, Productivity</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When developing, addictive, user-friendly, user interface, performance is most important to you.  Without it, everything else is meaningless.  How many times have you had to simplify the interface because it lags?  How many times have you come up with a ‚Äúnew, revolutionary user interface model‚Äù that you had to throw in the trash because the existing technology did not allow it to be implemented?  How many times have you told clients that you need a 2.4 GHz quad-core processor to complete the work?  Customers repeatedly asked me why on WPF and Sliverlight they could not get the same smooth interface as in the iPad application, even with four times more powerful PC.  These technologies may be suitable for business applications, but they are clearly not suitable for next-generation user applications. <br><br>  <b>But WPF uses hardware acceleration.</b>  <b>Why do you think it is ineffective?</b> <br><br>  WPF does use hardware acceleration and some aspects of its internal implementation are very good.  Unfortunately, the efficiency of using the GPU is much lower than it could be.  The WPF rendering system uses very brute force.  I hope to explain this statement below. <br><br>  <b>Analyzing a single pass rendering WPF</b> <br><br>  To analyze performance, we need to understand what is actually happening inside WPF.  For this, I used the PIX, Direct3D profiler, shipped with the DirectX SDK.  PIX runs your D3D application and injects a series of interceptors into all Direct3D calls for analysis and monitoring. <br><br>  I created a simple WPF application in which two ellipses are displayed from left to right.  Both ellipses are of the same color (# 55F4F4F5) with a black outline. <br><br><img src="https://habrastorage.org/files/b19/ac3/4f5/b19ac34f5da441a5b997082d8a0c0b74.png"><br><br>  <b>And how does WPF render it?</b> <br><br>  First of all, WPF clears (# ff000000) the dirty area it is going to redraw.  Dirty areas are needed to reduce the number of pixels sent to the final merge stage (output merger stage) in the GPU pipeline.  We can even assume that this reduces the amount of geometry that will have to be re-tessellated, more on this later.  After cleaning the dirty area, our frame looks like this <br><br><img src="https://habrastorage.org/files/87e/e27/303/87ee273035f94379b3667392347800c6.png"><br><br>  After that, WPF does something incomprehensible.  First, it fills the vertex buffer (vertex buffer), then draws something that looks like a rectangle on top of a dirty area.  Now the frame looks like this (exciting, isn't it?): <br><br><img src="https://habrastorage.org/files/8d2/c54/d38/8d2c54d389a44a48a3bb32c6fe913c8b.png"><br><br>  After that, it tessellates an ellipse on the CPU.  Tessellation, as you may already know, is the transformation of the geometry of our 100x100 ellipse into a set of triangles.  This is done for the following reasons: 1) triangles are a natural rendering unit for a GPU 2) an ellipse tessellation can result in just a few hundred triangles, which is much faster than rasterizing 10,000 pixels with antialiasing by means of CPU (which makes Silverlight).  The screenshot below shows what a tessellation looks like.  Readers familiar with 3D graphics may have noticed that these are triangle stripes.  Note that in the tessellation, the ellipse looks unfinished.  As a next step, WPF takes the tessellation, loads it into the vertex buffer of the GPU and makes another draw call using the pixel shader, which is configured to use the ‚Äúbrush‚Äù configured in XAML. <br><br><img src="https://habrastorage.org/files/7f4/5b5/27e/7f45b527e0c849b6b5d719a9a65e4c01.png"><br><br>  Remember that I noted the incompleteness of an ellipse?  It really is.  WPF generates what Direct3D programmers know as a ‚Äúline list‚Äù (line list).  The GPU understands the lines as well as the triangles.  WPF fills the vertex buffer with these lines and guess what?  Correctly, performs another draw call?  The set of lines looks like this: <br><br><img src="https://habrastorage.org/files/5dd/3ca/afe/5dd3caafeb344d1fa474bb8faeff9d3a.png"><br><br>  Now WPF has finished drawing an ellipse, right?  Not!  You forgot about the contour!  A contour is also a collection of lines.  It is also sent to the vertex buffer and executes another draw call.  The contour looks like this <br><br><img src="https://habrastorage.org/files/a6f/2b5/c86/a6f2b5c863ae45a4bbd21eac1fd83675.png"><br><br>  At this point, we drew one ellipse, so our frame looks like this: <br><br><img src="https://habrastorage.org/files/160/52c/e93/16052ce9326e4123a1d3b1b4bb575176.png"><br><br>  The entire procedure must be repeated for each ellipse on the stage.  In our case, two times. <br><br>  <b>I did not understand.</b>  <b>Why is it bad for performance?</b> <br><br>  The first thing you could notice is that for rendering one ellipse, we needed three draw calls and two calls to the vertex buffer.  To explain the inefficiency of this approach, I will have to tell you a little about how the GPU works.  To begin with, modern GPUs work VERY FAST and asynchronously with the CPU.  But for some operations, expensive switching from user mode to kernel mode (user-mode to kernel mode transitions) occurs.  When filling the vertex buffer it should be blocked.  If the buffer is currently used by the GPU, this forces the GPU to synchronize with the CPU and drastically reduces performance.  A vertex buffer is created with D3DUSAGE_WRITEONLY |  D3DUSAGE_DYNAMIC, but when it is locked (which happens often), D3DLOCK_DISCARD is not used.  This can cause a loss of speed (synchronization of the GPU and CPU) in the GPU, if the buffer is already used by the GPU.  In the case of a large number of draw calls, we have a high probability of getting a lot of transitions to kernel mode and a big load in the drivers.  To improve performance, we need to send as much work to the GPU as possible, otherwise your CPU will be busy and the GPU will be idle.  Do not forget that in this example it was only one frame.  A typical WPF interface tries to output 60 frames per second!  If you have ever tried to figure out why your rendering thread loads the processor so much, then you most likely found that most of the load comes from your GPU driver. <br><br>  <b>And what about cached construction (Cached Composition)?</b>  <b>After all, it improves performance!</b> <br><br>  Without a doubt, raises.  Cached construction or BitmapCache caches objects into the GPU texture.  This means that your CPU does not need to peresteselirovat, and the GPU does not need to be re-rasterized.  When performing one rendering pass, WPF simply uses the texture from the video memory, increasing performance.  Here is the BitmapCache ellipse: <br><br><img src="https://habrastorage.org/files/e00/0bd/f23/e000bdf23c7e4dd69e15832411a06906.png"><br><br>  But WPF has dark sides in this case too.  For each BitmapCache, it performs a separate draw call.  I will not lie, sometimes you really need to perform a draw call to render a single object (visual).  Anything can happen.  But let's imagine a scenario in which we have a &lt;Canvas /&gt; with 300 animated BitmapCached-ellipses.  The advanced system will understand that it needs to render 300 textures and they are all z-ordered (z-ordered) one after the other.  After that, it will collect their packets of the maximum size, as I recall, the DX9 can receive up to <a href="http://msdn.microsoft.com/en-us/library/bb172922(v%3Dvs.85).aspx">16 sampling inputs at a time</a> .  In this case, we get 16 draw calls instead of 300, which will noticeably reduce the load on the CPU.  In terms of 60 frames per second, we will reduce the load from 18,000 draw calls per second to 1125. In Direct 3D 10, the number of incoming items is <a href="http://msdn.microsoft.com/en-us/library/cc308052(v%3Dvs.85).aspx">much higher</a> . <br><br>  <b>Okay, I read this far.</b>  <b>Tell me how WPF uses pixel shaders!</b> <br><br>  WPF has an extensible pixel shader API and some built-in effects.  This allows developers to add truly unique effects to their user interface.  When Directing a Shader to an existing texture, Direct 3D typically uses an intermediate rendering target (intermediate rendertarget) ... after all, you cannot use the texture from which you are writing as a sample!  WPF also does this, but unfortunately it creates a completely new EACH FRAME texture and destroys it upon completion.  Creating and destroying GPU resources is one of the slowest things you can do when processing each frame.  I usually do not do this even with the allocation of system memory of similar volume.  Reusing these intermediate surfaces could achieve a very significant increase in productivity.  If you have ever wondered why your hardware-accelerated shaders put a significant load on the CPU, now you know the answer. <br><br>  <b>But maybe this is the way to render vector graphics on a GPU?</b> <br><br>  Microsoft has put a lot of effort into fixing these problems, unfortunately this was done not in WPF, but in Direct 2D.  Look at this group of 9 ellipses rendered by Direct2D: <br><br><img src="https://habrastorage.org/files/4f1/510/c9b/4f1510c9ba0740a3acba830c28db5de3.png"><br><br>  Remember how many render calls WPF needed to render a <i>single</i> ellipse with an outline?  What about vertex buffer locks?  Direct2D does this for ONE draw call.  Tessellation looks like this <br><br><img src="https://habrastorage.org/files/de8/264/e9b/de8264e9b57e4e6ea1dc4c5f1a61e3c9.png"><br><br>  Direct 2D tries to draw as much as possible at a time, maximizing the use of the GPU and minimizing CPU usage.  Read Insights: Direct2D Rendering at the <a href="http://msdn.microsoft.com/en-us/magazine/dd861344.aspx">end of this page</a> ; Mark Mark Lawrence explains many of the internal details of Direct 2D.  You may notice that despite the speed of Direct 2D there are even more areas where it will be improved in the second version.  It is possible that version 2 Direct 2D will use DX11 tessellation hardware acceleration. <br><br>  Looking at the API Direct 2D, it can be assumed that a significant part of the code was taken from WPF.  Watch this <a href="http://channel9.msdn.com/Blogs/Charles/Michael-Wallent-Advent-and-Evolution-of-WPF">old video about Avalon</a> , in which Michael Wallent talks about the development of a GDI replacement based on this technology.  It has a very similar geometric API and terminology.  Inside it is similar, but very optimized and modern. <br><br>  <b>What about Silverlight?</b> <br><br>  I could do Silverlight, but that would be redundant.  The rendering performance in Silverlight is also low, but the reasons are different.  It uses CPU for rendering (even for shaders, as far as I remember, they are partially written in assembler), but the CPU is at least 10-30 times slower than the GPU.  This leaves you with far less processor power for rendering the user interface and even less for the logic of your application.  Its hardware acceleration is very poorly developed and almost exactly repeats the cached construction of WPF and behaves in a similar way, making a draw call for each object with BitmapCache (BitmapCached visual). <br><br>  <b>And what should we do now?</b> <br><br>  This question is very often asked to me by clients who have encountered problems with WPF and Silverlight.  Unfortunately, I do not have a definite answer.  Those who can, make their own frameworks, tailored to their specific needs.  The rest have to accept, since there are no alternatives to WPF and SL in their niches.  If my clients are just developing business applications, then they have not so many problems with speed and they just enjoy the performance of programmers.  The real problems for those who want to build really interesting interfaces (that is, consumer apps or kiosk apps). <br><br>  <i>After the start of the translation, news appeared <a href="http://habrahabr.ru/company/geekfamily/blog/255263/">about the planned performance optimization and the use of DX10-11 in WPF 4.6.</a></i>  <i><a href="http://habrahabr.ru/company/geekfamily/blog/255263/">Whether the problems described in the article from the news will be solved is not entirely clear.</a></i> <i><br></i> <br><br>  Original article: <a href="https://jeremiahmorrill.wordpress.com/2011/02/14/a-critical-deep-dive-into-the-wpf-rendering-system/">A Critical Deep Dive into the WPF Rendering System</a> </div><p>Source: <a href="https://habr.com/ru/post/255683/">https://habr.com/ru/post/255683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255667/index.html">We do the IR remote control for the camera</a></li>
<li><a href="../255669/index.html">Bubot: Scout - a machine with control through a web interface without a line of code</a></li>
<li><a href="../255675/index.html">Fuel cells as a reliable source of energy for the data center?</a></li>
<li><a href="../255679/index.html">Webinar recording: ‚ÄúVirtualization based on Hyper-V 3.0 and Windows Server 2012R2 Virtual Desktop Infrastructure‚Äù</a></li>
<li><a href="../255681/index.html">The main vulnerabilities of corporate information systems in 2014: web applications, passwords and employees</a></li>
<li><a href="../255685/index.html">Secrets of the Madrid court. Part II: Developer Material Motivation System</a></li>
<li><a href="../255687/index.html">Signal detection in noise</a></li>
<li><a href="../255689/index.html">SSL certificates, SHA-1 and nic.ru</a></li>
<li><a href="../255691/index.html">Sublime Text 3 plugin "Symfony2 Override" for quick redefinition of part of bundles</a></li>
<li><a href="../255693/index.html">JavaScript for professional web developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>