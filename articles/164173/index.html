<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Coroutines in PHP and working with non-blocking functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the biggest innovations in PHP 5.5 will be support for generators and corutin (coroutines). Generators have already been sufficiently covered i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Coroutines in PHP and working with non-blocking functions</h1><div class="post__text post__text-html js-mediator-article">  One of the biggest innovations in PHP 5.5 will be support for generators and corutin (coroutines).  Generators have already been sufficiently covered in the <a href="http://de2.php.net/manual/en/language.generators.overview.php">documentation</a> and in several other posts (for example, in <a href="http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html">this</a> or <a href="http://sheriframadan.com/2012/10/test-drive-php-5-5-a-sneak-peek/">this</a> ).  Coroutines received very little attention.  It is much more powerful, but also more difficult to understand and explain, a tool. <br><br>  In this article, I will show you how to implement a task scheduler using corutin so that you understand what you can do with them and how to use them.  Let's start with a few introductory words.  If you think that you already know quite well how generators and corutines work, then you can immediately go to the section ‚ÄúCollaborative multitasking‚Äù. <br><br><h4>  Generators </h4><br>  The essence of the generator is that it is a function that returns not just one value, but a <em>sequence of values</em> , where each value is thrown one after the other.  Or, in other words, generators allow you to implement an iterator, without unnecessary code. <br><a name="habracut"></a><br>  A very simple example is the <code>xrange()</code> function: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xrange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($start, $end, $step = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = $start; $i &lt;= $end; $i += $step) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $i; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (xrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $num) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $num, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This function does the same as the built-in PHP <code>range()</code> .  The only difference is that <code>range()</code> would give you an array of a million numbers, and <code>xrange()</code> will return an iterator that will throw out these numbers, but will never create an array with all of them. <br><br>  The advantages of this approach should be obvious.  This way you can work with very large data sets without loading them all into memory.  You can even work with <em>endless</em> data streams. <br><br>  All this can also be done without generators by creating a class implementing interface <code>Iterator</code> .  Generators simply make this (much) easier to do, because you don't need to implement five different methods for each iterator. <br><br><h4>  Generators as interruptible functions </h4><br>  To move from generators to corintes, it is important to understand how they are built from the inside: generators are interruptible functions, in which the keyword <code>yield</code> is used for interruptions. <br><br>  Returning to the previous example, when you call <code>xrange(1, 1000000)</code> , nothing in the body of the <code>xrange</code> function will actually be called.  Instead, PHP will simply return a <code>Generator</code> class object that implements the <code>Iterator</code> interface: <br><pre> <code class="hljs xml"><span class="php"><span class="hljs-meta"><span class="php"><span class="hljs-meta">&lt;?php</span></span></span><span class="php"> $range = xrange(</span><span class="hljs-number"><span class="php"><span class="hljs-number">1</span></span></span><span class="php">, </span><span class="hljs-number"><span class="php"><span class="hljs-number">1000000</span></span></span><span class="php">); var_dump($range); </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">// object(Generator)#1 var_dump($range instanceof Iterator); // bool(true)</span></span></span></span></code> </pre> <br><br>  The code will be run only when you run certain iterator methods.  For example, if you call <code>$range-&gt;rewind()</code> the <code>xrange()</code> function code will be executed before the first <code>yield</code> .  In this case, this means that <code>$i = $start</code> will be executed first and then <code>yield $i</code> .  Whatever we pass to <code>yield</code> , this can be obtained by calling <code>$range-&gt;current()</code> . <br><br>  To continue executing the code, you must call <code>$range-&gt;next()</code> .  This again makes the generator execute the code before the next <code>yield</code> .  Thus, using successive calls to <code>next()</code> and <code>current()</code> , you can get all the values ‚Äã‚Äãfrom the generator until it reaches the point where the code just ends.  In the case of <code>xrange()</code> this will happen when <code>$i</code> reaches <code>$end</code> .  In this case, the execution thread reaches the end of the function, leaving no more code.  After this happens, <code>valid()</code> will return <code>false</code> and the iteration will stop. <br><br><h4>  Coroutines </h4><br>  The main thing is that the corutines add to the above functionality - it is the ability to send values ‚Äã‚Äãto the generator.  This makes the familiar monologue of the generator a full-fledged dialogue, where the caller may also say something to the generator. <br><br>  Values ‚Äã‚Äãare passed to corortine by calling the <code>send()</code> method instead of <code>next()</code> .  An example of how this works is this Korutin: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($fileName)</span></span></span><span class="hljs-function"> </span></span>{ $fileHandle = fopen($fileName, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { fwrite($fileHandle, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } } $logger = logger(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/log'</span></span>); $logger-&gt;send(<span class="hljs-string"><span class="hljs-string">'Foo'</span></span>); $logger-&gt;send(<span class="hljs-string"><span class="hljs-string">'Bar'</span></span>);</code> </pre> <br><br>  As you can see, here, the <code>yield</code> not as a statement (like <code>return</code> or <code>echo</code> ), but as an expression, that is, it returns some value.  It will return what was sent via <code>send()</code> .  In this example, <code>yield</code> first returns <code>"Foo"</code> , and then <code>"Bar"</code> . <br><br>  In this example, it was introduced how <code>yield</code> can act as a simple recipient.  But you can also combine both types of usage, so you can both send and receive values.  Here is an example of how this works: <br><pre> <code class="hljs perl">function gen() { $ret = (yield <span class="hljs-string"><span class="hljs-string">'yield1'</span></span>); var_dump($ret); $ret = (yield <span class="hljs-string"><span class="hljs-string">'yield2'</span></span>); var_dump($ret); } $gen = gen(); var_dump($gen-&gt;current()); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> string(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-string"><span class="hljs-string">"yield1"</span></span> var_dump($gen-&gt;<span class="hljs-keyword"><span class="hljs-keyword">send</span></span>(<span class="hljs-string"><span class="hljs-string">'ret1'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> string(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"ret1"</span></span> (the first var_dump in gen) // string(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-string"><span class="hljs-string">"yield2"</span></span> (the var_dump of the -&gt;<span class="hljs-keyword"><span class="hljs-keyword">send</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value) var_dump($gen-&gt;<span class="hljs-keyword"><span class="hljs-keyword">send</span></span>(<span class="hljs-string"><span class="hljs-string">'ret2'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> string(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"ret2"</span></span> (again from within gen) // NULL (the <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value of -&gt;<span class="hljs-keyword"><span class="hljs-keyword">send</span></span>())</code> </pre> <br><br>  The exact order of the output may seem a bit difficult to understand at first glance, so re-read the code and try to run it yourself to figure out why everything happens in that order.  There are two things that I would like to draw your attention to: first, the use of parentheses around <code>yield</code> is not an accident.  We need these brackets for technical reasons (I was even thinking of adding a throw-out exception to direct assignment).  Secondly, you should have noticed that <code>current()</code> was used without calling <code>rewind()</code> .  <code>rewind()</code> , in fact, is then invoked implicitly. <br><br><h4>  Joint multitasking </h4><br>  If, reading the example of the function <code>logger()</code> , you thought, ‚ÄúWhy would I use corutin for this?  Why not make an ordinary class for this? ‚Äù, Then you were absolutely right.  That example only demonstrates how to use it, but there is no reason for it to use the korutina.  As mentioned above, in the introduction, coroutines are a very powerful thing, but their use is very rare and often very complicated, which makes the task of inventing simple and non-contrived examples rather complicated. <br><br>  I decided to show you the implementation of collaborative multitasking using korutiny.  The bottom line is that we have several tasks that need to be run in parallel.  But the processor (approx. Lane spherical and in vacuum) can perform only one task at a time.  Thus, the processor needs to switch between different tasks and give each one a "little work". <br><br>  ‚ÄúJoint‚Äù is this multitasking because it implies a voluntary transfer of control of execution to the scheduler so that it can start another task.  There is also preemptive multitasking, where the planner itself can interrupt the task.  Joint multitasking was used in earlier versions of Windows (before Win95) and Mac OS, but then they switched to preemptive.  The reason is obvious - if you rely on any program to voluntarily give up control flow, then any program can simply occupy the entire CPU. <br><br>  Now you should already see the connection between the corortists and the task scheduler: <code>yield</code> allows you to interrupt the task yourself, in order to give the control flow to the scheduler and it could start another task.  In addition, <code>yield</code> can be used to communicate the task with the scheduler. <br><br>  In our case, the task will be a thin wrapper around the function generator: <br><pre> <code class="hljs php"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $taskId; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $coroutine; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $sendValue = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $beforeFirstYield = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($taskId, Generator $coroutine)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;taskId = $taskId; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;coroutine = $coroutine; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTaskId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;taskId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSendValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($sendValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;sendValue = $sendValue; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;beforeFirstYield) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;beforeFirstYield = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;coroutine-&gt;current(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $retval = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;coroutine-&gt;send(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;sendValue); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;sendValue = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $retval; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;coroutine-&gt;valid(); } }</code> </pre> <br><br>  Each task will have its own identifier ( <code>taskId</code> ).  Using the <code>setSendValue()</code> method, you can specify which value to send to the task on the next run (you will find out what you need to do later).  The <code>run()</code> method is really just calling the <code>send()</code> method of cortutina. <br>  To understand why we need an additional flag <code>beforeFirstYield</code> , look at the following code: <br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function"> '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function"> '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">'; } $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var_dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($gen-&gt;send('something')</span></span></span><span class="hljs-function">); //   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">,   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function">    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> //       : $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-function">-&gt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var_dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($gen-&gt;send('something')</span></span></span><span class="hljs-function">); // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   )</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> //    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( var_dump-  )</span></span></span><span class="hljs-function">. //      </span></span></code> </pre> <br><br>  With the help of <code>beforeFirstYield</code> we will know if the first yield has already been returned. <br><br>  The scheduler will now have to do a little more than just go through all the tasks: <br><pre> <code class="hljs bash">class Scheduler { protected <span class="hljs-variable"><span class="hljs-variable">$maxTaskId</span></span> = 0; protected <span class="hljs-variable"><span class="hljs-variable">$taskMap</span></span> = []; // taskId =&gt; task protected <span class="hljs-variable"><span class="hljs-variable">$taskQueue</span></span>; public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskQueue = new SplQueue(); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> newTask(Generator <span class="hljs-variable"><span class="hljs-variable">$coroutine</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$tid</span></span> = ++<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;maxTaskId; <span class="hljs-variable"><span class="hljs-variable">$task</span></span> = new Task(<span class="hljs-variable"><span class="hljs-variable">$tid</span></span>, <span class="hljs-variable"><span class="hljs-variable">$coroutine</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskMap[<span class="hljs-variable"><span class="hljs-variable">$tid</span></span>] = <span class="hljs-variable"><span class="hljs-variable">$task</span></span>; <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;schedule(<span class="hljs-variable"><span class="hljs-variable">$task</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$tid</span></span>; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> schedule(Task <span class="hljs-variable"><span class="hljs-variable">$task</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskQueue-&gt;enqueue(<span class="hljs-variable"><span class="hljs-variable">$task</span></span>); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskQueue-&gt;isEmpty()) { <span class="hljs-variable"><span class="hljs-variable">$task</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskQueue-&gt;dequeue(); <span class="hljs-variable"><span class="hljs-variable">$task</span></span>-&gt;run(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$task</span></span>-&gt;isFinished()) { <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span>(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskMap[<span class="hljs-variable"><span class="hljs-variable">$task</span></span>-&gt;getTaskId()]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;schedule(<span class="hljs-variable"><span class="hljs-variable">$task</span></span>); } } } }</code> </pre> <br><br>  The <code>newTask()</code> method creates a new task and puts it in the <code>taskMap</code> .  Moreover, it adds it to the <code>taskQueue</code> .  The <code>run()</code> method then goes through this queue and runs tasks.  If the task is completed, it is deleted, otherwise added to the end of the queue. <br><br>  Let's try a scheduler with two simple (and rather meaningless) tasks: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; ++$i) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"This is task 1 iteration $i.\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; ++$i) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"This is task 2 iteration $i.\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>; } } $scheduler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scheduler; $scheduler-&gt;newTask(task1()); $scheduler-&gt;newTask(task2()); $scheduler-&gt;run();</code> </pre> <br><br>  Both tasks simply output the message, and give the control flow back to the scheduler.  Here is what will be displayed: <br><pre>  This is task 1 iteration 1.
 This is task 2 iteration 1.
 This is task 1 iteration 2.
 This is task 2 iteration 2.
 This is task 1 iteration 3.
 This is task 2 iteration 3.
 This is task 1 iteration 4.
 This is task 2 iteration 4.
 This is task 1 iteration 5.
 This is task 2 iteration 5.
 This is task 1 iteration 6.
 This is task 1 iteration 7.
 This is task 1 iteration 8.
 This is task 1 iteration 9.
 This is task 1 iteration 10. </pre><br><br><h4>  Scheduler Interaction </h4><br>  So, our planner works and we can move on to the next item on the agenda: the interaction between tasks and the planner.  We will use the same method that processes use to communicate with the operating system: system calls (syscall, syscol).  We need syscola, because the operating system is at a different level of privilege than the processes themselves.  Therefore, in order to do some actions that require greater privileges (for example, to kill other processes) there must be a way to give control to the kernel so that it can perform those actions.  From the inside, this is implemented with interrupt instructions. <br><br>  Our scheduler will adhere to this architecture: instead of passing the scheduler to a task (which can do anything with it), we will interact using syscols passed through <code>yield</code> .  In this case, <code>yield</code> will act both as a breaker and as a way to transfer information (and get) to the scheduler. <br><br>  To introduce siskol, I will use a small <code>callable</code> : <br><pre> <code class="hljs php"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SystemCall</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $callback; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;callback = $callback; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span></span>{ $callback = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;callback; <span class="hljs-comment"><span class="hljs-comment">// Can't call it directly in PHP :/ return $callback($task, $scheduler); } }</span></span></code> </pre> <br><br>  She will behave like any other <code>callable</code> , but will take a task and a scheduler into the arguments.  To work with this, we need to slightly modify the <code>run()</code> method of the scheduler: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;taskQueue-&gt;isEmpty()) { $task = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;taskQueue-&gt;dequeue(); $retval = $task-&gt;run(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($retval <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> SystemCall) { $retval($task, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($task-&gt;isFinished()) { <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;taskMap[$task-&gt;getTaskId()]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;schedule($task); } } }</code> </pre> <br><br>  Our first syscol just returns the task id: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTaskId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemCall(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span></span>{ $task-&gt;setSendValue($task-&gt;getTaskId()); $scheduler-&gt;schedule($task); }); }</code> </pre> <br><br>  This is because we set the value to send and set the task back to the scheduler.  For syscols, the scheduler does not add tasks to the queue automatically, we need to do this manually (you will find out why later). <br>  Using this new siscol, we can rewrite the previous example: <br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($max)</span></span></span><span class="hljs-function"> { $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tid</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(yield getTaskId()</span></span></span><span class="hljs-function">); // &lt;-- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">here</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syscall</span></span></span><span class="hljs-function">! </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($i = 1; $i &lt;= $max; ++$i)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echo</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tid</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iteration</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">.\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">"; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function">; } } $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduler</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scheduler</span></span></span><span class="hljs-function">; $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduler</span></span></span><span class="hljs-function">-&gt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task(10)</span></span></span><span class="hljs-function">); $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduler</span></span></span><span class="hljs-function">-&gt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task(5)</span></span></span><span class="hljs-function">); $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduler</span></span></span><span class="hljs-function">-&gt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><br>  This code will give us the same output as the previous example.  Another pair of syscols to create new and kill tasks: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Generator $coroutine)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemCall( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($coroutine)</span></span></span><span class="hljs-function"> </span></span>{ $task-&gt;setSendValue($scheduler-&gt;newTask($coroutine)); $scheduler-&gt;schedule($task); } ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($tid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemCall( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($tid)</span></span></span><span class="hljs-function"> </span></span>{ $task-&gt;setSendValue($scheduler-&gt;killTask($tid)); $scheduler-&gt;schedule($task); } ); }</code> </pre> <br><br>  For the <code>killTask</code> function <code>killTask</code> we need an additional method in the scheduling: <br><pre> <code class="hljs bash">public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> killTask(<span class="hljs-variable"><span class="hljs-variable">$tid</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isset(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskMap[<span class="hljs-variable"><span class="hljs-variable">$tid</span></span>])) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span>(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskMap[<span class="hljs-variable"><span class="hljs-variable">$tid</span></span>]); //        , //      ,       foreach (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskQueue as <span class="hljs-variable"><span class="hljs-variable">$i</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$task</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$task</span></span>-&gt;getTaskId() === <span class="hljs-variable"><span class="hljs-variable">$tid</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span>(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;taskQueue[<span class="hljs-variable"><span class="hljs-variable">$i</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><br>  A small script to test this functionality: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">childTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $tid = (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getTaskId()); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Child task $tid still alive!\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $tid = (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getTaskId()); $childTid = (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> newTask(childTask())); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt;= <span class="hljs-number"><span class="hljs-number">6</span></span>; ++$i) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Parent task $tid iteration $i.\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> killTask($childTid); } } $scheduler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scheduler; $scheduler-&gt;newTask(task()); $scheduler-&gt;run();</code> </pre> <br><br>  The output will be as follows: <br><pre>  Parent task 1 iteration 1.
 Child task 2 still alive!
 Parent task 1 iteration 2.
 Child task 2 still alive!
 Parent task 1 iteration 3.
 Child task 2 still alive!
 Parent task 1 iteration 4.
 Parent task 1 iteration 5.
 Parent task 1 iteration 6. </pre><br><br>  The child task is killed after three iterations, then the messages ‚ÄúChild task still alive!‚Äù Are completed.  It is worth noting that this is not a real parent and child, since the child task can continue to be executed even when the parent has already completed.  Or a child may even kill the parent.  We could modify the scheduler to get a normal relationship between parent and child, but not in this article. <br><br>  There are still quite a lot of different types of calls that can be implemented, such as <code>wait</code> (wait until the task completes completely), <code>exec</code> (which sets what task you need to perform now) and <code>fork</code> (create a clone of the task).  The cloning is a pretty cool feature and you can implement it with the corutines, since they support cloning. <br><br><h4>  Non-blocking interaction </h4><br>  The really cool application of our scheduler is obviously a web server.  There may be one task listening to the socket for new connections and each time a new connection is made, a new task will be created to handle this connection. <br><br>  The difficulty lies in the fact that operations on sockets, such as reading data in PHP blocking, that is, PHP will wait until the client completes sending data.  For a web server, this is obviously not good at all: it means that it can only process one request at a time. <br><br>  As a solution, we need to ask the socket if it is ‚Äúready‚Äù before reading or writing data to it.  To find out which sockets are ready to send or receive data, we will use the <code>stream_select()</code> function. <br><br>  To begin, let's add a couple of new syscols that will send a specific socket to wait for either read or write: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemCall( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ $scheduler-&gt;waitForRead($socket, $task); } ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemCall( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ $scheduler-&gt;waitForWrite($socket, $task); } ); }</code> </pre> <br><br>  These syscol are just proxies for the corresponding scheduler methods: <br><pre> <code class="hljs markdown"><span class="xml"><span class="php"><span class="hljs-meta"><span class="xml"><span class="php"><span class="hljs-meta">&lt;?php</span></span></span></span><span class="xml"><span class="php"> </span></span><span class="hljs-comment"><span class="xml"><span class="php"><span class="hljs-comment">// resourceID =&gt;</span></span></span></span></span></span> [<span class="hljs-string"><span class="hljs-string">socket, tasks</span></span>] protected $waitingForRead = [<span class="hljs-string"></span><span class="hljs-string"></span>]; protected $waitingForWrite = [<span class="hljs-string"></span><span class="hljs-string"></span>]; public function waitForRead($socket, Task $task) { if (isset($this-&gt;waitingForRead[<span class="hljs-string"><span class="hljs-string">(int) $socket</span></span>])) { $this-&gt;waitingForRead[<span class="hljs-string"><span class="hljs-string">(int) $socket</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1</span></span>][<span class="hljs-string"></span><span class="hljs-string"></span>] = $task; } else { $this-&gt;waitingForRead[<span class="hljs-string"><span class="hljs-string">(int) $socket</span></span>] = [<span class="hljs-string"><span class="hljs-string">$socket, [$task</span></span>]]; } } public function waitForWrite($socket, Task $task) { if (isset($this-&gt;waitingForWrite[<span class="hljs-string"><span class="hljs-string">(int) $socket</span></span>])) { $this-&gt;waitingForWrite[<span class="hljs-string"><span class="hljs-string">(int) $socket</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1</span></span>][<span class="hljs-string"></span><span class="hljs-string"></span>] = $task; } else { $this-&gt;waitingForWrite[(int) $socket] = [$socket, [$task]]; } }</code> </pre> <br><br>  The <code>waitingForRead</code> and <code>waitingForWrite</code> simply arrays containing waiting sockets and related tasks.  The most interesting part is this method, which checks whether the sockets are ready and reschedules their tasks: <br><pre> <code class="hljs perl">protected function ioPoll($timeout) { $rSocks = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($this-&gt;waitingForRead as list($socket)) { $rSocks[] = $socket; } $wSocks = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($this-&gt;waitingForWrite as list($socket)) { $wSocks[] = $socket; } $eSocks = []; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> dummy <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream_select($rSocks, $wSocks, $eSocks, $timeout)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($rSocks as $socket) { list(, $tasks) = $this-&gt;waitingForRead[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) $socket]; unset($this-&gt;waitingForRead[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) $socket]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tasks as $task) { $this-&gt;schedule($task); } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($wSocks as $socket) { list(, $tasks) = $this-&gt;waitingForWrite[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) $socket]; unset($this-&gt;waitingForWrite[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) $socket]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tasks as $task) { $this-&gt;schedule($task); } } }</code> </pre> <br><br>  The <code>stream_select</code> function takes as input arrays of sockets waiting to be read, write, and exception (ignore the latter).  Arrays are passed by reference, and this function will leave in them only those elements whose state has changed.  After that we can go through all these arrays and reschedule all the tasks associated with these sockets. <br><br>  To perform all these actions, we will add the following method to the scheduler: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioPollTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;taskQueue-&gt;isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ioPoll(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;ioPoll(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>; } }</code> </pre> <br><br>  This task must be registered at some point, for example, you can add <code>$this-&gt;newTask($this-&gt;ioPollTask())</code> to the beginning of the <code>run()</code> method.  Then it will work just like any other task, checking the available ready-made sockets for each switch between tasks.  The <code>ioPollTask</code> method will call <code>ioPoll</code> with a zero timeout, which means stream_select will return the result immediately, without waiting. <br><br>  Only if the task queue is empty, we use <code>null</code> as a timeout, in which case <code>stream_select</code> will wait until one of the sockets is ready.  If we did not do this, we would have eaten the entire CPU (at least the kernel), since  this task would be performed in a loop, time after time, until someone would connect. <br><br>  The server itself looks pretty simple: <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Starting server at port $port...\n"</span></span>; $socket = @stream_socket_server(<span class="hljs-string"><span class="hljs-string">"tcp://localhost:$port"</span></span>, $errNo, $errStr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$socket) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>($errStr, $errNo); stream_set_blocking($socket, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> waitForRead($socket); $clientSocket = stream_socket_accept($socket, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> newTask(handleClient($clientSocket)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> waitForRead($socket); $data = fread($socket, <span class="hljs-number"><span class="hljs-number">8192</span></span>); $msg = <span class="hljs-string"><span class="hljs-string">"Received following request:\n\n$data"</span></span>; $msgLength = strlen($msg); $response = &lt;&lt;&lt;RES HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK\r Content-Type: text/plain\r Content-Length: $msgLength\r Connection: close\r \r $msg RES; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> waitForWrite($socket); fwrite($socket, $response); fclose($socket); } $scheduler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scheduler; $scheduler-&gt;newTask(server(<span class="hljs-number"><span class="hljs-number">8000</span></span>)); $scheduler-&gt;run();</code> </pre> <br><br>  It will accept connections to port 8000 and simply send in response the contents of the request itself.  It would be much more difficult to do something ‚Äúreal‚Äù (correct processing of HTTP requests is not the topic of this article). <br><br>  Now you can try this server with something like <code>ab -n 10000 -c 100 localhost:8000/</code> .  So we will send 10,000 requests, 100 of which will be sent simultaneously.  Using this benchmark, I received an average response in 10 milliseconds.  But there was a problem with some requests that were processed for a <em>very</em> long time (5 minutes in a district time), so the total throughput is only 2000 requests per second.  With higher concurrency (for example <code>-c 500</code> ), the script also works quite well, but some connections throw an error ‚ÄúConnections reset by peer‚Äù. <br><br><h4>  Corollaries delivered </h4><br>  If you start making a big system using our scheduler, you will soon come across one problem: we often divided the code, putting some pieces into separate functions and calling them.  But with coroutines this is impossible.  Imagine this code: <br><pre> <code class="hljs bash"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> echoTimes(<span class="hljs-variable"><span class="hljs-variable">$msg</span></span>, <span class="hljs-variable"><span class="hljs-variable">$max</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-variable"><span class="hljs-variable">$i</span></span> = 1; <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &lt;= <span class="hljs-variable"><span class="hljs-variable">$max</span></span>; ++<span class="hljs-variable"><span class="hljs-variable">$i</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$msg</span></span></span><span class="hljs-string"> iteration </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">\n"</span></span>; yield; } } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span></span>() { echoTimes(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, 10); // <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> foo ten <span class="hljs-built_in"><span class="hljs-built_in">times</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"---\n"</span></span>; echoTimes(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>, 5); // <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> bar five <span class="hljs-built_in"><span class="hljs-built_in">times</span></span> yield; // force it to be a coroutine } <span class="hljs-variable"><span class="hljs-variable">$scheduler</span></span> = new Scheduler; <span class="hljs-variable"><span class="hljs-variable">$scheduler</span></span>-&gt;newTask(task()); <span class="hljs-variable"><span class="hljs-variable">$scheduler</span></span>-&gt;run();</code> </pre> <br><br>  In this code, we tried to extract the coroutine from <code>task()</code> and execute it.  But it will not work.       ,        ,       <code>Generator</code> .       ,  <code>echoTimes()</code>   ,   . <br><br>     ,       .       -: <br><pre> <code class="hljs ruby">$retval = (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> someCoroutine($foo, $bar));</code> </pre> <br> -       <code>yield</code> : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"I'm return value!"</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <code>retval()</code>   ,      ,     ,   <em></em> : <br><pre> <code class="hljs php"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoroutineReturnValue</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;value = $value; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;value; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoroutineReturnValue($value); }</code> </pre> <br><br>       ( -)       (  ‚Äî   ): <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stackedCoroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Generator $gen)</span></span></span><span class="hljs-function"> </span></span>{ $stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SplStack; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { $value = $gen-&gt;current(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Generator) { $stack-&gt;push($gen); $gen = $value; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $isReturnValue = $value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CoroutineReturnValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$gen-&gt;valid() || $isReturnValue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($stack-&gt;isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $gen = $stack-&gt;pop(); $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $gen-&gt;send(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $gen-&gt;key() =&gt; $value); } }</code> </pre> <br><br>           -. ,         ,  ,  .     <code>CoroutineReturnValue</code> ,        . <br><br>        ,  <code>$this-&gt;coroutine = $coroutine;</code>    <code>Task</code> ,    <code>$this-&gt;coroutine = stackedCoroutine($coroutine);</code>  . <br><br>      - ,      ,     .     : <br><pre> <code class="hljs php"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoSocket</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $socket; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket = $socket; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> waitForRead(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> retval(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoSocket(stream_socket_accept(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket, <span class="hljs-number"><span class="hljs-number">0</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> waitForRead(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> retval(fread(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket, $size)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> waitForWrite(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket); fwrite(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket, $string); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ @fclose(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;socket); } }</code> </pre> <br><br>     : <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Starting server at port $port...\n"</span></span>; $socket = @stream_socket_server(<span class="hljs-string"><span class="hljs-string">"tcp://localhost:$port"</span></span>, $errNo, $errStr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$socket) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>($errStr, $errNo); stream_set_blocking($socket, <span class="hljs-number"><span class="hljs-number">0</span></span>); $socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoSocket($socket); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> newTask( handleClient(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $socket-&gt;accept()) ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($socket)</span></span></span><span class="hljs-function"> </span></span>{ $data = (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $socket-&gt;read(<span class="hljs-number"><span class="hljs-number">8192</span></span>)); $msg = <span class="hljs-string"><span class="hljs-string">"Received following request:\n\n$data"</span></span>; $msgLength = strlen($msg); $response = &lt;&lt;&lt;RES HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK\r Content-Type: text/plain\r Content-Length: $msgLength\r Connection: close\r \r $msg RES; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $socket-&gt;write($response); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $socket-&gt;close(); }</code> </pre> <br><br><h4>   </h4><br>   ,   ,        .         .   ,         (    )         . <br><br> ,   ,           :     <em></em>    <code>throw()</code> . <br><br>  <code>throw()</code>           ,    yield (       <code>current()</code> ): <br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Foo\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exception: {$e-&gt;getMessage()}\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Bar\n"</span></span>; } $gen = gen(); $gen-&gt;rewind(); <span class="hljs-comment"><span class="hljs-comment">// echos "Foo" $gen-&gt;throw(new Exception('Test')); // echos "Exception: Test" // and "Bar"</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a very cool thing, because </font><font style="vertical-align: inherit;">we can, for example, make it possible to throw exceptions through syscol and sub-coroutines. </font><font style="vertical-align: inherit;">For syscols, the method </font></font><code>Scheduler::run()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">needs a little change:</font></font><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($retval <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> SystemCall) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $retval($task, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { $task-&gt;setException($e); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;schedule($task); } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the class </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must handle calls </font></font><code>throw()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="hljs bash">class Task { // ... protected <span class="hljs-variable"><span class="hljs-variable">$exception</span></span> = null; public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> setException(<span class="hljs-variable"><span class="hljs-variable">$exception</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;exception = <span class="hljs-variable"><span class="hljs-variable">$exception</span></span>; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;beforeFirstYield) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;beforeFirstYield = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;coroutine-&gt;current(); } elseif (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;exception) { <span class="hljs-variable"><span class="hljs-variable">$retval</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;coroutine-&gt;throw(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;exception); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;exception = null; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$retval</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-variable"><span class="hljs-variable">$retval</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;coroutine-&gt;send(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;sendValue); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;sendValue = null; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$retval</span></span>; } } // ... }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can start throwing exceptions from syscols! </font><font style="vertical-align: inherit;">For example, for example </font></font><code>killTask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, let's throw an exception if the passed task ID is invalid:</font></font><br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($tid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemCall( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task $task, Scheduler $scheduler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($tid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($scheduler-&gt;killTask($tid)) { $scheduler-&gt;schedule($task); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidArgumentException(<span class="hljs-string"><span class="hljs-string">'Invalid task ID!'</span></span>); } } ); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now try: </font></font><br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> killTask(<span class="hljs-number"><span class="hljs-number">500</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Tried to kill task 500 but failed: '</span></span>, $e-&gt;getMessage(), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far this will not work, because </font><font style="vertical-align: inherit;">The function </font></font><code>stackedCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not handle exceptions. </font><font style="vertical-align: inherit;">To fix this, modify it a bit:</font></font><br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stackedCoroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Generator $gen)</span></span></span><span class="hljs-function"> </span></span>{ $stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SplStack; $exception = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($exception) { $gen-&gt;throw($exception); $exception = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $value = $gen-&gt;current(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Generator) { $stack-&gt;push($gen); $gen = $value; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $isReturnValue = $value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CoroutineReturnValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$gen-&gt;valid() || $isReturnValue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($stack-&gt;isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $gen = $stack-&gt;pop(); $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $sendValue = (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $gen-&gt;key() =&gt; $value); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { $gen-&gt;throw($e); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $gen-&gt;send($sendValue); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($stack-&gt;isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> $e; } $gen = $stack-&gt;pop(); $exception = $e; } } }</code> </pre> <br><br><h4>  Summarizing </h4><br>       ,   ,   ,       .      ,  ,      ,     ,      .       ,        .     <code>yield $socket-&gt;read()</code> . <br><br>      ,  ,    ,        PHP.         .         ,   ,     .   ,       ,     , - . <br><br>   ,           :) <br><br>   :       ,    ,  .. .    ‚Äî  . </div><p>Source: <a href="https://habr.com/ru/post/164173/">https://habr.com/ru/post/164173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164163/index.html">What should be able to personal account of the wholesale company in 2013?</a></li>
<li><a href="../164165/index.html">How to create a new IP telephony application on Android</a></li>
<li><a href="../164167/index.html">10,000 active ePayService users in January 2013!</a></li>
<li><a href="../164169/index.html">Mathematical library Numbers.js</a></li>
<li><a href="../164171/index.html">One way to backup the TrueCrypt container</a></li>
<li><a href="../164175/index.html">Technology to quickly create backgrounds for 2D games based on 3D blanks (48 hours of development)</a></li>
<li><a href="../164177/index.html">One small optimization</a></li>
<li><a href="../164181/index.html">JOBS Act promises explosive growth for IT companies in the US</a></li>
<li><a href="../164183/index.html">Happy New Year</a></li>
<li><a href="../164185/index.html">What is not written in Wikipedia on global navigation satellite systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>