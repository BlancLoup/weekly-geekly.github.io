<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Z-order vs R-tree, continued</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time we came to the conclusion that for the effective operation of a spatial index based on a Z-order, 2 things must be done: 



- efficient sub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Z-order vs R-tree, continued</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/13c/a11/68b/13ca1168b7124e42a2a309744fd977eb.png"></div><br>  <a href="https://habrahabr.ru/post/319096/">Last time</a> we came to the conclusion that for the effective operation of a spatial index based on a Z-order, 2 things must be done: <br><br><ul><li>  efficient subinterval acquisition algorithm </li><li>  low-level work with B-tree </li></ul><br>  That's exactly what we do under the cut. <br><a name="habracut"></a><br>  Let's start with a more interesting algorithm. <br><br><h3>  Subquery breakdown </h3><br>  We will consider a 2-dimensional algorithm (indexation of points) due to its relative simplicity.  However, the algorithm is easily generalized to large dimensions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we (also for simplicity) will use non-negative integer coordinates.  The coordinates are limited to 32 bits, so the value of the index key can be stored in uint64 <br><br>  We need the following simple z-numbering properties: <br><br><ol><li>  Let a certain rectangle be marked on the plane.  Then, among all points of the rectangle, the smallest z-number has a lower left corner of the rectangle (we will call it ‚Äúz‚Äù), and the largest one has the upper right corner (we will call it ‚ÄúZ‚Äù).  This property obviously follows from the method of constructing z-numbers. <br><br></li><li>  Each rectangle can be divided in one way into two rectangles (by a vertical or horizontal cut) so that all the z-numbers of the first rectangle are less than all the z-numbers of the second.  This follows from the self-similarity of the Z-curve.  The unit cell of four cells is divided in half, then in half in two cuts, the same happens at all levels of the hierarchy. </li></ol><br>  How exactly do you need to cut the extent to maintain the continuity property of the intervals? <br><br>  It follows from the self-similarity of a curve that one can cut only along the lattice with a step of a power of two and with a node at the origin of coordinates. <br><br>  But which lattice of 64 available to choose?  It is quite simple.  The extent to be cut must occupy more than one cell in the desired grid, otherwise there is simply nothing to cut.  On the other hand, in any of the coordinates, the size cannot exceed 2 cells, and at least one must be strictly 2 cells.  If, in both dimensions, the extent being cut occupies 2 cells, we will cut according to the coordinate whose rank in the construction of the Z-value is highest. <br><br>  How to find such a grid?  This is also easy.  It is enough to compare the Z-values ‚Äã‚Äãof the angles z and Z. We begin to compare with the higher digits and find the digit where their values ‚Äã‚Äãdiverged.  Here is the desired grid. <br><br>  How to make a cut?  Here it is necessary to recall the method of constructing the Z-value, namely, that the x &amp; y coordinates alternate through the discharge.  Consequently: <br><br><ul><li>  Let the difference between z and Z begin in discharge m </li><li>  We will cut into one coordinate, on which it was necessary to m, regardless of whether x is or y, even if in this case it is x, however, everything works the same for y </li><li>  From the extent (x0, y0, x1, y1) we should get two: (x0, y0, x2-1, y1), (x2, y0, x1, y1) </li><li>  And in order to get x2, it is enough to zero all the digits of the x coordinates under m, i.e.  through one </li><li>  x2-1 is obtained by zeroing the m bit and assigning 1 to all the low-order x bits </li></ul><br>  So, what does the subquery generation algorithm look like?  Pretty simple: <br><br><ol><li>  We get a queue of subqueries, initially in this queue a single element - the desired extent </li><li>  While the queue is not empty: <br><br><ol><li>  We get item from the top of the queue </li><li>  If <b>the stop criterion</b> does not work for this request <br><ol><li>  We get z and Z - values ‚Äã‚Äãfor its angles </li><li>  We compare z and Z - we find the discharge m, on which we will cut </li><li>  In the above way we get two subqueries </li><li>  We place them in the queue, first the one with the larger Z-values, then the second </li></ol></li></ol></li></ol><br>  This method guarantees us the generation of subqueries, in which the Z-values ‚Äã‚Äãof the final (that is, those on which the stop criterion has worked) of the subqueries only increase, no forwarding occurs. <br><br><h3>  Stop criterion </h3><br>  It is very important, if you neglect it, the generation of subqueries will continue until everything is cut into single squares. <br><br>  It should be noted that in developing such a criterion we cannot rely only on the parameters of the query, area, geometric properties ... In real data, the distribution of points can be very uneven, for example, cities and empty spaces.  The population of the area is unknown to us in advance. <br><br>  This means integration with the search in the index tree, which, as we remember, is a B-tree. <br><br>  What does a subquery look like in terms of an index?  This is a collection of data located on a certain number of pages.  If the subquery is empty, then the data interval is empty, but nonetheless looks somewhere, because  to understand that there is no data, you must try to read them and go down from the top of the tree to the leaf page.  It may happen that an empty query also looks outside the tree. <br><br>  In general, the process of subtracting subquery data consists of two phases - <br><br><ul><li>  Sounding a tree.  Starting from the root page, we are looking for a key less than or equal to the Z-value of the lower left corner of the subquery (z) and so go down to the leaf page.  At the exit we get a stack of pages and a leaf page ‚Äúin the air‚Äù.  On this page we are looking for an element greater than or equal to the one we searched for <br><br></li><li>  Read ahead to the end of the subquery.  In PostgreSQL, leafy B-tree pages are linked by a list, if that were not the case, in order to get the next page you would have to climb up the stack of pages in order to go down to it. </li></ul><br>  So, after the probe request, we have in our hands a leaf page on which our data presumably begins.  Different situations are possible: <br><br><ol><li>  Found page element is greater than the upper right corner of the subquery (Z).  Those.  No data. </li><li>  Found page element is less than Z, last page element is less than Z. Ie  The subquery starts on this page, ends somewhere further. </li><li>  The found page element is less than Z, the last page element is greater than Z. Ie  The entire subquery is located on this page. </li><li>  The found page element is less than Z, the last page element is Z. Ie  The subquery begins on this page, but it probably ends on the next (several elements with the same coordinates).  And maybe much further if there are many duplicates. </li></ol><br>  Option N1 does not require any action.  For N2, the following stopping criterion (splitting subqueries) seems natural - we will cut them until we get options 3 or 4. With option N3, everything is clear, in the case of N4 data pages there may be several, but it is pointless to cut the subquery .  on the next page (s) there can only be data with a key equal to Z, after the cut we will find ourselves in the same situation.  To cope with this, it is sufficient to simply read all the data with the key equal to Z from the following pages (pages). They may not be present, in general, N4 is a rather exotic case. <br><br><h3>  Work with B-tree </h3><br>  Low-level work with the B-tree does not present special difficulties.  But you have to create an <a href="https://postgrespro.ru/blog/pgsql/119069">extension</a> .  The general logic is as follows: register the <a href="https://postgrespro.ru/docs/postgrespro/9.5/functions-srf">SRF</a> function: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> __ret_2d_lookup <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (c_tid TID, x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, y <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> zcurve_2d_lookup(<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> SETOF __ret_2d_lookup <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'MODULE_PATHNAME'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> C IMMUTABLE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>;</code> </pre> <br>  Which receives the input index name and extent.  And returns a set of elements, in each of which a pointer to a row of the table and coordinates. <br><br>  Access to the actual tree is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *relname; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ... List *relname_list; RangeVar *relvar; Relation rel; ... relname_list = stringToQualifiedNameList(relname); relvar = makeRangeVarFromNameList(relname_list); rel = indexOpen(rel); ... indexClose(rel);</code> </pre><br>  Getting the root page: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access = BT_READ; Buffer buf; ... buf = _bt_getroot(rel, access);</code> </pre><br>  In general, the search in the index is made like a normal search in the B-tree (see postgresql / src / backend / access / nbtree / nbtsearch.c).  The changes are related to the specifics of the key, perhaps it could have been done without it, even if it were a bit slower. <br><br>  Search inside the page looks like this: <br><br><pre> <code class="cpp hljs">Page page; BTPageOpaque opaque; OffsetNumber low, high; int32 result, cmpval; Datum datum; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull; ... page = BufferGetPage(buf); opaque = (BTPageOpaque) PageGetSpecialPointer(page); low = P_FIRSTDATAKEY(opaque); high = PageGetMaxOffsetNumber(page); ...     ... <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (P_ISLEAF(opaque)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> low; <span class="hljs-comment"><span class="hljs-comment">/*   -   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OffsetNumberPrev(low);</code> </pre> <br>  Receiving a page element: <br><br><pre> <code class="cpp hljs">OffsetNumber offnum; Page page; Relation rel; TupleDesc itupdesc = RelationGetDescr(rel); IndexTuple itup; Datum datum; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull; uint64 val; ... itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum)); datum = index_getattr(itup, <span class="hljs-number"><span class="hljs-number">1</span></span>, itupdesc, &amp;isNull); val = DatumGetInt64(datum);</code> </pre><br><br><h3>  Summary algorithm </h3><br><ol><li>  We get a queue of subqueries, initially in this queue a single element - the desired extent </li><li>  While the queue is not empty: <br><ol><li>  We get item from the top of the queue </li><li>  Perform a probe query in the index for z (lower left corner).  In order to save, you can do the probe not every time, but only if the last value found (which is initially 0) is greater than or equal to z <br></li><li>  If the found minimum value exceeds Z (upper right corner), we finish processing this subquery, go to P.2 </li><li>  Check the last element of the leaf page of the B-tree where the probe request stopped </li><li>  If it is greater than or equal to Z, select the page elements, filter them for belonging to the search extent and remember the resulting points. </li><li>  If it is equal to Z, read the index forward until the keys are fully exhausted with a value equal to Z and also remember them </li><li>  Otherwise - the last value of the page is less than Z. <br><br><ol><li>  We compare z and Z - we find the discharge m, on which we will cut </li><li>  In the above way we get two subqueries </li><li>  We place them in the queue, first the one with the larger Z-values, then the second </li></ol></li></ol></li></ol><br><br><h3>  Preliminary results </h3><br>  The title of the article presents the breakdown of a real query into subqueries and resulting points.  A comparison of the results found by the R-tree with those obtained by the algorithm described above is shown.  Picture debugging times and it is clear that one point is not enough. <br><br>  But the pictures are pictures, but I want to see a comparison of performance.  From our side there will be the same table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> test_points (x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>,y <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); COPY test_points from '/home/.../data.csv'; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> zcurve_test_points <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_points(zcurve_val_from_xy(x, y));</code> </pre><br>  And requests like: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> zcurve_2d_lookup(<span class="hljs-string"><span class="hljs-string">'zcurve_test_points'</span></span>, <span class="hljs-number"><span class="hljs-number">500000</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>,<span class="hljs-number"><span class="hljs-number">501000</span></span>,<span class="hljs-number"><span class="hljs-number">501000</span></span>);</code> </pre> <br>  We will compare with the R-tree as a standard de facto.  Moreover, unlike the previous article, we need an ‚Äúindex only scan‚Äù on the R-tree, since  our Z-index no longer refers to the table. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> test_pt <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> point(x,y) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_points); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> test_pt_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_pt <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist (point); vacuum test_pt;</code> </pre><br>  On such data request: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, buffers) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_pt <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> point &lt;@ box( point(<span class="hljs-number"><span class="hljs-number">500000</span></span>, <span class="hljs-number"><span class="hljs-number">500000</span></span>), point(<span class="hljs-number"><span class="hljs-number">510000</span></span>, <span class="hljs-number"><span class="hljs-number">510000</span></span>));</code> </pre> <br>  gives out: <br><br><pre> <code class="hljs 1c"> QUERY PLAN --------------------------------------------------------------------------------------------- Index Only Scan using test_pt_idx on test_pt (cost=<span class="hljs-number"><span class="hljs-number">0.42</span></span>..<span class="hljs-number"><span class="hljs-number">539.42</span></span> rows=<span class="hljs-number"><span class="hljs-number">10000</span></span> width=<span class="hljs-number"><span class="hljs-number">16</span></span>) (actual time=<span class="hljs-number"><span class="hljs-number">0.075</span></span>..<span class="hljs-number"><span class="hljs-number">0.531</span></span> rows=<span class="hljs-number"><span class="hljs-number">968</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Index Cond: (point &lt;@ '(<span class="hljs-number"><span class="hljs-number">510000</span></span>,<span class="hljs-number"><span class="hljs-number">510000</span></span>),(<span class="hljs-number"><span class="hljs-number">500000</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>)'::box) Heap Fetches: <span class="hljs-number"><span class="hljs-number">0</span></span> Buffers: shared hit=<span class="hljs-number"><span class="hljs-number">20</span></span> Planning time: <span class="hljs-number"><span class="hljs-number">0.088</span></span> ms Execution time: <span class="hljs-number"><span class="hljs-number">0.648</span></span> ms (<span class="hljs-number"><span class="hljs-number">6</span></span> rows)</code> </pre><br>  as required. <br><br>  Actually comparison: <br><table><tbody><tr><th>  Request type </th><th>  Index type </th><th>  Time ms </th><th>  Shared reads </th><th>  Shared hits </th></tr><tr><td>  100100 <br>  ~ 1 point </td><td>  R-tree <br>  Z-curve </td><td>  0.4 * <br>  0.34 * </td><td>  1.8 <br>  1.2 </td><td>  3.8 <br>  3.8 </td></tr><tr><td>  10001000 <br>  ~ 100 points </td><td>  R-tree <br>  Z-curve </td><td>  0.5 ... 7 ** <br>  0.41 * </td><td>  6.2 <br>  2.8 </td><td>  4.9 <br>  37 </td></tr><tr><td>  10,000x10000 <br>  ~ 10,000 points </td><td>  R-tree <br>  Z-curve </td><td>  4 ... 150 *** <br>  6.6 **** </td><td>  150 <br>  43.7 </td><td>  27 <br>  2900 </td></tr></tbody></table>  * - data obtained by averaging a series of length 100 000 <br>  ** - data obtained by averaging a series of different lengths, 10,000 vs 100,000 <br>  *** - data obtained by averaging a series of different lengths, 1 000 vs 10 000 <br>  **** - data obtained by averaging a series of length 10 000 <br><br>  The measurements were conducted on a modest virtual machine with two cores and 4 GB of RAM, so the times have no absolute value, but the numbers of the pages you read can be trusted. <br>  The times are shown on the second runs, on the heated server and the virtual machine.  The number of buffers read is on a freshly raised server. <br><br><h3>  findings </h3><br><ul><li>  in any case, on small queries, the Z-index is faster than the R-tree </li><li>  and reads at the same time noticeably less pages </li><li>  R-tree much earlier begins to massively miss the cache </li><li>  at the same time, the Z-index itself is four times smaller, so that the cache works more efficiently for it </li><li>  moreover, it is possible that the misses go past the disk cache of the host machine, otherwise it is difficult to explain such a difference </li></ul><br><h3>  What's next </h3><br>  The considered two-dimensional point index is intended only for testing the concept, in life it is of little use. <br><br>  Even for a three-dimensional index of a 64-bit key, there is no longer enough (or end-to-end) for a useful resolution. <br><br>  So what will be ahead: <br><br><ul><li>  pass to another key, numeric </li><li>  3D option, including points on the sphere </li><li>  checking the ability to work with the Hilbert curve </li><li>  full measurements </li><li>  4D option - rectangles </li><li>  6D variant - rectangles on a sphere </li><li>  ... </li></ul><br>  <b>PS: The</b> sources are laid out <a href="https://github.com/bmuratshin/zcurve/tree/raw-2D">here</a> with the BSD license, described in this article corresponds to the ‚Äúraw-2D‚Äù branch <br><br>  <b>PPS:</b> The algorithm as such was developed in ancient times (2004-2005) in collaboration with Alexander Artyushin. <br><br>  <b>PPPS:</b> Many thanks to the guys from <a href="http://postgrespro.ru/">PostgresPro</a> for encouraging me to implement this algorithm in PostgreSQL. <br><br>  <b>PPPPS:</b> Continued <a href="https://habrahabr.ru/post/323192/">here</a> </div><p>Source: <a href="https://habr.com/ru/post/319810/">https://habr.com/ru/post/319810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319798/index.html">Why do people play games</a></li>
<li><a href="../319800/index.html">What are the service providers of data centers, and how to choose the best?</a></li>
<li><a href="../319804/index.html">Pure javascript.Classes</a></li>
<li><a href="../319806/index.html">Product development: two years of work on the Otkrytie Bank mobile app</a></li>
<li><a href="../319808/index.html">Fighting borrowing verification</a></li>
<li><a href="../319812/index.html">International Student School Recent Advances in Algorithms: St. Petersburg, May 22‚Äì26, 2017</a></li>
<li><a href="../319814/index.html">What to catch in the career of an IT architect: expectations VS reality</a></li>
<li><a href="../319820/index.html">How to avoid self-excitation of cellular amplifier</a></li>
<li><a href="../319822/index.html">IT outsourcing in Russia - current realities and perspectives, opinions and experience of experts</a></li>
<li><a href="../319824/index.html">Old men have a place here: forgotten IT technologies in the ranks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>