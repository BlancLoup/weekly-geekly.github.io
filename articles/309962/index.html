<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functions of higher orders and monads for PHP`s</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Among PHP programs, a procedural or, in recent versions, a partially object-oriented programming style prevails. But you can write differently, in con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functions of higher orders and monads for PHP`s</h1><div class="post__text post__text-html js-mediator-article"><p>  Among PHP programs, a procedural or, in recent versions, a partially object-oriented programming style prevails.  But you can write differently, in connection with which you want to talk about the functional style, the benefit of some tools for this are in PHP. </p><br><p>  Therefore, we will consider the implementation of the JSON parser in the form of the simplest functions and their combining functions into more complex ones, gradually reaching the full-fledged JSON parser format.  Here is an example of the code that we get: </p><br><pre><code class="php hljs">$jNumber = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $number = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'-'</span></span>)-&gt;orElse( literal(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) )-&gt;orElse( just(<span class="hljs-string"><span class="hljs-string">''</span></span>) ); $number .= <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeOf(<span class="hljs-string"><span class="hljs-string">'[0-9]'</span></span>)-&gt;onlyIf( notEmpty() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)-&gt;orElse( just(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) ) ) { $number .= <span class="hljs-string"><span class="hljs-string">'.'</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeOf(<span class="hljs-string"><span class="hljs-string">'[0-9]'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> +$number; });</code> </pre> <br><p>  <em>In addition to the functional approach itself, attention can be paid to the use of classes for creating a DSL-like syntax and to the use of generators to simplify the syntax of combinators.</em> </p><br><p>  <strong>UPDATE by</strong> itself JSON parsing has long been a problem solved and, of course, a ready and tested C function will work better.  The article uses this task as an example to explain the functional approach.  It is also not advocated the use of just such a code in production, everyone can learn some ideas that can simplify the code and life. </p><br><p>  The full code is on <a href="https://github.com/atamurius/phpM">github</a> . </p><a name="habracut"></a><br><h2>  Functional style </h2><br><p>  How does a programmer cope with the enormous complexity of programs?  He takes simple blocks and builds more complex ones out of which even more complex blocks are built and, finally, a program.  At least it was after the appearance of the first languages ‚Äã‚Äãwith subroutines. </p><br><p>  The procedural style is based on the description of the procedures that cause other procedures together to change some common data.  The object-oriented style adds the ability to describe data structures composed of other data structures.  The functional style uses the composition (connection) of functions. </p><br><p>  What is the difference between the composition of functions and the composition of procedures and objects?  The basis of the functional approach is the purity of the functions, which means that the result of the functions depends only on the input parameters.  If the functions are pure, it is much easier to predict the result of their composition and even create ready-made functions for converting other functions. </p><br><p>  The functions that receive and / or return other functions as a result are called higher order functions and represent the topic of this article. </p><br><h2>  What problem will we solve? </h2><br><p>  For example, let's take a task that is not very easy to solve entirely and see how the functional approach will help us simplify this task. </p><br><p>  For example, let's try to create a JSON parser, which from the JSON string will receive the corresponding PHP object: a number, string, list, or associated list (with all possible nested values, of course). </p><br><h3>  What is a parser? </h3><br><p>  Let's start with the simplest elements: we write a parser, what is it?  A parser is a function that takes a string and, if successful, returns a pair of values: the result of parsing and the remainder of the string (if the parsed value did not occupy the entire line) or an empty set if the line could not be parsed: </p><br><pre> <code class="hljs cs">Parser: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> =&gt; [x,<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] | []</code> </pre> <br><p>  For example, if we have a function-parser <code>number</code> then we could write such tests: </p><br><pre> <code class="php hljs">assert(number(<span class="hljs-string"><span class="hljs-string">'123;'</span></span>) === [<span class="hljs-number"><span class="hljs-number">123</span></span>,<span class="hljs-string"><span class="hljs-string">';'</span></span>]); assert(number(<span class="hljs-string"><span class="hljs-string">'none'</span></span>) === []);</code> </pre> <br><p>  <strong>DISCLAMER</strong> : PHP has a not very convenient syntax for working with functions, so for simpler and more understandable code we will use a class that is nothing but a wrapper around the parser function and is needed to specify types and use convenient chaining syntax, let's talk more about what next. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FAILED = []; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $parse; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $parse)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;parse = $parse; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $s)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;parse)($s); } }</code> </pre> <br><p>  But let's remember that <code>Parser</code> is nothing more than the function <code>string =&gt; array</code> . </p><br><p>  For convenience, we also introduce the <code>parser</code> function, which we will use instead of calling the <code>new Parser</code> constructor for short: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($f, $scope = null)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parser($f-&gt;bindTo($scope)); }</code> </pre> <br><h2>  Simple parsers </h2><br><p>  So, we figured out what parsers are, but we never wrote one, let's fix it.  Here is an example of a parser that always returns <code>1</code> , regardless of the source string: </p><br><pre> <code class="php hljs">$alwaysOne = parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, $s]; }); assert($alwaysOne(<span class="hljs-string"><span class="hljs-string">'123'</span></span>) === [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'123'</span></span>]);</code> </pre> <br><p>  The usefulness of this function is not obvious, let's make it more general and declare a function that allows you to create a similar parser for any value: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">just</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ $x, $s ]; }); }</code> </pre> <br><p>  So far, everything is simple, but still not very useful, because we want to parse a string, and not always return the same thing.  Let's make a parser that returns the first few characters of the input string: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $n)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strlen($s) &lt; $n ? Parser::FAILED : [ substr($s, <span class="hljs-number"><span class="hljs-number">0</span></span>, $n), substr($s, $n) ]; }); } test(take(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-string"><span class="hljs-string">'abc'</span></span>, [<span class="hljs-string"><span class="hljs-string">'ab'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>]); test(take(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-string"><span class="hljs-string">'abc'</span></span>, Parser::FAILED);</code> </pre> <br><p>  Already better, our first parser, which really parses the string!  Let me remind you: we describe the simplest bricks from which we can build a more complex parser.  Therefore, to complete the picture, we lack only a parser, which does not parse anything at all. </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">none</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Parser::FAILED; }); }</code> </pre> <br><p>  He is still useful to us. </p><br><p>  That's all the parsers we need.  This is enough to parse JSON.  Do not believe?  It remains to think of a way to assemble these bricks into more complex blocks. </p><br><h2>  Putting the bricks together </h2><br><p>  Since we decided to do functional programming, it is logical to use functions to combine parser functions into more complex parsers! </p><br><p>  For example, if we have <code>first</code> and <code>second</code> parsers and we want to apply any of them to the string, we can define a parser combinator ‚Äî a function that creates a new parser based on the existing ones: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oneOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parser $first, Parser $second)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($first,$second)</span></span></span><span class="hljs-function"> </span></span>{ $result = $first($s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === Parser::FAILED) { $result = $second($s); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }); } test(oneOf(none(),just(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-string"><span class="hljs-string">'123'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'123'</span></span>]);</code> </pre> <br><p>  But, as mentioned above, such syntax can quickly become unreadable (for example, <code>oneOf($a,oneOf($b,oneOf($c,$d)))</code> ), so we will rewrite this (and all the following) functions as class methods <code>Parser</code> : </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orElse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parser $alternative)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($alternative)</span></span></span><span class="hljs-function"> </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>($s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === Parser::FAILED) { $result = $alternative($s); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;-     parser  bindTo:   $this   } test(none()-&gt;orElse(just(1)), '123', [1,'123']);</span></span></code> </pre> <br><p>  This is better, you can write <code>$a-&gt;orElse($b)-&gt;orElse($c)-&gt;orElse($d)</code> instead of what was higher. </p><br><p>  And one more, not so simple, but much more powerful function: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $f)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($s)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($f)</span></span></span><span class="hljs-function"> </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>($s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result != Parser::FAILED) { <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> ($x, $rest) = $result; $next = $f($x); $result = $next($rest); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); }</code> </pre> <br><p>  Let's deal with it in more detail.  It takes the function <code>f: x =&gt; Parser</code> , which takes the result of parsing our existing parser and returns on its basis a new parser, which continues to parse the string from the place where our previous parser stopped. </p><br><p>  For example: </p><br><pre> <code class="php hljs">test(take(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'1234'</span></span>, [<span class="hljs-string"><span class="hljs-string">'1'</span></span>,<span class="hljs-string"><span class="hljs-string">'234'</span></span>]); test(take(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-string"><span class="hljs-string">'234'</span></span>, [<span class="hljs-string"><span class="hljs-string">'23'</span></span>, <span class="hljs-string"><span class="hljs-string">'4'</span></span>]); test( take(<span class="hljs-number"><span class="hljs-number">1</span></span>)-&gt;flatMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment"># x --   take(1) return take(2)-&gt;flatMap(function($y) use ($x) { # y --   take(2) return just("$x~$y"); # --   }); }), '1234', ['1~23','4'] );</span></span></code> </pre> <br><p>  So we combined <code>take(1)</code> , <code>take(2)</code> and <code>just("$x~$y")</code> and got a rather complicated parser that first parses one character, followed by two more and returns them as <code>$x~$y</code> . </p><br><p>  The main feature of the work done is that we describe what to do with the results of parsing, but the string itself is not involved here, we do not have the opportunity to be mistaken about what part of the string to send.  And then we will see how to make the syntax of such combinations more simple and readable. </p><br><p>  This feature will allow us to describe several other useful combinators: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onlyIf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $predicate)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;flatMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($predicate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $predicate($x) ? just($x) : none(); }); }</code> </pre> <br><p>  This combinator allows you to specify the action of the parser and check its result for compliance with some criterion.  For example, with its help we build a very useful parser: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">literal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> take(strlen($value))-&gt;onlyIf(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($actual)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $actual === $value; }); } test(literal(<span class="hljs-string"><span class="hljs-string">'test'</span></span>), <span class="hljs-string"><span class="hljs-string">'test1'</span></span>, [<span class="hljs-string"><span class="hljs-string">'test'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>]); test(literal(<span class="hljs-string"><span class="hljs-string">'test'</span></span>), <span class="hljs-string"><span class="hljs-string">'some1'</span></span>, []);</code> </pre> <br><h2>  DO notation </h2><br><p>  We have already described the simplest parsers <code>take</code> , <code>just</code> and <code>none</code> , methods of combining them ( <code>orElse</code> , <code>flatMap</code> , <code>onlyIf</code> ) and even described using their literal parser. </p><br><p>  Now we will start building more complex parsers, but before that I would like to make the way to describe them more simple: the <code>flatMap</code> combining function allows us a lot, but it doesn't look that good. </p><br><p>  In this regard, we shall see how other languages ‚Äã‚Äãsolve this problem.  So in the languages ‚Äã‚Äãof Haskell and Scala there is a very convenient syntax for working with such things (they even have their own name - monads), it is called (in Haskell) DO-notation. </p><br><p>  What does <code>flatMap</code> essentially do?  It allows you to describe what to do with the result of parsing without performing the actual parsing.  Those.  the procedure, as it were, is suspended until the intermediate result is obtained.  To implement this effect, you can use the new PHP syntax - generators. </p><br><h3>  Generators </h3><br><p>  Let's make a small digression and consider what generators are.  In PHP 5.5.0 and higher, it is possible to describe a function: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (generator() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $i) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $i; <span class="hljs-comment"><span class="hljs-comment"># -&gt; 123</span></span></code> </pre> <br><p>  What is more interesting for us is that you can not only receive data from the generator, but also transfer it to it via <code>yield</code> , and even from version 7 get the result of the generator via <code>getReturn</code> : </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspendable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $first = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">"first"</span></span>; $second = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $first.$second; } $gen = suspendable(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($gen-&gt;valid()) { $current = $gen-&gt;current(); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $current.<span class="hljs-string"><span class="hljs-string">','</span></span>; $gen-&gt;send($current.<span class="hljs-string"><span class="hljs-string">'!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $gen-&gt;getReturn(); <span class="hljs-comment"><span class="hljs-comment"># -&gt; first,second,first!second!</span></span></code> </pre> <br><p>  This can be used to hide <code>flatMap</code> calls from a programmer. </p><br><h3>  <code>flatMap</code> using combinators </h3><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Closure $gen, $scope = null)</span></span></span><span class="hljs-function"> </span></span>{ $step = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($body)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$step)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! $body-&gt;valid()) { $result = $body-&gt;getReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_null($result) ? none() : just($result); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $body-&gt;current()-&gt;flatMap( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$step, $body)</span></span></span><span class="hljs-function"> </span></span>{ $body-&gt;send($x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $step($body); }); } }; $gen = $gen-&gt;bindTo($scope); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($text)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($step,$gen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $step($gen())($text); }); }</code> </pre> <br><p>  This function takes each <code>yield</code> in the generator (which contains a parser, the result of which we want to get) and combines it with the remaining code snippet (in the form of the recursive <code>step</code> function) via <code>flatMap</code> . </p><br><p>  The same thing without recursion and <code>flatMap</code> functions could be written like this: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Closure $gen, $scope = null)</span></span></span><span class="hljs-function"> </span></span>{ $gen = $gen-&gt;bindTo($scope); <span class="hljs-comment"><span class="hljs-comment">#   $this   return parser(function($text) use ($gen) { $body = gen(); while ($body-&gt;valid()) { $next = $body-&gt;current(); $result = $next($text); if ($result === Parser::FAILED) { return Parser::FAILED; } list($x,$text) = $result; $body-&gt;send($x); } return $body-&gt;getReturn(); }); }</span></span></code> </pre> <br><p>  But the first entry is more interesting because it is not specifically tied to parsers, they only have the functions <code>flatMap</code> , <code>just</code> and <code>none</code> (and even that could be rewritten <code>just</code> to handle the null in a special way and do without <code>none</code> ). </p><br><p>  Objects that can be combined using the two methods <code>flatMap</code> and <code>just</code> call monads (this is a slightly simplified definition) and the same code can be used to write combinators for promises, optional values ‚Äã‚Äã(Maybe, Option), and many others. </p><br><p>  But for the sake of what did we write this not very simple function?  To make further use of <code>flatMap</code> much easier.  Compare the same code with a clean <code>flatMap</code> : </p><br><pre> <code class="php hljs">test( take(<span class="hljs-number"><span class="hljs-number">1</span></span>)-&gt;flatMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> take(<span class="hljs-number"><span class="hljs-number">2</span></span>)-&gt;flatMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> just(<span class="hljs-string"><span class="hljs-string">"$x~$y"</span></span>); }); }), <span class="hljs-string"><span class="hljs-string">'1234'</span></span>, [<span class="hljs-string"><span class="hljs-string">'1~23'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>] );</code> </pre> <br><p>  and the same code, but written in <code>_do</code> : </p><br><pre> <code class="php hljs">test( _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $x = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-number"><span class="hljs-number">1</span></span>); $y = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"$x~$y"</span></span>; }), <span class="hljs-string"><span class="hljs-string">'1234'</span></span>, [<span class="hljs-string"><span class="hljs-string">'1~23'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>] );</code> </pre> <br><p>  The resulting parser does the same thing in the same way, but reading and writing such code is much easier! </p><br><h2>  We build more complex parsers and combinators </h2><br><p>  Now, using this notation, we can write some more useful parsers: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $predicate)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($predicate)</span></span></span><span class="hljs-function"> </span></span>{ $c = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-number"><span class="hljs-number">1</span></span>)-&gt;onlyIf($predicate)-&gt;orElse(just(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($c !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $rest = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeWhile($predicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $c.$rest; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>; } }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $pattern)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> takeWhile(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($c)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($pattern)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> preg_match(<span class="hljs-string"><span class="hljs-string">"/^$pattern$/"</span></span>, $c); }); } test(takeOf(<span class="hljs-string"><span class="hljs-string">'[0-9]'</span></span>), <span class="hljs-string"><span class="hljs-string">'123abc'</span></span>, [<span class="hljs-string"><span class="hljs-string">'123'</span></span>,<span class="hljs-string"><span class="hljs-string">'abc'</span></span> ]); test(takeOf(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span>), <span class="hljs-string"><span class="hljs-string">'123abc'</span></span>, [ <span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">'123abc'</span></span>]);</code> </pre> <br><p>  And useful <code>Parser</code> methods for repeating elements: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repeated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ $atLeastOne = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $first = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>; $rest = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;repeated(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array_merge([$first],$rest); },<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $atLeastOne-&gt;orElse(just([])); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">separatedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parser $separator)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-function"> </span></span>{ $self = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>; $atLeastOne = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($separator)</span></span></span><span class="hljs-function"> </span></span>{ $first = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>; $rest = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;prefixedWith($separator)-&gt;repeated(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array_merge([$first], $rest); },<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $atLeastOne-&gt;orElse(just([])); }</code> </pre> <br><h2>  Json </h2><br><p>  Each of the parsers and combinators we wrote separately is simple (well, maybe except <code>flatMap</code> and <code>_do</code> , but there are only two of them and they are very versatile), but using them now we can easily write a JSON parser. </p><br><h3> <code>jNumber = ('-'|'+'|'') [0-9]+ (.[0-9]+)?</code> </h3> <br><pre> <code class="php hljs">$jNumber = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $number = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'-'</span></span>)-&gt;orElse(literal(<span class="hljs-string"><span class="hljs-string">'+'</span></span>))-&gt;orElse(just(<span class="hljs-string"><span class="hljs-string">''</span></span>)); $number .= <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeOf(<span class="hljs-string"><span class="hljs-string">'[0-9]'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)-&gt;orElse(just(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>))) { $number .= <span class="hljs-string"><span class="hljs-string">'.'</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeOf(<span class="hljs-string"><span class="hljs-string">'[0-9]'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($number !== <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> +$number; });</code> </pre> <br><p>  The code is completely self-documenting, reading and looking for errors in it is quite simple. </p><br><h3> <code>jBool = true | false</code> </h3> <br><pre> <code class="php hljs">$jBool = literal(<span class="hljs-string"><span class="hljs-string">'true'</span></span>)-&gt;orElse(literal(<span class="hljs-string"><span class="hljs-string">'false'</span></span>))-&gt;flatMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> just($value === <span class="hljs-string"><span class="hljs-string">'true'</span></span>); });</code> </pre> <br><h3> <code>jString = '"' [^"]* '"'</code> </h3> <br><pre> <code class="php hljs">$jString = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'"'</span></span>); $value = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeOf(<span class="hljs-string"><span class="hljs-string">'[^"]'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'"'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $value; });</code> </pre> <br><h3> <code>jList = '[' (jValue (, jValue)*)? ']'</code> </h3> <br><pre> <code class="php hljs">$jList = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$jValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'['</span></span>); $items = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $jValue-&gt;separatedBy(literal(<span class="hljs-string"><span class="hljs-string">','</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">']'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $items; });</code> </pre> <br><h3> <code>jObject = '{' (pair (, pair)*)? '}'</code> </h3> <br><pre> <code class="php hljs">$jObject = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$jValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); $result = []; $pair = _do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$jValue,&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeOf(<span class="hljs-string"><span class="hljs-string">'\\w'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">':'</span></span>); $value = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $jValue; $result[$key] = $value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $pair-&gt;separatedBy(literal(<span class="hljs-string"><span class="hljs-string">','</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> literal(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; });</code> </pre> <br><h3> <code>jValue = jNull | jBool | jNumber | jString | jList | jObject</code> </h3> <br><pre> <code class="php hljs">$jValue = $jNull-&gt;orElse($jBool)-&gt;orElse($jNumber)-&gt;orElse($jString)-&gt;orElse($jList)-&gt;orElse($jObject);</code> </pre> <br><p>  Here is the JSON <code>jValue</code> parser!  And it looks not so incomprehensible, as it seemed at the beginning.  There are some performance notes, but they are solved by replacing the way the string is divided (for example, instead of <code>string =&gt; [x, string]</code> you can use <code>[string,index] =&gt; [x,string,index]</code> and avoid multiple splitting of the string).  And to change this kind, just rewrite <code>just</code> , <code>take</code> and <code>flatMap</code> , the rest of the code built on their basis will remain unchanged! </p><br><h2>  Conclusion </h2><br><p>  My goal was, of course, not to write the next JSON parser, but to demonstrate how to write small simple (and functionally pure) functions, as well as simple ways to combine them, allows you to build complex functions in a simple way. </p><br><p>  And in a simple and clear code and errors are less.  Do not be afraid of the functional approach. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/309962/">https://habr.com/ru/post/309962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309948/index.html">IOS 10 security settings you should pay attention to</a></li>
<li><a href="../309954/index.html">Samsung Solid State Drives: Gaining Momentum</a></li>
<li><a href="../309956/index.html">5 classic personality types in business and how to work with each of them</a></li>
<li><a href="../309958/index.html">React.js: build an isomorphic / universal application from scratch. Part 1: build the stack</a></li>
<li><a href="../309960/index.html">6 statistical indicators of IT outsourcing in 2016</a></li>
<li><a href="../309964/index.html">Zabbix 3.2 released</a></li>
<li><a href="../309966/index.html">Trend Convergence: Dell PowerEdge FX Architecture</a></li>
<li><a href="../309968/index.html">Why I refused to Rust</a></li>
<li><a href="../309970/index.html">How we helped to return to the client 60 thousand dollars accrued for international communication</a></li>
<li><a href="../309972/index.html">Communication opportunities of Internet projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>