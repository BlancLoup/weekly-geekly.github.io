<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Single Responsibility Principle. Not as simple as it sounds.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Single responsibility principle, the same principle of uniform responsibility, 
 He is the principle of uniform variability - an extremely slippery gu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Single Responsibility Principle. Not as simple as it sounds.</h1><div class="post__text post__text-html js-mediator-article"><p><img width="500" src="https://habrastorage.org/getpro/habr/post_images/dad/c41/3d4/dadc413d4439871ac1632997daa6416c.png" alt="image" align="left">  Single responsibility principle, the same principle of uniform responsibility, <br>  He is the principle of uniform variability - an extremely slippery guy for understanding and such a nervous question at a programmer's interview. </p><br><p>  The first serious acquaintance with this principle took place for me at the beginning of the first course, when young and green people were taken to the forest to make students-real students from the larvae. </p><br><p>  In the forest, we were divided into groups of 8-9 people each and organized a competition - which group would drink a bottle of vodka faster, provided that the first person from the group pours vodka into a glass, drinks the second, and bites the third.  The unit that performed its operation gets to the end of the group queue. </p><br><p>  The case when the queue size was a multiple of three, and was a good implementation of the SRP. </p><a name="habracut"></a><br><h2 id="opredelenie-1-edinaya-otvetstvennost">  Definition 1. Single responsibility. </h2><br><p>  The formal definition of the principle of common responsibility (SRP) says that each object has its own responsibility and reason for existence and this responsibility is only one. </p><br><p>  Consider a booze object ( <strong>tippler</strong> ). <br>  To fulfill the SRP principle, we will divide the duties into three: </p><br><ul><li>  One pours ( <strong>PourOperation</strong> ) </li><li>  One <strong>Drink</strong> ( <strong>DrinkUpOperation</strong> ) </li><li>  One <strong>Bites</strong> ( <strong>TakeBiteOperation</strong> ) </li></ul><br><p>  Each of the participants in the process is responsible for one component of the process, that is, it has one atomic responsibility - to drink, pour or snack. </p><br><p>  Drinking, in turn, is a facade for these operations: </p><br><pre><code class="plaintext hljs">lass Tippler { //... void Act(){ _pourOperation.Do() //  _drinkUpOperation.Do() //  _takeBiteOperation.Do() //  } }</code> </pre> <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/07b/979/ed5/07b979ed5db74fcec05254aadb60220d.png" alt="image"></div><br><h4 id="zachem">  What for? </h4><br><p>  A human programmer writes code for a monkey man, and a monkey man is inconsiderate, stupid, and always in a hurry somewhere.  He can hold and understand about 3 - 7 terms at a time. <br>  In the case of drinking these three terms.  However, if we write the code of one sheet, then there will be hands, glasses, massacres and endless debates about politics.  And all this will be in the body of one method.  I am sure you have seen such code in your practice.  Not the most humane test for the psyche. </p><br><p>  On the other hand, the ape-man is sharpened to model real-world objects in his head.  In his imagination he can push them, assemble new objects from them and disassemble them in the same way.  Imagine an old car model.  In your imagination, you can open the door, unscrew the door trim and see the window regulator mechanisms, inside which there will be gears.  But you can not see all the components of the machine at the same time, in one "listing".  At least "ape-man" can not. </p><br><p>  Therefore, human programmers decompose complex mechanisms into a set of less complex and working elements.  However, it is possible to decompose in different ways: in many old machines, the air duct goes out the door, and in modern ones, the lock electronics fails to prevent the engine from starting, which delivers during repair. </p><br><p>  So, <strong>SRP is a principle explaining HOW to decompose, that is, where to draw the separation line</strong> . </p><br><p>  He says that it is necessary to decompose according to the principle of division of "responsibility", that is, according to the tasks of certain objects. </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/b89/d0f/3c6/b89d0f3c6434ae77a2b858e2af6374b0.png" alt="image"></div><br><p>  Let us return to the drinker and the pluses that a monkey man gets when decomposing: </p><br><ul><li>  The code has become very clear at every level. </li><li>  The code can be written by several programmers at once (each writing a separate element) </li><li>  Automatic testing is simplified - the simpler the element, the easier it is to test it. </li><li>  Of these three operations, in the future, you will be able to fold a glutton (using only <strong>TakeBitOperation</strong> ), Alcoholic (using only <strong>DrinkUpOperation</strong> directly from the bottle) and satisfy many other business requirements. </li></ul><br><p>  And, of course, cons: </p><br><ul><li>  We'll have to create more types. </li><li>  The drinker will drink for the first time a couple of hours later than it could </li></ul><br><h2 id="opredelenie-2-edinaya-izmenchivost">  Definition 2. Uniform variability. </h2><br><p>  Let the gentlemen!  The class of drinkers also fulfills a single responsibility - it drinks!  And in general, the word "responsibility" is a very vague concept.  Someone is responsible for the fate of mankind, and someone is responsible for raising penguins overturned at the pole. </p><br><p>  Consider two implementations of drinking.  The first, mentioned above, contains three classes - pour, drink and snack. </p><br><p>  The second, written through the methodology "Forward and only forward" and contains all the logic in the <strong>Act</strong> method: </p><br><pre> <code class="plaintext hljs">//      .    lass BrutTippler { //... void Act(){ //  if(!_hand.TryDischarge(from:_bottle, to:_glass, size:_glass.Capacity)) throw new OverdrunkException(); //  if(!_hand.TryDrink(from: _glass, size: _glass.Capacity)) throw new OverdrunkException(); // for(int i = 0; i&lt; 3; i++){ var food = _foodStore.TakeOrDefault(); if(food==null) throw new FoodIsOverException(); _hand.TryEat(food); } } }</code> </pre> <br><p>  Both of these classes, from the point of view of an outsider, look absolutely the same and fulfill the single responsibility of ‚Äúdrinking‚Äù. </p><br><p>  Embarrassment! </p><br><p>  Then we climb into the Internet and find out another definition of SRP - the principle of uniform variability. </p><br><p>  This definition states that " <strong>The module has one and only one reason for change</strong> ."  That is, "Responsibility is a reason for change." </p><br><p>  Now everything falls into place.  Separately, you can change the procedures for pouring, drinking and snacking, and in the drinker itself we can only change the sequence and composition of operations, for example, by moving the snack before drinking or adding a toast reading. </p><br><p>  In the "Forward and only forward" approach, all that can be changed is changed only in the <strong>Act</strong> method.  This can be readable and efficient in the case where there is little logic and it rarely changes, but often it ends in terrible methods with 500 lines each, with the number of if -s greater than is required for Russia to join NATO. </p><br><h2 id="opredelenie-3-lokalizaciya-izmeneniy">  Definition 3. Localization of changes. </h2><br><p>  Drinkers often do not understand why they woke up in someone else‚Äôs apartment, or where they were mobile.  It's time to add detailed logging. </p><br><p>  Let's start logging with the pouring process: </p><br><pre> <code class="plaintext hljs">class PourOperation: IOperation{ PourOperation(ILogger log /*....*/){/*...*/} //... void Do(){ _log.Log($"Before pour with {_hand} and {_bottle}"); //Pour business logic ... _log.Log($"After pour with {_hand} and {_bottle}"); } }</code> </pre> <br><p>  <strong>Having</strong> encapsulated it in <strong>PourOperation</strong> , we acted wisely from the point of view of responsibility and encapsulation, but now with the principle of variability we are now confused.  In addition to the operation itself, which can change, logging itself becomes changeable.  It is necessary to separate and make a special logger for the pouring operation: </p><br><pre> <code class="plaintext hljs">interface IPourLogger{ void LogBefore(IHand, IBottle){} void LogAfter(IHand, IBottle){} void OnError(IHand, IBottle, Exception){} } class PourOperation: IOperation{ PourOperation(IPourLogger log /*....*/){/*...*/} //... void Do(){ _log.LogBefore(_hand, _bottle); try{ //... business logic _log.LogAfter(_hand, _bottle"); } catch(exception e){ _log.OnError(_hand, _bottle, e) } } }</code> </pre> <br><p>  The meticulous reader will notice that <strong>LogAfter</strong> , <strong>LogBefore</strong> and <strong>OnError</strong> can also change separately, and by analogy with the previous actions will create three classes: <strong>PourLoggerBefore</strong> , <strong>PourLoggerAfter</strong> and <strong>PourErrorLogger</strong> . </p><br><p>  And remembering that there are three operations for drinking, we get nine logging classes.  As a result, the whole drinker consists of 14 (!!!) classes. </p><br><p>  Hyperbola?  Hardly!  A monkey man with a decomposition grenade will crush the ‚Äúpouring‚Äù into a decanter, a glass, pouring operators, a water supply service, a physical model of molecular collisions, and the next quarter will try to unravel dependencies without global variables.  And believe me - it will not stop. </p><br><p>  It is at this point that many come to the conclusion that the SRP are fairy tales from the pink kingdoms, and they leave the noodles ... </p><br><p>  ... without knowing about the existence of the third definition of Srp: </p><br><p>  " <strong>Similar things for change should be kept in one place</strong> ."  or ‚Äú <strong>What changes together should be kept in one place</strong> ‚Äù </p><br><p>  That is, if we change the operation logging, then we should change it in <strong>one</strong> place. </p><br><p>  This is a very important point - since all the SRP explanations that were above said that it was necessary to split up the types while they were split up, that is, they imposed a "top limit" on the object size, and now we are already talking about the "bottom limit" .  In other words, the <strong>SRP not only requires "to break up while it is being crushed," but also not to overdo it - "not to crush the linked things</strong> . <strong>"</strong>  Do not complicate unnecessarily.  This is the great battle of Occam's razor with the ape-man! </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/778/0d3/aa2/7780d3aa2ce9b489696c55ea792adb3a.jpg" alt="image"></div><br><p>  Now the drinker should be easier.  In addition to not splitting the IPourLogger logger into three classes, we can also combine all loggers into one type: </p><br><pre> <code class="plaintext hljs">class OperationLogger{ public OperationLogger(string operationName){/*..*/} public void LogBefore(object[] args){/*...*/} public void LogAfter(object[] args){/*..*/} public void LogError(object[] args, exception e){/*..*/} }</code> </pre> <br><p>  And if we add the fourth type of operation, then logging is ready for it.  And the code of the operations themselves is clean and free from infrastructural noise. </p><br><p>  As a result, we have 5 classes for solving the problem of drinking: </p><br><ul><li>  Pouring operation </li><li>  Drinking operation </li><li>  Bind operation </li><li>  Logger </li><li>  Facade drinkers </li></ul><br><p>  Each of them is responsible strictly for one functionality, has one reason for the change.  All similar to change the rules are next. </p><br><h2 id="primery-iz-realnoy-zhizni">  Real life examples </h2><br><div class="spoiler">  <b class="spoiler_title">Serialization and deserialization</b> <div class="spoiler_text"><p>  As part of the development of the data transfer protocol, it is necessary to do serialization and deserialization of some type of "User" into a string. </p><br><pre> <code class="plaintext hljs">User{ String Name; Int Age; }</code> </pre> <br><p>  You might think that serialization and deserialization should be done in separate classes: </p><br><pre> <code class="plaintext hljs">UserDeserializer{ String deserialize(User){...} } UserSerializer{ User serialize(String){...} }</code> </pre> <br><p>  Since each of them has its own responsibility and one reason for change. </p><br><p>  But the reason for changing their common is ‚Äúchanging the format of data serialization‚Äù. <br>  And changing this format will always change both serialization and deserialization together. </p><br><p>  According to the principle of localization of changes, we must combine them into one class: </p><br><pre> <code class="plaintext hljs">UserSerializer{ String deserialize(User){...} User serialize(String){...} }</code> </pre> <br><p>  This saves us from unnecessary complexity, and the need to remember that with each change of the serializer, we must also remember about the deserializer. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Count and save</b> <div class="spoiler_text"><p>  You must calculate the company's annual revenue and save it in the file C: \ results.txt. </p><br><p>  Quickly solve this with one method: </p><br><pre> <code class="plaintext hljs">void SaveGain(Company company){ //     //   }</code> </pre> <br><p>  Already from the definition of the task it is clear that there are two subtasks - "Calculate revenue" and "Save revenue".  Each of them has one reason for the changes - "changed counting methods" and "change the format of the preservation."  These changes do not overlap.  Also, we cannot answer the question ‚Äúwhat does the SaveGain method do?‚Äù In a monosyllabic way.  This method counts revenue <strong>and</strong> saves results. </p><br><p>  Therefore it is necessary to divide this method into two: </p><br><pre> <code class="plaintext hljs">Gain CalcGain(Company company){..} void SaveGain(Gain gain){..}</code> </pre> <br><p>  Pros: </p><br><ul><li>  can test CalcGain separately </li><li>  easier to localize bugs and make changes </li><li>  increased readability of the code </li><li>  reduced risk of error in each method due to their simplification </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Difficult business logic</b> <div class="spoiler_text"><p>  Once we wrote an auto b2b client registration service.  And a GOD method appeared with 200 lines of similar content: </p><br><ul><li>  Go to 1C and make an account </li><li>  Go to the payment module with this account and get it there. </li><li>  Check that the account with this account is not created in the main server. </li><li>  Create a new account </li><li>  The result of registration in the payment module and the number 1c add to the service results of registration </li><li>  Add account information to this table. </li><li>  Create a point number for this client in point service.  Transfer to this service account number 1c. </li></ul><br><p>  There were about 10 other business operations with a terrible connection in this list.  The object of the account was needed by almost everyone.  The point identifier and client name were needed in half of the calls. </p><br><p>  After an hour of refactoring, we were able to separate the infrastructure code and some of the nuances of working with the account into separate methods / classes.  The God method got better, but there were 100 lines of code left that didn‚Äôt want to unravel. </p><br><p>  Only a few days later it became clear that the essence of this ‚Äúeasier‚Äù method is the business algorithm.  And that initial description of the TK was rather complicated.  And it is an attempt to break into pieces this method would be a violation of SRP, and not vice versa. </p></div></div><br><h2 id="formalizm">  Formalism. </h2><br><p>  It's time to leave our drinker alone.  Wipe your tears - we will definitely return to it somehow.  And now we formalize the knowledge from this article. </p><br><h4 id="formalizm-1-opredelenie-srp">  Formalism 1. Definition of SRP </h4><br><ol><li>  Separate the elements so that each of them is responsible for one thing. </li><li>  Responsibility stands for "reason for change."  That is, each element has only one reason to change, in terms of business logic. </li><li>  Potential changes in business logic.  must be localized.  Variable items must be nearby. </li></ol><br><h4 id="formalizm-2-neobhodimye-kriterii-samoproverki">  Formalism 2. Necessary self-verification criteria. </h4><br><p>  I have not met sufficient criteria for the implementation of SRP.  But there are necessary conditions: </p><br><p>  1) Ask yourself the question - what does this class / method / module / service do?  you must answer it with a simple definition.  (thanks to <a href="https://habr.com/ru/users/brightori/" class="user_link">Brightori</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">explanations</b> <div class="spoiler_text"><p>  But sometimes it is very difficult to find a simple definition. </p></div></div><br><p>  2) Fixing some bug or adding a new feature affects the minimum number of files / classes.  Ideally, one. </p><br><div class="spoiler">  <b class="spoiler_title">explanations</b> <div class="spoiler_text"><p>  Since the responsibility (for the feature or bug) is encapsulated in one file / class, you know exactly where to look and what to edit.  For example: the feature of changing the output of logging operations will require changing only the logger.  Run around the rest of the code is not required. </p><br><p>  Another example is the addition of a new UI control, similar to the previous ones.  If this forces you to add 10 different entities and 15 different converters - it seems that you have ‚Äúcrushed‚Äù. </p></div></div><br><p>  3) If several developers are working on different features of your project, then the probability of a merge conflict, that is, the likelihood that the same file / class will be changed by several developers at the same time is minimal. </p><br><div class="spoiler">  <b class="spoiler_title">explanations</b> <div class="spoiler_text"><p>  If you add a new operation "Pour vodka under the table", you need to touch the logger, the operation of drinking and pouring - it seems that the responsibilities are divided crookedly.  Of course, this is not always possible, but you should try to reduce this figure. </p></div></div><br><p>  4) For a clarifying question about business logic (from a developer or manager), you climb strictly into one class / file and receive information only from there. </p><br><div class="spoiler">  <b class="spoiler_title">explanations</b> <div class="spoiler_text"><p>  Features, rules or algorithms are compactly written each in one place, and not scattered flags throughout the code space. </p></div></div><br><p>  5) Naming is understandable. </p><br><div class="spoiler">  <b class="spoiler_title">explanations</b> <div class="spoiler_text"><p>  Our class or method is responsible for one thing, and responsibility is reflected in its name. </p><br><p>  AllManagersManagerService - most likely, God-class <br>  LocalPayment - probably not </p></div></div><br><h4 id="formalizm-3-metodika-razrabotki-okkama-first">  Formalism 3. The method of development "Occam-first." </h4><br><p>  At the beginning of the design, the monkey-man does not know and does not feel all the subtleties of the problem being solved and can give a blunder.  You can be mistaken in different ways: </p><br><ul><li>  Make too large objects, sticking together different responsibilities </li><li>  Pererobit, dividing the responsibility for many different types </li><li>  Invalid boundaries </li></ul><br><p>  It is important to remember the rule: ‚Äúit‚Äôs better to err on the big side,‚Äù or ‚Äúnot sure - don‚Äôt split up.  If, for example, your class brings together two responsibilities - then it is still understandable and can be cut into two with minimal change in client code.  Collecting glass from glass fragments is usually more difficult due to the context smeared over several files and the lack of necessary dependencies in the client code. </p><br><h2 id="pora-zakruglyatsya">  Time to wrap up </h2><br><p>  The scope of the SRP is not limited to OOP and SOLID.  It is applicable to methods, functions, classes, modules, microservices, and services.  It is applicable both to figax-figax-and-in-prod, and to ‚Äúrocket seins‚Äù development, making the world a little better everywhere.  If you think about it, then this is almost the fundamental principle of all engineering.  Mechanical engineering, control systems, and indeed all complex systems are built from components, and ‚Äúincomplete crafting‚Äù deprives designers of flexibility, ‚Äúfragmentation‚Äù of efficiency, and incorrect boundaries ‚Äî of reason and peace of mind. </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/getpro/habr/post_images/5a4/13a/5ec/5a413a5ec8447752d1de83982a0fadea.jpg" alt="image"></div><br><p>  SRP is not invented by nature and is not part of exact science.  He gets out of our biological and psychological limitations. This is just a way to control and develop complex systems with the help of the human-monkey's brain.  He tells us how to decompose the system.  The original wording required a fair amount of telepathy, but I hope this article slightly dispelled the smoke screen. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/454290/">https://habr.com/ru/post/454290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45428/index.html">Eloquera - object database with SQL</a></li>
<li><a href="../454280/index.html">Remote development in VS Code: your life will never be the same</a></li>
<li><a href="../454282/index.html">The history of assembling a ‚Äúvillage supercomputer‚Äù from spare parts from eBay, Aliexpress and a computer store. Part 1</a></li>
<li><a href="../454284/index.html">Sorry, but I will not come to work, because now it is winter</a></li>
<li><a href="../45429/index.html">Another PR Shahidjanyan</a></li>
<li><a href="../454292/index.html">Js. Proxy Reef you need to know about</a></li>
<li><a href="../454294/index.html">"Without further experimentation," or how we launched the banking accelerator</a></li>
<li><a href="../454298/index.html">The Standoff: how it was</a></li>
<li><a href="../4543/index.html">Mail.Ru showed that in your pocket</a></li>
<li><a href="../45430/index.html">Umbuster - Advanced Security Umbrella</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>