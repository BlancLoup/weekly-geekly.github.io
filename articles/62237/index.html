<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Random numbers from sound card</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have ever been interested in random numbers. I want to share my experiments on obtaining truly random numbers using the "hardware generator" buil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Random numbers from sound card</h1><div class="post__text post__text-html js-mediator-article">  Many have ever been interested in random numbers.  I want to share my experiments on obtaining truly random numbers using the <b>"hardware generator"</b> built into almost any computer - a <b>sound card</b> . <br><br>  When preparing the material, I rewrote my old C code on Python, so this opus is also an example of using the <b>Windows DLL</b> from Python using the standard <b>ctypes</b> library. <br><br>  At the end of the article the data obtained from the two sound cards <b>Realtek</b> and <b>Audigy 2</b> are compared, the results of statistical tests for randomness are presented. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>UPD</b> Fixed the missing zeros in the code that a UFO ate. <br><a name="habracut"></a><br><h4>  Boring theoretical introduction </h4><br>  Virtually all programming languages ‚Äã‚Äãprovide several functions for generating so-called <b>Pseudo Random Numbers</b> .  PSCS are not random in the mathematical sense of the word, they are obtained by some well-known algorithm and, knowing the initial parameters of the algorithm, the resulting sequence can always be repeated again.  For many problems, a high-quality clock generator can completely replace true random numbers.  Computer games, process modeling, Monte-Carlo integration, genetic algorithms ... a list of tasks for which a sufficiently good frequency response can go on and on. <br><br>  On the other hand, there is a limited range of problems for which the true randomness of the resulting sequence is important.  The main example is cryptography.  It is in the context of encryption that people have always been interested in the issue of obtaining <b>truly random numbers</b> .  The simplest example is the only cipher for which absolute cryptographic robustness is proved, the Vernama cipher (born <i>One-time pad</i> ) requires a sequence of true random numbers for a key equal in length to a secret message.  To ensure cryptographic strength, random data used to generate keys (whether it is the Varnam cipher, AES, RSA, or something else) should never be reused.  Which leads us to the question of finding a reliable source of random numbers. <br><br>  The sound card, unlike most other components of the computer, has in itself not only a digital part, but also an analog one. <br><br>  Consider (primitively) the process of digitizing a sound signal at the line input of a sound card: <br><ol><li>  Initially, we have an electrical signal from some source that carries sound information. </li><li>  The signal enters the analog part of the sound card, where it is amplified to correspond to the dynamic range of the ADC (analog-to-digital converter). </li><li>  The signal is digitized on the ADC with a certain resolution and sampling frequency and enters the digital part of the audio card from where it can already be obtained programmatically. <br></li></ol><br>  We are interested in <b>paragraph 2</b> .  As you know, any analog electrical signal inevitably contains noise, the noise components can be roughly divided into several categories: <br><ul><li>  radio interference and interference from neighboring devices and radio (have you ever heard how badly shielded amplifier catches the radio?) </li><li>  interference power supply (in principle, can also be attributed to interference) </li><li>  thermal noise of random electrons moving in components of an electrical circuit </li></ul><br>  If the randomness of interference and power is a moot point, then the third type of noise is purely quantum and <b>truly random</b> . <br><br>  Actually the question is: how much does this noise penetrate the digital part of the sound card?  Experience shows that yes - penetrates, it can be digitized and saved. <br><br>  In the <b>16-bit</b> recording mode, only the low-order bit from each sample carries random information, while in the 24-bit mode it carries several low-order bits, but the safest thing is to always take only one low-order bit.  How to do this further and will be discussed on the example of Python programs for Windows. <br><br><h5>  Who is not interested in Python: analysis of the results and conclusions at the end, after the description of the program. </h5><br><br><h4>  Sound recording in Windows </h4><br>  The easiest way to record sound in Windows is to use the <b>Waveform Audio</b> interfaces from the <b>winmm.dll</b> library.  There is no standard library for working with sound in Python, so we will use the <b>ctypes</b> library, which provides an interface to regular <b>DLLs</b> . <br><br>  We import the <b>sys</b> libraries (to access the standard output) and <b>time</b> (to access the <i>sleep</i> function).  Also import all names from <b>ctypes</b> . <br><br><blockquote>  <font color="#ff7700">import</font> <font color="#dc143c">sys</font> <br>  <font color="#ff7700">import</font> <font color="#dc143c">time</font> <br>  <font color="#ff7700">from</font> ctypes <font color="#ff7700">import</font> <font color="#66cc66">*</font> </blockquote><br><br>  For C functions that return an integer (usually an error code), Python allows you to specify a function that will check the error code.  We will use this to add minimal error control in the program: if the C-function returns an error, MMSYSERR_NOERROR will cause a Python exception and in the console you will see exactly where the problem is. <br><br>  Then there is a loop that for each function of the <b>winmm.dll</b> library (the Python object windll.winmm is imported from <b>ctypes</b> ) from the list, we create a variable in the current context <u>vars ()</u> , this will allow later access to the function simply by name (waveInOpen instead of windll.winmm .waveInOpen).  We also assign the return type to our ‚Äúcontrolling‚Äù function MMSYSERR_NOERROR. <br><br><blockquote>  <font color="#ff7700">def</font> MMSYSERR_NOERROR <font>(</font> value <font>)</font> : <br>  <font color="#ff7700">if</font> value <font color="#66cc66">!</font>  = <font color="#ff4500">0</font> : <br>  <font color="#ff7700">raise</font> <font color="#008000">Exception</font> <font>(</font> <font color="#483d8b">"Error while running winmm.dll function"</font> , value <font>)</font> <br>  <font color="#ff7700">return</font> value <br><br>  <font color="#ff7700">for</font> funcname <font color="#ff7700">in</font> <font>[</font> <font color="#483d8b">"waveInOpen"</font> , <font color="#483d8b">"waveInPrepareHeader"</font> , <br>  <font color="#483d8b">"waveInAddBuffer"</font> , <font color="#483d8b">"waveInStart"</font> , <br>  <font color="#483d8b">"waveInStop"</font> , <font color="#483d8b">"waveInReset"</font> , <br>  <font color="#483d8b">"waveInUnprepareHeader"</font> , <font color="#483d8b">"waveInClose"</font> <font>]</font> : <br>  <font color="#008000">vars</font> <font>(</font> <font>)</font> <font>[</font> funcname <font>]</font> = windll.  <font>winmm</font> <font>[</font> funcname <font>]</font> <br>  <font color="#008000">vars</font> <font>(</font> <font>)</font> <font>[</font> funcname <font>]</font> .  <font>restype</font> = MMSYSERR_NOERROR </blockquote><br><br>  We define necessary for working with Windows Audio C-structure.  The structure class must inherit from the <u>Structure</u> class imported from <b>ctypes</b> , and must contain the <b>_fields_</b> field, which lists the names and C-types of structure elements.  We imported classes for C-types from <b>ctypes</b> , their names speak for themselves: c_int, c_uint, etc. <br><br>  The first structure WAVEFORMATEX contains information about the format of the sound data.  Without parameters, the constructor will create a structure with typical values ‚Äã‚Äãfor most sound cards: <b>16bit 48kHz mono</b> . <br><br>  The second WAVEHDR describes a buffer for audio data.  As a parameter, the constructor requires an object of the WAVEFORMATEX type and allocates a buffer capable of storing 1 second of audio of this format.  The array of C-characters is created by the function <b>create_string_buffer</b> . <br><br><blockquote>  <font color="#ff7700">class</font> WAVEFORMATEX <font>(</font> Structure <font>)</font> : <br>  WAVE_FORMAT_PCM = <font color="#ff4500">1</font> <br>  _fields_ = <font>[</font> <font>(</font> <font color="#483d8b">"wFormatTag"</font> , c_ushort <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"nChannels"</font> , c_ushort <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"nSamplesPerSec"</font> , c_uint <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"nAvgBytesPerSec"</font> , c_uint <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"nBlockAlign"</font> , c_ushort <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"wBitsPerSample"</font> , c_ushort <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"cbSize"</font> , c_ushort <font>)</font> <font>]</font> <br><br>  <font color="#ff7700">def</font> <font color="#0000cd">__init__</font> <font>(</font> <font color="#008000">self</font> , samples = <font color="#ff4500">48000</font> , bits = <font color="#ff4500">16</font> , channels = <font color="#ff4500">1</font> <font>)</font> : <br>  <font color="#008000">self</font> .  <font>wFormatTag</font> = WAVEFORMATEX.  <font>WAVE_FORMAT_PCM</font> <br>  <font color="#008000">self</font> .  <font>nSamplesPerSec</font> = samples <br>  <font color="#008000">self</font> .  <font>wBitsPerSample</font> = bits <br>  <font color="#008000">self</font> .  <font>nChannels</font> = channels <br>  <font color="#008000">self</font> .  <font>nBlockAlign</font> = <font color="#008000">self</font> .  <font>nChannels</font> <font color="#66cc66">*</font> <font color="#008000">self</font> .  <font>wBitsPerSample</font> / <font color="#ff4500">8</font> <br>  <font color="#008000">self</font> .  <font>nAvgBytesPerSec</font> = <font color="#008000">self</font> .  <font>nBlockAlign</font> <font color="#66cc66">*</font> <font color="#008000">self</font> .  <font>nSamplesPerSec</font> <br>  <font color="#008000">self</font> .  <font>cbSize</font> = <font color="#ff4500">0</font> <br><br>  <font color="#ff7700">class</font> WAVEHDR <font>(</font> Structure <font>)</font> : <br>  _fields_ = <font>[</font> <font>(</font> <font color="#483d8b">"lpData"</font> , POINTER <font>(</font> c_char <font>)</font> <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"dwBufferLength"</font> , c_uint <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"dwBytesRecorded"</font> , c_uint <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"dwUser"</font> , c_uint <font>)</font> , <font color="#808080"># User data dword or pointer</font> <br>  <font>(</font> <font color="#483d8b">"dwFlags"</font> , c_uint <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"dwLoops"</font> , c_uint <font>)</font> , <br>  <font>(</font> <font color="#483d8b">"lpNext"</font> , c_uint <font>)</font> , <font color="#808080"># pointer</font> <br>  <font>(</font> <font color="#483d8b">"reserved"</font> , c_uint <font>)</font> <font>]</font> <font color="#808080"># pointer reserved</font> <br>  <font color="#ff7700">def</font> <font color="#0000cd">__init__</font> <font>(</font> <font color="#008000">self</font> , waveformat <font>)</font> : <br>  <font color="#008000">self</font> .  <font>dwBufferLength</font> = waveformat.  <font>nAvgBytesPerSec</font> <br>  <font color="#008000">self</font> .  <font>lpData</font> = create_string_buffer <font>(</font> <font color="#483d8b">' <font color="#000099">\ 0</font> 00'</font> <font color="#66cc66">*</font> <font color="#008000">self</font> . <font>dwBufferLength</font> <font>)</font> <br>  <font color="#008000">self</font> .  <font>dwFlags</font> = <font color="#ff4500">0</font> </blockquote><br><br>  Next, we create a waveFormat object.  And three buffers for audio data. <br><br>  Unfortunately, with the majority of <b>winmm.dll</b> drivers (because this is a fairly old interface), it doesn‚Äôt allow digitizing more precisely 16 bits even if the audio card supports it.  I know only one card: SB Live24bit, which it could.  Now it is not at hand, but there is an Audigy 2 Notebook, which writes 24 bits only in DirectX or ASIO.  Therefore, today's example is designed for 16 bits (the place that needs to be changed for 24 bits is marked with a comment, in case your card supports it). <br><br><blockquote>  waveFormat = WAVEFORMATEX <font>(</font> samples = <font color="#ff4500">48000</font> , bits = <font color="#ff4500">16</font> <font>)</font> <br>  waveBufferArray = <font>[</font> WAVEHDR <font>(</font> waveFormat <font>)</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">3</font> <font>)</font> <font>]</font> </blockquote><br><br>  The next function is the main one in the program; it will be called by Windows when <b>winmm.dll</b> fills one of our buffers. <br><br>  Tk is a C-callback, you first need to create a class.  This is done by the WINFUNCTYPE function of <b>ctypes</b> , arguments: return type, argument types.  Tk, our function should not return anything, the first argument is <u>None</u> , the rest according to MSDN.  Pay attention to the argument POINTER (c_uint) - this is a pointer to user data, in the example it is just a number, but there could be anything, such as a class indicating where to write data or how much data is needed and so on.  POINTER (WAVEHDR) is a pointer to a data buffer. <br><br>  Parameter <u>uMsg</u> indicates the reason for the call, we are interested in MM_WIM_DATA - audio data is available. <br><br><blockquote> WRITECALLBACK = WINFUNCTYPE <font>(</font> <font color="#008000">None</font> , c_uint, c_uint, POINTER <font>(</font> c_uint <font>)</font> , POINTER <font>(</font> WAVEHDR <font>)</font> , c_uint <font>)</font> <br>  <font color="#ff7700">def</font> pythonWriteCallBack <font>(</font> HandleWaveIn, uMsg, dwInstance, dwParam1, dwParam2 <font>)</font> : <br>  MM_WIM_CLOSE = 0x3BF <br>  MM_WIM_DATA = 0x3C0 <br>  MM_WIM_OPEN = 0x3BE <br>  <font color="#ff7700">if</font> uMsg == MM_WIM_OPEN: <br>  <font color="#ff7700">print</font> <font color="#483d8b">"Open handle ="</font> , HandleWaveIn <br>  <font color="#ff7700">elif</font> uMsg == MM_WIM_CLOSE: <br>  <font color="#ff7700">print</font> <font color="#483d8b">"Close handle ="</font> , HandleWaveIn <br>  <font color="#ff7700">elif</font> uMsg == MM_WIM_DATA: <br>  <font color="#808080">#print "Data handle =", HandleWaveIn</font> <br>  wavBuf = dwParam1.  <font>contents</font> <br>  <font color="#ff7700">if</font> wavBuf.  <font>dwBytesRecorded</font> <font color="#66cc66">&gt;</font> <font color="#ff4500">0</font> : <br>  bits = <font>[</font> <font color="#008000">ord</font> <font>(</font> wavBuf. <font>lpData</font> <font>[</font> i <font>]</font> <font>)</font> <font color="#66cc66">&amp;</font> <font color="#ff4500">1</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">0</font> , wavBuf. <font>dwBytesRecorded</font> , <font color="#ff4500">2</font> <font>)</font> <font>]</font> <br>  <font color="#808080"># for 24 bit: replace at the end of 2 by 3 in the previous line</font> <br>  bias = <font>[</font> bits <font>[</font> i <font>]</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">0</font> , <font color="#008000">len</font> <font>(</font> bits <font>)</font> , <font color="#ff4500">2</font> <font>)</font> <font color="#ff7700">if</font> bits <font>[</font> i <font>]</font> <font color="#66cc66">!</font>  = bits <font>[</font> i + <font color="#ff4500">1</font> <font>]</font> <font>]</font> <br>  <font color="#dc143c">bytes</font> = <font>[</font> <font color="#008000">chr</font> <font>(</font> <font color="#008000">reduce</font> <font>(</font> <font color="#ff7700">lambda</font> v, b: v <font color="#66cc66">&lt;&lt;</font> <font color="#ff4500">1</font> | b, bias <font>[</font> i- <font color="#ff4500">8</font> : i <font>]</font> , <font color="#ff4500">0</font> <font>)</font> <font>)</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">8</font> , <font color="#008000">len</font> <font>(</font> bias <font>)</font> , <font color="#ff4500">8</font> <font>)</font> <font>]</font> <br>  rndstr = <font color="#483d8b">''</font> .  <font>join</font> <font>(</font> <font color="#dc143c">bytes</font> <font>)</font> <br>  <font color="#808080">#print bytes,</font> <br>  <font color="#dc143c">sys</font> .  <font>stdout</font> .  <font>write</font> <font>(</font> rndstr <font>)</font> <br>  <font color="#ff7700">if</font> wavBuf.  <font>dwBytesRecorded</font> == wavBuf.  <font>dwBufferLength</font> : <br>  waveInAddBuffer <font>(</font> HandleWaveIn, dwParam1, sizeof <font>(</font> waveBuf <font>)</font> <font>)</font> <br>  <font color="#ff7700">else</font> : <br>  <font color="#ff7700">print</font> <font color="#483d8b">"Releasing one buffer from"</font> , dwInstance <font>[</font> <font color="#ff4500">0</font> <font>]</font> <br>  dwInstance <font>[</font> <font color="#ff4500">0</font> <font>]</font> - = <font color="#ff4500">1</font> <br>  <font color="#ff7700">else</font> : <br>  <font color="#ff7700">raise</font> <font color="#483d8b">"Unknown message"</font> </blockquote><br><br>  Key points: <br><blockquote>  bits = <font>[</font> <font color="#008000">ord</font> <font>(</font> wavBuf. <font>lpData</font> <font>[</font> i <font>]</font> <font>)</font> <font color="#66cc66">&amp;</font> <font color="#ff4500">1</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">0</font> , wavBuf. <font>dwBytesRecorded</font> , <font color="#ff4500">2</font> <font>)</font> <font>]</font> </blockquote><br>  Tk data is packed by 2 bytes (3 bytes in the case of 24 bits) we go through the array in step 2: <u>range (0, wavBuf.dwBytesRecorded, 2)</u> and select the low-order bit of the lower byte in the pair: <u>ord (wavBuf.lpData [i]) &amp; 1</u> .  The result will be a list of <u>bits of the</u> lower bits of each sample. <br><br><h5>  Minor Methematic Retreat: </h5><br>  Random data may have a different distribution, i.e.  frequency of loss of a particular number.  For example, if we have the sequence of bits 0000100000000, and the position of the unit changes randomly, this is also a random sequence, but it is obvious that the probability of a zero being dropped is much higher than one.  The most convenient so-called.  <b>"Uniform distribution"</b> in which the probability of occurrence of zero and one is equal.  The procedure for bringing to a uniform distribution is called unbiasing.  The simplest method is the replacement: 10 -&gt; 1, 01 -&gt; 0, 11 -&gt; discard, 00 -&gt; discard. <br><br>  Unbiasing performs the next line. <br><blockquote>  bias = <font>[</font> bits <font>[</font> i <font>]</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">0</font> , <font color="#008000">len</font> <font>(</font> bits <font>)</font> , <font color="#ff4500">2</font> <font>)</font> <font color="#ff7700">if</font> bits <font>[</font> i <font>]</font> <font color="#66cc66">!</font>  = bits <font>[</font> i + <font color="#ff4500">1</font> <font>]</font> <font>]</font> </blockquote><br>  We pass in step 2: <u>range (0, len (bits), 2)</u> , throwing out identical pairs: <u>bits [i]! = Bits [i + 1]</u> , from the remaining take the first: bits [i]. <br><br>  Finally, this expression collects our bits in bytes and merges everything into a string. <br><blockquote>  <font color="#dc143c">bytes</font> = <font>[</font> <font color="#008000">chr</font> <font>(</font> <font color="#008000">reduce</font> <font>(</font> <font color="#ff7700">lambda</font> v, b: v <font color="#66cc66">&lt;&lt;</font> <font color="#ff4500">1</font> | b, bias <font>[</font> i- <font color="#ff4500">8</font> : i <font>]</font> , <font color="#ff4500">0</font> <font>)</font> <font>)</font> <font color="#ff7700">for</font> i <font color="#ff7700">in</font> <font color="#008000">range</font> <font>(</font> <font color="#ff4500">8</font> , <font color="#008000">len</font> <font>(</font> bias <font>)</font> , <font color="#ff4500">8</font> <font>)</font> <font>]</font> </blockquote><br>  We pass with step 8, for each 8 bits, the function <u>reduce</u> is called <u>(lambda v, b: v &lt;&lt; 1 | b, bias [i-8: i], 0)</u> .  Here an element of functional programming is used, an anonymous function (let's call it temporarily F) <u>lambda v, b: v &lt;&lt; 1 | b</u> , called by the function reduce: F (... F (F (0, bias [i-8]), bias [i-7]), ..., bias [i-1]) - it turns out a byte, which is converted to a character by the function <u>chr</u> . <br><br>  The list of bytes is converted to a string that is written to <b>stdout</b> , since this binary data is better to redirect the output to a file.  If you want to write to the console, then it is better to do this through " <b>print bytes,</b> ", because with binary output to the console, Wind doesn‚Äôt catch Ctrl + C. <br><br>  At the end of the function it is worth checking whether the buffer has been completely filled.  If yes, then we return it back to the system for filling with the waveInAddBuffer function.  If not, this means that the data output is stopped (the device is closed), we reduce the counter of occupied buffers by one (the counter is stored in user data). <br><br>  Create an instance of the C function of the WRITECALLBACK class from our pythonWriteCallBack function. <br><br>  Next, defining several useful constants, open the WAVE_MAPPER device (you can directly set the sound card number, they are numbered starting from zero: 0, 1, 2) first with the WAVE_FORMAT_QUERY parameter to check that the format is supported, then with the CALLBACK_FUNCTION parameter, specifying our function and user data (in our case, the ExitFlag number). <br><br>  Notice how pointers are passed from Python to the C function using the <b>byref</b> function.  We also passed a pointer to our ‚Äúuser data‚Äù in <u>byref (ExitFlag)</u> , which Windows will send to our callback as <b>dwInstance</b> at every event (eg, buffer filling). <br><br>  Then we call the waveInPrepareHeader for each created buffer and pass them to <b>winmm.dll</b> using waveInAddBuffer.  Finally, the waveInStart (HandleWaveIn) call gives the command to start audio input.  We are waiting for the end in the <u>time.sleep (1)</u> loop. <br><br>  Exit the program by intercepting the Ctrl + C key combination (Python <b>KeyboardInterrupt</b> ). <br><blockquote>  writeCallBack = WRITECALLBACK <font>(</font> pythonWriteCallBack <font>)</font> <br>  <font color="#ff7700">try</font> : <br>  ExitFlag = c_uint <font>(</font> <font color="#ff4500">3</font> <font>)</font> <br>  HandleWaveIn = c_uint <font>(</font> <font color="#ff4500">0</font> <font>)</font> <br>  WAVE_MAPPER = c_int <font>(</font> - <font color="#ff4500">1</font> <font>)</font> <br>  WAVE_FORMAT_QUERY = c_int <font>(</font> <font color="#ff4500">1</font> <font>)</font> <br>  CALLBACK_FUNCTION = c_int <font>(</font> 0x30000 <font>)</font> <br><br>  waveInOpen <font>(</font> <font color="#ff4500">0</font> , WAVE_MAPPER, byref <font>(</font> waveFormat <font>)</font> , <font color="#ff4500">0</font> , <font color="#ff4500">0</font> , WAVE_FORMAT_QUERY <font>)</font> <br>  waveInOpen <font>(</font> byref <font>(</font> HandleWaveIn <font>)</font> , WAVE_MAPPER, byref <font>(</font> waveFormat <font>)</font> , writeCallBack, byref <font>(</font> ExitFlag <font>)</font> , CALLBACK_FUNCTION <font>)</font> <br><br>  <font color="#ff7700">for</font> waveBuf <font color="#ff7700">in</font> waveBufferArray: <br>  waveInPrepareHeader <font>(</font> HandleWaveIn, byref <font>(</font> waveBuf <font>)</font> , sizeof <font>(</font> waveBuf <font>)</font> <font>)</font> <br>  waveInAddBuffer <font>(</font> HandleWaveIn, byref <font>(</font> waveBuf <font>)</font> , sizeof <font>(</font> waveBuf <font>)</font> <font>)</font> <br><br>  waveInStart <font>(</font> HandleWaveIn <font>)</font> <br><br>  <font color="#ff7700">while</font> <font color="#ff4500">1</font> : <br>  <font color="#dc143c">time</font> .  <font>sleep</font> <font>(</font> <font color="#ff4500">1</font> <font>)</font> <br><br>  <font color="#ff7700">except</font> <font color="#008000">KeyboardInterrupt</font> : <br>  waveInReset <font>(</font> HandleWaveIn <font>)</font> <br><br>  <font color="#ff7700">while</font> <font color="#ff4500">1</font> : <br>  <font color="#dc143c">time</font> .  <font>sleep</font> <font>(</font> <font color="#ff4500">1</font> <font>)</font> <br>  <font color="#ff7700">if</font> ExitFlag.  <font>value</font> == <font color="#ff4500">0</font> : <br>  <font color="#ff7700">break</font> <br><br>  <font color="#ff7700">for</font> waveBuf <font color="#ff7700">in</font> waveBufferArray: <br>  waveInUnprepareHeader <font>(</font> HandleWaveIn, byref <font>(</font> waveBuf <font>)</font> , sizeof <font>(</font> waveBuf <font>)</font> <font>)</font> <br><br>  waveInClose <font>(</font> HandleWaveIn <font>)</font> </blockquote><br><br>  To disable automatic end-of-line conversion, the script should be called with the " <b>-u</b> " parameter: <br> <code>c:\...\python.exe -u .py &gt; .rnd</code> <br> <br><h4>  findings </h4><br><br>  You can record without an external signal, just "silence", the low bits still get random values.  Recording without an external signal (source), we get the characteristics of the noise naturally present in the circuits of the sound card.  Another option would be to record some signal, then the noise will be manifested in the digitization errors of the low-order bits. <br><br>  Digitization errors are always there, on the other hand ‚Äúzero‚Äù noise strongly depends on the physical device of the audio card and may not appear on some models.  Further, the results of the analysis of "zero" noise are discussed. <br><br>  The optimal mixer settings for recording, obtained experimentally: choose a recording channel (not playback!) <b>Line-In</b> , loudness of the channel to the maximum, all other channels are turned off. <br><br>  The Microphone channel showed the worst quality of random numbers, which is explained by the fact that many audio cards try to ‚Äúimprove‚Äù the signal from the microphone and use various digital filters.  On one of the tested audio cards (namely, <b>Realtek</b> ), the microphone channel produced an unusable output for the midrange.  On <b>Audigy 2,</b> turning on the Mic Boost + 20DBA microphone gain also removed the random component. <br><br>  You can test the quality of the random numbers obtained using several programs.  Simplest use of ent (download from <a href="">http://www.fourmilab.ch/random/random.zip</a> ).  Runs from console <br> <code>&gt; type data.rnd | ent.exe</code> <br>  Where <u>data.rnd is a</u> binary file with random data (do not forget to comment out extra print'y in the program, they can spoil the statistics a bit).  The optimal file size for the test is approx.  500KB.  The program calculates several parameters: <br><ul><li>  Entropy (for random data: tends to 8 - the number of bits per byte) </li><li>  Arithmetic average (for random data: aspires to 127.5) </li><li>  The number of pi by the Monte Carlo method (for 500kB data an error of the order of 0.1%) </li><li>  Chi-Square (ideally in the range of 10-90%) </li><li>  Ratio (for random data close to 0) </li></ul><br><br>  It should be remembered that randomness criteria are statistical in nature and are not applied to the sequence itself, but to the source.  Therefore, to obtain reliable results, it is necessary to conduct a series of tests on samples of one source.  For example, 20 pieces of 500KB each.  If the majority passed the test (approx. 90%), then the source is random with a certain probability. <br><br>  Unfortunately, there are no 100% criteria in statistics, since  with a certain probability, your sound card can generate this article (actually, this is how I got it - just kidding). <br><br>  Also, I tested the randomness of the ‚Äúzero‚Äù output of both sound cards with the help of a more sophisticated software package from NIST (US National Standards Institute).  Both cards showed good quality random numbers. <br><br>  Interestingly, the built-in audio from <b>Realtek</b> , gives a slightly better uniformity of distribution, apparently due to the lower quality of the ADC and high noise.  <b>Audigy 2</b> would be out of competition in 24-bit mode, which Realtek is not supported (in any case, it needs DirectX, and DirectX in Python is a separate story). <br><br>  Links to other test packages: <br>  <a href="http://stat.fsu.edu/pub/diehard/">http://stat.fsu.edu/pub/diehard/</a> <br>  <a href="http://www.phy.duke.edu/~rgb/General/dieharder.php">http://www.phy.duke.edu/~rgb/General/dieharder.php</a> <br>  <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html">http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html</a> <br><br>  An example of the output of the program <b>ent</b> on a file obtained by recording silence from the <b>Audigy 2</b> line input: <br> <code>Entropy = 7.999609 bits per byte. <br> <br> Optimum compression would reduce the size <br> of this 500000 byte file by 0 percent. <br> <br> Chi square distribution for 500000 samples is 270.78, and randomly <br> would exceed this value 23.75 percent of the times. <br> <br> Arithmetic mean value of data bytes is 127.5890 (127.5 = random). <br> Monte Carlo value for Pi is 3.139644559 (error 0.06 percent). <br> Serial correlation coefficient is 0.001109 (totally uncorrelated = 0.0).</code> </div><p>Source: <a href="https://habr.com/ru/post/62237/">https://habr.com/ru/post/62237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../62230/index.html">Preparation of articles for Habr: Markdown extension + syntax highlighting + loading images</a></li>
<li><a href="../62232/index.html">Some useful aspects for PostSharp</a></li>
<li><a href="../62233/index.html">Why is it Opera Unite?</a></li>
<li><a href="../62234/index.html">Global network of discussions and comments</a></li>
<li><a href="../62235/index.html">Do I need a diploma from the university?</a></li>
<li><a href="../62238/index.html">How I raised my site traffic</a></li>
<li><a href="../62243/index.html">My struggle with devaluation</a></li>
<li><a href="../62245/index.html">Monetizing Facebook Fan Pages</a></li>
<li><a href="../62247/index.html">Coordination of design in the project by the customer - errors and their solutions</a></li>
<li><a href="../62250/index.html">For the first time in world practice: the army of Israel will adopt a snake robot!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>