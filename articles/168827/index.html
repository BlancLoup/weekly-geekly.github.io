<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Type conversion to Boost.Python. We do the conversion between the usual types of C + + and Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is not a continuation of the story about wrappers C ++ API. There will be no wrappers today. Although the logic is the third part of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Type conversion to Boost.Python. We do the conversion between the usual types of C + + and Python</h1><div class="post__text post__text-html js-mediator-article">  This article is not a continuation of the story about wrappers C ++ API.  There will be no wrappers today.  Although the logic is the third part of <a href="http://habrahabr.ru/post/168083/">the</a> <a href="http://habrahabr.ru/post/168233/">story</a> . <br>  Today there will be a sea of ‚Äã‚Äãblood, the dismemberment of existing types and the magical transformation of them into familiar analogs in another language. <br>  We will not talk about the existing conversion between the lines, no, we will write our converters. <br>  We will transform the usual <b>Python datetime.datetime</b> into <b>boost :: posix_time :: ptime of</b> the Boost library and vice versa, but to hell with it, we will turn the entire datetime library into booster types!  And in order not to be boring, we sacrifice the built-in class of the Python 3.x byte array, for it there is just no converter in Boost.Python, and then brutally use the conversion of the byte array in the new python converter <b>uuid.UUID</b> to <b>boost :: uuids: : uuid</b> .  Yes, the converter can be used in the converter! <br>  Do you crave blood, Colosseum?! .. <br><a name="habracut"></a><br><h4>  Table of contents </h4><br><ul><li>  <a href="http://habrahabr.ru/post/168083/">Combining C ++ and Python.</a>  <a href="http://habrahabr.ru/post/168083/">Subtleties Boost.Python.</a>  <a href="http://habrahabr.ru/post/168083/">Part one</a> </li><li>  <a href="http://habrahabr.ru/post/168233/">Combining C ++ and Python.</a>  <a href="http://habrahabr.ru/post/168233/">Subtleties Boost.Python.</a>  <a href="http://habrahabr.ru/post/168233/">Part two</a> </li><li>  <a href="http://habrahabr.ru/post/168827/">Type conversion to Boost.Python.</a>  <a href="http://habrahabr.ru/post/168827/">We do the conversion between the usual types of C + + and Python</a> </li><li>  <a href="http://habrahabr.ru/post/169639/">Exception travel between C ++ and Python, or "Back and forth"</a> </li></ul><br><h4>  Instead of introducing </h4><br>  If someone did not notice, Boost.Python does a great job turning a bunch of scalars into objects of the Python classes of the appropriate type.  If you want to compare, write on pure C, use the C-API directly, let it communicate your brain.  Spend a lot of time to understand the comfort of modern technology, the convenience of an easy chair, the need for a hot tub and a remote control for a TV.  Fans of wooden shops, washing in ice holes and torches, let them continue to engage in cheap popular art. <br>  So, there is such a thing: built-in converters in Boost.Python are built-in type converters from Python to C ++ and back, which are partially implemented in $ (BoostPath) \ libs \ python \ src \ converter and $ (BoostPath) \ boost \ python \ converter.  There are many of them, they solve about 95% of the problems when working with the built-in types of Python and C ++, there is string conversion, <a href="http://habrahabr.ru/post/161931/">not ideal of course</a> , but if in C ++ we work with UTF-8 strings or wide-strings, then everything will be fast, qualitatively and discreetly, in the sense of convenient to use. <br>  Almost everything that is not done by the built-in converters is solved by wrappers of your classes.  Boost.Python offers a truly monstrously simple way to describe class wrappers, in the form of a meta-language that even looks like a Python class: <br><pre><code class="cpp hljs">class_&lt;Some&gt;( <span class="hljs-string"><span class="hljs-string">"Some"</span></span> ) .def( <span class="hljs-string"><span class="hljs-string">"method_A"</span></span>, &amp;Some::method_A, args( <span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">"y"</span></span>, <span class="hljs-string"><span class="hljs-string">"z"</span></span> ) ) .def( <span class="hljs-string"><span class="hljs-string">"method_B"</span></span>, &amp;Some::method_B, agrs( <span class="hljs-string"><span class="hljs-string">"u"</span></span>, <span class="hljs-string"><span class="hljs-string">"v"</span></span> ) ) ;</code> </pre> <br>  Everything is great, but there is one thing ... <br>  ... one big and wonderful thing: both C ++ and Python are languages ‚Äã‚Äãwith their own libraries.  In C ++ <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/date_time.hpp&gt; #include &lt;boost/uuid/uuid.hpp&gt;</span></span></span></span></code> </pre><br>  is a de facto analog in Python: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid</code> </pre><br>  So, a lot of things in your C ++ code can already be tied to work, for example, with the class <b>boost :: gregorian :: date</b> , and in Python, in turn, a lot is tied to the <b>datetime.date</b> class, its equivalent.  Working in Python with the class wrapper <b>boost :: gregorian :: date</b> , wrapped with all methods, operator overloading and trying to stick its instances instead of the usual <b>datetime.date</b> - I don‚Äôt even know what it is called, it‚Äôs not a crutch, it‚Äôs dancing with a grenade.  And this grenade will jerk, gentlemen of the jury.  On the Python side, you need to work with the built-in date and time library. <br>  If you read this, and look at your code, where you extract extract datetime Python fields in C ++, there‚Äôs nothing stupid to smile, everything described in the paragraph above applies to you to no less degree.  Even if you have a mega-class of date / time in C ++, it is better to write a type converter, rather than pull them one field away in some kind of cycling method. <br>  In general, if Python has its own type, and C ++ has its own well-established type that implements the basic logic with a similar functional component, then you need a converter. <br>  You really need a converter. <br><br><h4>  What is a converter </h4><br>  A converter is a kind of conversion registered in Boost.Python from C ++ type to Python type or vice versa.  On the C ++ side, you use familiar types, in full confidence that in Python this will be the appropriate type.  Actually, converters are usually written in both directions, but it is much easier to write a conversion from C ++ to Python, you will see.  The whole point is that creating an instance in C ++ requires memory, which is often a non-trivial task.  Creating an object in Python is an extremely easy task, so let's start with a conversion from C ++ to Python. <br><br><h4>  Type conversion from C ++ to Python </h4><br>  To convert from C ++ to Python, you need a structure that has a static <b>convert</b> method that accepts a reference to a type in C ++ and returns <b>PyObject</b> *, a common type for any object used in the C-API of the Python language and as a stuffing object boost :: python :: object. <br>  Let's immediately get a template structure, because we want mass slaughter: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_into_python</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> PyObject* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span></span>; };</code> </pre><br>  All that is required is to implement, for example, for the type boost :: posix_time :: ptime, the method of specialization of the template structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; PyObject* type_into_python&lt;ptime&gt;::convert( ptime <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; );</code> </pre><br>  and register a converter when declaring a module inside a <b>BOOST_PYTHON_MODULE</b> : <br><pre> <code class="cpp hljs"> to_python_converter&lt; ptime, type_into_python&lt;ptime&gt; &gt;();</code> </pre><br>  Well, well, since I said Az, let's tell you and Buki.  The implementation of the converter for boost :: posix_time :: ptime will look something like this: <br><pre> <code class="cpp hljs">PyObject* type_into_python&lt;ptime&gt;::convert( ptime <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; t ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d = t.date(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tod = t.time_of_day(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> usec = tod.total_microseconds() % <span class="hljs-number"><span class="hljs-number">1000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyDateTime_FromDateAndTime( d.year(), d.month(), d.day(), tod.hours(), tod.minutes(), tod.seconds(), usec ); }</code> </pre><br>  <b>Important!</b>  When registering a module, we definitely need to <u>connect</u> <b>datetime</b> via the C-API: <br><pre> <code class="cpp hljs"> PyDateTime_IMPORT; to_python_converter&lt; ptime, type_into_python&lt;ptime&gt; &gt;();</code> </pre><br>  Without the <b>PyDateTime_IMPORT</b> string <b>,</b> nothing will take off. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, we are lucky that the Python C-API has a ready-made function for creating PyObject * for a new <b>datetime.datetime</b> by its parameters, essentially an analogue of the constructor for the datetime class.  And it‚Äôs not lucky that Boost has such a ‚Äúfun‚Äù API for the <b>ptime</b> class.  The class turned out to be not completely independent, you have to pull out the date and time from it, which are separate components there, and time is represented as <b>time_duration</b> - the analog is not so much a datetime.time, but rather a datetime.timedelta!  This, in general, will not allow one-to-one representation of the datetime library types in C ++. Well, the fact that <b>boost :: posix_time :: time_duration</b> does not provide direct access to microseconds and milliseconds is completely unpleasant.  Instead, you have to either "cunningly" work with the fractional_seconds () method, or stupidly make a terrible thing - to take the module total_microseconds ()% 1,000,000. Worse, I have not decided yet, I don‚Äôt like how <b>time_duration</b> is <b>done</b> .  We will make the datetime.time class for it, and we will not touch another similar datetime.timedelta class yet. <br><br><h4>  Convert from Python to C ++ </h4><br>  Hehe, my friends, this is a really complicated point.  Stock up with validol, fasten your seat belts. <br>  Everything seems to be exactly the same: we make a structure template with two methods convertible and construct - the ability to convert and type constructor in C ++.  Actually all the same as the methods are called, the main thing is to refer to them when registering, it is most convenient to do this in the constructor of our template structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_from_python</span></span></span><span class="hljs-class"> {</span></span> type_from_python() { converter::registry::push_back( convertible, construct, type_id&lt;T&gt;() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PyObject* )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PyObject*, converter::rvalue_from_python_stage1_data* )</span></span></span></span>; };</code> </pre><br>  Actually, when a module is declared, it will be enough to call the constructor of this structure.  Well, of course, you need to implement these methods for each convertible type, for example, for ptime: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;ptime&gt;::convertible( PyObject* ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;ptime&gt;::construct( PyObject*, converter::rvalue_from_python_stage1_data* );</code> </pre><br>  Let's immediately look at the implementation of the convertibility check method and the ptime design method: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;ptime&gt;::convertible( PyObject* obj ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyDateTime_Check( obj ) ? obj : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;ptime&gt;::construct( PyObject* obj, converter::rvalue_from_python_stage1_data* data ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> storage = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; converter::rvalue_from_python_storage&lt;ptime&gt;* &gt;( data )-&gt;storage.bytes; <span class="hljs-function"><span class="hljs-function">date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">date_only</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PyDateTime_GET_YEAR( obj ), PyDateTime_GET_MONTH( obj ), PyDateTime_GET_DAY( obj ) )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">time_duration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time_of_day</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PyDateTime_DATE_GET_HOUR( obj ), PyDateTime_DATE_GET_MINUTE( obj ), PyDateTime_DATE_GET_SECOND( obj ) )</span></span></span></span>; time_of_day += microsec( PyDateTime_DATE_GET_MICROSECOND( obj ) ); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(storage) ptime( date_only, time_of_day ); data-&gt;convertible = storage; }</code> </pre><br>  With the <b>convertible</b> method, everything is clear: you <b>datetime</b> - <b>go through</b> , no - <b>nullptr</b> and exit. <br>  But the <b>construct</b> method will be just as furious for absolutely <u>every</u> type! <br>  Even if you have your own type of MyDateTime, you <u>will</u> have <u>to</u> create it in place via <b>placing new</b> where you will be given to place it!  You see this funny operator: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(storage) ptime( date_only, time_of_day );</code> </pre><br>  This is posting new.  It creates your new object in the specified location.  This is the place we need to calculate, we are offered the following way to get the desired pointer: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> storage = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; converter::rvalue_from_python_storage&lt;ptime&gt;* &gt;( data )-&gt;storage.bytes;</code> </pre><br>  I will not comment on this.  Just remember. <br>  All the rest is additional calculations to call the understandable constructor of the non-dependent class ptime. <br>  Do not forget to fill in another field at the end: <br><pre> <code class="cpp hljs"> data-&gt;convertible = storage;</code> </pre><br>  Again, I don‚Äôt know how to name it more simply, just remember that this is important and you need to fill in the field.  Think of it as an unpleasant trifle before universal happiness. <br>  Examples of how it is done by someone other than me can be found <a href="http://misspent.wordpress.com/2009/09/27/how-to-write-boost-python-converters/">here</a> , <a href="http://code.activestate.com/lists/python-cplusplus-sig/16463/">here</a> and <a href="http://www.boost.org/doc/libs/1_39_0/libs/python/doc/v2/faq.html">here on the website Boost.Python in the FAQ section</a> . <br><br><h4>  Converting datetime types to &lt;boost / date_time.hpp&gt; and back </h4><br>  So for date and time separately, everything is pretty simple.  Thanks to our template structure, we just need to add the implementation for the date and time_duration of the following specialization methods of our template structures: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; PyObject* type_into_python&lt;date&gt;::convert( date <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;date&gt;::convertible( PyObject* ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;date&gt;::construct( PyObject*, converter::rvalue_from_python_stage1_data* ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; PyObject* type_into_python&lt;time_duration&gt;::convert( time_duration <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;time_duration&gt;::convertible( PyObject* ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;time_duration&gt;::construct( PyObject*, converter::rvalue_from_python_stage1_data* );</code> </pre><br>  The task is simple, it comes down to splitting the previous methods into pairs for date and time separately. <br>  For <b>boost :: gregorian :: date</b> and <b>datetime.date</b> : <br><pre> <code class="cpp hljs">PyObject* type_into_python&lt;date&gt;::convert( date <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; d ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyDate_FromDate( d.year(), d.month(), d.day() ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;date&gt;::convertible( PyObject* obj ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyDate_Check( obj ) ? obj : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;date&gt;::construct( PyObject* obj, converter::rvalue_from_python_stage1_data* data ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> storage = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; converter::rvalue_from_python_storage&lt;date&gt;* &gt;( data )-&gt;storage.bytes; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(storage) date( PyDateTime_GET_YEAR( obj ), PyDateTime_GET_MONTH( obj ), PyDateTime_GET_DAY( obj ) ); data-&gt;convertible = storage; }</code> </pre><br>  And for <b>boost :: posix_time :: time_duration</b> and <b>datetime.time</b> : <br><pre> <code class="cpp hljs">PyObject* type_into_python&lt;time_duration&gt;::convert( time_duration <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; t ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> usec = t.total_microseconds() % <span class="hljs-number"><span class="hljs-number">1000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyTime_FromTime( t.hours(), t.minutes(), t.seconds(), usec ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;time_duration&gt;::convertible( PyObject* obj ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyTime_Check( obj ) ? obj : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;time_duration&gt;::construct( PyObject* obj, converter::rvalue_from_python_stage1_data* data ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> storage = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; converter::rvalue_from_python_storage&lt;time_duration&gt;* &gt;( data )-&gt;storage.bytes; time_duration* t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(storage) time_duration( PyDateTime_TIME_GET_HOUR( obj ), PyDateTime_TIME_GET_MINUTE( obj ), PyDateTime_TIME_GET_SECOND( obj ) ); *t += microsec( PyDateTime_TIME_GET_MICROSECOND( obj ) ); data-&gt;convertible = storage; }</code> </pre><br>  Registration of all this stuff in our module will look like this: <br><pre> <code class="cpp hljs">BOOST_PYTHON_MODULE( ... ) { ... PyDateTime_IMPORT; to_python_converter&lt; ptime, type_into_python&lt;ptime&gt; &gt;(); type_from_python&lt; ptime &gt;(); to_python_converter&lt; date, type_into_python&lt;date&gt; &gt;(); type_from_python&lt; date &gt;(); to_python_converter&lt; time_duration, type_into_python&lt;time_duration&gt; &gt;(); type_from_python&lt; time_duration &gt;(); ... }</code> </pre><br><br><h4>  We check the work with the conversion of the date and time </h4><br>  It's time to check in our megaconversion, let's get all sorts of unnecessary functions that take the date / time at the entrance and return the date / time at the exit. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ptime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tomorrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ptime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">day_before</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ptime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; the_moment )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last_day_of_this_month</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">year_after</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( date </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; the_day )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">time_duration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delta_between</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ptime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; at, ptime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; to )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">time_duration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus_midday</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( time_duration </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; the_moment )</span></span></span></span>;</code> </pre><br>  We declare them in our module to call from Python: <br><pre> <code class="cpp hljs"> def( <span class="hljs-string"><span class="hljs-string">"tomorrow"</span></span>, tomorrow ); def( <span class="hljs-string"><span class="hljs-string">"day_before"</span></span>, day_before, args( <span class="hljs-string"><span class="hljs-string">"moment"</span></span> ) ); def( <span class="hljs-string"><span class="hljs-string">"last_day_of_this_month"</span></span>, last_day_of_this_month ); def( <span class="hljs-string"><span class="hljs-string">"year_after"</span></span>, year_after, args( <span class="hljs-string"><span class="hljs-string">"day"</span></span> ) ); def( <span class="hljs-string"><span class="hljs-string">"delta_between"</span></span>, delta_between, args( <span class="hljs-string"><span class="hljs-string">"at"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span> ) ); def( <span class="hljs-string"><span class="hljs-string">"plus_midday"</span></span>, plus_midday, args( <span class="hljs-string"><span class="hljs-string">"moment"</span></span> ) );</code> </pre><br>  The way these our functions do the following (although in reality it is no longer important, the types of input / output are important): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ptime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tomorrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> microsec_clock::local_time() + days( <span class="hljs-number"><span class="hljs-number">1</span></span> ); } <span class="hljs-function"><span class="hljs-function">ptime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">day_before</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ptime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; that )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that - days( <span class="hljs-number"><span class="hljs-number">1</span></span> ); } <span class="hljs-function"><span class="hljs-function">date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last_day_of_this_month</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ date today = day_clock::local_day(); date next_first_day = (today.month() == Dec) ? date( today.year() + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ) : date( today.year(), today.month() + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next_first_day - days( <span class="hljs-number"><span class="hljs-number">1</span></span> ); } <span class="hljs-function"><span class="hljs-function">date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">year_after</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( date </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; the_day )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> the_day + years( <span class="hljs-number"><span class="hljs-number">1</span></span> ); } <span class="hljs-function"><span class="hljs-function">time_duration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delta_between</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ptime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; at, ptime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; to )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> to - at; } <span class="hljs-function"><span class="hljs-function">time_duration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus_midday</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( time_duration </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; the_moment )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time_duration( <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ) + the_moment; }</code> </pre><br>  In particular, here is such a simple script (in Python 3.x): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> someconv <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment"># test datetime.datetime &lt;=&gt; boost::posix_time::ptime t = tomorrow(); print( 'Tomorrow at same time:', t ) for _ in range(3): t = day_before(t); print( 'Day before that moment:', t ) # test datetime.date &lt;=&gt; boost::gregorian::date d = last_day_of_this_month(); print( 'Last day of this month:', d ) for _ in range(3): d = year_after(d); print( 'Day before that day:', d ) # test datetime.time &lt;=&gt; boost::posix_time::time_duration at = datetime.now() to = at + timedelta( seconds=12*60*60 ) dt = delta_between( at, to ) print( "Delta between '{at}' and '{to}' is '{dt}'".format( at=at, to=to, dt=dt ) ) t0 = time( 6, 30, 0 ) t1 = plus_midday( t0 ) print( t0, "plus midday is:", t1 )</span></span></code> </pre><br>  It should work out correctly and end with something like this, with the output of correct dates and times.  The test script will of course be attached.  (I do not write a conclusion, so as not to burn what time it was written!) <br>  You can, in principle, not be shy and write your test functions, they will all work as it should, if you did everything correctly. <br>  As a last resort, at the end I‚Äôll post a link to the project along with a test script. <br><br><h4>  Byte array as vector bytes in C ++ </h4><br>  Generally speaking, the example below is extremely harmful.  A standard std :: vector pattern with a bit lower than int will be extremely inefficient.  Losing when copying and, as a result, with vector :: resize () will be catastrophic, simply because copying will be element-wise.  With all optimizations enabled, this will lead to losses of up to 170% with simple copying compared to memcpy () (measured in the MSVS v10 Release Build).  Which is not particularly pleasant for a frequently used code fragment.  Especially when copying is not visible, and sometimes resize () implicitly occurs.  There are "interesting" subsidence in performance, in the sense that there will be something to do, catching the brakes in a large system. <br><br>  The example below is purely academic, if you need a manic code optimization somewhere and you are writing a part of the C ++ module code.  If you are on performance, feel free to use this conversion. <br>  For Python 2.x, this section is irrelevant in principle.  Then byte arrays were called strings.  It will be <a href="http://wiki.python.org/moin/boost.python/EmbeddingPython">much</a> more interesting to read about working with unicode and converting it to the standard C ++ string <a href="http://wiki.python.org/moin/boost.python/EmbeddingPython">here in PyWiki</a> . <br>  But for Python 3.x, this conversion will reduce the huge piece of code with a bunch of C-APIs before using the usual vector ( <b>byte</b> is an unsigned 8-bit integer - <b>uint8_t</b> ). <br><br>  So, again use our wonderful patterned structures and rejoice: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;byte&gt; byte_array; ... <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; PyObject* type_into_python&lt;byte_array&gt;::convert( byte_array <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;byte_array&gt;::convertible( PyObject* ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;byte_array&gt;::construct( PyObject*, converter::rvalue_from_python_stage1_data* );</code> </pre><br>  We also add the registration of converters to the ad of our module: <br><pre> <code class="cpp hljs">BOOST_PYTHON_MODULE( ... ) { ... to_python_converter&lt; byte_array, type_into_python&lt;byte_array&gt; &gt;(); type_from_python&lt; byte_array &gt;(); }</code> </pre><br>  And the simplest implementation, we simply use the C-API knowledge of the PyBytes object and work with the methods of std :: vector: <br><pre> <code class="cpp hljs">PyObject* type_into_python&lt;byte_array&gt;::convert( byte_array <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ba ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* src = ba.empty() ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;( &amp;ba.front() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyBytes_FromStringAndSize( src, ba.size() ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;byte_array&gt;::convertible( PyObject* obj ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyBytes_Check( obj ) ? obj : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;byte_array&gt;::construct( PyObject* obj, converter::rvalue_from_python_stage1_data* data ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> storage = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; converter::rvalue_from_python_storage&lt;byte_array&gt;* &gt;( data )-&gt;storage.bytes; byte* dest; Py_ssize_t len; PyBytes_AsStringAndSize( obj, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**&gt;( &amp;dest ), &amp;len ); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(storage) byte_array( dest, dest + len ); data-&gt;convertible = storage; }</code> </pre><br>  It is unlikely that additional comments will be required, for knowledge of the C-API of the PyBytes object I will send <a href="http://docs.python.org/3/c-api/bytes.html%3Fhighlight%3Dpybytes">here</a> . <br><br><h4>  Convert uuid.UUID to boost :: uuids :: uuid and back </h4><br>  You will laugh, but we have so simplified our work by creating those two templates at the very beginning, which, again, everything will be reduced to the implementation of the three methods: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::uuids; ... <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; PyObject* type_into_python&lt;uuid&gt;::convert( uuid <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;uuid&gt;::convertible( PyObject* ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;uuid&gt;::construct( PyObject*, converter::rvalue_from_python_stage1_data* );</code> </pre><br>  Usually we add two new lines to the module's ad - registration of the conversion back and forth: <br><pre> <code class="cpp hljs"> to_python_converter&lt; uuid, type_into_python&lt;uuid&gt; &gt;(); type_from_python&lt; uuid &gt;();</code> </pre><br>  And now the most interesting thing is that the C-API will not help us here, rather it will prevent, the easiest way is to act through the boost :: python :: import module of the python ‚Äúuuid‚Äù itself and the ‚ÄúUUID‚Äù class of the same module. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> object py_uuid = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>( <span class="hljs-string"><span class="hljs-string">"uuid"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> object py_uuid_UUID = py_uuid.attr( <span class="hljs-string"><span class="hljs-string">"UUID"</span></span> ); PyObject* type_into_python&lt;uuid&gt;::convert( uuid <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; u ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incref( py_uuid_UUID( object(), byte_array( u.data, u.data + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(u.data) ) ).ptr() ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* type_from_python&lt;uuid&gt;::convertible( PyObject* obj ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PyObject_IsInstance( obj, py_uuid_UUID.ptr() ) ? obj : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> type_from_python&lt;uuid&gt;::construct( PyObject* obj, converter::rvalue_from_python_stage1_data* data ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> storage = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; converter::rvalue_from_python_storage&lt;uuid&gt;* &gt;( data )-&gt;storage.bytes; byte_array ba = extract&lt;byte_array&gt;( object( handle&lt;&gt;( borrowed( obj ) ) ).attr( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> ) ); uuid* res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(storage) uuid; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( res-&gt;data, &amp;ba.front(), ba.size() ); data-&gt;convertible = storage; }</code> </pre><br>  Sorry to use global variables, this is usually done in a singleton with Py_Initialize () and Py_Finalize () in the constructor and destructor, respectively.  But since here we have a purely training example and are only used from Python so far, then you can get by with this approach, forgive again, but the code is clearer. <br><br>  Since the behavior in these methods is very different from all of the above, it is necessary to describe in more detail what is actually happening. <br>  In py_uuid, we saved the object of the connected uuid module from the standard Python library. <br>  In py_uuid_UUID, we saved an object of class uuid.UUID.  It is the class itself as such.  Applying parentheses to this object will result in a call to the constructor and the creation of an object of this type.  What we will do later.  However, this class itself is still useful for the convertible method - checking the type of the argument whether an object is a UUID. <br><br>  In the direction of Python from C ++, everything is clear - we simply call the constructor, pass the first parameter <b>None</b> (the <i>default constructor boost :: python :: object will create just <b>None</b></i> ), the second leaves our byte array from the previous section.  If your Python 2.x code changes a bit and is simplified, it is enough to pass a string and pretend that it is a byte array. <br><br>  When checking a Python object for convertibility, the PyObject_IsInstance () function helps us a lot. <br>  We take the PyObject * pointer of type uuid.UUID using the ptr () method of class boost :: python :: object.  This is where the class object itself came in handy.  In fact, classes in Python are the same objects.  And this is great.  Thank you for such a logical and understandable language. <br><br>  Here is the conversion code from Python to C ++, nothing is clear what is happening on this line: <br><pre> <code class="cpp hljs"> byte_array ba = extract&lt;byte_array&gt;( object( handle&lt;&gt;( borrowed( obj ) ) ).attr( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> ) );</code> </pre><br>  Here, in fact, everything is extremely simple.  From the uuid.UUID object that came as PyObject *, we create a full-fledged boost :: python :: object.  Pay attention to the handle &lt;&gt; ( <b>borrowed</b> (obj)) construction - it is very important not to lose the borrowed call, otherwise our fresh object will crash into the destructor of the transferred object. <br>  So, we have obtained from object PyObject * boost :: python :: object by reference to an argument of type uuid.UUID.  We take the attribute <b>bytes</b> from our object, pull out from it byte_array through extract.  Everything, we have content. <br>  Fans can do everything through serialization-deserialization can search through conversion to string and back.  Any lexical_cast () to help them and a stone around his neck.  Remember that string creation and serialization in C ++ is in fact a very expensive operation. <br>  Python 2.x users will immediately get the bytes as a string.  Such before there were lines, as well as in C / C ++, in fact through char *. <br>  In general, everything is simple further, fill in the array, sorry for unsafe copying, and transfer the filled object back to C ++. <br><br><h4>  We check the operation of the byte and UUID transformations </h4><br>  Let's get some more functions that drive our types back and forth between C ++ and Python: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">byte_array </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_to_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span></span>; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bytes_to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( byte_array </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">uuid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">byte_array </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uuid </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span></span>;</code> </pre><br>  We describe them in our module to call from Python: <br><pre> <code class="cpp hljs">BOOST_PYTHON_MODULE( someconv ) { ... def( <span class="hljs-string"><span class="hljs-string">"string_to_bytes"</span></span>, string_to_bytes, args( <span class="hljs-string"><span class="hljs-string">"src"</span></span> ) ); def( <span class="hljs-string"><span class="hljs-string">"bytes_to_string"</span></span>, bytes_to_string, args( <span class="hljs-string"><span class="hljs-string">"src"</span></span> ) ); def( <span class="hljs-string"><span class="hljs-string">"random_uuid"</span></span>, random_uuid ); def( <span class="hljs-string"><span class="hljs-string">"uuid_bytes"</span></span>, uuid_bytes, args( <span class="hljs-string"><span class="hljs-string">"src"</span></span> ) ); ... }</code> </pre><br>  Actually their behavior is not so important, but let's honestly describe their implementation for clarity of the result: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">byte_array </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_to_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> byte_array( src.begin(), src.end() ); } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bytes_to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( byte_array </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>( src.begin(), src.end() ); } <span class="hljs-function"><span class="hljs-function">uuid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> random_generator gen_uuid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen_uuid(); } <span class="hljs-function"><span class="hljs-function">byte_array </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uuid </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> byte_array( src.data, src.data + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(src.data) ); }</code> </pre><br>  In general, such a test script (in Python 3.x): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> someconv <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * ... <span class="hljs-comment"><span class="hljs-comment"># test bytes &lt;=&gt; std::vector&lt;uint8_t&gt; print( bytes_to_string( b"I_must_be_string" ) ) print( string_to_bytes( "I_must_be_byte_array" ) ) print( bytes_to_string( " - !".encode() ) ) print( string_to_bytes( " - !" ).decode() ) print( bytes_to_string( string_to_bytes( " -  !" ) ) ) # test uuid.UUID &lt;=&gt; boost::uuids::uuid u = random_uuid() print( 'Generated UUID (C++ module):', uuid_bytes(u) ) print( 'Generated UUID (in Python): ', u.bytes)</span></span></code> </pre><br>  Must correctly work out and produce the result of something like: <br><pre> <code class="python hljs">I_must_be_string <span class="hljs-string"><span class="hljs-string">b'I_must_be_byte_array'</span></span> - ! - ! -  ! Generated UUID (C++ module): <span class="hljs-string"><span class="hljs-string">b'\xf1B\xdb\xa9&lt;lL\x9d\x9a\xfd\xf3\xe9\x9f\xa6\x9aT'</span></span> Generated UUID (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Python): <span class="hljs-string"><span class="hljs-string">b'\xf1B\xdb\xa9&lt;lL\x9d\x9a\xfd\xf3\xe9\x9f\xa6\x9aT'</span></span></code> </pre><br>  By the way, if you take and remove the borrowed from the UUID from Python in C ++ for verification, drop exactly on the last line, since the object will already be destroyed and there will be nothing to take the bytes property. <br><br><h4>  Total </h4><br>  We have learned not only to write converters, but also to generalize them, to reduce labor costs when writing them to a minimum and to use one of the other.  Actually, we already know what it is, how to use it and where it is vital. <br>  The link to the project is <a href="http://www.2shared.com/file/lULxBoyM/someconv.html">here (~ 207 KB)</a> .  The MSVS v11 project is configured to build with Python 3.3 x64. <br><br><h4>  useful links </h4><br>  <a href="http://www.boost.org/doc/libs/1_52_0/libs/python/doc/">Boost.Python Documentation</a> <br>  <a href="http://misspent.wordpress.com/2009/09/27/how-to-write-boost-python-converters/">How to write a string converter</a> <br>  <a href="http://wiki.python.org/moin/boost.python/EmbeddingPython">Unicode to Python 2.x conversion</a> <br>  <a href="http://code.activestate.com/lists/python-cplusplus-sig/16463/">Converting arrays between C ++ and Python</a> <br>  <a href="http://code.activestate.com/recipes/576395-convert-datetimedatetime-objects-tofrom-boostpytho/">Another option for converting date / time</a> </div><p>Source: <a href="https://habr.com/ru/post/168827/">https://habr.com/ru/post/168827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168809/index.html">ICANN won the .WEB domain case</a></li>
<li><a href="../168811/index.html">.Net: we get Portable Library and UI</a></li>
<li><a href="../168813/index.html">Refinement completion Ricoh Dx2330</a></li>
<li><a href="../168817/index.html">My experience of introducing R or "I Love R"</a></li>
<li><a href="../168823/index.html">On the way to creating a secure web resource. Part 2 - Development</a></li>
<li><a href="../168829/index.html">File Manager (Silex + Kendo UI) - Tutorial</a></li>
<li><a href="../168831/index.html">keyContentSwitcher - JS library for quick switch creation</a></li>
<li><a href="../168833/index.html">People and organizations that influenced the creation and development of the Internet</a></li>
<li><a href="../168835/index.html">Installing Fusion Drive in iMac 2010</a></li>
<li><a href="../168839/index.html">We exploit the vulnerabilities of wi-fi routers from an android device</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>