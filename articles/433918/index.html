<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why is the web so complicated?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Discussion of the results of the year in the frontend suddenly became a subject of discussion . I will add my opinion, and I will be glad to hear the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why is the web so complicated?</h1><div class="post__text post__text-html js-mediator-article"><p>  Discussion of the <a href="https://habr.com/company/ruvds/blog/433396/">results of the year in the frontend</a> suddenly <a href="https://habr.com/post/433638/">became a subject of discussion</a> .  I will add my opinion, and I will be glad to hear the opinion of others. </p><br><p>  It seems to me that it makes sense to talk about the fact that what is happening in the modern web is perceived outside and inside completely differently.  Yes, and "inside" has several levels.  Looking "again they complicate the layout" on the one hand is absolutely correct, but on the other - wrong and flawed, but the look "do not stop us from building abstractions" is also ineffective. </p><br><p>  When someone complains that the modern web has become too complicated, every time I want to remind this person that he trusts this modern web with his money in Internet banks and forms of purchase, personal correspondence on social networks and web versions of instant messengers, and personal files in the clouds.  And most likely he really wants the development process of these systems to be complex, difficult, but reliable and not giving failures. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c8d/8da/bb3/c8d8dabb3e9df958e3662221e3d63acc.png" alt="image"><br>  <em><a href="https://blog.logrocket.com/the-increasing-nature-of-frontend-complexity-b73c784c09ae">source image</a></em> </p><a name="habracut"></a><br><p>  By modern frontend and his friends they now understand much more than it seems from the outside.  These are classic websites and SPA, applications on the electron, and mobile applications on cordova, NativeScript, React Native, and even Flutter.  This is a complex infrastructure with CDNs, geocentralized services, these are chat bots on JS, and even machine learning tools for <a href="https://blog.mgechev.com/2018/03/18/machine-learning-data-driven-bundling-webpack-javascript-markov-chain-angular-react/">optimizing builds</a> and even <a href="https://sketch2code.azurewebsites.net/">generating layout</a> . </p><br><p>  And in the web itself appear monstrously complex solutions that previously could work exclusively in the desktop mode.  I myself managed a couple of years ago to touch the development of a full-fledged browser of the genome in the browser - I was engaged in providing performance and 60FPS, which was a fairly large, but solvable problem.  Even 5 years ago, no one could have imagined that the genome browser could not be something installed on a powerful computer, and this solution allowed doctors and researchers to work with the genome even from a tablet or lightweight laptop. </p><br><h3 id="pochemu">  Why? </h3><br><p>  At the moment, a bunch of HTML + CSS + JS is one of the most powerful in building interfaces - not only due to its capabilities, but also the number of solutions built on it - css-frameworks, libraries of visual components, interfaces to a huge number of services and SAAS .  In terms of efficiency, in hours, the development of potential audience and accessibility - web technologies are ahead of both mobile and desktop solutions.  And now it has broken up into three areas: </p><br><ul><li>  Development of completely static and near-static sites with partially dynamic content (galleries, pop-ups and so on) </li><li>  Development of "classic" web applications on server-side frameworks (django, rails) </li><li>  Development of client web applications </li></ul><br><p>  And each of them has a completely different specifics. </p><br><p>  Development on JS was really painful, so solutions that solved this pain began to appear. </p><br><p>  If you look at them, you can see something very interesting: first, solutions like jQuery and CoffeeScript began to appear, reducing the redundancy and verbosity of the language.  But they quickly faded away, and in their place came the tools that allow for the most efficient reuse of the code, statically detecting errors, and building effective abstractions, ‚Äúhiding‚Äù certain levels of complexity behind simple and well-described interfaces. </p><br><p>  GraphQL appeared, solving problems with the complexity of describing, documenting and maintaining REST.  Appeared TypeScript and Flow, which solved the problem of lack of typing.  There are new entities of the language, allowing to work effectively with asynchronous operations, classes, data streams.  There was WebAssembly, allowing to reuse code from other languages, and do it quickly. </p><br><p>  All these solutions are aimed at the same thing: the reuse of code and the potential for building "flat" commands.  They solve the problem in order to take someone else's code and start using it. </p><br><p>  This is clear evidence that the web is developing in the direction of working in large teams, it has become a platform for "adult" solutions. </p><br><p>  Even more clear evidence was a series of events that occurred further: React Native, NativeScript, Dart + Flutter and other solutions appeared for reusing code on native platforms.  This is a very important point: in the absence of the ability to use other languages ‚Äã‚Äãon the web, companies have begun to adjust their processes in search of a silver bullet, which will allow them to reduce far from small development costs and time to deliver the new functionality to all customers.  It is important for any project to be fast, and high-level specialists began to unite in search of opportunities to work effectively on JS. </p><br><p>  By the way, for the same reason, the template engines began to partially die away: the use of one more semantics proved to be less effective than using familiar HTML for all with small extensions on JS (Angular, Vue) or using just a language to describe the layout (React, Flutter).  The inability to expand, the need to acquaint developers with a new language, the risk of the platform dying out, decentralization led to the fact that they began to prefer template frameworks of frameworks that tried to be as close as possible to HTML / DOM platforms. </p><br><p>  However, in addition to efficiently writing code, there is also a "factor" for command synchronization.  If the language allows you to work super-fast, but at the same time synchronizing a separate functional between the two developers creates tremendous pain, it most likely remains niche.  Therefore, many language features and solutions are aimed precisely at reducing problems with synchronization and the absence of problems.  They reduce this "factor", which tells how many juniors can simultaneously control the middle one, and how many middle ones the leading developer can control.  Of the latest examples of such capabilities, es6 imports partially solve the problem of cyclic dependencies, and the <a href="https://github.com/prettier/prettier">prettier</a> allows you to get the expected, well-giving merge code into the git code, regardless of how the developer writes.  It should not be beautiful, it should be well synchronized. </p><br><p>  And in the end, in just a few years, the web as a platform was captured by large companies and serious teams, which caused the majority to suffer <a href="https://medium.com/%40ericclemmons/javascript-fatigue-48d4011b6fc4">from "javascript fatigue"</a> .  By the way, the main complaint about Google‚Äôs near-monopoly on the web in the face of Chromium lies in the fact that they push into the capabilities of the web platform and JS what they need (although this usually coincides with what most companies need). </p><br><p>  As a result, on the one hand we got a completely adorable platform for reusable code everywhere, a syntax that allows working with large flat commands.  But... </p><br><h3 id="vse-stalo-slozhno-i-vse-zaputalis">  Everything became difficult and all confused </h3><br><p>  And no one understood what to do.  What is the problem?  In those same three different categories. </p><br><ul><li>  Development of completely static and near-static sites with partially dynamic content: for this type of applications, HTML is typical as an entry point, maximum download speed and optional JS </li><li>  Development of "classic" web applications on server-side frameworks (django, rails): these solutions currently feature HTML loading as an entry point, but instead of maximum download speed, they are focused on reusing code, DRY, and backend integration.  The JS code is partially generated by the framework (notifications, forms, turbo links, and so on), partially you need to write yourself </li><li>  Development of client web applications.  This is where the unexpected happens: HTML instead of the entry point becomes both the application manifest and the rendering platform, and the ‚Äúentry point‚Äù becomes JS. </li></ul><br><p>  What I mean by the entry point: this is an entity whose loading is equal to the minimum delivery to the user of the product.  If the user needs to show information, then we need HTML + CSS, if you run the application - you need JS, which runs from HTML. </p><br><p>  And in order to confuse everyone completely - a fourth category appeared: </p><br><h3 id="izomorfnye-prilozheniya">  Isomorphic applications </h3><br><p>  By "isomorphic" in web development, they usually mean something that works on both the server and the client.  In this mode, applications can work on react, angular, vue.js, there are ready-made frameworks - <a href="https://nextjs.org/">Next</a> and <a href="https://ru.nuxtjs.org/">Nuxt</a> , for example. </p><br><p>  Both tasks are relevant for them: the web application must both deliver its initial state to the user as quickly as possible and act as an application.  In other words, they should deliver both HTML and JS as two entry points, one for the content, the other for the application.  This creates two conflicting sections: on the one hand, the amount of data to be delivered should be minimal, on the other - the code should be reused.  For JS, this is solved by webpack chunks, code splitting and dynamic code loading, the templates have gone to JS, but CSS still remains.  And most importantly, we want to not deliver a single extra byte to the user.  And then the idea came to someone after all: such applications really have two entry points.  They can be treated as two autonomous entities. </p><br><p>  From this, the concept of CSS-in-JS was born, focused on two separate processes: generating a CSS file for static content, and preserving styles next to components. </p><br><p>  All left for JS. </p><br><p>  Now, in JS, you can find styles, layout, and the actual code. </p><br><h3 id="teper-vse-v-js-i-eto-horosho">  Now everything is in js and that's good </h3><br><p> It is necessary to make another digression - now to the grocery side. </p><br><p>  Any product in development or development is important to be able to "move" in the other direction.  This is valid on any of the levels: </p><br><ul><li><p>  The ability to turn a visual component into a component with minimal logic by adding a line of code is very cool.  The need to rewrite it from scratch is not cool. </p><br></li><li><p>  Cheap transformation into a SPA or into an application with a server render is really cool, but it is very rarely possible.  It is more reasonable, if it does not impose costs, to start from the very beginning with such a platform. </p><br></li></ul><br><p>  Therefore, almost any web project that has the risk that it will need to become rendered on the server, the risk that it will have to refactor components, move from one templating engine to another - tries to run away from risks. </p><br><p>  When there is a single platform, within which some entities can turn into others rather cheaply, the development is carried out pretty darn fast. </p><br><p>  In the case of an angular / react / vue application, this is exactly the case.  They are difficult to understand.  Not as complex as Angular 1, of course, but all the same - the path to their realization is long, and there are not enough semi-annual online courses to understand them.  But they make it possible in a few hours to do what used to be done in a few weeks, and in a few days - something that used to take several months. </p><br><p>  However, the opposite is also true - many do not need them, but they are used because they are ‚Äúfashionable‚Äù. </p><br><p>  When they talk about the infrastructure architect of a group of web and mobile apps and the coder, it will be damn hard for them.  Now it is so different directions that they will have no intersections in knowledge, except for JS. </p><br><p>  The next time you want to say "the web has become very complicated and bloated" - think about how difficult it is to design and build a google inbox-level email client (with intelligent entities that turn on depending on the letter), a Web IDE like Cloud9 or an Internet bank . </p><br><p>  But if the coder comes to you and starts telling about the fact that he needs react, because he needs strong typing and decorators for the layout of the landing, do not be persuaded. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/433918/">https://habr.com/ru/post/433918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433906/index.html">Problems using NtQuerySystemInformation with undocumented arguments</a></li>
<li><a href="../433908/index.html">Tetris on C # in 100 lines</a></li>
<li><a href="../433910/index.html">Thoughts on Rust 2019</a></li>
<li><a href="../433912/index.html">Want to attract the best engineers? Open code</a></li>
<li><a href="../433916/index.html">Go Community in Kazan and our meetings</a></li>
<li><a href="../433920/index.html">Chinese polysilicon giant increases power</a></li>
<li><a href="../433922/index.html">Intensive by Kubernetes: about the work of support</a></li>
<li><a href="../433926/index.html">Javascript frameworks: 2019 trends</a></li>
<li><a href="../433932/index.html">We shoot in the foot, processing the input data</a></li>
<li><a href="../433934/index.html">SAFe or Scaled Agile Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>