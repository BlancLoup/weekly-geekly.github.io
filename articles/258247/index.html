<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What should we build Cache?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not a few good articles were written on the topic ‚ÄúWhat, how and where to cache‚Äù. So why once again expose this topic? And because the topic is quite ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What should we build Cache?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/1e0/cea/3f1/1e0cea3f1a53424ebb44cc98a76053db" align="right"><br>  Not a few good articles were written on the topic ‚ÄúWhat, how and where to cache‚Äù.  So why once again expose this topic?  And because the topic is quite important, and many, until they encounter specific problems, do not consider it necessary to deal with it.  So the audience I am counting on are those who were not interested in them by the time the existing articles came out, but now there is interest and they will not pass by. <br><br>  I will try to briefly highlight the main points of caching organization, and then review the .Net Framework 4.0 innovations, which should simplify the life of developers (it will be a question of In-memory cache outside of ASP.NET infrastructure). <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Often, when it comes to performance, it is quite difficult to do without the use of caching techniques.  But before we can apply it effectively, we need to answer the following questions: <br><ul><li>  <i>What to cache</i> : which data should be stored in the cache; </li><li>  <i>How to cache</i> : what is the maximum amount we can allocate for the cache;  whether the maximum allowed time will be set during which the item will not be considered obsolete;  whether the relevance of our elements in the cache will depend on some external factors or will there be dependencies between the elements themselves inside the cache;  whether the order in which we will delete the elements from the cache when the memory limit is reached will be important;  and so on‚Ä¶ </li><li>  <i>Where to cache</i> : what will act as a cache ‚Äî in devices, it can be a hardware cache; in programs, as a rule, we resort to a ready or self-written cache implementation that is able to satisfy the requirements in the ‚Äúhow‚Äù question; </li></ul><br>  Interestingly, the answers must be given exactly in the order in which these questions are listed.  For it is difficult to say ‚Äúwhere to cache‚Äù, not understanding ‚Äúwhat and how‚Äù we cache.  Also, it is highly desirable to take care of caching in the early stages of system design.  Since contrary to popular belief that ‚ÄúKesh can always be added at the last moment,‚Äù this is often not the case.  Without thinking about caching at the initial stage, then adding it and testing it can be extremely difficult.  Let's try to find answers to the questions asked above, but just want to clarify that most of the thoughts below will be given regarding the general-purpose cache inside the .Net application stored in RAM, i.e.  This is not a processor cache or browser cache.  In addition, within the framework of a single article, it will be extremely difficult to explain in detail and intelligibly all possible caching theory, so I will give basic recommendations and tips that I hope will help to avoid common mistakes. <br><br><h4>  What?  How?  Where? </h4><br>  When we decide that we will cache, we need to understand that the cache is not free and will not be useful for all data types.  Regardless of the chosen cache strategy and cache implementation, in one way or another, we will experience problems of data obsolescence and the amount of memory they occupy.  And since the caching adds complexity during the creation / testing / maintenance of our application, it is definitely not necessary to cache everything.  We need a balanced approach to the choice of those places where adding a cache, in addition to problems, will also bring benefits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You should not cache data that is only useful in real time.  For example, currency quotations in the trading system, which are obsolete for 30 seconds, can weighfully influence the correctness of the decisions made.  But if our system has a summary statistics on the company's sales for the last week on the home page, then these data are perfect for caching. <br><br>  There is also no sense to cache something that can be obtained so quickly from a data source or calculated on the fly.  But if the data source is far and very slow, and the specificity of the data allows them to be used with some kind of delay, then these are good candidates for caching. <br><br>  As another example, let's consider the data that are calculated on the fly, require a lot of CPU time, but the result is quite large in volume.  When trying to cache this data, we can very quickly fill up all the available memory, putting only a few results into it.  Under these conditions, it will be difficult to achieve efficient operation of the cache, since  It is likely that literally several new items will result in the mashing of the newly calculated values ‚Äã‚Äãand the percentage of successful hits (finding the desired item in the cache) will be extremely low.  In this case, you should rather think about accelerating the calculation algorithm, rather than caching the result.  When choosing the right candidates to save to the cache, always think about the effectiveness of the cache.  Those.  we must strive to ensure that the data we select, when placed in a cache, is extracted from it many times before they are pushed out of it by newer data or become obsolete. <br><br>  Thinking about how to properly store our data in the cache, we should pay attention to the following points: <br><ul><li>  Timely data obsolescence </li><li>  Correct order of deleting elements when the maximum available memory is reached </li><li>  Data coherence (if the cache is distributed, then the same object may differ in different instances of the cache and thus lead to negative consequences) </li></ul><br>  Some problems related to the question ‚Äúhow to store‚Äù can be so complicated that in order to solve them separate projects are created and specialists with relevant experience are identified.  I hope that this does not apply to your project, because, as I said, this article will not address the depths related to cache issues. <br><br>  So, having received answers to the ‚ÄúWhat‚Äù and ‚ÄúHow‚Äù questions, it may turn out that our answer to the question of where the Dictionary &lt;T, T&gt; will be created in our application.  If so, then we are very lucky.  But, as a rule, everything is a bit more complicated and we still have to write a full-fledged implementation of the cache or choose one of the ready-made solutions. <br>  <i>Note: there is no consensus on whether a dictionary-based implementation will be considered a cache or not.</i>  <i>Personally, I prefer to consider this as a special case, which stands apart aside.</i>  <i>At the same time, I even met the term describing such a cache as ‚Äústatic‚Äù, i.e.</i>  <i>cache in which data is not deleted and are considered infinitely relevant.</i> <br><br><h4>  Handwritten cache </h4><br>  I will not tell you how to write your cache.  I, on the contrary, will try to protect you from a false impression that it is easy and simple to do this.  Except for the case when the Dictionary-like implementation perfectly covers our needs, writing a full-fledged cache is quite a challenge. <br><br>  The first difficulty that comes to mind is to work in a multithreaded environment.  After all, if we use the cache, then for sure the system is not small and working in one thread will be extremely inefficient.  Those.  all data write / read / invalidate operations must be thread safe.  Without extensive experience working with threads, we are guaranteed deadlocks or slow work due to a not optimally chosen thread synchronization approach. <br><br>  If you think about how the data becomes obsolete, then a number of far from the simplest scenarios that our cache should support may come to mind.  Taking the Cartesian product of all possible options, we get the set of states in which our system can be.  This will be sufficient reason to make the task of debugging and testing the samopny cache just very heavy. <br><br>  Many examples that implement caching that can be found on the Internet use the Weak references mechanism.  There may be an irrepressible desire to apply them in their implementation.  But without sufficient experience in the relevant field, we are not weakly increasing the chances of getting a code, which is not enough that the majority of the team will not understand, so it is still unlikely to work after the first 5 times of rewriting. <br>  I think that I could continue this list for a long time, but I hope that even the reasons already listed are enough for you to lose the desire to test yourself for strength and perseverance.  If not, then I can only wish "Strength, intelligence and patience (C)." <br><br>  Now, realizing that your cache is far from being so simple, I propose to move on to the final part of the article, which will tell you that there is already ready in the .NET Framework to simplify our lives. <br><br><h4>  Life before .Net Framework 4.0 </h4><br>  Caching has always been an integral part of ASP.NET web applications and the .Net Framework offered excellent tools for ASP.NET applications.  Therefore, historically, all the classes for working with the cache were located in the System.Web assembly.  When the cache was required outside the web (for example, Windows service), many developers sacrificed the beauty of their solutions and added a link to the System.Web assembly.  This made it possible to take advantage of the cache, but it pulled a huge amount of unnecessary code.  This problem remained unsolved for a long time, but fortunately, in the .NET Framework 4.0 it was returned to it.  As a result, we got the <a href="https://msdn.microsoft.com/ru-ru/library/system.runtime.caching%2528v%3Dvs.110%2529.aspx">System.Runtime.Caching namespace</a> , which, among other things, contains the abstract <a href="https://msdn.microsoft.com/en-us/library/system.runtime.caching.objectcache(v%3Dvs.110).aspx">ObjectCache</a> class and its only implementation, <a href="https://msdn.microsoft.com/en-us/library/system.runtime.caching.memorycache(v%3Dvs.110).aspx">MemoryCache</a> .  It is with them that I would like to introduce you. <br><br><h4>  Objectcache </h4><br>  ObjectCache is an abstract class that allows us to standardize approaches when working with different cache implementations.  Having the same interface (API) to work with the cache, we will not have to study in detail each new cache implementation.  After all, implementations from the user's point of view should look the same and behave according to well-known expectations expressed in the form of an API of this class.  The main methods, properties and their purpose are given below. <br><img src="https://habrastorage.org/files/eff/9e9/4f6/eff9e94f65d547f8b2048e19b2e51aa3" align="left"><br>  <u>Properties</u> : <br><ul><li>  <i>DefaultCacheCapabilities</i> ‚Äî bit flags (enum, with the Flags attribute) that determine what capabilities a particular implementation provides (removing an element at a specific time, supporting regions, having a callback mechanism, etc.) </li><li>  <i>Name</i> - the name of the cache instance;  in the case of using MemoryCache, it can be useful if we want to save data in isolated memory locations and create more than one cache instance (this feature is called ‚Äúregions‚Äù and is not implemented in MemoryCache) </li><li>  <i>this</i> - index for accessing items by key </li></ul><br>  <u>Methods</u> : <br><ul><li>  <i>Add (...)</i> , <i>AddOrGetExisting (...)</i> , <i>Set (...)</i> - add data to the cache </li><li>  <i>Get (...)</i> , <i>GetCacheItem (...)</i> , <i>GetValues ‚Äã‚Äã(...)</i> - return data from the cache </li><li>  <i>GetCount ()</i> - returns the current cache size </li><li>  <i>Contains (...)</i> - checks the existence of an element by key </li><li>  <i>Remove (...)</i> - removes item by key </li></ul><br>  I hope now, in general terms, it is already clear how you can create your own implementation of the cache.  But there are a couple of points that I would like to consider in more detail, namely the methods of adding data to the cache.  I suggest to make it, on the example of methods in already existing implementation of cache - the class MemoryCache. <br><br><h4>  Memorycache </h4><br>  As the name implies, MemoryCache is an implementation that stores data in RAM.  Currently it is the only class in the .Net Framework that inherits ObjectCache, but there are Nuget packages that other implementations offer (for example, the <a href="https://github.com/ovicus/sqlcache">SqlCache</a> Nuget package can be used to store data in the Sql server).  Below will be considered only those methods whose work may not be immediately apparent.  As a demonstration of the methods, listings of unit tests written using <a href="http://xunit.github.io/">xUnit</a> will be given. <br><br><h5>  Method AddOrGetExisting (...) </h5><br>  Adds an element only if the key has not yet been used, otherwise it ignores the new value and returns the existing value. <br><img src="https://habrastorage.org/files/b70/28f/b07/b7028fb07179471cb845a04a85802318"><br><br><h5>  Method Add (...) </h5><br>  It is a wrapper on <i>AddOrGetExisting (...)</i> and works almost identically, with the only difference that it returns True if the element is successfully added, and False if the key already exists (that is, adding a value does not occur). <br><img src="https://habrastorage.org/files/e20/5ae/b85/e205aeb8538042ffa3b706bc7f3c76bb"><br><br><h5>  Set (...) method </h5><br>  Adds a new or replaces an existing item without checking existing keys.  Those.  Unlike the Add and AddOrGetExisting methods, the passed value to the Set method always appears in the cache. <br><img src="https://habrastorage.org/files/c3e/436/74d/c3e43674dced46a799022db22b4daf43"><br><br><h5>  Regions in MemoryCache </h5><br>  All methods of adding data to MemoryCache have overloads that take the region parameter ( <a href="https://msdn.microsoft.com/en-us/library/dd780614(v%3Dvs.110).aspx">example1</a> , <a href="https://msdn.microsoft.com/en-us/library/dd780602(v%3Dvs.110).aspx">example2</a> and <a href="https://msdn.microsoft.com/en-us/library/dd988784(v%3Dvs.110).aspx">example3</a> ).  But if you try to pass any non-NULL value to it, we get a NotSupportedException.  Someone may say that this violates the Liskov substitution principle (so <b>L</b> id), but it is not.  Indeed, before taking advantage of the regions opportunity, the client code must make sure that they are implemented in a specific implementation.  This is done by checking the DefaultCacheCapabilities property for the presence of the corresponding bit flag (DefaultCacheCapabilities.CacheRegions), and it is not set for MemoryCache. <br><br><h4>  CacheItemPolicy </h4><br><img src="https://habrastorage.org/files/745/e6d/849/745e6d84914f401296eba682c62854b2" align="right"><br>  To demonstrate all the methods of adding data, the simplest versions of overloads were chosen, taking the key, the value, and the time until which the value will be considered relevant.  But all of them also have a version that accepts a parameter of type CacheItemPolicy.  It is thanks to this parameter that we have quite rich possibilities for managing the lifetime of an item in the cache, which makes the implementation of MemoryCache extremely useful. <br><br>  Most of the properties of this type look clear, but in practice we will encounter many unexpected surprises.  Strictly speaking, many of them will not be in the CacheItemPolicy class itself, but in the logic of the MemoryCache methods that accept this type.  But since these types are often used together, I propose to consider them together. <br><br><h5>  AbsoluteExpiration and SlidingExpiration properties </h5><br>  From the name it is clear what these properties are responsible for.  But the curious can ask the following question: "How will the cache behave if you simultaneously specify values ‚Äã‚Äãfor both properties?"  Someone may assume that AbsoluteExpiration has a higher priority and the object will be deleted at the time of AbsoluteExpiration, even if it is regularly requested from the cache (more often than SlidingExpiration).  Someone, on the contrary, will assume that the value of SlidingExpiration will allow the object to survive AbsoluteExpiration.  But the developers of Microsoft, they considered that there is no true correct answer and acted differently - they generate an ArgumentException at the stage of adding an item to the cache.  Therefore, we can choose only one time (time-dependent) invalidation strategy for each element. <br><br>  The second surprise awaits us if we decide to write tests for functionality using the cache.  Surely, to speed up the test run, we want to set a sufficiently small value for SlidingExpiration (less than 1 second).  In this case, our tests will behave unstable and will often fall.  This is all due to the fact that in order to optimize the operation of the cache, when an element is read (the Get method and its derivatives), the new Expires value will be set only if it differs from the old one, by at least one second.  I could not find confirmation of this in the documentation, but I can verify this by decompiling the MemoryCache class and studying the UpdateSlidingExp (...) method of the internal MemoryCacheEntry class. <br><br><img src="https://habrastorage.org/files/8be/38d/884/8be38d884c014a3cb7733d85ed536dd3"><br><br><h5>  Priority property </h5><br>  When I saw this property, I expected that it could be ‚Äúlow / medium / high‚Äù to set the order for deleting items from the cache when the maximum volume was reached.  But it can have only 2 values: CacheItemPriority.Default or CacheItemPriority.NotRemovable. <br>  MSDN says that setting the CacheItemPriority.NotRemovable value will cause the item to never be removed from the cache.  Personally, I perceived this fact as the fact that, by adding all the elements with such a priority, we will get a Dictionary-like implementation, but this is far from the case.  Elements will still be deleted if they ‚Äúrotten‚Äù (AbsoluteExpiration comes or SlidingExpiration passes), but unlike the default mode, they will not be deleted from memory when the limit on the amount of memory is reached.  By the way, the limit can be set via the CacheMemoryLimit property (in bytes) or through the PhysicalMemoryLimit property (percentage of the total memory in the system). <br><br><h5>  RemovedCallback and UpdateCallback </h5><br>  Another surprise.  Both properties are accepted by delegates who will be called, both in the case of an update, and in the case of deleting an item from the cache. <br><br>  If you think about it, an update is essentially a delete operation, immediately followed by an operation to add a new value.  This explains why RemovedCallback works when an item is updated.  And the fact that UpdateCallback works when you delete is just a fact from MSDN. <br><br>  The difference in properties is that RemovedCallback should be called after, and UpdateCallback should be called before the item is actually removed from the cache.  The delegates stored in these properties accept a parameter that contains a link to the cache, a link to the item to be deleted, and the reason for deleting the item. <br><br>  Another gift is stored in the MemoryCache implementation.  In this class there is a bit strange logic of validation of the parameter passed by CacheItemPolicy.  First, it checks that both delegates are not set at the same time, otherwise we will get an ArgumentException at the stage of adding an item to the cache. <br><br><img src="https://habrastorage.org/files/e22/d59/183/e22d591830ef432eb9945ead2490d578"><br><br>  And everything would be fine if for the UpdateCallback property to work correctly, it would be enough to make sure that the RemovedCallback property does not have a value.  But in fact, we always get an ArgumentException at the stage of adding an element when setting a non-empty value in UpdateCallback. <br><br><img src="https://habrastorage.org/files/e3a/bc5/d01/e3abc5d019114c3ab98230f7f40796a4"><br>  As a result, the only valid property for setting a delegate that signals changes in the cache is the RemovedCallback (valid only for the MemoryCache implementation). <br><br><h5>  ChangeMonitors property </h5><br>        ChangeMonitor,      ,       . <br><br>  ,         ChangeMonitor,  .Net Framework   : <br><ul><li> <i>CacheEntryChangeMonitor</i> ‚Äì           </li><li> <i>FileChangeMonitor (HostFileChangeMonitor)</i> ‚Äì          </li><li> <i>SqlChangeMonitor</i> ‚Äì       (      ). </li></ul><br>  ,      CacheItemPolicy       .            . <br><br><h5>  Conclusion </h5><br>          MemoryCache,           ,     - ¬´¬ª          . ,                . </div><p>Source: <a href="https://habr.com/ru/post/258247/">https://habr.com/ru/post/258247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258235/index.html">PCs and servers based on the Elbrus-4C processors are on sale</a></li>
<li><a href="../258237/index.html">Moore's Law for Google Compute Engine: more power for the same money</a></li>
<li><a href="../258239/index.html">Night, street, LED, pharmacy</a></li>
<li><a href="../258241/index.html">The starting list of pages in the new assembly Vivaldi 1.0.178.2</a></li>
<li><a href="../258245/index.html">Inside the post is money. Another JavaScript contest</a></li>
<li><a href="../258249/index.html">Cyclic containers in Objective-C</a></li>
<li><a href="../258251/index.html">Interface revolution. USB 3.1 Type-C in detail. Electronic technician</a></li>
<li><a href="../258253/index.html">Google transfers corporate applications to the cloud with access from outside</a></li>
<li><a href="../258255/index.html">Development of the system architecture through the service-resource model</a></li>
<li><a href="../258257/index.html">Microservices. Good, bad, evil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>