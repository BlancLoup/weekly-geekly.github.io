<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tuples in programming languages. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous part, I looked at the implementation of tuples in various programming languages ‚Äã‚Äã(I also considered non-scriptable compiled languages...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tuples in programming languages. Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habrahabr.ru/post/276871">previous part,</a> I looked at the implementation of tuples in various programming languages ‚Äã‚Äã(I also considered non-scriptable compiled languages ‚Äã‚Äãwith static typing and classical C-like syntax, which surprised some readers).  In this part, I propose to go beyond the existing and take up the essence of the programming language design.  The source data is the same: a compiled non-scripting language with static typing and a C-like syntax that includes an imperative paradigm (although not limited to it, of course). <br><br>  In this part we will try to dream and experiment - and what can you do with tuples?  How to squeeze the maximum out of them?  How to use them to make the programming language more powerful and expressive, how to cause admiration from the true Hackers of the Code and at the same time not too confuse the ordinary programmers?  What unexpected possibilities appear in the language, if you correctly and correctly extrapolate the semantics of tuples in different directions, and what difficulties arise in this case? <br><br>  So, if you like reflections and holivars on the topic of programming language design, then I ask for cat. <br><a name="habracut"></a><br>  <b>SYNTAX</b> <br>  To begin with we will be defined with syntax.  It is possible to consider different versions of tuples in the code for a long time - in curly brackets, in round brackets, without brackets at all ... I like the curly version for a number of reasons, and take it as a basis (at least until there is a real need for another syntax).  So, a tuple is a sequence of names or expressions, separated by commas and enclosed in braces.  Like unified initialization in C ++. <br><pre><code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} {i, j, k}</code> </pre> <br>  Other options may exist, but for our purposes this will be enough for now. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I would also like to mention the simple idea of ‚Äã‚Äãcreating tuples from ranges and repetitions.  Ranges - a way to specify tuples for enumerated elements (which include integers and enumeration elements) <br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>}</code> </pre><br>  Repetitions - taken from Assembler, a way to fill a tuple with the same value. <br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">10</span></span> dup <span class="hljs-string"><span class="hljs-string">'A'</span></span>}</code> </pre><br>  In this article, I will not use these methods, and just mentioned them as a beautiful idea. <br><br>  <b>GENERAL IDEAS</b> <br>  In the first part, I mentioned a certain thought that caused some confusion - that the tuple is ‚Äúnot quite the type‚Äù.  If you open the same Wikipedia, then it <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D1%2582%25D0%25B5%25D0%25B6_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">clearly states</a> <blockquote>  In some programming languages, such as Python or ML, a tuple is a special data type. <br>  In programming languages ‚Äã‚Äãwith static typing, a tuple differs from the list in that the elements of a tuple can belong to different types and the set of such types is predefined by the type of tuple, and hence the size of the tuple is also defined.  On the other hand, collections (lists, arrays) have a restriction on the type of stored items, but do not have a limit on the length. </blockquote><br>  However, what did I mean by saying that this is ‚Äúnot exactly a type‚Äù?  Sometimes (and quite often) you want to have a certain <b>language construct</b> that would allow locally grouping arbitrary objects at the compilation stage.  Some group pseudonym that would simply be the equivalent of its constituent parts without introducing any additional entities.  In fact, this is just a way to look at the tuples from a slightly different side.  For example, multiple return from functions.  It may well be considered as the return of a single object of the tuple type;  but on the other hand, the assignment operation for multiple returns is just one of many operations;  using Rust as an example, we have seen the possibility of another operation on tuples ‚Äî comparisons for equality.  And what if you allow all operations to be performed on tuples?  Immediately, various questions arise - what kind of operations can they be, can they be performed on tuples of different lengths, on a tuple and a single value?  You can also consider the semantics of transferring tuples to functions (for example, ‚Äúopening‚Äù a tuple during transmission to a function, or performing a function on all elements of a tuple, etc.).  Of course, we will need convenient tools for creating and decomposing tuples, accessing elements of a tuple.  Perhaps something else? .. <br><br>  <b>MULTIPLE RETURN FROM FUNCTIONS AND VOID TYPE</b> <br>  Let's start with the simplest, and already implemented in many languages ‚Äã‚Äã- with multiple return from functions.  A function can return multiple values, and we call it returning a tuple of several values ‚Äã‚Äã‚Äî just as a function can take multiple arguments.  The following generalization suggests itself: a function that returns a single value returns a tuple of one value.  At the very least, <b>it can be taken as a wish that tuples from one value be freely converted to these same values, and vice versa.</b> <br><br>  Further extrapolation leads us to the void type.  As you know, this is a special type used in most programming languages ‚Äã‚Äãto indicate that a function does not return a result.  Creating objects of this type is prohibited.  It is not difficult to guess that void is not a full-fledged type, but a symbol for a zero-length tuple.  Creating objects of this type in the usual sense is really impossible;  but if our compiler is able to work with tuples in a more advanced way, then nothing prevents us from introducing a ‚Äúpseudo-object‚Äù of type void in the form of an empty tuple {} and something to do with it.  The question is what?  And in what cases can it be useful?  For now, just note this and move on to the following extrapolations. <br><br>  <b>MULTIPLE OPERATIONS</b> <br>  We considered multiple return from functions and the associated multiple assignment.  But assignment is just one of many possible operations.  By analogy with the assignment (from which everything started), we will try to build other operations on tuples: <br><pre> <code class="cpp hljs">{x,y,z} = foo(); <span class="hljs-comment"><span class="hljs-comment">//   ,   foo()  3  {x,y,z} += foo(); //   ,   ? {x,y,z} ++; //    {x,y,z} = {1,2,3} + {a,b,c}; //      </span></span></code> </pre><br>  So far, it looks good, although perhaps a little alarming is the thought of how such expressions with a large number of operations will look.  The important thing is that <b>each object in the expression is a tuple of the same number of elements</b> .  Deviation from this rule gives rise to various ambiguities, which should be avoided when designing a programming language.  However, they must be considered necessarily (and, if possible, allowed). <br><br>  <b>GROUP OPERATIONS</b> <br>  In addition to multiple operations, group operations on a tuple and a single value seem very attractive.  In fact, this is the first deviation from the rule of the same number of elements in each operand of an expression.  But I want to make it beautiful, so we try: <br><pre> <code class="cpp hljs">{i, j, k} = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ...  ,    ,     ? ++{i, j, k}; //    ... {i, j, k} += 100; //    rec.{x,y,z}.At(i).flag = true; //   </span></span></code> </pre><br>  The general view of such a binary operation is <b>‚Äútuple operator value‚Äù</b> , or <b>‚Äúvalue operator tuple‚Äù</b> (most operations are commutative);  And under the form <b>‚Äúvalue operator tuple‚Äù</b> , the assignment of a single variable to a whole tuple, and in particular, the result of a multiple return of a function <b>,</b> falls. <br><pre> <code class="cpp hljs">x = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     x   ? x = foo(); //  foo()   ,    x ?</span></span></code> </pre><br>  In the case of assigning multiple returns from a function, obviously I want the first return value to be written in ‚Äúx‚Äù and the following ones ignored.  Here is such an unexpected ambiguity.  But somehow it is necessary to solve it - I really want to have such a syntax.  It could be useful not only for group assignments, but also in a number of interesting cases.  For example, indexing an array and even accessing a structure field by name is also an operation. <br><pre> <code class="cpp hljs">arr[ {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} ] = { <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//     obj.{x,y,z} = {10,20,30}; //     ... {obj1, obj2, obj3}.x = { 10, 20, 30 }; //  ... {arr1, arr2, arr3} [ 0 ] = {10, 20, 30 }; //    </span></span></code> </pre><br>  Despite the apparent obviousness of the expressions, formally arr [{1,2,3}] is the form ‚Äúvalue operator tuple‚Äù, where ‚Äúvalue‚Äù is arr, ‚Äútuple‚Äù is {1,2,3}, and ‚Äúoperator‚Äù - square brackets.  Unlike assigning a tuple to a single value, there are no questions here - the result of such an operation must be a tuple {arr [1], arr [2], arr [3]}.  But for the compiler, that assignment, that indexing are just binary operations.  Hence, an expression of the form x = {1,2,3} should unfold in {x = 1, x = 2, x = 3}, that is, the variable x is sequentially assigned all values ‚Äã‚Äãof the tuple, and the result is also a tuple <i>(by the way, if such a programming language was in reality - it would be an interesting question for backfilling for all sorts of interviews: what would its elements be equal to? {1,2,3} or {3,3,3}?)</i> <br>  Thus, the question of the proper organization of operations on a tuple and the only element is still open. <br><br>  <b>BINARY OPERATIONS ABOVE COLORS WITH DIFFERENT SIZES</b> <br>  Consider a more general case - the sizes of the tuples - operands of a binary operation do not match.  What to do in this case?  As always, the simplest solution is to prohibit :) But let's try to figure it out ... Go and Rust have a special metavariable "_" (underscore), which is used when some of the elements of the tuple to the right of the assignment operator are not needed.  In our syntax, this will look like this: <br><pre> <code class="cpp hljs">{x, _ ,z} = foo(); {x, _, z} = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre><br>  The operation with the second component of the tuple is simply ignored.  Using the metavariable "_" in Go and Rust is mandatory for multiple assignment in case some results of the returned tuple are not needed.  Thus, in these languages, the requirement of mandatory matching of the sizes of the tuples is preserved.  But in these languages ‚Äã‚Äãthere are no other multiple operations except assignment;  when trying to extrapolate the metavariable "_" to other operations, such interesting results are obtained that they should be considered in a separate chapter. <br><br>  Let's try to consider the general case: what to do if such an expression is written (@ is a generalized binary operation) <br><pre> <code class="cpp hljs">{a, b} @ {x, y, z}</code> </pre><br>  What are the opportunities? <br><ul><li>  Perform smaller tuple size operations.  That is, the result is {a @ x, b @ y}.  It contradicts group operations (if we consider single values ‚Äã‚Äãequivalent to tuples with one element) ‚Äîfor a group operation, a single operand must interact with each element of the tuple. </li><li>  Perform operations on the size of a large tuple.  At the same time, elements of a larger tuple, which did not have enough elements of a smaller tuple, remain unchanged.  {a @ x, b @ y, z}.  Also contradicts group operations for the same reason. </li><li>  Perform operations on the size of a large tuple.  When the smaller tuple ends, cycle to its beginning.  {a @ x, b @ y, a @ z}.  This corresponds to group operations, but abstrusely. </li><li>  Perform operations on the size of a tuple with a larger size. When the smaller tuple is complete, perform operations on the last element of the smaller tuple.  {a @ x, b @ y, b @ z}.  Also corresponds to group operations, and also abstruse. </li><li>  Perform operations in pairs "each element of one tuple with each element of another tuple" ("Cartesian product").  {a @ x, a @ y, a @ z, b @ x, b @ y, b @ z}.  Also corresponds to group operations, and also abstruse.  And by the way, the question arises of how to group pairs - according to the first tuple or the second, or some other way. </li></ul><br>  Perhaps there are other options.  But now one thing is clear: if a programmer is given such an opportunity, then an indication of the way tuples interact <b>should be made explicitly</b> .  In this case, it is almost a prerequisite for maintaining clarity in the code.  For this purpose, some keywords can be used that cover such an expression.  Until we specify the list of such words (we can assume beforehand that for each of the options there can be one keyword) <br><br>  <b>ACCESS TO ELEMENTS</b> <br>  And now we should turn to another important opportunity - access to the elements of the tuple. <br>  Traditionally, brackets are used for indexing, and a dot is used for access by name;  although the Swift variant with the index through a dot is not so bad, it is ambiguous when using named numeric constants instead of numbers, and it is not at all unusual;  I would prefer to use square brackets for access by index (it is important - by constant index) and a point for access by name (if there is one) <br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">30</span></span>}[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 20 {x:10,y:20,z:30}.z; // 30</span></span></code> </pre><br>  It seems everything is simple?  Actually no longer.  Since we have introduced multiple and group operations on tuples, and these include indexing "[]" and referring to named members of the structure ".", Using these operations on tuples, whose elements are complex objects (for which indexing is defined or "Point") - it is not clear what to do: access the element of a tuple or perform a group operation on all elements of a tuple? <br><pre> <code class="cpp hljs">{arr1, arr2, arr3} [<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">// "arr2"  "{arr1[1], arr2[1], arr3[1]} " ? {x:obj1, y:obj2, z:obj3}.z // "obj3"  "{obj1.z, obj2.z, obj3.z}" ?</span></span></code> </pre><br>  Another interesting aspect is getting (designing) tuples.  According to the agreement adopted at the beginning of the article, we use curly brackets for simple construction of a tuple object.  However, in some cases it may be necessary to build a tuple from another tuple by excluding or adding elements.  Syntactically, this can be done using ‚Äúmultiple indexing‚Äù, applying essentially the same rules as for arrays or structures. <br>  To obtain a tuple, you could use multiple indexing or ranges: <br><pre> <code class="cpp hljs">{a,b,c,d,e}[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">// {b,e,a} {a,b,c,d,e}[1..4] // {b,c,d,e} {a,b,c,d,e}[1..3,0] // {b,c,d,a}</span></span></code> </pre><br>  (the indexing operation itself contains brackets, therefore, within brackets one more curly ones can be omitted) <br>  If the elements of the composite object have names, you can refer to the names: <br><pre> <code class="cpp hljs">obj.{a, d, e} <span class="hljs-comment"><span class="hljs-comment">//   obj.{b .. f} //  -    </span></span></code> </pre><br>  It should be noted an interesting consequence - since the tuples are indexed by constant indices, the idea suggests that the field names should be reduced to constant indices (and maybe vice versa) <br><br>  Thus, there are at least two ‚Äúspecial‚Äù operations, ‚Äúdot‚Äù and ‚Äúsquare brackets‚Äù, which can act on the tuple itself as an integral object.  The remaining operations for the tuple are not defined, although it can be assumed that we need, for example, concatenation of tuples ‚Äî flat pasting of two or more tuples into one long one.  Therefore, the open question arises: is <b>it necessary to somehow allocate access operations directly to the elements of the tuple?</b>  <b>Or is it more appropriate to allocate operations on each element of the tuple?</b> <br><br>  <b>FROM OPERATIONS TO FUNCTIONS</b> <br>  Any operation is equivalent to some function.  For example, the unary bit-inversion operation ~ x can be represented as neg (x), and the binary addition x + y as sum (x, y); <br>  therefore, considering operations on tuples as multiple operations, the question arises - what to do if a function call is involved in such an expression? <br>  To begin with, a unary operation: <br><pre> <code class="cpp hljs">~{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    neg({1,2,3}); //   </span></span></code> </pre><br>  By analogy with ‚Äúgroup assignment‚Äù, we need to expand the tuple as follows: <br><pre> <code class="cpp hljs">{neg(<span class="hljs-number"><span class="hljs-number">1</span></span>), neg(<span class="hljs-number"><span class="hljs-number">2</span></span>), neg(<span class="hljs-number"><span class="hljs-number">3</span></span>)}</code> </pre><br>  at first glance, this seems quite logical;  the function itself takes a single value and returns a single value;  must return a single value so that you can make a tuple of them. <br>  Probably, functions with two arguments could be similarly expanded.  for example <br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} + {<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} sum( {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} )</code> </pre><br>  at <br><pre> <code class="cpp hljs">{ sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>), sum(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>), sum(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) }</code> </pre><br>  Although it must be admitted that the syntax of an implicit multiple function call for tuples is too implicit, and just like with operations, some explicit way to indicate such a call suggests (although the possibility of such a call is not bad by itself). <br><br>  On the other hand, recall the syntax Go, D, C‚àÄ: there the tuple passed to the function unfolds inside the argument list, replacing the corresponding number of arguments.  And in general, this is also very logical and expected - but again incompatible with ‚Äúgroup‚Äù semantics!  Is it possible to somehow resolve this contradiction?  And we have not yet considered complex options, when the dimensions of the tuples-arguments do not coincide, when tuples and single values ‚Äã‚Äãare mixed, when we want to get the Cartesian product from the results of the operation on the elements of tuples, etc. <br><br>  The solution, which seems to be quite good, came oddly from C ++.  There is such an opportunity as templates with a variable number of parameters, and for transferring a package of parameters (by the way, too, a tuple) to another template, the syntax is used with a triple-point.  The ellipsis visually marks that the given argument is ‚Äúrevealed‚Äù in this context (and this is very important for the perception of the code!).  It is important that this is immediately visible in the code.  The only thing that is not visible is how many arguments it reveals.  But if you want to specify in detail - nothing prevents access to individual elements of the tuple. <br><pre> <code class="cpp hljs">foo(t..., <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  foo(t[0], t[1], t[2], 10, 20); //  foo(tx, ty, tz, 10, 20); //      </span></span></code> </pre><br>  Finally, the most difficult situation: a function with several parameters, and tuples are transferred to some (or all) parameters, and with different lengths.  Similar to the situation with binary operations, there are many possibilities for opening such a call: a multiple function call for a minimal number of elements, for a maximum with different types of additions to shorter tuples, a Cartesian product, etc.  <b>All these methods are rather complicated for perception, and therefore any of them should be declared only explicitly</b> - for example, using the appropriate keyword before calling a function. <br><br>  <b>META VARIABLE "_"</b> <br>  We return to the consideration of the behavior of the metavariable "_", which is used in some languages ‚Äã‚Äãto ignore the elements of the source tuple when assigning tuples.  Let's see if this metavariable can be extrapolated to more complex cases (after all, assignment is just a binary operation). <br><pre> <code class="cpp hljs">{x,y,z} = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} + {a,_,c};</code> </pre><br>  By analogy, the operation of adding the number 2 with "_" will be ignored, but what will be the result?  In general, there are two possibilities: either leave the number 2 in the resulting tuple, or extend the "_" there.  In the first case, "_" can be considered as a " <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B9%25D1%2582%25D1%2580%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258D%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582">neutral element</a> ".  for any operation (that is, for any operation "@" and any argument "x", it is true x @ _ == _ @ x == x).  For example, the expression x = y * ~ (_ + z) can be transformed into x = y * ~ z. <br>  However, this is not all clear.  For example, the unary operation of changing the sign "-x" can be written as a binary operation subtracting the number from zero "0-x".  If instead of "x" put "_", then this expression will have a different meaning depending on the method of recording. <br><pre> <code class="cpp hljs">z = y * (<span class="hljs-number"><span class="hljs-number">0</span></span> - _) <span class="hljs-comment"><span class="hljs-comment">// z = y*0,   z = 0 z = y * (- _ ) // z = y</span></span></code> </pre><br>  In the second case, when "_" appears in some position of the tuple, all further calculations for this position from the node of the syntactic tree containing "_" to the root of the tree (that is, the end of the expression, as a rule - semicolons) are discarded (that is, it is true x @ _ == _ @ x == _).  That is, the presence of at least one "_" in the i-th element of a tuple means that all calculations with the i-th element of all tuples in the whole expression are discarded. <br>  I find it difficult to say which way to work with "_" is better.  This is another question that requires careful thought. <br><br>  <b>ATTACHED TRAINING</b> <br>  Another interesting aspect that is practically not considered in the documentation for languages ‚Äã‚Äãis nesting of tuples.  The most obvious and realistically existing (even in the C language) application of nested tuples is the initialization of nested structures. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y, z; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> Foo f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; }; Bar b = { {<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>}, <span class="hljs-number"><span class="hljs-number">30</span></span> };</code> </pre><br>     x, y, i,    z  j.          ( ,       /    ).  ,       .             . <br><br> <b> </b> <br>          bool.     : <br><pre> <code class="cpp hljs">{x, y, z} == {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-comment"><span class="hljs-comment">//  {false, true, false}</span></span></code> </pre><br>   if, while  ..     bool!         ? <br>      <br><ol><li>     (       true) </li><li>  -     (  -      true). </li></ol><br>           .    ,    ,      .        : ,    ,       . ,       ‚Äî   . <br>       ? ,    ;         (   -    )      . <br><br>            ¬´ ¬ª         : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( {x, y, z} == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }</code> </pre><br>            ‚Äî  ¬´  ¬ª       (    )   -   ,   . <br><br> <b> </b> <br> ,      !  ,            ;  ,       .    ‚Äî      ¬´   ¬ª    ,         (    ‚Äî , ,   -  ‚Äî  Evernote  Wiznote  ). ,        ,       ‚Äî   ! </div><p>Source: <a href="https://habr.com/ru/post/280608/">https://habr.com/ru/post/280608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280596/index.html">How I VK Mobile Challenge accepted</a></li>
<li><a href="../280598/index.html">Trends in the development of cloud data centers</a></li>
<li><a href="../280602/index.html">As we broke up mobile Lenta.ru to the speed of light</a></li>
<li><a href="../280604/index.html">Legend of international avos</a></li>
<li><a href="../280606/index.html">Collection and analysis of the logs of demons in Badoo</a></li>
<li><a href="../280610/index.html">The tale of Tsar Saltan about the potential of the Laplacian</a></li>
<li><a href="../280614/index.html">Cisco Routermate</a></li>
<li><a href="../280616/index.html">How the memory is arranged NetApp FAS: NVRAM, Kesh and Tetris</a></li>
<li><a href="../280618/index.html">Exploratory testing: when to use it and how to do it</a></li>
<li><a href="../280622/index.html">Build 2016 conference text translation - second day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>