<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deploy applications on RoR 4 using Capistrano 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine: You are a web developer who just recently mastered Ruby on Rails. And then your first project comes to the stage when it needs to be posted o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deploy applications on RoR 4 using Capistrano 3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3aa/2f6/0a63aa2f640920d345e0d82d27fe3466.jpg"></div><br>  Imagine: You are a web developer who just recently mastered Ruby on Rails.  And then your first project comes to the stage when it needs to be posted on the Internet. <br>  Of course, you can pour it on Heroku, but local prices bite a little.  It remains only to buy a VPS, configure it and put the project there. <br>  ‚ÄúWhat could be easier?  I‚Äôll find some guide, but I‚Äôll follow everything on it ‚Äù- you will think.  Here are only guides that not only lay out commands, but also explaining what these commands do - units, and they use the outdated second version of Capistrano. <br><br>  Therefore, I decided to write my guide in which I will try to examine in detail: <br><ul><li>  Initial server setup </li><li>  Installation and configuration of nginx (with the module PageSpeed), postgresql, redis </li><li>  Install rvm, rails </li><li>  Setting foreman gem to manage the processes of your application </li><li>  Unicorn server setup </li><li>  Setting Capistrano heme (v3.1) to automate deployment </li></ul><br><br>  I hope that this guide will be useful not only for beginners, but also for developers with experience. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Initial server configuration </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d0/6b4/21c/2d06b421c7b265808e7d2c24f4624065.jpg"></div><br>  You bought your first VPS, installed the OS (I use ubuntu 12.04 LTS and I‚Äôll upload all the commands for it), logged in via SSH.  What to do next? <br><br>  First, change the password for the root user by the command <pre><code class="bash hljs">passwd</code> </pre> <br>  Create a new user: <br><pre> <code class="bash hljs">adduser deployer</code> </pre><br>  Let him use the sudo command: <br><pre> <code class="bash hljs">visudo</code> </pre>  and append: <pre> <code class="hljs pgsql">deployer <span class="hljs-keyword"><span class="hljs-keyword">ALL</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">ALL</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">ALL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ALL</span></span></code> </pre><br>  Let's change the ssh server settings (we will disable login as root, access by domain name and allow login only under our new user).  Add to the file '/ etc / ssh / sshd_config': <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">PermitRootLogin</span></span> <span class="hljs-literal"><span class="hljs-literal">no</span></span> UseDNS <span class="hljs-literal"><span class="hljs-literal">no</span></span> AllowUsers deployer</code> </pre><br>  Restart the ssh server with the command: <pre> <code class="bash hljs">reload ssh</code> </pre><br><br>  In order not to enter the password every time you connect via ssh, we need to copy the ssh key from your machine to the server.  The easiest way to do this is to run it on a local machine. <pre> <code class="bash hljs">ssh-copy-id deployer@123.123.123.123</code> </pre>  (On a Mac, you need to install ssh-copy-id, you can do it through brew, on Windows I don‚Äôt know an automated tool for copying keys, but there are many interesting things on the Internet). <br><br>  Also, as long as we are under the root, you can create a SWAP file if you have a little RAM.  This is done like this: <br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=/swapfile bs=1024 count=512k mkswap /swapfile swapon /swapfile</code> </pre><br>  Next in the file '/ etc / fstab' add the line: <br><pre> <code class="hljs swift"> /swapfile <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-built_in"><span class="hljs-built_in">swap</span></span> sw <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  And then we perform: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 0 &gt; /proc/sys/vm/swappiness sudo chown root:root /swapfile sudo chmod 0600 /swapfile</code> </pre><br>  You can reboot and check for the presence of the SWAP file with the command <pre> <code class="bash hljs">swapon -s</code> </pre><br><br><h4>  Install and configure nginx </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/541/7a6/785/5417a67857580be18180dbb0d30a1384.png"></div><br>  This time we are logged in with our new user command. <pre> <code class="bash hljs">ssh deployer@123.123.123.123</code> </pre>  (on the local computer). <br>  Personally, I use the PageSpeed ‚Äã‚Äãmodule, so I compile nginx myself.  But first we need to update the repositories, update the system, and download the packages necessary for successful assembly: <br><pre> <code class="bash hljs">sudo apt-get update sudo apt-get dist-upgrade sudo apt-get install build-essential zlib1g-dev libpcre3 libpcre3-dev unzip</code> </pre><br>  Now we collect: <br><pre> <code class="bash hljs">wget https://github.com/pagespeed/ngx_pagespeed/archive/v1.7.30.1-beta.zip unzip v1.7.30.1-beta.zip <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ngx_pagespeed-1.7.30.1-beta wget https://dl.google.com/dl/page-speed/psol/1.7.30.1.tar.gz tar -xzvf 1.7.30.1.tar.gz wget http://nginx.org/download/nginx-1.4.4.tar.gz tar -xzvf nginx-1.4.4.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> nginx-1.4.4 ./configure --add-module=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/ngx_pagespeed-1.7.30.1-beta make sudo checkinstall</code> </pre><br>  To manage nginx we will write an <a href="http://upstart.ubuntu.com/">upstart</a> script.  Create the file '/etc/init/nginx.conf' with the following contents: <br><div class="spoiler">  <b class="spoiler_title">etc / init / nginx.conf</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">description <span class="hljs-string"><span class="hljs-string">"nginx http daemon"</span></span> author <span class="hljs-string"><span class="hljs-string">"George Shammas &lt;georgyo@gmail.com&gt;"</span></span> start <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (filesystem <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> net-device-up IFACE=lo) <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> runlevel [!<span class="hljs-number"><span class="hljs-number">2345</span></span>] env DAEMON=/usr/local/nginx/sbin/nginx env PID=/var/run/nginx.pid expect fork respawn respawn limit <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> #oom never pre-start script $DAEMON -t <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne <span class="hljs-number"><span class="hljs-number">0</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> $? fi <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> script exec $DAEMON</code> </pre><br></div></div><br>  Now you can perform <pre> <code class="bash hljs">sudo start/stop/restart/status nginx</code> </pre><br>  Our nginx.conf is at the address '/usr/local/nginx/conf/nginx.conf', but for the time being we will not touch it.  We will fill it automatically when the application is first deployed. <br><br>  For our web applications, we will create a new user and a new group, add ourselves to this group, and create a folder: <br><pre> <code class="bash hljs">sudo useradd -s /sbin/nologin -r nginx sudo groupadd web sudo usermod -a -G web nginx sudo usermod -a -G web deployer sudo mkdir /var/www sudo chgrp -R web /var/www sudo chmod -R 775 /var/www</code> </pre><br>  In order for us to write to the folder, you will have to log out and log in again under our user. <br><br><h4>  Install and configure PostgreSQL </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c46/490/b80/c46490b8070528ded4adc5ddd2d2e480.png"></div><br>  In the ubuntu repositories is an outdated version, so we add a third-party repo.  In the file '/etc/apt/sources.list.d/pgdg.list' we add: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">deb</span></span> http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main</code> </pre><br>  Then add the repository key and install PostgreSQL: <br><pre> <code class="bash hljs">wget --quiet -O - http://apt.postgresql.org/pub/repos/apt/ACCC4CF8.asc | sudo apt-key add - sudo apt-get update sudo apt-get install postgresql-9.3 postgresql-server-dev-9.3</code> </pre><br>  And create a new user: <br><pre> <code class="bash hljs">sudo -u postgres psql create user deployer with password <span class="hljs-string"><span class="hljs-string">' '</span></span>; alter role deployer superuser createrole createdb replication; \q</code> </pre><br><br>  To access from the local computer in the file '/etc/postgresql/9.3/main/postgresql.conf' change the parameter <code>listen_addresses = 'localhost'</code> to <code>listen_addresses = '*'</code> and add it to the file '/etc/postgresql/9.3/main/pg_hba .conf 'line <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">all</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">deployer</span></span> .<span class="hljs-selector-class"><span class="hljs-selector-class">.ip</span></span>. 255<span class="hljs-selector-class"><span class="hljs-selector-class">.255</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.255</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">md5</span></span></code> </pre><br><br>  Reboot the postgresql command <pre> <code class="bash hljs">sudo service postgresql restart</code> </pre><br><br><h4>  Install and configure Redis </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4e/5dc/854/f4e5dc8543844123d64fb68139951e31.png"></div><br>  If you use gem <a href="https://github.com/resque/resque">resque</a> , then you need to install Redis.  For an outdated version in the repository, I compile it from source, and it also takes a little time: <br><pre> <code class="bash hljs">sudo apt-get install tcl8.5 wget http://download.redis.io/redis-stable.tar.gz tar xvzf redis-stable.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> redis-stable make make <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> sudo cp src/redis-server /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin sudo cp src/redis-cli /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin</code> </pre><br><br>  Redis is not password protected by default and is open to everyone, so we put the password: in the 'redis.conf' file, add the <code>requirepass</code> parameter with our password.  Redis is easy to brute force, so I make a password of at least 100 characters.  Also, so that later there are no errors, change the <code>dir</code> parameter to <code>/var/www/other</code> , after creating such a folder ( <code>mkdir /var/www/other</code> ). <br>  We copy our config command <pre> <code class="bash hljs">sudo cp redis.conf /etc/redis/redis.conf</code> </pre><br>  Create an upstart script at '/etc/init/redis-server.conf' with the following content: <br><div class="spoiler">  <b class="spoiler_title">/etc/init/redis-server.conf</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">#!upstart description <span class="hljs-string"><span class="hljs-string">"Redis Server"</span></span> env USER=deployer start <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> runlevel [<span class="hljs-number"><span class="hljs-number">2345</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> runlevel [<span class="hljs-number"><span class="hljs-number">016</span></span>] respawn exec start-<span class="hljs-keyword"><span class="hljs-keyword">stop</span></span>-daemon --start --make-pidfile --pidfile /var/run/redis-<span class="hljs-built_in"><span class="hljs-built_in">server</span></span>.pid --chuid $USER --exec /usr/local/bin/redis-<span class="hljs-built_in"><span class="hljs-built_in">server</span></span> /etc/redis/redis.conf &gt;&gt; /var/www/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br></div></div><br><br>  Now we can manage Redis commands <pre> <code class="bash hljs">sudo start/stop/restart/status redis-server</code> </pre>  by creating a folder for logs ( <code>mkdir /var/www/log</code> ). <br><br><h4>  Installing RVM, Ruby, Rails, Bundler </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/5bf/168/fd75bf168d048c419cf083bad58c8e51.png"></div><br>  There is nothing complicated at all: <br><pre> <code class="bash hljs">sudo apt-get install git curl python-software-properties sudo add-apt-repository ppa:chris-lea/node.js sudo apt-get update sudo apt-get install nodejs curl -L get.rvm.io | bash -s stable <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/.rvm/scripts/rvm rvm requirements rvm install 2.0.0 rvm use 2.0.0 --default gem install rails --no-ri --no-rdoc gem install bundler</code> </pre><br><br><h4>  Create a repository on GitHub / BitBucket </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d1/b5c/563/3d1b5c56357a4371884a9d1b1a94ac13.png"></div><br><br>  We will use git on a remote server to deploy our application.  You can also configure the git server on our VPS, but why, if there are convenient free solutions.  So, we create a repository on GitHub / BitBucket (in BitBucket, private repositories are free), but we are not in a hurry to upload our project there, first edit the .gitignore file (it is in the root of the application) so that no confidential information gets into the repo (this is especially important, if the repo is public), and at the same time we don‚Äôt need the extra files there: <br><pre> <code class="hljs pgsql">/config/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.yml #     /Procfile #      /config/deploy/ #  Capistrano /shared/ # ,    ,           /<span class="hljs-built_in"><span class="hljs-built_in">public</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>/ #   Paperclip</code> </pre><br><br>  Now you can make the first commit and launch the project in git. <br><pre> <code class="bash hljs">git init git remote add origin <span class="hljs-comment"><span class="hljs-comment">#  git add -A git commit -m 'first commit' git push -u origin --all</span></span></code> </pre><br><br>  We also need to add the key of our server to the Github / BitBucket admin panel, this is a prerequisite, since  from the repository changes will be uploaded to the server.  How to do this can be found in the Help service. <br><br><h4>  gem foreman </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26d/932/db9/26d932db99bae73a60f9cdfdb865dcb4.jpg" alt="Dr. Foreman from Dr. House"></div><br>  <a href="https://github.com/ddollar/foreman">foreman</a> is a heme for managing application processes.  On the local machine, it allows you to run all the processes specified in the Procfile at once by one command <pre> <code class="bash hljs">foreman start</code> </pre>  and shows their output. <br>  On the server with a command <pre> <code class="bash hljs">foreman <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> upstart</code> </pre>  he creates an upstart script for easy application management using the start / stop / restart commands.  But more about that later.  For now, just install it, create a Procfile in the root of the application, and fill it for local use.  I have it looks like this. <br><pre> <code class="hljs pgsql">web: rails s job1: bundle exec rake resque:<span class="hljs-keyword"><span class="hljs-keyword">work</span></span> PIDFILE=./tmp/pids/resque2.pid QUEUES=send_email job2: bundle exec rake resque:<span class="hljs-keyword"><span class="hljs-keyword">work</span></span> PIDFILE=./tmp/pids/resque2.pid QUEUES=send_email</code> </pre><br>  We will write the production configuration later when it comes to Capistrano. <br><br><h4>  Install Unicorn </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01b/a1f/26f/01ba1f26f0eeecd3cfe3380416bff98b.png"></div><br>  <a href="https://github.com/defunkt/unicorn">Unicorn</a> is an advanced HTTP server.  Install it by adding <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">group</span></span> :production <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> gem <span class="hljs-string"><span class="hljs-string">'unicorn'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre>  in the gemfile.  (Do not forget about the <code>bundle install</code> ) <br><br>  In the folder '/ config /' create a file unicon.rb with something like this: <br><div class="spoiler">  <b class="spoiler_title">Unicorn.rb</b> <div class="spoiler_text"><pre> <code class="ruby hljs">worker_processes <span class="hljs-number"><span class="hljs-number">2</span></span> working_directory <span class="hljs-string"><span class="hljs-string">"/var/www/apps/_/current"</span></span> <span class="hljs-comment"><span class="hljs-comment"># available in 0.94.0+ # listen on both a Unix domain socket and a TCP port, # we use a shorter backlog for quicker failover when busy listen "/var/www/apps/_/socket/.unicorn.sock", :backlog =&gt; 64 listen 8080, :tcp_nopush =&gt; true # nuke workers after 30 seconds instead of 60 seconds (the default) timeout 30 # feel free to point this anywhere accessible on the filesystem pid "/var/www/apps/_/run/unicorn.pid" # By default, the Unicorn logger will write to stderr. # Additionally, ome applications/frameworks log to stderr or stdout, # so prevent them from going to /dev/null when daemonized here: stderr_path "/var/www/apps/_/log/unicorn.stderr.log" stdout_path "/var/www/apps/_/log/unicorn.stdout.log" # combine Ruby 2.0.0dev or REE with "preload_app true" for memory savings # http://rubyenterpriseedition.com/faq.html#adapt_apps_for_cow preload_app true GC.respond_to?(:copy_on_write_friendly=) and GC.copy_on_write_friendly = true # Enable this flag to have unicorn test client connections by writing the # beginning of the HTTP headers before calling the application. This # prevents calling the application for connections that have disconnected # while queued. This is only guaranteed to detect clients on the same # host unicorn runs on, and unlikely to detect disconnects even on a # fast LAN. check_client_connection false before_fork do |server, worker| # the following is highly recomended for Rails + "preload_app true" # as there's no need for the master process to hold a connection defined?(ActiveRecord::Base) and ActiveRecord::Base.connection.disconnect! # The following is only recommended for memory/DB-constrained # installations. It is not needed if your system can house # twice as many worker_processes as you have configured. # # # This allows a new master process to incrementally # # phase out the old master process with SIGTTOU to avoid a # # thundering herd (especially in the "preload_app false" case) # # when doing a transparent upgrade. The last worker spawned # # will then kill off the old master process with a SIGQUIT. old_pid = "#{server.config[:pid]}.oldbin" if old_pid != server.pid begin sig = (worker.nr + 1) &gt;= server.worker_processes ? :QUIT : :TTOU Process.kill(sig, File.read(old_pid).to_i) rescue Errno::ENOENT, Errno::ESRCH end end # # Throttle the master from forking too quickly by sleeping. Due # to the implementation of standard Unix signal handlers, this # helps (but does not completely) prevent identical, repeated signals # from being lost when the receiving process is busy. # sleep 1 end after_fork do |server, worker| # per-process listener ports for debugging/admin/migrations # addr = "127.0.0.1:#{9293 + worker.nr}" # server.listen(addr, :tries =&gt; -1, :delay =&gt; 5, :tcp_nopush =&gt; true) # the following is *required* for Rails + "preload_app true", defined?(ActiveRecord::Base) and ActiveRecord::Base.establish_connection # if preload_app is true, then you may also want to check and # restart any other shared sockets/descriptors such as Memcached, # and Redis. TokyoCabinet file handles are safe to reuse # between any number of forked children (assuming your kernel # correctly implements pread()/pwrite() system calls) end</span></span></code> the same <code class="ruby hljs">worker_processes <span class="hljs-number"><span class="hljs-number">2</span></span> working_directory <span class="hljs-string"><span class="hljs-string">"/var/www/apps/_/current"</span></span> <span class="hljs-comment"><span class="hljs-comment"># available in 0.94.0+ # listen on both a Unix domain socket and a TCP port, # we use a shorter backlog for quicker failover when busy listen "/var/www/apps/_/socket/.unicorn.sock", :backlog =&gt; 64 listen 8080, :tcp_nopush =&gt; true # nuke workers after 30 seconds instead of 60 seconds (the default) timeout 30 # feel free to point this anywhere accessible on the filesystem pid "/var/www/apps/_/run/unicorn.pid" # By default, the Unicorn logger will write to stderr. # Additionally, ome applications/frameworks log to stderr or stdout, # so prevent them from going to /dev/null when daemonized here: stderr_path "/var/www/apps/_/log/unicorn.stderr.log" stdout_path "/var/www/apps/_/log/unicorn.stdout.log" # combine Ruby 2.0.0dev or REE with "preload_app true" for memory savings # http://rubyenterpriseedition.com/faq.html#adapt_apps_for_cow preload_app true GC.respond_to?(:copy_on_write_friendly=) and GC.copy_on_write_friendly = true # Enable this flag to have unicorn test client connections by writing the # beginning of the HTTP headers before calling the application. This # prevents calling the application for connections that have disconnected # while queued. This is only guaranteed to detect clients on the same # host unicorn runs on, and unlikely to detect disconnects even on a # fast LAN. check_client_connection false before_fork do |server, worker| # the following is highly recomended for Rails + "preload_app true" # as there's no need for the master process to hold a connection defined?(ActiveRecord::Base) and ActiveRecord::Base.connection.disconnect! # The following is only recommended for memory/DB-constrained # installations. It is not needed if your system can house # twice as many worker_processes as you have configured. # # # This allows a new master process to incrementally # # phase out the old master process with SIGTTOU to avoid a # # thundering herd (especially in the "preload_app false" case) # # when doing a transparent upgrade. The last worker spawned # # will then kill off the old master process with a SIGQUIT. old_pid = "#{server.config[:pid]}.oldbin" if old_pid != server.pid begin sig = (worker.nr + 1) &gt;= server.worker_processes ? :QUIT : :TTOU Process.kill(sig, File.read(old_pid).to_i) rescue Errno::ENOENT, Errno::ESRCH end end # # Throttle the master from forking too quickly by sleeping. Due # to the implementation of standard Unix signal handlers, this # helps (but does not completely) prevent identical, repeated signals # from being lost when the receiving process is busy. # sleep 1 end after_fork do |server, worker| # per-process listener ports for debugging/admin/migrations # addr = "127.0.0.1:#{9293 + worker.nr}" # server.listen(addr, :tries =&gt; -1, :delay =&gt; 5, :tcp_nopush =&gt; true) # the following is *required* for Rails + "preload_app true", defined?(ActiveRecord::Base) and ActiveRecord::Base.establish_connection # if preload_app is true, then you may also want to check and # restart any other shared sockets/descriptors such as Memcached, # and Redis. TokyoCabinet file handles are safe to reuse # between any number of forked children (assuming your kernel # correctly implements pread()/pwrite() system calls) end</span></span></code> </pre><br></div></div><br>  We replace the APPLICATION NAME with your application name, which you will later set in the Capistrano settings. <br><br><h4>  Capistrano </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3aa/2f6/0a63aa2f640920d345e0d82d27fe3466.jpg"></div><br>  <a href="https://github.com/capistrano/capistrano">Capistrano</a> is a very convenient tool for deploying an application, even if it does not seem so at first.  Install it with the necessary additions by adding to the Gemfile: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">group</span></span> :development <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> gem <span class="hljs-string"><span class="hljs-string">'capistrano'</span></span> gem <span class="hljs-string"><span class="hljs-string">'capistrano-rails'</span></span> gem <span class="hljs-string"><span class="hljs-string">'capistrano-bundler'</span></span> gem <span class="hljs-string"><span class="hljs-string">'capistrano-rvm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Run the <code>bundle exec cap install</code> and add it to the Capfile: <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'capistrano/deploy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'capistrano/rvm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'capistrano/bundler'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'capistrano/rails'</span></span></code> </pre><br>  Already, just by specifying the server address, the repository and the working folder, Capistrano: <br><ul><li>  Upload your application from the repository to the server in the folder <code>_/_/releases/_/</code> without deleting the old version (by default it stores the 5 latest versions of the applications). </li><li>  Run bundle install. </li><li>  Run db: migrate. </li><li>  Run assets: precompile. </li><li>  Create symlink from the application folder in the folder <code>_/_/current</code> </li></ul><br><br>  But this is not enough for us.  We need to implement the following: <br><ul><li>  For the first time, complete the configuration of nginx, unicorn, download some files that will not change, create an upstart script (using foreman). </li><li>  Before each deployment automatically execute git add, git commit, git push (ask the user to send the message to the commit).  After each deployment create symlinks and restart Unicorn. </li></ul><br>  The files that are needed only for the first time will be stored in the shared folder (in the project folder on the local machine), for good reason we added it to .gitignore.  At first we will create nginx.conf there approximately with such contents: <br><div class="spoiler">  <b class="spoiler_title">nginx.conf</b> <div class="spoiler_text"><pre> <code class="hljs rust">user nginx web; pid /var/run/nginx.pid; error_log /var/www/log/nginx.error.log; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; # increase <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you have lots of clients accept_mutex off; # <span class="hljs-string"><span class="hljs-string">"on"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nginx worker_processes &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> epoll; # enable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Linux <span class="hljs-number"><span class="hljs-number">2.6</span></span>+ # <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> kqueue; # enable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> FreeBSD, OSX } http { # nginx will find this file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the config directory set at nginx build time include mime.types; types_hash_max_size <span class="hljs-number"><span class="hljs-number">2048</span></span>; server_names_hash_bucket_size <span class="hljs-number"><span class="hljs-number">64</span></span>; # fallback <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> case we can<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> determine a <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_type</span></span></span></span> application/octet-stream; # click tracking! access_log /var/www/log/nginx.access.log combined; # you generally want to serve <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> files with nginx since neither # Unicorn nor Rainbows! is optimized <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> it at the moment sendfile on; tcp_nopush on; # off may <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> better <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> *some* Comet/long-poll stuff tcp_nodelay off; # on may <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> better <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> some Comet/long-poll stuff # we haven<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> checked to see <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Rack::Deflate on the app server is # faster or not than doing compression via nginx. It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> easier # to configure it all <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> one place here <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> files and also # to disable gzip <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> clients who don<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> get gzip/deflate right. # There are other gzip settings that may <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> needed used to deal with # bad clients out there, see http:<span class="hljs-comment"><span class="hljs-comment">//wiki.nginx.org/NginxHttpGzipModule gzip on; gzip_http_version 1.0; gzip_proxied any; gzip_min_length 0; gzip_vary on; gzip_disable "MSIE [1-6]\."; gzip_proxied expired no-cache no-store private auth; gzip_comp_level 9; gzip_types text/plain text/xml text/css text/comma-separated-values text/javascript application/x-javascript application/atom+xml; # this can be any application server, not just Unicorn/Rainbows! upstream app_server { server unix:/var/www/apps/_/socket/.unicorn.sock fail_timeout=0; } server { # PageSpeed pagespeed on; pagespeed FileCachePath /var/ngx_pagespeed_cache; location ~ "\.pagespeed\.([az]\.)?[az]{2}\.[^.]{10}\.[^.]+" { add_header "" ""; } location ~ "^/ngx_pagespeed_static/" { } location ~ "^/ngx_pagespeed_beacon$" { } location /ngx_pagespeed_statistics { allow 127.0.0.1; allow 5.228.169.73; deny all; } location /ngx_pagespeed_global_statistics { allow 127.0.0.1; allow 5.228.169.73; deny all; } pagespeed MessageBufferSize 100000; location /ngx_pagespeed_message { allow 127.0.0.1; allow 5.228.169.73; deny all; } location /pagespeed_console { allow 127.0.0.1; allow 5.228.169.73; deny all; } charset utf-8; # enable one of the following if you're on Linux or FreeBSD listen 80 default deferred; # for Linux # listen 80 default accept_filter=httpready; # for FreeBSD # If you have IPv6, you'll likely want to have two separate listeners. # One on IPv4 only (the default), and another on IPv6 only instead # of a single dual-stack listener. A dual-stack listener will make # for ugly IPv4 addresses in $remote_addr (eg ":ffff:10.0.0.1" # instead of just "10.0.0.1") and potentially trigger bugs in # some software. # listen [::]:80 ipv6only=on; # deferred or accept_filter recommended client_max_body_size 4G; server_name _; # ~2 seconds is often enough for most folks to parse HTML/CSS and # retrieve needed images/icons/frames, connections are cheap in # nginx so increasing this is generally safe... keepalive_timeout 5; # path for static files root /var/www/apps/_/current/public; # Prefer to serve static files directly from nginx to avoid unnecessary # data copies from the application server. # # try_files directive appeared in in nginx 0.7.27 and has stabilized # over time. Older versions of nginx (eg 0.6.x) requires # "if (!-f $request_filename)" which was less efficient: # http://bogomips.org/unicorn.git/tree/examples/nginx.conf?id=v3.3.1#n127 try_files $uri/index.html $uri.html $uri @app; location ~ ^/(assets)/ { root /var/www/apps/_/current/public; expires max; add_header Cache-Control public; } location @app { # an HTTP header important enough to have its own Wikipedia entry: # http://en.wikipedia.org/wiki/X-Forwarded-For proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # enable this if you forward HTTPS traffic to unicorn, # this helps Rack set the proper URL scheme for doing redirects: # proxy_set_header X-Forwarded-Proto $scheme; # pass the Host: header from the client right along so redirects # can be set properly within the Rack application proxy_set_header Host $http_host; # we don't want nginx trying to do something clever with # redirects, we set the Host: header above already. proxy_redirect off; # set "proxy_buffering off" *only* for Rainbows! when doing # Comet/long-poll/streaming. It's also safe to set if you're using # only serving fast clients with Unicorn + nginx, but not slow # clients. You normally want nginx to buffer responses to slow # clients, even with Rails 3.1 streaming because otherwise a slow # client can become a bottleneck of Unicorn. # # The Rack application may also set "X-Accel-Buffering (yes|no)" # in the response headers do disable/enable buffering on a # per-response basis. # proxy_buffering off; proxy_pass http://app_server; } # Rails error pages error_page 500 502 503 504 /500.html; location = /500.html { root /var/www/apps/_/current/public; } } }</span></span></code> </pre><br></div></div><br>  This is my config for nginx, there you need to replace 'APPLICATION_NAME' with your application name, indicated in the first line of config / deploy.rb (set: application, 'APPLICATION_NAME'). <br><br>  Now we create in the same place (in / shared /) a Procfile file with the following content: <br><pre> <code class="hljs swift">web: bundle exec unicorn_rails -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/apps/<span class="hljs-number"><span class="hljs-number">_</span></span>/current/config/unicorn.rb -<span class="hljs-type"><span class="hljs-type">E</span></span> production job1: bundle exec rake resque:work <span class="hljs-type"><span class="hljs-type">RAILS_ENV</span></span>=production <span class="hljs-type"><span class="hljs-type">PIDFILE</span></span>=/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/apps/<span class="hljs-number"><span class="hljs-number">_</span></span>/run/resque1.pid <span class="hljs-type"><span class="hljs-type">QUEUES</span></span>=* job2: bundle exec rake resque:work <span class="hljs-type"><span class="hljs-type">RAILS_ENV</span></span>=production <span class="hljs-type"><span class="hljs-type">PIDFILE</span></span>=/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/apps/<span class="hljs-number"><span class="hljs-number">_</span></span>/run/resque2.pid <span class="hljs-type"><span class="hljs-type">QUEUES</span></span>=*</code> </pre><br>  This is a config for an application with two resque workers.  If you are not using Resque, just leave only the first line. <br>  In the same place we create database.yml with database settings and application.yml, if you use the Figaro gem. <br><br>  Your Capistrano script will execute some commands on behalf of the superuser on the server.  To allow him to do this, run the command <pre> <code class="bash hljs">sudo visudo</code> </pre>  on the server and add the line: <br><pre> <code class="hljs ruby">deployer ALL=<span class="hljs-symbol"><span class="hljs-symbol">NOPASSWD:</span></span> /usr/sbin/service, <span class="hljs-regexp"><span class="hljs-regexp">/bin/ln</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/bin/rm</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/bin/mv</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/sbin/start</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/sbin/stop</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/sbin/restart</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/sbin/status</span></span></code> </pre><br><br>  It remains only to configure the Capistrano.  In the file 'config / deploy / production' we make changes: <br> <code>server 'IP ', user: 'deployer', roles: %w{web app db}</code> <br>  In the file 'config / deploy.rb' add on top: <br><div class="spoiler">  <b class="spoiler_title">deploy.rb</b> <div class="spoiler_text"><pre> <code class="ruby hljs">set <span class="hljs-symbol"><span class="hljs-symbol">:repo_url</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> set <span class="hljs-symbol"><span class="hljs-symbol">:application</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span> application = <span class="hljs-string"><span class="hljs-string">'_'</span></span> set <span class="hljs-symbol"><span class="hljs-symbol">:rvm_type</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:user</span></span> set <span class="hljs-symbol"><span class="hljs-symbol">:rvm_ruby_version</span></span>, <span class="hljs-string"><span class="hljs-string">'2.0.0-p353'</span></span> set <span class="hljs-symbol"><span class="hljs-symbol">:deploy_to</span></span>, <span class="hljs-string"><span class="hljs-string">'/var/www/apps/_'</span></span> namespace <span class="hljs-symbol"><span class="hljs-symbol">:foreman</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> desc <span class="hljs-string"><span class="hljs-string">'Start server'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> sudo <span class="hljs-string"><span class="hljs-string">"start </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> desc <span class="hljs-string"><span class="hljs-string">'Stop server'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> sudo <span class="hljs-string"><span class="hljs-string">"stop </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> desc <span class="hljs-string"><span class="hljs-string">'Restart server'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:restart</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> sudo <span class="hljs-string"><span class="hljs-string">"restart </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> desc <span class="hljs-string"><span class="hljs-string">'Server status'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:status</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute <span class="hljs-string"><span class="hljs-string">"initctl list | grep </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> namespace <span class="hljs-symbol"><span class="hljs-symbol">:git</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> desc <span class="hljs-string"><span class="hljs-string">'Deploy'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:deploy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ask(<span class="hljs-symbol"><span class="hljs-symbol">:message</span></span>, <span class="hljs-string"><span class="hljs-string">"Commit message?"</span></span>) run_locally <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute <span class="hljs-string"><span class="hljs-string">"git add -A"</span></span> execute <span class="hljs-string"><span class="hljs-string">"git commit -m '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{fetch(</span></span><span class="hljs-symbol"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-symbol">:message</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">'"</span></span> execute <span class="hljs-string"><span class="hljs-string">"git push"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br></div></div><br>  What does all of this mean?  The first lines - config.  Then we describe the tasks.  There is a task foreman, which has 4 actions: start, stop, restart status.  When you run 'cap production foreman: start' on the local machine on the server, it will execute 'sudo start APPLICATION_NAME', but so far this will not give us anything, because foreman has not yet created upstart scripts.  Go ahead: there is a git task that has a deploy action.  When executing 'cap production git: deploy', the user will be asked to comment on the commit and will be executed: <br><pre> <code class="bash hljs">git add -A git commit -m <span class="hljs-string"><span class="hljs-string">''</span></span> git push</code> </pre><br>  Not difficult at all, right?  But we will not use these commands ourselves, they will be executed when executing other scripts.  Now inside the 'namespace: deploy do' add <br><div class="spoiler">  <b class="spoiler_title">deploy.rb</b> <div class="spoiler_text"><pre> <code class="ruby hljs"> desc <span class="hljs-string"><span class="hljs-string">'Setup'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:setup</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute <span class="hljs-string"><span class="hljs-string">"mkdir </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/config/"</span></span> execute <span class="hljs-string"><span class="hljs-string">"mkdir /var/www/apps/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">/run/"</span></span> execute <span class="hljs-string"><span class="hljs-string">"mkdir /var/www/apps/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">/log/"</span></span> execute <span class="hljs-string"><span class="hljs-string">"mkdir /var/www/apps/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{application}</span></span></span><span class="hljs-string">/socket/"</span></span> execute <span class="hljs-string"><span class="hljs-string">"mkdir </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/system"</span></span> sudo <span class="hljs-string"><span class="hljs-string">"ln -s /var/log/upstart /var/www/log/upstart"</span></span> upload!(<span class="hljs-string"><span class="hljs-string">'shared/database.yml'</span></span>, <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/config/database.yml"</span></span>) upload!(<span class="hljs-string"><span class="hljs-string">'shared/Procfile'</span></span>, <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/Procfile"</span></span>) upload!(<span class="hljs-string"><span class="hljs-string">'shared/nginx.conf'</span></span>, <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/nginx.conf"</span></span>) sudo <span class="hljs-string"><span class="hljs-string">'stop nginx'</span></span> sudo <span class="hljs-string"><span class="hljs-string">"rm -f /usr/local/nginx/conf/nginx.conf"</span></span> sudo <span class="hljs-string"><span class="hljs-string">"ln -s </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/nginx.conf /usr/local/nginx/conf/nginx.conf"</span></span> sudo <span class="hljs-string"><span class="hljs-string">'start nginx'</span></span> within release_path <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> with <span class="hljs-symbol"><span class="hljs-symbol">rails_env:</span></span> fetch(<span class="hljs-symbol"><span class="hljs-symbol">:rails_env</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute <span class="hljs-symbol"><span class="hljs-symbol">:rake</span></span>, <span class="hljs-string"><span class="hljs-string">"db:create"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> desc <span class="hljs-string"><span class="hljs-string">'Create symlink'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:symlink</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute <span class="hljs-string"><span class="hljs-string">"ln -s </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/config/database.yml </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{release_path}</span></span></span><span class="hljs-string">/config/database.yml"</span></span> execute <span class="hljs-string"><span class="hljs-string">"ln -s </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/Procfile </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{release_path}</span></span></span><span class="hljs-string">/Procfile"</span></span> execute <span class="hljs-string"><span class="hljs-string">"ln -s </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{shared_path}</span></span></span><span class="hljs-string">/system </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{release_path}</span></span></span><span class="hljs-string">/public/system"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> desc <span class="hljs-string"><span class="hljs-string">'Foreman init'</span></span> task <span class="hljs-symbol"><span class="hljs-symbol">:foreman_init</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on roles(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> foreman_temp = <span class="hljs-string"><span class="hljs-string">"/var/www/tmp/foreman"</span></span> execute <span class="hljs-string"><span class="hljs-string">"mkdir -p </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{foreman_temp}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment">#   current  ,  foreman  upstart     execute "ln -s #{release_path} #{current_path}" within current_path do execute "cd #{current_path}" execute :bundle, "exec foreman export upstart #{foreman_temp} -a #{application} -u deployer -l /var/www/apps/#{application}/log -d #{current_path}" end sudo "mv #{foreman_temp}/* /etc/init/" sudo "rm -r #{foreman_temp}" end end desc 'Restart application' task :restart do on roles(:app), in: :sequence, wait: 5 do sudo "restart #{application}" end end after :finishing, 'deploy:cleanup' after :finishing, 'deploy:restart' after :updating, 'deploy:symlink' after :setup, 'deploy:foreman_init' after :foreman_init, 'foreman:start' before :foreman_init, 'rvm:hook' before :setup, 'deploy:starting' before :setup, 'deploy:updating' before :setup, 'bundler:install'</span></span></code> </pre><br></div></div><br><br>  There is a deploy task and we added 4 new actions: setup (primary setup), foreman_init (creating an upstart script for the application), symlink (creating symbolic links) and restart (restarting the application).  We also indicate after / before what stages what needs to be done. <br><br>  deploy: setup performs the initial server configuration: loads files from the shared folder on the local computer to the shared folder on the server, configures nginx, creates the necessary folders and starts the deploy: foreman_init, which in turn creates upstart scripts through foreman and copies them to / etc / init, after which we can control our application with the <code>sudo start/stop/restart/status _</code> .  Before deploy: setup, the first three steps of the normal deployment of the application are performed, namely, files are uploaded to the server and <code>bundle install</code> is performed.  After each deployment, new symlinks are created and Unicorn reboots.  It remains only to add in the end of this file <code>before :deploy, 'git:deploy'</code> and now new changes will be automatically committed before each deployment. <br><br>  Again: <br><ul><li>  perform <code>cap production deploy:setup</code> at the very first deployment of your application. </li><li>  perform <code>cap production deploy</code> for each deployment of your application. </li></ul><br><hr><br>  That's exactly the way I always deploy my applications on a VPS.  Of course, this method is not the ultimate truth, but I tried to explain with an example how Capistrano works, so that even a beginner would not have problems changing the script to fit his needs.  I also do not claim that my nginx.conf and unicorn.rb are perfect, but for almost a year everything has been working with me for slightly powerful VPS and there were no problems even under load. </div><p>Source: <a href="https://habr.com/ru/post/213269/">https://habr.com/ru/post/213269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213257/index.html">Therascale OCP Solution</a></li>
<li><a href="../213259/index.html">Code Obfuscation Techniques with LLVM</a></li>
<li><a href="../213261/index.html">CodeFest number 5 - again cake</a></li>
<li><a href="../213263/index.html">Prostokvashino on Habr√© or Uncle Fedor‚Äôs letter</a></li>
<li><a href="../213265/index.html">Init.js: Why and how to develop JavaScript with Full-Stack</a></li>
<li><a href="../213271/index.html">Intuition as a developer tool</a></li>
<li><a href="../213273/index.html">Thanks to 3D printing, a paralyzed woman can walk again</a></li>
<li><a href="../213275/index.html">"Heart Eater" - ASUS RT-AC68U Router: 802.11ac, usb 3.0, BitTorent, TimeMachine</a></li>
<li><a href="../213279/index.html">Airplane: 10 categories of people - those who can and who do not</a></li>
<li><a href="../213281/index.html">PRFLR, or how your code works in production</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>