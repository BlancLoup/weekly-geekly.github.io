<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker images with GOST-certificates support in openssl, curl, php, nginx</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I will talk about how I solved the problem of integration in test mode with services that work using algorithms defined by GOST R 34....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker images with GOST-certificates support in openssl, curl, php, nginx</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, I will talk about how I solved the problem of integration in test mode with services that work using algorithms defined by <a href="http://docs.cntd.ru/document/1200026578">GOST R 34.10-2001</a> (outdated) and <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_%25D0%25A0_34.10-2012">GOST R 34.10-2012</a> .  I will give examples of some of the problems I encountered when solving a problem, give references to a ready-made solution and show several examples of their use. </p><a name="habracut"></a><br><h2 id="prichiny">  The reasons </h2><br><p> For a start it is worth saying that for the production environment there are certified funds from the companies Cryptocom, Crypto-Pro, Signal-KOM and others.  I also needed to implement the interaction in the test (developer) environment on Linux, buying licenses for this is not very convenient, but what's worse, there is no public documentation on this issue.  On the request "https gost" not so many solutions.  Among them, the use of OpenSSL + Crypto CSP is mentioned, I don‚Äôt remember the details, but I didn‚Äôt have this bundle with the support of GOST R 34.10-2012.  Another result that was often encountered was the proposal to use OpenSSL 1.0, in which the GOST-engine is embedded inside, but this solution also did not contain support for <code>GOST2012-GOST8912-GOST8912</code> . </p><br><p>  The working solution turned out to be the OpenSSL 1.1.0g + build taken out in the separately connected dynamic <a href="https://github.com/gost-engine/engine">GOST-engine</a> .  There is often a mention on the Internet that a certain Russian company has made efforts to develop it, but the repository itself does not contain information about the authors of the product.  Taking this opportunity, I thank the authors for the engine in open source.  <a href="https://wiki.openssl.org/index.php/Binaries">This page</a> says that before OpenSSL 1.1.0 the built-in GOST engine was used, now for GOST a third-party product from OpenSSL is used.  Judging by the configuration, most likely, this is the same library. </p><br><h2 id="sborka-openssl-gost-engine-curl">  Build OpenSSL, GOST-engine, cURL </h2><br><p>  Building a third-party product for those who rarely do this can be a non-trivial task.  To build OpenSSL, GOST-engine and cURL I had to deal with a bunch of options and try several combinations of versions.  If you notice strange things in the Dockerfile, then most likely it remains from such experiments. </p><br><p>  I fixed all versions of the projects for the assembly, in order to eliminate the situation that something would stop working due to the update.  For example, I collected the OpenSSL 1.1.0h + GOST-engine and the <code>openssl ciphers</code> command did not contain GOST-algorithms, although the <code>openssl engine</code> showed the GOST-engine in the list.  Having specified the previous version of OpenSSL 1.1.0g, everything worked as expected.  It was very strange, I repeated it again, then I tried to find out the <a href="https://www.openssl.org/news/changelog.html">reasons</a> , but in the end I decided to stay at 1.1.0g. </p><br><p>  Collecting the GOST-engine itself, I did not immediately notice the presence of the <code>INSTALL.md</code> file in the master branch, because I collected <code>openssl_1_1_0</code> from a branch from where the documentation was taken.  That version was built with the custom build of the OpenSSL team </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">cmake</span></span> -DCMAKE_C_FLAGS=<span class="hljs-string"><span class="hljs-string">'-I/usr/local/ssl/include -L/usr/local/ssl/lib'</span></span> ..</code> </pre> <br><p>  But the master branch stopped <code>DOPENSSL_ROOT_DIR</code> like this, there were errors about the absence of <code>DOPENSSL_ROOT_DIR</code> and the like.  As a result, the solution was found and fixed. </p><br><p>  There are a lot more documentation to build cURL with a custom build of OpenSSL, however, the documentation was outdated and I had to experiment a lot with options. <br>  <a href="https://github.com/rnixik/docker-openssl-gost">The result of the work posted here</a> . <br>  <a href="https://hub.docker.com/r/rnix/openssl-gost/">The image is launched in the Docker Hub</a> . </p><br><h2 id="primery-ispolzovaniya-openssl--gost-engine">  Examples of using OpenSSL + GOST-engine </h2><br><p>  I will not go into much detail about working with docker images, I‚Äôll just give one command to start working inside the image: </p><br><pre> <code class="hljs pgsql">docker run <span class="hljs-comment"><span class="hljs-comment">--rm -i -t rnix/openssl-gost bash</span></span></code> </pre> <br><p>  For a start, you can make sure that the algorithms <code>GOST2012-GOST8912-GOST8912</code> and <code>GOST2001-GOST89-GOST89</code> are in the list of supported: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">openssl</span></span> ciphers</code> </pre> <br><p>  If you know a host that uses HTTPS based on GOST algorithms, you can see its certificate and try to connect using the command: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">openssl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s_client</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-connect</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gost</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.example</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:443</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-showcerts</span></span></code> </pre> <br><p>  Create a private key and certificate in accordance with GOST R 34.10-2012: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">openssl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">req</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-x509</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-newkey</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gost2012_256</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-pkeyopt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">paramset</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:A</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-nodes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-keyout</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pem</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-out</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cert</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pem</span></span></code> </pre> <br><p>  Sign the file with previously created certificates: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">openssl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cms</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-sign</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-signer</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cert</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pem</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-inkey</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pem</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-binary</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">file</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.txt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-nodetach</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-outform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DER</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-nocerts</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-noattr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-out</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">signed</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sgn</span></span></code> </pre> <br><p>  Extract the contents of the signed file with a certificate that was signed by itself: </p><br><pre> <code class="hljs objectivec">openssl cms -verify -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span>.sgn -certfile cert.pem -<span class="hljs-built_in"><span class="hljs-built_in">CAfile</span></span> cert.pem -inform der -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> data.txt</code> </pre> <br><p>  With the signatures of the certificates themselves, everything is a little more complicated.  So far I have not come across a service for which the certificate is issued by a trusted certificate authority.  Usually, it is required to additionally indicate the certificate of the certificate authority when working with the certificates issued to them.  This can be done globally for the system (in the image), or explicitly specified in each command. </p><br><p>  The cURL program has not changed in use; it simply supports hosts with GOST certificates. </p><br><h2 id="ispolzovanie-obraza-v-rabote-s-yazykami-programmirovaniya">  Using the image in working with programming languages </h2><br><p>  If a programming language allows you to execute programs installed in the system, then the task of using GOST algorithms is most easily accomplished by copying the binaries of the openssl and curl compiled at the end of the Dockerfile programming language using <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage build</a> .  For example: </p><br><pre> <code class="hljs delphi">FROM rnix/openssl-gost <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> openssl-gost # Replace <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> any other image based <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Debian x86_64 FROM debian:stretch-slim COPY --from=openssl-gost /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/ssl /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/ssl COPY --from=openssl-gost /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/ssl/bin/openssl /usr/bin/openssl COPY --from=openssl-gost /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/curl /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/curl COPY --from=openssl-gost /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/curl/bin/curl /usr/bin/curl COPY --from=openssl-gost /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/gostsum /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/gostsum COPY --from=openssl-gost /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/gost12sum /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/gost12sum</code> </pre> <br><p>  It is not even necessary to copy to <code>/usr/bin</code> , this can be done in any directory, and then called from your program, passing the full path and all the arguments. </p><br><h2 id="podderzhka-gost-algoritmov-v-php">  GOST Algorithm Support in PHP </h2><br><p>  PHP, of course, allows you to make calls to system commands using, for example, <code>exec</code> .  But, looking at how PHP-FPM is going to be in Dockerfile, it seemed to me that you can easily build PHP with custom builds of OpenSSL and cURL.  As it turned out, I was mistaken that it was easy.  I still collected. </p><br><p>  For some reason, I started with PHP-FPM 7.1.  The idea was to use multi-stage build.  To do this, replace the <code>FROM</code> instruction in their Dockerfile with my <code>FROM rnix/openssl-gost AS openssl-gost</code> , then write the copies of the collected openssl and curl before starting the php build itself, and finally, specify the path to these libraries in the <code>--with-openssl-dir=/usr/local/ssl</code> and <code>--with-curl=/usr/local/curl</code> replacing the original ones. </p><br><p>  Surprises waited from everywhere.  One of the most significant was that when building php 7.1, pkg-config is used, and the explicit installation of libcurl4-openssl-dev, libssl-dev was prescribed in the pkg-config version of the packages.  As a result, not what was needed was collected.  If you remove their installation, then <code>/configure</code> php fell, citing the absence of openssl in pkg-config.  I had to additionally copy from the custom openssl and curl assemblies their <code>lib/pkgconfig /*</code> .  After dozens of such surprises, the assembly began to pass.  Then it turned out that the dependencies installed openssl, thus overwriting the previously copied binary of my custom build.  I had to additionally copy it at the very end.  But that's not all. </p><br><p>  <code>openssl_get_md_methods()</code> hashes algorithms appeared in the assembled php: <code>GOST R 34.11-2012 with 256 bit hash</code> , <code>GOST R 34.11-2012 with 512 bit hash</code> , <code>GOST R 34.11-94</code> .  This meant that php connected the GOST-engine.  But the use of the curl extension in php for some reason said that it does not know such algorithms, connecting to the host via GOST-HTTPS.  I spent several hours trying to find the reason for this.  I watched the source, how the curl extension in php is arranged, how the curl itself works, how they communicate with openssl.  I was looking for a place where supported algorithms can be defined or engines can connect.  I searched on master branches, googled a lot, but did not find anything that would solve the problem right away.  Then I remembered that I was not collecting the latest version of PHP. </p><br><p>  I tried to build PHP-FPM 7.2.  I had to make some changes to my script for adjusting the original Dockerfile PHP-FPM, but the build started to go through without a lot of surprises.  The main news was that now the curl extension inside php was able to communicate with hosts in accordance with GOST algorithms, but there was one nuisance.  Each php call wrote to stdout <code>GOST engine already loaded</code> .  Very unpleasant.  I did not immediately understand who was doing this, but I found <a href="">such a line</a> in the GOST-engine source code.  I still do not know in which part of the system the error occurred: php, php-curl, curl, openssl.  But, apparently, in php 7.1 php-curl did not connect the engine at all, now in php 7.2 it began to connect it twice.  Since everything worked correctly, only there was a conclusion, I decided to remove it by editing the source code in the Dockerfile instruction: </p><br><pre> <code class="hljs vhdl">sed -i <span class="hljs-symbol"><span class="hljs-symbol">'s</span></span>|printf(<span class="hljs-string"><span class="hljs-string">"GOST engine already loaded\\n"</span></span>);|goto <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;|' gost_eng.c</code> </pre> <br><p>  There, the line below already has a <code>goto end;</code>  , so I did not do anything serious.  But, having rebuilt the whole zoo, everything began to work, as I wanted. <br>  The image with PHP-FPM + OpenSSL + GOST + cURL is launched in <a href="https://hub.docker.com/r/rnix/php-fpm-gost/">Docker Hub</a> . </p><br><h2 id="podderzhka-gost-sertifikatov-v-nginx">  Support for GOST certificates in nginx </h2><br><p>  The ability to work from programming languages ‚Äã‚Äãis already a lot, but I also wanted two more possibilities: </p><br><ol><li>  Easily raise your web server with a GOST-certified HTTPS (TLS) certificate. </li><li>  Easily proxy all requests to the host with a GOST certificate </li></ol><br><p>  Easy - this means docker image.  It needs to be created.  To do this, you need to build a nginx with a custom OpenSSL and GOST-engine in the Dockerfile.  Having opened the nginx <a href="https://nginx.ru/ru/docs/configure.html">build documentation</a> , I saw one option about ssl - <code>--with-http_ssl_module</code> , which is just boolean.  But nginx is a popular product, there are a lot of instructions for building with openssl, so I found another option <code>--with-openssl=[DIR]</code> .  As practice has shown, nginx wants openssl sources to be here, and the nginx scripts will take care of building themselves.  This is not exactly what I would like (I would like to use a multi-stage build).  I got acquainted with the help-output of the nginx collector, but I could not find anything that would help me there. </p><br><p>  I had to duplicate the instructions for downloading the OpenSSL sources, unpacking, assembling the GOST-engine, including the GOST-engine in the configs.  All this started to come together, but nginx still lacked support for GOST algorithms.  I checked this with the indication in the config <code>ssl_ciphers GOST2001-GOST89-GOST89:HIGH:MEDIUM;</code>  .  Running <code>nginx -t</code> said that it does not know this algorithm. </p><br><p>  As it turned out, the openssl compiled by nginx did not support dynamic engines, i.e.  <code>./Configure</code> output <code>no-dynamic-engine [forced]</code> .  Here I had to carefully read the OpenSSL <a href="https://wiki.openssl.org/index.php/Compilation_and_Installation">build documentation</a> to find out what <code>forced</code> put down.  The reason was found in the openssl <a href="https://github.com/nginx/nginx/blob/78386faf7ee21ecc17db6e90a226c5bd54526f82/auto/lib/openssl/make">build arguments</a> that nginx called, namely <code>no-shared</code> .  If this is specified, then there are no flags to enable support for loading engines.  I had to edit the assembly instructions: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sed</span></span> -i <span class="hljs-string"><span class="hljs-string">'s|--prefix=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ngx_prefix</span></span></span><span class="hljs-string"> no-shared|--prefix=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ngx_prefix</span></span></span><span class="hljs-string">|'</span></span> auto/lib/openssl/make</code> </pre> <br><p>  All this has gathered, but nginx started swearing that it could not find <code>gost.so</code> along the path <code>/usr/lib/x86_64-linux-gnu/</code> , which is rather strange, because the same assembled openssl is looking for and finds engines in a completely different place, exactly where it was going <code>./lib/engines-1.1</code> .  Added instructions for copying compiled engines to <code>/usr/lib/x86_64-linux-gnu/</code> , to please nginx.  It worked. </p><br><p>  Next to the main Dockerfile in the repository, I put a <a href="https://github.com/rnixik/docker-openssl-gost/blob/cebf769a3608952ffedcab888144eaa8c65d6d8f/nginx-gost/Dockerfile_gost_example_com">demo Dockerfile</a> , which, during assembly, creates GOST certificates for itself and uses them, processing connections to <a href="https://gost.example.com/">https://gost.example.com</a> .  We'll have to work with DNS or docker network to try to connect to this demo from one container, but I described all this in the <a href="https://github.com/rnixik/docker-openssl-gost/tree/master/nginx-gost">documentation</a> . <br>  The demo host uses the <code>gost2001</code> keys, other options are <code>gost2012_256</code> , <code>gost2012_512</code> .  And instead of <code>GOST2001-GOST89-GOST89</code> - <code>GOST2012-GOST8912-GOST8912</code> . <br>  The image with nginx + GOST is launched in the Docker Hub: <a href="https://hub.docker.com/r/rnix/nginx-gost/">https://hub.docker.com/r/rnix/nginx-gost/</a> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I have studied the problem of working with GOST-algorithms in Linux systems, provided a solution in the form of docker-images, all this is accompanied by documentation and examples.  The solution is in the form of a repository on GitHub. </p><br><p>  It should be said about the safety of using such a solution.  The main thing is not to trust the images on the Docker Hub, even if it says <code>Automated Build</code> .  I can still collect an image with any edits of all used libraries and systems and push it into my Docker Hub under any tag.  Therefore, I recommend to fork the repository on the githaba, pull it myself and assemble it yourself, checking the instructions in the Dockerfile for the fact that only official resources are used without suspicious modification during the build. </p><br><p>  By assembling the image yourself, you can make sure that malicious edits do not get into the code, because the assembly occurs only from open source, which is available for viewing to everyone.  However, this does not guarantee that there are no bugs and vulnerabilities in it.  Using proprietary certified tools also does not guarantee the absence of errors and vulnerabilities, but besides their code is closed from you. </p><br><h2 id="ssylki">  Links </h2><br><ol><li>  <a href="https://github.com/rnixik/docker-openssl-gost">Repository with all solutions on github</a> </li><li>  <a href="https://hub.docker.com/r/rnix/openssl-gost/">Image on Docker Hub with OpenSSL + GOST + cURL</a> </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_%25D0%25A0_34.10-2012">GOST R 34.10-2012 on Wikipedia with a list of certified solutions</a> </li><li>  <a href="https://github.com/gost-engine/engine">GOST-engine repository</a> </li><li>  <a href="">About the possibilities and limitations of the GOST-engine</a> </li><li>  <a href="https://habrahabr.ru/company/alfa/blog/341476/">An example of how to solve the issue in the production environment</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353534/">https://habr.com/ru/post/353534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353524/index.html">Javascript operating system? Jsos</a></li>
<li><a href="../353526/index.html">System procedural level generation in the Unreal Engine</a></li>
<li><a href="../353528/index.html">Getting to know the cloud: how dynamic traffic distribution works</a></li>
<li><a href="../353530/index.html">How to pass the test MTCNA (Mikrotik) at 100%</a></li>
<li><a href="../353532/index.html">GDPR. Practical advice</a></li>
<li><a href="../353536/index.html">How IaaS helps develop the car market</a></li>
<li><a href="../353540/index.html">The digest of interesting materials for the mobile developer # 249 (April 9 - April 15)</a></li>
<li><a href="../353542/index.html">How to develop a SIEM (Information Security Incident Management System) in one day</a></li>
<li><a href="../353546/index.html">JupyterHub, or how to manage hundreds of Python users. Yandex lecture</a></li>
<li><a href="../353548/index.html">[Yekaterinburg, Announcement] UralJS # 7 - three reports on React Native, convenient navigation in the SPA and the principles of working with DateTime</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>