<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Alan.Platform Tutorial (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, we started modeling checkers with the help of Alan.Platform. We created a library of elements, to which we added one element, an op...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Alan.Platform Tutorial (Part 2)</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/artificial_intelligence/98003/">first part,</a> we started modeling checkers with the help of Alan.Platform.  We created a library of elements, to which we added one element, an operator that controls the location of the checkers.  Also, using the constructor, we created two checkers located at the corners of the platform.  All this could be seen in the console, in the form of text, which was kindly compiled by ObjectDumper. <br><br>  No matter how good ObjectDumper is, it‚Äôs difficult for our brain to see a board for playing checkers among key-value pairs.  Therefore, you need to create a graphical representation for the model.  This we will soon do. <br><a name="habracut"></a><br>  From the graphical interface, we need two things.  The first is the opportunity to see the objects of the created world in the window, to learn their properties.  The second is the ability to act on these objects, change their properties.  It just so happened that the same possibilities are required of the model of the organism - it should be able to ‚Äúfeel‚Äù the properties of the surrounding objects, and also be able to perform actions on them that change these properties. <br><br>  This means that the creation of a graphical interface will be similar to the simulation of the body.  And it is not just similar - the same classes and principles will be used.  The easiest way to explain this is with the following diagram: <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/0d/ab/0dabb49ef1befca9788383d823a2310c.png"></a> <br>  Arrows indicate in which direction the information is moving.  As I said in the first part - the information goes in a circle.  The operator and the brain interact with each other.  At the same time, the states of the world (Properties) and the brain (Memory) change. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Actions and sensors in this case are mediators of this interaction, mediators.  Their main task is to transform information from a form that is understandable to one side to a form that is understandable to the other.  For the operator - this is a set of properties, and for the brain - an array of values. <br><br>  Actions, sensors and the brain together are one entity - the body.  In Alan.Platform the organism is implemented as a class derived from the component - the client.  To him was added the ability to contain a set of sensors, actions and the brain. <br><br>  Thus, for the system, our interface is a normal organism that has a certain shape, location and other properties that the model objects have.  He himself is one of these objects.  And we can all see it with ‚Äúeyes‚Äù and interact with the system with its ‚Äúhands‚Äù. <br><br>  So, what parts will our body consist of?  We need one sensor that will be connected to the CellBoard operator created earlier and that will be able to see the location of the checkers and convert this information into something suitable for display in the window.  You also need one action that will move the checkers on the platform.  Finally, you need a brain that will manage all of this.  He will be responsible for rendering the checkers and handling user actions. <br><br>  It sounds quite difficult, but the suitable brain is already in the Alan.Platform.  It uses WPF to render objects.  Moreover, it is itself inherited from FrameworkElement, so that it can be placed directly on the window. <br><br><h3>  Tutorial ["Part 2"] </h3><br>  Armed with theory, you can smoothly move on to the practical part.  Copy the Platform.Explorer and ElementsLibSample projects from Alan.Platform into the previously created solution.  Let's make Platform.Explorer a default project and add to it a link to a previously created element library containing CellBoard. <br><br>  Let's start with the sensor.  Add a new class UISensor to our library of elements. <br><blockquote><code><font color="black"><font color="#0000ff">using</font> System; <br> <font color="#0000ff">using</font> System.Collections. <font color="#2B91AF">Generic</font> ; <br> <font color="#0000ff">using</font> Platform.Core.Concrete; <br> <font color="#0000ff">using</font> Platform.Core.Elements; <br> <br> <font color="#0000ff">namespace</font> Checkers <br> { <br> [AssociatedOperator( <font color="#A31515">"Checkers.CellBoard"</font> )] <br> [ChannelsCount(300)] <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> UISensor : Sensor <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Update( <font color="#2B91AF">IEnumerable</font> &lt;PropertySet&gt; elements) <br> { <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotImplementedException(); <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Transmit() <br> { <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotImplementedException(); <br> } <br> } <br> }</font></code> </blockquote>  Associated Operator indicates which operator can work with the sensor.  The full name of the operator type is passed to the constructor.  Each sensor and action must have such an attribute. <br><br>  Normally, the ChannelsCount indicates the number of values ‚Äã‚Äãthat are transmitted to the brain.  But our interface brain is not quite ordinary and does not accept values.  In order to squeeze at least some benefit from the attribute, a scale is transferred to its constructor.  By convention, all property values ‚Äã‚Äãrange from 0 to 1. Thus, our checked board has dimensions 1x1.  Using the scale, the board will have a size of 300x300 units when drawing in the window. <br><br>  Next we have implementations of abstract methods.  The Update method is declared in the abstract class Mediator, from which Sensor and Action are inherited.  It helps to realize the "field of view".  For a sensor it is a set of objects whose properties it can see.  For an action, a set of objects whose properties it can change.  These objects are stored in the VisibleElements protected field.  Since we need to see all the objects, the implementation of the Update method will take the form: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Update( <font color="#2B91AF">IEnumerable</font> &lt;PropertySet&gt; elements) <br> { <br> <font color="#0000ff">this</font> .VisibleElements = elements; <br> }</font></code> </blockquote>  This method is called by the operator every time the field of view can change, that is, when one of the objects is moved, and almost immediately after the program is started.  All sets of properties that the operator has are transferred to the method, so that the sensor selects those that it ‚Äúsees‚Äù. <br><br>  The Transmit method is declared in the Sensor class.  His task is to transmit to the brain information about the properties of objects, previously transforming it into a form that the brain can understand.  This method is called by the operator when property values ‚Äã‚Äãchange.  Therefore, the brain is always relevant information about the state of the world. <br><br>  Our brain expects to receive information on how to draw objects.  This mechanism uses the RenderInstructions - a simple wrapper for DrawingVisual.  Three methods are defined in the brain that take instructions: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">void</font> SetShape( <font color="#0000ff">int</font> id, Shapes shape, <font color="#0000ff">double</font> height, <font color="#0000ff">double</font> width); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> SetBrush( <font color="#0000ff">int</font> id, Brush brush); <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> SetTransform( <font color="#0000ff">int</font> id, Transform transform);</font></code> </blockquote>  Id is the identifier of the component for which the instruction is specified.  In the brain, a RenderInstructions object is associated with each id.  Calling one of these methods, we change the properties of this object and force it to be redrawn.  To do this, the RenderOpen () method of the corresponding DrawingVisual object is called inside the RenderInstructions.  A new context is created to render the object, and then WPF will take care of updating the window contents. <br><br>  However, all this is not so important.  The main thing is to understand that after calling any of the three methods, we will immediately see the result on the screen. <br><br>  With arguments, I think, everything should be clear.  Shapes is an enumerated type that so far contains only two forms - an ellipse and a rectangle.  There are dimensions, there is a fill, but there are no coordinates themselves.  It would not be desirable at each moving drafts to open and close the DrawingContext.  Therefore, the movement will be implemented using the TranslateTransform.  Initially, the centers of all checkers will be at the point (0,0), from where they will be transmitted to the destination.  To offset the checkers on the screen, you just need to change the values ‚Äã‚Äãof the X and Y properties of the corresponding TranslateTransform object.  Since these properties are DependencyProperty, you can use animation to change them. <br><br>  With drawing it seems to have figured out, you can begin to implement it.  In the Transmit method, we will need to change the properties of the TranslateTransform.  But before changing them, you need to add this transformation to the RenderInstructions.  There you need to add all the other instructions.  This must be done once after starting the program. <br><br>  The most suitable place for this is the ConnectTo method, declared in the IConnectable interface, which all elements implement.  It is called immediately after starting the program and helps to bind the elements.  Therefore, it is a good place to initialize. <br><br>  We add to our library of elements links to PresentationCore, PresentationFramework, WindowsBase and the ElementsLibSample project. <br><blockquote> <code><font color="black">BaseUIBrain brain; <br> <font color="#0000ff">int</font> scale; <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> ConnectTo(Component parent) <br> { <br> <font color="#0000ff">base</font> .ConnectTo(parent); <br> <br> <font color="#0000ff">this</font> .brain = <font color="#0000ff">this</font> .ConnectedBrain <font color="#0000ff">as</font> BaseUIBrain; <br> <font color="#0000ff">this</font> .scale = Sensor.GetChannelsCount( <font color="#0000ff">this</font> .GetType()); <br> <font color="#0000ff">this</font> .brain.Scale = scale; <font color="#008000">//   .</font> <br> <font color="#0000ff">var</font> checkerBrush = Brushes.BurlyWood; <br> <font color="#0000ff">double</font> diameter = 0.12 * scale; <font color="#008000">//  .</font> <br> <br> <font color="#008000">//     Update  ,   </font> <br> <font color="#008000">// VisibleElements .</font> <br> <font color="#0000ff">foreach</font> ( <font color="#0000ff">var</font> checker <font color="#0000ff">in</font> <font color="#0000ff">this</font> .VisibleElements) <br> { <br> <font color="#008000">//   .</font> <br> <font color="#0000ff">double</font> x = checker[ <font color="#A31515">"X"</font> ].Value * scale; <br> <font color="#0000ff">double</font> y = checker[ <font color="#A31515">"Y"</font> ].Value * scale; <br> <br> <font color="#0000ff">var</font> translate = <font color="#0000ff">new</font> TranslateTransform(x, y); <br> <br> brain.SetShape(checker.Id, Shapes.Ellipse, diameter, diameter); <br> brain.SetBrush(checker.Id, checkerBrush); <br> brain.SetTransform(checker.Id, translate); <br> } <br> }</font></code> </blockquote>  This is already enough to see the cherished circles on the screen.  Platform.Explorer stores the model configuration in the world.xml file.  Open it and replace its contents with the following: <br><blockquote> <code><font color="black"><font color="#0000ff">&lt;?</font> <font color="#800000">xml</font> <font color="#ff0000">version</font> <font color="#0000ff">="1.0"</font> ? <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">component</font> <font color="#ff0000">xmlns</font> <font color="#0000ff">="http://alan.codeplex.com/constructor/world"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">operator</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checkers.CellBoard"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">component</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">propertySet</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checker"</font> <font color="#ff0000">operator</font> <font color="#0000ff">="Checkers.CellBoard"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">property</font> <font color="#ff0000">name</font> <font color="#0000ff">="X"</font> <font color="#ff0000">value</font> <font color="#0000ff">="0.0625"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">property</font> <font color="#ff0000">name</font> <font color="#0000ff">="Y"</font> <font color="#ff0000">value</font> <font color="#0000ff">="0.6875"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">propertySet</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">component</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">component</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">propertySet</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checker"</font> <font color="#ff0000">operator</font> <font color="#0000ff">="Checkers.CellBoard"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">property</font> <font color="#ff0000">name</font> <font color="#0000ff">="X"</font> <font color="#ff0000">value</font> <font color="#0000ff">="0.0625"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">property</font> <font color="#ff0000">name</font> <font color="#0000ff">="Y"</font> <font color="#ff0000">value</font> <font color="#0000ff">="0.9375"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">propertySet</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">component</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">client</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">propertySet</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checker"</font> <font color="#ff0000">operator</font> <font color="#0000ff">="Checkers.CellBoard"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">property</font> <font color="#ff0000">name</font> <font color="#0000ff">="X"</font> <font color="#ff0000">value</font> <font color="#0000ff">="0.1875"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">property</font> <font color="#ff0000">name</font> <font color="#0000ff">="Y"</font> <font color="#ff0000">value</font> <font color="#0000ff">="0.8125"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">propertySet</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">sensor</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checkers.UISensor"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">brain</font> <font color="#ff0000">name</font> <font color="#0000ff">="ElementsLibSample.UIElements.BaseUIBrain"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">client</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">component</font> <font color="#0000ff">&gt;</font></font></code> </blockquote>  Thus, we create three checkers, one of which is our organism-interface.  Now you can run.  This is what should happen in the end: <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/a3/bd/a3bdee21e2fb97bafb55bbd059cc13b3.png"></a> <br>  BaseUIBrain supports object selection.  If you click on any of the checkers, at the bottom you can see the values ‚Äã‚Äãof all its properties (values ‚Äã‚Äãare rounded).  With a little tweaking of XAML and world.xml, you can achieve the following result: <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/da/26/da26dd5626d101b3b9732aac02d9886f.png"></a> <br>  So, there is a sensor, there is a brain.  Left action.  Add a new class MoveChecker to our library of items. <br><blockquote> <code><font color="black"><font color="#0000ff">using</font> System; <br> <font color="#0000ff">using</font> System.Linq; <br> <font color="#0000ff">using</font> System.Collections. <font color="#2B91AF">Generic</font> ; <br> <font color="#0000ff">using</font> Platform.Core.Concrete; <br> <br> <font color="#0000ff">namespace</font> Checkers <br> { <br> [AssociatedOperator( <font color="#A31515">"Checkers.CellBoard"</font> )] <br> [ChannelsCount(3)] <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> MoveChecker : Platform.Core.Elements.Action <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Update( <font color="#2B91AF">IEnumerable</font> &lt;PropertySet&gt; elements) <br> { <br> <font color="#0000ff">this</font> .VisibleElements = elements; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> DoAction( <font color="#0000ff">params</font> <font color="#0000ff">double</font> [] args) <br> { <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotImplementedException(); <br> } <br> } <br> }</font></code> </blockquote>  The Action class is very similar to Sensor, but instead of the Transmit method, it has a DoAction, which takes an array of double values ‚Äã‚Äãfrom the brain.  If the sensors took the properties of objects and made up the data set from them, then the inverse task of the actions - they must, using the data set, find the necessary objects and change their properties. <br><br>  Three arguments will suffice for our action.  In the first one there will be a checker id to move, in the second one the value to which the coordinate ‚ÄúX‚Äù needs to be changed, and in the third one the value to which the coordinate Y is to be changed. <br><br>  That part of the Alan.Platform, which is responsible for changing the properties, is closely related to the internal time of the platform, which I have not mentioned.  Internal time is implemented in cycles.  The center of time management is the static class Platform.Core.Concrete.Time. <br><br>  The idea is that there are some objects, the state of which may depend on time.  These objects are registered in the Time class.  Then, when the user calls the Time.Tick () method, a similar method is called on all registered objects.  The developer can override this method.  These objects are called TimeObjects, and the PropertySet is one of them. <br><br>  PropertySet allows you to schedule property changes as follows: <br><blockquote> <code><font color="black">propertySet[ <font color="#A31515">"PropertyName"</font> ][ticks] = delta;</font></code> </blockquote>  Where ticks is the number of ticks, through which a property should be added to a value, and delta is that value.  For example: <br><blockquote> <code><font color="black">checker[ <font color="#A31515">"Y"</font> ][1] = 0.125;</font></code> </blockquote>  This line means that for the next clock cycle, you should add 0.125 to the ‚ÄúY‚Äù property.  The minimum number of ticks for which you can schedule a change is 1, the maximum is 10 (for now).  That is, you cannot instantly change the value. <br><br>  The reason why a delta is used, rather than a new property value, is simple ‚Äî several deltas can be planned for one measure.  And no matter in which order they will be applied, the end result will remain the same (simple arithmetic rule). <br><br>  Now you can start implementing DoAction: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> DoAction( <font color="#0000ff">params</font> <font color="#0000ff">double</font> [] args) <br> { <br> <font color="#0000ff">var</font> checker = <font color="#0000ff">this</font> .VisibleElements.First(x =&gt; x.Id == args[0]); <br> <br> checker[ <font color="#A31515">"X"</font> ][1] = args[1]; <br> checker[ <font color="#A31515">"Y"</font> ][1] = args[2]; <br> }</font></code> </blockquote>  This is where our action is done and you can add it to world.xml: <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">&lt;/</font> <font color="#800000">propertySet</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">action</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checkers.MoveChecker"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">sensor</font> <font color="#ff0000">name</font> <font color="#0000ff">="Checkers.UISensor"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">brain</font> <font color="#ff0000">name</font> <font color="#0000ff">="ElementsLibSample.UIElements.BaseUIBrain"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">client</font> <font color="#0000ff">&gt;</font> <br> ...</font></code> </blockquote>  If we start Platform.Explorer now, we will not see any changes, since the DoAction method is not called anywhere in our country.  We correct this misunderstanding.  To do this, you need to add a new UIBrain class derived from BaseUIBrain to the library of elements that we used before. <br><blockquote> <code><font color="black"><font color="#0000ff">using</font> ElementsLibSample.UIElements; <br> <br> <font color="#0000ff">namespace</font> Checkers <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> UIBrain : BaseUIBrain <br> { <br> <br> } <br> }</font></code> </blockquote>  We need to, in response to some user action, UIBrain call the DoAction method with the necessary parameters.  The easiest thing to do is hang it on the KeyDown event - pressing a key on the keyboard.  To begin, add a handler for this event.  This can be done in the ConnectTo method: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> ConnectTo(Decorator parent) <br> { <br> <font color="#0000ff">base</font> .ConnectTo(parent); <br> <br> <font color="#0000ff">this</font> .KeyDown += UIBrain_KeyDown; <br> }</font></code> </blockquote>  This tricky ConnectTo method is defined in BaseUIBrain, not IConnectable.  BaseUIBrain has two parents.  One is the client from the model tree of the world, and the other is the Border from the WPF world.  Anyway, initialization of UIBrain can be done in this method. <br><br>  The UIBrain_KeyDown handler is very simple: <br><blockquote> <code><font color="black"><font color="#0000ff">void</font> UIBrain_KeyDown( <font color="#0000ff">object</font> sender, KeyEventArgs e) <br> { <br> <font color="#0000ff">if</font> ( <font color="#0000ff">this</font> .selectedId != 0) <br> { <br> <font color="#0000ff">var</font> moveChecker = <font color="#0000ff">this</font> .actions[ <font color="#A31515">"Checkers.MoveChecker"</font> ]; <br> <br> <font color="#0000ff">switch</font> (e.Key) <br> { <br> <font color="#0000ff">case</font> Key.Q: <br> moveChecker.DoAction(selectedId, -0.125, -0.125); <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> Key.W: <br> moveChecker.DoAction(selectedId, 0.125, -0.125); <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> Key.S: <br> moveChecker.DoAction(selectedId, 0.125, 0.125); <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> Key.A: <br> moveChecker.DoAction(selectedId, -0.125, 0.125); <br> <font color="#0000ff">break</font> ; <br> } <br> Time.Tick(); <br> OnChanged(selectedId); <br> } <br> }</font></code> </blockquote>  First we check if any checker is selected.  If so, the selectedId will contain its index.  Next we find our action.  Then we analyze which of the keys was pressed.  If it is 'Q' - move the highlighted checker up-left, if it is 'W' - up-right, 'S' - down-right, 'A' - down-left.  After that we count one cycle. <br><br>  The Tick method returns control only when all its subscribers process this event.  That is, when changes in properties scheduled for the next cycle will be applied.  At the very end, the OnChanged method is called, which updates the property information at the bottom of the window.  The beat will be counted when you press any of the keys. <br><br>  UIBrain is ready.  It remains only to specify it in world.xml instead of BaseUIBrain and you can run ... The launch fails because we forgot to implement CellBoard.ValidatePropertySet.  This method is called immediately after changing the values ‚Äã‚Äãof the properties in the set.  It is in it that the laws of the world are realized.  Here is what his ad looks like in the Operator class: <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">abstract</font> <font color="#0000ff">bool</font> ValidatePropertySet(PropertySet ps);</font></code> </blockquote>  The only parameter is the set of properties for which you need to check the new state and return the result - whether this state is valid.  If not, it will roll back to the previous state, i.e., the planned property changes will not be applied.  Since the drafts have quite a few laws, while we put the ‚Äúreturn true‚Äù stub in their place and try to run the program again ... <br><br>  Restarting fails because we forgot to implement UISensor.Transmit as well.  Here we need to change the properties of the TranslateTransform objects. <br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Transmit() <br> { <br> <font color="#0000ff">foreach</font> ( <font color="#0000ff">var</font> element <font color="#0000ff">in</font> VisibleElements) <br> { <br> <font color="#0000ff">var</font> translate = brain.GetTransform&lt;TranslateTransform&gt;( <br> element.Id); <br> translate.X = element[ <font color="#A31515">"X"</font> ].Value * scale; <br> translate.Y = element[ <font color="#A31515">"Y"</font> ].Value * scale; <br> } <br> }</font></code> </blockquote>  Well, now just start!  Knocking on wood, press Run ... Urrraa!  If you are not embarrassed by the fact that all the checkers are of the same color, you can play a pat-another. <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/18/2c/182cf40cde3a284f91595f1939f56ac7.png"></a> <br>  Of course, there are some shortcomings.  For example, you can not remove a knocked checker, you can only move it outside the window.  Deleting and adding objects is not currently supported in Alan.Platform.  You can walk with checkers both forward and backward and even put one on top of another.  In principle, this can be fixed - it is enough to add the appropriate code to the CellBoard.ValidatePropertySet, which will reject such checker states.  You can also add colors to the checkers, and also add the state ‚Äúlady-not lady‚Äù.  All this can be done by adding another operator and connecting its own sensor and action to it. <br><br>  This tutorial ends.  In it, we created a model of a world inhabited by 24 checkers, one of which is an organism-interface.  The archive with the final result can be downloaded <a href="">here</a> . <br><br>  In general, the model does not have to be bound to WPF.  It is quite possible by analogy to create a new Command Line Interface in the form of an organism and add it to the rest of the checkers.  It is possible not to add organisms to the model at all, but then no one will see its state and no one will change it. <br><br>  At the very end, I would like to answer the question - what is Alan.Platform?  This is what allows you to forget about the service code, about creating and linking objects, about keeping them up-to-date, etc. You can just sit down and do modeling. <br><br>  PS It may seem that this idea of ‚Äã‚Äãcreating objects at runtime is redundant, complex and inconvenient.  It would be much simpler and clearer to create strongly typed objects with properties similar to how it is shared in ORM systems.  On the one hand, this will simplify the creation of objects, since it will be possible to use all the advantages of OOP.  On the other hand, it will complicate the creation of the laws of the world and the interaction of the brain with objects. <br><ul><li>  Analogue of the operator will not be possible to create, even using the Reflection API. </li><li>  The laws of the world will have to be built into the objects themselves. </li><li>  The inheritance tree will constantly grow. </li><li>  Composition can complicate the process of creating objects. </li><li>  Analogues of sensors and actions will have to either know about all types of objects, or use the Reflection API. </li></ul>  At the very beginning I tried to build a similar system and ran into these problems.  Expanding and complicating a world modeled in this way is very difficult.  Implementing sensors and actions is also very difficult.  At about the same time, it became clear that sensors and actions actually do not need objects - they only need properties.  From here the idea with operators was born.  What happened next, you already know. <br><br>  <i>Those wishing to participate in the project or use it to create something, please contact the LAN or knock on the jabber:</i> <i><br></i>  <i>openminded@xdsl.by</i> </div><p>Source: <a href="https://habr.com/ru/post/98006/">https://habr.com/ru/post/98006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../97999/index.html">New Kindle DX for $ 379</a></li>
<li><a href="../98000/index.html">From July 1 - duty-free import of goods up to 1000 euros (it was: 5-10 thousand rubles)</a></li>
<li><a href="../98001/index.html">Supercomputer problems in the middle lane</a></li>
<li><a href="../98003/index.html">Alan.Platform Tutorial (Part 1)</a></li>
<li><a href="../98005/index.html">Connecting a rotary encoder to a computer via USB</a></li>
<li><a href="../98010/index.html">Again about forms: default values</a></li>
<li><a href="../98013/index.html">Fractality Fractal Clock or Thoughts of Scale and Time</a></li>
<li><a href="../98014/index.html">Making a dystopian / cyberpunk mask</a></li>
<li><a href="../98016/index.html">Online consultant to the site through Jabber</a></li>
<li><a href="../98018/index.html">Project C ++ Migration from Visual Studio 2008 to Visual Studio 2010</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>