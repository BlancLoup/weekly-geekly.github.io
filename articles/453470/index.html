<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Your distributed monoliths weave intrigues behind your back</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Today's translation affects not only and not so much microservices - a topic that is on everyone‚Äôs lips today - but also recalls how impo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Your distributed monoliths weave intrigues behind your back</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Today's translation affects not only and not so much microservices - a topic that is on everyone‚Äôs lips today - but also recalls how important it is to call things by their proper names.  The transition to microservice architecture is sometimes necessary, but, as the author once again emphasizes, it requires carefully calculating the consequences.  Pleasant and fruitful reading! <br><br><img src="https://habrastorage.org/webt/im/q8/dr/imq8drim-mkatdxhbytwowus1ik.jpeg"><br><a name="habracut"></a><br>  From time to time I ask the same question. <br><blockquote>  Is there such an important truth in which only a few agree with you?  - Peter Thiel </blockquote>  Before I sit down for this post, I spent a long time trying this question on one topic, which today is in a serious trend - talking about microservices.  I think now I have something to tell;  some findings are based on reflections, others on practical experience.  So, I tell. <br>  Let's start with one important truth, which will serve as a guide for us in this way as the pole star. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Most implementations of microservices are nothing more than distributed monoliths. <br><br><h4>  Era of monoliths </h4><br>  Any system began as a monolithic application.  I will not go into the details of this topic here - many have not already written a lot about it.  However, the lion's share of information about monoliths is devoted to issues such as developer productivity and scalability, leaving behind the brackets the most valuable asset of any Internet company: data. <br><br><img src="https://habrastorage.org/webt/83/75/yh/8375yhxrmoq8jmhfl-wz97u7slg.png"><br><br>  <i>Typical monolithic application architecture</i> <br><br>  If the data is so important, then why is all attention paid to any other topics, but not to them?  The answer, in general, is simple: because they are not as painful as the data question. <br>  Perhaps the monolith is the only stage in the life cycle of a system where you: <br><br><ul><li>  Fully understand your data model; </li><li>  You can operate on data consistently (assuming that your database is correctly selected for your application case). </li></ul><br>  In terms of data, the monolith is perfect.  And since the data is the most valuable asset of any company, it is better not to break the monolith, unless you have a very good reason for this, or a combination of such reasons.  In most cases, the decisive reason for this kind is the need to scale up (since we live in the real world with its inherent physical limitations). <br><br>  When this moment comes, your system, most likely, passes into a new hypostasis: <b>turns into a distributed monolith</b> . <br><br><h4>  The era of distributed monoliths </h4><br>  Let's say things are going well in your company, and the application needs to evolve.  You have increasingly large customers, and your requirements for billing and reporting have changed both in terms of the set of opportunities and in terms of their volume. <br><br>  Taking seriously the demolition of the monolith, in particular, you will try to implement two small services, one of which will provide reporting, and the second - billing.  Probably, these new services will provide the HTTP API and have a dedicated database for long-term state storage.  After a lot of commits, you, like us in <a href="https://unbabel.com/">Unbabel</a> , can get something resembling the following illustration. <br><br><img src="https://habrastorage.org/webt/lg/js/9g/lgjs9grnmyupckoplo0to5q-kjm.png"><br><br>  <i>Generalized view of the system architecture after detaching the billing and reporting services from the main monolithic application</i> <br><br>  Everything goes according to plan. <br><br><ul><li>  The team continues to break up the monolith into smaller systems; </li><li>  Continuous integration / delivery conveyors work like a clock; </li><li>  The Kubernetes cluster is healthy, the engineers are productive and satisfied with everything. </li></ul><br>  Life is Beautiful. <br><br>  But what if I say that heinous conspiracies are lashing against you right now? <br><br>  Now, looking at your system, you will find that the data was distributed over many different systems.  You started from the stage when you had a unique database where all the data objects were stored, and now your data objects have spread to different places.  Perhaps, you think, there is no problem in this, since microservices are needed to create abstractions and seal data, hiding the internal complexity of the system. <br><br>  You are absolutely right.  But with the increase in scale, more complex problems arise: now at any time you have to fulfill business requirements (for example, track a certain metric) that require access to data located in more than one system. <br><br>  What to do?  In fact, there are many options.  But you are in a hurry, but you need to serve the huge customer fraternity that you have recently registered with, so you have to find a balance between ‚Äúfast‚Äù and ‚Äúgood‚Äù.  After discussing the details, you decide to build an additional system that would perform some ETL work to help solve the final tasks.  This system will need to have access to all read replicas that contain the information you need.  The following figure shows how such a system could work. <br><br><img src="https://habrastorage.org/webt/76/op/x0/76opx0yinpcv5fbxh9x8sais2hm.png"><br><br>  <i>A generic example of an analytical ETL system (we called Automatic Translation Analytics in Unbabel)</i> <br><br>  At Unbabel, we used this approach because: <br><br><ul><li>  It does not affect the performance of each microservice too much; </li><li>  It does not require major infrastructure changes (just add a new microservice); </li><li>  We were able to fairly quickly meet our business requirements. </li></ul><br>  Experience suggests that for some time this approach will be operational - until a certain scale is reached.  At Unbabel, it served us very well until very recently, when we began to face ever more serious challenges.  Here are some things that turned into a headache for us: <br><br>  <b>1. Data Changes</b> <br><br>  One of the main advantages of microservices is encapsulation.  The internal representation of the data may change, but this does not affect the system‚Äôs clients, since they communicate through an external API.  However, our strategy required direct access to the internal data presentation, and therefore, as the team only made some changes to the data presentation (for example, rename the field or change the type from <code>text</code> to <code>uuid</code> ), we also had to change and redeploy our ETL service. <br><br>  <b>2. The need to process many different data schemes</b> <br><br>  As the number of systems to which we needed to connect increased, we had to deal with more and more numerous non-uniform ways of presenting data.  It was obvious that we could not scale all these schemes, the interrelations between them and their representations. <br><br>  <i><b>Root of all evil</b></i> <br><br>  To get a complete picture of what is happening in the system, we had to stop at a monolith-like approach.  The difference was that we had not one system and one database, but dozens of such pairs, each with its own presentation of data;  moreover, in some cases the same data was replicated across several systems. <br><br>  I prefer to call such a system a distributed monolith.  Why?  Since it is completely unsuitable for tracking changes in the system, the only way to display the state of the system is to build a service that connects directly to the data stores of all microservices.  It is interesting to see how many of the colossi of the Internet also faced similar challenges at some point in their development.  A good example in this case that I always like to give is Linkedin. <br><br><img src="https://habrastorage.org/webt/bx/zv/l8/bxzvl8oaw7htdnldzu7fr3toxdm.png"><br><br>  <i>It was just such a jumble of data that LinkedIn information flows as of about 2011 - source</i> <br><br>  At the moment, you may be thinking: ‚Äúwhat are you guys going to do with all this?‚Äù The answer is simple: you need to start tracking changes and keep track of important actions as they occur. <br><br>  <b>We break the distributed monolith by means of event registration (Event Sourcing)</b> <br><br>  As with virtually the rest of the world, systems on the Internet work by responding to actions.  For example, a request to the API may result in the insertion of a new record into the database.  Currently, such details do not bother us in most cases, since we are primarily interested in updating the database status.  Updating a database state is a result of a certain event (in this case, a request to the API).  The phenomenon of the event is simple and, nevertheless, the potential of events is very great - they can even be used to destroy a distributed monolith. <br><br>  <b>An event is nothing but the unchanging fact of some modification that has occurred in your system</b> .  In the microservice architecture, events become critical and help to comprehend data flows, and based on them - to derive the aggregate state of several systems.  Each microservice that performs an action that is interesting from the point of view of the entire system should generate an event along with all the essential information relating to the fact that this event represents. <br><br>  Perhaps you have a question: <br>  ‚ÄúHow can microservices generating events help me with solving the problem of a distributed monolith?‚Äù <br><br>  If you have systems generating events, then there may be a fact log with the following properties: <br><br><ul><li>  No binding to any data warehouse: events are usually serialized using binary formats such as JSON, Avro or Protobufs; </li><li>  Immutability: as soon as an event is fired, it cannot be changed; </li><li>  Reproducibility: the state of the system at any given time can be restored;  it is enough to ‚Äúreplay‚Äù the event log. </li></ul><br>  Using this log, you can display the state using any type of logic at the application level.  You are no longer associated with any set of microservices and <i>N</i> ways, in which data is presented in them.  The single source of truth and your only data repository is now the repository in which your events are stored. <br><br>  Here are a few reasons why the event log seems to me to be the tool that helps break the Distributed Monolith: <br><br>  <b>1. Single source of truth</b> <br><br>  Instead of maintaining the N data sources that may be needed to connect to (multiple) different types of databases, in this new scenario, the ultimate truth is stored in exactly one repository: the event log. <br><br>  <b>2. Universal data format</b> <br><br>  In the previous version of the system, we had to deal with a variety of data formats, since we were directly connected to the database.  In the new layout, we can act much more flexibly. <br><br>  Suppose you like a picture from Instagram that was posted by one of your friends.  Such an action can be described: ‚Äú <i>User X liked the picture P</i> ‚Äù.  And here is the event representing this fact: <br><br><img src="https://habrastorage.org/webt/ff/sp/2x/ffsp2xttqkwolrptkfa3bw66mdc.png"><br><br>  <i>An event corresponding to the AVO approach (Actor, Verb, Object), which simulates the fact that a user has selected the image they like.</i> <br><br>  <b>3. The weakening of communication between producers and consumers</b> <br><br>  Last but not least, one of the greatest benefits of dealing with events is effectively weakening the link between data producers and consumers.  This situation not only simplifies scaling, but also reduces the number of dependencies between them.  The only contract remaining between the systems in this case is the event chart. <br><br><hr><br>  At the beginning of this article the question was posed: Is there such an important truth in which only a few agree with you? <br><br>  Let me come back to him in the conclusion of this excursion.  I suppose most companies do not consider the data as ‚Äúfirst-class entities‚Äù when they start migrating to microservice architecture.  It is argued that all changes to the data can still be carried out through the API, but this approach ultimately leads to the constant complication of the service itself. <br><br>  I believe that the only right approach to capturing data changes in the microservice architecture is to make the systems generate events according to a strictly defined contract.  Having a properly compiled event log, you can display a set of data based on any set of business requirements.  In this case, you just have to apply different rules to the same facts.  In some cases, this data fragmentation can be avoided if your company (especially your product managers) treats the data as a product.  However, this is a topic for another article. </div><p>Source: <a href="https://habr.com/ru/post/453470/">https://habr.com/ru/post/453470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453458/index.html">Real reactive programming in Svelte 3.0</a></li>
<li><a href="../45346/index.html">Project bwpix - black and white pixelart</a></li>
<li><a href="../453460/index.html">When tired of virtual</a></li>
<li><a href="../453464/index.html">Quantum Future (continued)</a></li>
<li><a href="../45347/index.html">Poppies Survival Guide. Part 1</a></li>
<li><a href="../453472/index.html">Bicycle power monitor PZEM004T and ESP8266, with people's monitoring</a></li>
<li><a href="../453474/index.html">Computer control via remote control from the amplifier using Arduino and Node.js</a></li>
<li><a href="../453478/index.html">Studying the health of Starlink satellites Ilona Mask</a></li>
<li><a href="../45348/index.html">Start comparison on GetAFreelancer and oDesk</a></li>
<li><a href="../453480/index.html">Ill-healthy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>