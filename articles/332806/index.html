<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Oculus Rift integration into desktop Direct3D application on the example of Renga</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In this article I want to make out the process of connecting a virtual reality helmet to a desktop application for Windows. It's about Oculus R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Oculus Rift integration into desktop Direct3D application on the example of Renga</h1><div class="post__text post__text-html js-mediator-article">  Hello!  In this article I want to make out the process of connecting a virtual reality helmet to a desktop application for Windows.  It's about Oculus Rift. <br><br>  Architectural visualization is a very fertile topic for various kinds of experiments.  We decided to keep up with the trend.  In one of the following versions of our BIM-systems ( <a href="http://rengabim.com/">let</a> me remind you that I work at <a href="http://rengabim.com/">Renga Software</a> , a joint venture of ASCON and 1C): <a href="http://rengacad.com/ru/renga/architecture/">Renga Architecture</a> - for architectural and construction design and <a href="http://rengacad.com/ru/renga/structure/">Renga Structure</a> - for designing the structural part of buildings and structures, It will be possible to walk on the projected building in a virtual reality helmet.  It is very convenient for demonstration of the project to the customer and evaluation of those or other design decisions from the point of view of ergonomics. <br><br><img src="https://habrastorage.org/web/a80/919/786/a809197865e44558ae525299e25bd316.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  The site developer helmet is available for download <a href="https://developer.oculus.com/downloads/package/oculus-sdk-for-windows/">SDK</a> .  At the time of this writing, the latest available version is 1.16.  There is also OpenVR from Valve.  I did not try this thing myself, but there are suspicions that it works worse than the native for Oculus SDK. <br><br>  Let us examine the main stages of connecting the helmet to the application.  First you need to initialize the device: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVR_D3D_VERSION 11 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// in case direct3d 11 #include "OVR_CAPI_D3D.h" bool InitOculus() { ovrSession session = 0; ovrGraphicsLuid luid = 0; // Initializes LibOVR, and the Rift ovrInitParams initParams = { ovrInit_RequestVersion, OVR_MINOR_VERSION, NULL, 0, 0 }; if (!OVR_SUCCESS(ovr_Initialize(&amp;initParams))) return false; if (!OVR_SUCCESS(ovr_Create(&amp;session, &amp;luid))) return false; // FloorLevel will give tracking poses where the floor height is 0 if(!OVR_SUCCESS(ovr_SetTrackingOriginType(session, ovrTrackingOrigin_EyeLevel))) return false; return true; }</span></span></span></span></code> </pre> <br>  Initialization complete.  Now we have a session - this is a pointer to the internal structure of ovrHmdStruct.  We will use it for all requests to the oculus runtime.  luid is the identifier of the graphics adapter that the helmet is connected to.  It is required for configurations with multiple video cards or laptops.  The application should use the same adapter for drawing. <br><br>  The process of creating a frame in the usual mode and for the helmet Oculus Rift is not very different. <br>  For each eye, we need to create a texture with SwapChain and RenderTarget. <br>  To create textures, Oculus SDK provides a set of functions. <br><br>  An example of a wrapper for creating and storing SwapChain and RenderTarget for each eye: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EyeTexture</span></span></span><span class="hljs-class"> {</span></span> ovrSession Session; ovrTextureSwapChain TextureChain; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ID3D11RenderTargetView*&gt; TexRtv; EyeTexture() : Session(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), TextureChain(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ovrSession session, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeH)</span></span></span><span class="hljs-function"> </span></span>{ Session = session; ovrTextureSwapChainDesc desc = {}; desc.Type = ovrTexture_2D; desc.ArraySize = <span class="hljs-number"><span class="hljs-number">1</span></span>; desc.Format = OVR_FORMAT_R8G8B8A8_UNORM_SRGB; desc.Width = sizeW; desc.Height = sizeH; desc.MipLevels = <span class="hljs-number"><span class="hljs-number">1</span></span>; desc.SampleCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; desc.MiscFlags = ovrTextureMisc_DX_Typeless; desc.BindFlags = ovrTextureBind_DX_RenderTarget; desc.StaticImage = ovrFalse; ovrResult result = ovr_CreateTextureSwapChainDX(Session, pDevice, &amp;desc, &amp;TextureChain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OVR_SUCCESS(result)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> textureCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; ovr_GetTextureSwapChainLength(Session, TextureChain, &amp;textureCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textureCount; ++i) { ID3D11Texture2D* tex = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ovr_GetTextureSwapChainBufferDX(Session, TextureChain, i, IID_PPV_ARGS(&amp;tex)); D3D11_RENDER_TARGET_VIEW_DESC rtvd = {}; rtvd.Format = DXGI_FORMAT_R8G8B8A8_UNORM; rtvd.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D; ID3D11RenderTargetView* rtv; DIRECTX.Device-&gt;CreateRenderTargetView(tex, &amp;rtvd, &amp;rtv); TexRtv.push_back(rtv); tex-&gt;Release(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ~EyeTexture() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)TexRtv.size(); ++i) { Release(TexRtv[i]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TextureChain) { ovr_DestroyTextureSwapChain(Session, TextureChain); } } <span class="hljs-function"><span class="hljs-function">ID3D11RenderTargetView* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRTV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; ovr_GetTextureSwapChainCurrentIndex(Session, TextureChain, &amp;index); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TexRtv[index]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ovr_CommitTextureSwapChain(Session, TextureChain); } };</code> </pre><br>  Using this wrapper, we create a texture for each eye, where we will draw the 3D scene.  The size of the texture needs to be learned from Oculus Runtime.  To do this, you need to get a description of the device and using the ovr_GetFovTextureSize function to get the required texture size for each eye: <br><br><pre> <code class="cpp hljs">ovrHmdDesc hmdDesc = ovr_GetHmdDesc(session); ovrSizei idealSize = ovr_GetFovTextureSize(session, (ovrEyeType)eye, hmdDesc.DefaultEyeFov[eye], <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br>  Another convenient to create the so-called Mirror Texture.  This texture can be displayed in the application window.  Oculus Runtime will copy the image for two eyes after post-processing into this texture. <br><br><img src="https://habrastorage.org/web/95f/55d/1a2/95f55d1a20f144fe9eaf514376ebcb68.png" alt="image"><br><br>  If you do not do post processing, the person will see in the helmet an image obtained using an optical system with positive distortion (image on the left).  To compensate for the oculus imposes the effect of negative distortion (image right). <br><br>  The code for creating mirror texture: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Create a mirror to see on the monitor. ovrMirrorTexture mirrorTexture = nullptr; mirrorDesc.Format = OVR_FORMAT_R8G8B8A8_UNORM_SRGB; mirrorDesc.Width = width; mirrorDesc.Height =height; ovr_CreateMirrorTextureDX(session, pDXDevice, &amp;mirrorDesc, &amp;mirrorTexture);</span></span></code> </pre><br>  An important point when creating textures.  When creating a SwapChain using the ovr_CreateTextureSwapChainDX function, we pass in the desired texture format.  This format is used later for post-processing by the Oculus runtime. <br><br>  For everything to work properly, the application must create a swap chain in the sRGB color space.  For example, <b>OVR_FORMAT_R8G8B8A8_UNORM_SRGB</b> .  If you do not do gamma correction in your application, then you need to create a swap chain in sRGB format.  Set the <i><b>ovrTextureMisc_DX_Typeless</b></i> flag in ovrTextureSwapChainDesc.  Create a Render Target in <b>DXGI_FORMAT_R8G8B8A8_UNORM</b> format.  If this is not done, the image on the screen will be too light. <br><br>  After we have connected the helmet and created textures for each eye, we need to draw the scene into the corresponding texture.  This is done in the usual way that direct3d provides.  There is nothing interesting.  You only need to get his position from the helmet; this is done like this: <br><br><pre> <code class="cpp hljs">ovrHmdDesc hmdDesc = ovr_GetHmdDesc(session); ovrEyeRenderDesc eyeRenderDesc[<span class="hljs-number"><span class="hljs-number">2</span></span>]; eyeRenderDesc[<span class="hljs-number"><span class="hljs-number">0</span></span>] = ovr_GetRenderDesc(session, ovrEye_Left, hmdDesc.DefaultEyeFov[<span class="hljs-number"><span class="hljs-number">0</span></span>]); eyeRenderDesc[<span class="hljs-number"><span class="hljs-number">1</span></span>] = ovr_GetRenderDesc(session, ovrEye_Right, hmdDesc.DefaultEyeFov[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Get both eye poses simultaneously, with IPD offset already included. ovrPosef EyeRenderPose[2]; ovrVector3f HmdToEyeOffset[2] = { eyeRenderDesc[0].HmdToEyeOffset, eyeRenderDesc[1].HmdToEyeOffset }; double sensorSampleTime; // sensorSampleTime is fed into the layer later ovr_GetEyePoses(session, frameIndex, ovrTrue, HmdToEyeOffset, EyeRenderPose, &amp;sensorSampleTime);</span></span></code> </pre><br>  Now, when creating a frame, you need to remember to set the correct view matrix for each eye, taking into account the position of the helmet. <br><br>  After we have rendered the scene for each eye, we need to transfer the resulting textures to the post-processing in Oculus runtime. <br><br>  This is done like this: <br><br><pre> <code class="cpp hljs">OculusTexture * pEyeTexture[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... // Draw into eye textures // ... // Initialize our single full screen Fov layer. ovrLayerEyeFov ld = {}; ld.Header.Type = ovrLayerType_EyeFov; ld.Header.Flags = 0; for (int eye = 0; eye &lt; 2; ++eye) { ld.ColorTexture[eye] = pEyeTexture[eye]-&gt;TextureChain; ld.Viewport[eye] = eyeRenderViewport[eye]; ld.Fov[eye] = hmdDesc.DefaultEyeFov[eye]; ld.RenderPose[eye] = EyeRenderPose[eye]; ld.SensorSampleTime = sensorSampleTime; } ovrLayerHeader* layers = &amp;ld.Header; ovr_SubmitFrame(session, frameIndex, nullptr, &amp;layers, 1);</span></span></code> </pre><br>  After that, the finished image will appear in the helmet.  In order to show in the application what the person in the helmet sees, you can copy the contents of the mirror texture we created earlier into the back buffer of the application window: <br><br><pre> <code class="cpp hljs">ID3D11Texture2D* tex = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ovr_GetMirrorTextureBufferDX(session, mirrorTexture, IID_PPV_ARGS(&amp;tex)); pDXContext-&gt;CopyResource(backBufferTexture, tex);</code> </pre><br>  That's all.  Many good examples can be found in the Oculus SDK. </div><p>Source: <a href="https://habr.com/ru/post/332806/">https://habr.com/ru/post/332806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332794/index.html">Results of SAP Coder 2017: smart refrigerator, recruiter virtual assistant and much more</a></li>
<li><a href="../332798/index.html">The implementation of webhukov on the example of the interaction of third-party services with online cash registers</a></li>
<li><a href="../332800/index.html">Anonymous workaholic: how to motivate yourself</a></li>
<li><a href="../332802/index.html">Pathfinder: how we make the interface for CRPG</a></li>
<li><a href="../332804/index.html">Simple form validation without JS</a></li>
<li><a href="../332808/index.html">How I revived VCSA 6.0</a></li>
<li><a href="../332812/index.html">Stupidly Simple DDoS Protocol (SSDP) generates 100 Gbps DDoS</a></li>
<li><a href="../332814/index.html">Translation of the Appium Essentials book. Chapter 5</a></li>
<li><a href="../332816/index.html">24-core CPU, and I can not move the cursor</a></li>
<li><a href="../332818/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 26</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>