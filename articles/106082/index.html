<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Program code and its metrics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the topics in programming, in which interest periodically appears and disappears, is the question of software code metrics. In large software e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Program code and its metrics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/c09/e91/bfac09e9163f9cc6b95834ae752821e5.png" alt="Measurements ..." align="left"><br>  One of the topics in programming, in which interest periodically appears and disappears, is the question of software code metrics.  In large software environments, mechanisms for counting various metrics from time to time appear.  Wave-like interest in the subject looks like this because so far the metrics have not come up with the main thing - what to do with them.  That is, even if some tool allows you to calculate some metrics well, then what to do with this is often incomprehensible.  Of course, metrics are both the quality control of the code (we do not write large and complex functions), and the "performance" (in quotes) of programmers, and the speed of development of the project.  This article is an overview of the most well-known software code metrics. <a name="habracut"></a><br><br><h2>  Introduction </h2><br>  The article provides an overview of 7 classes of metrics and more than 50 of their representatives. <br><br>  A wide range of software metrics will be presented.  Naturally, it is not advisable to bring all existing metrics, most of them are never applied in practice either because of the impossibility of further use of the results, or because of the impossibility of automating measurements, or because of the narrow specialization of these metrics, but there are metrics that are sufficiently applied. often, and their review will be given below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the general case, the use of metrics allows project managers and enterprises to study the complexity of a developed or even developed project, to estimate the scope of work, the style of the program being developed and the effort spent by each developer to implement a particular solution.  However, metrics can only serve as recommendations, they cannot be fully guided, since programmers, trying to minimize or maximize a measure for their program, may resort to tricks up to a program‚Äôs performance, while developing software.  In addition, if, for example, a programmer wrote a small number of lines of code or made a small number of structural changes, this does not mean that he did not do anything, but could mean that the defect of the program was very difficult to find.  The latter problem, however, can be partially solved by using complexity metrics, since  in a more complex program, the error is harder to find. <br><br><h2>  1. Quantitative metrics </h2><br>  First of all, we should consider the quantitative characteristics of the source code of programs (in view of their simplicity).  The most elementary metric is the number of lines of code (SLOC).  This metric was originally developed to estimate project effort.  However, due to the fact that the same functionality can be split into several lines or written into one line, the metric has become practically inapplicable with the advent of languages ‚Äã‚Äãin which more than one command can be written into one line.  Therefore, there are logical and physical lines of code.  The logical lines of code are the number of program commands.  This version of the description also has its drawbacks, as it strongly depends on the programming language used and the programming style [ <a href="http://www.viva64.com/go.php%3Furl%3D241">2</a> ]. <br><br>  In addition to SLOC, quantitative characteristics also include: <br><ul><li>  number of blank lines </li><li>  number of comments </li><li>  the percentage of comments (the ratio of the number of lines containing comments to the total number of lines, expressed as a percentage), </li><li>  average number of lines for functions (classes, files), </li><li>  average number of lines containing source code for functions (classes, files), </li><li>  average lines for modules. </li></ul><br>  Sometimes they further distinguish the evaluation of the style of the program (F).  It consists in dividing the program into n equal fragments and calculating the estimate for each fragment using the formula Fi = SIGN (Ncom.i / Ni - 0.1), where Ncomm.  <sub>i</sub> is the number of comments in the i-th fragment, N <sub>i</sub> is the total number of lines of code in the i-th fragment.  Then the total score for the entire program will be determined as follows: F = SUM F <sub>i</sub> .  [ <a href="http://www.viva64.com/go.php%3Furl%3D241">2</a> ] <br><br>  Also, the group of metrics based on counting some units in the program code includes Holstead metrics [ <a href="http://www.viva64.com/go.php%3Furl%3D243">3</a> ].  These metrics are based on the following indicators: <br><br>  n1 is the number of unique program statements, including characters <br><br>  separators, procedure names and operation signs (operator dictionary), <br><br>  n2 is the number of unique operands of the program (dictionary of operands), <br><br>  N1 - the total number of operators in the program, <br><br>  N2 - the total number of operands in the program, <br><br>  n1 'is the theoretical number of unique operators, <br><br>  n2 'is the theoretical number of unique operands. <br><br>  Given the entered designations, you can determine: <br><br>  n = n1 + n2 - dictionary of the program, <br><br>  N = N1 + N2 - the length of the program, <br><br>  n '= n1' + n2 'is the theoretical vocabulary of the program, <br><br>  N '= n1 * log <sub>2</sub> (n1) + n2 * log <sub>2</sub> (n2) - the theoretical length of the program (for stylistically correct programs, the deviation of N from N' does not exceed 10%) <br><br>  V = N * log <sub>2</sub> n - the volume of the program, <br><br>  V '= N' * log <sub>2</sub> n 'is the theoretical scope of the program, where n * is the theoretical vocabulary of the program. <br><br>  L = V '/ V - the level of programming quality, for an ideal program L = 1 <br><br>  L '= (2 n2) / (n1 * N2) - the level of programming quality, based only on the parameters of a real program without taking into account theoretical parameters, <br><br>  E <sub>C</sub> = V / (L ') 2 - the difficulty of understanding the program, <br><br>  D = 1 / L '- the complexity of the coding program, <br><br>  y '= V / D2 - expression language level <br><br>  I = V / D - the information content of the program, this characteristic allows you to determine the mental cost of creating a program <br><br>  E = N '* log <sub>2</sub> (n / L) - assessment of the necessary intellectual efforts in the development of the program, characterizing the number of required elementary solutions when writing a program <br><br>  When using Halstead metrics, the disadvantages associated with the ability to write the same functionality with different numbers of lines and operators are partially compensated. <br><br>  Another type of quantitative software metrics is the Jilba metrics.  They show the complexity of the software based on the saturation of the program with conditional operators or loop operators.  This metric, despite its simplicity, fairly well reflects the complexity of writing and understanding the program, and adding such an indicator as the maximum level of nesting of conditional and cyclic operators, the effectiveness of this metric increases significantly. <br><br><h2>  2. Metrics of program control flow complexity </h2><br>  The next large class of metrics, no longer based on quantitative indicators, but on the analysis of the program control graph, is called the program control flow complexity metrics. <br><br>  Before directly describing the metrics themselves, for a better understanding, the control graph of the program and the method of its construction will be described. <br><br>  Let some program be presented.  For this program, a directed graph is constructed that contains only one input and one output, while the vertices of the graph correspond to those parts of the program code that contain only sequential calculations, and there are no branching and cycle operators, and arcs correlate with transitions from block to block and branches of the program.  The condition for constructing this graph: each vertex is reachable from the initial one, and the final vertex is reachable from any other vertex [4]. <br><br>  The most common estimate, based on the analysis of the resulting graph, is the <a href="http://www.viva64.com/terminology/Cyclomatic_complexity_rus.html">cyclomatic complexity of the</a> program (McCabe's cyclomatic number) [4].  It is defined as V (G) = e - n + 2p, where e is the number of arcs, n is the number of vertices, p is the number of connected components.  The number of connected components of a graph can be considered as the number of arcs that must be added to convert a graph to strongly connected.  A graph is strongly connected, any two vertices of which are mutually attainable.  For graphs of correct programs, that is, graphs that do not have sections and ‚Äúhanging‚Äù entry and exit points unreachable from the entry point, a strongly connected graph is usually obtained by closing an arc with a vertex denoting the end of the program to a vertex denoting the entry point into this program.  In essence, V (G) determines the number of linearly independent contours in a strongly connected graph.  So in correctly written programs, p = 1, and therefore the formula for calculating cyclomatic complexity takes the form: <br><br>  V (G) = e - n + 2. <br><br>  Unfortunately, this assessment is not able to distinguish between cyclic and conditional constructions.  Another significant disadvantage of this approach is that programs represented by the same graphs may have completely different predicates in terms of complexity (a predicate is a logical expression containing at least one variable). <br><br>  To correct this deficiency, G. Myers developed a new technique.  He proposed to take the interval as an estimate (this estimate is also called interval) [V (G), V (G) + h], where h is zero for simple predicates and h = n-1 for n-place predicates.  This method allows us to distinguish between different predicates of complexity, but in practice it is almost never used. <br><br>  Another modification of the McCabe method is the Hansen method.  The measure of the complexity of the program in this case is represented as a pair (cyclomatic complexity, number of operators).  The advantage of this measure is its sensitivity to the structured software. <br><br>  Chen's topological measure expresses the complexity of a program in terms of the number of border crossings between areas formed by the program graph.  This approach is applicable only to structured programs that allow only a consistent connection of control structures.  For unstructured programs, the Chen measure essentially depends on conditional and unconditional transitions.  In this case, you can specify the upper and lower bounds of the measure.  The upper one is m + 1, where m is the number of logical operators with their mutual nesting.  The lower one equals 2. When the control graph of the program has only one connected component, the Chen measure coincides with the McCabe cyclomatic measure. <br><br>  Continuing the topic of analysis of the control graph of the program, we can single out another subgroup of metrics - the Harrison and Meijel metrics. <br><br>  These measures take into account the level of nesting and the length of the program. <br><br>  Each vertex is assigned its own complexity in accordance with the operator that it represents.  This initial vertex complexity can be calculated in any way, including the use of Holstead measures.  For each predicate vertex, we select a subgraph generated by vertices that are the ends of arcs emanating from it, as well as vertices reachable from each such vertex (the lower boundary of the subgraph), and vertices lying on the paths from the predicate vertex to some lower boundary.  This subgraph is called the sphere of influence of the predicate vertex. <br><br>  The reduced complexity of the predicate vertex is the sum of the initial or reduced complexity of the vertices within its sphere of influence, plus the primary complexity of the predicate vertex itself. <br><br>  The functional measure (SCOPE) of the program is the sum of the reduced difficulties of all the vertices of the control graph. <br><br>  The functional relation (SCORT) is the ratio of the number of vertices in the control graph to its functional complexity, and the terminal ones are excluded from the number of vertices. <br><br>  SCORT can take different values ‚Äã‚Äãfor graphs with the same cyclomatic number. <br><br>  The Pivovarsky metric is another modification of the measure of cyclomatic complexity.  It allows you to track differences not only between sequential and nested control structures, but also between structured and unstructured programs.  It is expressed by the relation N (G) = v * (G) + SUMMAPi, where v * (G) is the modified cyclomatic complexity, calculated in the same way as V (G), but with one difference: the CASE operator with n outputs is treated as one logical operator, not as n - 1 operators. <br><br>  Pi - nesting depth of the i-th predicate vertex.  To calculate the depth of nesting of predicate vertices, the number of ‚Äúspheres of influence‚Äù is used.  The nesting depth is understood to be the number of all ‚Äúspheres of influence‚Äù of predicates that are either completely contained in the sphere of the vertex under consideration or intersect with it.  The depth of nesting increases due to nesting not of the predicates themselves, but of ‚Äúspheres of influence‚Äù.  Pivovarsky's measure increases with the transition from sequential programs to nested programs and further to unstructured ones, which is a huge advantage over many other measures of this group. <br><br>  The measure of Woodward is the number of intersections of the arcs of the control graph.  Since such a situation should not arise in a well-structured program, this metric is used mainly in weakly structured languages ‚Äã‚Äã(Assembler, Fortran).  The intersection point occurs when the control goes beyond two vertices, which are consecutive operators. <br><br>  The boundary value method is also based on the analysis of the control graph of the program.  To define this method, you must enter a few additional concepts. <br><br>  Let G be the control graph of a program with a single initial and only final vertices. <br><br>  In this graph, the number of incoming vertices at the arcs is called the negative degree of the vertex, and the number of outgoing arcs from the vertex is called the positive degree of the vertex.  Then the set of vertices of the graph can be divided into two groups: vertices with a positive degree &lt;= 1;  vertices with a positive degree&gt; = 2. <br><br>  The vertices of the first group are called the host vertices, and the vertices of the second group are the vertices of selection. <br><br>  Each receiving vertex has a reduced complexity equal to 1, except for the final vertex, the reduced complexity of which is 0. The reduced difficulties of all the vertices of the graph G are summed to form the absolute boundary complexity of the program.  After that, the relative boundary complexity of the program is determined: <br><br>  S0 = 1- (v-1) / Sa, <br><br>  where S0 is the relative boundary complexity of the program, Sa is the absolute boundary complexity of the program, v is the total number of vertices of the program graph. <br><br>  There is a Schneidevind metric, expressed in terms of the number of possible paths in the control graph. <br><br><h2>  3. Metrics of data management flow complexity </h2><br>  The next class of metrics is the metrics of data flow control complexity. <br><br>  Chepin's metric: the essence of the method is to assess the informational strength of a single program module using the analysis of the nature of using variables from the input-output list. <br><br>  The whole set of variables that make up the list of I / O, is divided into 4 functional groups: <br><br>  1. P - input variables for calculations and for providing output, <br><br>  2. M - modifiable, or created within the program variables, <br><br>  3. C - variables involved in the management of the program module (control variables), <br><br>  4. T - variables not used in the program ("parasitic"). <br><br>  Since each variable can simultaneously perform several functions, it is necessary to take it into account in each relevant functional group. <br><br>  Metric Chepina: <br><br>  Q = a1 * P + a2 * M + a3 * C + a4 * T, <br><br>  where a1, a2, a3, a4 are weight coefficients. <br><br>  The weights are used to reflect the different effects on the complexity of the program of each functional group.  According to the author of the metric, the functional group C has the greatest weight, equal to 3, since it affects the program control flow.  The weights of the other groups are distributed as follows: a1 = 1, a2 = 2, a4 = 0.5.  The weight of the group T is not equal to 0, since the "parasitic" variables do not increase the complexity of the program data flow, but sometimes make it difficult to understand.  Taking into account the weighting factors: <br><br>  Q = P + 2M + 3C + 0.5T <br><br>  The Spene metric is based on the localization of data accesses within each program section.  Span is the number of statements containing the given identifier, between its first and last appearance in the program text.  Therefore, an identifier that appears n times has a spen equal to n-1.  With a large spine, testing and debugging is complicated. <br><br>  Another metric that takes into account the complexity of the data flow is a metric that associates the complexity of programs with calls to global variables. <br><br>  The pair ‚Äúmodule-global variable‚Äù is denoted as (p, r), where p is the module that has access to the global variable r.  Depending on the presence in the program of a real call to the variable r, two types of ‚Äúmodule-global variable‚Äù pairs are formed: actual and possible.  A possible reference to r with p shows that the region of existence of r includes p. <br><br>  This characteristic is denoted by Aup and indicates how many times the modules Up actually accessed global variables, and the number Pup - how many times they could get access. <br><br>  The ratio of the number of actual references to possible is determined <br><br>  Rup = Aup / Pup. <br><br>  This formula shows the approximate probability of a link of an arbitrary module to an arbitrary global variable.  Obviously, the higher this probability, the higher the likelihood of an ‚Äúunauthorized‚Äù change in any variable, which can significantly complicate the work associated with modifying the program. <br><br>  Based on the concept of information flows, a Kafur measure has been created.  To use this measure, the concepts of local and global flow are introduced: a local flow of information from A to B exists if: <br><br>  1. Module A calls module B (direct local stream) <br><br>  2. Module B causes module A and A to return B the value that is used in B (indirect local flow) <br><br>  3. Module C calls modules A, B and transfers the result of module A to B. <br><br>  Next, the concept of a global information flow should be given: a global information flow from A to B through the global data structure D exists if module A places information in D, and module B uses information from D. <br><br>  Based on these concepts, the quantity I is introduced - the information complexity of the procedure: <br>  I = length * (fan_in * fan_out) 2 <br>  Here: <br><br>  length - the complexity of the text of the procedure (measured through any of the metrics of volume, such as the metrics of Halstead, McCabe, LOC, etc.) <br><br>  fan_in - the number of local streams entering the procedure plus the number of data structures from which the procedure takes information <br><br>  fan_out - the number of local streams outgoing from the procedure plus the number of data structures that are updated by the procedure <br><br>  You can define the informational complexity of a module as the sum of the informational complexities of its member procedures. <br><br>  The next step is to consider the informational complexity of the module with respect to some data structure.  Informational measure of the complexity of the module relative to the data structure: <br><br>  J = W * R + W * RW + RW * R + RW * (RW - 1) <br><br>  W is the number of procedures that only update the data structure; <br><br>  R - only read information from the data structure; <br><br>  RW - and read and update information in the data structure. <br><br>  Another measure of this group is the Oviedo measure.  Its essence is that the program is divided into linear non-intersecting sections - rays of operators that form the control graph of the program. <br><br>  The author of the metric proceeds from the following assumptions: the programmer can find the relationship between the defining and using occurrences of a variable inside the ray more easily than between the rays;  the number of different determinative occurrences in each ray is more important than the total number of occurrences of the variables in each ray. <br><br>  Let R (i) denote the set of defining occurrences of variables that are located within the radius of the ray i (the defining variable entry is in the radius of the ray if the variable is either local to it and has a defining entry, or for it is a defining entry in some previous ray, and there is no local definition along the way).  Denote by V (i) the set of variables that use entries that already exist in ray i.  Then the measure of the complexity of the i-th ray is given by: <br><br>  DF (i) = SUM (DEF (v <sub>j</sub> )), j = i ... || V (i) || <br><br>  where DEF (v <sub>j</sub> ) is the number of defining occurrences of the variable v <sub>j</sub> from the set R (i), and || V (i) ||  - power of the set V (i). <br><br><h2>  4. Metrics of control flow and program data complexity </h2><br>  The fourth class of metrics is metrics that are close to both the class of quantitative metrics, the class of metrics for the control flow of a program, and the class of metrics for the complexity of a data flow (strictly speaking, this class of metrics and the class of metrics for the control flow of a program are the same topological metrics, but it makes sense to separate them in this context for greater clarity).  This class of metrics establishes the complexity of the program structure both on the basis of quantitative calculations, and on the basis of the analysis of control structures. <br><br>  The first of these metrics is the testing M-measure [5].  A testing measure M is a measure of complexity that satisfies the following conditions: <br><br>  The measure increases with the depth of nesting and takes into account the length of the program.  A measure based on regular investment is closely related to the test measure.  The idea of ‚Äã‚Äãthis measure of program complexity is to count the total number of characters (operands, operators, brackets) in a regular expression with the minimum necessary number of brackets describing the control graph of the program.  All measures of this group are sensitive to the nesting of control structures and to the length of the program.  However, the level of complexity of calculations increases. <br><br>  Also, the measure of software quality is connectedness of program modules [6].  If the modules are strongly connected, then the program becomes difficult to modify and difficult to understand.  This measure is not expressed numerically.  Types of connectedness of modules: <br><br>  Data connectivity - if the modules interact through the transfer of parameters and each parameter is an elementary information object.  This is the most preferred type of connection. <br><br>  Connectedness by data structure - if one module sends another composite information object (structure) for data exchange. <br><br>  A control connection ‚Äî if one sends an information object to another ‚Äî a flag designed to control its internal logic. <br><br>  Modules are linked by a common area if they refer to the same global data area.  Connectivity (coupling) over a common area is undesirable, because, first, an error in a module using a global area may suddenly manifest itself in any other module;  secondly, such programs are difficult to understand, since it is difficult for a programmer to determine which particular data is used by a specific module. <br><br>  Connected content - if one of the modules is referenced to the inside of another.  This is an unacceptable type of coupling, since it completely contradicts the principle of modularity, i.e.  representation of the module in the form of a black box. <br><br>  External connectivity - two modules use external data, such as a communication protocol. <br><br>  Connectedness by means of messages is the most free kind of connectedness, modules are not directly connected with each other, they are communicated through messages that do not have parameters. <br><br>  Lack of connectedness - modules do not interact with each other. <br><br>  Subclass relatedness is the relationship between the parent class and the descendant class, with the descendant associated with the parent, and the parent with the descendant is not. <br><br>  Time bound - two actions are grouped in one module only because, due to circumstances, they occur at the same time. <br><br>  Another measure relating to the stability of the module is the Kolofello measure [7], which can be defined as the number of changes that need to be made in modules other than the module whose stability is checked, and these changes should apply to the module being tested. <br><br>  The next metric from this class is the McClure metric.  There are three stages of calculating this metric: <br><br>  1. For each control variable i, the value of its complexity function C (i) is calculated by the formula: C (i) = (D (i) * J (i)) / n. <br><br>  Where D (i) is a value that measures the scope of the variable i.  J (i) is a measure of the complexity of the interaction of modules in terms of the variable i, n is the number of individual modules in the partitioning scheme. <br><br>  2. For all modules included in the partitioning sphere, the value of their complexity functions M (P) is determined by the formula M (P) = fp * X (P) + gp * Y (P) <br>  where fp and gp - respectively, the number of modules immediately preceding and immediately following the module P, X (P) is the difficulty of accessing the module P, <br><br>  Y (P) is the complexity of call control from the P module of other modules. <br><br>  3. The overall complexity MP of the hierarchical scheme of splitting the program into modules is given by the formula: <br><br>  MP = SUM (M (P)) by all possible values ‚Äã‚Äãof P - modules of the program. <br><br>  This metric is focused on programs that are well structured, composed of hierarchical modules that define the functional specification and management structure.  It is also assumed that in each module there is one entry point and one exit point, the module performs exactly one function, and the modules are invoked in accordance with the hierarchical control system that defines the call relationship on multiple program modules. <br><br>  There is also a metric based on an informational concept - the Berlinger measure [8].  The measure of complexity is calculated as M = SUMMAf <sub>i</sub> * log <sub>2</sub> p <sub>i</sub> , where f <sub>i</sub> is the frequency of occurrence of the i-th symbol, p <sub>i</sub> is the probability of its occurrence. <br><br>  The disadvantage of this metric is that a program containing many unique characters, but in small quantities, will have the same complexity as a program containing a small number of unique characters, but in large quantities. <br><br><h2>  5. Object Oriented Metrics </h2><br>  In connection with the development of object-oriented programming languages, a new class of metrics, also called object-oriented metrics, has appeared.  In this group, Martin‚Äôs metric sets and Chidamber and Kemerer‚Äôs metrics are the most commonly used.  To begin, consider the first subgroup. <br><br>  Before starting the consideration of Martin metrics, it is necessary to introduce the notion of a category of classes [ <a href="http://www.viva64.com/go.php%3Furl%3D242">9</a> ].  In reality, a class can rarely be reused in isolation from other classes.  Virtually every class has a group of classes with which it works in cooperation, and from which it cannot be easily separated.  To reuse such classes, you must reuse the entire class group.  Such a group of classes is strongly connected and is called a category of classes.  For the existence of a class category, the following conditions exist: <br><br>  Classes within the class category are closed to any change attempts all together.  This means that if one class should change, all classes in this category are more likely to change.  If any of the classes is open to some kind of change, they are all open to that kind of change. <br><br>  Classes in a category are reused only together.  They are so interdependent and cannot be separated from each other.  Thus, if any attempt is made to reuse one class in a category, all other classes must be reused with it. <br><br>  Classes in a category share some common function or achieve some common goal. <br><br>  Responsibility, independence and stability of a category can be measured by calculating the dependencies that interact with this category.  Three metrics can be defined: <br><br>  1. Ca: Centripetal clutch.  The number of classes outside this category, which depend on the classes within this category. <br><br>  2. Ce: Centrifugal clutch.  The number of classes within this category, which depend on the classes outside this category. <br><br>  3. I: Instability: I = Ce / (Ca + Ce).  This metric has a range of values ‚Äã‚Äã[0,1]. <br><br>  I = 0 indicates the most stable category. <br><br>  I = 1 indicates the most unstable category. <br><br>  You can define a metric that measures abstractness (if a category is abstract, then it is quite flexible and can be easily expanded) categories as follows: <br><br>  A: Abstract: A = nA / nAll. <br><br>  nA is the number of abstract_classes_in_category. <br><br>  nAll - general_number_classes_in_category. <br><br>  The values ‚Äã‚Äãof this metric vary in the range [0,1]. <br><br>  0 = category is completely specific <br><br>  1 = category is completely abstract. <br><br>  Now, based on Martin‚Äôs metrics, we can construct a graph that reflects the relationship between abstraction and instability.  If we construct on it a straight line defined by the formula I + A = 1, then on this straight line will lie the categories that have the best balance between abstractness and instability.  This line is called the main sequence. <br><br>  Then you can enter 2 more metrics: <br><br>  Distance to the main sequence: D = | (A + I-1) / sqrt (2) | <br><br>  The normalized distance to the main sequence: Dn = | A + I-2 | <br><br>  Practically for all categories it‚Äôs true that the closer they are to the main sequence, the better. <br><br>  The next subgroup of metrics is the Chidamber and Kemerer metrics [10].  These metrics are based on the analysis of class methods, inheritance tree, etc. <br><br>  WMC (Weighted methods per class), total complexity of all class methods: WMC = SUMMA <sub>i</sub> , i = 1 ... n, where c <sub>i</sub> is the complexity of the i-th method, calculated by any of the metrics (Holsted, etc.) depending on the criterion of interest), if all methods have the same complexity, then WMC = n. <br><br>  DIT (Depth of Inheritance tree) - the depth of the inheritance tree (the largest path through the hierarchy of classes to this class is from the ancestor class), the more the better, because with greater depth the data abstraction increases, the class saturation with methods decreases, however with a sufficiently large depth greatly increases the complexity of understanding and writing a program. <br><br>  NOC (Number of children) - the number of descendants (immediate), the more, the higher the abstraction of data. <br><br>  CBO (Coupling between object classes) - coupling between classes, shows the number of classes with which the original class is associated.  For this metric, all the statements introduced earlier for connectedness of modules are true, that is, with a high CBO, data abstraction is reduced and class reuse is difficult. <br><br>  RFC (Response for a class) - RFC = | RS |, where RS is the response set of a class, that is, a set of methods that can potentially be called by a class method in response to data received by a class object.  That is, RS = (({M} ({R <sub>i</sub> }), i = 1 ... n, where M is all possible methods of the class, R <sub>i</sub> is all possible methods that can be called by the ith class. Then RFC will be the power of this set. The greater the RFC, the more difficult is testing and debugging. <br><br>  LCOM (Lack of cohesion in Methods) - lack of cohesive methods.  To determine this parameter, consider a class C with n methods M1, M2, ..., Mn, then {I1}, {I2}, ..., {In} are the sets of variables used in these methods.  Now we define P - the set of pairs of methods that do not have common variables;  Q - a set of pairs of methods that have common variables.  Then LCOM = | P | - | Q |.  A lack of coherence can be a signal that a class can be divided into several other classes or subclasses, so that it is better to increase the cohesion to increase data encapsulation and reduce the complexity of classes and methods. <br><br><h2>  6. Reliability metrics </h2><br>  The next type of metrics is metrics that are close to quantitative, but based on the number of errors and defects in the program.  It makes no sense to consider the features of each of these metrics, it will be enough just to list them: the number of structural changes made since the last test, the number of errors detected during the code review, the number of errors detected during program testing, and the number of necessary structural changes necessary for correct work program.  For large projects, these indicators are usually considered in relation to thousands of lines of code, i.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> average number of defects per thousand lines of code. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Hybrid metrics </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, it is necessary to mention another class of metrics, called hybrid. Metrics of this class are based on simpler metrics and represent their weighted sum. The first representative of this class is the Cocol metric. It is defined as follows: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H_M = (M + R1 * M (M1) + ... + Rn * M (Mn) / (1 + R1 + ... + Rn) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where M is the base metric, Mi is other interesting measures, Ri is correct matched coefficients, M (Mi) - functions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The functions M (Mi) and the coefficients Ri are calculated using regression analysis or task analysis for a specific program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of the research, the author of the metric identified three models for measures: The Holstead measure is used as the baseline, and these models are called the ‚Äúbest‚Äù, ‚Äúrandom‚Äù and ‚Äúlinear‚Äù ones.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The metric of Zolnovsky, Simmons, Thayer also represents a weighted sum of various indicators. There are two variants of this metric: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(structure, interaction, volume, data) SUM (a, b, c, d). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(interface complexity, computational complexity, input / output complexity, readability) SUM (x, y, z, p). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The metrics used in each variant are selected depending on the specific task, the coefficients depending on the value of the metric for decision making in this case.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summing up, I would like to note that not a single universal metric exists. </font><font style="vertical-align: inherit;">Any controlled metric characteristics of the program should be controlled either depending on each other, or depending on the specific task, in addition, hybrid measures can be applied, but they also depend on simpler metrics and cannot be universal. </font><font style="vertical-align: inherit;">Strictly speaking, any metric is only an indicator that depends heavily on the language and programming style; therefore, no measure can be raised to an absolute and any decisions can be made based only on it.</font></font></div><p>Source: <a href="https://habr.com/ru/post/106082/">https://habr.com/ru/post/106082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../106076/index.html">Messenger embedded in your site</a></li>
<li><a href="../106077/index.html">Yandeks.Novosti: Ekaterinburg captures the world</a></li>
<li><a href="../106078/index.html">Touch player</a></li>
<li><a href="../106079/index.html">Once again about Harvest</a></li>
<li><a href="../106080/index.html">MAXIM's Epic File Magazine, or Hi, Losers</a></li>
<li><a href="../106083/index.html">YouTube videos</a></li>
<li><a href="../106084/index.html">Rzhunimagu.rf</a></li>
<li><a href="../106085/index.html">‚ÄúBring back the tomcat‚Äù, or a reliable way to get to the MeeGo 2010 conference in Dublin</a></li>
<li><a href="../106086/index.html">Gas extinguishing system in the data center</a></li>
<li><a href="../106088/index.html">Our new project SHOPTUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>