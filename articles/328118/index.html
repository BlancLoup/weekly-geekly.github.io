<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The story of creating a classic RTS at home from scratch (Part 2: "Resurrection") End of article: Network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About a year ago my article came out, which can be called the " first part " of this article. In the first part, as far as I could, I sorted out in de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The story of creating a classic RTS at home from scratch (Part 2: "Resurrection") End of article: Network</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/5c0/bb8/9d7/5c0bb89d72904e72aebc5e656c30839c.jpg"></div><br>  About a year ago my article came out, which can be called the " <a href="https://habrahabr.ru/post/280520/">first part</a> " of this article.  In the first part, as far as I could, I sorted out in detail the thorny path of an enthusiastic developer who I was once able to independently walk from beginning to end.  The result of these efforts was the game of the <b>RTS</b> genre "The <i>Land of Onimods</i> " that I created at home without engines, designers and other modern development tools.  For the project, <b>C ++</b> and <b>Assembler were used</b> , well, and my own head was the main tool. <br><br>  In this article I will try to talk about how I decided to take on the role of "resuscitator" and try to "resurrect" this project.  A lot of attention will be paid to writing your own game server. <br><br>  This is the end of the article, the beginning is <a href="https://habrahabr.ru/post/327596/">here</a> . <br><a name="habracut"></a><br>  ‚Üí <a href="https://habrahabr.ru/post/327596/">Beginning of the article: Resurrection of the game</a> <br>  ‚Üí <a href="https://habrahabr.ru/post/328116/">Continued article: GUI</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Network </h2><br>  <i>I do not think that without analyzing the <a href="http://astralax.ru/projects/others/ol_wrap">attached example,</a> it will be possible in the subtleties to understand what I will try to talk about.</i>  <i>However, the general thoughts on this matter, I hope, I will be able to convey in any case.</i>  <i>I also have to separately note that I come up with such solutions on my own, so there is always the risk that some of my solution to the problem will be suboptimal.</i>  <i>I studied the library for the network <b>libuv</b> mainly by the method of ‚Äúscientific spear‚Äù, and I also fully admit that people who are engaged in network programming all the time will be able to correct some of my interpretations.</i>  <i>And now, perhaps, I will return to the topic of the article ...</i> <br><br>  At first, I honestly wanted to use the <b>WinSock</b> library for networking.  However, I quickly changed my mind, as it was obvious that in this way I would again be completely tied to <i>Windows</i> , which I really did not want.  Therefore, I rummaged through the Internet and found an interesting solution called <b>libuv</b> .  This library is free.  Works on <i>Windows</i> , <i>Unix</i> , <i>Mac OS</i> and <i>Android</i> .  And also does not pull modern innovations, like the requirement to use the latest standard of the C ++ language.  And in general, it is written in pure C, which I consider to be an additional benefit for the developer, since my eternally lifesaving principle sounds like: ‚Äúthe simpler the better.‚Äù <br><br>  At first I had 2 problems: <br><br><ol><li>  I never wrote servers from scratch, so I had to come up with the general structure of the program. <br><br></li><li>  Documentation on <b>libuv</b> , in my opinion, leaves much to be desired.  In general, I always wondered how you could make quite a decent product and be too lazy to more or less describe its capabilities.  But, unfortunately, almost all developers suffer from this.  The last stage of laziness in this area is the use of automatic generation of documentation using the <b>Doxygen</b> utility (and others like it), which turns comments into code in the help, and also automatically generates connections between classes and structures.  I‚Äôm probably behind the times, but I don‚Äôt see a better way to harm my own library than automatically generating a ‚Äútrash bin‚Äù for it from various structures and diagrams, where it is often not clear where to start. </li></ol><br>  The second problem I had was partially compensated by the fact that I also never used <b>WinSock</b> and, accordingly, it was not so important to me how to deal with <b>WinSock</b> or <b>libuv</b> .  But since <b>libuv</b> promised me several platforms without having to rewrite anything, he clearly won in my eyes. <br><br>  Despite the fact that now game developers often remove the possibility of playing on a local network, I decided that I would keep this version of the network game too.  In the first part of the article, I personally explained that to play <b>RTS</b> over a local network, no server is needed at all, since the game runs on each computer independently and no coordinating center is required.  And indeed it is.  However, in my case, I wanted to get two options for a network game: via the Internet and through a local network.  If I began to use the peer-to-peer way of interaction between computers for a local network, such a solution would create a second branch of code.  Would such a solution work faster?  Probably yes, but hardly a player would be able to sense the difference, since in LAN, data usually quickly reaches the target. <br><br>  As a result, I logically reasoned that I would also use a server for the local network. <br><br><h2>  A bit of theory about addresses and ports. </h2><br>  As many probably know, every computer in the world included in the Internet should be assigned a unique address (unless, of course, NAT or something similar is used).  This address is called IP.  An IP address consists of 4 digits and, in the ‚Äúhuman form‚Äù, looks like this: 234.123.34.18 <br><br>  At these addresses computers and find each other.  However, usually many programs are running on the same computer at the same time, so there is an additional concept of ‚Äúport‚Äù.  Programs can discover these ports and establish interaction through them.  To make it clearer ... IP-address is like: Russia, Buhalovskaya oblast, village ‚ÄúBolshaya golodukhino‚Äù, ul.  "New Russian descent", d. 18, and "port" is the apartment number <s>where the money is</s> in which a specific person lives.  Without an apartment (port) number it is impossible to deliver a ‚Äúletter‚Äù to a specific person (program), therefore the concept of ‚Äúport‚Äù is very important.  Usually the port is written after the IP-address separated by a colon, for example: 234.123.34.18:57 <br><br>  The delivery of messages between computers is carried out by special programs called protocols.  The most famous protocol that holds the entire Internet is <b>TCP</b> .  There is another very important protocol called <b>UDP</b> , but it is somewhat more difficult to use. <br><br>  Briefly explain the difference for those who are not very familiar with this topic. <br><br>  <b>UDP</b> allows you to transfer data in chunks.  This piece of data is called a <i>datagram</i> .  The datagram can be sent to the specified IP address and port.  But ... the <b>UDP protocol</b> ‚Äúpromises nothing to you‚Äù, i.e.  The sent datagram can easily get lost on the way, and in this case, the recipient simply does not receive anything.  And if several datagrams were sent, they may come in a different order or some may not come, i.e.  Any options are possible here and this is a perfectly legal behavior for <b>UDP.</b>  The only thing that <b>UDP</b> guarantees is the fact that if the datagram has arrived, it has come completely, i.e.  ‚Äúhalf‚Äù datagram cannot come. <br><br>  <b>TCP</b> works in a completely different way.  He does not send any incomprehensible datagrams to the unknown network space to the mercy of fate - he first establishes a channel of communication with the recipient and clearly sends data through this channel.  <b>TCP</b> ensures that all transmitted data reaches the recipient, and reach exactly in the order in which they were sent.  The data itself does not come in the form of fixed-length datagrams, but in the form of a stream of bytes (a good analogy is byte-writing data to a file).  Note that with this approach, <b>TCP</b> can divide the sent messages into parts as it pleases, i.e.  The recipient may first receive only a portion of the sent data, and after a while the remaining half will arrive. <br><br>  For communication between the program and the port, so-called sockets are used.  The socket is connected to the port and then all the interaction with the port occurs through this socket.  The existence of a socket without a port does not make much sense, since the socket is not involved in anything other than interacting with the port. <br><br><h2>  Protocol selection </h2><br>  At the initial stage, I needed to choose a protocol for interaction.  If you do not write your own solution, then there are only two options: <b>TCP</b> and <b>UDP</b> .  <b>UDP</b> is good where you can not allow delays in the game process.  Usually, the game itself is performed on the server, and clients only receive data from the server about changes in the game situation.  Such an approach allows literally ‚Äúnot paying attention‚Äù to a player with whom there is a bad connection.  All other players will continue to play quite comfortably, as the server does not stop the game to wait for the lagging behind.  An example of such a game is <i>Counter Strike</i> . <br><br>  In the case of <b>RTS,</b> this approach is often not suitable, since the game process requires a large amount of computation and therefore runs on each computer, and these computers must do everything the same.  Therefore, each computer from each other computer must constantly receive a list of actions performed by the player in one "network tact".  If the list is late, you will have to wait until it is received.  Those.  even if you use <b>UDP</b> , you will have to control the delivery of messages yourself.  Therefore, <b>TCP</b> was selected. <br><br>  <i>As I heard, Starcraft2, despite the fact that it belongs to the genre of <b>RTS</b> , still works on the server.</i>  <i>It is possible that modern iron has reached such a level as to use this method.</i>  <i>But in my case, the network is made in a ‚Äúclassic‚Äù way for the <b>RTS</b> .</i> <br><br><h2>  What does the server do? </h2><br>  In fact, he does almost nothing until he receives any message from the client.  In the case of <b>TCP</b> , the server‚Äôs task is to open the port and listen to it.  If a request comes to this port from a client asking to establish a <b>CONNECT</b> connection, then the server should perform <b>ACCEPT</b> , which opens a new random port and informs the client.  The client, having received a random port from the server, opens its own random port and a connection is established on these ports between the server and the client.  The connection will exist until one of the parties wishes to close it, or until the connection is broken for technical reasons.  The server establishes one connection with each client.  All data that clients send to each other, passes through the server, but never directly from client to client, as in the case of a peer-to-peer network. <br><br>  My server has the following tasks: <br><br><ul><li>  It exchanges a ‚Äúgreeting‚Äù with the client and, if everything is in order, it gives the client the opportunity to exchange messages with himself and other clients. </li><li>  Forwards messages between clients, acting as an intermediary. </li><li>  Registers a new game session and sends information about it to clients who request a list of existing sessions (the game session is created by the host, that is, the client that creates the network game and waits for other players to join it). </li><li>  Deletes a game session if there are no more players in it.  The server keeps track of which players enter into which session. </li><li>  Engaged in sending text messages between players, i.e.  for example, focusing on the name of the player, can transfer a private message only to this player.  Practically, this is a normal chat. </li><li>  Monitors the situation with an emergency disconnection of the player - informs other participants of the game session about this fact. </li><li>  Monitors the network activity of each player.  If the player does not receive any data for a long time, the server assumes that something is wrong and resets the connection. </li><li>  Responds to ping requests from the client.  Pinging a server allows you to approximately determine connection delays, as well as maintain client activity, which the server monitors. </li><li>  Allows administrator control over their work.  In general, administration is a separate story that has nothing to do with the game.  In my case, I wrote for myself a separate utility that will control the Internet server of my game.  This utility doesn‚Äôt deal with anything else as soon as it shows server statistics: the number of players, the number of game sessions, the connection between players and sessions, and so on.  It also allows you to restart and shut down the server. </li></ul><br><h2>  What does the client do? </h2><br>  On the client, the game itself takes place.  The client knows that he is not alone in the game, and it is necessary to send messages to the other participants about the player‚Äôs actions and receive the same messages. <br><br><ul><li>  It exchanges a ‚Äúgreeting‚Äù with the server and, if successful, it is possible to exchange messages over the network. </li><li>  It creates its own game session (in this case, such a client is called a host, since it is ‚Äúsenior by session‚Äù). </li><li>  Requests a list of already existing game sessions from the server. </li><li>  Has the opportunity to join an existing game session. </li><li>  Being a participant in a session can change its characteristics, for example, choose a political union and race.  In addition, the host can add bots to the session or remove other players from the session, as well as cancel the session. </li><li>  Text messaging between those present on the server, speaking not in Russian, ‚Äúchat‚Äù. </li><li>  If someone from the session participants does not have the card on which the game will take place, then the host must forward this card to him. </li><li>  The host has the right to run the game, if all players are marked with the flag "Ready". </li><li>  During the game, customers accumulate the player's actions from the mouse and keyboard for a certain period of time (network beat) and send them to other players.  It is impossible to continue the game if the full exchange of these messages between all participants of the game session has not been implemented.  If a player is late, the rest of the players will be waiting for him.  If the waiting is delayed, a message is displayed on the topic ‚ÄúProblem of communication with such a player‚Äù and the time counter, which counts the time in the opposite direction to 0. If during this time communication with the player is not restored, then he is forcibly disconnected from the game. </li><li>  In case ‚Äúnetwork desynchronization‚Äù is noticed (when the game starts to flow in different ways on different computers), the host tries to restore the damaged game.  For this, practically, all the game data is recorded in a file and sending this file to the other participants in the session.  In turn, other participants read this file and completely replace their data with data received from the host.  In fact, this is an analogue of <b>Save</b> / <b>Load</b> . </li></ul><br><h2>  Differences between the Internet server and the LAN server </h2><br>  How paradoxical it sounds, but the local network server is somewhat more complex than the Internet server.  Why is that? <br><br>  Please note that the Internet server runs as a separate program, which is running somewhere somewhere and should ideally work forever.  The local server is created <u>for a time</u> on a computer that acts as a host.  Such a server does not exist as a separate program, but only as a separate stream that has access to any data of the main application, which entails small packet problems that can be treated by synchronization of flows.  And ‚Äúmultithreading‚Äù is generally a separate debugging section that can seriously and permanently spoil the life of any developer. <br><br>  Further, note that the principle of connecting the client to the Internet server and the local server is completely different.  In order for the client to connect to the Internet server, it must know its IP address and port.  And this data should indicate the player in any text field.  And in the local network, existing game sessions should be detected without specifying any IP addresses.  Such an action is achieved through a so-called ‚Äúbroadcast request‚Äù, whose IP is 255.255.255.255.  This address means ‚Äúthe entire local network at once,‚Äù but for <b>TCP,</b> this will not work, since this is a pure <b>UDP</b> feature.  Why is <b>TCP</b> unable to work with a broadcast address?  Well, as I explained above, <b>TCP</b> must establish a communication channel and communicate strictly one by one.  And here it is necessary to ‚Äúhail‚Äù the entire local network according to the principle ‚Äúhey, is there anyone here?  Call out! "  Well, those who "are" should respond by transferring information about the game session to the applicant.  Therefore, on the local server will have to use more and <b>UDP</b> . <br><br>  Well, for a sweet ... Imagine that during the game the host on which the local server is running, suddenly lost or just left the game for some reason.  What will happen to you?  And the same thing happens in <i>Diablo2</i> , when the one who created the game decided to leave the game session before the others.  In <i>Diablo2</i> , the rest of the unfortunates on a black screen get a message in the ‚Äúhost is no longer available‚Äù style, and, in fact, everything ... the players are simply thrown out of the game.  The reason for this behavior is that leaving the session, the host also closes its local server, and after all all the players are attached to it.  To combat such ugly behavior in <b>DirectPlay</b> , there once existed a beautiful thing called ‚Äúhost migration‚Äù.  In a nutshell, it looks like this ... when information about his sudden demise comes from the local server, the remaining clients decide to start a new server and reconnect to it again.  You can run a local server on the client, which is the very first in the list of players in the session.  Next, the server must wait until everyone who was previously in the game can connect to it, well, and if everything is in order, the game will continue. <br><br>  The Internet server, however, also has its own characteristics.  The main feature is that there is always a danger that the server will crash or freeze due to a developer or OS error.  In this case, all players who are currently in the game will be very annoyed.  But with this situation it is hardly possible to do something, except to try to identify as many errors as possible before the release.  But, nevertheless, in any complex program errors remain, and the question here is only in the probability of their occurrence. <br><br>  But even suppose that the server suddenly took and "died", and the players were disconnected.  After the developer stops cursing for his ‚Äúcurved hands‚Äù, the player usually tries to reconnect to the server.  But ... if the server is "dead", then it will not work until someone restarts it, and if nobody watches the server, this can happen very soon.  As a result, the player's anger can begin to spontaneously increase, which can lead to serious psychological consequences.  He will begin to subside badly, tests will deteriorate sharply and, practically, a person will be close to a nervous breakdown.  Personally, I would not want to take on such responsibility, so I decided to insure in advance. <br><br>  The Internet server should not work independently - there should be a controller who will start the server and try to monitor its work.  This requires periodically sending a signal to the server and receiving a response.  If the signal remains unanswered, this means that the server "crashes."  In this case, you must first kill the server process permanently, and then restart the server.  This approach should somehow protect the server, although I do not know how effective it will be in practice, but I have no doubt that this is a move in the right direction. <br><br>  In addition, the controller program can perform some additional actions.  For example, you can instruct her to upgrade the server.  In my case, it looks like this: <br><br>  1) For example, I decided to fix something on the server and assembled a new version of the server, but if someone is interested in the game, then someone constantly plays on the server.  Restarting the server will result in players being thrown out of the game, which is always fraught with emotional experiences. <br><br>  2) Knowing this, I teach the server and the monitoring utility to update the server in ‚Äúsoft mode‚Äù, which is performed as follows.  Through the administration utility, the new server is transferred as a regular file, which gets to the computer where the main server is running.  After that, the main server closes its listening port, but does not shut down, that is, in practice, new players will not be able to join anymore, and those who are ‚Äúalready here‚Äù will continue to play quietly.  Further, this server will periodically check for a situation when all players disconnect from it, and then it will quietly complete the work.  At this time, the controller program will detect the sent file of the new server and launch it for execution in parallel with the old server.  Since the listening port from the old server will already be released, the new server will start listening to it, which will connect all new players to it.  After some time, the old server will turn itself off, and only one new version of the server will remain in operation. <br><br>  All this sounds pretty good, but, unfortunately, at the time of this writing, I could not check the server under a good real load.  This is the typical problem of developing projects with enthusiasm, when there is no team of testers who are paid to simply play and report problems found.  But common sense tells me that I am doing everything in the right direction, so I have included my thoughts on this subject in the article. <br><br><h2>  Libuv library functions </h2><br>  In this section, I will try to briefly describe the functions of the <b>libuv</b> library that I had to deal with during the development of network interaction.  At a minimum, this information can be a useful reference, including for me, since good memory is not my strong quality. <br><br>  The <b>libuv</b> interaction with the user is entirely based on the use <b>of callback functions</b> or <b>callback functions</b> .  How it works?  For example, a user wants to send a message via <b>TCP</b> .  For this, the <i>uv_write ()</i> function is used, which, of course, takes as parameters ‚Äúwhat to send‚Äù and ‚Äúthrough which socket‚Äù.  But besides this, you must also specify the address of the user-defined function, which will be called when the sending is successfully completed.  It is these functions that allow you to control the events.  The same applies to receiving messages, only for this purpose the function <i>uv_read_start () is used</i> , which also indicates the user function that will be called after receiving the next piece of data. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most important function is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv_run ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, which, in essence, is something like a message processing loop in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The library makes all calls to callback functions only inside </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv_run ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This means that even if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itself </font><font style="vertical-align: inherit;">received some message over the network, the user will never know about it until </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv_run () is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv_run () is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> declared as follows:</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uv_run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_loop_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* loop, uv_run_mode mode)</span></span></span></span>;</code> </pre> <br>  The first parameter, <i>uv_loop_t * loop,</i> is a pointer to a structure that <b>libuv</b> uses for some of its personal needs.  You need to create this variable once and never touch it again.  You can create it, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uv_loop_t</span></span> loop; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;loop, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(loop)); uv_loop_init(&amp;loop);</code> </pre> <br>  This is all that concerns the loop parameter and there is no special need to know how it is used inside <b>libuv</b> .  But ... there is one important nuance.  If you have a multi-threaded program, then for each thread you need to use its own <i>loop</i> .  In my case, I create one <i>loop</i> for the game itself and another for the local server, which runs on another thread.  And accordingly, I have my own <i>uv_run ()</i> on each thread. <br><br>  The second parameter, <i>uv_run_mode mode,</i> determines the mode in which the <i>uv_run ()</i> function will operate.  For the server, use the value <i>UV_RUN_DEFAULT</i> , and for the client, <i>use UV_RUN_NOWAIT</i> .  Let's try to figure out why. <br><br>  The <i>UV_RUN_DEFAULT</i> parameter causes the <i>uv_run ()</i> function to execute as long as there is at least some work for it.  And such work, for example, is the task of listening to the port.  Those.  if a socket is first created that listens to a port, then <i>uv_run ()</i> will never complete until that socket exists.  And this is the main task of the server - to wait for the connection from the client and install it.  Therefore, the option with <i>UV_RUN_DEFAULT</i> is very correct for the server, and the line: <br><br><pre> <code class="cpp hljs">uv_run(&amp;loop, UV_RUN_DEFAULT)</code> </pre> <br>  Often it is the last line in the program, because when you exit this cycle, the server simply quits. <br><br>  The exit from the <i>uv_run</i> function <i>(&amp; loop, UV_RUN_DEFAULT)</i> will occur independently when the user destroys the listening socket. <br><br>  To exit the <i>uv_run</i> function <i>(&amp; loop, UV_RUN_DEFAULT)</i> , the <i>uv_stop ()</i> function is <i>used</i> , which takes the same <i>loop</i> as a parameter.  After such a call, <i>uv_run ()</i> will exit, but return an error, which means that it was interrupted too soon and she still has something to do.  <i>By the</i> way, no one bothers to call <i>uv_run ()</i> in this case again. <br><br>  The <i>UV_RUN_NOWAIT</i> parameter causes the <i>uv_run ()</i> function to deal only with the events that have occurred so far.  That is, if any network messages were received, then callback functions will be called for them.  After that, the <i>uv_run ()</i> function will be completed.  This behavior is well suited for the client, since the client is also involved in the game itself, in addition to exchanging network messages.  In my case, I call <i>uv_run (&amp; loop, UV_RUN_NOWAIT)</i> once at the beginning of the game clock and once at the end (the clock frequency is about 60 Hz).  This is done so that it is possible to process the received messages before the start of the clock, and after the end of the clock, immediately send your own. <br><br>  As mentioned above, the <b>TCP</b> protocol requires a mandatory connection.  A connection request is always sent by the client to a specific IP address and port of the server.  To do this, <i>use the uv_tcp_connect ()</i> function. <br><br>  The function <i>uv_tcp_connect () is</i> declared as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uv_tcp_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_connect_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_tcp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* handle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sockaddr* addr, uv_connect_cb cb)</span></span></span></span>;</code> </pre> <br>  The first parameter <i>uv_connect_t * req</i> is a pointer to some kind of structure, which, apparently, <b>libuv is</b> very necessary for <b>something</b> .  The task of the user is simply to create this structure and pass it to the function.  Creating a structure is more than easy: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uv_connect_t</span></span> connect_data;</code> </pre> <br>  Just in case, I write zeros into it, but it seems that this is not necessary: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;connect_data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(connect_data));</code> </pre> <br>  Also note that this variable must continue to exist after calling <i>uv_tcp_connect ()</i> , since its address is used in the callback function, so it is easier to make it global. <br><br>  The second parameter, <i>uv_tcp_t * handle,</i> is a <b>TCP socket</b> that must be created in advance, but not bound to any port.  Creating a <b>TCP socket</b> is done with the <i>uv_tcp_init ()</i> function, which will be discussed a bit later. <br><br>  The third parameter <i>const sockaddr * addr</i> is the IP address and port of the server from which the connection is requested.  <b>Libuv</b> has a function <i>uv_ip4_addr ()</i> , which helps to fill this structure with data. <br><br><pre> <code class="cpp hljs">sockaddr_in dest; uv_ip4_addr(<span class="hljs-string"><span class="hljs-string">"234.123.34.18"</span></span>, <span class="hljs-number"><span class="hljs-number">57</span></span>, &amp;dest);</code> </pre> <br>  The fourth parameter, <i>uv_connect_cb cb</i> , is the custom callback function.  And it is in this function that the user can determine whether a connection has been established and somehow respond to this fact. <br><br>  In my case, the callback function looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_connect_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> status)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status==<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ... ... ... } else { //    ... ... ... } }</span></span></code> </pre> <br><h3>  Creating sockets. </h3><br>  <b>The TCP socket is</b> described by the <i>uv_tcp_t</i> structure.  First you need to allocate memory for this structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uv_tcp_t</span></span>* tcp_socket=<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uv_tcp_t</span></span>));</code> </pre> <br>  Those interested can clear the allocated memory with zeroes, although this is an optional operation: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tcp_socket, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uv_tcp_t</span></span>));</code> </pre> <br>  Then you can create the socket itself: <br><br><pre> <code class="cpp hljs">uv_tcp_init(&amp;loop, tcp_socket);</code> </pre> <br>  here the <i>loop</i> is the same long-suffering <i>loop</i> that is served in <i>uv_run ()</i> . <br><br>  And now a very important moment for game writers: <br><br><pre> <code class="cpp hljs">uv_tcp_nodelay(tcp_socket, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  I will try to explain what this setting.  The fact is that <b>TCP</b> considers itself to be a very smart protocol and it knows that sending data in small portions is unprofitable, since the minimum transmitted data size will in any case be equal to the size of the packet.  In other words, if you send 1 byte, the result will still be sent a whole packet, in which only 1 byte of the payload will be sent, and the rest will be garbage.  Therefore, by default, smart <b>TCP</b> will wait 200 milliseconds for the user to add more data to send, to send everything at once.  This mechanism with the expectation is called the " <i>Nagle</i> " <i>algorithm</i> and is not suitable for games at all.  Therefore, this setting seems to say the <b>TCP</b> protocol - ‚Äúlisten, dear, let's not get smart, but send the data immediately.‚Äù  In practice, this setting prohibits the <b>TCP</b> protocol from using the " <i>Nagle</i> " <i>algorithm</i> . <br><br>  Now, if this is a server, then the main socket must be immediately bound to the port: <br><br><pre> <code class="cpp hljs">sockaddr_in address; uv_ip4_addr(<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>,   , &amp;address); uv_tcp_bind(tcp_socket, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct sockaddr*)&amp;address, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  In this case, the address is ‚Äú0.0.0.0‚Äù, which means that the socket will be tied to all network adapters that are present on the computer, and not just to any one.  <i>PORT NUMBER SERVER</i> should be selected independently and the main <i>thing</i> here is its uniqueness so as not to create conflict with other programs. <br><br>  Next, the server should enable port listening for the socket: <br><br><pre> <code class="cpp hljs">uv_listen((<span class="hljs-keyword"><span class="hljs-keyword">uv_stream_t</span></span>*)tcp_socket, <span class="hljs-number"><span class="hljs-number">1024</span></span>, OnAccept);</code> </pre> <br>  The first parameter <i>tcp_socket</i> is, of course, the socket itself, but the second one is much more specific.  This is the maximum number of connection requests that can wait for their turn.  Imagine that you have a super-popular server and players are eager to play on it, i.e.  There are a lot of connection requests from clients.  If the server does not have time to answer them, then it puts them in a queue.  And this number 1024 in this case is the maximum size of this queue.  Those who do not fit in the queue, the server will respond with three words. <br><br>  The third <i>OnAccept</i> parameter is a callback function that will be called when a <b>CONNECT</b> connection request is <i>received</i> from any client, for which the client uses the <i>uv_tcp_connect ()</i> function. <br><br>  The <i>OnAccept ()</i> function might look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAccept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_stream_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *server, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> status)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    return; } //    ,        uv_tcp_t* tcp_socket=malloc(sizeof(uv_tcp_t)); memset(tcp_socket, 0, sizeof(uv_tcp_t)); uv_tcp_init(&amp;loop, tcp_socket); if (uv_accept(server, (uv_stream_t*)tcp_socket)==0) //     { //   uv_read_start((uv_stream_t*)tcp_socket, OnAllocBuffer, OnReadTCP); //      } else { //     uv_close((uv_handle_t*) tcp_socket, OnCloseSocket); //  ,      } }</span></span></code> </pre> <br>  Let's take a <i>closer look at the</i> interiors of the <i>OnAccept ()</i> function. <br><br><ol><li>  First, a new socket is created, which will be used to connect to the client from whom the request to establish a connection came.  To establish the connection, the client uses <i>uv_tcp_connect ()</i> . <br><br></li><li>  Called uv_accept (), which sets up the connection between the server and the client.  The <i>uv_accept ()</i> function calls on the client the triggering of the call-back function specified in <i>uv_tcp_connect ()</i> as the last parameter.  In the example above, this was the <i>OnConnect ()</i> function. <br><br></li><li>  If the connection is successfully established, the server should allow the created socket to read data from this connection.  The <i>uv_read_start ()</i> function <i>enables</i> data reading for the newly created <i>tcp_socket</i> socket.  Please note that ‚Äúreading data‚Äù and ‚Äúlistening to a socket‚Äù are different operations.  ‚ÄúReading data‚Äù is literally ‚Äúreading‚Äù by analogy with byte reading from a file, and ‚Äúlistening to a socket‚Äù is waiting for a <b>CONNECT</b> request to establish a connection. <br><br>  The <i>uv_read_start ()</i> function uses as many as two callback functions: <br><br>  - <i>OnAllocBuffer ()</i> is called before reading the data and asks the user to specify the memory for receiving data. <br><br>  The function itself is defined as: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAllocBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* handle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suggested_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf)</span></span></span></span></code> </pre> <br>  The first parameter <i>uv_handle_t * handle</i> is a pointer to a socket that requires memory. <br><br>  The second parameter <i>size_t suggested_size</i> is the required buffer size. <br><br>  The third parameter, <i>uv_buf_t * buf</i> , is the structure through which the user returns the <b>buffer</b> information (size and address) to the <b>libuv</b> library. <br><br><pre> <code class="cpp hljs">buf-&gt;len=; buf-&gt;base=;</code> </pre> <br>  In short, the buffer itself must be created by the user and deleted also by the user.  And <b>libuv</b> will only accept data into this buffer.  The same buffer can be used for multiple sockets. <br><br>  In my case, <b>for</b> some reason, <b>libuv</b> always requested a buffer of 65536 bytes in size.  As for me, it's a bit strange, but since I allocate this memory 1 time, it seems that there is nothing wrong with that. <br><br>  - <i>OnReadTCP ()</i> is called after <i>OnAllocBuffer ()</i> to transfer to the user the data that the socket has received into the buffer. <br><br>  The function itself is defined as: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnReadTCP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_stream_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ssize_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nread, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf)</span></span></span></span></code> </pre> <br>  The first parameter <i>uv_handle_t * handle</i> is a pointer to the socket that received the data. <br><br>  The second parameter <i>ssize_t nread</i> is the number of bytes received.  If <i>nread is</i> less than or equal to zero, then this is a sign that the connection has been broken.  Those.  this is not a data reading, but information about a communication breakdown, which may occur due to the fact that the other party has deleted a socket related to this connection or for hardware reasons such as cable breakage.  This situation must be monitored and responded to accordingly. <br><br>  The third parameter <i>const uv_buf_t * buf</i> - contains the address of the buffer with the read data.  This will be the same address that the user specified in the <i>OnAllocBuffer ()</i> function. <br><br>  The most important moment when reading data.  As I wrote earlier, <b>TCP</b> can deliver a sent message in parts, for example, if the sender sent the phrase ‚ÄúHello,‚Äù and then the phrase ‚ÄúServer‚Äù, it is not necessary that when receiving these two messages, the information will look exactly the same and as sent.  First, both messages can stick together in one and then the receiving party will receive one integral message ‚ÄúHello Server‚Äù, or maybe even this: first ‚ÄúAt‚Äù, then ‚Äúslow, Ser‚Äù, and then ‚Äúver‚Äù.  Those.  the message in theory can be fragmented into any number of parts.  Therefore, every message transmitted over the network should always have a header that will allow to separate one message from another in a stream of bytes arriving on a socket.  From all this follows a very unpleasant feature of reading data from a <b>TCP socket</b> .  Practically, each such socket should have its own buffer, where it will add incoming bytes of the next message, because if the message is received only partially, then you have to wait until it is received completely and then you can somehow react to it. <br><br></li><li>  If the connection could not be established, then the socket intended for it should be removed.  To do this, use the <i>uv_close ()</i> function.  But ... pay attention that this function also takes the <i>OnCloseSocket ()</i> call-back function as the last parameter.  And just at the moment of calling this function, libuv informs the user that the socket can now be physically removed from memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCloseSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* handle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(handle); <span class="hljs-comment"><span class="hljs-comment">//     malloc(),      free() }</span></span></code> </pre> </li></ol><br><h3>  Sending messages </h3><br>  To send a message through a socket, use the <i>uv_write ()</i> function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uv_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_write_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_stream_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* handle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bufs[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nbufs, uv_write_cb cb)</span></span></span></span>;</code> </pre><br>  The first parameter <i>uv_write_t * req</i> is some kind of variable that <b>libuv</b> needs to transfer data.  You shouldn‚Äôt understand the meaning of its presence in the function parameters, but you need to create it, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uv_write_t</span></span> write_data;</code> </pre> <br>  Now this variable can be used repeatedly to send messages sequentially, but you cannot use it at the same time to send multiple messages. <br><br>  The second parameter of <i>uv_stream_t * handle</i> is the sending socket. <br><br>  The third parameter <i>const uv_buf_t bufs []</i> is an array of messages to send.  It consists of <i>uv_buf_t</i> elements that have <i>len</i> and <i>base</i> fields, which, respectively, must contain <i>SIZE</i> and <i>ADDRESS</i> . <br><br>  The fourth parameter <i>unsigned int nbufs</i> is the number of elements in the message array.  In my case, I always used only one message to send. <br><br>  The fifth parameter, <i>uv_write_cb cb</i> , is a callback function that is called when a message is sent.  Why is it even needed?  The fact is that the messages that the user sends should be kept in memory until they were sent.  Those.  when this callback function is triggered, it means that the data buffer that contained the message being sent is now no longer needed by <b>libuv</b> .  And now this buffer again goes under the control of the user and it can be filled with new data and send a new message. <br><br>  In my case, I put both the data buffer and the incomprehensible, but <i>uv_write_t write_data,</i> in one structure.  Therefore, they work in pairs as part of the same structure. <br><br><h2>  Moving from libuv structures to more convenient data types </h2><br>  Imagine that you have a set of <i>uv_tcp_t</i> sockets that accept messages.  As I said a little higher, due to the fact that data is read according to the flow principle and messages can be arbitrarily divided into parts, we will additionally need a buffer for each socket to store and analyze incoming data.  And now let's take another look at the <i>OnReadTCP ()</i> callback function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnReadTCP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_stream_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ssize_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nread, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf)</span></span></span></span></code> </pre> <br>  and note that it shows the socket that received the data through the parameter <i>uv_stream_t * stream</i> .  But ... how do you bind the socket to the desired data buffer?  Suppose you have 1000 sockets and everyone accepts something there.  You need to put received data for each socket in its own buffer.  But after all, its buffer is not determined by the socket in any way - inside the structure of the socket there will be a set of some nonsense without any indication of which one of the thousands of available buffers it corresponds to. <br><br>  So the principle of networking should be completely different, and now I will try to describe how to solve this issue. <br><br>  For <b>now</b> , let's temporarily forget about the existence of <b>libuv</b> and try to create a common server structure. <br><br>  Suppose we have a server class called <b>GNetServer</b> .  An object of this class always exists in a single instance and completely assumes the functions of a server.  In my particular case, the server should have two main arrays: <br><br><ul><li>  Array of players </li><li>  Array of existing sessions (or an array of games created) </li></ul><br>  Close connections should be established between these two arrays, i.e.  any player must know which session he belongs to (if he has already joined the session), and also any session must know which players belong to it. <br><br>  What are the requirements for players and sessions?  The main requirement is quick access to the desired player or session by his personal unique identifier.  And nothing is faster to search than simply making this identifier a player index or a session in an array, it‚Äôs probably impossible to come up with.  So, every player in our country has an ID that is simply equal to its number in the general array of players.  And now if another player sends data to players with identifiers 5, 10, 21 and 115, then the server can immediately identify these recipients simply by using their identifiers as indices. <br><br>  Now let's define what the ‚Äúplayer‚Äù is from the point of view of the server.  In fact, the ‚Äúplayer‚Äù is the ‚Äúsocket‚Äù, with only some additional information.  Additional information includes the following data: <br><br><ul><li>  Player ID (also known as the index in the player array) </li><li>  Buffer for received data </li><li>  Socket creation time </li><li>  The last time the data was received on the socket. </li><li>  Sign <b>UDP</b> / <b>TCP</b> </li><li>  Player's name (except perhaps for debugging and general information) </li><li>  Something else that is not very important. </li></ul><br>  All this information is stored in the <b>GNetSocket</b> class.  But note that there is no libuv nicknames in it.  This was done so that with some desire you could replace <b>libuv</b> with something else. <br><br>  In my case, there is a class <b>GNetSocketLibUV</b> , which is inherited from <b>GNetSocket</b> .  Why <b>did</b> I need an intermediate class <b>GNetSocket</b> , if in reality only objects of class <b>GNetSocketLibUV are created</b> ?  The fact is that my task was to separate the <b>libuv</b> library from the overall network structure as much as possible.  As a result, the main server / client file takes up more than 7 thousand lines, and the file specific to <b>libuv</b> - 600 lines.  And if you need to replace <b>libuv</b> , then I can do it relatively easily.  I also use the principle when objects of key classes are not created directly through <i>new</i> , but through virtual functions, for example, this is how a socket object is created for the server: <br><br><pre> <code class="cpp hljs">GNetSocket* GNetServerLibUV::NewSocket(GNet* net) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GNetSocketLibUV(net); }</code> </pre> <br>  Those.  It costs me to replace in one place <i>return new GNetSocketLibUV (net);</i>  on some other type of object, how only this type will be created in the program. <br><br>  The <b>GNetSocketLibUV</b> class overrides all abstract functions of the base class.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GNetSocketLibUV</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GNetSocket { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* sock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GNetSocketLibUV(GNet* net); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~GNetSocketLibUV(); <span class="hljs-comment"><span class="hljs-comment">//  UDP  TCP- ,   listaen=true,     virtual bool Create(bool udp_tcp, int port, bool listen); //     TCP-    virtual bool SetConnectedSocketToReadMode(); //   virtual void Destroy(); //  IP-   TCP- // own_or_peer           virtual bool GetIP(CMagicString&amp; addr, bool own_or_peer); //      (  TCP-) virtual bool Connect(NET_ADDRESS* addr); //     (  TCP-) virtual bool Accept(); virtual void SendTCP(NET_BUFFER_INDEX* buf); virtual void SendUDP(NET_BUFFER_INDEX* buf); virtual void ReceiveTCP(); virtual void ReceiveUPD(); };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocketLibUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">, only one </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable has </font><b><font style="vertical-align: inherit;">been</font></b><font style="vertical-align: inherit;"> added </font><font style="vertical-align: inherit;">, which will almost be a pointer to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> socket </font><font style="vertical-align: inherit;">, but with some qualification. </font><font style="vertical-align: inherit;">We need the ability to quickly </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use the libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> socket </font><b><font style="vertical-align: inherit;">to</font></b><font style="vertical-align: inherit;"> determine the corresponding socket of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font><font style="vertical-align: inherit;">, in which both the read buffer and the player identifier lie.</font></font><br><br>  How to do it?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I added intermediate structures: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NET_SOCKET_PTR</span></span></span><span class="hljs-class"> {</span></span> GNetSocket* net_socket; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCP_SOCKET</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NET_SOCKET_PTR, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uv_tcp_t</span></span> { }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UDP_SOCKET</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NET_SOCKET_PTR, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uv_udp_t</span></span> { };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So ... now we have a new structure for a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP socket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and a new structure for a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP socket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But ... both of these structures have a new field in front of the socket structure, which is a pointer to the parent object of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now one more important note. The program should not create ‚Äúnative‚Äù sockets </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libuv anywhere</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but only sockets like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Immediately after creating a field </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">net_socket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be recorded address of the object </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which structure was created</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practically, creating a socket looks like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  UDP  TCP- ,   listen=true,     bool GNetSocketLibUV::Create(bool udp_tcp, int port, bool listen) { GNetSocket::Create(udp_tcp, port, listen); uv_loop_t* loop=GetLoop(net); if (udp_tcp) { sock=malloc(sizeof(TCP_SOCKET)); memset(sock, 0, sizeof(TCP_SOCKET)); ((TCP_SOCKET*)sock)-&gt;net_socket=this; ... ... ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when we have </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the address of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP_SOCKET,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and we always know that the first in the structure will always be a pointer to the main socket </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket * net_socket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the task of ‚Äúquick match‚Äù is almost solved. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a couple of functions that will help you easily get the right data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then passing the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> address </font><font style="vertical-align: inherit;">to the following function easily retrieves the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP socket of libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uv_tcp_t</span></span>* GetPtrTCP(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uv_tcp_t</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptr)+<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP_SOCKET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then passing the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> address </font><font style="vertical-align: inherit;">to the following function easily retrieves the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP socket libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uv_udp_t</span></span>* GetPtrUDP(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uv_udp_t</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptr)+<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNetSocketPtr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">(uv_tcp_t address or uv_udp_t socket address)</font></i><font style="vertical-align: inherit;"> allows you to get the corresponding socket address of our main socket of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GNetSocket* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPtrSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *((GNetSocket**)ptr); } <span class="hljs-function"><span class="hljs-function">GNetSocket* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNetSocketPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* uv_socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetPtrSocket(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)uv_socket)-<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to use it in practice? </font><font style="vertical-align: inherit;">For example, you need to put a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP socket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in read mode:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     TCP-    bool GNetSocketLibUV::SetConnectedSocketToReadMode() { if (udp_tcp) { uv_tcp_t* tcp=GetPtrTCP(sock); int r=uv_read_start((uv_stream_t*)tcp, OnAllocBuffer, OnReadTCP); return (r==0); } return false; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that our </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> turns into </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv_tcp_t * tcp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetPtrTCP (sock)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and you can already pass it to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv_read_start ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, in my case, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnReadTCP ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> callback function looks like </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnReadTCP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_stream_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ssize_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nread, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uv_buf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf)</span></span></span><span class="hljs-function"> </span></span>{ GNetSocket* socket=GetNetSocketPtr(stream); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nread&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { NET_BUFFER* recv_buffer=socket-&gt;net-&gt;GetRecvBuffer(); assert(buf-&gt;base==(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)recv_buffer-&gt;GetData()); recv_buffer-&gt;SetLength(nread); socket-&gt;ReceiveTCP(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,    socket-&gt;net-&gt;OnLostConnection(socket); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first line: </font></font><br><br><pre> <code class="cpp hljs">GNetSocketLibUV* socket=(GNetSocketLibUV*)GetNetSocketPtr(stream);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets the address of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">for which the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket-&gt; ReceiveTCP ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function will be executed </font><font style="vertical-align: inherit;">, which </font><i><font style="vertical-align: inherit;">actually</font></i><font style="vertical-align: inherit;"> receives the messages received by the socket. </font><font style="vertical-align: inherit;">She will already put this data into the socket's own buffer, check for the fact that the message has been received completely, and then pass it on to the server or client for processing (I have most of the server and client code). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Still, perhaps, I will give an example of removing a socket:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void GNetSocketLibUV::Destroy() { if (sock) { if (udp_tcp) { uv_tcp_t* tcp=GetPtrTCP(sock); uv_close((uv_handle_t*)tcp, OnCloseSocket); ((TCP_SOCKET*)sock)-&gt;net_socket=NULL; } else { uv_udp_t* udp=GetPtrUDP(sock); int r=uv_read_stop((uv_stream_t*)udp); assert(r==0); uv_close((uv_handle_t*)udp, OnCloseSocket); ((UDP_SOCKET*)sock)-&gt;net_socket=NULL; } sock=NULL; } GNetSocket::Destroy(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notice here the line </font></font><br><br><pre> <code class="cpp hljs">((TCP_SOCKET*)sock)-&gt;net_socket=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  i.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> socket </font><font style="vertical-align: inherit;">is not deleted here, it becomes generally on its own, since the main </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetSocket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><b><font style="vertical-align: inherit;">will</font></b><font style="vertical-align: inherit;"> no longer have a connection with this socket. But when </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finishes all its affairs with a socket, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnCloseSocket ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> callback function will inevitably work </font><font style="vertical-align: inherit;">, in which </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">free ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be executed </font><font style="vertical-align: inherit;">. Therefore, memory leaks will not occur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this, I think that the conversation about the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libuv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">can be ended. I tried to clarify the essence of the principles that underlie her work and, I think that these principles are practically the same for most of these decisions, including </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinSock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Perhaps in my interpretation there are not enough code examples, but they are not very difficult to find on the Internet by function names. </font><font style="vertical-align: inherit;">I tried to explain what to do with these functions and how they interact with each other. </font><font style="vertical-align: inherit;">It is quite possible that in my understanding there are some inaccuracies, since my goal was to finish the game, and not to become an expert in network programming, so I figured out this matter on the principle of "necessary and sufficient".</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GNetClient Network Client Structure </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client at different points in time should behave in absolutely different ways, for example, at the very beginning he should connect to the server and create or join the session, and when the game has already begun, he should exchange data from the mouse and keyboard with other players. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can break the logic of the work of the client at the stage and describe the work of each stage separately. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my case, there are the following stages: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyEnumSession</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_ENUM_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the stage of getting a list of existing gaming sessions. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyJoinSession</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_JOIN_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the stage of connecting to the game session and setting up your own player. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyCreateSession</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_CREATE_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- A stage that allows you to create a session, customize it and your own player. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyStartGame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_START_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the stage of launching a network game. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyGame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the stage of the game. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyMigrationHost</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_MIGRATION_HOST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the stage of the migration of the host. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage indices are declared as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NET_STADY {NET_STADY_ENUM_SESSION, NET_STADY_JOIN_SESSION, NET_STADY_CREATE_SESSION, NET_STADY_START_GAME, NET_STADY_GAME, NET_STADY_MIGRATION_HOST, NET_STADY_NO=<span class="hljs-number"><span class="hljs-number">-1</span></span>};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The object of each stage is created in advance and stored in an array of stages inside </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetClient</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     class GNetClient : public GNet { protected: NET_STADY net_stady; //   int k_net_stady; //   GNetStady** m_net_stady; //    ... ... ... } GNetClient::GNetClient() : GNet() { net_stady=NET_STADY_NO; k_net_stady=6; m_net_stady=new GNetStady*[k_net_stady]; m_net_stady[NET_STADY_ENUM_SESSION]=new GNetStadyEnumSession(this); m_net_stady[NET_STADY_JOIN_SESSION]=new GNetStadyJoinSession(this); m_net_stady[NET_STADY_CREATE_SESSION]=new GNetStadyCreateSession(this); m_net_stady[NET_STADY_START_GAME]=new GNetStadyStartGame(this); m_net_stady[NET_STADY_GAME]=new GNetStadyGame(this); m_net_stady[NET_STADY_MIGRATION_HOST]=new GNetStadyMigrationHost(this); ... ... ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The base for all stages is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStady</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">, from which all other stages are inherited:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      class GNetStady { protected: GNetClient* owner; //    - GNetClient unsigned int stady_period; unsigned int stady_tick; public: GNetStady(GNetClient* owner); virtual ~GNetStady(){} virtual bool OnStart(NET_STADY previous, void* init); virtual void OnFinish(NET_STADY next){} virtual void OnUpdate(); //     ,    stady_period (    0) virtual void OnPeriod(){} //      virtual bool IsMessageCorrected(int message_type){return false;} };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Walk briefly on the functions of the stage. </font></font><br><br><ul><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NET_STADY previous, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* init)</span></span></span></span></code> </pre> <br>      . ,   ,      .     <i>false</i> ,   ,      .          <i>NET_STADY previous</i>      <i>void* init</i> ,     . <br><br>       <i>bool GNetClient::SetStady(NET_STADY stady, void* init)</i> . <br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NET_STADY next)</span></span></span></span></code> </pre> <br>  ,     , ..     ,   -    .      . <br><br>        <i>SetStady()</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   bool GNetClient::SetStady(NET_STADY stady, void* init) { if (stady!=net_stady) { if (net_stady!=NET_STADY_NO) { //     m_net_stady[net_stady]-&gt;OnFinish(stady); } if (stady!=NET_STADY_NO) { //     if (!m_net_stady[stady]-&gt;OnStart(net_stady, init)) return false; } net_stady=stady; } return true; }</span></span></code> </pre> <br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br> ,    .    ,     . <br><br>  GNetStady::OnUpdate()   GNetClient::OnUpdate(): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GNetClient::OnUpdate() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (net_stady!=NET_STADY_NO) m_net_stady[net_stady]-&gt;OnUpdate(); }</code> </pre> <br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br> ,     ,     -  .     <i>GNetStady::stady_period</i> ,      <i>OnPeriod()</i> . ,  <i>stady_period=500</i> ,   ,    OnPeriod()    1   . <br><br>     <i>OnPeriod()</i>   <i>OnUpdate()</i> ,      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GNetStady::OnUpdate() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stady_period) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tick=owner-&gt;game-&gt;platform-&gt;GetTick(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tick&gt;=stady_tick+stady_period) { stady_tick=tick; OnPeriod(); } } }</code> </pre> <br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMessageCorrected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message_type)</span></span></span></span></code> </pre> <br> ,         . ,       ,   .               .    ,      ,     . <br><br>  Why do you need it? , -,       . , -,       , ..   ,         N-  . <br> ,       ,          .   ,  -    ( <i>Cancel</i> )     <b>NET_STADY_ENUM_SESSION</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to choose another session. </font><font style="vertical-align: inherit;">Then at the time of leaving the session, he also notifies other players about his retirement, but the problem is that until they receive his message and react to it, time passes. </font><font style="vertical-align: inherit;">During this period, the other players can easily continue to send messages about the session settings to the player who has already left the session. </font><font style="vertical-align: inherit;">And it is these already unnecessary messages that the gone player must mercilessly cut off.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Network Client Stage Management </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some stage is always current, except for the situation when the client has not yet connected to the server. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To start working with the network, use the function:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    virtual bool GGame::StartNet(const char* ip);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip = NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then start your own local server, otherwise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> must be the IP address of the Internet server, for example, 234.123.34.18:57. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To complete the work with the network there is a function:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    virtual void StopNet();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function is guaranteed to remove all signs of the network, i.e. stops the local network server, if there is one, and destroys the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetClient</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> client </font><b><font style="vertical-align: inherit;">object</font></b><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To start working with the network, you need to call the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GGame :: StartNet function (const char * ip)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the ip-address is specified, the function initializes the network and tries to establish a connection with the server located at the specified address. If the server responded and allowed the connection, the function returns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , otherwise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All further calls to the server will be made through the established </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP connection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip = NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the function does not perform any connection to the server. Instead, it creates a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP socket.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to use it to search for servers on the local network via a broadcast request. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If </font><font style="vertical-align: inherit;">there are no problems </font><font style="vertical-align: inherit;">with the execution of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StartNet ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, the network starts to execute the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_ENUM_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">, i.e. search created game sessions. This happens as follows ... in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyEnumSession :: OnPeriod ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, which is automatically called once every half second, a message of the </font><b><font style="vertical-align: inherit;">MESSAGE_TYPE_ENUM_SESSION</font></b><font style="vertical-align: inherit;"> type is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The message is sent either only to the Internet server via a pre-established connection, or by broadcasting a request to the local network. In any case, if the Internet server or some server on the local network receives this message, then they react the same way, namely: they send the questioning answer as a message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_ENUM_SESSION_REPLY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which lists all the sessions available on the server. Each session has a brief description in the form </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of session creation time</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">host ID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">card name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">number of players and their characteristics</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">password sign in the session</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the server IP address</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, through which the client can connect - it is very important for the local network, as the client in this case sends a request to the broadcast and he must know the address of the server that sent him the answer to make the connection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After receiving information about the sessions found, the client calls the virtual function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnEnumSession (GSessionList * sessions, int count_general_session)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This function is </font><font style="vertical-align: inherit;">not defined </font><font style="vertical-align: inherit;">in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GGame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">, since its task, in practice, is to display a list of sessions to the user. Since </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GGame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a universal base class, it does not undertake such tasks, since it knows nothing about a particular game where it can be used. Therefore, this function in my case is redefined in the class</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GGameOnimodLand</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and it is she who sorts the resulting sessions according to the time of creation and shows them to the user by adding lines to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GListBox</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> component </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the user chooses a session and clicks " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Join</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", the following happens. The client simply starts the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_JOIN_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">, which, in its function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyJoinSession :: OnStart ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , attempts to connect to the session. This attempt may be unsuccessful for various reasons, for example, the game was started or another player connected, and there is no more room in the session. In any case, the connection permission is issued by the host (in no case is the server). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does this happen in practice?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of a local network, you must first connect to the server. For this, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GNetClient :: ConnectToServer (const char * ip)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is used </font><font style="vertical-align: inherit;">, which returns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if successful </font><font style="vertical-align: inherit;">. The IP address of the server is taken from the session information. Before establishing a connection, a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP socket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is first killed </font><font style="vertical-align: inherit;">, since it is no longer needed, and a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP socket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is created instead </font><font style="vertical-align: inherit;">, through which the connection will be established. The client accesses the server using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONNECT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the server must accept the request and respond via </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACCEPT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the connection is established, then you need to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shake hands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  What is it for?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that anyone from another program can connect to the server. The ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handshake</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù identifies the client in the eyes of the server and it is after the successful ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handshake</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù that the server allows the client to begin exchanging messages. The ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handshake</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù itself is performed via the message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_HELLO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is additionally supplied with any service information such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client version</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">license key</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc. The server verifies this information and returns a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_HELLO_REPLY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> message to the </font><b><font style="vertical-align: inherit;">client</font></b><font style="vertical-align: inherit;"> , which contains a unique </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All further communication with the server and other players, the client performs through this</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the server returned </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID = 0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then this means that the client is not accepted by the server. In this case, the server additionally sends the text, which explains to the client the reason for the refusal. This text can be displayed on the client in the form of, for example, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GMessageBox</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Please note that the connection to the Internet server is similar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the client is connected to the server, then it should immediately send a request for connection to the session to the host. However, the host can protect the session with a password so that only " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">your</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " are </font><font style="vertical-align: inherit;">connected </font><font style="vertical-align: inherit;">. From the session information, the fact of having such a password is determined. In this case, the user must first be prompted to enter a password. Next, the function is executed</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GNetClient :: ConnectSession (NET_JOIN_DATA * join)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which in turn sends a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_CONNECTING</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> message to the host </font><font style="vertical-align: inherit;">. The message is sent to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">host ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is again taken from the session information. First, the message is received by the server, which analyzes the list of recipients and sends the message to the host. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upon receiving the message, the host looks to see if it is possible to accept the player in the session, checks the password (if any) and makes a decision. If the answer is positive, the host first selects a slot for the new player using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virtual function </font><i><font style="vertical-align: inherit;">GGame :: GetIndexOfConnectedPlayer ()</font></i><font style="vertical-align: inherit;"> , and includes the player in the session. Additionally, the host function is triggered.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnNewPlayer (int index)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows you to perform some actions due to the appearance of a new member. Next, the host sends the client a response in the form of a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_CONNECT_REPLY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> message </font><font style="vertical-align: inherit;">, where, in the event of a positive response, it sends the slot index in the session to the client, all information about the status of other players in the session, as well as some additional information. Upon receiving the message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_CONNECT_REPLY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the client remembers its slot and initializes its session variables with the data received from the server. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now a new player can customize their characteristics in the session and exchange chat messages. In order for the host to start the game, each participant in the session must click the " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am ready</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", without this, the host button" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "will be in an inactive state.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game session information </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Session information should be organized so that it does not depend on the particular game. For example, I have no desire to change the structure of my shell, if I suddenly want to say so, ‚Äúremember the golden childhood‚Äù and start playing games again. So you need to make sure that the fields in the session description are arbitrary and only a specific game, but never a server or a client, deals with their analysis. However, some fields still need to be clearly defined, since something the server still needs to know about the session, for example, its name. You also need to uniquely interpret some information about the players entering the session, for example, the number and status of " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">who is it</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">person</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open slot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closed slot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I put all this information in a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct NET_SESSION_INFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As part of this structure there is an array with players </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_PLAYER ** m_player; </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and their number is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int k_player; </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the most important thing is that there are fields that can store arbitrary information:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length_info; <span class="hljs-comment"><span class="hljs-comment">//  .  char* info; //  . </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same fields are available in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_PLAYER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">and they also allow you to store arbitrary information for any player. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, </font><font style="vertical-align: inherit;">add the following functions and operators </font><font style="vertical-align: inherit;">to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_SESSION_INFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CMagicStream&amp; stream)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// /    NET_SESSION_INFO&amp; operator=(const NET_SESSION_INFO&amp; si); //   bool operator==(const NET_SESSION_INFO&amp; si); //     bool operator!=(const NET_SESSION_INFO&amp; si) //    </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is all this necessary? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will try to clarify one important thing, which, I think, is far from being understood by everyone. The use of operators, in my opinion, is a rather dangerous matter. The problem is that very often new variables are added to the structure in the course of development. And often you can even forget to initialize them in the constructor. And forgetting that these variables should also be added to the comparison and equality operators ‚Äî this happened to me more than once, after which I was sometimes very angry with my ‚Äút </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">head.‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For forgetfulness. So ... as a result, I came to the following decision. Usually important structures have serialization in their structure, or, more simply, they can read their data from a stream and write them to a stream. Most often, a stream is a regular file where bytes are written, but it will be much better if the stream can also be a memory area. In my case, I wrote the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicStream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">and spawned the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicStreamFile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicStreamMemory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classes from it </font><font style="vertical-align: inherit;">. Therefore, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void Serialize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">(CMagicStream &amp; stream);</font></i><font style="vertical-align: inherit;"> able to work with files and with RAM, depending on which class object is in reality </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, I have one more class type</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicStreamVirtualFile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is included in my "shell" and is designed to work with a virtual disk. A virtual disk is a couple of files that contain their own file system. I used my virtual disk to place game resources inside it. A virtual disk can be opened via </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicString GPlatform :: OpenVirtualDrive (const char * path),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specifying a virtual disk file as the path. As a result, a path of the following type will be returned: 0 \ which can then be used in the shell to work with files inside a virtual disk. It is important here that the functions of the "shell" working with the file system will understand this way and redirect requests to the files where necessary, for example, the function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicStream * GPlatform :: OpenStream (const char * file, int mode)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works according to this universal principle and correctly access the virtual disk if </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a corresponding path pointing to it. The same applies to the situation with the " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current folder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " - no one bothers to make the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folder on the virtual disk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So ... back to the point. I talked about the fact that for me, operators can be dangerous because of my forgetfulness. To minimize the risk, I do this: I make the serialization function for the structure in binary form, then I pass all operators through this function.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if I need to write an assignment statement, then instead of copying the structure fields one by one, I create a stream of type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMagicStreamMemory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in RAM </font><font style="vertical-align: inherit;">for writing and execute </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialize () for the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copied structure object </font><font style="vertical-align: inherit;">for it </font><font style="vertical-align: inherit;">, then I create the same stream for reading and of the resulting structure object, I also perform </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialize ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the same memory location. It turns out this </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save + Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">through ram. Similarly, you can do with the comparison operator - write the data of the compared objects in two different streams, and then begin to compare them byte-by-bye. This method is, of course, slower than if the operator compared each field with each one. But for bottlenecks you can always use the traditional version. The advantage of serialization is that it is also used for regular </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data. And here the forgetfulness emerges quickly enough, at least in my case, since the corrupted data or unsaved fields are much more active.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, serialization is great for copying your data through the clipboard. And in the case of the network ... note that the network interaction is reduced to the transmission of messages, which are the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arbitrary data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fields </font><font style="vertical-align: inherit;">. And using binary serialization just allows you to turn any type of data into a stream of bytes that can be transmitted over the network, and then turned back into original data on the receiving side. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I finally got to the point of configuring a network session. The network client should not know anything about the game and should not know about the majority of the players' settings. For example, the flag " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am ready</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"he certainly doesn‚Äôt need it - the game needs it, and the network client serves only to send messages over the network. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did this. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GGame, I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> announced 4 empty virtual functions that should be defined already in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GGameOnimodLand</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> GGame::GetSessionInfoStruct(NET_SESSION_INFO* si); <span class="hljs-comment"><span class="hljs-comment">//    NET_SESSION_INFO* si   . virtual void GGame::SetSessionInfoStruct(NET_SESSION_INFO* si); //      NET_SESSION_INFO* si  . virtual bool GGame::GetSessionPlayerStruct(int index, NET_PLAYER* np); //     NET_PLAYER* np      .  index   . virtual void GGame::SetSessionPlayerStruct(int index, NET_PLAYER* np); //       NET_PLAYER* np    .</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In practice, these functions universally transfer data from the network client to the game and back. In this </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case, the GetSessionInfoStruct</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetSessionInfoStruct</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functions work with the data of the entire session, including the data about the players. And the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSessionPlayerStruct</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetSessionPlayerStruct</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functions work with data for a specific player. Naturally, the functions for players are used by the session functions, since </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_SESSION_INFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contains an array of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_PLAYER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objects </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After this approach, the game itself for the network client turns into a ‚Äúblack box‚Äù, from which ‚Äúsomething‚Äù comes and which ‚Äúsomething‚Äù accepts. And now the important point that is needed in order to simplify the process of configuring the player. Just imagine that a player has many settings and that they can change, for example, you can change the color of your team or choose a race. But you never know what you can think of in the future and it is desirable that then the structure of the program should not be corrected. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did this: on the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_JOIN_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void GNetStadyJoinSession :: OnUpdate ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is called by the timer </font><font style="vertical-align: inherit;">and it executes a couple of lines that solves the problem of universality. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyJoinSession</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">has a variable</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_SESSION_INFO * copy_session;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which contains a copy of the session state for the last clock. I still give the significant part of the code in its entirety.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GNetStadyJoinSession::OnUpdate() { GNetStady::OnUpdate(); <span class="hljs-comment"><span class="hljs-comment">//       NET_PLAYER* current_player=current_session-&gt;m_player[index_player]; NET_PLAYER* copy_player=copy_session-&gt;m_player[index_player]; owner-&gt;game-&gt;GetSessionPlayerStruct(index_player, current_player); if (*copy_player!=*current_player) { //        *copy_player=*current_player; if (current_player-&gt;type==PLAYER_MAN) { GMemWriter* wr1=owner-&gt;wr1; wr1-&gt;Start(); (*wr1)&lt;&lt;index_player; current_player-&gt;Serialize(*wr1); MEM_DATA buf; wr1-&gt;Finish(buf); //    ,    int k_receiver=owner-&gt;RefreshReceiverList(); NET_BUFFER_INDEX* result=owner-&gt;PrepareMessageForPlayers(MESSAGE_TYPE_PLAYER_INFO, buf.length, buf.data, k_receiver, owner-&gt;m_receiver); owner-&gt;GetMainSocket()-&gt;SendMessage(result); } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practically, the following happens here. The variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index_player</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the slot number that belongs to the player in the session. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">owner-&gt; game-&gt; GetSessionPlayerStruct (index_player, current_player);</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> takes the current settings of the same player from the game and then simply compares them with those remembered by the client: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (* copy_player! = * current_player)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and if there is a discrepancy, then the copy is first matched </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* copy_player = * current_player;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and then all participants in the session sends a message of type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_PLAYER_INFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which the new player settings are transmitted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the great advantage of this approach? </font><font style="vertical-align: inherit;">The fact is that the game itself should not follow the sending of the configuration to other players at all. </font><font style="vertical-align: inherit;">It is worth changing in the configuration at least 1 byte, as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyJoinSession :: OnUpdate ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will immediately notice this change and automatically send out new data to all participants in the session. </font><font style="vertical-align: inherit;">At the same time, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyJoinSession :: OnUpdate ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not know anything about real data that can be configured, because the comparison operator works through the serializer, and the length of the byte stream and the stream itself is compared with the case of equal length. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example of the article, the structure with the player's configuration looks like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerCfg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type; CMagicString name; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> player_id; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ready; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CMagicStream&amp; stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream.IsStoring()) { stream&lt;&lt;type; stream&lt;&lt;name; stream&lt;&lt;player_id; stream&lt;&lt;color; stream&lt;&lt;ready; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { stream&gt;&gt;type; stream&gt;&gt;name; stream&gt;&gt;player_id; stream&gt;&gt;color; stream&gt;&gt;ready; } } };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the game the fields are completely different and much more. </font><font style="vertical-align: inherit;">However, this approach works great in terms of versatility.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating a session </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, before joining a session, it is necessary that someone create this session. To do this, there is a stage </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_CREATE_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The class of this stage is inherited from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_JOIN_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GNetStadyCreateSession</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GNetStadyJoinSession</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is due to the fact that these stages are in many ways similar and seriously different except by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnStart ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, which performs either the creation of a session or joining a session. In the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_CREATE_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">, the configuration change check also works in the same way, but there is an additional check and on changing each player in the session, because the host controls the entire session and can, for example, delete other players. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, the network client is still a little involved in the analysis of the player configuration data. The configuration is answered by the message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_PLAYER_INFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which the client analyzes as follows. At the time of receiving the message, he remembers whether the player for whom the new configuration came was a living person (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type = PLAYER_MAN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). After receiving the message, the current configuration is replaced with a new one. But the client only checks the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> field </font><font style="vertical-align: inherit;">to see if it is still </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLAYER_MAN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And if the field suddenly changed to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLAYER_OPENED</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this could mean, for example, that the host removed the player from the session and the slot is now open. The client is involved in handling this situation and as a result, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GNetClient :: LostPlayer (unsigned int player_id) is called</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which means that it is lost to the player. Then it all comes to the game in the form of one of the options:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    (    ) virtual void GGame::OnCancelSession(); //        virtual void GGame::OnDeletingFromSession();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GNetStadyCreateSession :: OnStart (NET_STADY previous, void * init)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">is called when the player presses the "Create Game" button. If this is a game over a local network, you must first start your own server and join it:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    bool GNetClient::CreateSession() { bool is=false; if (!internet) { //    if (StartLocalServer()) { is=ConnectToServer("127.0.0.1"); } else is=false; } else { is=true; } return is; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConnectToServer</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">(‚Äú127.0.0.1‚Äù), the </font></i></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP socket is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destroyed and a T </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CP socket is created</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Next, a connection is established with the server, which is launched on the same computer by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StartLocalServer ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. The server‚Äôs IP address is ‚Äú127.0.0.1‚Äù, which means ‚Äúthe same computer‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the host calls the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnCreateSession function (int index_player)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which in my case only sets its slot for the host, which is always 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, the host uses the void </font><i><font style="vertical-align: inherit;">GNetStadyCreateSession :: OnPeriod ()</font></i><font style="vertical-align: inherit;"> function</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starts to periodically inform the server about the session state. This function is automatically called once every half second. It sends to the server a message of type </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_SESSION_INFO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This message is not always sent, but only when the session settings have been changed. Here, the same principle is used as with changing the player‚Äôs configuration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The server, having received the message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_SESSION_INFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , first checks whether there is already such a session in the list of its sessions and, if it does not, then adds a new session. The sender of the message is added to the new session as the first participant and host. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, the server will send information about available sessions in response to a request from the client </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_ENUM_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_CREATE_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">lasts until the player presses the " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">button </font><font style="vertical-align: inherit;">to initiate the start of the game. Practically, at this moment the stage </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_START_GAME is established</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> through a call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">net-&gt; SetStady (NET_STADY_START_GAME, NULL);</font></font></i>  . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_START_GAME is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sent automatically from the </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">GNetStadyCreateSession :: OnFinish (NET_STADY next)</font></i><font style="vertical-align: inherit;"> , which is called when the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_CREATE_SESSION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage is </font><b><font style="vertical-align: inherit;">completed</font></b><font style="vertical-align: inherit;"> . Here the host informs the server that the session is now closed for connection and there is no need to inform other players about it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_START_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is sent by the server to all participants in the session. After receiving it, they all also switch to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_START_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, the main work of the game launch stage is performed in the function: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void GNetStadyStartGame :: OnPeriod (), which performs a countdown from 5 to 1 through the function</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnStartNetCounter (int counter);</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Practically, the numbers 5,4,3,2,1 are output to the chat area. Next, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnStartNetGame () is called</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which starts the process of preparing the game session for launch. At this point, the game card should load and players should be placed on it. Note that this whole process is performed on each computer independently. When all data is initialized, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual bool GGame :: IsNetGameLoaded ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">should return </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This function is called continuously from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNetStadyStartGame :: OnPeriod ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and while it returns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the network client assumes that the game is being initialized. As soon as it returns</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the message </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_PLAYER_STARTED is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sent to all other players </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">At that moment, when the network client detects that it received the message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_PLAYER_STARTED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from all participants in the session, it goes to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">and this means the start of the game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GNetStadyGame :: OnStart (NET_STADY previous, void * init)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">immediately calls </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnLaunchNetGame ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and this is the launch.</font></font> Everything.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then the game begins. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Online game </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_STADY_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage </font><font style="vertical-align: inherit;">controls the entire gameplay through the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void GNetStadyGame :: OnUpdate ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. In practice, this stage sends commands that the player has entered using the mouse and keyboard for a certain period of time. Also this stage expects exactly the same data from other players. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User commands are transmitted via message </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MESSAGE_TYPE_PLAYER_GAME</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The GNetStadyGame stage has fields:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_player; PLAYER_MESSAGE* m_player;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which serve to receive commands from other players. The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLAYER_MESSAGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">has a buffer for receiving </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_BUFFER next_message messages;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, its purpose is not at all what it may seem at first glance. The fact is that there is a concept of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a network clock number</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is such a variable that counts clock cycles increasing from 0 to infinity until the game ends. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The network clock is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> increased only if the network client received commands from all players for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Otherwise, waiting happens and the game stops. But since the quality of communication usually allows delivering messages fairly stably, these delays occur unnoticed by the player.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the client starts to wait for a long time, then he reports this game through the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: OnWaitingPlayers function (unsigned int dtime, int k_player_id, unsigned int * m_player_id)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the game‚Äôs task is to bring this list of players to the screen. The waiting time is limited and the client ensures that the wait is not infinite. When the time limit is exhausted, the client begins to cut off problem players, declaring them losers, which immediately leads to the continuation of the game or its completion due to victory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the client received commands from another player for the current clock, they are immediately transferred to the game using the </font><i><font style="vertical-align: inherit;">virtual void</font></i><font style="vertical-align: inherit;"> function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GGame :: SetPlayerNetMessage (unsigned int sender, MEM_DATA &amp; message)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But if the received message is immediately transferred to the game, then probably it is not very clear, why do we need another buffer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_BUFFER next_message</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? But why? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said, network interaction is very much like multithreading, when performing some actions can be postponed indefinitely due to synchronization of flows. So ... in a network game, a situation can easily form when one computer began to overtake another by 1 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In this case, the message that came from the overtaking computer may be marked as a message for the next clock cycle, to which </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> computer has not yet reached. And then our computer should do the following ... it just saves this message in its own buffer.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NET_BUFFER next_message</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and while temporarily will no longer perform any action on this issue, but he will know that the message for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from such a player has already been received. And when this </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> begins </font><font style="vertical-align: inherit;">, first of all </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> computer will take these commands from its own buffer and immediately transfer them to the game via </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual void GGame :: SetPlayerNetMessage (unsigned int sender, MEM_DATA &amp; message)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is a very important point that it is desirable to understand to build network interaction in similar games. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You also need to understand that overtaking is no longer possible for 2 bars, since the process " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waiting for other players</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", therefore, the maximum advance can only be by 1 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in order to accept commands, you need to start someone to send them. The network client does not need to know anything about the specifics of the commands used in the game, so it simply calls the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">MEM_DATA GGame :: GetPlayerNetMessage ()</font></i><font style="vertical-align: inherit;"> , which returns to it a ready buffer with commands in the form of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEM_DATA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The received buffer is sent simultaneously to itself to all other players to the players.</font></font><br><br><pre> <code class="cpp hljs">MEM_DATA message=owner-&gt;game-&gt;GetPlayerNetMessage(); GNetSocket* socket=owner-&gt;GetMainSocket(); owner-&gt;game-&gt;SetPlayerNetMessage(socket-&gt;player_id, message); <span class="hljs-comment"><span class="hljs-comment">//     ,       int k_receiver=owner-&gt;RefreshReceiverList(); owner-&gt;m_receiver[k_receiver]=takt; //      ,     NET_BUFFER_INDEX* result=owner-&gt;PrepareMessageForPlayers(MESSAGE_TYPE_PLAYER_GAME, message.length, message.data, k_receiver, owner-&gt;m_receiver, 1); socket-&gt;SendMessage(result); //       </span></span></code> </pre> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The network clock is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> controlled by the game, and it returns it to the client via the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">GGame :: GetNetTakt ()</font></i><font style="vertical-align: inherit;"> . However, the client controls the completion of the network tact - this is the moment when all teams are received from all players. The client immediately reports this game by calling the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual bool GGame :: OnNextNetTakt ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This function, in my case, checks for network desynchronization and returns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if everything is in order. If it returns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the network client will automatically begin the process of correcting out of sync, for which the host will write all the data to the file and transfer this file to all other players, and other players will read this file and continue the game with this data. Practically, the host will make </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">save</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the rest of the players - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I control the network desynchronization through counting the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sum of random numbers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generated in one </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network cycle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random numbers are</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generated constantly and on all computers they must be the same, otherwise it is a sign that the network has become out of sync. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual bool GGame :: OnNextNetTakt ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then the client notes this fact in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on_next_net_takt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable for </font><i><font style="vertical-align: inherit;">itself</font></i><font style="vertical-align: inherit;"> - this means that the network clock is completed. The game must, in its main loop, periodically call the client function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool GNetClient :: IsNextNetTakt () {return on_next_net_takt;}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and when </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns </font><font style="vertical-align: inherit;">, the game increases the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by 1 and executes all commands received over the network for the last </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for each player. Then the arrays of commands are cleared and everything starts in a new way, but with an increased value of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commands that the player enters through the mouse and keyboard, get into the network is not immediately. In fact, it happens that the </font><font style="vertical-align: inherit;">commands that were collected during the </font><i><font style="vertical-align: inherit;">last network clock</font></i><font style="vertical-align: inherit;"> are transmitted </font><font style="vertical-align: inherit;">to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current network clock </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and at this time new commands from the mouse and keyboard are collected.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a delay in the reaction to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 network clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This delay is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Network Latency</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">However, there is no point in doing so that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network clocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coincide with the </font><i><font style="vertical-align: inherit;">tact of the</font></i><font style="vertical-align: inherit;"> game. </font><font style="vertical-align: inherit;">For example, if the game is updated 60 times per second, then it is quite possible to make sure that </font><font style="vertical-align: inherit;">10 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> games correspond </font><font style="vertical-align: inherit;">to </font><i><font style="vertical-align: inherit;">one network clock</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is unlikely that the user will be very annoyed by the response delay of 1/6 second.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traffic encryption </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have to admit that I am not strong in the subject of data protection and I want only to pay attention to it at the end. It is not necessary to connect to the server from the game, as the developer expects, i. In practice, you can connect from any program that has the ability to connect to an arbitrary IP address and port. Then you can start sending anything to the server. The server should try at least to check if the messages are not correct, otherwise it will simply collapse, having received a portion of ‚Äúnonsense‚Äù and become entangled in it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, messages from both sides are usually encrypted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not particularly argue on this topic, I will just say that I used the minimum encryption of traffic in my own. </font><font style="vertical-align: inherit;">I do not think that my defense is difficult to crack, because at this stage I have neither the desire nor the strength to do it. </font><font style="vertical-align: inherit;">I hope that for the time being I will be defended by the small fame of my project, and then it will be seen ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About one error that exists in Windows for a long time. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first part of the article, I described the network game in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> only as a general idea. </font><font style="vertical-align: inherit;">But there I pointed out the biggest problem that the network is fraught with in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the need to have completely identical calculations on all computers. If a computer starts to do something a little bit wrong, then in a couple of minutes everything will be very different on your computers. And the game will simply go into a stupor when a player tries to control a unit on his computer, which on another computer has long been "killed in a shootout." I consider such errors the most terrible of those I have seen, since it is practically impossible to catch such bugs with logic. The reasons for such errors are usually some insignificant trifle of the type ‚ÄúI forgot to re-initialize the variable when the network game was restarted‚Äù. As a result, this variable is guaranteed to collapse network synchronization, and very long before the game itself finally collapses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If anyone is interested in my reasoning on this topic, then refer to the </font></font><a href="https://habrahabr.ru/post/280520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first part of the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Now I want to talk about one, in my opinion, a very dirty glitch that has been present in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> since time immemorial. It is guaranteed to produce errors in floating-point calculations, which in turn once killed my network. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I discovered this problem supposedly in 2003-2004, even on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows 98</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , from there it successfully migrated to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows XP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and recently I discovered that </font><font style="vertical-align: inherit;">nothing has changed </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows 8</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> either. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main essence of the error is that the corresponding </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functions </font><font style="vertical-align: inherit;">change (and do not return back) the </font><b><font style="vertical-align: inherit;">FPU</font></b><font style="vertical-align: inherit;"> control word.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And, of course, there is no mention of such behavior anywhere in the documentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is my old code that proves the existence of a problem on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows XP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">On </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows 8,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I did not try it, but on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows 8</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I also ‚Äúflew into a situation‚Äù when my well-established network game suddenly began to work ugly for no apparent reason. </font><font style="vertical-align: inherit;">It turned out that I accidentally removed a piece of code that compensates for this problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So an example of the function:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> step=<span class="hljs-number"><span class="hljs-number">66.666664123535156</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> start_position_interpolation=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> position_interpolation=<span class="hljs-number"><span class="hljs-number">199.99998474121094</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> vdiscret=(position_interpolation-start_position_interpolation)/step; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> discret=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)vdiscret; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discret; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers, of course, are strange, but they show an error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you call the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error1 ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">and walk through it with a debugger, then the </font><font style="vertical-align: inherit;">number 2 will fall </font><font style="vertical-align: inherit;">into the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discret</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">. And now we do this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result=Error1(); <span class="hljs-comment"><span class="hljs-comment">// result=2 ok=direct_3d-&gt;CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &amp;d3d9pp, device_3d ); result=Error1(); //    result=3</span></span></code> </pre> <br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if between calls of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error1 ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">interpose</font></i><font style="vertical-align: inherit;"> the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">that creates the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> device </font><font style="vertical-align: inherit;">, then the second function call will give an unexpected result of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discret = 3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is due to the fact that for the first time the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vdiscret</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be equal to 2.99999 ......., and for the second time already 3. The difference is minimal in practice, but since in my game </font><font style="vertical-align: inherit;">, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variables are used </font><font style="vertical-align: inherit;">, this is quite enough to kill the whole network game. And besides, without knowing the reasons, there is nothing impossible to fix there, because formally the code itself is correct, just somewhere, some kind of processor state flag did not return to the desired value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows 98</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This problem manifested itself even more fiercely than in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows XP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There, this glitch occurred just when trying to list the available monitor resolutions, and using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinAPI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. </font><font style="vertical-align: inherit;">even without </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows 8,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I did not investigate this issue, since I already knew what to do with it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know of 2 solutions that "cure" this attack. </font><font style="vertical-align: inherit;">Once I just created a separate stream, switched the screen resolution in it and then just killed the stream along with the error. </font><font style="vertical-align: inherit;">This problem did not affect the main thread in this case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second method is simpler.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status=_controlfp(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    // ... // ... // ... _controlfp(status,_MCW_DN | _MCW_IC | _MCW_RC | _MCW_PC);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This kills the glitch that appears after switching the screen resolution, and the math continues to work correctly. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The current state of the game or release </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided that the game is already quite ready for release. Yes, it is possible that it is necessary to correct the balance or correct some minor errors, but, in fact, it is time to release the game. In any case, I see sense for further improvement only if there are regular players. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recently, I was surprised to find that, in addition to the well-known domains like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">org</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">net</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc., there is also a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">land</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> domain </font><font style="vertical-align: inherit;">. And since my game in English is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onimod land</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I immediately took the domain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onimod.land</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the game </font><font style="vertical-align: inherit;">, so now the game, like it used to be in the past, has its own personal site - </font></font><a href="http://onimod.land/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onimod.land</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before entering Steam, I think it will come a little later, but for now I am releasing the game through my website. Those who want to support my project financially, can do it on the site with the game. However, I myself live in Russia and I understand that people here have much more pressing items of expenditure than buying software. Therefore, if you like the game and you don‚Äôt have the financial means to support me financially, you can ask me for the key for free using the feedback form on the site. Please do not be lazy to introduce yourself, and even letters like ‚Äúgive me the key‚Äù from wertwq@mail.ru cause mostly negative emotions in me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The game has become commercial and, probably, soon I will find out if someone other than me needs it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps, on this note of philosophy, I will complete my story. I thank everyone for the strong willpower shown during the reading of this article, as well as for the condescending attitude towards my ‚Äúliterary talent‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincerely, Alexey Sedov (aka Odin_KG)</font></font><br><br>  <b>PS</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have a desire to translate articles about the game into English, at least the </font></font><a href="https://habrahabr.ru/post/280520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first part</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://astralax.ru/articles/pathway"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the path finding algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If someone has a good knowledge of English, at least some understanding of what I'm trying to talk about, and a desire to help me in this matter, then I will be very happy. </font><font style="vertical-align: inherit;">I tried to somehow hire a translator, but he gave me such grammatically correct sense nonsense that I have no particular desire to make another similar attempt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will remove this request from the article if someone responds and really gets down to business. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://habrahabr.ru/post/327596/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginning of the article: Resurrection of the game</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://habrahabr.ru/post/328116/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuation of the article: GUI</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/328118/">https://habr.com/ru/post/328118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328108/index.html">How to work with events in Flussonic</a></li>
<li><a href="../328110/index.html">How I did a "<" monoid</a></li>
<li><a href="../328112/index.html">How to learn 100 English words per day</a></li>
<li><a href="../328114/index.html">PHDays HackQuest 2017: RanSomWare - a small cryptor on GO</a></li>
<li><a href="../328116/index.html">The story of creating a classic RTS at home from scratch (Part 2: "Resurrection"). Continuation of the article: GUI</a></li>
<li><a href="../328120/index.html">Hachim IntegerCache in Java 9</a></li>
<li><a href="../328122/index.html">We do GraphQL API on PHP and MySQL. Part 1: Installation, layout and queries</a></li>
<li><a href="../328126/index.html">Parallels Mac Management: Transition Difficulties</a></li>
<li><a href="../328128/index.html">Quake 2 source code overview</a></li>
<li><a href="../328130/index.html">Pygest # 8. Releases, articles, interesting projects from the world of Python [April 11, 2017 - May 7, 2017]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>