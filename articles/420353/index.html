<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making Shrimp More Useful: Adding Recoding Images to Other Formats</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the beginning of 2017, our small team has been developing the RESTinio OpenSource library for embedding an HTTP server in a C ++ application. To...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making Shrimp More Useful: Adding Recoding Images to Other Formats</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Since the beginning of 2017, our small team has been developing the <a href="https://stiffstream.com/ru/products/restinio.html">RESTinio OpenSource library</a> for embedding an HTTP server in a C ++ application.  To our great surprise, from time to time, we get questions from the category ‚ÄúBut why might we need an embedded HTTP server in C ++?‚Äù Unfortunately, simple questions are the most difficult to answer.  Sometimes the best answer is sample code. <br><br>  A couple of months ago, we started a small <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo">Shrimp demo project</a> , which clearly demonstrates a typical scenario under which our library is ‚Äúhoned‚Äù.  The demo project is a simple Web service that receives requests for scaling of the pictures stored on the server and which responds with a picture of the size the user needs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This demo project is good because firstly, it requires integration with a long time ago written and properly working code in C or C ++ (in this case, ImageMagick).  Therefore, it should be clear why it makes sense to build an HTTP server in a C ++ application. <br><br>  And, secondly, in this case, asynchronous processing of requests is required so that the HTTP server does not block while the image is scaled (and this can take hundreds of milliseconds or even seconds).  And we started the development of RESTinio precisely because we could not find a sane C ++ embedded server that was focused on asynchronous request processing. <br><br>  We built the work on Shrimp in an iterative way: first, the simplest version that just scaled the pictures was made and <a href="https://habr.com/post/416387/">described</a> .  Then we eliminated a number of shortcomings of the first version and <a href="https://habr.com/post/417527/">described it in the second article</a> .  Finally got around to expand the functionality of Shrimp-and again: added the conversion of images from one format to another.  About how this was done and will be discussed in this article. <br><a name="habracut"></a><br><h1>  Target-format support </h1><br>  So, in the next version of Shrimp, we added the ability to render the scaled image in a different format.  So, if you issue a Shrimp request type: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  Shrimp will render the image in the same JPG format as the original image. <br><br>  But if you add the target-format parameter to the URL, then Shrimp will convert the image to the specified target format.  For example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  In this case, Shrimp will give the image in webp format. <br><br>  The updated Shrimp supports five image formats: jpg, png, gif, webp and heic (also known as HEIF).  You can experiment with different formats <a href="https://stiffstream.com/en/shrimp-demo.html">on a special web-page</a> : <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (on this page it is not possible to select the heic format, since regular desktop browsers do not support this format by default). <br><br>  In order to maintain the target-format in Shrimp, it took a little bit to refine the Shrimp code (which we were surprised by, because there really were a few changes).  But then I had to mess around with the ImageMagick build, which we were even more surprised by, since  before, we were faced with this kitchen, by a happy coincidence, it was not necessary.  But let's talk about everything in order. <br><br><h2>  ImageMagick must understand different formats. </h2><br>  ImageMagick for encoding / decoding images uses external libraries: libjpeg, libpng, libgif, etc.  These libraries must be installed on the system before ImageMagick is configured and built. <br><br>  The same thing should happen in order for ImageMagick to support webp and heic formats: first you need to build and install libwebp and libheif, then configure and install ImageMagick.  And if everything is simple with libwebp, then around libheif I had to dance with a tambourine.  Although after a while, after everything as a result gathered and started working, it is already incomprehensible: why did you have to resort to a tambourine, everything seems to be trivial?  ;) <br><br>  In general, if someone wants to make friends with heic and ImageMagick, you will have to install: <br><br><ul><li>  <a href="http://www.videolan.org/developers/x265.html">x265 from the project videolan.org</a> ; </li><li>  <a href="https://github.com/strukturag/libde265">libde265</a> ; </li><li>  <a href="https://github.com/strukturag/libheif">libheif</a> . </li></ul><br>  In that order (you may have to install <a href="https://www.nasm.us/">nasm</a> in order for x265 to work at maximum speed).  After that, when issuing the <i>./configure</i> command, ImageMagick will be able to find everything it needs to support .heic-files. <br><br><h2>  Support for target-format in query string incoming requests </h2><br>  After we made ImageMagick friends with the webp and heic formats, it was time to modify the Shrimp code.  First of all, we need to learn to recognize the target-format argument in incoming HTTP requests. <br><br>  From the point of view of RESTinio, this is not a problem at all.  Well, another argument appeared in the query string, so what?  But from the point of view of Shrimp, the situation turned out to be somewhat more complicated, which is why the function code that was responsible for parsing the HTTP request became more complicated. <br><br>  The fact is that before it was necessary to distinguish only two situations: <br><br><ul><li>  A request came in the form "/filename.ext" without any other parameters.  So you just need to give the file "filename.ext" as it is; </li><li>  A request came in the form "/filename.ext?op=resize &amp; ...".  In this case, you need to scale the image from the file ¬´filename.ext¬ª. </li></ul><br>  But after adding the target-format, we need to distinguish four situations: <br><br><ul><li>  A request came in the form "/filename.ext" without any other parameters.  So you just need to give the file "filename.ext" as it is, without scaling and without recoding to another format; </li><li>  A request came in the form "/filename.ext?target-format=fmt" without any other parameters.  It means to take an image from the file ‚Äúfilename.ext‚Äù and transcode it to the format ‚Äúfmt‚Äù while maintaining the original dimensions; </li><li>  A request came in the form "/filename.ext?op=resize &amp; ..." but without target-format.  In this case, you need to scale the image from the file ‚Äúfilename.ext‚Äù and give it in the original format; </li><li>  A request came in the form "/ filename.ext?op=resize&amp;...&amp;target-format=fmt".  In this case, you need to perform scaling, and then re-encode the result in the format "fmt". </li></ul><br>  As a result, the function for determining the request parameters took the <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">following form</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  In the previous version of Shrimp, where it was not necessary to transcode the image, working with the request parameters <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">looked a bit simpler</a> . <br><br><h2>  Request queue and image cache with target-format </h2><br>  The next point in the implementation of target-format support was the work to the queue of waiting requests and the cache of finished pictures in the a_transform_manager agent.  More about these things discussed <a href="https://habr.com/post/417527/">in the previous article</a> , but slightly recall what we are talking about. <br><br>  When a request comes to convert images, it may be that the finished image with such parameters is already in the cache.  In this case, you don‚Äôt need to do anything, just send the image from the cache in response.  If the picture needs to be converted, it may turn out that there are no free workers at the moment and you need to wait until it appears.  For this information about the request must be put in the waiting queue.  But at the same time, it is necessary to check the uniqueness of requests - if we are waiting for processing three identical requests (that is, we need to convert the same image in the same way), then we should process the image only once, and return the result of processing for these three requests.  Those.  waiting queues for the same requests must be grouped. <br><br>  Earlier in Shrimp, we used a simple composite key for searching the image cache and waiting queue: a <a href="">combination of the original file name + parameters for resizing the image</a> .  Now it was necessary to take into account two new factors: <br><br><ul><li>  first, the target image format (i.e., the source image may be in jpg, and the resulting image may be in png); </li><li>  secondly, the fact that image scaling may not be necessary.  This happens in a situation where the customer orders only the conversion of the image from one format to another, but with preservation of the original image size. </li></ul><br>  It must be said that here we went along the simplest path, without trying to somehow optimize anything.  For example, one could try to make two caches: one would store images in the original format, but scaled to the desired size, and in the second, scaled images converted to the target format. <br><br>  Why would such double caching be needed?  The fact is that during the transformation of images, the two most expensive operations in time are the resizing and serialization of the image into the target format.  Therefore, if we received a request for scaling the example.jpg image to the size of 1920 in width and transforming it into webp format, we could save two images in memory: example_1920px_width.jpg and example_1920px_width.webp.  Picture example_1920px_width.webp we would give when we receive a second request.  But the picture example_1920px_width.jpg could be used when receiving requests for scaling example.jpg up to size 1920 by width and transforming it into heic format.  We could skip the resizing operation and only do the format conversion (i.e. the ready-made image of example_1920px_width.jpg would be encoded into the heic format). <br><br>  Another potential opportunity: when a request comes to transcode an image into another format without resizing, you can determine the actual size of the image and use this size inside the composite key.  For example, let example.jpg be 3000x2000 pixels.  If we then receive a request for scaling example.jpg up to 2000px in height, then we can immediately determine that we already have a picture of this size. <br><br>  In theory, all these arguments deserve attention.  But from a practical point of view, it is not clear how high the probability of such a development is.  Those.  how often will we receive a request for scaling example.jpg up to 1920px with conversion to webp, and then a request for the same scaling of the same picture, but with conversion into png?  Without real statistics it is difficult to say.  Therefore, we decided not to complicate our lives in our demo project, but to go first along the simplest path.  Assuming that if someone needs more advanced caching schemes, this can be added later, starting from real, not fictional, scenarios for using Shrimp. <br><br>  As a result, in the updated version of Shrimp, we slightly expanded the key, adding to it another parameter such as the target format: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  Those.  request for resizing example.jpg up to size 1920px with conversion to png differs from the same resizing, but with conversion to webp or heic. <br><br>  But the main focus is hiding <a href="">in the new implementation of the resize_params_t class</a> , which defines the new dimensions of the scaled image.  <a href="">Previously, this class</a> supported three options: only the width is specified, only the height is specified or the long side is specified (the height or width is determined by the actual size of the picture).  Accordingly, the <a href="">resize_params_t :: value ()</a> method always returned some real value (which value was determined by the <a href="">resize_params_t :: mode ()</a> method). <br><br>  But in the new Shrimp one more mode has been added - keep_original, which means that the scaling is not performed and the picture is given in its original size.  To support this mode, some changes had to be made to resize_params_t.  First, the <a href="">resize_params_t :: make ()</a> method now determines whether the keep_original mode is used (this mode is considered to be used if none of the width, height, and max parameters in the query query query string is specified).  This allowed us not to rewrite the function <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> , which pushes the request to scale the image for execution. <br><br>  Secondly, the <a href="">resize_params_t :: value ()</a> method can now not always be called, but only when the scaling mode is different from keep_original. <br><br>  But the most important thing is that <a href="">resize_params_t :: operator &lt;()</a> continued to work as intended. <br><br>  Thanks to all these changes, a_transform_manager and the cache of scaled images, and the queue of waiting requests, remain the same.  But now in these data structures information about various queries is stored.  Thus, the key {"example.jpg", "jpg", keep_original} will be different from the key {"example.jpg", "png", keep_original}, and from the key {"example.jpg", "jpg", width = 1920px}. <br><br>  It turned out that by shaming a bit with defining such simple data structures as resize_params_t and resize_params_key_t, we avoided reworking more complex structures, such as the cache of the resulting images and the queue of pending requests. <br><br><h2>  Target-format support in a_transformer </h2><br>  Well, the final step in the support of target-format is an extension of the logic of the a_transformer agent so that the picture, possibly already scaled, is then converted to the target format. <br><br>  It was easiest to do this; all you had to do was to expand the code of the <a href="">a_transform_t :: handle_resize_request ()</a> method: <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  Compared <a href="">with the previous version,</a> there are two principal additions. <br><br>  First, calling the truly magical method image.magick () after performing a resizing.  This method specifies the ImageMagick image format.  At the same time, the representation of the picture in memory does not change - ImageMagick continues to store it as it suits him.  But then the value specified by the magick () method will be taken into account during the subsequent call to Image :: write (). <br><br>  Secondly, the updated version marks the time of the serialization of the image in the specified format.  The new version of Shrimp now records separately the time spent on scaling, and the time taken to convert to the target format. <br><br>  For the rest, the a_transformer_t agent has not changed. <br><br><h1>  Parallelization of ImageMagick work </h1><br>  By default, ImageMagic is built with OpenMP support.  Those.  it is possible to parallelize operations on images that ImageMagick performs itself.  You can control the number of worker threads that ImageMagick uses in this case by using the MAGICK_THREAD_LIMIT environment variable. <br><br>  For example, on my test machine with MAGICK_THREAD_LIMIT = 1 (that is, without real parallelization), I get the following results: <br><br><pre> <code class="hljs vbscript">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> -v &gt; /dev/<span class="hljs-literal"><span class="hljs-literal">null</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User-Agent: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep-alive &lt; Content-Length: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">Server</span></span>: Shrimp draft <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last-Modified: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access-Control-Allow-Origin: * &lt; Access-Control-Expose-Headers: Shrimp-Processing-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>, Shrimp-Resize-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>, Shrimp-Encoding-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>, Shrimp-Image-Src &lt; Content-Type: image/jpeg &lt; Shrimp-Image-Src: transform &lt; Shrimp-Processing-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp-Resize-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp-Encoding-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  The time spent on resizing is indicated in the Shrimp-Resize-Time header.  In this case, it is 1086.72ms. <br><br>  But if you set MAGICK_THREAD_LIMIT = 3 on the same machine and run Shrimp, then we get different values: <br><br><pre> <code class="hljs vbscript">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> -v &gt; /dev/<span class="hljs-literal"><span class="hljs-literal">null</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User-Agent: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep-alive &lt; Content-Length: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">Server</span></span>: Shrimp draft <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last-Modified: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access-Control-Allow-Origin: * &lt; Access-Control-Expose-Headers: Shrimp-Processing-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>, Shrimp-Resize-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>, Shrimp-Encoding-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>, Shrimp-Image-Src &lt; Content-Type: image/jpeg &lt; Shrimp-Image-Src: transform &lt; Shrimp-Processing-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp-Resize-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp-Encoding-<span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  Those.  the resizing time was reduced to 558.25ms. <br><br>  Accordingly, since ImageMagick provides the ability to parallelize calculations, you can use this opportunity.  But at the same time it is desirable to be able to control how many worker threads Shrimp will take under it.  In previous versions of Shrimp, it was impossible to influence how many workflows Shrimp created.  And in the updated version of Shrimp, it can be done.  Or through environment variables, for example: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  Or through command line arguments, for example: <br><br><pre> <code class="hljs matlab">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app -p <span class="hljs-number"><span class="hljs-number">8080</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> ... --io-threads <span class="hljs-number"><span class="hljs-number">1</span></span> --worker-threads <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Values ‚Äã‚Äãset via the command line have a higher priority. <br><br>  It should be emphasized that MAGICK_THREAD_LIMIT affects only those operations that ImageMagick performs itself.  For example, resizing is performed by ImageMagick.  But converting from one format to another ImageMagick delegates to external libraries.  And how operations in these external libraries are parallelized is a separate issue that we did not understand. <br><br><h1>  Conclusion </h1><br>  Perhaps, in this version of Shrimp, we have brought our demo project to an acceptable state.  Those who want to watch and experiment can find the source code of Shrimp on <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo">BitBucket</a> or <a href="https://github.com/Stiffstream/shrimp-demo">GitHub</a> .  You can also find a Dockerfile there to build Shrimp for your experiments. <br><br>  In general, we have achieved our goals, which we set for ourselves when starting this demo project.  A number of ideas have emerged for the further development of both RESTinio and SObjectizer, and some of them have already been implemented.  Therefore, whether Shrimp will develop somewhere further depends entirely on questions and wishes.  If they are, then Shrimp can expand.  If not, then Shrimp will remain a demo project and a testing ground for experiments with new versions of RESTinio and SObjectizer. <br><br>  In conclusion, I would like to express special thanks to <a href="https://habr.com/users/aensidhe/" class="user_link">aensidhe</a> for the help and advice, without which our dancing with a tambourine would be much longer and sad. </div><p>Source: <a href="https://habr.com/ru/post/420353/">https://habr.com/ru/post/420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420343/index.html">LED lights OK</a></li>
<li><a href="../420345/index.html">Overview of IXcellerate data center (the largest machine building in the Russian Federation)</a></li>
<li><a href="../420347/index.html">Learn how to create your own bash commands in less than 4 minutes.</a></li>
<li><a href="../420349/index.html">Checklist IT-outsourcing: working without risks</a></li>
<li><a href="../420351/index.html">How to search for users on GitHub using Vue</a></li>
<li><a href="../420355/index.html">Pebble smartwatch: how to become a rarity overnight</a></li>
<li><a href="../420357/index.html">Vuex: structuring large projects and working with modules</a></li>
<li><a href="../420359/index.html">Var, let or const? Problems scopes variables and ES6</a></li>
<li><a href="../420361/index.html">Bug when working TextBox.GetLineText in .NET WPF</a></li>
<li><a href="../420363/index.html">HPE webinars in August-October: new topics (+ storage, AI practice, turnkey petabyte storage)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>