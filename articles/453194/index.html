<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Solving the Best Reverser problem with PHDays 9</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 My name is Marat Gayanov, I want to share with you my solution to the problem from the Best Reverser competition , to show how to make keyge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Solving the Best Reverser problem with PHDays 9</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  My name is Marat Gayanov, I want to share with you my solution to the problem from the <a href="https://www.phdays.com/ru/program/contests/best-reverser/">Best Reverser competition</a> , to show how to make keygen for this case. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/ja/bo/rpjabo27x0oemehl_380bdoiyto.png" alt="image"></div><br><h2>  Description </h2><br>  In this competition, participants are provided with ROM games for the Sega Mega Drive ( <a href="">best_reverser_phd9_rom_v4.bin</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task: to choose such a key, which together with the participant‚Äôs email address will be recognized as valid. <br><br>  So the solution is ... <br><a name="habracut"></a><br><h2>  Instruments </h2><br><ul><li>  IDA Pro 6.8 </li><li>  <a href="https://github.com/lab313ru/smd_ida_tools">Plugin smd_ida_tools</a> </li></ul><br><h2>  Key length check </h2><br>  The program accepts not every key: you need to fill in the entire field, this is 16 characters.  If the key is shorter, then you will see the message: ‚ÄúWrong length!  Try again ... ". <br><br>  Let's try to find this line in the program, for which we use the binary search (Alt-B).  What will we find? <br><br>  Let's find not only this, but also a number of other service lines: ‚ÄúWrong key!  Try again ... ‚Äùand‚Äú YOU ARE THE BEST REVERSER! ‚Äù. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/-b/ru/fb/-brufb6jqqrejxctfwwvrp8l0xu.png" alt="image"></div><br><div style="text-align:center;"><img src="https://hsto.org/webt/6y/6m/jb/6y6mjbg8kod7ys087rlbngrshky.png" alt="image"></div><br>  The labels <code>WRONG_LENGTH_MSG</code> , <code>YOU_ARE_THE_BEST_MSG</code> and <code>WRONG_KEY_MSG</code> I set to make it convenient. <br><br>  Put a break on reading the address <code>0x0000FDFA</code> - find out who is working with the message ‚ÄúWrong length!  Try again ... ".  And we will start the debugger (it will stop several times before the key can be entered, just press F9 at each stop).  Enter your email, key <code>ABCD</code> . <br><br>  The debugger leads on <code>0x00006FF0 tst.b (a1)+</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/h5/mf/jqh5mfieh1st-s6fktdghtomemy.png" alt="image"></div><br>  There is nothing interesting in the block itself.  It is much more interesting who transfers control here.  Enjoying a call stack: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/w4/sa/1p/w4sa1p9_t4czdofd4jjj-tdtg4q.png" alt="image"></div><br>  Click and get here - on instruction <code>0x00001D2A jsr (sub_6FC0).l</code> : <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/1d/bp/xy/1dbpxyojlaks20xlmgivzm0rpdw.png" alt="image"></div><br>  We see that all possible messages were found in one place.  But let's find out where the control is transferred to the <code>WRONG_KEY_LEN_CASE_1D1C</code> block.  We will not put breaks, just hover the cursor on the arrow going to the block.  The caller is located at the address <code>0x000017DE loc_17DE</code> (which I will rename to <code>CHECK_KEY_LEN</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/bo/c1/tc/boc1tck7dpjuq46sppgq93wghfu.png" alt="image"></div><br>  Put a break to the address <code>0x000017EC cmpi.b 0x20 (a0, d0.l)</code> (the instruction in this context looks to see if there is an empty character at the end of the key character array), restart, re-enter the mail and the <code>ABCD</code> key.  The debugger stops and shows that at the address <code>0x00FF01C7</code> (which is currently stored in register <code>a0</code> ) is the key entered: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/qs/l9/k4/qsl9k4apyhz2orh5lz9vphf-gdo.png" alt="image"></div><br>  This is a good find, we will get everything out through it.  But first, mark the key bytes for convenience: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/on/kw/c8/onkwc8dvpch6ckyjbcl0a-9zx4q.png" alt="image"></div><br>  Scroll up from this place, we see that the mail is stored next to the key: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/at/_t/_j/at_t_jhxaruncxgntbn-i5t396o.png" alt="image"></div><br>  We plunge deeper and deeper, and it's time to find the criterion for the correctness of the key.  Rather, the first half of the key. <br><br><h2>  The criterion of the correctness of the first half of the key </h2><br><h3>  Preliminary calculations </h3><br>  It is logical to assume that immediately after checking the length will follow other operations with the key.  Consider the block immediately after the check: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/g4/oy/w6/g4oyw6inctcnokzxmo1r5kbfl9c.png" alt="image"></div><br>  This block is preliminary work.  The function <code>get_hash_2b</code> (in the original was <code>sub_1526</code> ) is called twice.  First, the address of the first byte of the key is transferred to it (register <code>a0</code> contains the address <code>KEY_BYTE_0</code> ), the second time - the fifth ( <code>KEY_BYTE_4</code> ). <br><br>  I called the function like this because it considers something like a 2-byte hash.  This is the most understandable name that I picked up. <br><br>  I will not consider the function itself, but I will write it on python right away.  She does simple things, but her description with screenshots will take a lot of space. <br><br>  The most important thing about it is to say: the starting address is supplied to the input, and the work is on 4 bytes from this address.  That is, they fed the input of the first byte of the key, and the function will work with the 1,2,3,4th.  The fifth filed, the function works from 5,6,7,8th.  In other words, in this block calculations are performed over the first half of the key.  The result is written to the register <code>d0</code> . <br><br>  So, the <code>get_hash_2b</code> function: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># key_4s -    def get_hash_2b(key_4s): #    def transform(b): # numbers -. if b &lt;= 0x39: r = b - 0x30 # Letter case and @ else: # @ABCDEF if b &lt;= 0x46: r = b - 0x37 else: # WXYZ if b &gt;= 0x57: r = b - 0x57 # GHIJKLMNOPQRSTUV else: r = 0xff - (0x57 - b) + 1 # a9+b return r #    key_4b = bytearray(key_4s, encoding="ascii") #     codes = [transform(b) for b in key_4b] #      part0 = (codes[0] &amp; 0xff) &lt;&lt; 0xc part1 = (codes[1] &lt;&lt; 0x8) &amp; 0xf00 part2 = (codes[2] &lt;&lt; 0x4) &amp; 0xf0 hash_2b = (part0 | part1) &amp; 0xffff hash_2b = (hash_2b | part2) &amp; 0xffff hash_2b = (hash_2b | (codes[3] &amp; 0xf)) return hash_2b</span></span></code> </pre> <br>  Immediately write the function decoding hash: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    4-  def decode_hash_4s(hash_2b): #    def transform(b): if b &lt;= 0x9: return b + 0x30 if b &lt;= 0xF: return b + 0x37 if b &gt;= 0x0: return b + 0x57 return b - 0xa9 #         b0 = transform(hash_2b &gt;&gt; 12) b1 = transform((hash_2b &amp; 0xfff) &gt;&gt; 8) b2 = transform((hash_2b &amp; 0xff) &gt;&gt; 4) b3 = transform(hash_2b &amp; 0xf) #  key_4s = [chr(b0), chr(b1), chr(b2), chr(b3)] key_4s = "".join(key_4s) return key_4s</span></span></code> </pre> <br>  I didn‚Äôt think up a better decoding function, and it‚Äôs not quite correct.  Therefore, I will check it this way (not right now, but much later): <br><br><pre> <code class="python hljs">key_4s == decode_hash_4s(get_hash_2b(key_4s))</code> </pre> <br>  Check the work <code>get_hash_2b</code> .  We are interested in the state of the <code>d0</code> register after executing the function.  We <code>0x000017FE</code> breaks on <code>0x000017FE</code> , <code>0x00001808</code> , key, enter <code>ABCDEFGHIJKLMNOP</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/x-/tu/mv/x-tumvz-5akeokp44a-wlclamuu.png" alt="image"></div><br><div style="text-align:center;"><img src="https://hsto.org/webt/ft/gy/ke/ftgykerggzjdpvpseel8vm7vaji.png" alt="image"></div><br>  The register <code>d0</code> contains the values <code>0xABCD</code> , <code>0xEF01</code> .  And what will <code>get_hash_2b</code> give? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>first_hash = get_hash_2b(<span class="hljs-string"><span class="hljs-string">"ABCD"</span></span>) &gt;&gt;&gt; hex(first_hash) <span class="hljs-number"><span class="hljs-number">0xabcd</span></span> &gt;&gt;&gt; second_hash = get_hash_2b(<span class="hljs-string"><span class="hljs-string">"EFGH"</span></span>) &gt;&gt;&gt; hex(second_hash) <span class="hljs-number"><span class="hljs-number">0xef01</span></span></code> </pre> <br>  Check passed. <br><br>  Next, <code>xor eor.w d0, d5</code> produced, the result is entered in <code>d5</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>hex(<span class="hljs-number"><span class="hljs-number">0xabcd</span></span> ^ <span class="hljs-number"><span class="hljs-number">0xef01</span></span>) <span class="hljs-number"><span class="hljs-number">0x44cc</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://hsto.org/webt/fa/6l/a0/fa6la0nx5iia9ldl24wgxibdwhy.png" alt="image"></div><br>  The receipt of such a hash <code>0x44CC</code> consists of preliminary calculations.  Then everything just gets complicated. <br><br><h3>  Where the hash goes </h3><br>  We can‚Äôt go further if we don‚Äôt know how the program works with the hash.  Surely it moves from <code>d5</code> to memory, since  the register is useful somewhere else.  We can find such an event through tracing (watching <code>d5</code> ), but not manual, but automatic.  This script will help: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto d5_val; auto i; for(;;) { StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); d5_val = GetRegValue("d5"); //    d5 if (d5_val != 0xFFFF44CC){ break; } } }</span></span></span></span></code> </pre> <br>  Let me remind you that we are now at the last break <code>0x00001808 eor.w d0, d5</code> .  Insert the script ( <code>Shift-F2</code> ), click <code>Run</code> <br><br>  The script will stop at the instruction <code>0x00001C94 move.b (a0, a1.l), d5</code> , but by this time <code>d5</code> has already been cleared.  However, we see that the value from <code>d5</code> moved by instruction <code>0x00001C56 move.w d5,a6</code> : it is written into memory at address <code>0x00FF0D46</code> (2 bytes). <br><br>  <b>Remember: the hash is stored at <code>0x00FF0D46</code> .</b> <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/wr/ya/gj/wryagjtwp8fvk35qfeyukg9meae.png" alt="image"></div><br>  Let's catch instructions that read from <code>0x00FF0D46-0x00FF0D47</code> (set break for reading).  Got 4 blocks: <br><br><img src="https://hsto.org/webt/m6/8g/ym/m68gymzx3mold0wdl1g0xnab-sw.png" alt="image"><img src="https://hsto.org/webt/id/rr/k_/idrrk_tmum_fu409yn21tqygisk.png" alt="image"><img src="https://hsto.org/webt/e0/nl/z_/e0nlz_whuvgznlt-efdiuecujqa.png" alt="image"><img src="https://hsto.org/webt/i8/tn/kv/i8tnkvhk6mc5nirtlb9hlwj-bui.png" alt="image"><br><br>  How to choose the right / the right ones? <br><br>  Back to the beginning: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/1d/bp/xy/1dbpxyojlaks20xlmgivzm0rpdw.png" alt="image"></div><br>  This block determines whether the program will go to <code>LOSER_CASE</code> or <code>WINNER_CASE</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/0l/ry/p70lrykx4qd6lof_e5kcnmcjbbk.png" alt="image"></div><br>  We see that in the register <code>d1</code> must be zero to win. <br><br>  Where is put zero?  Just scroll up: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_4/u0/tv/_4u0tvhvply85bhmwhjki65l0vu.png" alt="image"></div><br>  If the <code>loc_1EEC</code> is met in the <code>loc_1EEC</code> block: <br><br><pre> <code class="cpp hljs">*(a6 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) == *(a6 + <span class="hljs-number"><span class="hljs-number">0x22</span></span>)</code> </pre> <br>  then we get zero in <code>d5</code> . <br><br>  If we put a break on instruction <code>0x00001F16 beq.w loc_20EA</code> , then we see that <code>a6 + 0x24 = 0x00FF0D6A</code> and the value <code>0x4840</code> is stored there.  And in <code>a6 + 0x22 = 0x00FF0D68</code> is stored. <br><br>  If we enter different keys, mail, we will see that <code>0xCB4C - </code> .  <b>The first half of the key will be accepted only if in <code>0x00FF0D6A</code> will also be <code>0xCB4C</code> .</b>  <b>This is the criterion of the correctness of the first half of the key.</b> <br><br>  We find out what blocks they write in <code>0x00FF0D6A</code> - put a break on the record, enter the mail and the key again. <br><br>  And we will find this <code>loc_EAC</code> block (in fact, there are 3 of them, but the first two simply zero out <code>0x00FF0D6A</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/pc/um/u1/pcumu10pkuhgdcfehysc-hzlbk4.png" alt="image"></div><br>  This block belongs to the <code>sub_E3E</code> function. <br><br>  Through the call stack, we find out that the function <code>sub_E3E</code> is called in blocks <code>loc_1F94</code> , <code>loc_203E</code> : <br><br><img src="https://habrastorage.org/webt/8p/mt/uh/8pmtuh7u7gigntcmbx7wugc6q5e.png" alt="image"><img src="https://hsto.org/webt/lg/_-/2k/lg_-2kw8yl2_klsq5azj1mebnzs.png" alt="image"><br><br>  Remember we found 4 blocks earlier?  <code>loc_1F94</code> we saw there - this is the beginning of the main key processing algorithm. <br><br><h2>  The first important cycle loc_1F94 </h2><br>  The fact that <code>loc_1F94</code> is a loop can be seen from the code: it is executed <code>d4</code> times (see instruction <code>0x00001FBA d4,loc_1F94</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8p/mt/uh/8pmtuh7u7gigntcmbx7wugc6q5e.png" alt="image"></div><br>  What to look for: <br><br><ol><li>  There is a <code>sub_5EC</code> function. </li><li>  The instruction 0x00001FB4 jsr (a0) calls the sub_E3E function (this can be seen by a simple trace). </li></ol><br>  What's going on here: <br><br><ol><li>  The <code>sub_5EC</code> function writes the result of its execution to the <code>d0</code> register (a separate section is devoted to this below). </li><li>  The <code>d1</code> register stores the byte at <code>sp+0x33</code> ( <code>0x00FFFF79</code> , the debugger tells us), it is equal to the second byte from the key hash address ( <code>0x00FF0D47</code> ).  This is easy to prove if you put a break on the record at <code>0x00FFFF79</code> : it will work on the instruction <code>0x00001F94 move.b 1(a2), 0x2F(sp)</code> .  Register <code>a2</code> at this moment stores the address <code>0x00FF0D46</code> - the hash address, that is, <code>0x1(a2) = 0x00FF0D46 + 1</code> - the address of the second byte of the hash. </li><li>  Register <code>d0</code> is written <code>d0^d1</code> . <br></li><li>  The resulting xor'a result is given to the <code>sub_E3E</code> function, whose behavior depends on its previous calculations (shown below). </li><li>  Repeat. </li></ol><br>  How many times is this cycle executed? <br><br>  Let's figure it out.  Run this script: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto pc_val, d4_val, counter=0; while(pc_val != 0x00001F16) { StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); pc_val = GetRegValue("pc"); if (pc_val == 0x00001F92){ counter++; d4_val = GetRegValue("d4"); print(d4_val); } } print(counter); }</span></span></span></span></code> </pre> <br>  <code>0x00001F92 subq.l 0x1,d4</code> - here it is determined what will be in <code>d4</code> immediately before the cycle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xt/p9/ac/xtp9acx13gq3qrtvnisseyt8lfw.png" alt="image"></div><br>  We deal with the sub_5EC function. <br><br><h3>  sub_5EC </h3><br>  Significant piece of code: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/fd/uv/xk/fduvxkbfaxne_7eratvlhuqdt8w.png" alt="image"></div><br>  where <code>0x2c(a2)</code> always <code>0x00FF1D74</code> . <br>  This piece can be rewritten in pseudocode: <br><br><pre> <code class="cpp hljs">d0 = a2 + <span class="hljs-number"><span class="hljs-number">0x2C</span></span> *(a2+<span class="hljs-number"><span class="hljs-number">0x2C</span></span>) = *(a2+<span class="hljs-number"><span class="hljs-number">0x2C</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> #*(<span class="hljs-number"><span class="hljs-number">0x00FF1D74</span></span>) = *(<span class="hljs-number"><span class="hljs-number">0x00FF1D74</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> result = *(d0) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span></code> </pre> <br>  That is, 4 bytes from <code>0x00FF1D74</code> are the address, since  they are treated like a pointer. <br><br>  How to rewrite <code>sub_5EC</code> function on python? <br><br><ol><li>  Or make a memory dump and work with it. </li><li>  Or just write down all the output values. </li></ol><br>  I like the second method more, but what if for different authorization data the values ‚Äã‚Äãreturned are different?  Check it out. <br><br>  The script will help in this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto pc_val=0, d0_val; while(pc_val != 0x00001F16){ pc_val = GetRegValue("pc"); if (pc_val == 0x00001F9C) StepInto(); else StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); if (pc_val == 0x00000674){ d0_val = GetRegValue("d0") &amp; 0xFF; print(d0_val); } } }</span></span></span></span></code> </pre> <br>  I just compared the conclusions to the console with different keys, mails. <br><br>  Running the script several times with different keys, we will see that the <code>sub_5EC</code> function always returns the next value from the array: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_5EC_gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> dump = [<span class="hljs-number"><span class="hljs-number">0x92</span></span>, <span class="hljs-number"><span class="hljs-number">0x8A</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0x94</span></span>, <span class="hljs-number"><span class="hljs-number">0x3B</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xFC</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFE</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A</span></span>, <span class="hljs-number"><span class="hljs-number">0xBD</span></span>, <span class="hljs-number"><span class="hljs-number">0x91</span></span>, <span class="hljs-number"><span class="hljs-number">0xD5</span></span>, <span class="hljs-number"><span class="hljs-number">0x0A</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>, <span class="hljs-number"><span class="hljs-number">0xED</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xC2</span></span>, <span class="hljs-number"><span class="hljs-number">0xA5</span></span>, <span class="hljs-number"><span class="hljs-number">0xD6</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xA6</span></span>, <span class="hljs-number"><span class="hljs-number">0x72</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0x1A</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE7</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xF7</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xD6</span></span>, <span class="hljs-number"><span class="hljs-number">0x91</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xA4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0x86</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xE6</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xC6</span></span>, <span class="hljs-number"><span class="hljs-number">0xFE</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0x9D</span></span>, <span class="hljs-number"><span class="hljs-number">0x11</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A</span></span>, <span class="hljs-number"><span class="hljs-number">0xB8</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF7</span></span>, <span class="hljs-number"><span class="hljs-number">0xAE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x1C</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0x4C</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAD</span></span>, <span class="hljs-number"><span class="hljs-number">0x72</span></span>, <span class="hljs-number"><span class="hljs-number">0x4B</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAA</span></span>, <span class="hljs-number"><span class="hljs-number">0x3D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x3D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB9</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xD9</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB1</span></span>, <span class="hljs-number"><span class="hljs-number">0x13</span></span>, <span class="hljs-number"><span class="hljs-number">0xE1</span></span>, <span class="hljs-number"><span class="hljs-number">0xE1</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x15</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0xA3</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0x88</span></span>, <span class="hljs-number"><span class="hljs-number">0x9E</span></span>, <span class="hljs-number"><span class="hljs-number">0x2C</span></span>, <span class="hljs-number"><span class="hljs-number">0xB0</span></span>, <span class="hljs-number"><span class="hljs-number">0x8F</span></span>] l = len(dump) offset = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> offset &lt; l: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> dump[offset] offset += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  So, the <code>sub_5EC</code> function <code>sub_5EC</code> ready. <br><br>  At the queue <code>sub_E3E</code> . <br><br><h3>  sub_E3E </h3><br>  Significant piece of code: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/pc/um/u1/pcumu10pkuhgdcfehysc-hzlbk4.png" alt="image"></div><br>  We decipher: <br><br><pre> <code class="cpp hljs">   ,   d2,     .  a2   <span class="hljs-number"><span class="hljs-number">0xFF0D46</span></span>, a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF0D7A</span></span> d0 = *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) = *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>   ,   a0    a0 = d0 *(a0) = d2    offset,     d2.  a2   <span class="hljs-number"><span class="hljs-number">0xFF0D46</span></span>, a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF0D6A</span></span> -  ,     (. )  <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>,     d0 = *(a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) d2 = d0 ^ d2 d2 = d2 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span> d2 = d2 + d2  - <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> + d2,   ROM,   <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> + d2  a0 = <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> d2 = *(a0 + d2)       <span class="hljs-number"><span class="hljs-number">8</span></span>  d0 = d0 &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>  d2 = d0 ^ d2     *(a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) = d2</code> </pre> <br>  The <code>sub_E3E</code> function is reduced to such steps: <br><br><ol><li>  Save input argument to array. </li><li>  Calculate the offset. </li><li>  Pull out 2 bytes at <code>0x00011FC0 + offset</code> (ROM). </li><li>  Result = <code>(  &gt;&gt; 8) ^ (2  0x00011FC0 + offset)</code> . </li></ol><br>  Imagine the function <code>sub_E3E</code> in this form: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_E3E</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prev_sub_E3E_result, d2, d2_storage)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * ((prev_sub_E3E_result ^ d2) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) d2_storage.append(d2) offset = calc_offset() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"dump_00011FC0"</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dump_00011FC0_4096b = f.read() some = dump_00011FC0_4096b[offset:offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] some = int.from_bytes(some, byteorder=<span class="hljs-string"><span class="hljs-string">"big"</span></span>) prev_sub_E3E_result = prev_sub_E3E_result &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_sub_E3E_result ^ some</code> </pre> <br>  <code>dump_00011FC0</code> is just a file where I saved 4096 bytes from <code>[0x00011FC0:00011FC0+4096]</code> . <br><br><h2>  Activity about 1FC4 </h2><br>  We have not yet seen the address <code>0x00001FC4</code> , but it is easy to find, because the block goes almost immediately after the first cycle. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/rq/qu/4d/rqqu4dswxqemcgszszulcrrc8mc.png" alt="image"></div><br>  This block changes the contents at the address <code>0x00FF0D46</code> (register <code>a2</code> ), and that is where the hash of the key is stored, so we are now studying this block.  Let's see what happens here. <br><br><ol><li>  The condition that determines whether the left or right branch will be selected is: <code>(   ) &amp; 0b1 != 0</code> .  That is, the first bit of the hash is checked. </li><li>  If you look at both branches, you will see: <ul><li>  In both cases, there is a shift to the right by 1 bit. </li><li>  In the left branch above the hash operation <code> 0x8000</code> performed. </li><li>  In both cases, the processed hash value is written to the address <code>0x00FF0D46</code> , that is, the hash is replaced with the new value. </li><li>  Further calculations are not critical, because, roughly speaking, there are no write operations in <code>(a2)</code> (there is no instruction where the second operand would be <code>(a2)</code> ). <br></li></ul></li></ol><br>  Imagine a block like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hash_2b)</span></span></span><span class="hljs-function">:</span></span> new = hash_2b &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b &amp; <span class="hljs-number"><span class="hljs-number">0b1</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>: new = new | <span class="hljs-number"><span class="hljs-number">0x8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new</code> </pre> <br><h2>  The second important cycle loc_203E </h2><br>  <code>loc_203E</code> - cycle,  <code>0x0000206C bne.s loc_203E</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/lg/_-/2k/lg_-2kw8yl2_klsq5azj1mebnzs.png" alt="image"></div><br>  This cycle counts the hash and here is its main feature: <code>jsr (a0)</code> is a call to the <code>sub_E3E</code> function, which we have already considered - it relies on the previous result of its own work and on some input argument (above it was passed through the <code>d2</code> register, and here through <code>d0</code> ). <br><br>  Let's find out what is passed to it through the <code>d0</code> register. <br><br>  We have already met with the construction <code>0x34(a2)</code> - there the function <code>sub_E3E</code> saves the passed argument.  This means that previously passed arguments are used in this loop.  But not all. <br><br>  Decipher some code: <br><br><pre> <code class="cpp hljs">  <span class="hljs-number"><span class="hljs-number">2</span></span>    a2+<span class="hljs-number"><span class="hljs-number">0x1C</span></span> move.w <span class="hljs-number"><span class="hljs-number">0x1C</span></span>(a2), d0  neg.l d0   a0       sub_E3E movea.l <span class="hljs-number"><span class="hljs-number">0x34</span></span>(a2), a0 ,  d0  <span class="hljs-number"><span class="hljs-number">2</span></span>    a0-d0(   d0 ) move.b (a0, d0.l), d0</code> </pre><br>  The essence comes down to a simple action: at each iteration, take <code>d0</code> saved argument from the end of the array.  That is, if 4 is stored in <code>d0</code> , then we take the fourth element from the end. <br><br>  If so, what exactly does <code>d0</code> ?  Here I did without scripts, but simply wrote them out, putting a break at the beginning of this block.  Here they are: <code>0x04, 0x04, 0x04, 0x1C, 0x1A, 0x1A, 0x06, 0x42, 0x02</code> . <br><br>  Now we have everything to write a complete function to calculate the key hash. <br><br><h2>  Full function hash calculation </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hash_2b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    def transform(hash_2b): new = hash_2b &gt;&gt; 1 if hash_2b &amp; 0b1 != 0: new = new | 0x8000 return new main_cycle_counter = [17, 2, 2, 3, 4, 38, 10, 30, 4] second_cycle_counter = [2, 2, 2, 2, 2, 4, 2, 4, 28] counters = list(zip(main_cycle_counter, second_cycle_counter)) d2_storage = [] storage_offsets = [0x04, 0x04, 0x04, 0x1C, 0x1A, 0x1A, 0x06, 0x42, 0x02] prev_sub_E3E_result = 0x0000 sub_5EC = sub_5EC_gen() for i in range(9): c = counters[i] for _ in range(c[0]): d0 = next(sub_5EC) d1 = hash_2b &amp; 0xff d2 = d0 ^ d1 curr_sub_E3E_result = sub_E3E(prev_sub_E3E_result, d2, d2_storage) prev_sub_E3E_result = curr_sub_E3E_result storage_offset = storage_offsets.pop(0) for _ in range(c[1]): d2 = d2_storage[-storage_offset] curr_sub_E3E_result = sub_E3E(prev_sub_E3E_result, d2, d2_storage) prev_sub_E3E_result = curr_sub_E3E_result hash_2b = transform(hash_2b) return curr_sub_E3E_result</span></span></code> </pre> <br><h3>  Health check </h3><br><ol><li>  In the debugger, we set a break to the address <code>0x0000180A move.l 0x1000,(sp)</code> (immediately after calculating the hash). </li><li>  Break to the address <code>0x00001F16 beq.w loc_20EA</code> (comparison of the final hash with the constant <code>0xCB4C</code> ). </li><li>  In the program, enter the key <code>ABCDEFGHIJKLMNOP</code> , press <code>Enter</code> . </li><li>  The debugger stops at <code>0x0000180A</code> , and we see that the value of <code>0xFFFF44CC</code> is <code>0x44CC</code> <code>d5</code> register, <code>0x44CC</code> is the first hash. </li><li>  Run the debugger on. </li><li>  We stop at <code>0x00001F16</code> and see that at the address <code>0x00FF0D6A</code> is <code>0x4840</code> - the final hash <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lb/zp/bo/lbzpbohzrioqfs-3h_jj7q5v4sy.png" alt="image"></div></li><li>  Now we‚Äôll check our finish_hash (hash_2b) function: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>r = finish_hash(<span class="hljs-number"><span class="hljs-number">0x44CC</span></span>) &gt;&gt;&gt; print(hex(r)) <span class="hljs-number"><span class="hljs-number">0x4840</span></span></code> </pre> </li></ol><br><h2>  Looking for the right key 1 </h2><br>  The correct key is this key, whose final hash is <code>0xCB4C</code> (figured out above).  Hence the question: what should be the first hash for the final to become <code>0xCB4C</code> ? <br><br>  Now it's just to find out: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_CB4C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hash_2b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>): final_hash = finish_hash(hash_2b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> final_hash == <span class="hljs-number"><span class="hljs-number">0xCB4C</span></span>: result.append(hash_2b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result &gt;&gt;&gt; r = find_CB4C() &gt;&gt;&gt; print(r)</code> </pre> <br>  The output of the program says that there is one option: the first hash should be <code>0xFEDC</code> . <br><br>  What characters do we need for their first hash to be <code>0xFEDC</code> ? <br><br>  Since <code>0xFEDC = __4_ ^ __4_</code> , then you only need to find <code>__4_</code> because the <code>__4_ = __4_ ^ 0xFEDC</code> .  And then decode both hashes. <br><br>  The algorithm is as follows: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first_half</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pairs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>): pair = (i, i ^ <span class="hljs-number"><span class="hljs-number">0xFEDC</span></span>) pairs.append(pair) pairs = deque(pairs) pairs.rotate(randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(pairs) pairs = get_pairs() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs: key_4s_0 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]) key_4s_1 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]) hash_2b_0 = get_hash_2b(key_4s_0) hash_2b_1 = get_hash_2b(key_4s_1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b_0 == pair[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hash_2b_1 == pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_4s_0, key_4s_1</code> </pre> <br>  A bunch of options, choose any. <br><br><h2>  We are looking for the right key 2 </h2><br>  The first half of the key is ready, what about the second? <br><br>  This is the easiest part. <br><br>  The responsible piece of code is located at <code>0x00FF2012</code> , I got to it by manual tracing, starting at <code>0x00001F16 beg.w loc_20EA</code> (validation of the first half of the key).  In the register <code>a0</code> is the address of the mail, <code>loc_FF2012</code> is a cycle, because  <code>bne.s loc_FF2012</code> .  It is executed as long as there is <code>*(a0+d0)</code> (the next byte of the mail). <br><br>  The <code>jsr (a3)</code> instruction calls the familiar function <code>get_hash_2b</code> , which now works with the second half of the key. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/wl/ln/5i/wlln5if5bzqcukbxnvpc_osl5lw.png" alt="image"></div><br>  Let's make the code clearer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(d1 != <span class="hljs-number"><span class="hljs-number">0x20</span></span>){    d2++ d1 = d1 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>     d3 = d3 + d1 d0 = <span class="hljs-number"><span class="hljs-number">0</span></span> d0 = d2    d1 = *(a0+d0) } d0 = get_hash_2b(key_byte_8) d3 = d0^d3 d0 = get_hash_2b(key_byte_12) d2 = d2 - <span class="hljs-number"><span class="hljs-number">1</span></span> d2 = d2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> d2 = d0^d2 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 == d3) success_branch</code> </pre> <br>  In the register <code>d2</code> - <code>( -1) &lt;&lt; 8</code> .  In <code>d3</code> , the sum of the bytes of the characters in the mail. <br><br>  The correctness criterion is obtained as follows: <code>__ ^ d2 == ___2 ^ d3</code> . <br><br>  We write the function of selecting the second half of the key: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_second_half</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_koeff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> k1 = sum([ord(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> email]) k2 = (len(email) - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k1, k2 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(k1, k2)</span></span></span><span class="hljs-function">:</span></span> pairs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>): pair = (a, (a ^ k1) ^ k2) pairs.append(pair) pairs = deque(pairs) pairs.rotate(randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(pairs) k1, k2 = get_koeff() pairs = get_pairs(k1, k2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs: key_4s_0 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]) key_4s_1 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]) hash_2b_0 = get_hash_2b(key_4s_0) hash_2b_1 = get_hash_2b(key_4s_1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b_0 == pair[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hash_2b_1 == pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_4s_0, key_4s_1</code> </pre> <br><br><h2>  Keygen </h2><br>  Mail necessarily caps. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keygen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email)</span></span></span><span class="hljs-function">:</span></span> first_half = get_first_half() second_half = get_second_half(email) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join(first_half) + <span class="hljs-string"><span class="hljs-string">""</span></span>.join(second_half) &gt;&gt;&gt; email = <span class="hljs-string"><span class="hljs-string">"M.GAYANOV@GMAIL.COM"</span></span> &gt;&gt;&gt; print(keygen(email)) <span class="hljs-number"><span class="hljs-number">2</span></span>A4FD493BA32AD75</code> </pre> <br><div style="text-align:center;"><img src="https://hsto.org/webt/rp/ja/bo/rpjabo27x0oemehl_380bdoiyto.png" alt="image"></div><br>  Thanks for attention!  All code is available <a href="https://github.com/mgayanov/PHDays9_Best_Reverser">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/453194/">https://habr.com/ru/post/453194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453178/index.html">The main skill of the developer who will make your code better</a></li>
<li><a href="../45318/index.html">Gay Test v.2</a></li>
<li><a href="../453188/index.html">How to explain to non-IT managers how to build a resilient IT infrastructure</a></li>
<li><a href="../45319/index.html">Bind an icon to each type of file on CSS</a></li>
<li><a href="../453192/index.html">Synchronous and asynchronous processes</a></li>
<li><a href="../453196/index.html">Forrester study: a comparison of the top ten vendors of Software Composition Analysis</a></li>
<li><a href="../4532/index.html">Digital music sales continue to grow</a></li>
<li><a href="../45320/index.html">Acceptance of payments on the site</a></li>
<li><a href="../453200/index.html">Discussion: the OpenROAD project intends to solve the problem of automation of processor design</a></li>
<li><a href="../453204/index.html">Containers, microservices and service meshes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>