<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FPGA image rotation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Half a year ago, I came across this video here . 

 The first thought was that it was very cool and I could never do that again. Time passed, articles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FPGA image rotation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/db0/1e5/ea3/db01e5ea384b44e3a946d61a962487b0.png"><br><br>  Half a year ago, I came across <a href="https://www.youtube.com/watch%3Fv%3Di7zvnbMZeUs">this video here</a> . <br><br>  The first thought was that it was very cool and I could never do that again.  Time passed, articles were read, methods were studied, and I looked for examples of how to implement this, but to my chagrin, nothing concrete was found on the network.  Once I stumbled upon the calculations of trigonometric functions using the CORDIC algorithms, I decided to try creating my own image rotator on the FPGA. <br><a name="habracut"></a><br><h3>  CORDIC </h3><br>  So, <b>CORDIC</b> is an abbreviation for <b>CO</b> ordinate <b>R</b> otation <b>D</b> Igital <b>C</b> omputer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is a powerful tool for calculating hyperbolic and trigonometric functions.  Most CORDIC algorithms work in a sequential approximation method and are not very difficult to implement in both high-level programming languages ‚Äã‚Äãand HDL.  I will not focus on the math method, the reader can read it on the network or on the links below. <br><br>  In free access, I came across <a href="https://github.com/freecores/verilog_cordic_core">this</a> implementation of the CORDIC algorithm in verilog.  This core works in 2 modes: <b>Rotate</b> and <b>Vector</b> .  Rotate mode is suitable for our purposes.  It allows you to calculate the values ‚Äã‚Äãof the functions <b>sin</b> and <b>cos</b> from a given angle in radians or degrees.  The library can be configured both in the pipeline and in the combination version.  For our purposes, the pipeline is suitable, it has the largest <b>Fmax</b> .  It will produce sine and cosine values ‚Äã‚Äãwith a delay of 16 cycles. <br><br>  In the RTL Viewer-e CORDIC module is displayed consisting of 16 blocks of the same type: <br><img src="https://habrastorage.org/files/7b8/ee7/911/7b8ee791177f4b4287d56d47d322e0e8.png"><br><br>  Each of which accepts input from the previous one and outputs connected to the inputs of the next.  It looks like this: <br><br><img src="https://habrastorage.org/files/c9c/e14/e29/c9ce14e295364f7ab261f54ac4425469.png"><br><br>  The library core works only in the first quadrant, and this means that we will have to calculate the remaining three by subtracting pi / 2 and changing the sign. <br><br>  The approach I have chosen is not very correct.  The quality of the rotated image leaves much to be desired.  This is due to the calculation of coordinates on the fly, without the use of additional data buffering and sequential calculation of coordinates for several passes, as is done in <a href="https://en.wikipedia.org/wiki/Shear_mapping"><b>Shear</b></a> . <br><br>  The first instance of our rotator is the block for calculating the quadrant and the angle of rotation.  The rotation angle is incremented by each new frame by 1 degree.  Upon reaching an angle of 90 degrees, the quadrant changes to the next one in turn, and the angle is either reset to zero or decremented by 1 degree each new frame. <br><br>  It looks like this: <br><br><pre><code class="hljs vhdl">always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> cordic_angle &lt;= <span class="hljs-number"><span class="hljs-number">17</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; cordic_quadrant &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; rotator_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frame_changed) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (rotator_state) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cordic_angle[<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] == <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d89</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> cordic_quadrant &lt;= cordic_quadrant + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; rotator_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cordic_angle[<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] &lt;= cordic_angle[<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cordic_angle[<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] == <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> cordic_quadrant &lt;= cordic_quadrant + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; rotator_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cordic_angle[<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] &lt;= cordic_angle[<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: rotator_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Next, the angle value is fed to the CORDIC module, which calculates the values ‚Äã‚Äãof sin and cos. <br><br><pre> <code class="hljs lisp">cordic CORDIC( .clk(<span class="hljs-name"><span class="hljs-name">clk</span></span>), .rst(~nRst), .x_i(<span class="hljs-number"><span class="hljs-number">17</span></span>'d19896), .y_i(<span class="hljs-number"><span class="hljs-number">16</span></span>'d0), .theta_i(<span class="hljs-name"><span class="hljs-name">cordic_angle</span></span>), .x_o(<span class="hljs-name"><span class="hljs-name">COS</span></span>), .y_o(<span class="hljs-name"><span class="hljs-name">SIN</span></span>), .theta_o(), .valid_in(), .valid_out() )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Further, it is not difficult to guess that the calculation of the coordinates of each subsequent pixel will be made using the formula: <br><br>  x '= cos (angle) * x - sin (angle) * y; <br>  y '= sin (angle) * x + cos (angle) * y; <br><br><img src="https://habrastorage.org/files/baa/63b/6db/baa63b6db1d54dc1bdc772d343b908e8.png"><br><br>  If you leave everything in this form, then the rotation will be centered at the origin.  This rotation does not suit us, we need the image to rotate around its axis with the center in the middle of the image.  To do this, we need to conduct calculations relative to the center of the image. <br><br><pre> <code class="hljs pgsql">parameter <span class="hljs-type"><span class="hljs-type">PRECISION</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span>; parameter OUTPUT = <span class="hljs-number"><span class="hljs-number">12</span></span>; parameter INPUT = <span class="hljs-number"><span class="hljs-number">12</span></span>; parameter OUT_SIZE = <span class="hljs-type"><span class="hljs-type">PRECISION</span></span> + OUTPUT; parameter BUS_MSB = OUT_SIZE + <span class="hljs-number"><span class="hljs-number">2</span></span>; wire [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] res_x = RES_X - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; wire [15:0] res_y = RES_Y - 1'</span></span>b1; assign dx = {<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0, RES_X[11:1]}; assign dy = {1'</span></span>b0, RES_Y[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> delta_x &lt;= dx &lt;&lt; <span class="hljs-type"><span class="hljs-type">PRECISION</span></span>; delta_y &lt;= dy &lt;&lt; <span class="hljs-type"><span class="hljs-type">PRECISION</span></span>; nd</code> </pre><br>  Next, we calculate the values ‚Äã‚Äãcos (angle) * x, sin (angle) * x, cos (angle) * y, sin (angle) * y. <br>  You can calculate it like this: <br><br><pre> <code class="hljs vbscript">always @(posedge clk) begin mult_xcos &lt;= (xi - dx) * <span class="hljs-built_in"><span class="hljs-built_in">COS</span></span>; mult_xsin &lt;= (xi - dx) * <span class="hljs-built_in"><span class="hljs-built_in">SIN</span></span>; mult_ycos &lt;= (yi - dy) * <span class="hljs-built_in"><span class="hljs-built_in">COS</span></span>; mult_ysin &lt;= (yi - dy) * <span class="hljs-built_in"><span class="hljs-built_in">SIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  But I decided to use megafunctions <b>lpm_mult</b> .  Their use significantly increases <b>Fmax</b> . <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> signed [BUS_MSB: <span class="hljs-number"><span class="hljs-number">0</span></span>] tmp_x, tmp_y, mult_xsin, mult_xcos, mult_ysin, mult_ycos; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> signed [BUS_MSB: <span class="hljs-number"><span class="hljs-number">0</span></span>] delta_x = <span class="hljs-number"><span class="hljs-number">0</span></span>, delta_y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">wire</span></span> signed [<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] dx, dy; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> signed [BUS_MSB: <span class="hljs-number"><span class="hljs-number">0</span></span>] mxsin, mxcos, mysin, mycos; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> signed [<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] ddx, ddy; <span class="hljs-attribute"><span class="hljs-attribute">always</span></span> @(posedge clk) begin ddx &lt;= xi - dx; <span class="hljs-attribute"><span class="hljs-attribute">ddy</span></span> &lt;= yi - dy; <span class="hljs-attribute"><span class="hljs-attribute">end</span></span> wire signed [BUS_MSB-<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] mult_xcos1; <span class="hljs-attribute"><span class="hljs-attribute">wire</span></span> signed [BUS_MSB-<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] mult_xsin1; <span class="hljs-attribute"><span class="hljs-attribute">wire</span></span> signed [BUS_MSB-<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] mult_ycos1; <span class="hljs-attribute"><span class="hljs-attribute">wire</span></span> signed [BUS_MSB-<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] mult_ysin1; <span class="hljs-attribute"><span class="hljs-attribute">lpm_mult</span></span> M1(.clock(clk), .dataa(COS), .datab(ddx), .result(mult_xcos1)); <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M1.lpm_widtha = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M1.lpm_widthb = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M1.lpm_pipeline = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M1.lpm_representation = <span class="hljs-string"><span class="hljs-string">"SIGNED"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">lpm_mult</span></span> M2(.clock(clk), .dataa(SIN), .datab(ddx), .result(mult_xsin1)); <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M2.lpm_widtha = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M2.lpm_widthb = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M2.lpm_pipeline = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M2.lpm_representation = <span class="hljs-string"><span class="hljs-string">"SIGNED"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">lpm_mult</span></span> M3(.clock(clk), .dataa(COS), .datab(ddy), .result(mult_ycos1)); <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M3.lpm_widtha = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M3.lpm_widthb = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M3.lpm_pipeline = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M3.lpm_representation = <span class="hljs-string"><span class="hljs-string">"SIGNED"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">lpm_mult</span></span> M4(.clock(clk), .dataa(SIN), .datab(ddy), .result(mult_ysin1)); <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M4.lpm_widtha = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M4.lpm_widthb = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M4.lpm_pipeline = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M4.lpm_representation = <span class="hljs-string"><span class="hljs-string">"SIGNED"</span></span>;</code> </pre><br>  After multiplication, we obtain products whose sign we need to change in each of the following quadrants: <br><br><pre> <code class="hljs vhdl">always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mxcos &lt;= mult_xcos1; mxsin &lt;= mult_xsin1; mycos &lt;= mult_ycos1; mysin &lt;= mult_ysin1; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (cordic_quadrant) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mxsin &lt;= -mult_xsin1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mxcos &lt;= -mult_xcos1; mxsin &lt;= -mult_xsin1; mycos &lt;= -mult_ycos1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mxcos &lt;= -mult_xcos1; mysin &lt;= -mult_ysin1; mycos &lt;= -mult_ycos1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mysin &lt;= -mult_ysin1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Now it remains for the small - to calculate the pixel coordinates themselves: <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/* I II III IV + + + - - - - - + - + + + - - + */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> tmp_x &lt;= delta_x + mxcos + mysin; tmp_y &lt;= delta_y + mycos + mxsin; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> wire [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] xo = tmp_x[BUS_MSB] ? <span class="hljs-number"><span class="hljs-number">12</span></span><span class="hljs-string"><span class="hljs-string">'d0: tmp_x[OUT_SIZE-1:PRECISION]; wire [15:0] yo = tmp_y[BUS_MSB] ? 12'</span></span>d0: tmp_y[OUT_SIZE<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-type"><span class="hljs-type">PRECISION</span></span>];</code> </pre><br>  We cut the pixels that go beyond the image: <br><br><pre> <code class="hljs scala">wire [<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] xo_t = (xo[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; res_x[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]) ? <span class="hljs-number"><span class="hljs-number">12</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span> : xo[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; wire [<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] yo_t = (yo[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; res_y[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]) ? <span class="hljs-number"><span class="hljs-number">12</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span> : yo[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  And his address in memory: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//addr_out &lt;= yo[11:0] * RES_X + xo[11:0];</span></span></code> </pre><br>  And again we use <b>lpm_mult:</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] xo_r, yo_r; <span class="hljs-attribute"><span class="hljs-attribute">always</span></span> @(posedge clk) begin xo_r &lt;= xo_t; <span class="hljs-attribute"><span class="hljs-attribute">yo_r</span></span> &lt;= yo_t; <span class="hljs-attribute"><span class="hljs-attribute">end</span></span> wire [<span class="hljs-number"><span class="hljs-number">28</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] result; <span class="hljs-attribute"><span class="hljs-attribute">lpm_mult</span></span> M5(.clock(clk), .dataa(RES_X[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]), .datab(yo_r[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]), .result(result)); <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M5.lpm_widtha = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M5.lpm_widthb = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M5.lpm_pipeline = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">defparam</span></span> M5.lpm_representation = <span class="hljs-string"><span class="hljs-string">"UNSIGNED"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">always</span></span> @(posedge clk) addr_out &lt;= result[<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] + xo_r[<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  That's all! <br><br><h3>  Method problems </h3><br>  As I mentioned above, this approach has many drawbacks.  Because of the calculation error, holes appear in the output image; the larger the angle of rotation, the larger the holes.  This also happens by the fact that the size of the new image is larger than that of the original.  This effect will be aliasing and there are methods of dealing with it, for example, the median filter reviewed in my previous <a href="https://habrahabr.ru/post/324070/">article</a> . <br><br>  Before each subsequent frame it would not hurt to clean the memory from the previous frame so that the new image is obtained on a clean background, but it takes time and you have to skip one frame. <br><br>  The only advantage of the method is the ease of implementation and processing speed, since  coordinates are calculated on-the-fly. <br><br><h3>  That's what came out of it </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/TLw5JwMIgkM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h3>  Related Links </h3><br>  ‚Üí <a href="https://electronix.ru/forum/index.php%3Fact%3Dattach%26type%3Dpost%26id%3D90724">CORDIC in Russian</a> <br>  ‚Üí <a href="http://bsvi.ru/uploads/CORDIC--_10EBA/cordic.pdf">CORDIC for dummies</a> <br>  ‚Üí <a href="https://dspguru.com/dsp/faqs/cordic/">CORDIC FAQ</a> <br><br><h3>  Quartus Project Archive </h3><br>  ‚Üí <a href="https://yadi.sk/d/J24nvd7G3GUSkN">Link to Yandex disk.</a> </div><p>Source: <a href="https://habr.com/ru/post/325236/">https://habr.com/ru/post/325236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325224/index.html">We generate a table of contents for the text</a></li>
<li><a href="../325226/index.html">How hackers attack corporate WiFi: parsing attacks</a></li>
<li><a href="../325230/index.html">OpenSSL, ssl_ciphers and nginx: we pump 100%</a></li>
<li><a href="../325232/index.html">Zen social programming</a></li>
<li><a href="../325234/index.html">Poll. What php-framework do you use?</a></li>
<li><a href="../325242/index.html">Tuning SQL Server 2012 under SharePoint 2013/2016. Part 1</a></li>
<li><a href="../325244/index.html">SEM time measure. Or ‚Äúhow do you know SEM and what to do next?‚Äù</a></li>
<li><a href="../325246/index.html">Sandbox technology. Check Point SandBlast. Part 1</a></li>
<li><a href="../325248/index.html">Pitfalls for home-made distribution "out of the box" in the C ++ actor framework</a></li>
<li><a href="../325252/index.html">On the practice of using the IBM DOORS requirements management system at NAMI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>