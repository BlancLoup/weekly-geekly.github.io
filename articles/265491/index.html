<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We do our iterator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is not often necessary to create your own iterator, and I would like to have on hand a small HowTo. In this article I want to tell you how to creat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We do our iterator</h1><div class="post__text post__text-html js-mediator-article">  It is not often necessary to create your own iterator, and I would like to have on hand a small HowTo.  In this article I want to tell you how to create a simple iterator that can be used in standard algorithms like std :: copy, std :: find.  What methods and type definitions are needed in the container class so that it can be bypassed in for loops from c ++ 11 and BOOST_FOREACH. <br><br><a name="habracut"></a><br><h1>  Container </h1><br>  In the container class, you need to define the types of the iterator and const_iterator (types are needed first for convenience, and secondly the bypass will not work without them using BOOST_FOREACH), as well as the begin and end methods (depending on the requirements, you can add only constant methods returning const_iterator): <br>  For example, take a container storing an array of integers. <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> OwnIterator&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> OwnIterator&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; const_iterator; OwnContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; values); <span class="hljs-function"><span class="hljs-function">iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">const_iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">const_iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; data; };</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Implementing OwnContainer Methods</b> <div class="spoiler_text"><pre> <code class="cpp hljs">OwnContainer::OwnContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; values) : size(values.size()), data(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[size]) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(values.begin(), values.end(), data.get()); } OwnContainer::iterator OwnContainer::begin() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator(data.get()); } OwnContainer::iterator OwnContainer::end() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator(data.get() + size); } OwnContainer::const_iterator OwnContainer::begin() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> const_iterator(data.get()); } OwnContainer::const_iterator OwnContainer::end() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> const_iterator(data.get() + size); }</code> </pre><br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Naturally, nothing prevents the definition of the iterator and const_iterator as aliases of the same type. <br><br><h1>  Iterator </h1><br>  The iterator should be inherited from the class std :: iterator.  By itself, this class does not implement any methods, but declares the necessary types that are used in standard algorithms. <br><div class="spoiler">  <b class="spoiler_title">std :: iterator</b> <div class="spoiler_text">  How is it defined in g ++ 4.9 <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Category, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Tp, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Distance = <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Pointer = _Tp*, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Reference = _Tp&amp;&gt; struct iterator { <span class="hljs-comment"><span class="hljs-comment">/// One of the @link iterator_tags tag types@endlink. typedef _Category iterator_category; /// The type "pointed to" by the iterator. typedef _Tp value_type; /// Distance between iterators is represented as this type. typedef _Distance difference_type; /// This type represents a pointer-to-value_type. typedef _Pointer pointer; /// This type represents a reference-to-value_type. typedef _Reference reference; };</span></span></code> </pre><br></div></div><br><br>  This is a template class, the first parameter of the template is an iterator type, since we are going to use it with the standard library, then the type is selected from the following types: input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag, random_access_iterator_tag.  The second parameter is the type of value that is stored and returned by the * and -&gt; operators, the termination parameter is a type that can describe the distance between iterators, the fourth template parameter is the type of the pointer to the value, the fifth is the type of the reference to the values.  The first two parameters are required. <br><br>  The easiest iterator is InputIterator (input_iterator_tag), it must support the prefix increment form, the! = Operator, the * operator and the -&gt; operator (I will not implement it, since the iterator is used for the int type in the example, and in this case operator-&gt; meaningless).  In addition, you need a constructor and copy constructor.  The example does not suppose the creation of an iterator except as the begin and end methods of the container class, therefore the iterator constructor will be private, and the container class will be declared as friendly.  And we add the operator ==, firstly it‚Äôs good practice to add support! = And == together, and secondly, BOOST_FOREACH will not work without it. <br><br>  const_iterator is not much different from the iterator, so we declare an iterator as a template class with one parameter ‚Äî the return type for the * and -&gt; operators. <br><br>  In the constructor we will pass a pointer to the array element stored in the OwnContainer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnIterator</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::input_iterator_tag, ValueType&gt; { <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnContainer</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: OwnIterator(ValueType* p); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OwnIterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OwnIterator &amp;it); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(OwnIterator <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(OwnIterator <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-comment"><span class="hljs-comment">//need for BOOST_FOREACH typename OwnIterator::reference operator*() const; OwnIterator&amp; operator++(); private: ValueType* p; };</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Implementing OwnIerator Methods</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; OwnIterator&lt;ValueType&gt;::OwnIterator(ValueType *p) : p(p) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; OwnIterator&lt;ValueType&gt;::OwnIterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OwnIterator&amp; it) : p(it.p) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> OwnIterator&lt;ValueType&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(OwnIterator <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p != other.p; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> OwnIterator&lt;ValueType&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(OwnIterator <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p == other.p; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OwnIterator&lt;ValueType&gt;::reference OwnIterator&lt;ValueType&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *p; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; OwnIterator&lt;ValueType&gt; &amp;OwnIterator&lt;ValueType&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { ++p; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br></div></div><br><br>  We could stop at this, but the boost library has a base class for creating iterators, and I want to say a few words about it. <br><br><h1>  Iterator inherited from boost :: iterator_facade </h1><br><br>  A container differs only in the types referenced by the iterator and const_iterator: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnContainerBBI</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> OwnIteratorBB&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> OwnIteratorBB&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; const_iterator; OwnContainerBBI(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; values); <span class="hljs-function"><span class="hljs-function">iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">const_iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">const_iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; data; };</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Implementing OwnContainerBBI Methods</b> <div class="spoiler_text"><pre> <code class="cpp hljs">OwnContainerBBI::OwnContainerBBI(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; values) : size(values.size()), data(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[size]) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(values.begin(), values.end(), data.get()); } OwnContainerBBI::iterator OwnContainerBBI::begin() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator(data.get()); } OwnContainerBBI::iterator OwnContainerBBI::end() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator(data.get() + size); } OwnContainerBBI::const_iterator OwnContainerBBI::begin() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> const_iterator(data.get()); } OwnContainerBBI::const_iterator OwnContainerBBI::end() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> const_iterator(data.get() + size); }</code> </pre><br></div></div><br><br>  The iterator is inherited from the template type boost :: iterator_facade.  This is a template class, the first parameter is the type of the heir, the second type of value, the third type of iterator.  The type used in std :: iterator and boost-specific (in the description this option is designated as old-style) can act as an iterator type, I will take the same type as for std :: iterator.  boost :: iterator_facade implements the necessary methods: operator *, operator ++, operator-&gt;, etc.  But their implementation is based on auxiliary methods that need to be implemented in our iterator, namely dereference, equal, increment, decrement, advance, distance.  In a simple case (like ours) only equal, increment and dereference will be required.  Since these methods are used to implement the iterator interface, we place them in the privat section, and use their class (boost :: iterator_core_access) to be declared friend. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnIteratorBB</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::iterator_facade&lt; OwnIteratorBB&lt;ValueType&gt;, ValueType, boost::single_pass_traversal_tag &gt; { <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnContainerBBI</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">boost</span></span></span><span class="hljs-class">:</span></span>:iterator_core_access; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: OwnIteratorBB(ValueType* p); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OwnIteratorBB(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OwnIteratorBB&amp; it); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OwnIteratorBB </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; it)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OwnIteratorBB::<span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ValueType* p; };</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Implementing OwnIteratorBB Methods</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; OwnIteratorBB&lt;ValueType&gt;::OwnIteratorBB(ValueType *p) : p(p) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; OwnIteratorBB&lt;ValueType&gt;::OwnIteratorBB(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OwnIteratorBB &amp;it) : p(it.p) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> OwnIteratorBB&lt;ValueType&gt;::equal(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OwnIteratorBB &amp;it) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p == it.p; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OwnIteratorBB&lt;ValueType&gt;::increment() { ++p; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OwnIteratorBB&lt;ValueType&gt;::reference OwnIteratorBB&lt;ValueType&gt;::dereference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *p; }</code> </pre><br></div></div><br><br><h1>  Conclusion </h1><br>  An iterator can be created and used without a container, and sometimes the container is not needed at all.  Iterators can serve as wrappers over other iterators and modify their behavior, for example, output items after one.  Or data is stored separately, and a container with some keys or field values ‚Äã‚Äãis stored separately.  And it is possible to organize an iterator that will be traversed over all the geels, but only return those that correspond to some condition based on the values ‚Äã‚Äãof the second container.  More ideas can be found in the article <a href="http://habrahabr.ru/post/122283/">Underrated iterators</a> written by <a href="http://habrahabr.ru/users/k06a/" class="user_link">k06a</a> . <br><br>  For simple iterators, the use of boost :: iterator_facade is not very relevant, but for more complex ones it can reduce the amount of code, of course, if the boost library is already in use, there is no sense in pulling it just for the sake of iterator_facade. <br><br><h1>  Links </h1><br>  1. <a href="http://en.cppreference.com/w/cpp/iterator">Description Iterator library at cppreference, com</a> . <br>  2. <a href="http://www.boost.org/doc/libs/1_59_0/libs/iterator/doc/iterator_facade.html">Description of boost :: iterator_facade</a> <br>  3. A <a href="https://github.com/hokum2004/OwnIterator">repository with an example on github</a> .  The project uses Qt5 (for tests), since boost is used, then you need to declare the BOOST environment variable with the directory path with boost. </div><p>Source: <a href="https://habr.com/ru/post/265491/">https://habr.com/ru/post/265491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265481/index.html">How company executives understand what is happening in the data center</a></li>
<li><a href="../265483/index.html">Using Microsoft Azure for scalability and resiliency of the CloudStats.me project</a></li>
<li><a href="../265485/index.html">Features of the xPDOObject :: save () + Transaction Method</a></li>
<li><a href="../265487/index.html">Why gaming performance is not just average FPS</a></li>
<li><a href="../265489/index.html">Co-clustering: Segmentation of data along and across</a></li>
<li><a href="../265495/index.html">Corporate immunity: we create a system of centralized management of network security in the company and its branches</a></li>
<li><a href="../265497/index.html">Telegram-like animated placeholder for HTML inputs</a></li>
<li><a href="../265499/index.html">Unstructured data analysis and storage optimization</a></li>
<li><a href="../265501/index.html">Creating a test DB context in tests using xUnit</a></li>
<li><a href="../265503/index.html">Motivational tale for indie game developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>