<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize the Android game mTricks Looting Crown for the Intel Atom platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The most popular category of mobile apps is games. In the old days, the capabilities of processors and graphic accelerators of portable devices were v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize the Android game mTricks Looting Crown for the Intel Atom platform</h1><div class="post__text post__text-html js-mediator-article">  The most popular category of mobile apps is games.  In the old days, the capabilities of processors and graphic accelerators of portable devices were very limited, which affected their performance.  As a result, most of the games had to be made fairly simple.  Today, the computing power of smartphones and tablets has grown significantly, which means that it has become possible to create high-quality, resource-intensive games.  However, mobile CPUs and GPUs are still inferior to those installed in personal computers. <br><br>  The growth of the mobile application market has led many PC game manufacturers to create games for mobile platforms.  However, traditional approaches to designing games do not work well in a mobile environment.  The same applies to the graphics resources of PC games, which are too ‚Äúheavy‚Äù for mobile hardware. <br><br> <a href="http://habrahabr.ru/company/intel/blog/264511/"><img src="https://habrastorage.org/files/363/a75/cd0/363a75cd06c04121816a05e27cb69cf4.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, you will learn how to analyze and improve mobile game performance and how to optimize graphics resources for mobile platforms. <br><a name="habracut"></a><br>  All this we consider the example of the game mTricks Looting Crown.  IA-version of the game has already been published, <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.barunsonena.looting">here is a link to it</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/574/da7/115/574da7115a4426b1a526261ea2feec96.jpg"><br>  <i><font color="#999999">Game mTricks Looting Crown.</font></i> <br><br><h2>  <font color="#0071c5">1. Preliminary information</font> </h2><br>  The company mTricks has extensive experience in the development of computer games using various commercial engines.  Planning the next project, the company's experts, given the growth in mobile device performance, predicted the readiness of the mobile market for complex MMORPGs.  As a result, the company has aimed its new project at mobile platforms, and not at ordinary computers. <br><br>  For starters, mTricks transferred its PC-based experience to Android.  However, the performance of the solution left much to be desired.  In particular, one of the hardware platforms on which the development was oriented was devices based on Intel Atom (Bay Trail) processors. <br><br>  The mTricks company faced two problems that usually arise before PC developers moving on to the creation of mobile applications. <br><br><ol><li>  PC-based graphics resources and design approaches are not suitable for mobile applications.  The thing is that mobile processors and video cards are still lagging behind similar components of personal computers. <br><br></li><li>  Mobile devices create on the basis of a wide range of components that have different characteristics.  This includes the computational capabilities of the CPU and GPU, the amount of RAM, and the screen size.  As a result, various resources are available to the various target platforms, which affects the appearance and performance of the application. <br></li></ol><br><h2>  <font color="#0071c5">2. The main provisions</font> </h2><br>  Looting Crown is the so-called SNRPG (Social Network + RPG), that is, a role-playing game with social network functions.  It supports three-dimensional graphics and various multiplayer game modes (PvP, PvE, Clan vs Clan).  In developing and optimizing the game, mTricks used a reference device built on the Bay Trail platform.  Below are the technical specifications of this device. <br><br>  <b>Device characteristics and test results</b> <br><table><tbody><tr><td>  Indicator </td><td>  Characteristic of the device (screen diagonal - 10 inches) </td></tr><tr><td>  CPU </td><td>  Intel Atom Quad Core 1.46 Ghz </td></tr><tr><td>  Ram </td><td>  2Gb </td></tr><tr><td>  Screen resolution </td><td>  2560 x 1440 </td></tr><tr><td>  Points in the test 3DMark ICE Storm Unlimited </td><td>  15094 </td></tr><tr><td>  Graphics test </td><td>  13928 </td></tr><tr><td>  Physical effects test </td><td>  21348 </td></tr></tbody></table><br>  The company mTricks in the development of the game used Intel Graphics Performance Analyzers (Intel GPA) to find bottlenecks in the CPU and GPU.  The results of the analysis were used to solve problems with graphic resources and performance. <br><br>  The reference point from which the optimization and performance analysis was started was 23 frames per second (FPS, Frame per Second).  Below are the graphics core loading characteristics (GPU Busy) and processor load statistics generated by the application (Target App CPU Load).  Data received in 2 minutes of the application.  The average load of the graphics core was 91%.  The load on the processor was about 27%. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17e/ecf/e28/17eecfe2876799eab65be54cea766fb9.png"><br>  <i><font color="#999999">The reference point for measuring the load on the processor and graphics core.</font></i>  <i><font color="#999999">Data obtained using Intel GPA System Analyzer.</font></i> <br><br><h2>  <font color="#0071c5">3. Who is to blame, the processor or video core?</font> </h2><br>  There are two ways to find out what exactly is the bottleneck of the system: CPU or GPU.  One of them is to use override modes.  The second implies a change in the CPU clock frequency. <br><br>  One of the bypass modes provided in the Intel GPA System Analyzer is Disable Draw Calls mode.  It helps to understand whether the processor or video core is the bottleneck of the system.  After testing in this mode, it is necessary to compare the results obtained with those obtained in the standard state of the system.  The following table will help to interpret these results. <br><br>  <b>How to analyze games using the bypass mode Disable Draw Calls</b> <br><table><tbody><tr><td width="200">  Performance Change in Disable Draw Call Mode </td><td>  Interpretation </td></tr><tr><td>  FPS changes slightly </td><td>  The speed of the game is tied to CPU performance.  Use the tools of the Intel GPA Platform Analyzer or the Intel VTune Amplifier to find out which functions are the most stressful for the system. </td></tr><tr><td>  FPS is noticeably improving </td><td>  The speed of the game is tied to the performance of the GPU.  Use the Intel GPA Frame Analyzer to find out which requests for image output take the most time. <br></td></tr></tbody></table><br>  Intel GPA System Analyzer allows you to explore the performance of an application with different CPU settings.  This is very useful in finding bottlenecks.  In order to determine whether the game's performance is tied to the CPU, you need to do the following: <br><br><ol><li>  Make sure that the frame rate of your application is not tied to vertical sync (Vertical Sync, Vsync).  To do this, take a look at the Intel GPA System Analyzer notification bar.  If this mode is enabled, you will see the word Vsync highlighted in gray: <img src="https://habrastorage.org/getpro/habr/post_images/e84/216/019/e8421601940b7ee9e08a033a77c9c595.jpg"><br><br></li><li>  Try setting different CPU frequencies using the sliders on the Platform Settings panel in the Intel GPA System Analyzer window.  If the FPS changes as the processor frequency changes, it‚Äôs very likely that the application‚Äôs performance is tied to the CPU <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/a35/931/389/a35931389e437d97750096d823cd248d.png"><br>  <i><font color="#999999">Modification of the processor frequency in the Platform Settings panel.</font></i> <br><br>  The following table shows the results of experiments with Looting Crown.  In Disable Draw Calls mode, the frame rate does not change.  This leads to the conclusion that the performance of the game is tied to the CPU.  However, when setting the maximum possible processor frequency (Highest CPU Frequency mode), the FPS also does not change.  This, in turn, suggests that the performance of the Looting Crown is tied to the video core.  In order to resolve this contradiction, we must return to the reference point of measurement, to the data on the load on the processor and video core, which we cited above.  Namely, we see that on the reference device built on the Bay Trail platform, the video core is loaded by 91%, and the processor - by 27%.  As a result, the processor cannot reach its full potential as long as the video chip runs at its limit.  The GPU, in our case, is the bottleneck of the system.  Therefore, for a start, we will start optimizing the use of the video core, after which we will repeat testing. <br><br>  <b>FPS measurement results in various modes</b> <br><table><tbody><tr><td>  Mode </td><td>  FPS </td></tr><tr><td>  Usual </td><td>  23 </td></tr><tr><td>  Disable Draw Calls </td><td>  23 </td></tr><tr><td>  Highest CPU Frequency </td><td>  23 </td></tr></tbody></table><br><h2>  <font color="#0071c5">4. Search for GPU bottlenecks</font> </h2><br>  As already mentioned, we found out that the bottleneck of the game is in the GPU.  Let's analyze the situation with the help of Intel GPA Frame Analyzer.  Here is the frame information for the reference measurement point. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14a/b2f/65d/14ab2f65d41fe2263bc2d39915461e0d.png"><br>  <i><font color="#999999">View data using Intel GPA Frame Analyzer.</font></i> <br><br><h2>  <font color="#0071c5">4.1.</font>  <font color="#0071c5">Reducing the number of calls to the paint function</font> </h2><br>  We reduced the number of calls to the drawing function by combining hundreds of static grids into one and applying larger textures. <br><br>  Consider the performance before optimization and after.  In measurements, we use a unit of measurement called erg (erg).  Erg is a command that performs some work on the graphics core during frame output.  For example, ergs are functions of drawing, cleaning, other calls to the graphic API. <br><br>  <b>Reference Measurement Indicators</b> <br><table><tbody><tr><td>  Indicator </td><td>  Value </td></tr><tr><td>  Total number of ergs </td><td>  1726 </td></tr><tr><td>  Total number of primitives </td><td>  122204 </td></tr><tr><td>  GPU duration, ms </td><td>  23 </td></tr><tr><td>  The time required to display the frame, ms </td><td>  48 </td></tr></tbody></table><br>  <b>Estimated cost of displaying the image for the reference point of measurement</b> <br><table><tbody><tr><td>  Type of transaction </td><td>  Number of ergs </td><td>  Time, ms </td><td>  % </td></tr><tr><td>  Cleaning </td><td>  0 </td><td>  0.2 </td><td>  0.5 </td></tr><tr><td>  Ocean </td><td>  one </td><td>  6 </td><td>  13.7 </td></tr><tr><td>  Terrain <br></td><td>  2 ~ 977 <br></td><td>  20 <br></td><td>  41.9 <br></td></tr><tr><td>  Grass <br></td><td>  19 ~ 977 <br></td><td>  18 <br></td><td>  39.0 <br></td></tr><tr><td>  Character, buildings, effects <br></td><td>  978 ~ 1676 <br></td><td>  nineteen <br></td><td>  40.6 <br></td></tr><tr><td>  User interface <br></td><td>  1677 ~ 1725 <br></td><td>  one <br></td><td>  3.4 <br></td></tr></tbody></table><br>  The total time of the ‚ÄúTerrain‚Äù output is 20 ms, while on the ‚ÄúGrass‚Äù, with which this ‚ÄúTerrain‚Äù is overgrown, is 18 ms.  This is about 90% of the time required to process the ‚ÄúEarth‚Äù.  Therefore, we continue the analysis in order to understand why the conclusion of the ‚ÄúGrass‚Äù takes so much time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa5/458/bec/fa5458bec8ae7a369a2305b8ca800e75.png"><br>  <i><font color="#999999">The process of building "terrain".</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e8/d77/2e5/4e8d772e5665cbd4663c80822e28a7b3.png"><br>  <i><font color="#999999">Texture "Grass".</font></i> <br><br>  Looting Crown fills most of the "land" with small squares of "grass."  As a result, the number of calls to the drawing function in the ‚ÄúTerrain‚Äù column (in the table below) is 960. The time for drawing one such fragment is very small.  However, the output of all fragments overload the system.  A relatively simple operation consumes an unreasonably large amount of resources.  Therefore, we stopped at the need to reduce the number of calls to the drawing function by combining several hundred static grids into one.  In addition, we decided to use a larger texture.  Here is what happened after this optimization: <br><br>  <b>Comparing the cost of image output when using small and large textures</b> <br><table><tbody><tr><td>  Indicator </td><td>  Value </td></tr><tr><td>  Small texture, ms. </td><td>  18 </td></tr><tr><td>  Number of ergs </td><td>  960 </td></tr><tr><td>  Large texture, ms. </td><td>  6 </td></tr><tr><td>  Number of ergs </td><td>  one </td></tr></tbody></table><br><img src="https://habrastorage.org/getpro/habr/post_images/06b/e66/18c/06be6618cfe012db7b6127bf8c199052.png"><br>  <i><font color="#999999">Changed "Terrain".</font></i> <br><br>  The derivation of a ‚Äúterrain‚Äù consisting of small-sized textures requires a large number of drawing function calls.  Therefore, we have reduced the number of such calls and saved 12 milliseconds at the conclusion of the ‚Äúgrass‚Äù. <br><br><h2>  <font color="#0071c5">4.2.</font>  <font color="#0071c5">Graphics resource optimization</font> </h2><br>  Here are the results obtained when using a large texture for ‚ÄúGrass‚Äù. <br><br>  <b>Performance data obtained after the first optimization</b> <br><table><tbody><tr><td>  Indicator </td><td>  Value </td></tr><tr><td>  Total number of ergs </td><td>  179 </td></tr><tr><td>  Total number of primitives </td><td> 27537 </td></tr><tr><td>  The duration of the GPU, ms. </td><td>  24 </td></tr><tr><td>  The time required to display the frame, ms. </td><td>  27 </td></tr></tbody></table><br>  <b>Estimating the cost of displaying the image after the first optimization</b> <br><table><tbody><tr><td>  Type of transaction </td><td>  Number of ergs </td><td>  Time, ms </td><td>  % </td></tr><tr><td>  Cleaning </td><td>  0 </td><td>  2 </td><td>  10.4 </td></tr><tr><td>  Ocean <br></td><td>  18 <br></td><td>  6 <br></td><td>  23.6 <br></td></tr><tr><td>  Terrain <br></td><td>  1 ~ 17, 19, 23 ~ 96 <br></td><td>  14 <br></td><td>  53.4 <br></td></tr><tr><td>  Grass <br></td><td>  nineteen <br></td><td>  6 <br></td><td>  23.2 <br></td></tr><tr><td>  Character, buildings, effects <br></td><td>  20 ~ 22, 97 ~ 131 <br></td><td>  one <br></td><td>  5.9 <br></td></tr><tr><td>  User interface <br></td><td>  132 ~ 178 <br></td><td>  one <br></td><td>  5.7 <br></td></tr></tbody></table><br>  After the first pass of optimization, we again checked whether the performance of the game is tied to the GPU.  The same measurements as before were performed in the Disable Draw Calls and Highest CPU Frequency modes. <br><br>  <b>FPS measurement results after the first optimization</b> <br><table><tbody><tr><td>  Mode <br></td><td>  FPS <br></td></tr><tr><td>  Usual <br></td><td>  40 <br></td></tr><tr><td>  Disable Draw Calls <br></td><td>  60 <br></td></tr><tr><td>  Highest CPU Frequency <br></td><td>  40 <br></td></tr></tbody></table><br>  The table shows that when the drawing functions are disabled, the FPS grows, and when setting the maximum processor frequency, it does not change.  This suggests that the performance of Looting Crown is still tied to the graphics core.  In addition, we again checked the load that the game creates on the CPU and GPU. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/de8/68b/932de868bf1239e6dad661d20acf8d8c.png"><br>  <i><font color="#999999">The load on the processor and the graphics core after the first optimization.</font></i>  <i><font color="#999999">Data obtained using Intel GPA System Analyzer.</font></i> <br><br>  Here you can see that on the reference system built on the Bay Trail platform, the processor load is about 13%, while the graphics core is loaded at 99%.  Thus, the optimization regarding the use of the CPU will not increase the performance of the game until we figure out how to overload the video core. <br><br>  Looting Crown was originally created for the PC.  Its graphics resources are not suitable for mobile devices that have less powerful CPUs and GPUs than desktop devices.  Therefore, we have subjected the graphic resources of a series of optimizations. <br><br>  <b>1.</b> Minimizing Draw Calls <br><br>  From 10 to 2 reduced the number of materials objects. <br>  Reduced the number of layers of particles. <br><br>  <b>2.</b> Reduced the number of polygons <br><br>  With the help of Simplygon reduced the level of detail (LOD, Level Of Details) characters. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/017/efb/423/017efb423dbd43b86a47713e589c1b43.png"><br>  <i><font color="#999999">Character at different stages of reducing the level of detail.</font></i> <br><br>  The number of polygons used to display "terrain" has been reduced.  To begin with, we reduced the detail of the mountains, which are located far away and do not require high detail.  Then they reduced the number of polygons for a flat "earth", for which modeling a pair of triangles is enough. <br><br>  <b>3.</b> Optimized lighting maps used. <br><br>  Disable dynamic lighting for "Time of Day." <br>  The size of the irradiance map for each of the grids is minimized, in particular, for the background. <br><br>  <b>4.</b> Minimized change in the state of rendering elements. <br><br>  Reduced the number of materials, which reduced the number of changes in the state of rendering elements and changes in textures. <br><br>  <b>5.</b> Separated animated parts of static grids. <br><br>  The Havoc engine that was used to create the game does not support updating only the area of ‚Äã‚Äãthe object that is being animated.  If the object has only a small part of it, then it is, all the same, updated entirely.  In order to cope with this, we separated the moving parts (smoke, highlighted by a red circle in the following figure) from the fixed part of the objects.  The result was two separate models of game objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd3/983/1a1/cd39831a15f8c51dbf63767a96919fd2.jpg"><br>  <i><font color="#999999">Separating animated smoke from a static grid.</font></i> <br><br><h2>  <font color="#0071c5">4.3.</font>  <font color="#0071c5">Effective Z-clipping application</font> </h2><br>  When a 3D video card displays objects, a three-dimensional scene (the points at which have x, y, z coordinates) is projected onto a plane (transition to the x, y coordinate model).  In order to save information about the depth of each pixel (that is, the z-coordinate data), a so-called Z-buffer or depth buffer is used.  If at the same point of the plane you need to display two three-dimensional objects, the GPU compares the data by the depths of these objects.  The video core will overwrite the current pixel if the new object is closer to the observer than the previous one.  Thus, the use of Z-buffer allows you to correctly reproduce the usual depth of space.  Z-clipping technique (Z-culling) consists in the fact that at first those objects that are located closer are drawn, they overlap distant objects, which are not necessary to be drawn only in order to ‚Äúpaint over‚Äù later.  Z-clipping can improve performance when rendering hidden surfaces. <br><br>  In Looting Crown, part of the terrain is covered by the ocean, and part by grass.  Most of the ocean is behind the grass, that is, these areas are hidden.  However, the ocean is derived earlier than grass, which does not effectively apply Z-clipping.  Below are the data from the analysis of the operating time of the GPU at the conclusion of the ocean and grass.  Drawing on the ocean requires 18 ergs, on the grass - 19. If the grass was displayed before the ocean, then, since it is located closer to the viewer, most of the pixels of the ocean simply would not need to be displayed.  This would lead to a decrease in the time it takes the GPU to draw objects.  After the second optimization, as shown in the corresponding figure, the operating time of the GPU during the output of the ocean decreased from 6 ms.  up to 0.3 ms <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a31/062/477/a31062477e73a48d19dd301250da9442.png"><br>  <i><font color="#999999">The cost of drawing the ocean after the first optimization.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ce/dc7/822/1cedc782216cc38de5b11056941c048a.png"><br>  <i><font color="#999999">The cost of drawing grass after the first optimization.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca4/b2b/45c/ca4b2b45c26ce7ff3e40c3aacf5e7465.png"><br>  <i><font color="#999999">The cost of drawing the ocean after the second optimization.</font></i> <br><br><h2>  <font color="#0071c5">results</font> </h2><br>  By taking the steps above, mTricks has optimized all graphics resources for mobile devices.  At the same time managed to maintain a high level of quality.  The number of ergs was reduced from 1726 to 124. The number of primitives decreased from 122204 to 9525. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f60/b4e/5d7/f60b4e5d70f31570cd3e0263440d93c9.jpg"><br>  <i><font color="#999999">Changes in graphic resources.</font></i> <br><br>  Below are the optimization results.  So, after all the improvements, the FPS index changed from 23 to 60 frames per second on a device built on the Bay Trail platform. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/ec4/dfb/e5fec4dfb038c6d5675be8b132c6bda8.png"><br>  <i><font color="#999999">Increased FPS during optimization.</font></i> <br><br>  <b>Change FPS, load on GPU and CPU</b> <br><table><tbody><tr><td>  Indicator <br></td><td>  Reference point <br></td><td>  First optimization <br></td><td>  Second optimization <br></td></tr><tr><td>  FPS <br></td><td>  23 <br></td><td>  45 <br></td><td>  60 <br></td></tr><tr><td>  Download GPU,% <br></td><td>  91 <br></td><td>  99 <br></td><td>  71 <br></td></tr><tr><td>  CPU load,% <br></td><td>  27 <br></td><td>  13 <br></td><td>  22 <br></td></tr></tbody></table><br>  After the first optimization, the analysis of the game on the Bay Trail device showed that its performance is still tied to the GPU.  The purpose of the second optimization was to reduce the load on the graphics core due to optimization of graphics resources and more efficient use of the Z-buffer.  As a result, we managed to achieve 60 frames per second.  Since Android uses Vsync, 60 FPS is the maximum that is achievable on this platform. <br><br><h2>  <font color="#0071c5">Getting Started with Intel Graphics Frame Analyzer for OpenGL</font> </h2><br>  If you want to analyze your own Android application using Intel tools, you will need the appropriate tools.  In particular, a full-fledged working environment for creating and analyzing Android applications can be organized using <a href="https://software.intel.com/en-us/intel-inde">Intel INDE</a> and <a href="https://software.intel.com/en-us/gpa">Intel GPA</a> .  Intel GPA can be installed either independently or with the INDE installation. <br><br>  When booting Intel GPA, you need to select a file that matches your work environment and the platform on which you plan to do graphics research.  In our case, provided that Windows is used as the OS of the computer on which the development is being performed, the <i>Windows 7 / 8.1 (x64) Graphics Frame Analyzer for OpenGL</i> package is selected. <br><br>  Let's see how to start analyzing applications using the Intel Graphics Frame Analyzer for OpenGL.  Before carrying out the analysis, you need to prepare the application accordingly.  Namely, in the AndroidManifest.xml file, you need to enter the following permission: <br><br><pre><code class="hljs pgsql">&lt;uses-permission android:<span class="hljs-type"><span class="hljs-type">name</span></span>="android.permission.INTERNET" /&gt;</code> </pre> <br>  Also, in the <i>&lt;application&gt;</i> section of this file, you need to enable the debugging feature of the application: <br><br><pre> <code class="hljs xml">   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">       </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:debuggable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">  &gt;</span></span></code> </pre> <br>  Without such preparation, even if you install a debug-version of the application on your device, the Graphics Frame Analyzer will not be able to work with it.  In addition, it is important that the device is determined by ADB. <br><br>  Once the application is installed on an Android device, you can run the Graphics Frame Analyzer for OpenGL.  If you see a mobile device connected to a computer in the title of the application window, then everything has been done correctly up to this point.  Now you can use the Add button, which is located in the working area of ‚Äã‚Äãthe window. <br><br>  The Graphics Frame Analyzer will perform a device analysis and, in the Analyzable applications section, show a list of applications that can be analyzed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa7/f09/672/fa7f09672fbb84a30ff316798ba278bb.png"><br>  <i><font color="#999999">List of applications received from the device.</font></i> <br><br>  In our case, the tablet is Asus Fonepad 8 with an Intel Atom Z3530 CPU.  Android 5.0 is installed on the device. <br><br>  The list contains an application example of working with OpenGL, which is prepared as stated above.  The original application can be found <a href="http://developer.android.com/training/graphics/opengl/index.html">here</a> .  In addition, you can download a <a href="http://rghost.ru/7d8NsWbzf">project</a> in which all the necessary settings are made. <br><br>  After double-clicking on the application icon in the left part of the program window, the Capture button will appear.  After clicking on this button, the application data will be captured and a thumbnail will appear in the right-hand part of the window, corresponding to the application screen.  Clicking on this thumbnail opens the page with a list of the results of previous tests.  On this page, click on the desired icon - and we get to the window, where the results of the analysis are presented. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b5/12e/7bd/1b512e7bdbfb1e08da2dd8c062f5fe06.png"><br>  <i><font color="#999999">Analysis results window.</font></i> <br><br><h2>  <font color="#0071c5">findings</font> </h2><br>  Starting to optimize the game, first determine the bottlenecks.  Intel GPA is able to help in this matter.  It gives the developer powerful analytical tools.  If game performance is tied to a CPU, valuable information can be obtained using the Intel VTune Amplifier.  If the performance of the game "rests" in the possibility of a GPU, you can search for bottlenecks using Intel GPA. <br><br>  In order to fix the problems of the game, tied to the GPU, it is worthwhile to look for effective ways to reduce calls to the drawing function, the number of polygons, changes in the state of the rendering elements.  In addition, you can check the dimensions of the terrain textures, the animation of objects, the irradiance maps, find out whether the work with the Z-buffer is organized properly. </div><p>Source: <a href="https://habr.com/ru/post/264511/">https://habr.com/ru/post/264511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264497/index.html">Video from LoveQA mitap</a></li>
<li><a href="../264499/index.html">Online Programming Programming Basics</a></li>
<li><a href="../264501/index.html">Zabbix - welcome to listen</a></li>
<li><a href="../264503/index.html">Features of the DNS resolver in Windows 10 and DNS Leak</a></li>
<li><a href="../264505/index.html">Managing dependency versions in the Maven project</a></li>
<li><a href="../264513/index.html">Writing a program to steal data from a USB-drive in Windows</a></li>
<li><a href="../264515/index.html">Updating Linux on a device based on the Altera SoC FPGA chip and gaining access to shared Windows server resources</a></li>
<li><a href="../264517/index.html">The notorious programmer: life hacking firsthand</a></li>
<li><a href="../264519/index.html">Tutorial: Interactive SVG Cartogram Component for InstantCMS 2</a></li>
<li><a href="../264521/index.html">Treacherous router or why ports need to open</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>