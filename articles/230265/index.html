<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tugging a Camel or integration with Camel. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story of one project. 

 Have you ever dreamed of camels? So I don't either. But when you work with Camel for the third year, not only camels begi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tugging a Camel or integration with Camel. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h2>  The story of one project. </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/264/939/7d9/2649397d9f610b4e8dbe950f50fcb53d.jpg" width="456" height="333" align="left"><br>  Have you ever dreamed of camels?  So I don't either.  But when you work with Camel for the third year, not only camels begin to dream. <br>  In general, I will share my experience, write about camels and teach you how to cook them.  This is a series of articles in three parts: the first part will be for those who are interested in stories and torments of creativity;  the second is more technical, about integration patterns, their application, and the third part is about errors and debugging. <br>  If you need to combine your services, here you will find out why Camel is good.  If you want to learn how to use something new, here we start with the basics.  If you like the stories and the original chips that are in each team, then read on. <br><a name="habracut"></a><br><br clear="all"><br clear="all"><h3>  Integration task </h3><br>  To begin with, there was a need for a service bus.  We are developing a large system that affectionately ‚Äúbehind the eyes‚Äù was called a monster.  The monster turned out to be big and scary, but in reality it was one of the <a href="http://en.wikipedia.org/wiki/Business_process_management">BPM</a> systems (business process managment system).  It all started a few years ago.  Once at a meeting, the project manager started talking about future plans: <br>  - Colleagues, in the near future we plan to integrate with a large number of internal and external systems.  Now we need to work out a systematic approach so that our analysts can start preparing tasks. <br><br>  Then for some time he talked about the systems with which we have to integrate.  There were both external well-known systems, for example, elibrary.ru, and internal ones that were yet to be created.  At the end of the story, characteristic features of integration with different types of systems were identified.  For external systems, this is a big uncertainty in the description of the processes and objects of the subject area (business objects) that were to be exchanged;  but it was clear the direction of data transmission (loading or unloading);  Additional requirements for the protection of data transmission channels, ensuring guaranteed delivery and prerequisites for creating tools for correcting erroneous data were reviewed.  For the second - the internal systems, there was more clarity.  Clearly described the functional purpose of each of the systems.  Due to this, it was possible to work out the range of objects to be transferred.  That's just for these systems, the uncertainty manifested itself at the level we will - we will not, we will have time - we will not have time to implement.  Without going into the details of the application area, I will limit myself to typical tasks that we have focused on. <br><ol><li>  It is necessary to download information to the main system using a standard protocol.  At the time of discussion for the external systems two were mentioned: HTTP, ftp;  for internal: JMS, HTTP, NFS, SMB and / or using the RMI interface.  What architecture could we use to solve this problem? </li><li>  Suppose you need to upload information from the main system and transfer it to an external system using one of the standard protocols.  What could be the ways to solve this problem? </li><li>  Or it is required to transfer one, two, n business objects.  How could we prepare the data and what format to use? </li><li>  Suppose you need to send an email through an email server that is temporarily unavailable.  To do this, the user will need to either wait for the availability of the latter, or receive a message about the inability to finish his work now.  How could we build a system that guarantees delivery and does not block user work? </li><li>  We assume that we need to be able to take information from the external system at 1 or 3 am, but our system at that time interrupted its work for maintenance.  How to make it so that during the non-availability of the main system the processes of unloading and loading of data do not stop? </li><li>  And the last task: you must be able to quickly change the login and password to access the external system or the communication protocol from ftp to sftp.  How could we make it so that the settings can be changed flexibly without disrupting the operation of the main system? </li></ol><br>  After discussing the problem, we came to the decision to create a standalone application that will connect the main system with others.  The idea of ‚Äã‚Äãusing an intermediate link is not new and is known in the world of integration as the <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BF%25D1%2580%25D0%25B8%25D1%258F%25D1%2582%25D0%25B8%25D1%258F">service bus of an enterprise</a> or an ESB.  Let's outline the range of functionality that our application should have.  The basis for the formulation of tasks.  It should be able to: <br><ul><li>  interact with other systems using standard protocols: HTTP, FTP, as well as using the <a href="http://ru.wikipedia.org/wiki/Java_Message_Service">JMS</a> protocol or using the <a href="http://ru.wikipedia.org/wiki/RMI">RMI</a> interface. </li><li>  read, write and create files in the local file system to work with NFS </li><li>  send emails via SMTP server. </li><li>  parse one of the transport formats XML, JSON </li><li>  have a flexible setting </li><li>  to be able to describe the rules for the harmonization of formats in one of the Java programming languages, Groovy.  We worked with these languages, so we could count on the absence of additional overhead to study. </li><li>  the ability to work with XSLT and xPath would be an added plus. </li></ul><br><br><h3>  From reasoning to practice </h3><br>  After some time, when the search process only gained momentum, analysts, at the request of the client, wrote the first statement: <br>  - Guys, we wrote the play here, we need to do it quickly.  The customer was waiting for her yesterday, so try. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It happens so often with us, but we always have time to make new functionality in time.  This time is no exception, we were waiting for a large amount of work and short deadlines for implementation.  Although we could not use a service bus for this production, we used the formulation as the first practical task for creating a prototype. <br><br>  In the meantime, we had to choose the technologies on which our prototype was to be built.  To invent your bicycle and start from scratch is great, but too expensive.  Proprietary solutions also did not use because the result was needed quickly, but it takes time to agree and resolve financial issues.  Therefore, turned to opensource projects.  At that time, the choice was small, so they could appreciate the merits of the ‚Äúcamel‚Äù at a glance. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfe/6b5/f2d/bfe6b5f2d5a20893a6d769bba31b7ec2.jpg"></div><br>  As can be seen from the diagram, Apache Camel is a modular, easily extensible framework for integrating applications.  The main structural elements: component model, routing mechanism, message processing mechanism.  A component model is a collection of factories that create routing endpoints.  For example, an endpoint may be an abstraction sending messages to a broker JMS queue.  A routing mechanism associates endpoints with message processing abstractions.  The latter, a message processing mechanism, allows you to manipulate message data.  For example, convert to a different format, validate, add new content, log and more.  All three architectural components are modular, and thanks to this, Camel‚Äôs capabilities are constantly expanding.  You can get acquainted with the architecture in detail in <a href="http://ru.wikipedia.org/wiki/Apache_Camel">Wikipedia</a> and on the <a href="http://camel.apache.org/user-guide.html">official site</a> .  Only having appeared, Apache Camel got a solid collection of components.  There were components to satisfy all our requirements: JMS, HTTP, ftp, file, SMTP, xPath, xslt, XStream, Groovy, Java.  Like the author of <a href="http://java.dzone.com/articles/which-integration-framework">Which Integration Framework Should You Use - Spring Integration, Mule ESB or Apache Camel?</a>  , we chose Camel.  This article compares three frameworks: Spring Integration, Mule ESB and Apache Camel.  The key advantage the author describes as follows: <blockquote>  ... Apache Camel due to its awesome Java, Groovy and Scala DSLs, combined with many supported technologies. </blockquote>  The ability to use <i>fluent Java DSL</i> instead of ‚Äúclumsy‚Äù XML has become a big advantage for us.  The question arises: what is clumsiness?  XML is a great markup language, but JSON or YAML have long preferred it.  They are preferred because of simplicity, better readability, fewer supporting information and simpler parsing algorithms.  Programming languages ‚Äã‚Äãsuch as Java, Groovy, Scala have full support for modern IDEs, which means that unlike XML, debugging and refactoring are possible.  Camel had no doubts, and he formed the basis of our service tire.  The fact that this project was used by <a href="http://camel.apache.org/commercial-camel-offerings.html">other companies</a> added confidence in the right choice. <br>  The main question that remained was how to integrate Camel into our monsters. <br><br><h3>  Flour choice: JMS vs. RMI. </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/0a4/411/a6b0a44115bb44672c4889cd1f0fd7e7.png"></div><br>  The integration of the service bus and our monster could be implemented using one of the many components supported by Camel.  Based on the tasks outlined above, we have formed the requirements: the connection must be stable and guarantee the delivery of messages.  We stopped at three options: the first two were synchronous RMI and HTTP, and one asynchronous JMS.  Of the three, we focused on the two simplest variants suitable for our Java projects: JMS, RMI.  JMS (Java message service) is a standard for sending messages, it regulates the rules for sending, receiving, creating and viewing messages.  Second, RMI (Remote Method Invocation) is a remote procedure call programming interface; it allows calling methods of one JVM in the context of another.  The standard remote call procedure involves wrapping Java objects and passing.  In fairness, it is worth noting that opposing JMS and RMI is not correct because JMS can be a transport and an integral part of RMI.  We contrast the standard RMI implementation with the JMS implementation ActiveMQ.  Previously, we used RMI to integrate two applications.  Why was he chosen then?  When both applications are in Java, there is nothing simpler than RMI.  In order to use it, it is enough to describe the interface and register an object that implements this interface.  But we had the opportunity to solve problems that arise with RMI when transferring a large amount of data between applications: memory was clogged up, and applications ‚Äúadded‚Äù.  We looked for ways to solve this problem and discussed it with JavaOne JVM developers.  It turned out that the garbage collectors in the virtual machine and the distributed collectors are different things.  Everything rested on the fact that for the standard garbage collector it was possible to choose its type and adjust the optimal parameters, but for the distributed such possibility was not.  If we talk about other differences, RMI limited integration to applications running on the JVM, but JMS did not.  In addition to the difficulties described, there was a desire to learn something new: to abandon RMI and use an alternative solution. <br><br><h3>  Camel's first prototype </h3><br>  Let's go back to prototype creation.  The first practical task for the service bus was this: the user initiates the process of uploading data, the system prepares them and sends them to the service bus.  All the work of data delivery falls on her.  The figure is an example of a problem statement in the symbols of enterprise application integration patterns (EIP). <br><img src="https://habrastorage.org/getpro/habr/post_images/e69/c66/8ca/e69c668caf2bea57d668f5d61b4776fe.png"><br>  The service bus combines the reception of messages from the JMS channel, their conversion and sending via HTTP.  The JMS channel and the message channel in HTML format marked in the figure were supposed to be implemented using Camel‚Äôs JMS and Jetty components.  The data transformation process could be implemented in Java and / or use template engines, such as, for example, VM (Apache Velocity).  The proposed data transfer scheme is implemented in Java DSL in one line.  Example: <br><pre><code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"jms:queue:se.export"</span></span>) .setHeader(Exchange.HTTP_METHOD,constant(org.apache.camel.component.http.HttpMethods.POST)) .process( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JmsToHttpMessageConvertor() ) .inOnly(<span class="hljs-string"><span class="hljs-string">"jetty:{{externalsystem.uri}}"</span></span>);</code> </pre> <br>  The example above shows the Java DSL route.  A route is a description of the message route.  In Camel, descriptions can be of two types: Java DSL and XML DSL.  Characteristics of such a route are the starting point and one or more endpoints designated by the from and to tokens, respectively.  The route describes the message path from the start to the end point.  If the end points are specified sequentially, the message will be transmitted to the first one, the service bus will wait for a response, which will then be sent to the next point.  There may be routes that select the desired endpoint ( <a href="http://camel.apache.org/dynamic-router.html">Dynamic Router</a> ) or send a message to several points at once ( <a href="http://camel.apache.org/recipient-list.html">Recipient List</a> ).  The from and to tokens parameter is a string with a URI.  A URI is a triple of parameters, consisting of the name of the Camel component, a resource identifier, and connection parameters.  Let's take an example: <br><pre> <code class="java hljs">from(‚Äújms:queue:se.export?timeToLife=<span class="hljs-number"><span class="hljs-number">10000</span></span>‚Äù)</code> </pre><br>  This is the entry point description that uses the JMS component.  The JMS component provides the ability to retrieve data from the queue: se.export resource.  Where queue is the type of message channel, it can be either a queue, or a topic.  Next comes the channel name ‚Äúse.export‚Äù.  A queue with the same name will be created by the message broker.  The last part of the URI, the parameters of the end point: ‚ÄútimeToLife = 10,000‚Äù, means that the lifetime of the packet is 10 seconds. <br>  From the example it is clear how we planned to organize the transfer of data, in the next article there will be more real code and examples. <br>  So, we solved the data transfer problem, created a prototype integration bus that consisted of Camel and was almost ready for implementation.  It remained to solve the problem of its proper and convenient settings. <br><br><h3>  Prototype setup </h3><br>  I am very impressed with this topic, as it is difficult to find practical advice and examples of implementation. <br>  Our stand structure is as follows: <br>  Each developer has his own copy of the software, and he fully sets it up before launching it.  There are two test benches for manual testing, and of course, there is a working system.  The task statement is obtained as follows: <br><ul><li>  fine tuning on each of the stands should have been done simply by editing the minimum number of parameters in the system configuration files </li><li>  a large setting (adding new functions) was performed imperceptibly for all stands </li></ul><br>  In addition, if there was an opportunity to use the project builder (Maven) on the developers' booths, then there was no such possibility on the test stands and the working server. <br>  There are a lot of difficulties in this task: Camel is associated with a JMS broker, which forces you to use different channels for different stands or different message brokers.  We went the easiest way by launching the ActiveMQ broker built into the bus.  In this case, it remains to provide connection settings for different servers. <br><br>  Let's move on to examples of using parameters in Camel settings: <br><ol><li>  Example from camel-config.xml <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"locations"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>classpath:system.properties<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>classpath:smtp.properties<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In this example, two files are specified with settings for Spring. </li><li>  An example that uses the settings specified by the two files from the previous example. <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someServiceStartPolicy"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.camel.routepolicy.quartz.CronScheduledRoutePolicy"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"routeStartTime"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${config.someService.routeStartTime}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"routeStopTime"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${config.someService.routeStopTime}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The properties themselves are set in the string "$ {config.someService.routeStartTime}" <br></li><li>  An example in which several files with settings are transferred to the Camel context <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">camelContext</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"rootCamelRoute"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://camel.apache.org/schema/spring"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">propertyPlaceholder</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"properties"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">location</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"smtp.properties, system.properties"</span></span></span><span class="hljs-tag">/&gt;</span></span> ‚Ä¶ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">propertyPlaceholder</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">camelContext</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></li><li>  An example of using parameters in Camel routs in Java DSL <br><pre> <code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"jms:queue:email.send"</span></span>) .setHeader(<span class="hljs-string"><span class="hljs-string">"to"</span></span>, simple(<span class="hljs-string"><span class="hljs-string">"${headers.email}"</span></span>)) .setHeader(<span class="hljs-string"><span class="hljs-string">"from"</span></span>, simple(<span class="hljs-string"><span class="hljs-string">"${properties:config.smtp.from}"</span></span>)) .to(<span class="hljs-string"><span class="hljs-string">"{{config.smtps.server}}?username={{config.smtps.user}}&amp;password={{config.smtps.password}}&amp;contentType=text/html&amp;consumer.delay=60000"</span></span>)</code> </pre><br>  It uses several ways to address parameters.  Here they are: <br>  - in a simple dialect with the string ‚Äú$ {properties: config.smtp.to}‚Äù <br>  - in the endpoint URI with the string ‚Äú{{config.smtps.server}}‚Äù <br>  Parameter names can be any, the lines are taken from the example above. <br></li></ol><br><br>  Let's present the real problem: <br>  there is a service that sends letters via the service bus to the SMTP server;  such a service should send messages to users for the working system, and for the test system, send all letters to one mailbox. <br>  Then this task is transformed into the addition of different logic for some routes performed on the test and production systems. <br><br>  Here is an example of how such a problem can be solved using parameters in Camel routes. <br><pre> <code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"jms:queue:event.recoverypass"</span></span>) .setHeader(<span class="hljs-string"><span class="hljs-string">"to"</span></span>, isDebug() ? simple(<span class="hljs-string"><span class="hljs-string">"${properties:config.smtp.to}"</span></span>) : simple(<span class="hljs-string"><span class="hljs-string">"${headers.email}"</span></span>)) .setHeader(<span class="hljs-string"><span class="hljs-string">"from"</span></span>, simple(<span class="hljs-string"><span class="hljs-string">"${properties:config.smtp.from}"</span></span>)) ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// some other headers .choice() .when( header("password").isNotNull() ) .setHeader("subject", simple("${properties:config.passwordNotify}")) .to("velocity:vm/email/newPasswordNotify.vm") .otherwise() .setHeader("subject", simple("${properties:config.recoverypass}")) .to("velocity:vm/email/recoveryPassword.vm") .end() .to("{{config.smtps.server}}?username={{config.smtps.user}}&amp;password={{config.smtps.password}}&amp;contentType=text/html&amp;consumer.delay=60000")</span></span></code> </pre><br>  The sample code above is needed for the password recovery service.  The following logic is implemented: the user clicks on the button to recover the password, an email is sent to him with a temporary link to generate a new password, the user follows the link, and the same route sends the user a new password by mail.  This is probably the reason to complete the first part, it remains only to take stock. <br><br><h3>  Results </h3><br>  The prototype of the bus was completed: there were several routes that perform the transfer of messages, configuration files appeared to facilitate the configuration and deployment of the bus.  Already by the results of the first steps in mastering Camel, it was possible to talk about the great potential of such an approach.  The simplicity and conciseness of writing routes is fascinating.  It seems that one line can do everything.  But you should pay attention to the fact that working with routs requires a change of thinking.  For programmers who have not dealt with them, it is better to immediately turn to the book ‚ÄúPatterns of integration of corporate applications‚Äù.  The effect of understanding integration patterns is comparable to the effect of knowing design patterns in a classic <abbr title="Object oriented programming">OOP</abbr> . <br><br>  On this bye, bye.  See you in the next part.  Let me remind you, it will be devoted to the use cases of Camel. </div><p>Source: <a href="https://habr.com/ru/post/230265/">https://habr.com/ru/post/230265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230255/index.html">How to discuss money at the interview: the negotiation strategy for the applicant</a></li>
<li><a href="../230257/index.html">Best ways to use Angular.js</a></li>
<li><a href="../230259/index.html">Microsoft fires 18,000 employees</a></li>
<li><a href="../230261/index.html">VMware vCloud Connector Part 1. Product Overview and Base Version Installation</a></li>
<li><a href="../230263/index.html">Speech synthesizer directly connected to the brain</a></li>
<li><a href="../230267/index.html">Juniper tincture: Prepare Juniper SRX. Part 2: IPSec</a></li>
<li><a href="../230269/index.html">Building Reliable Web Applications with React: Part 4, Server Generation</a></li>
<li><a href="../230273/index.html">British special services Swiss knife: a set of tools for doing cyber war</a></li>
<li><a href="../230279/index.html">Facebook is testing the Buy button</a></li>
<li><a href="../230281/index.html">Bing has become the next search engine where you can request the removal of search results.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>