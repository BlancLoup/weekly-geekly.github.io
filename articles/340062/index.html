<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Due to which Tarantool is so optimal</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anikin Denis ( danikin , Mail.Ru ) 
 The report will be devoted to Tarantool. I always talked about use case, about something that the user sees. Toda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Due to which Tarantool is so optimal</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f0f/240/713/f0f2407139594ee9e6bfd2b919d4798c.jpg" alt="Denis anikin"><br><br><h2>  Anikin Denis ( <a href="https://habrahabr.ru/users/danikin/" class="user_link">danikin</a> , <a href="https://habrahabr.ru/company/mailru/">Mail.Ru</a> ) </h2><br>  The report will be devoted to Tarantool.  I always talked about use case, about something that the user sees.  Today I will talk more about the insides. <br><br>  When I first saw Tarantool, when I recognized his benchmarks, what his performance was, it wasn‚Äôt that suspicious, because I had already programmed for more than 10 years and understood about what could be squeezed out of iron with optimal programming, with optimal code.  But still it seemed to me suspicious - how is it that he is so fast?  That is, conditionally, if all databases can operate at a speed of tens of thousands of queries per second, at best, and Tarantool - <strong>up to hundreds of thousands and even a million</strong> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, before you start using it in production, in mail.ru Mail and in the Cloud, I carefully studied everything and found out how Tarantool works inside and what makes it so optimal.  And I suspect that, probably, other users of Tarantool also have the same suspicion - something is somehow too fast, and somehow it is suspicious ... <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YNOoR7XwcxE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  By the way, raise your hands to those who have never heard of Tarantool.  Almost everyone heard.  Which of you applies it on production?  Not much.  In fact, you do not apply, including because you do not understand how he is so fast, and all others are slow, and that's due to what.  If this is really the reason why you are still afraid to use it, then you have come to the right place, and I hope that today I will tell you and explain.  Of course, not everything, because the database is a huge product, it has a lot of features, a lot of functions and it‚Äôs almost impossible to tell everything in 40 minutes.  Therefore, I will tell you about the main thing.  Go. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/08d/23d/88708d23d8c53308d4977d0f1999a03a.png"><br><br>  I also wanted to briefly tell you what to expect and what not to expect from the report.  Expect - specifics, i.e.  why Tarantool is so fast, why it reads quickly, writes fast, starts quickly, etc., and what were the reasons for us in Mail.ru to make it so fast. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/230/ed2/719/230ed271952b66419ba50f1fbda909cf.png"><br><br>  What not to expect is holy wars, i.e.  all databases are good, each database is for its case, and we do not claim to be a universal database for everything.  Also, do not expect any new structures or new algorithms, because the main strength of Tarantool is not that the guys invented some new algorithms that nobody knew before, but that they correctly apply and compose existing ones algorithms.  And they write the code very optimally.  You all know O (N).  When you say O (N) or O (logN), it means that if O (N) is 2 times the data set, the algorithm works 2 times longer, but how much it works specifically is unknown, i.e.  You can write it optimally, but you can make a bunch of copies and other things that will not affect its asymptotic complexity, but will also affect the speed of work.  So, in Tarantool a lot of attention is paid to this coefficient, which is facing O, i.e.  on which everything is multiplied.  This is a theory, and now we are moving to practice. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ea/420/910/6ea4209102a44a0fd65a0e1a3572d78d.png"><br><br>  Let's start with the most important thing that Tarantool stores the entire copy of the data completely in memory.  This does not mean that when the machine restarts, everything is lost, but the fact that a copy of the data is in memory.  The data is also on the disk, of course, but at the same time all the data is in memory and is never unloaded from there.  It is worth making a reservation here that it is about the original Tarantool engine, which is called Memtx, which, in fact, stores everything in memory and which is in-memory.  Tarantool has recently appeared a disk engine, which allows not a complete copy of the data to be stored in memory, but only a part of it.  Here I will touch only the original Tarantool engine, i.e.  only in-memory engine.  Obviously, memory is faster than disk, i.e.  if everything is in memory, then everything happens quickly. <br><br>  Such a picture symbolizing this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3c/601/674/d3c601674e180e57b45a8e864faeb49e.png"><br><br>  Tarantool reads everything from memory, and the disk database ‚Äî MySQL, Postgres, Oracle, SQL server ‚Äî they all read from disk, so Tarantool is faster.  This seems to be obvious, but there is a nuance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/790/2dd/1aa/7902dd1aa006cd420ca0f8a29b4a8192.png"><br><br>  You, probably, are looking at me now with this squint: ‚ÄúBut what about the cache, because disk databases have a cache, and why, nevertheless, Tarantool is faster, because disk databases cache the most popular queries, which means they should also be are they fast?  How do you think, what is the difference when you have a cache, from when you have data just in memory?  Is there any difference with tz  performance?  Can get old  Now about it and tell. <br><br>  Let's see how Tarantool interacts with memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b14/621/1e6/b146211e6387499bf746163ede85ac88.png"><br><br>  It simply reads data from memory, which there are always already prepared, in an ideal format that allows them to quickly read, quickly search, quickly make queries on the index. <br><br>  Now let's see how the disk database works: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ea/bb0/529/3eabb05299d2ebf1a898a8020bba96a8.png"><br><br>  Very primitive scheme, of course.  All bases are different, all have a different cache, but in general, the logic is as follows.  At first, let's say, comes from the user reading, some SELECT * FROM blah blah blah.  First we look to see if the data is in the cache.  If there is, then we climb into the cache and return, if not, then we read from the disk, write what we read into the cache.  If the cache is already clogged (and the cache is always clogged by definition, because it is always full, that is its meaning), then we force out the old data and then read from the cache.  Those.  if you are lucky, then one more action, if not lucky, then this whole long chain happens, and it should be noted that this is not all for free.  They counted it from a disk to some buffer, took it from this buffer, copied it to the cache, supplanted the old one, freed up the memory, wrote down the new one, allocated the memory.  Freeing / allocating memory is expensive.  This is all copying, this is all searching, and this is all not for free.  This is all the very coefficient that is before O, i.e.  many, many actions to do.  Appealing to a hash table, to some hash index in complexity is possible and constant ¬±, or if the tree is logarithmic, but this is all that is multiplied by Oh, this is a huge amount of work.  Plus, the data - they are on the disk in one form, in the cache are in a different form, then they are often cached through pages, so  we load a little more, it means we allocate a little more memory, we also release a little more.  All this precious processor cycles, which are all spent on this business.  It should be understood that even if you hit the cache, i.e.  read happened, and the data is already in the cache, then your processor in the background still does all this, this whole chain, it is always done in the background, without stopping.  Those.  if the data is even already in the cache, then the processor or its other cores are busy with something.  And once the other kernels are busy with something, then blocking occurs, then mutexes occur.  A lot of work compared to just counting from memory and everything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d24/be6/e57/d24be6e57ca35bf711a0220c60035776.png"><br><br>  Such a thing about the cache.  Feel the difference - always in memory and the cache is not the same thing, it is a little different things. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8a/4ba/9bc/a8a4ba9bcfa01f11fdd094606c06ab98.png"><br><br>  And now let's about the record. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bab/ab5/2be/babab52be6c080a4db4622dd22569fe9.png"><br><br>  From reading everything is more or less clear - ok, Tarantool in-memory, it reads quickly from memory, but what about the record?  Tarantool works on writing in almost the same way as reading, while it persists all the data to the disk anyway.  Why do you think it is so fast, although the data is still saved to disk when recording?  The keyword is consistent.  Now I will show it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/334/a85/8e1/334a858e151d4bd0d70906ace699a353.png"><br><br>  What does Tarantool do when it performs a transaction?  It executes it in memory and writes it to the transaction log.  In the transaction log, he writes it only for the purpose of recovery, i.e.  if everything falls in order to rise, roll everything out of the log and bring the database into the same state it was in before it started. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da7/471/be5/da7471be514a87c594ee1cc3076a904e.png"><br><br>  Writing to disk takes place as shown here.  Just write to the file, sequentially.  You all know that sequentially is written to the file very quickly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/209/d42/256/209d422563098d9ae10ad3d46ffd3958.png"><br><br>  Is the question here not slow?  It is fast enough.  On magnetic disks, this is somewhere around 100 MB per second, and on an SSD it is 250 MB per second.  Check it out right now.  On SSD macbooks usually stand, it will be hellish hundreds of MBs per second.  This is on SSD.  On a magnetic disk a little slower, but still, it is 100 MB per second.  What is 100 MB per second?  This is actually a fig, because if, for example, the transaction size is 100 bytes, which is basically a lot, i.e.  any transaction on updating there is just update something set key = value.  You just need to write key and value.  If it's numbers, then it is literally a few bytes.  But even if the transaction is 100 bytes, it is 1 million transactions per second.  Those.  peak performance is 1 million transactions per second.  This is such a performance that is usually never needed, it is very big.  And usually the bottleneck is not even a disk, but a processor or, for example, memory.  Those.  there is not enough memory to store so much data to do so many transactions on one machine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc8/b2c/1af/fc8b2c1af85e653bdc891c13c69f8cd3.png"><br><br>  But what about disk databases write to disk?  Why can't they just write optimally?  They do the same thing as Tarantool, i.e.  they update in memory, in cache, they also write log transactions, because how can it be without this?  Because transaction logs are the only way to restore the database after crash. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/047/72d/a16/04772da164faa77311da15ff2e997de7.png"><br><br>  And besides that, they also update the data on the disk.  How do they do it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b7/326/614/0b7326614d63693457b8bb2c31a80195.png"><br><br>  They usually use the good old B-trees. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c62/480/7c5/c624807c5f0f95b2c0f7db8fa1288098.png"><br><br>  This is by far the most popular data structure for storage on disk.  Although, I must say that new data structures of the LSM-tree type have already appeared.  They are used in the Tarantool disk engine, they are used in RocksDB from Facebook, they are used by Google in LevelDB.  In principle, all traditional run-in databases use B-trees or B + trees.  MySQL or Postgres, Oracle - all built on B-trees.  A B-tree is like a tree, only n-nar is it, it has a data block in each node, and further there are many references to subsequent blocks.  And due to the n-narrative, it is very short.  But still, in order to read the data stored here, you need to do 3 readings from the disk.  And these disk readings are slow.  Here the most important question ... It was correctly said that B-trees for disk databases are needed only to read the data later.  If disk databases would store, as Tarantool, the entire copy of the data in memory, i.e.  if they were Tarantool, they would not need to read.  And when it is not necessary to read, it is not necessary to write.  They write to this structure, only to be counted, only for the sake of it.  This is not for recovery.  For recovery, they use the same way as Tarantool, the log transaction.  And it makes them slower to write simply because they are disk-based, not because there are bad programmers there, they are very good there.  And simply because they are disk. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/045/f10/956/045f109564780a41de001f515d7560b1.png"><br><br>  At the same time, such a data structure is good - it does not lead to linear searches, but, on the other hand, it leads to random access to the disk.  On a magnetic disk, this is only 100 hits per second maximum.  Why do you think the magnetic disk allows you to read / write data in series of 100 MB / s and accidentally access only 100 times / s?  Because it causes physical movement of the disk head, and the disk head cannot move very quickly.  100 times a second - this is so very much, just imagine.  But if you read the banal 100 bytes, which are scattered throughout the disk, you will write or read them at a speed of 100 bytes per second.  Also, do a simple test - you can write a simple C program, take some file in several gigs so that it does not fit in the page cache, and accidentally read or write some bytes from it.  You will have at best 100 times per second.  If you fragment, it will be even worse, because then with each call there will be a few more sik, it will be several dozen times per second.  This is a separate problem that these files are also fragmented.  But, like, the databases are able to deal with this, they, in fact, create some kind of big file right away in advance and rule its pieces, but they squeeze it once in a while so that there is no fragmentation.  On SSD it is a little faster, but the same thing, well, 1000 times per second.  Again, feel the difference - in the transaction log we write 1 million transactions per second, in the table space, in the B-tree we write on the HDD several dozen, 100 times, on the SSD - 1000 times, just a difference of 3-4 orders of magnitude. <br><br>  Now let's go further.  About the start. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/769/a2f/78d/769a2f78d93aefb2a538b12a0875b945.png"><br><br>  I told about reading and writing.  Tarantool reads faster, because everything in-memory and in-memory is not a cache, because it does a lot less work than cache, cache, allocate, free, change data structure, copy, etc.  And Tarantool writes faster, because it does not need to update the table space, because it has a disk only for recovery, and not for the execution of transactions. <br><br>  Now let's start about the start.  How does the start of Tarantool?  Tarantool has a log of transactions, there is a Snapshot, I haven‚Äôt spoken about it yet, but I‚Äôll tell you later.  Snapshot is the state of the database at some point in time.  Tarantool periodically resets all of its state to disk so that the log transactions do not grow much, so that you can easily recover later.  Accordingly, the launch of Tarantool is simply reading 2 files, and the files are not fragmented and linear, i.e.  reading from them is linear.  Just read Snapshot from the beginning to the end, read the log from the beginning to the end and in the process of this reading apply everything to the memory.  This is what start Tarantool is. <br><br>  How fast? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f12/6bf/aa2/f126bfaa27b29aefca8d36cd8aaf3f97.png"><br><br>  This, again, on a magnetic disk - 100 MB / s, on SSD - 200-250 MB / s. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cd/a5a/320/8cda5a320db1d3417d2e2ed98f8bba17.png"><br><br>  And how does this happen with disk databases?  The question is very interesting, because disk databases, we must give them their due, they start almost instantly, because they do not need to read the Snapshot into memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/e84/d74/024e84d741946372f98f5192f5064795.png"><br><br>  But what happens next?  Suppose you have Postgres or MySQL.  They started, what next?  Do they work quickly right there?  The cache warms up - this is tin.  We are now at HighLoad - this is a conference dedicated to high loads.  If you have high loads, then you use the cache with might and main, and this means that without a cache, the database normally, in principle, does not work, it simply does not cope with the load.  Experienced DBA, they can forcibly warm up, different techniques, etc.  But the fact remains.  How does it warm up normally? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/043/21d/e18/04321de189c65508eea46ba5fd365690.png"><br><br>  How does the cache warm up?  Like this, it warms up.  Not fast. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/500/353/22c/50035322cf6d97d47d463721d8575b6f.png"><br><br>  The user goes to the database, asks for something from her, the database randomly reads something from the disk (by chance, because the data is not in the cache), and then gives it away and caches.  Then comes the next request, it happens in a different place on the disk, again by chance.  Yes, you can warm up, you can do cat index file, you can do many, many, many things, but the fact remains that when there is a lot of data, then no one knows the hot data, which should be in the cache where they are on the disk.  How to find out?  You will not know this until users begin to request them.  You know that an index is hot data, but the idea is that the data is already on the disk in the format in which the data is located, and the hot data is somewhere random.  To warm up the cache, you need to read some random data by some optimal algorithm, which is much slower than just reading 2 files linearly.  Here they are hot data, the other Tarantool and no.  It is like for hot data. <br><br><blockquote>  <font color="gray">By the way, we posted in open access the video of the last five years of the conference of developers of high-loaded systems <a href="http://www.highload.ru/">HighLoad ++</a> .</font>  <font color="gray">Watch, learn, share and subscribe to <a href="https://www.youtube.com/user/profyclub">the YouTube channel</a> .</font> </blockquote><br>  For disk databases, you need to find these hot data as a grain somewhere.  In practice, Mail.ru our super cool admins all that could be squeezed out of MySQL is 1-2 MB / s.  On our volumes, and we have 100 GB, 1 TB databases, more than at this speed, it does not work to start it, to warm it up with all the technicians, which is not surprising, because the hot data is scattered across the disk in different places.  You need to do siki, you need to do the movements of the head.  Conventionally, you read 10 Kbytes of data, made a movement of your head, spent 1 ms, and also read a couple of Kbytes - also spent 1 ms.  Thus, when you spend 1 ms per every 10 Kbytes, you get 1 MB / s.  Rest against just input / output.  Such situation.  It should be noted that this difference in heating is the result of the fact that the cache and ‚Äúalways in memory‚Äù are two different things.  Those.  Tarantool always keeps in memory what is needed, and it starts quickly, reads / writes quickly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49a/f30/a6b/49af30a6bb52890ccc834b857ed7e7d7.png"><br><br>  And disk databases are arranged differently, they are calculated on the fact that the data lies on the disk, and sometimes there is something in the cache, and this data is scattered right among the disk data and lies somewhere separate, therefore a slow start occurs.  The difference is 100 times somewhere. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/5f9/040/7435f9040b5db29137fb095a291b238f.png"><br><br>  This is what I said that Tarantool groups all the hot data in one place just by design. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/374/0fa/a67/3740faa670d42388aa055ed605b85245.png"><br><br>  Now let's talk about latency.  Latency is the time between starting a query and getting a result.  When I talk about Tarantool, I will not compare it with disk databases, because everything is clear, and I will compare it with other in-memory databases. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d53/413/4b8/d534134b8ed209ca93c90e1fed494ea0.png"><br><br>  How did it all start?  Once upon a time we had every night at Mail.ru we saw such latency peaks, i.e.  for some reason, from time to time we grew 1000 times the execution time of the request.  Those.  it was not a millisecond, but it was a second. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bd/b3c/794/3bdb3c79479815f2efcd3172c8dd8585.png"><br><br>  We began to think why this is happening.  Moreover, it happens at night, This is clearly not the users to blame, it is something inside of us.  We began to deal with this and found out that the reason is simple - it is snapshotting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82d/ac9/db9/82dac9db9154cea6ea3f56c4e310c1ff.png"><br><br>  In-memory databases, unlike disk, and this is their minus very well-known, must snapshot once in a while.  Those.  if the disk database does not snapsot, it works for itself, it changes data in B-trees, writes transaction logs and does not need to reset the state to disk periodically because it has data already stored on the disk in the format in which they are readable.  The in-memory databases are wrong.  They have to snapshot once in a while, because if you don‚Äôt do this, huge transaction logs will accumulate that will be used for a very long time.  Do you understand why log transactions take longer than snapshot?  There can be 50-100-1000 operations to the same field, and each transaction in the transaction log will go separately, and it should all roll.  And in the snapshot, it will be like one, just the current last value.  Therefore, in-memory databases need to constantly snapshot. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5e/bc7/bd2/e5ebc7bd2cedcb889ca2aa63b134a473.png"><br><br>  How does it happen, why does snapshoting hinder everything?  It would seem, well, the snapshot database and snapshot, it snapshot on disks, it would seem, the disk is a bottleneck, but it also works with memory, why snapshoting can slow down the entire database?  Lock  This is a very interesting lock. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0e/ad1/802/d0ead1802bf626b16ccf384bc8d96a1c.png"><br><br>  In order not to snapshot'it with the lock of the entire database, we at one time made it a fork.  Fork () is a Linux or Unix system call that simply creates a copy of the process.  Those.  it creates the entire child process from the context of the parent process. <br><br>  How did we do the snapshot?  We do fork (), create a child process.  Fork () has all the data that its parent has, and quietly writes this data to disk.  And parent serves transactions at this time.  And log at the same time slows down, why?  Copy-on-write. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e2/c31/e25/7e2c31e25de12f3d8a0f7af5e3997b8b.png"><br><br>  How does fork () happen?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fork (), firstly, copies the descriptors of all pages from parents to children, and if you have hundreds of memory gigs on a machine, then tens of millions of pages or under 100 million pages of 4 KBytes each have a handle which weighs something there, this whole thing needs to be copied first. </font><font style="vertical-align: inherit;">And after copying all this marahayki begins to work copy-on-write.</font></font> What it is?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, child, when it starts, it inherits all pages of memory from parent, i.e. </font><font style="vertical-align: inherit;">they have a common memory completely sharpened. </font><font style="vertical-align: inherit;">But as soon as a parent or child changes at least 1 byte in itself, no matter where, this page is completely copied, and the page is 4 KB.</font></font> So<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what is going on? </font><font style="vertical-align: inherit;">In Tarantool, mass updates are sent to parent, it is updated here and there, and for each update of the several bytes that are updated, the entire page 4 Kb is copied. </font><font style="vertical-align: inherit;">Update came in some other place - again the page.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it is copied hundreds of times more than the data changes. </font></font> So<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">even from a small load, everything leaves on the CPU, the whole machine. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/da1/4be/04f/da14be04f045ef501c413c38ff817a97.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, this problem in other in-memory databases, as far as we know, has not been solved yet, they all do the same, including Redis, Couchbase, Aerospike. But we solved this problem at some point to solve. And I hope that everyone else will follow us, and they will be the same optimal ones too. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/286/7b3/6bc/2867b36bc26c7108b2346b1a5f2b857e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you have any idea how to improve it? How to get rid of this copying that happens during snapshoting? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/912/fd8/915/912fd8915ef385b254aa5c93301f0879.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it is its own copy-on-write mechanism, which does not replace the system copy-on-write, but which is simply implemented inside Tarantool, and which operates not with pages, but with fields and entries. This is a bit like a multiview concurrency control.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f53/f8d/bf9/f53f8dbf973f76521a12495f91a24ec1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have heard such a word, it is in many databases so. transactions are arranged so as not to block reading when writing is in progress. We, in principle, do the same here, our idea is not to block the recording in Tarantool while reading is in progress, and the entire database is read and dumped to disk. The idea is very simple - during snapshoting, any change to any data item leads to copying this item. Just like copy-on-write. Only not the whole page is copied, but only a small element is copied. And, accordingly, from this profit. If very briefly. At the same time there is no fixed cost in the form of a copy of the table of descriptors. It just starts snapshoting, starts slowly on every change to make a copy of the elements that change.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/df3/af8/81b/df3af881b32165f0f94ae3e94926bd75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something like this happens. There is an old version, a new version. Something has changed, new versions are budding. Everything, we work with the new version. We don‚Äôt touch the old version, it participates in snapshoting.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all updates go to new versions. The old versions do not change, the old version of the database is complete and, in fact, we do not copy the entire database, we copy only what has changed, and only those bytes that have changed, those records, those fields. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ea/f39/cf3/1eaf39cf35df4b21dc3ecd35cf549e2a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This helped us solve this problem. Night spikes disappeared. This is starting from version 1.6.6. This is about 9 months ago. The snapshot we had was turned on at night, if it was turned on during the day, it would be still worse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We talked about reading, about writing, about latency. The last topic for today is the bottlenecks in the database. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1a/f77/dc4/e1af77dc41fb02a78dbcc35354c657c7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, of course, there are a lot of bottlenecks, and we will not cover all the bottlenecks, but will highlight the ‚Äúnarrowest‚Äù.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/37e/c74/9d7/37ec749d78ad16918765f3e9f169eae5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++, Java and other languages ‚Äã‚Äãhave built-in structures that are very similar to a database. For example, in C ++, there is a std :: unordered_map - this is a hash, in fact. It is like an index, i.e. there you can write a key, a value, it is quickly read, it is written quickly, all for O (1), and everything is fine. It is, in essence, like a database. Only it is inside your process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This database works at a speed (I checked it on the MacBook) 2 million operations per second on a single core. In fact, you can accelerate even more, I just did not bother much, but to give you an estimate - millions of operations per second. Just take this cycle and somehow start this hash to read / write by chance.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this index in the database, everyone knows that it does not work at such a speed. </font><font style="vertical-align: inherit;">At best, 10 thousand operations on one core, 20. This is a difference of 2 orders of magnitude. </font><font style="vertical-align: inherit;">Strangely it turns out - the standard C ++ hash that already exists, I don‚Äôt want to use it, 100 times faster than the same hash, but inside the database.</font></font> Why is that?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is one word that explains everything, and that word is ‚Äúsystem calls.‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are system calls? </font><font style="vertical-align: inherit;">This is when a process goes to the kernel with the goal that it does something to it, which it cannot do - read the file, write the file, read from the network, etc. </font><font style="vertical-align: inherit;">Every system call is evil.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/8d5/c8d/3878d5c8d2b72f3290fa09b0c804b3ab.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where do system calls come from? At least 5 system calls need to be made to process one transaction in the database, because they are obliged to read our request from the network, without this in any way. Next we have to block the data - this is also a system call, this is mutex. Next we have to do something with them. Next we have to unblock them, again this is mutex. Then we must write a transaction to the log, and further, even if we do not write anything in the table space, and write only to the log of transactions, we must also give an answer to the network.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">less than 5 system calls are very difficult to make. In fact, there are many more of them, in Postgres, MySQL, Oracle, there will be 10 of them, well, plus or minus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLite memory is in the same address space, i.e. SQLite is std :: unordered_map, which works in the same address space as the code works. You can discuss for a long time what is best, because when your database works in the same address space as the code, you lose network interaction and you cannot go from another place. And if you go there from another place on the network, then you get it all.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/490/ccc/76d/490ccc76dba33c96457b2c548c2d87e1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why are system calls expensive? This may not be clear to everyone. Because a lot of copying happens. To make a system call, you need to enter the kernel, exit the kernel and copy a lot of data, then restore. You can make some program that makes read from / dev / zero, the simplest one, and reads one byte from there. Reading one byte from / dev / zero, which actually doesn't go anywhere on the disk, just returns 0 to you, it does almost nothing in the kernel, it will occur, well, if 1 million times per second. Even the simplest system call is slower than the useful std :: unordered_map, which does all our dirty work. Even 1. And there are 5 of them here, but in fact there are more. On the log, on the system call, it is huge, it is 90% -95% - just huge.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/634/c68/7ed634c68c096e09bfba389930dfe1c7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How did we solve this problem in Tarantool? </font><font style="vertical-align: inherit;">We thought: why not make more payloads for one system call?</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idea such that we use a socket in parallel. </font><font style="vertical-align: inherit;">For example, if there is a client application, all clients that are on the same machine, they all write to the same socket in parallel. </font><font style="vertical-align: inherit;">They make a lot of write system calls on the client, but Tarantool reads all the requests from the network that came in parallel to it in one read in one read. </font><font style="vertical-align: inherit;">Then it processes these requests in parallel in one lock. </font><font style="vertical-align: inherit;">In fact, there are no locks in Tarantool, there is such a special approach, which makes it work without locks. </font><font style="vertical-align: inherit;">But even if they were there, we accepted a packet of requests, blocked, executed, unblocked, so </font><font style="vertical-align: inherit;">less system calls. </font><font style="vertical-align: inherit;">Next one pack all written to disk.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also one write, one syscall write for many, many transactions. </font><font style="vertical-align: inherit;">And one pack gave everything to the client, too, to write to the socket.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f3e/c0e/a22/f3ec0ea22eceb2ec857c85507e71ff35.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like this. </font><font style="vertical-align: inherit;">This is, in fact, several threads, each of which does its work in parallel. </font><font style="vertical-align: inherit;">This is a client, it from parallel processes all into one socket in parallel, Tarantool catches it all with one read, gives it further to the processing of the transaction processor, it processes in-memory, then the same packet with one write, i.e. </font><font style="vertical-align: inherit;">gives a pack of this thread, thread writes to disk with one write. </font><font style="vertical-align: inherit;">Then he gives the whole pack back, again, the whole inter thread communication, i.e. </font><font style="vertical-align: inherit;">all locks that are, if they are, they are per pack, not per request, but per per package. </font><font style="vertical-align: inherit;">And it all comes back. </font><font style="vertical-align: inherit;">At the same time, everything works in parallel while it is processing it, this new one takes, a new pack, a new pack, a new pack ...</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be compared with the fact that the bus pulls up to the bus stop, and it takes as many people as there are. Stand 100 - took 100, left. It is worth 1 - took 1, left. On latency is not affected. The idea is that the more requests from the client accumulate here, the more efficiently it uses the processor. If there are few of them, the processor is used inefficiently, it is true, but at the same time, it smokes so, why not? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many machines, many sockets, then we return to the good old system calls. If each client writes everything synchronously to one socket, then we return to this scheme: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c2/04d/0c5/9c204d0c542c532673547bbc0f93d4d1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also fast, but there is no such magic - </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f3e/c0e/a22/f3ec0ea22eceb2ec857c85507e71ff35.png"><br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Osipov:</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have this activity on many sockets, many clients, all the same will not affect the transaction-processor, because the network thread will process all these sockets separately and then the transaction-processor patches. Therefore, we have a network thread ... If we compare Redis with us, then when there are many customers and the load is small, then Redis eats less CPU, this is due to the approach that it does not do interthread communications, it all has one thread. But if the load grows and there are a lot of clients, then we have the throughput of this dedicated thread, which processes transactions, above, because everything else is pulled out of it, and it only does useful work. </font></font><br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denis Anikin:</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Because this crap is scaled right there on all cores, they will always be ineffective, because such a load pattern all use their own socket.</font></font><br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Osipov:</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In 2 words, an event-machine runs in each thread, and in each thread its own firewalls work, so the exchange of messages between the fireboxes is just part of the work of the event-machine scheduler. Under the hood, they use shared memory and a file descriptor is used.</font></font><br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Denis Anikin:</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is a separate big topic, that Tarantool also has faders, except for this whole thing. He has parallel requests being processed in the faybery ...</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/5a2/4f5/9195a24f5f7a8facc087a0fdbac486e1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is still a lot of things that I haven‚Äôt told, you can still make 2-3 reports here, but the general idea is that we write, read, start and process the mass load faster, simply because we use the right approaches, algorithms and always think about performance.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c46/462/c5c/c46462c5c6541561533f7428219a5deb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, you can go to the address on the slide. </font><font style="vertical-align: inherit;">We have everything open-source, not only the code, but all of our tools. </font><font style="vertical-align: inherit;">We have such a tool (link to it) that shows the performance of each commit.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there for each commit a complete set of performance tests takes place. </font><font style="vertical-align: inherit;">And if we see that some commit has dropped one of the tests, then we fix it right there. </font><font style="vertical-align: inherit;">The method is not technical, but this is how we keep ourselves in shape to be always fast.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/30d/847/c0d/30d847c0d2c5ce1f0ded8237bd81b310.png"><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anikin@corp.mail.ru</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/users/danikin/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">danikin</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/company/mailru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru company blog</font></font></a> <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the conference of developers of high-loaded <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad ++</a> systems.</font>  <font color="gray">Less than a month is left before the HighLoad ++ 2017 conference.</font> <font color="gray"><br><br></font>  <font color="gray">We have already prepared <a href="http://www.highload.ru/2017/abstracts">the conference program</a> , now the schedule is being actively formed.</font> <font color="gray"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What will be this year about Tarantool? </font></font><br></font> <ul><li> <a href="http://www.highload.ru/2017/abstracts/2848.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronization of data from PgSQL to Tarantool</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / Veniamin Carnations (Calltouch);</font></font></li><li> <a href="http://www.highload.ru/2017/abstracts/2950.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stored procedures in NoSQL DBMS on the example of Tarantool</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / Denis Linnik (Mail.Ru);</font></font></li><li> <a href="http://www.highload.ru/2017/abstracts/2974.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cluster metadata: race key-value-heroes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / Ruslan Ragimov, Svetlana Lazareva (RAIDIX)</font></font></li><li> <a href="http://www.highload.ru/2017/abstracts/2837.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libfpta - the pinnacle of performance between SQLite and Tarantool</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / Leonid Yuriev (Positive Technologies)</font></font></li></ul><br><br>  Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.  Already, in our textbook more than 30 unique materials.  Get connected! <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/340062/">https://habr.com/ru/post/340062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340048/index.html">Why DataScientists do not use errors of the first and second kind</a></li>
<li><a href="../340050/index.html">Why a Python Networker? Part two</a></li>
<li><a href="../340052/index.html">Not on TK</a></li>
<li><a href="../340054/index.html">VPC statistics service</a></li>
<li><a href="../340060/index.html">20 best books for product and project managers</a></li>
<li><a href="../340064/index.html">What is DFD (data flow diagrams)</a></li>
<li><a href="../340066/index.html">How to hack more than 17,000 sites in one night</a></li>
<li><a href="../340068/index.html">Microsoft has demonstrated a working fuel-powered data center</a></li>
<li><a href="../340070/index.html">Golden ratio (Phi number) and time, your opinion?</a></li>
<li><a href="../340072/index.html">Moments in the development and sale of modules Bitrix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>