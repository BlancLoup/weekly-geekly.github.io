<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast and secure JVM application monitoring with BPF magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all met with complex production errors that are difficult to catch using conventional monitoring tools. BPF is a Linux kernel technology that allow...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast and secure JVM application monitoring with BPF magic</h1><div class="post__text post__text-html js-mediator-article"><p>  We all met with complex production errors that are difficult to catch using conventional monitoring tools.  <strong>BPF</strong> is a Linux kernel technology that allows you to do fast and secure dynamic debugging directly on a running running system without having to prepare for it in advance.  The JVM itself has many monitoring points for tracking garbage collection, object allocation, JNI calls, even method calls ‚Äî all without the need for additional instrumentation.  When these monitoring points are not enough, the Linux kernel and various libraries can track system calls, network packets, scheduler events, time spent accessing the disk, and even database requests. </p><br><p>  In this session, we did a textual transcript of the <a href="http://2017.jpoint.ru/talks/fast-and-safe-production-monitoring-of-jvm-applications-with-bpf-magic/">Sasha Goldshtein report</a> on how BPF tools can be used to monitor JVM applications on GNU / Linux, and performance checklists using classic tools such as <em>fileslower</em> , <em>opens</em> , <em>op</em> , and <em>strace</em> - but all this with using non-invasive, fast and safe <em>BPF</em> technology. </p><br><p>  After the kata there will be a lot of pictures with slides.  Caution traffic!  Pictures as tight as you can, but no more.  They are all really needed. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0qI31tdlV-k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><p>  Today we will talk about monitoring through some new and most advanced tools for Linux.  My name is Sasha Goldstein and I do a lot of things related to .NET for Microsoft.  For several years I have been working on monitoring and tracing tools for Linux, and, in general, my work over the past twelve years or so has been related to performance.  It turns out that the same Linux tools that are used to monitor applications in C ++ (I do this quite often), under Python (I do this sometimes), can be used to monitor, improve performance, trace, and solve important problems of Java applications under Linux .  Some things that I do are also useful to Java developers. </p><br><p>  The report will focus on expert Linux trace tools and how they can be used in Java applications.  This means that I will show you only the tip of the iceberg, these are system-level tools that can be used with other languages ‚Äã‚Äãand environments.  So if you sometimes have to debug or profile applications written not only in Java, these tools will be useful to you, unlike many Java-profilers that can only work with Java code, and they do not support C ++ or Python. </p><br><p>  During the report, I will highlight four main points that I hope will be useful to you.  First, you will learn exactly which traceable tools you can use with JVM applications.  About this I will tell quite a bit.  Secondly, and this will be one of the key topics, it will be about <em>BPF</em> (this is a system-level technology), and how much it can change a lot in modern tracing tools for Linux, since it allows what it was extremely difficult to achieve before in production under linux.  Thirdly, I will demonstrate a sort of checklist of performance assessment tools, with which you can easily and quickly obtain some preliminary data.  Finally, I will show examples of narrowly focused research that solves certain problems with the help of more complex and sophisticated tools. </p><br><p>  If you sometimes use something other than Linux during deployment, on other systems there are analogues to these tools.  Under Windows, some of the things I will talk about can be done by <em>ETW</em> .  Under FreeBSD and MacOS, you can use <em>DTrace</em> ;  <em>BPF</em> is DTrace for Linux, even though they don‚Äôt like to call it that. </p><br><p>  Now I will give you a general picture of the Linux trace tools as a graph. </p><br><p><img src="https://habrastorage.org/webt/wv/2f/0y/wv2f0ynjubuk0y5awtwwiydjh9q.png"><br></p><br><p>  The horizontal axis is the degree of detail, i.e., how detailed information a tool can produce.  The vertical axis is ease of use.  Separate colors are presented by new tools, stable tools and out-of-use tools, which should not waste your time. </p><br><p>  Very often, people are unfamiliar with <em>ftrace</em> , especially for non-system-level developers.  Raise your hands, which of you heard about <em>ftrace</em> ?  Just a few.  Ftrace is a built-in mechanism, it has been included in Linux since time immemorial, it is a tool for tracing performance problems, bugs during production.  However, it is not designed to work with Java.  It cannot be used to trace many interesting Java events, such as garbage collection, class loading, object highlighting. </p><br><p>  Let's <em>go</em> to <em>perf</em> .  Quite a useful tool, which of you used it?  Already significantly more people.  The following speaker will talk about how to adapt <em>perf</em> to work with Java applications.  In my report, I will not use <em>perf,</em> and later I will explain why.  But I will say that it is applicable to a much wider range of applications. </p><br><p>  Next, <em>SystemTap</em> .  Which of you used it or heard about it?  Again, very few, and, it seems, the same people that raised their hands earlier.  <em>SystemTap is a</em> very low-level tool that can trace kernel events and high-level events in user space (including Java events).  The main problem that many people encounter in <em>SystemTap</em> is that in order to work with this tool, you need to compile the kernel module during its execution and load it into the kernel.  Some are ready to do this; for others, loading dynamically compiled kernel modules does not arouse much enthusiasm.  The creators of <em>SystemTap</em> are developing a backend to <em>BPF</em> so that you can not compile a new kernel module for each trace program, but so far this remains a problem. </p><br><p>  At the opposite end of the spectrum is maximum availability and convenience, but less functionality, this is <em>SysDig</em> .  Which of you used it?  Even fewer people.  <em>SysDig</em> is a great tool, with a special focus on tracking performance in containers, but it can only work with system calls.  He does it well, but he can't do anything else.  Not exactly what is needed for Java applications. </p><br><p>  Today, I will mainly talk about <em>BPF-</em> based tools, but I'll go on to <em>BPF</em> itself later.  <em>BPF</em> has several frontends, tools based on it can be written in C, in Python, there are many options.  Those that will be discussed in the report are new, not as stable as others, but extremely powerful.  Because of the novelty, it is sometimes not easy to use them, but they are worth it - at least I hope to prove it today. </p><br><p>  There are other tools.  For example, some obsolete, incl.  <em>DTrace</em> under Linux.  It was quite an ambitious project, but in the end he died.  As I said before, in its own way <em>BPF</em> is the DTrace for Linux that we lacked. </p><br><p>  Since Java is today our focus, let's talk about monitoring points in the JVM.  What can be traced in a running JVM-specific Java application, i.e.  in addition to things performed by the operating system (system calls, network events)?  It turns out that in most of the latest Java versions, the JVM has built in quite a few static trace points that can be enabled at runtime, i.e., they do not need to be included in advance.  Then you can connect trace programs to these points, which will give you the information you need. </p><br><p><img src="https://habrastorage.org/webt/fl/zw/ej/flzwejwci3wkaj2xz_vio_z_dom.png"><br></p><br><p> I will describe one of the ways you can get a list of these trace points.  Linux has a <em>readelf</em> tool that analyzes <em>ELF</em> headers and can issue notes.  They describe those very trace points that are embedded in any Java application on your system.  We see high-level Java events: <code>class_loaded</code> , <code>thread_start</code> , <code>object_alloc</code> , they can be traced through these points. </p><br><p><img src="https://habrastorage.org/webt/bm/ii/ob/bmiiob_rndvyipv2we3ehe42x6e.png"><br></p><br><p>  There is another tool, <em>tplist</em> , it is somewhat easier to use, I wrote it myself.  You do not need to analyze notes with it, since it creates a simple list.  There are many dozens of examples of trace points: garbage collection, occupation and abandonment of monitors, JNI events (they are not shown on the slide). </p><br><p><img src="https://habrastorage.org/webt/7q/pw/ns/7qpwnsw7ux3ru4puzw0tg5c9vdq.png"><br></p><br><p>  These events also have arguments.  In the interest of saving time, I will not now tell you how this information was extracted, but <em>tplist</em> has a flag that allows you to output the arguments of each of these points of observability.  For example, based on common sense, we can say that the <code>monitor__waited</code> event most likely has some kind of information about the monitor that we expected, perhaps there is a stream identifier.  However, nothing is said directly here about what exactly these arguments mean.  It turns out that here the text files attached to the JVM, in which these trace points are described, can help us.  Essentially, <em>SystemTap</em> trace files.  In them, you can, for example, find out that the <code>monitor__waited</code> event <code>monitor__waited</code> several arguments, it is the stream identifier, the monitor identifier, the class name of the expected object.  It even offers the option of a format in which it can be presented for tracing, for display. </p><br><p>  So, the question is: are we talking about OpenJDK, Oracle JDK, any specific distributions?  As far as I know, there are these trace points in all JDKs, even though I strongly doubt that the specification forces this.  When they arose, I can not say for sure.  I remember the Oracle article, it seems, of 2008, in which they were described, so this is not a new phenomenon. </p><br><p>  (After this report, we checked: <strong>there</strong> are <strong>no</strong> monitoring points on Oracle in OracleJDK. There are on Solaris and possibly on Oracle Linux. These points are in the source, but they are not compiled by default. But in all OpenJDK they are present!). </p><br><p>  First, I would like to show how they can be used, and then go on to describe <em>BPF</em> and its work with them.  Here is a not serious example: a Java application prints messages to the console, which are apparently important, but we do not know where they come from.  And to find out which code sends these messages, we want it in production.  Perhaps with the help of a debugger, this problem could be solved through breakpoints, but we will not do that.  We need the <em>PreserveFramePointer</em> flag, which is also used by many Java profilers for passing the stack.  This flag was already present in JDK 8u60, and will be discussed in the next report, which uses <em>perf</em> .  The flag is required for walking on the stack.  This flag enables verification that frame register (one of the CPU registers) is not used for normal calculations, like any other register.  It should only be used to handle call chains, including for walking on a stack. </p><br><p>  Estimated cost of using this flag is about 3%.  If the CPU load is not ultra-high and millions of methods are not called per second - maybe 0%, this is a modest estimate.  On the screen you see the output of the program we are trying to trace. </p><br><p><img src="https://habrastorage.org/webt/6l/_3/rj/6l_3rjixc5eg89pzr0uedius7de.png"><br></p><br><p>  Warnings look serious enough, so you need to understand where they come from.  Let's try to use the <em>trace</em> tool, written, again, by me.  He is involved in tracing system-level events, and simultaneously receives a stack of Java calls from these events.  There is no need to restart the Java application, recompile, in fact, <em>trace</em> is an extremely lightweight tool that can be run in production.  Links are posted along the slides, by the end of the report you will know where to get all these tools. </p><br><p><img src="https://habrastorage.org/webt/0z/ok/su/0zoksudjg00suhl31zeilkeqbme.png"><br></p><br><p>  <em>trace is</em> based on <em>BPF</em> .  On the slide you see the appeal to him.  First, note: I need to run the code as a privileged user.  As we will see later, this is required by <em>BPF</em> , like <em>perf</em> , like many other tools.  Then you need to determine what exactly to attach the <em>trace</em> .  I need output tracing on the screen, but in this particular case I work at the system level, so I will look for a specific system call that, among other things, performs standard output.  In addition, I will add the condition that the first argument should be one.  What do you think will be the first argument for the desired system call? </p><br><p>  That's right, the file descriptor, and the unit is the condition by which I will trace the <code>stdout</code> to <code>stdout</code> .  Then we see the message that will be printed, in <code>printf</code> style;  <code>arg2</code> is a buffer that is directly in the process of printing (if it contains text, which is most likely).  It is followed by the <code>-U</code> flag, which indicates the call stack in user space.  At the very end, we put a filter that leaves only the Java process, since we are only interested in it.  If you understand the syntax, I hope it will all become clear. </p><br><p>  Let's look at the <em>trace</em> output.  He is almost as we wanted.  The first few lines are the heading, identifying process and thread identifiers.  Then comes the message that interests us - ‚Äúan error in data acquisition, clearing occurs‚Äù.  The call stack is almost what we need, at its beginning everything is in order, but it does not show us the most interesting part, for example, what happens before <code>java_io_FileOutputStream</code> .  And we will face this problem when working with many tools that try to go through Java stacks and build correspondences with symbols, function names, and methods in your code. </p><br><p><img src="https://habrastorage.org/webt/3p/sg/jq/3psgjqiaogh20cp0rw7mdqvswks.png"><br></p><br><p>  Here, as in <em>perf</em> and many other tools, a small agent will be needed to print the correspondences between the addresses in the memory of the JIT compiled code and the actual method names.  If necessary, it can also print information about the source, since it has access to them.  In this case, I use a fairly common and very simple agent, <em>perf-map-agent</em> , which can be found on GitHub.  It will send its output to the / tmp folder, these will be files in a very simple format with the address of the code, the specific method and the size of this method.  These matches are needed to resolve java call stacks.  If the profiler initially does not know how to work with frames of Java stacks, one cannot do without such an operation. </p><br><p><img src="https://habrastorage.org/webt/49/br/ki/49brkiacl9a4jmysbbav8el5l3k.png"><br></p><br><p>  On the slide, the new result using the agent, the stacks look acceptable in it, the names of the functions are resolved, which are all extracted from the .map file we just generated.  The slide highlights a part of the code of my application (DataFetcher :: fetchData), which provides the output to the console that disturbed us.  The source was found, and now it depends on the situation, what we will do with this code.  It seems to me that this is an example of the possibilities that we must have: extract data from an already running system using simple, non-resource-intensive, ready-to-produce tools.  This can occur at the Java level, at the system level, at the kernel level ‚Äî it does not matter. </p><br><p>  Before we get to the heart of the matter, consider another similar example.  A java application that causes a lot of garbage collection.  From the garbage collector log, I know that it calls <code>System.gc()</code> directly, and I need to understand exactly where.  The application is huge, a lot of libraries, which code makes these calls is unknown.  I did not start with this example, because here we will need a flag that requires a lot of resources.  This kind of super-debug mode is called <code>ExtendedDTraceProbes</code> , and it allows you to attach a trace program to the input and output of any Java method.  Obviously, this will require more resources than for other methods that I have mentioned, so this flag should only be used when a specific problem needs to be solved. </p><br><p><img src="https://habrastorage.org/webt/re/fd/xf/refdxfuz3c2afoezxbqbp85nq4m.png"><br></p><br><p>  Before us is the garbage collector log, in which we see direct calls to <code>System.gc()</code> .  Here we will use trace again, but in a slightly different way, since the purpose of the attachment will be slightly different. </p><br><p><img src="https://habrastorage.org/webt/6e/em/ho/6eemho6eltp2dvhtzuj8zsi7abm.png"><br></p><br><p>  It will be a point inside the JVM called <code>method__entry</code> , and with it you can trace any Java method.  To indicate which particular method we are interested in, we substitute a condition that requires that <code>arg4</code> (this method name) be equal to <code>gc</code> .  Probably I should also add a check on the name of the class, which should be <code>System</code> .  Then I type the message, and after it the call stack.  Finally, all this should be done only with Java processes.  Next is the output that has the call and stack traces for each <code>System.gc()</code> call in this application.  We see that this is the same code as last time, <code>DataFetcher::fetchData</code> , called upon <code>RequestProcessor::processRequest</code> , etc. </p><br><p>  This is an honest full stack, it has both java-frames and native frames from the JVM, and it leads us all the way through, up to the root thread in Linux.  Absolutely everything can be seen here.  Such here came an example of what you need to overcome in order to get to such data. </p><br><p>  A few more examples of the motivation behind such work ... Let's move from examples to the already mentioned problem - what's wrong with <em>perf</em> ?  This tool is mentioned in every monitoring or tracing report of Java applications in production on Linux.  As I already mentioned, the next after mine will be a report on the new and original way of using <em>perf</em> for sampling CPU cycles in Java applications. </p><br><p><img src="https://habrastorage.org/webt/n7/3j/u9/n73ju9xwhm0bumrjlxishnj5ilg.png"><br></p><br><p>  With <em>perf,</em> we act simply - first we write down, then we process the record, we get, for example, a flamegraph.  Most likely, some are aware of this use of <em>perf</em> .  The problem I‚Äôm going to talk about is connected with <em>BPF</em> and with the thought that I would like most of all to convey to you.  For its work, <em>perf</em> transfers a large amount of data to the usespace through a file for later analysis.  I put an experiment: I created a virtual machine on a certain cloud, connected to this machine and downloaded the file at a speed of about 1 Gbit / s.  I don‚Äôt have such a connection at home, which is why I said that this is a virtual machine on a cloud.  As a result, I got about 90 thousand events <code>netif_receive_skb</code> .  I could record this using <em>perf</em> to trace the data my system receives, trace delays and packet sizes.  But at the same time, 90 thousand events per second will be output, and when recording call stacks, this is 20 megabytes of data per second written to the file.  Obviously, in production, as a rule, it is not done, and it is clearly undesirable to perform such work for more than a minute, as the hard disk space will simply run out.  In this case, we may be interested only in 5 bytes from these 20 megabytes per second, for example, the average packet size, or the average delay between receiving a packet and delivering it to a Java application, or something similar.  We do not need 20 megabytes per second, but this is exactly how <em>perf</em> works - events are shipped to a file, and then the program is launched in the user space that analyzes this file.  This is exactly the problem we are trying to solve.  We are trying to move processing closer to the immediate data collection, to the trace program, and to avoid creating any files if we don‚Äôt need them ourselves. </p><br><p><img src="https://habrastorage.org/webt/of/ya/gc/ofyagc6ljp0vwikeezdjplit5d8.png"><br></p><br><p>  And here I want to introduce you to BPF, stands for <em>‚ÄúBerkley Packet Filter‚Äù</em> .  The tool exists since the beginning of the 90s.  I would not like the report to turn into a history lesson, just trying to show that the basis here is very mature.  <em>BPF</em> was created to filter packets, to trace incoming packets, and to decide whether to pass them or not.  <em>tcpdump</em> , <em>Wireshark</em> or similar tracking tools use it when you specify from which IP addresses you want to receive packets, with which protocols.  Both <em>tcpdump</em> and <em>Wireshark</em> in such cases create a small BPF program with its own set of instructions, pass it to your kernel, and it then runs this program for each incoming packet to decide whether to remove this packet or trace it.  On the slide in front of us is this set of instructions, which is just another assembler.  In the 90s, this instruction set was extremely simple.  But over the last 3-4 years, much effort has been made to ensure that BPF can be used not only for network purposes, not only for packet filtering.  Today, its function includes tracing, and my main focus will be on it.  The <em>trace</em> tool I demonstrated above uses <em>BPF</em> .  But <em>BPF</em> has other features.  In addition, like Java, <em>BPF</em> now has a JIT compiler.  This instruction set is no longer interpreted by the kernel; instead, it compiles them into machine code, into processor instructions, and then executes them. </p><br><p>  Above, I said that <em>SystemTap</em> has a problem, which is that it loads a dynamically compiled kernel module.  This is not the same as <em>BPF</em> .  In the latter case, the set of instructions is not arbitrary, it was specially selected to avoid security problems.  A bad <em>BPF</em> program cannot drop or suspend the core.  <em>BPF</em> programs do not allocate memory, and therefore cannot cause a memory leak in the kernel.  All the functions of these programs are severely limited so that they do not harm production. </p><br><p>  I'll tell you briefly about some of the scenarios, before moving on to the main topic, the trace.  One of the crucial uses of <em>BPF</em> today, which can be heard at network conferences - <em>XDP (eXpress Data Path)</em> .  Suppose you are creating a service for protection against DDoS attacks (for example, <em>Cloudflare</em> ).  You need to remove packages as quickly as possible, without processing them and not transferring them.  In this case, before the packet goes into the kernel, onto the TCP stack, or into any application, a <em>BPF</em> program is executed that decides whether to remove the packet, pass it on to someone else, or send it up to the top.  This is one example of setting up dynamic rules for your system using <em>BPF</em> . </p><br><p>  Another example of the same kind is <em>seccomp</em> .  In Linux today, you can install a <em>BPF</em> program to filter the system calls of a particular application.  An application can deny access to a specific file, while allowing calls to other files.  You can prevent writing to the hard disk, while allowing you to read from it.  Thanks to this filter of interactions with the system, the <em>BPF</em> program creates a kind of sandbox. </p><br><p>  We will mainly talk about using <em>BPF</em> to trace events on your system, for example, garbage collection, as well as tracing method calls, which I have already mentioned when I showed trace.  The system has different attachment points; at the application level, it is garbage collection, object allocation, and class loading in Java applications.  In addition, there are many attachment points at the kernel level, for example, receiving packets, <code>write</code> and <code>read</code> system calls.  In user space, there is a monitoring program that installs a program on the BPF in the kernel, and then attaches it to events of interest to us.  When these events occur, the program in the kernel is executed, and it can do one of two things.  It can transfer information to the user space, and at the same time it essentially works as a trace facility.  This is how my program works, it prints its output through a script in a user space.  Alternatively, the program may update the in-memory data structure that performs the aggregation.  Instead of transferring data to the user space for further analysis, you can perform aggregations directly in the core, get averages, maxima, minima, histograms, etc.  where the tracer works, while not transmitting millions of events.  This is the key difference of <em>BPF</em> , which makes it so valuable and gives it an advantage over <em>perf</em> . </p><br><p>  When the program in the kernel has completed, your script in the userspace reads data from the buffer or from the data structure, and does with it what you need: it displays messages on the screen, draws graphs, histograms, etc.  Unlike perf, files are not created anywhere unless you need them. <br>  Why is this tool not generally accepted?  First of all, because it is brand new.  To use any <em>BPF</em> programs <em>involved in tracing and performance monitoring</em> , you need at least a <code>4.1</code> Linux kernel, which is only a few years old.  In <em>Ubuntu 14</em> or <em>CentOS 5,</em> it is not.  For the most useful things you need an even newer core.  Let's look at the example of <em>Fedora</em> and <em>Ubuntu</em> .  In <em>Ubuntu 16 LTS,</em> you can use many features of <em>BPF</em> , in <em>Ubuntu 16.10</em> you can use almost everything.  The newest functionality added by <em>BPF</em> requires kernel version <code>4.9</code> , which was released just a few months ago.  Therefore, many things may not work directly today, or work only on certain systems with a fairly new kernel.  But the future of tracing under Linux is precisely <em>BPF</em> .  This applies to both Java, and Python, and C ++ - any language that runs under Linux.  The reason lies in the ability to execute the trace program in the kernel and perform complex actions there, such as updating the correspondence tables and histograms, instead of transferring all the data to the usespace for subsequent analysis. </p><br><p>  Compare the old and new methods.  As a rule, when using <em>perf</em> , data is shipped to a file, then the file is processed and analyzed.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPF,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> analysis and aggregation take place in the kernel, and a small correspondence table is updated. </font><font style="vertical-align: inherit;">The trace tool then only needs to read from this table and display the result. </font><font style="vertical-align: inherit;">Thus, there is a significant unloading of channels between the core and user space, and significantly less resources are consumed.</font></font></p><br><p>    .  ,   ,       <em>BPF</em> ,        .             <em>BCC</em> .     ,  ..  ,     , , ,   - Linux.       .       . </p><br><p><img src="https://habrastorage.org/webt/zc/8f/ww/zc8fwwvgbmy-isu3z4xjfhmbc_c.png"><br></p><br><p>  <em>BCC</em>   .     ‚Äî     ,     .      -  ,         .          , ,  ,      ,   Java, MySQL, Postgres       ,        .  ,       ,   ,         ,           <em>BPF</em> . </p><br><p><img src="https://habrastorage.org/webt/u4/9k/x4/u49kx4e3fdhh7kbo8upg5a84jts.png"><br></p><br><p>         ,     .   , ,  ,        ,        , ,     .         ,  ,     IO.       ,    TCP   TCP.        DNS.     ,   .   ,   ,     ‚Äî       .  ,       Java. </p><br><p>   ,    .    ,     .      .      ,   ,      BPF. </p><br><p><img src="https://habrastorage.org/webt/u4/9k/x4/u49kx4e3fdhh7kbo8upg5a84jts.png"><br></p><br><p>   <em>top</em>  ,      100%.       ,  ,  .     <em>BCC</em> ‚Äî <em>uthreads</em> .   ,   Java-,           .       ,       .  ,         .    <em>profile</em> ,     (      <em>perf</em> ).  <em>profile</em>   Java,  ,       PU,     .        ,     .   Java,  Java-,  ‚Äî    .     ,     <em>perf</em>     ‚Äî   ,  java-,    ‚Äî       . </p><br><p><img src="https://habrastorage.org/webt/h8/4r/it/h84ritdf6mhcejeu67ekd7mi2pi.png"><br></p><br><p>     ,        .       ,     .       ,      .   ,   .   ,         .      ,    ,     . ,    ,     .       dd,  dnf,  Java   <em>stress</em> . ,      ,       Java.   Java    ,       ‚Äî <code>Prime::isPrime</code> , ,     .       ?   ,       ,     .   <code>isPrime</code>   ,       ,    ,  ,  <code>isPrime</code>   .  ,       .          ,     ,        .  ‚Äî  , , ,     CPU,       . ,     ,      <em>BPF</em> ,  ,          . </p><br><p><img src="https://habrastorage.org/webt/zl/0p/dp/zl0pdpxp6eglywbjub9jmjki0-k.png"><br></p><br><p>      .    ,     ,       :    ,  ,      <i>( <code>if(isPrime(i))</code>  )</i> .  ,       ?    ?  ,       Java-  ,      ?       BCC, argdist.         ,    .  ,     : <code>monitor__contended__enter()</code> ,   JVM. Argdist     5 ,     .  ,      ‚Äî 3 , 9 .   - ,    3  9    5 ,      .   ,          ,    .   ,       .       ,     ,   JVM. </p><br><p>         CPU,   ,   Java-    , , ,  .   Java-,  ,       MySQL.      ,    .   ,    ,          .  ,             ,             50 ,            . </p><br><p><img src="https://habrastorage.org/webt/8k/tx/er/8ktxerpp75ahz5i3zhfzx8uk4f0.png"><br></p><br><p>  ,      <em>dbstat</em>  <em>BCC</em> .      MySQL  PostgreSQL.     ,      ,          .    MySQL   ASCII-    (     ,       ). 3000    0  1 ,   8    1  2 ,   .                .     MySQL. <em>dbstat</em>      , ,   ,    5 .      ,    2 ,      . </p><br><p><img src="https://habrastorage.org/webt/7w/zc/ya/7wzcyautzsc8o_ndiwlbdvbrkem.png"><br></p><br><p> ,       MySQL.    top ,     2%  ,      .    ,   BCC dbslower.    MySQL   ,      ‚Äî    500.   dbslower ,          , <code>call getproduct(97)</code> .       ,     ? </p><br><p><img src="https://habrastorage.org/webt/o0/o5/c7/o0o5c76bmjl4ji02hb-bkpu22ka.png"><br></p><br><p>     ,    <em>trace</em> ,      .        MySQL <code>query__exec__start</code>      ,       .   trace  ,    <code>call getproduct(97)``    </code> sleep(2)`. ,      ,      ‚Äî    sleep(2).  ,       ,     . </p><br><p><img src="https://habrastorage.org/webt/d_/iy/fu/d_iyfuljo1g2lscy2pvxot9ylk8.png"><br></p><br><p>  ,         .    Java-,         .     .   Java    ,         , <em>mysqlsniff</em> .     .   BPF        Java   , , , <code>socket.send()</code> .         MySQL.    ,   ,   .      ,   ,        .     ,      <code>call getproduct(97)</code> .      ,   hibernate, beans  .,   JDBC,   .     ‚Äî   , <code>Product::load</code> , <code>User::loadProducts</code> , <code>Databaseey::main</code>  ..    ,     ,      .        , <em>Wireshark</em> ,    ,      .        ,   <em>BPF</em>  ,   MySQL ,  ,        .       ,  ,    ‚Äî   . <br> ,         .   MySQL         ,     Java.   Java      ,        <em>BCC</em> ,       . <br> ,    ,   . ,           ,   ,     . </p><br><p><img src="https://habrastorage.org/webt/fx/dt/nh/fxdtnhc0onrzvlhgua2hpkx8emm.png"><br></p><br><p>   ,         ,   .  Java-,    .         .NET, , , .     top,  ,      ,      <em>BCC ustat</em> .        Java,        .   800, , ,  , , ,    .        profile,  ,      .     <code>ResponseBuilder::addLine</code> ,      ,          . </p><br><p><img src="https://habrastorage.org/webt/iv/dn/hl/ivdnhlqjmbj2uij2_kkhn94jank.png"><br></p><br><p>    ,  BCC        Java, Ruby     ‚Äî uobjnew.      ,     <em>ExtendedDTraceProbes</em> .  ,       ,     ,    ,    .  5       ,        Java.          ,            .   uobjnew  ,     ,  ,  .    ,       ,         ‚Äî <em>stackcount</em> .       <code>object__alloc</code>  JVM,      ,       .    ,       ,     .     ,    : <code>_new_array_Java</code> ,  <code>ResponseBuilder::AddLine</code> . ,       ‚Äî  JVM,    <code>SharedRuntime::dtrace_object_alloc</code> ‚Äî     . <br> ,  ,      .     ,     ,  ,         . -,        ,     ,     . </p><br><p><img src="https://habrastorage.org/webt/ub/vn/kj/ubvnkjv96han-izpdsnugwld2ni.png"><br></p><br><p>   .  ,    ,       ‚Äî ¬´  ¬ª.       ,       ,  ,    ,  ?         opensnoop,                   .  -x   .  ,          <code>/etc</code> ,    ‚Äî 2,   Linux  ¬´  ¬ª,   . ,  ,          .    trace.       open,       ¬´-2¬ª.       Java.         .  ,        , ,        .  ,       Java. </p><br><p>   ,      . HTTP-       .       ,      .      ,  ,  ,    ,    1.4-2 .        6  ‚Äî , -   .       ‚Äî facebook.com,   ‚Äî i-dont-exist-at-all.com, . .  .   ,    ,   5 . </p><br><p>  ,  ,  DNS    ,       .         .  BCC      DNS.    DNS         .  ,       DNS       ,             .     .    ,    ?   trace  ,    ¬´-2¬ª, ¬´   ¬ª,  . </p><br><p><img src="https://habrastorage.org/webt/ej/sr/xm/ejsrxmlij5w4vg_7zfnsynonh2u.png"><br></p><br><p>    <em>dig</em> ‚Äî ,  , ,     ,    BCC.    DNS  i-dont-exist-at-all.com dig   :   ,    ,      ,   15    , . .         .      ¬´ ¬ª   0,       .        <em>dig</em> .      DNS. </p><br><p><img src="https://habrastorage.org/webt/jz/go/z5/jzgoz5xubyyhad_4lseqafe9c7k.png"><br></p><br><p>         .  ,     DNS-,   ,    800  - .      -   . ,            DNS   <code>0</code> . ,     ,    Java     DNS     .       ,     ,       <em>BPF</em> ,   DNS. <br>   ,       ,     :    ,     JVM-;  BPF      Linux;   ;     .    . </p><br><p><img src="https://habrastorage.org/webt/dz/7s/pm/dz7spmgd228j8tn1d77hqpwxpaw.png"><br></p><br><img src="https://habrastorage.org/webt/n2/j-/qk/n2j-qkkwialr640g2nzoyul4zb0.png"><br><hr><br><blockquote>  Minute advertising.  As you probably know, we do conferences.  ‚Äî <a href="http://jbreak.ru/">JBreak 2018</a>  <a href="https://jpoint.ru/">JPoint 2018</a> .           ,    <a href="https://2018.jbreak.ru/speakers/6v9tls2dwwae4s6gcs4kkk/">Simon Ritter</a> ‚Äî Deputy CTO  Azul Systems.     c <a href="https://2018.jbreak.ru/speakers/7fuk0541rsoqggsgsicsi0/"> </a>  " "     .     ( <a href="https://habrahabr.ru/users/olegchir/" class="user_link">olegchir</a> )   .  In short, come in, we are waiting for you. </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348912/">https://habr.com/ru/post/348912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348898/index.html">Slack is the opposite of organizational memory.</a></li>
<li><a href="../348900/index.html">Blockchain and medicine: 4 startups in the field of health care that are worth following</a></li>
<li><a href="../348902/index.html">Slightly reduce the action</a></li>
<li><a href="../348906/index.html">Dynamic generation of proxy classes in Java</a></li>
<li><a href="../348908/index.html">Reactive applications with Model-View-Intent. Part 3: State Reducer</a></li>
<li><a href="../348914/index.html">The random () function of a googleblock works absolutely deterministically.</a></li>
<li><a href="../348916/index.html">How to deploy HD Wi-Fi for 45 thousand fans in 10 days? Stadium "Spartacus" in anticipation of the 2018 World Cup</a></li>
<li><a href="../348918/index.html">O'Zhal: What's wrong with flexible methodologies</a></li>
<li><a href="../348920/index.html">Why don't people buy your game</a></li>
<li><a href="../348922/index.html">Privacy: birth and death. 3000 years of privacy history in pictures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>