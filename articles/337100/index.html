<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Be careful with what you measure - MJIT vs TruffleRuby: 2.1 times slower or 4.2 times faster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you seen the results of the MJIT benchmarks ? They are amazing, right? MJIT literally makes all other implementations without options. Where has ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Be careful with what you measure - MJIT vs TruffleRuby: 2.1 times slower or 4.2 times faster</h1><div class="post__text post__text-html js-mediator-article">  Have you seen the <a href="https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch">results of the MJIT benchmarks</a> ?  They are amazing, right?  MJIT literally makes all other implementations without options.  Where has he been all these years?  Everything is now finished with the race? <br><br>  However, you can understand from the headline that not everything is so simple.  But before you understand the problems of these particular benchmarks (of course, you can scroll down to nice charts), you need to consider the important basic basics of benchmarking. <br><br><h2>  Mjit?  TruffleRuby?  What is all this? </h2><br>  <a href="https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch">MJIT</a> is a Ruby branch on Github from <a href="https://www.linkedin.com/in/vladimir-makarov-1449859/%3Fppe%3D1">Vladimir Makarov, a GCC developer</a> , which implements a dynamic JIT compilation ( <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Just In Time Compilation</a> ) on the most popular Ruby interpreter - CRuby.  This is <a href="https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch">not the final version, on the contrary, the project is at an early stage of development</a> .  The promising benchmark results were published on June 15, 2017, and this is the main topic of discussion in this article. <br><a name="habracut"></a><br>  <a href="https://github.com/graalvm/truffleruby">TruffleRuby</a> is an implementation of Ruby on GraalVM from Oracle Labs.  It shows impressive performance results, as you could see in my previous article ‚Äú <a href="https://pragtob.wordpress.com/2017/01/24/benchmarking-a-go-ai-in-ruby-cruby-vs-rubinius-vs-jruby-vs-truffle-a-year-later/">Ruby plays Go Rumble</a> ‚Äù.  It also implements JIT, it needs a little warm-up, but in the end it is about 8 times faster than Ruby 2.0 in the aforementioned benchmark. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Before continuing ... </h2><br>  I have incredible respect for Vladimir, and I think that MJIT is an extremely valuable project.  In fact, this may be one of the few attempts to introduce JIT into standard Ruby.  JRuby has had JIT for many years and it demonstrates good performance, but this implementation has never become really popular (this is a topic for another article). <br><br>  I am going to criticize the way the benchmarks were conducted, although I admit that there could be some reasons for this that I missed (I will try to point out those that are known to me).  In the end, Vladimir is engaged in programming much longer than I generally live in the world, and obviously knows more about my language implementations. <br><br>  And once again, this is not a matter of the developer‚Äôs personality, but of the way in which benchmarks are conducted.  Vladimir, if you read this, <img src="https://habrastorage.org/web/a03/4ef/20b/a034ef20b789493aa927c08c3166bd91.png"><br><br><h2>  <b>What do</b> we measure? </h2><br>  When you see the results of benchmarks, the first question is: ‚ÄúWhat was measured?‚Äù Here the answer is twofold: code and time. <br><br><h2>  What code do we measure? </h2><br>  It‚Äôs important to know what code tests actually measure: is it relevant to us, is it a good Ruby program?  This is especially important if we are going to use benchmarks as a performance indicator for a particular implementation of Ruby. <br><br>  If you look at the list of benchmarks in the README file (and scroll down to a <a href="https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch">description of what they mean</a> or <a href="https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch/MJIT-benchmarks">examine their code</a> ), then you will see that almost the entire upper half is micro-tests: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75a/e21/2f1/75ae212f15253c431801a20d18cc5ef0.png"><br><br>  Here you can write to instance variables, read constants, calls to an empty method, while loops, and so on.  These are extremely miniature tests, maybe interesting from the point of view of language implementers, but not very much reflecting the actual performance of Ruby.  The day the search for a constant becomes a bottleneck in the performance of your Ruby application will be the happiest day.  And what part of your code contains while loops? <br><br>  Most of the code here (not counting micro examples) is not quite what I would call typical Ruby code.  Much more like a mix of scripts and C-code.  In many places, classes are not defined, while and for cycles are used instead of the more common Enumerable methods, and in some places even bit masks are used. <br><br>  Some of these designs could result from optimization.  Apparently, they are used in <a href="http://benchmarksgame.alioth.debian.org/">common language tests</a> .  This is also dangerous, although most of them are optimized for one particular platform, in this case CRuby.  The fastest Ruby code on one platform may be much slower on other platforms due to implementation details (for example, a <a href="https://www.youtube.com/watch%3Fv%3DUQnxukip368">different String implementation is</a> used in TruffleRuby).  Naturally, because of this, other implementations are at a disadvantage. <br><br>  Here the problem is a little deeper: whatever is contained in the popular benchmark, it will inevitably be better optimized for some implementation, but this code should be as close as possible to the real one.  Therefore, I am very pleased with the <a href="https://blog.heroku.com/ruby-3-by-3">benchmarks of the Ruby 3 √ó 3 project</a> , these new tests show as if a more relevant result. <br><br><h2>  What time do we measure? </h2><br>  This is actually my favorite part of the article and <b>undoubtedly the most important</b> .  As far as I know, the time measurements in the original article were made as follows: <code>/usr/bin/time -v ruby $script</code> , and this is one of my favorite benchmark errors for programming languages ‚Äã‚Äãthat are widely used in web applications.  You can hear more about this in my speech at the conference <a href="https://www.youtube.com/watch%3Fv%3DpolavOwhYRE">here</a> . <br><br>  What is the problem?  Well, let's analyze what is included in the overall result, when we measure only <i>the</i> execution <i>time of</i> the script: start, warm up and execution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d89/528/0c9/d895280c9d1c3a3a1094f552a5b7721d.png"><br><br><ul><li>  <b>The launch</b> is the time before we do something ‚Äúuseful‚Äù like running the Ruby Interpreter and parsing the code.  For reference, the execution of an empty Ruby file using standard Ruby takes me 0.02 seconds, in MJIT - 0.17 seconds, and <b>in TruffleRuby - 2.5 seconds</b> (although there are <a href="http://nirvdrum.com/2017/02/15/truffleruby-on-the-substrate-vm.html">plans to significantly reduce this time using Substrate VM</a> ).  These seconds are essentially added to each benchmark, if you measure just <i>the</i> runtime of the script. </li><li>  <b>Warming up</b> - time before the program starts to work at full speed.  This is especially important for implementations on JIT.  At a high level, the following happens: they see which code is called most often, and try to further optimize it.  This process takes a lot of time, and only after its completion can we talk about achieving real ‚Äúpeak performance‚Äù.  <b>On warming up, the program can run much slower than at peak performance</b> .  Below we will analyze the warm-up timings in more detail. </li><li>  <b>Execution</b> is what we call ‚Äúpeak performance‚Äù - with fixed execution times.  By this stage, most or all of the code is already optimized.  This is the level of performance at which code will be executed from now on and in the future.  Ideally, you need to measure this performance, because more than 99.99% of the time our code will be executed in the already heated state. </li></ul><br>  Interestingly, the <a href="https://github.com/vnmakarov/ruby">original benchmark confirms the</a> presence of start-up and warm-up times, but these indicators are processed in such a way that their effect softens, but does not completely disappear: ‚ÄúMJIT starts up very quickly, unlike JRuby and Graal Ruby.  To even out the odds for JRuby and Graal Ruby, the benchmarks are modified so that the Ruby MRI v2.0 works for 20‚Äì70 s on each test. ‚Äù <br><br>  I believe that in a more well-designed testing scheme, <b>the load and warm-up time does not affect</b> the result, if our goal is to test performance in a long-term process. <br><br>  Why?  Because web applications, for example, are usually long-term processes.  We run a web server - and it works hours, days, weeks.  <b>We spend time on loading and warming up only once at the very beginning, and then the process</b> takes a <b>long time</b> until we turn off the server.  Normal servers should operate in a heated state for more than 99.99% of the time.  This is a fact that our benchmarks should reflect: how to <b>get the best performance during the hours / days / weeks of the server, and not in the first seconds or minutes after the download</b> . <br><br>  As a small analogy, you can bring a car.  You are going to drive 300 kilometers in minimum time (in a straight line).  Measurement as in the table above can be compared with the measurement of approximately the first 500 meters.  Get in the car, accelerate to maximum speed and maybe a little drive at the peak.  Is the fastest car really going to drive 300 kilometers faster than anyone in the first 500 meters?  Probably not.  (Note: I am not good at cars). <br><br>  What does this mean for our benchmark?  Ideally, we need to remove the load and warm up time from it.  This can be done using the Ruby test library, which first runs the benchmark several times before taking actual measurements (warm-up time).  We use my <a href="https://github.com/PragTob/rubykon/tree/master/lib/benchmark">own small library</a> because it does not need a gem and it is well suited for long-term testing. <br><br>  Do boot and warm up times really matter?  Have  Most noticeably, they affect the development process ‚Äî start the server, reload the code, run tests.  For all these tasks, you need to "pay" the time of loading and warming up.  Also, if you are developing a UI application or CLI tool for end users, the load and warm-up times can be a problem, since the load happens much more often.  You can‚Äôt just warm it up before sending it to the load balancer.  Another periodic start of processes like cronjob on the server also forces you to waste time on loading and warming up. <br><br>  So, is there any advantage to measuring the boot and warm up time?  Yes, it is important for one of the above situations.  And the measurement with the <i>time -v</i> parameter produces much more data: <br><br> <code>tobi@speedy $ /usr/bin/time -v ~/dev/graalvm-0.25/bin/ruby pent.rb <br> Command being timed: "/home/tobi/dev/graalvm-0.25/bin/ruby pent.rb" <br> User time (seconds): 83.07 <br> System time (seconds): 0.99 <br> Percent of CPU this job got: 555% <br> Elapsed (wall clock) time (h:mm:ss or m:ss): 0:15.12 <br> Average shared text size (kbytes): 0 <br> Average unshared data size (kbytes): 0 <br> Average stack size (kbytes): 0 <br> Average total size (kbytes): 0 <br> Maximum resident set size (kbytes): 1311768 <br> Average resident set size (kbytes): 0 <br> Major (requiring I/O) page faults: 57 <br> Minor (reclaiming a frame) page faults: 72682 <br> Voluntary context switches: 16718 <br> Involuntary context switches: 13697 <br> Swaps: 0 <br> File system inputs: 25520 <br> File system outputs: 312 <br> Socket messages sent: 0 <br> Socket messages received: 0 <br> Signals delivered: 0 <br> Page size (bytes): 4096 <br> Exit status: 0</code> <br> <br>  You get a lot of information, including memory usage, CPU, elapsed time (wall clock) and more, which is also important for evaluating language implementations and therefore also <a href="https://github.com/vnmakarov/ruby">included in the original benchmarks</a> . <br><br><h2>  Configuration </h2><br>  Before we (finally!) Move on to benchmarks, we need the obligatory part ‚ÄúThis is the system on which the measurements were taken‚Äù. <br><br>  The following versions of Ruby were used: MJIT from <a href="https://github.com/vnmakarov/ruby/commit/aab4c2701e6aa7e2994b13444f1633340901253e">this commit for August 25, 2017</a> , compiled without special settings, graalvm 25 and 27 (more on this later) and CRuby 2.0.0-p648 as the base level. <br><br>  All this was run on my desktop PC under Linux Mint 18.2 (based on Ubuntu 16.04 LTS) with 16 GB of memory and an <a href="https://ark.intel.com/products/80806/Intel-Core-i7-4790-Processor-8M-Cache-up-to-4_00-GHz">i7-4790</a> processor <a href="https://ark.intel.com/products/80806/Intel-Core-i7-4790-Processor-8M-Cache-up-to-4_00-GHz">(3.6 GHz, 4 GHz turbo)</a> . <br><br> <code>tobi@speedy ~ $ uname -a <br> Linux speedy 4.10.0-33-generic #37~16.04.1-Ubuntu SMP Fri Aug 11 14:07:24 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</code> <br> <br>  It seems to me especially important to mention the configuration here, because when I <a href="https://pragtob.wordpress.com/2017/07/09/slides-stop-guessing-and-start-measuring-poly-version/">first did tests for the Polyconf conference</a> on my dual-core laptop, the results of TruffleRuby were much worse.  I think that graalvm wins from two additional cores for warming up, etc., since the CPU utilization by cores is quite high. <br><br>  You can check the script for testing and everything else in <a href="">this repository</a> . <br><br><h2>  But ... you promised the benchmarks, where are they? </h2><br>  Sorry, it seemed to me that the theory is more important than the test results themselves, although they no doubt help to illustrate the thesis.  First, I will explain why I chose the benchmark <i>pent.rb</i> and why I ran it on slightly older versions of graalvm (don't worry, the current version is also in effect).  And then, finally, there will be graphs and numbers. <br><br><h2>  Why is this benchmark? </h2><br>  First of all, the original performance tests were launched on graalvm-0.22.  An attempt to reproduce the results from the current (at the moment) version of graalvm-0.25 turned out to be difficult, since many of them were already optimized (and version 0.22 contains several authentic performance bugs). <br><br>  The only benchmark where I was able to reproduce performance problems was <i><a href="">pent.rb</a></i> , and it also most clearly showed an anomaly.  In the original benchmarks, it is marked as 0.33 Ruby 2.0 performance (that is, three times slower).  But all my experience with TruffleRuby said that this is probably wrong.  So I excluded him not because he was the fastest at TruffleRuby, but on the contrary - <b>he was the slowest</b> . <br><br>  Moreover, although this is in many ways not the most characteristic Ruby code, in my opinion (there are no classes, many global variables), many Enumerable methods are used there, such as each, collect, sort and uniq, while bitmasks are missing, and like that  So it seemed to me that here, too, I would receive a relatively good candidate. <br><br>  The original benchmark was placed in a loop and repeated several times, so that you can measure the warm-up time, and then the average work time at the peak of performance. <br><br>  So why did I launch it on the old version of graalvm-0.25?  Well, whatever is optimized for the benchmark, the difference here will be less obvious. <br><br>  Benoit Dalouz writes in a tweet below that he optimized the warm-up time of the TruffleRuby for this benchmark, so now TruffleRuby is three times faster than MJIT.  He notes that the benchmark code <i>pen.rb</i> <a href="https://gist.github.com/eregon/d75343884518fe4be72c95008ccb05ae">uses a global variable</a> instead of an argument to pass the value to the method. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="884351478495891458"></twitter-widget><script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Later we will test the new improved version. <br><br><h2>  MJIT vs Graalvm-0.25 </h2><br>  So, on my machine, the initial execution of the <i>pent.rb</i> benchmark (boot time, warm-up and execution) on TruffleRuby 0.25 took 15.05 seconds and only 7.26 seconds on MJIT.  That is, MJIT was 2.1 times faster.  Impressive! <br><br>  But what is not to take into account the load and warm up?  What if you start the measurement after the interpreter starts?  In this case, we run the code in a cycle for 60 seconds to warm up, and then measure the real performance for 60 seconds.  The diagram shows the test execution time for the first 15 iterations (after that the TruffleRuby is stabilized): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1dc/37e/139/1dc37e139da412c1057199bf0293c232.png"><br>  <font color="gray">Runtime in TruffleRuby and MJIT gradually changes - iteration after iteration</font> <br><br>  As you can see, <b>TruffleRuby starts much slower, but then quickly picks up speed, while MJIT continues to work more or less the same</b> .  Interestingly, TrufleRuby again slows down in iterations 6 and 7. Or he found a new optimization, which took considerable time to complete, or de-optimization occurred because the limitations of the previous optimization were no longer valid.  After that, the TruffleRuby will stabilize and reach peak performance. <br><br>  When we start the benchmark after warming up, we get an average time of 1.75 seconds for TruffleRuby, and 7.33 seconds for MJIT.  That is, with this method of measurement, <b>TruffleRuby is unexpectedly 4.2 times faster than MJIT</b> . <br><br>  <b>Instead of 2.1 times slower, we got results 4.2 times faster by simply changing the measurement method.</b> <br><br>  I like to present the test results as the number of iterations per second / minute (ips / ipm), because here the more the better, so the graphs come out more intuitive.  Our runtime is converted at 34.25 iterations per minute for TruffleRuby and at 8.18 iterations per minute for MJIT.  So now look at the test results, converted as iterations per minute.  Here we compare the original measurement method and our new method: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cb/066/176/9cb06617619edef257ecdbc7517c1e0b.png"><br>  <font color="gray">The number of iterations per minute when the entire script is executed (the initial time) and the number of iterations after warming up</font> <br><br>  The big difference in TruffleRuby results is due to a long warm-up time during the first few iterations.  MJIT, on the other hand, is very stable.  The difference is quite within the statistical error. <br><br><h2>  Ruby 2.0 vs MJIT vs Graalvm-0.25 vs GRAALVM-0.27 </h2><br>  So, I promised you more data, and here they are!  This dataset also includes CRuby 2.0 indicators as a baseline for comparison, as well as a new graalvm. <br><br><table><tbody><tr><td align="left"></td><td align="left">  initial time (sec) </td><td align="left">  ipm start time </td><td align="left">  average (s) </td><td align="left">  ipm average after warming up </td><td align="left">  standard deviation as part of the total </td></tr><tr><td align="left">  CRuby 2.0 </td><td align="right">  12.3 </td><td align="right">  4.87 </td><td align="right">  12.34 </td><td align="right">  4.86 </td><td align="right">  0.43% </td></tr><tr><td align="left">  TruffleRuby 0.25 </td><td align="right">  15.05 </td><td align="right">  3.98 </td><td align="right">  1.75 </td><td align="right">  34.25 </td><td align="right">  0.21% </td></tr><tr><td align="left">  TruffleRuby 0.27 </td><td align="right">  8.81 </td><td align="right">  6.81 </td><td align="right">  1.22 </td><td align="right">  49.36 </td><td align="right">  0.44% </td></tr><tr><td align="left">  Mjit </td><td align="right">  7.26 </td><td align="right">  8.26 </td><td align="right">  7.33 </td><td align="right">  8.18 </td><td align="right">  2.39% </td></tr></tbody></table><br><img src="https://habrastorage.org/getpro/habr/post_images/5df/d76/dc4/5dfd76dc4df4d835968705ec3f0cd957.png"><br>  <font color="gray">The execution time of each iteration in seconds.</font>  <font color="gray">CRuby results fade because iterations are over</font> <br><br>  We see that TruffleRuby 0.27 is faster than MJIT already from the first iteration, which is quite impressive.  He also avoided a strange deceleration around the sixth iteration and therefore reached peak performance much faster than TruffleRuby 0.25.  The new version has generally become generally faster if we compare the performance after warming up all four competitors: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/561/05b/06e/56105b06e6e3f057543c199f13ccd285.png"><br>  <font color="gray">Average number of iterations per minute after warming up for four test participants</font> <br><br>  So in TruffleRuby 0.27, not only accelerated warming up, but overall, the performance improved slightly.  Now it is more than 6 times faster than MJIT.  Of course, this was partially due to the fact that the developers of TruffleRuby probably implemented optimization for the existing benchmark.  This once again underlines my thesis that we need better performance tests. <br><br>  As a final fancy diagram, I have a comparison of the total runtime of the script (through <i>time</i> ) and performance after warming up, by the number of iterations per minute. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71c/75d/471/71c75d47130d8f58304aba936e4a23a8.png"><br>  <font color="gray">The difference between the total run time of the script (iterations per minute) and performance after warming up</font> <br><br>  As expected, CRuby 2 is fairly stable, TruffleRuby immediately shows quite decent performance, but then accelerates several times.  I hope this helps you to see that <b>different measurement methods lead to radically excellent results</b> . <br><br><h2>  Conclusion </h2><br>  So what is the conclusion?  Loading time and warming up matter, and you should carefully consider how important these indicators are to you and whether they need to be measured.  For web applications, the load and warm-up time is almost irrelevant, because more than 99.99% of the time the program demonstrates performance after warming up. <br><br>  It is important not only what time we measure, but also what code.  Benchmarks should be as realistic as possible so that their results are as meaningful as possible.  Any arbitrary test on the Internet is most likely not directly related to what your application does. <br><br>  <b>ALWAYS RUN YOUR OWN BENCHMARKS AND LOOK WHAT THE CODE IS DETERMINED, HOW THIS IS HAPPENED AND WHAT TIME IS CONSIDERED AT THE BENCHMARK</b> </div><p>Source: <a href="https://habr.com/ru/post/337100/">https://habr.com/ru/post/337100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337088/index.html">Securing Network Security in the Kubernetes Cluster</a></li>
<li><a href="../337092/index.html">Artificial intelligence will save from ransomware</a></li>
<li><a href="../337094/index.html">4 ICO IT startups in September: sale of excess communications, parallel Internet and awards to open-source developers</a></li>
<li><a href="../337096/index.html">Sending an e-mail message in the 3CX Call Flow Designer development environment</a></li>
<li><a href="../337098/index.html">Creator of Node.js: ‚ÄúFor servers, I can‚Äôt imagine another language other than Go‚Äù</a></li>
<li><a href="../337102/index.html">BFQ I / O scheduler better</a></li>
<li><a href="../337106/index.html">Meeting in St. Petersburg "The role of the analyst in making important product decisions"</a></li>
<li><a href="../337108/index.html">Test asynchronous code with PyTest (translation)</a></li>
<li><a href="../337110/index.html">Getting rid of the RecyclerView.Adapter routine with DataBinding</a></li>
<li><a href="../337112/index.html">We broadcast WebRTC, RTSP and RTMP streams to Media Source Extensions via Websocket protocol</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>