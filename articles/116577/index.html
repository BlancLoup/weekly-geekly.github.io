<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the singleton pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Many are already familiar with such a term as singleton. In brief, this is a pattern that describes an object that has a single instanc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the singleton pattern</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Many are already familiar with such a term as singleton.  In brief, this is a pattern that describes an object that has a single instance.  You can create such an instance in different ways.  But now we are not talking about this.  I will also omit issues related to multithreading, although this is a very interesting and important issue when using this pattern.  I would like to tell you about the proper use of singleton. <br><a name="habracut"></a><br>  If you read the literature on this topic, then you can meet various criticisms of this approach.  I will give a <a href="http://www.rsdn.ru/forum/design/2615563.flat.aspx">list of shortcomings [1]</a> : <br><ol><li>  Singleton violates SRP (Single Responsibility Principle) - the singleton class, in addition to fulfilling its direct duties, is also engaged in controlling the number of its copies. </li><li>  The dependence of the usual class from the singleton is not visible in the public contract of the class.  Since usually a singleton instance is not passed in the method parameters, but is obtained directly through getInstance (), then to identify the dependence of the class on the singleton, it is necessary to crawl into the body of each method ‚Äî simply viewing the public contract of the object is not enough.  As a consequence: the difficulty of refactoring during the subsequent replacement of a singleton with an object containing several instances. </li><li>  Global state  About the harm of global variables, it seems everyone already knows, but here is the same problem.  When we access an instance of a class, we do not know the current state of this class, and who changed it when, and this state may not be at all as expected.  In other words, the correctness of working with a singleton depends on the order of calls to it, which causes an implicit dependence of the subsystems on each other and, as a result, seriously complicates the development. </li><li>  The presence of a singleton reduces the testability of the application in general and the classes that use the singleton, in particular.  Firstly, instead of a singleton one cannot push a Mock-object, and secondly, if Singlelton has an interface for changing its state, then tests begin to depend on each other. </li></ol><br>  Thus, in the presence of these problems, many conclude that the use of this pattern should be avoided.  In general, I agree with the above problems, but I do not agree with the fact that, based on these problems, we can conclude that you should not use singletones.  Let's take a closer look at what I mean and how to avoid these problems even when using singleton. <br><br><h4>  Implementation </h4><br>  The first thing I would like to point out: a singleton is an implementation, not an interface.  What does it mean?  This means that the class should, if possible, use some kind of interface, and whether there will be a singleton or not, it does not know and should not know it, because  any explicit use of singleton will result in these problems.  In words, it looks good, let's see how it should look in life. <br><br>  To implement this idea, we will use a powerful approach called Dependency Injection.  Its essence is that we in some way fill the implementation into a class, while the class that uses the interface does not care about who will do it and when.  He is not interested in these questions at all.  All he needs to know is how to properly use the provided functionality.  The interface of the functional can be both an abstract interface and a specific class.  In our particular case, it does not matter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The idea is, let's implement in C ++.  Here templates and the possibility of their specialization will help us.  First, let's define a class that will contain a pointer to the required instance: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class"> {</span></span> An() { clear(); } T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get0(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get0(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(T* t) { data = t; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ data = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEmpty()) reinit(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reinit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ anFill(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;An*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;init(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } T* data; };</code> </pre> <br>  The described class solves several problems.  First, it stores a pointer to the required instance of the class.  Secondly, in the absence of an instance, the anFill function is called, which fills it with the required instance if there is no such instance (the reinit method).  When a class is accessed, it is automatically initialized by the instance and invoked.  Let's look at the implementation of the anFill function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anFill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;T&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot find implementation for interface: "</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).name()); }</code> </pre><br>  Thus, by default, this function throws an exception in order to prevent the use of undeclared function. <br><br><h4>  Examples of using </h4><br>  Now suppose we have a class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> X() : counter(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ++ counter &lt;&lt; <span class="hljs-string"><span class="hljs-string">": in action"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter; };</code> </pre><br>  We want to make it a singleton for use in different contexts.  To do this, we specialize the anFill function for our class X: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> anFill&lt;X&gt;(An&lt;X&gt;&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> X x; a = &amp;x; }</code> </pre><br>  In this case, we used the simplest singleton and for our reasoning the concrete implementation does not matter.  It is worth noting that this implementation is not thread-safe (issues of multithreading will be discussed in another article).  Now we can use class X as follows: <br><pre> <code class="cpp hljs">An&lt;X&gt; x; x-&gt;action();</code> </pre><br>  Or easier: <br><pre> <code class="cpp hljs">An&lt;X&gt;()-&gt;action();</code> </pre><br>  What will display: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: in action</code> </pre><br>  When we call action again, we will see: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">2</span></span>: in action</code> </pre><br>  That says that at us the state and a copy of a class X exactly one is saved.  Now let's complicate a bit of an example.  To do this, create a new class Y, which will contain the use of class X: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class"> {</span></span> An&lt;X&gt; x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ x-&gt;action(); } };</code> </pre><br>  Now, if we want to use the default instance, then we can simply do the following: <br><pre> <code class="cpp hljs">Y y; y.doAction();</code> </pre><br>  What after the previous calls will display: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">3</span></span>: in action</code> </pre><br>  Now suppose we wanted to use another instance of the class.  This is very easy to do: <br><pre> <code class="cpp hljs">X x; yx = &amp;x; y.doAction();</code> </pre><br>  Those.  we fill the class Y with our (known) instance and call the corresponding function.  On the screen we get: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: in action</code> </pre><br>  Let us now consider the case with abstract interfaces.  Create an abstract base class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~I() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  We define 2 different implementations of this interface: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl1</span></span></span><span class="hljs-class"> :</span></span> I { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"in Impl1"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl2</span></span></span><span class="hljs-class"> :</span></span> I { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"in Impl2"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  By default, we will fill in using the first implementation of Impl1: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> anFill&lt;I&gt;(An&lt;I&gt;&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Impl1 i; a = &amp;i; }</code> </pre><br>  Thus, the following code: <br><pre> <code class="cpp hljs">An&lt;I&gt; i; i-&gt;action();</code> </pre><br>  Will conclude: <br><pre> <code class="cpp hljs">in Impl1</code> </pre><br>  Create a class using our interface: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Z</span></span></span><span class="hljs-class"> {</span></span> An&lt;I&gt; i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ i-&gt;action(); } };</code> </pre><br>  Now we want to change the implementation.  Then do the following: <br><pre> <code class="cpp hljs">Z z; Impl2 i; zi = &amp;i; z.doAction();</code> </pre><br>  What gives as a result: <br><pre> <code class="cpp hljs">in Impl2</code> </pre><br><br><h4>  Idea development </h4><br>  In general, this could be finished.  However, it is worth adding a few useful macros to make life easier: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PROTO_IFACE(D_iface) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; void anFill&lt;D_iface&gt;(An&lt;D_iface&gt;&amp; a) #define DECLARE_IMPL(D_iface) \ PROTO_IFACE(D_iface); #define BIND_TO_IMPL_SINGLE(D_iface, D_impl) \ PROTO_IFACE(D_iface) { a = &amp;single&lt;D_impl&gt;(); } #define BIND_TO_SELF_SINGLE(D_impl) \ BIND_TO_IMPL_SINGLE(D_impl, D_impl)</span></span></span></span></code> </pre><br>  Many may say that macros are evil.  I declare responsibly that I am familiar with this fact.  Nevertheless, this is part of the language and it can be used, besides, I am not subject to dogma and prejudice. <br><br>  The macro DECLARE_IMPL declares a different fill than the default fill.  In fact, this line says that for this class there will be an automatic filling with a certain value if there is no explicit initialization.  The macro BIND_TO_IMPL_SINGLE will be used in the CPP file for implementation.  It uses the single function, which returns a singleton instance: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre><br>  The use of the BIND_TO_SELF_SINGLE macro indicates that an instance of itself will be used for the class.  Obviously, in the case of an abstract class, this macro is not applicable and you must use BIND_TO_IMPL_SINGLE with the task of implementing the class.  This implementation can be hidden and declared only in a CPP file. <br><br>  Now consider the use of a specific example, such as configuration: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// IConfiguration.hpp struct IConfiguration { virtual ~IConfiguration() {} virtual int getConnectionsLimit() = 0; virtual void setConnectionLimit(int limit) = 0; virtual std::string getUserName() = 0; virtual void setUserName(const std::string&amp; name) = 0; }; DECLARE_IMPL(IConfiguration) // Configuration.cpp struct Configuration : IConfiguration { Configuration() : m_connectionLimit(0) {} virtual int getConnectionsLimit() { return m_connectionLimit; } virtual void setConnectionLimit(int limit) { m_connectionLimit = limit; } virtual std::string getUserName() { return m_userName; } virtual void setUserName(const std::string&amp; name) { m_userName = name; } private: int m_connectionLimit; std::string m_userName; }; BIND_TO_IMPL_SINGLE(IConfiguration, Configuration);</span></span></code> </pre><br>  Further it can be used in other classes: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectionManager</span></span></span><span class="hljs-class"> {</span></span> An&lt;IConfiguration&gt; conf; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_connectionCount == conf-&gt;getConnectionsLimit()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Number of connections exceeds the limit"</span></span>); ... } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_connectionCount; };</code> </pre><br><br><h4>  findings </h4><br>  As a result, I would note the following: <br><ol><li>  Explicit assignment of interface dependencies: now there is no need to look for dependencies, they are all written into the class declaration and this is part of its interface. </li><li>  Providing access to the singleton instance and the class interface are separated into different objects.  Thus, each solves his problem, thereby preserving the SRP. </li><li>  If there are multiple configurations, you can easily fill the desired instance into the ConnectionManager class without any problems. </li><li>  Testability class: you can make a mock object and check, for example, that the condition is working correctly when you call the connect method: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockConfiguration</span></span></span><span class="hljs-class"> :</span></span> IConfiguration { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnectionsLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setConnectionLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"not implemented in mock"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"not implemented in mock"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUserName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"not implemented in mock"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// preparing ConnectionManager manager; MockConfiguration mock; manager.conf = &amp;mock; // testing try { manager.connect(); } catch(std::runtime_error&amp; e) { //... } }</span></span></code> </pre><br></li></ol><br>  Thus, the described approach eliminates the problems mentioned at the beginning of this article.  In subsequent articles, I would like to touch on important issues related to lifetime and multithreading. <br><br><h4>  Literature </h4><br>  [1] <a href="http://www.rsdn.ru/forum/design/2615563.flat.aspx">Forum RDN: list of disadvantages of a singleton</a> <br>  [2] <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia: Singleton</a> <br>  [3] <a href="http://insidecpp.ru/patterns/singleton">Inside C ++: Singleton</a> </div><p>Source: <a href="https://habr.com/ru/post/116577/">https://habr.com/ru/post/116577/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116571/index.html">Creating a Comet application using Ajax Push Engine</a></li>
<li><a href="../116572/index.html">March 31 is the international day of backup!</a></li>
<li><a href="../116574/index.html">Intelligent Information Networks and the Semantic Web</a></li>
<li><a href="../116575/index.html">Determine your location via WiFi network</a></li>
<li><a href="../116576/index.html">April 1</a></li>
<li><a href="../116578/index.html">How to deal with pauses GC</a></li>
<li><a href="../116579/index.html">OpenCL: How to make this thing work</a></li>
<li><a href="../116581/index.html">Waiting for several events in nodejs</a></li>
<li><a href="../116582/index.html">Ubuntu 11.04 Beta released</a></li>
<li><a href="../116583/index.html">Mobile thumbnails</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>