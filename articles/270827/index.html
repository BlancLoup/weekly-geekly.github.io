<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL on multicore servers Power 8</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 
 With the help of IBM‚Äôs Moscow office, we tested the performance of the latest PostgreSQL DBMS on Power8 servers, examined the scalability...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL on multicore servers Power 8</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f42/619/f9e/f42619f9e4c64621908635f6d40b6be6.jpg" width="256" align="left"><br><h3>  annotation </h3><br>  With the help of IBM‚Äôs Moscow office, we tested the performance of the latest PostgreSQL DBMS on Power8 servers, examined the scalability of performance versus simultaneous requests, found performance bottlenecks, offered new technical solutions, and achieved record-breaking performance. <br><br><h3>  Introduction </h3><br>  In a number of tasks, virtually unlimited scaling by the volume of processed transactions can be achieved using distributed systems, in which in one way or another the transaction flow is distributed to a large number of servers.  Such scaling is often called ‚Äúhorizontal.‚Äù  However, there is no universal distributed solution, moreover, distribution has its price.  The system architecture must be designed in advance as distributed.  Distributed systems are less flexible than monolithic, moreover, they are more difficult to operate and require higher qualification of staff.  Some tasks are easier to parallelize, others more difficult.  Therefore, the demand for high-performance monolithic systems exists, and achieving the best possible performance in one server was and remains an important task.  This is often called ‚Äúvertical scaling‚Äù. <br><br>  The essence of the problems arising from the parallel processing of a large number of transactions in monolithic and distributed systems is the same - this is competition between transactions for access to the same resources.  Speaking simply, individual processes work in parallel and independently until they queue up for a common resource (and this can be either a hardware resource or a piece of information stored in a database) and do not begin to expect each other. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To solve such problems, there are mechanisms for controlling access to resources ‚Äî the use of locks, as well as lock-free approaches that are suitable in some cases.  The productivity growth of these mechanisms, as well as the specification of locks, makes it possible to reduce the costs associated with simultaneous (competitive) access. <br><br>  At the same time, while in distributed systems a network is usually a bottleneck, in monolithic systems close to peak performance, its growth is limited by the aforementioned simultaneous access control mechanisms. <br><a name="habracut"></a><br><h3>  PostgreSQL Scaling Studies </h3><br>  In 2012, at the PgCon conference, Robert Haas from EnterpriseDB presented the results of performance studies (number of read requests per second) by PostgreSQL depending on the number of concurrent client sessions (Fig. 1).  Measurements were made on the amd64 platform using the pgbench tool included in PostgreSQL. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/04d/be8/46f04dbe8e6af73064dbade3db07243d.png" alt="image"><br>  Fig.1.  Schedule from R. Haas's report at the PgCon conference, 2012, case for 32 cores <br><br>  Before analyzing this graph, we make some important remarks.  The PostgreSQL architecture is such that one client is served by one single-threaded process on the server, and the disk is managed through a buffer located in the RAM shared between all such processes.  Thus, on the one hand, a simultaneous independent operation of a certain number of client sessions is possible, but the data itself, which is in shared memory, is a shared resource that is accessed competitively.  The disk subsystem is also a shared resource, but in this study work with it was not considered.  All data were already in the buffers, so the measurements performed show the maximum achievable performance. <br><br>  In this graph, the growth in the number of transactions per second (TPS) with an increase in the number of customers is initially close to linear;  This means that the costs of access to shared resources are insignificant, when the next client appears, the next processor core is fully utilized.  However, with increasing competition, linear growth ceases.  Termination of linear growth with the number of parallel sessions, a smaller number of processor cores, says that the CPU is used inefficiently, and the costs of scalability are high. <br><br>  Fig.1.  shows that when upgrading from version 9.1 to 9.2, thanks to the improvement of locking mechanisms, a steady performance increase was observed up to at least 32 clients simultaneously working with CPUs (the test used a 32-core machine, therefore, with a further increase in the number of clients, performance did not increase anymore).  A little later, R. Haas carried out similar measurements on 64 cores (Fig.2).  It can be seen that close to linear vertical scalability is preserved even with the number of cores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1eb/4a6/ba0/1eb4a6ba00906d31bcf01d837c7412c9.png" alt="image"><br>  Fig.2.  Graph from R. Haas‚Äôs report at the PgCon conference, 2012, case for 64 cores <br><br>  These graphs and the research behind them inspired us to see how PostgreSQL will behave on modern versions on modern multiprocessor servers.  IBM became interested in this, supplying such servers on the Power platform (the business related to x86 servers, IBM ceded to Lenovo in 2014 after the PC).  That's what came of it. <br><br><h3>  Our research </h3><br>  In February 2015, the most well-known Russian developers of PostgreSQL <a href="http://gov.cnews.ru/news/top/osnovatel_envizhn_investiroval_v">founded</a> Postgres Professional (Postgres Professional), whose goal was to develop PostgreSQL DBMS and provide a full range of related services.  The creation of the company made it possible to increase the amount of work on the development of PostgreSQL in Russia several times, made it possible to conduct applied research and enter into partnerships with manufacturers of software and hardware.  From the very beginning, Postgres Professional showed interest in partnering with IBM and entered into the partner network of IBM PartnerWorld.  In May 2015, Terri Virnig, IBM Vice President for Power Ecosystem and Strategy, visited Moscow, which confirmed IBM‚Äôs high interest in PostgreSQL and its adaptation to achieve maximum performance on the Power platform. <br><br>  As part of a partnership, in August 2015, an IBM E880 server with 2 nodes was selected for testing PostgreSQL in the IBM client center in Pokkepsiya (Poughkeepsie, NY), each node contained 4 eight-core SMT (simultaneous multithreading) processors, each core allows up to 8 threads.  Thus, this configuration provides up to 2 * 4 * 8 * 8 = 512 execution threads (or in the terminology of the IBM ‚ÄúLogical CPU‚Äù, LCPU).  It is important to note that the implementation of SMT in IBM Power 8 differs from its implementation in Intel processors (known as Hyperthreading), and, unlike the latter, gives a noticeable, up to twofold, performance boost on PostgreSQL DBMS tasks.  The number of threads (LCPU) can be controlled by setting their number to 1, 2, 4, or 8 per CPU core.  The testing technique was pre-tested on less powerful servers in Moscow.  The tests, like those of R. Haas, were conducted using the pgbench utility included with PostgreSQL. <br><br>  The test script was a search query on the B-tree index, which was entirely stored in memory.  The PostgreSQL server was launched on a large LPAR, and with the help of the tools built into the Linux kernel under the NUMA architecture, it was fixed on a certain number of numa nodes.  The success of the test was to achieve as many transactions per second (TPS) as possible. <br><br>  The first launch showed that when adding more cores, the performance does not increase, but even drops. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/97e/240/f33/97e240f3307046535d661d8e3aef3996.png" alt="image"><br>  Fig.3.  Performance depending on the number of clients for different number of LCPUs <br><br>  In order to understand why performance has fallen when adding LCPU, you need to imagine an IBM E880 server device.  It has two motherboards, each of which has 4 processors.  Among themselves, motherboards are connected by hyperconnect.  More details about the internal structure of servers on IBM Power 8 can be read in a <a href="http://ieeexplore.ieee.org/xpl/tocresult.jsp%3Fisnumber%3D7029148%26punumber%3D5288520">series of articles from IBM</a> .  The hyperconnect, though very fast, was predictably slower than the interaction of processors located on the same motherboard.  And it will be noticeable not only in PostgreSQL, but also in any other system where processes interact through shared memory.  Therefore, in further studies, in narrow places, we excluded the influence of the hyperconnect and used a single computing node, i.e.  256 LCPU with SMT = 8. <br><br>  Initially, the last PostgreSQL official release (version 9.4.5) was tested at the time of testing, which showed linear scaling only up to 32 clients, then the current versions from the 9.5 and 9.6 branches, on which growth close to linear, continued to 64 clients. <br><br><img src="https://habrastorage.org/files/74d/afd/841/74dafd84112f46bbb0605e4dec88cb14.png"><br>  Fig.4.  Performance depending on the number of threads <br><br>  Version 9.5 shows an improvement over version 9.4, which can be explained by the optimization of the LWLock mechanisms (to be explained below). <br><br>  So, the measurements were taken.  But we decided not to dwell on this, but to go further - trying to understand whether there is a possibility, having discovered a bottleneck in the code, to eliminate it and achieve a better result.  To search for bottlenecks, the perf utility was used, which showed that about 32% of the CPU time is occupied by the execution of the s_lock function (Fig.5). <br><br><pre><code class="hljs css">32<span class="hljs-selector-class"><span class="hljs-selector-class">.10</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s_lock</span></span> 7<span class="hljs-selector-class"><span class="hljs-selector-class">.77</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">GetSnapshotData</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.64</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AllocSetAlloc</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.40</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hash_search_with_hash_value</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.37</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">base_yyparse</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.36</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SearchCatCache</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.32</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PinBuffer</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.23</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LWLockAcquire</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.05</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">palloc</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.01</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ReadBuffer_common</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.99</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LWLockRelease</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.94</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">libc-2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.17</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.so</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">memset_power7</span></span></code> </pre> <br>  Fig.5.  Sample perf top output during testing <br><br>  To identify the places in the PostgreSQL program code responsible for the s_lock call, the gdb debugger was used (the single-threaded perf performance for building the dependency graph was insufficient).  Sample gdb connections showed that in most cases the s_lock call comes from the PinBuffer and UnpinBuffer functions, which serve to increase and decrease the reference count for the buffer that stores a specific data block.  The reference counter is protected by the BufferDesc.buf_hdr_lock spinlock, and therefore, to work with it, you must first capture this spinlock.  To better understand this place, let's consider what types of locks are in PostgreSQL, and why they are needed. <br><br><h3>  PostgreSQL locks: what and why so many different? </h3><br>  PostgreSQL implements several types of locks, each of which solves its own problems. <br><ol><li>  <a href="https://en.wikipedia.org/wiki/Spinlock">Spinlock</a> (spinlock) - the simplest type of locks, which has only two states "busy" and "free."  The procedure for taking a spinlock consists of successive attempts to change its state from ‚Äúfree‚Äù to ‚Äúbusy‚Äù.  In order to avoid <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25BA%25D0%25B8">racing</a> , spinlocks use the atomic <a href="https://en.wikipedia.org/wiki/Test-and-set">Test-and-set</a> (TAS) operation.  Processes wishing to get a spinlock do not line up.  From the side of the DBMS, neither monitoring of spinlockes nor automatic detection of deadlocks on spinlocks is supported.  All this has been sacrificed for high performance in very short operations.  PostgreSQL contains assembler implementations of spinlock for various hardware platforms.  In the case when the assembler implementation of the spin-locks is absent, the emulation of the spin-locks via UNIX semaphores is used, which, however, have far less performance. </li><li>  Lightweight lock (LWLock) is a more complex type of lock that has two levels, shared and exclusive.  At the same time, either an unlimited number of shared locks or only one exclusive can be taken.  The implementation of LWLock has undergone significant changes between PostgreSQL 9.4 and 9.5 versions.  In versions 9.4 and below, LWLock contained a set of fields protected by a spinlock.  Starting from version 9.5, most of the operations with LWLock are performed bypassing the spinlock, using atomic operations with the ‚Äústate variable‚Äù of the LWLock.  Processes that want to get LWLock are lining up, so that when you wait for LWLock for a long time, the bus resource is not wasted.  Automatic detection of deadlocks for LWLock is not supported, the DBMS algorithms are adjusted so that deadlocks never occur.  LWLock monitoring support is led by Postgres Professional employee Ildus Kurbangaliev (aka <a href="http://habrahabr.ru/users/ildus/" class="user_link">ildus</a> ) as part of the more general task of monitoring wait events. </li><li>  Heavyweight lock (HWLock) - the most ‚Äúadvanced‚Äù type of locks.  It has <a href="http://www.postgresql.org/docs/current/static/explicit-locking.html">many levels and a non-trivial conflict matrix</a> .  On tables, indexes and other database objects, HWLock'i, are set, both implicitly by the SQL commands that use them, and explicitly by the LOCK command.  For monitoring HWLock'ov designed system view <a href="http://www.postgresql.org/docs/current/static/view-pg-locks.html">pg_locks</a> .  As the name implies, HWLock'i ‚Äã‚Äãis a rather heavyweight mechanism, therefore, to receive them by DML commands, a special fastpath locking mechanism is provided.  In addition, since the order in which HWLockes are retrieved depends on user actions, there can be no guarantee of the absence of deadlocks, so PostgreSQL has an automatic mechanism for detecting deadlocks. </li></ol><br><br>  In addition to the locks listed above, PostgreSQL has row-level locks, predicate locks, advisory locks and others, which, in turn, are implemented using the three basic types of locks listed above. <br><br><h3>  How we sped up PostgreSQL </h3><br>  To understand whether we can improve performance in the bottleneck we found, we, together with PostgreSQL lead developer Andres Freund (Andres Freund), developed a patch replacing the buf_hdr_lock spinlock for atomic operations with a ‚Äústate‚Äù buffer.  Thus, the developed patch implements optimization for buffers similar to that done for LW Lockers in version 9.5: the PinBuffer function started the <a href="https://en.wikipedia.org/wiki/Compare-and-swap">Compare and Swap</a> operation (CAS) in a loop, and the UnpinBuffer function - atomic decrement.  This made it possible to extend the growth area close to linear, about 2 times and achieve a performance of more than 800 thousand TPS (Fig. 6). <br><br><img src="https://habrastorage.org/files/f6c/f6b/e2b/f6cf6be2b29c4d5c9d1483379cebab73.png"><br>  Fig.6.  The results of measuring the performance of the developed patch. <br><br>  However, we did not stop at that either.  If you look at the assembler implementation of the CAS operation under power8, you can see that it is a cycle (Fig. 7). <br><br><pre> <code class="hljs css">#  : # <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span> ‚Äì  , <span class="hljs-selector-tag"><span class="hljs-selector-tag">r4</span></span> ‚Äì   # <span class="hljs-selector-tag"><span class="hljs-selector-tag">r5</span></span> ‚Äì    <span class="hljs-selector-class"><span class="hljs-selector-class">.L1</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">lwarx</span></span> 9,0,5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmpw</span></span> 0,9,3 <span class="hljs-selector-tag"><span class="hljs-selector-tag">bne-</span></span> 0,<span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">stwcx</span></span>. 4,0,5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">bne-</span></span> 0,<span class="hljs-selector-class"><span class="hljs-selector-class">.L1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">isync</span></span></code> </pre><br>  Figure 7. Implementing an atomic CAS operation in Power 8 assembler. <br><br>  Thus, performing a CAS operation in a loop is a loop in a loop.  With a lot of competition for changing the value, it can be noticeably slower than performing a single cycle. <br><br>  If you look at the assembler implementation of the atomic increment operation, you can see that it also represents a similar cycle, but within which the add command is already located. <br><br><pre> <code class="hljs css">#  : # <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span> ‚Äì  # <span class="hljs-selector-tag"><span class="hljs-selector-tag">r5</span></span> ‚Äì    <span class="hljs-selector-class"><span class="hljs-selector-class">.L1</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">lwarx</span></span> 9,0,5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> 9,9,3 <span class="hljs-selector-tag"><span class="hljs-selector-tag">stwcx</span></span>. 9,0,5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">bne-</span></span> 0,<span class="hljs-selector-class"><span class="hljs-selector-class">.L1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">isync</span></span></code> </pre><br>  Figure 8. The implementation of the atomic operation of the atomic increment in the assembler Power 8. <br><br>  Obviously, more complex calculations can be placed between the <a href="https://www-01.ibm.com/support/knowledgecenter/ssw_aix_61/com.ibm.aix.alangref/idalangref_lwarx_lwri_instrs.htm">lwarx and stwcx</a> commands. <br><br>  Based on this, two ideas were born for further optimizations. <br><ol><li>  Implement performance-critical features such as PinBuffer and LWLockAttemptLock with assembly inserts.  The disadvantage of this option is that we go beyond the level of abstraction in the form of atomic operations, which the compiler provides us. </li><li>  An alternative idea is to use an atomic increment and implement the so-called ‚Äúoptimistic approach‚Äù.  In PinBuffer and LWLockAttemptLock, you can make an atomic increment of a ‚Äústate variable‚Äù and then, by the actually set value, check whether we had the right to such a state change or not.  In case we did not have the right to change the state in this way, cancel this change in the operation of the atomic increment.  The calculation here is made that the change will have to be canceled only in a very small fraction of cases, this is the ‚Äúoptimism‚Äù of the approach.  Of course, all other functions that work with the ‚Äústate variable‚Äù should also take this into account. </li></ol><br>  Both of these ideas were implemented in the form of patches.  At the same time, the version with the atomic increment was tested in several versions, so that the effect on the application of this approach to the PinBuffer and to the LWLockAttemptLock could be evaluated separately. <br><br><img src="https://habrastorage.org/files/7bb/76e/7f0/7bb76e7f098344769730609351b8b32c.png"><br>  Fig.9.  The results of measuring the performance of various patches. <br><br>  The graph (Fig. 9) shows the performance comparison of the following patches: <br><ol><li>  pinunpin-cas - PinBuffer is performed using a CAS cycle of operations. </li><li>  pinunpin-increment - PinBuffer is performed using an ‚Äúoptimistic‚Äù atomic increment. </li><li>  pinunpin-cas-lwlock-increment - PinBuffer is performed using the CAS cycle of operations, LWLockAttemptLock is performed using the ‚Äúoptimistic‚Äù atomic increment. </li><li>  pinunpin-lwlock-increment - PinBuffer and LWLockAttemptLock are performed using the ‚Äúoptimistic‚Äù atomic increment. </li><li>  pinunpin-lwlock-asm - PinBuffer and LWLockAttemptLock are implemented in assembler. </li></ol><br>  It can be seen that the effect of the ‚Äúoptimistic‚Äù atomic increment in PinBuffer is almost nonexistent, but the application of the same approach to LWLockAttemptLock gives a very large effect.  And about the same effect can be obtained using assembly optimizations. <br><br>  Figure 10 shows the changed perf top picture after applying the patch.  It can be seen that the bottleneck has moved to the function GetSnapshotData, which may also be accelerated.  But the time allotted to us for testing is over and the best results could not be shown.  However, the results achieved are of great value, since  There was a significant increase in performance. <br><br><pre> <code class="hljs css">13<span class="hljs-selector-class"><span class="hljs-selector-class">.75</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">GetSnapshotData</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.88</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AllocSetAlloc</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.47</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LWLockAcquire</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.11</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hash_search_with_hash_value</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.02</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SearchCatCache</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.00</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">palloc</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.81</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">base_yyparse</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.69</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">libc-2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.17</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.so</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">memset_power7</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.63</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LWLockRelease</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.56</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">libc-2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.17</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.so</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">memcpy_power7</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.33</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">bt_compare</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.99</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">core_yylex</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.99</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">postgres</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[.]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">expression_tree_walker</span></span></code> </pre><br>  Fig.10 Example of perf top output during testing after applying the pinunpin-lwlock-asm experimental patch. <br><br>  It should be noted that not only our team is engaged in vertical postgres scalability.  There is a general trend towards more economical use of locks, which was, in particular, described at the October conference <a href="http://2015.pgconf.eu/">pgconf.eu</a> in the <a href="http://www.anarazel.de/talks/pgconf-eu-2015-10-30/concurrency.pdf">report by</a> Andres Freund).  Including, as already mentioned, version 9.5 includes LWLock optimizations. <br><br><h3>  findings </h3><br>  In the experimental mode, the low-level locking system was replaced in PostgreSQL, which made it possible to approximately double the scalability of the number of processor cores and thereby increase the usability of PostgreSQL for efficient use on very large Power 8 servers. <br><br>  Were tested patches containing optimizations of critical sections of code used in locks and the buffer manager, both in assembler and using atomic operations provided by the compiler.  The results showed that when using atomic operations at a higher level of abstraction, it is possible to achieve almost the same level of performance as when using assembly inserts. <br><br>  IBM's Advanced Toolchain OpenSource (which is essentially a version of gcc with PPC-optimized runtime libraries) showed better performance than vanilla gcc and is recommended for assembly.  XLC under linux has still unresolved issues with PostgreSQL and is not recommended. <br><br>  PostgreSQL showed solid performance in LPAR.  Hardware partitioning with PowerVM turned out to be a powerful and convenient virtualization system, with which you can increase the performance of a single LPAR and PostgreSQL server inside it. <br><br>  SMT in Power8 can give more than double the performance boost on tasks similar to those on which our testing was performed. <br><br>  The latest patch on asm made it possible to achieve a total performance of over 2 million transactions per second on 48 Power8 cores.  This was achieved on two instances of PostgreSQL running simultaneously on different compute nodes. <br><br>  In practice, this means that you don‚Äôt have to worry about how much PostgreSQL scales up to the cores until you reach a performance of 1 million transactions per second on a top-end gland, or face a frequently used memory page (for example, the top B-line). tree).  As a rule, our clients with&gt; 100 physical cores have no problems with scaling PostgreSQL and do not feel the effects described here. <br><br><h3>  Thanks </h3><br>  This study was conducted as part of the activities of the Russian vendor PostgreSQL - Postgres Professional, a participant in the IBM Partner World program.  The authors thank IBM‚Äôs Moscow office and Denis Sosnovtsev and Alexander Lunyakov personally for their interest in Postgres Professional research and assistance in gaining access to testing equipment, and Ivan Goncharov for valuable advice on its use, as well as IBM Vice President Terry Virng for support and IBM client center in Pukhipsi and IBM Cambridge Innovation Center for testing. <br><br>  I would also like to thank my co-authors - Postgres Professional employees Dmitry Vasilyev (aka <a href="http://habrahabr.ru/users/vadv/" class="user_link">vadv</a> ), who directly drove the tests and wrote a large part of this article, and Yury Zhuravlev (aka <a href="http://habrahabr.ru/users/stalkerg/" class="user_link">stalkerg</a> ), who developed the initial version of the patch for translating PinBuffer / UnpinBuffer to atomic operations . </div><p>Source: <a href="https://habr.com/ru/post/270827/">https://habr.com/ru/post/270827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270813/index.html">Online algorithms in high-frequency trading: problems of competition</a></li>
<li><a href="../270815/index.html">Security Week 46: Versatile Java Bug, Life for Crypto-Folders, 17 Adobe Flash Patches</a></li>
<li><a href="../270821/index.html">Pirate metrics: how to create an email campaign based on the AARRR principle. Part 4</a></li>
<li><a href="../270823/index.html">First article about checking C # project</a></li>
<li><a href="../270825/index.html">Component-oriented C # engine</a></li>
<li><a href="../270829/index.html">Development and debugging of applications for Android Wear</a></li>
<li><a href="../270837/index.html">Embedding Addictions in Angular 2</a></li>
<li><a href="../270839/index.html">Class Requests at InterSystems Cach√©</a></li>
<li><a href="../270841/index.html">Cisco ipsec tunnel without using crypto map</a></li>
<li><a href="../270843/index.html">Digest of the game industry: October</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>