<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing long-term arithmetic in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In most modern languages, the programmer no longer needs to worry about numbers with which the processor cannot directly manipulate. Somewhere, like i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing long-term arithmetic in C ++</h1><div class="post__text post__text-html js-mediator-article">  In most modern languages, the programmer no longer needs to worry about numbers with which the processor cannot directly manipulate.  Somewhere, like in Python or Haskell, support for long integer types is built right into the core of the language, somewhere, like in Java or C #, is implemented as separate classes.  But in the standard library of C ++, long numbers are still not supported.  So I decided to write it myself. <br><a name="habracut"></a><br><h5>  Class structure </h5><br>  The first thing to decide is how to store our number.  I store it in the form of an array of numbers, in reverse order (this makes it easier to implement all operations), at once, 9 digits in one element of the array (which saves memory): <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">big_integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//    (1 000 000 000) static const int BASE = 1000000000; //    std::vector&lt;int&gt; _digits; //   bool _is_negative; };</span></span></code> </pre> <br>  In my implementation there will be two representations of zero at once - in the form of an empty vector and in the form of a vector with one and only zero. <br><br><h5>  Create number </h5><br>  The first thing you need to learn to do is create a number.  This is how it is converted from a string containing numbers: <br><pre> <code class="cpp hljs">big_integer::big_integer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      this-&gt;_is_negative = false; } else { if (str[0] == '-') { str = str.substr(1); this-&gt;_is_negative = true; } else { this-&gt;_is_negative = false; } // - i    size_t.      , //   int      ,   long long for (long long i = str.length(); i &gt; 0; i -= 9) { if (i &lt; 9) this-&gt;_digits.push_back(atoi(str.substr(0, i).c_str())); else this-&gt;_digits.push_back(atoi(str.substr(i - 9, 9).c_str())); } //     ,    this-&gt;_remove_leading_zeros(); } }</span></span></code> </pre><br>  The code of the procedure for removing leading zeros is simple to disgrace: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> big_integer::_remove_leading_zeros() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.back() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.pop_back(); } <span class="hljs-comment"><span class="hljs-comment">//   ,        if (this-&gt;_digits.size() == 1 &amp;&amp; this-&gt;_digits[0] == 0) this-&gt;_is_negative = false; }</span></span></code> </pre><br>  We also need to be able to convert ordinary numbers to long: <br><pre> <code class="cpp hljs">big_integer::big_integer(<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> l) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_is_negative = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; l = -l; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_is_negative = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.push_back(l % big_integer::BASE); l /= big_integer::BASE; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l != <span class="hljs-number"><span class="hljs-number">0</span></span>); } big_integer::big_integer(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> l) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_is_negative = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.push_back(l % big_integer::BASE); l /= big_integer::BASE; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l != <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  The conversion code from the other types is even simpler, I did not mention it here. <br><br><h5>  Conclusion number </h5><br>  Now we need to learn how to print our number to a stream and convert it to a string: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; bi) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bi._digits.empty()) os &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bi._is_negative) os &lt;&lt; <span class="hljs-string"><span class="hljs-string">'-'</span></span>; os &lt;&lt; bi._digits.back(); <span class="hljs-comment"><span class="hljs-comment">//        9  //    -,     char old_fill = os.fill('0'); for (long long i = static_cast&lt;long long&gt;(bi._digits.size()) - 2; i &gt;= 0; --i) { os &lt;&lt; std::setw(9) &lt;&lt; bi._digits[i]; } os.fill(old_fill); } return os; } big_integer::operator std::string() const { std::stringstream ss; ss &lt;&lt; *this; return ss.str(); }</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Comparison of numbers </h5><br>  Now we need to learn how to compare two numbers with each other.  The theory says that only two operations are enough for this, the rest can be derived from them.  So, first learn to compare two numbers for equality: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-comment"><span class="hljs-comment">//       if (left._is_negative != right._is_negative) return false; //      ,     if (left._digits.empty()) { if (right._digits.empty() || (right._digits.size() == 1 &amp;&amp; right._digits[0] == 0)) return true; else return false; } if (right._digits.empty()) { if (left._digits.size() == 1 &amp;&amp; left._digits[0] == 0) return true; else return false; } //       ,         () if (left._digits.size() != right._digits.size()) return false; for (size_t i = 0; i &lt; left._digits.size(); ++i) if (left._digits[i] != right._digits[i]) return false; return true; }</span></span></code> </pre><br><br>  Now check if one is smaller than the other: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left._is_negative) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right._is_negative) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((-right) &lt; (-left)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right._is_negative) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left._digits.size() != right._digits.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left._digits.size() &lt; right._digits.size(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i = left._digits.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left._digits[i] != right._digits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left._digits[i] &lt; right._digits[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre><br>  Here we use unary negation to change the sign of a number.  I also introduced a unary plus for symmetry: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> big_integer(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-function"><span class="hljs-function">big_integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; copy._is_negative = !copy._is_negative; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> copy; }</code> </pre><br>  I learned from <a href="http://habrahabr.ru/post/132014/">this article</a> about why to return const big_integer, not just big_integer, and also about the rules for choosing between a friendly operator function and a member operator of a class. <br><br>  Then everything is quite simple: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> !=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(left == right); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (left &lt; right || left == right); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(left &lt;= right); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(left &lt; right); }</code> </pre><br><br><h5>  Arithmetic operations </h5><br><h6>  Addition </h6><br>  I did not begin to subtilize with operations and realized normal school addition in a column.  Since, in any case, we will need to create a new number as a result of the operation, I immediately copy the left operand by value onto the stack and add the numbers directly to it: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(big_integer left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-comment"><span class="hljs-comment">//        //   ,      if (left._is_negative) { if (right._is_negative) return -(-left + (-right)); else return right - (-left); } else if (right._is_negative) return left - (-right); int carry = 0; //      for (size_t i = 0; i &lt; std::max(left._digits.size(), right._digits.size()) || carry != 0; ++i) { if (i == left._digits.size()) left._digits.push_back(0); left._digits[i] += carry + (i &lt; right._digits.size() ? right._digits[i] : 0); carry = left._digits[i] &gt;= big_integer::BASE; if (carry != 0) left._digits[i] -= big_integer::BASE; } return left; }</span></span></code> </pre><br>  Here I avoided the ‚Äúexpensive‚Äù division operation in the case when the resulting ‚Äúfigure‚Äù is more than the basis on which I work, by simple comparison. <br><br><h6>  Subtraction </h6><br>  In principle, subtraction is similar to addition.  It is only necessary to consider the case when the decrease is less than the deductible: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -(big_integer left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right._is_negative) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left + (-right); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left._is_negative) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(-left + right); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(right - left); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; right._digits.size() || carry != <span class="hljs-number"><span class="hljs-number">0</span></span>; ++i) { left._digits[i] -= carry + (i &lt; right._digits.size() ? right._digits[i] : <span class="hljs-number"><span class="hljs-number">0</span></span>); carry = left._digits[i] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (carry != <span class="hljs-number"><span class="hljs-number">0</span></span>) left._digits[i] += big_integer::BASE; } left._remove_leading_zeros(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; }</code> </pre><br><br><h6>  Increment and decrement </h6><br>  Before implementing these two operations, we need to implement addition and subtraction with assignment: <br><pre> <code class="cpp hljs">big_integer&amp; big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value); } big_integer&amp; big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> - value); }</code> </pre><br><br>  Then the prefix versions of the operations are implemented in one line, and the postfix versions are only slightly more complicated: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> --() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> --(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br><h6>  Multiplication </h6><br>  I did not write the rapid multiplication of Karatsuba, but again I used ‚Äúschool‚Äù arithmetic: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { big_integer result; result._digits.resize(left._digits.size() + right._digits.size()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; left._digits.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; right._digits.size() || carry != <span class="hljs-number"><span class="hljs-number">0</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cur = result._digits[i + j] + left._digits[i] * <span class="hljs-number"><span class="hljs-number">1L</span></span>L * (j &lt; right._digits.size() ? right._digits[j] : <span class="hljs-number"><span class="hljs-number">0</span></span>) + carry; result._digits[i + j] = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(cur % big_integer::BASE); carry = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(cur / big_integer::BASE); } } <span class="hljs-comment"><span class="hljs-comment">//     result._is_negative = left._is_negative != right._is_negative; result._remove_leading_zeros(); return result; }</span></span></code> </pre><br><br><h6>  Division </h6><br>  Since I have not found on the Internet fast ways to divide, we will use the school division corner.  Let's start to share with the senior discharges.  We need to reduce the current value of the dividend by the maximum possible number of dividends.  We will search for this maximum value by binary search.  But first we need to define the function of ‚Äúshifting‚Äù the number to the right, which will allow us to iterate through the digits sequentially: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> big_integer::_shift_right() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.push_back(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//             , //  i  ""  size_t for (size_t i = this-&gt;_digits.size() - 2; i &gt; 0; --i) this-&gt;_digits[i] = this-&gt;_digits[i - 1]; this-&gt;_digits[0] = 0; }</span></span></code> </pre><br>  Now we describe the division itself: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> /(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { <span class="hljs-comment"><span class="hljs-comment">//     if (right == 0) throw big_integer::divide_by_zero(); big_integer b = right; b._is_negative = false; big_integer result, current; result._digits.resize(left._digits.size()); for (long long i = static_cast&lt;long long&gt;(left._digits.size()) - 1; i &gt;= 0; --i) { current._shift_right(); current._digits[0] = left._digits[i]; current._remove_leading_zeros(); int x = 0, l = 0, r = big_integer::BASE; while (l &lt;= r) { int m = (l + r) / 2; big_integer t = b * m; if (t &lt;= current) { x = m; l = m + 1; } else r = m - 1; } result._digits[i] = x; current = current - b * x; } result._is_negative = left._is_negative != right._is_negative; result._remove_leading_zeros(); return result; }</span></span></code> </pre><br>  Here, <code>big_integer::divide_by_zero</code> is an empty class inherited from <code>std::exception</code> . <br><br><h6>  Taking balance </h6><br>  In fact, in the previous operation, the remainder is actually stored in the variable <code>current</code> .  But I wondered about the definition of the remainder sign.  <a href="http://ru.wikipedia.org/wiki/%25C4%25E5%25EB%25E5%25ED%25E8%25E5_%25F1_%25EE%25F1%25F2%25E0%25F2%25EA%25EE%25EC">Wikipedia says</a> that the remainder of the division is always positive.  Therefore, I wrote this version of this operation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> %(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer&amp; right) { big_integer result = left - (left / right) * right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result._is_negative) result += right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br><h6>  Exponentiation </h6><br>  I used the quick exponentiation algorithm.  It requires checking the number for odd.  Since it would be expensive to calculate the remainder of division by 2, to put it mildly, we introduce the following operations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> big_integer::odd() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_digits[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> big_integer::even() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;odd(); }</code> </pre><br>  Now we will write the construction itself: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> big_integer big_integer::<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(big_integer n) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-function"><span class="hljs-function">big_integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n.odd()) result *= a; a *= a; n /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  Full class code: <a href="http://pastebin.com/MxQdP5s9">pastebin.com/MxQdP5s9</a> <br><br>  Everything!  Now you can calculate, for example, 2 <sup>1000</sup> , or factorial 100: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "big_integer.hpp" using namespace std; int main() { big_integer bi("2"), bi2 = 100; cout &lt;&lt; bi.pow(1000) &lt;&lt; endl; big_integer f = 1; for (big_integer i = 2; i &lt;= bi2; ++i) f *= i; cout &lt;&lt; f &lt;&lt; endl; }</span></span></span></span></code> </pre><br><br><h5>  Literature </h5><br><ol><li>  <a href="http://e-maxx.ru/">e-maxx.ru</a> - a site dedicated to olympiad algorithms </li><li>  <a href="http://cppalgo.blogspot.ru/2010/05/blog-post.html">cppalgo.blogspot.ru/2010/05/blog-post.html</a> - Igor Belyaev's blog </li></ol></div><p>Source: <a href="https://habr.com/ru/post/172285/">https://habr.com/ru/post/172285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172271/index.html">ExtJS4: practical impressions</a></li>
<li><a href="../172273/index.html">Intel offers to consider the display service</a></li>
<li><a href="../172279/index.html">Non-obvious ways to protect against malware</a></li>
<li><a href="../172281/index.html">Philips opens development program for Hue bulbs</a></li>
<li><a href="../172283/index.html">Ejabberd Crutches protection</a></li>
<li><a href="../172289/index.html">Large-scale update of the mobile version of 2GIS</a></li>
<li><a href="../172293/index.html">Technology to combat MiniDuke. Simple protection against complex threats?</a></li>
<li><a href="../172295/index.html">Mysterious FrontCache</a></li>
<li><a href="../172299/index.html">Record and modify sound in the browser</a></li>
<li><a href="../172301/index.html">How graphics kill gameplay</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>