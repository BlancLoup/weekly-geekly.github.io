<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building video delivery systems based on HTTP Dynamic Streaming from Adobe and OpenSource</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As part of the project, one of our customers once again faced the task of building a system for converting / storing / delivering video to the Interne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building video delivery systems based on HTTP Dynamic Streaming from Adobe and OpenSource</h1><div class="post__text post__text-html js-mediator-article">  As part of the project, one of our customers once again faced the task of building a system for converting / storing / delivering video to the Internet.  A typical such task is to create your own small (or not very small) ‚ÄúTube‚Äù only with professional, not UGC-content. <br><br>  Since the creation of the first "Tube" video technologies on the Internet have gone some way of development, they now allow to do much more, and the requirements for a modern video site have become somewhat different. <br><br>  The most interesting recent trends, in our opinion, are: <br><ul><li>  the ability to watch one video site from different devices, </li><li>  adaptive HTTP streaming technology </li></ul><br><a name="habracut"></a><br>  As a result of the recent emergence and rapid spread of mobile devices that are really convenient for the use of the Internet from them, as well as the development of wireless data transmission technologies, it becomes clear that you need to have a second version of the site optimized for mobile iOS, Android and other platforms.  The third version of the site, optimized for the ‚Äú10-foot interface‚Äù, will soon be needed when any WebTV technology, such as GoogleTV, becomes popular. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It all fits into the so-called.  the concept of ‚Äúthree screens‚Äù, from which people will consume video (and generally Internet content) in the near future - a mobile phone (tablet) on the road, a PC at the office at work, TV in the living room at home. <br><br>  I would like to talk about the technology of adaptive HTTP streaming in more detail, which is the subject of this article. <br><br>  The Internet, by its nature, is poorly suited for video delivery, especially in real time.  On the one hand, we want to see a smooth continuous stream of video; on the other hand, we have an unstable connection with characteristics floating in time and we can deal with it in two ways - by increasing the delay (buffer) or adapting the bitrate of the stream. <br><br>  The main idea of ‚Äã‚Äãadaptive multi-bit streaming technology lies precisely in stream adaptation ‚Äî that we encode one video in several bitrates and stream the user to the bit rate that we consider possible at a given time, for example, based on the assessment of the current throughput of the user's network and evaluation decoding speeds (i.e. whether the user's computer is coping with decoding the stream in real time). <br><br>  First of all, it is important for live broadcasts, when it is more important for the user to ‚Äúkeep up with the stream,‚Äù that is, minimizing the likelihood of ‚Äúprebuffering‚Äù, even if at times sacrificing image quality.  However, for video-on-demand services, this technology is also extremely useful - it‚Äôs nice when the video starts quickly, in the capacity that the channel allows and by all means tries not to stumble. <br><br>  In practice, this means that we can significantly improve the perception of the service not only to users with an unstable / weak channel, somewhere deep in the regions, but also to users of wifi networks, users who have one connection common to several users in a household, and t .d  For users with a dedicated quality channel, this technology will simply automatically determine the speed of its channel and will give the video in a suitable bitrate - i.e.  the end user no longer needs to know what 360p, 240p or SD is, HD, etc.  - everything happens automatically. <br><br>  Pay for all these benefits accounted for 3 things - <br><ul><li>  complication of the streaming procedure, </li><li>  additional coding costs, </li><li>  additional storage costs. </li></ul><br>  The first reason at the moment should no longer be taken into account, since there are already ready opensource - building blocks for the construction of such systems, which I will talk about later. <br><br>  The second and third reasons, of course, are important, but here the developers of the site should themselves consider whether their users are worth these additional costs. <br><br>  At the moment there are at least three implementations of adaptive multibitrate streaming technology known to me: <br><ul><li>  Apple HTTP Adaptive Streaming for iPhone / iPad, </li><li>  Microsoft Smooth Streaming for Silverlight, </li><li>  Adobe Dynamic Streaming for Flash. </li></ul><br>  For the practice of developing video sites, the most important, of course, is the implementation from Adobe, since Apple HTTP Adaptive Streaming works only for iOS devices and Safari under MacOS X (although I was recently shown one STB in which this protocol was implemented), and Silverlight, let's say, until I received such popularity as Flash. <br><br>  Adobe implemented Dynamic Streaming within the framework of the rtmp protocol for quite some time and only relatively recently (with the advent of flash 10.1) was it possible to use HTTP streaming.  This is a very important step, since previously a specialized streaming server was needed to use dynamic streaming, but now most of the work has been transferred to the client, and server support is simplified to the point of returning normal HTTP statics. <br><br>  In fact, we need to encode the video in several bitrates, and then either cut it into fragments, for example, 5 seconds each and put it under the fast statics return server (see the picture below), or if there is a server or streaming module, which is from mp4 files can cut the necessary fragments on the fly, then we put it on the storage level, and we route the requests through some effective cache.  Moreover, this casher can be at the CDN service provider.  One of the main advantages of the adaptive HTTP streaming technology is the ease of use of external CDNs and cachers - you can not care about the prefilling of the cache - in the case of ‚Äúcache miss‚Äù the request is proxied to the origin-server, while being saved in the cache. <br><br><img src="https://habrastorage.org/storage/4aa3fb48/9f50dc96/0254b043/c7aa5bfc.png"><br><br>  Caching is very effective, because in the proxy cache, the demanded content ‚Äúslices‚Äù into pieces.  Moreover, these pieces are relatively small and you can come up with different strategies for managing the cache - when to ‚Äúsave‚Äù a piece, when to delete it, etc.  This gives more freedom to develop optimization mechanisms for developers of CDN services.  At one time, for the first versions of the rutub delivery system, we developed a similar piecewise caching mechanism, which allowed the project to deliver video efficiently with a minimum of equipment for a long time. <br><br>  From a programming point of view, for the support of HTTP Dynamic Streaming, the guys from Adobe did one simple thing - the <a href="http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/net/NetStream.html">appendBytes</a> method appeared for the NetStream object.  The format of the input array is byte stream in FLV format.  In fact, this makes it possible to play byte stream, and the issues of its delivery is a separate task.  For example, you can deliver these bytes via HTTP - pieces and you get HTTP streaming. <br><br>  Systems from Apple and Microsoft implement the delivery and playback system inside their ‚Äúblack box‚Äù, and Adobe allows you to program the system yourself.  They also made an open implementation of such a system as part of their Open Source Media Framework.  <a href="http://www.osmf.org/">OSMF</a> is a set of base classes that simplify the writing of video players in ActionScript3, which, among other things, includes the implementation of HTTP dynamic streaming support.  Moreover, the specifications of this protocol and details of the implementation of Adobe is trying to disclose.  You can see <a href="http://www.adobe.com/devnet/f4v.html">here</a> and <a href="http://sourceforge.net/adobe/osmf/wiki/Specifications/">here</a> .  Can you imagine such a thing earlier, when Flash had no competitors and their future seemed completely cloudless? <br><br>  So, back to the formulation of the problem - we want to make a video hosting service, the desktop version will use flash and HTTP adaptive streaming technology. <br><br>  How to build such a system for converting and delivering video? <br><br>  We will encode in mp4, codecs - x264 and faac, tools - ffmpeg, mencoder.  We do not like commercial software, if there are free alternatives. <br><br>  At the moment I know about the following implementations of this technology: <br><ul><li> commercial software.  Commercial servers from Adobe and Wowza have an implementation of this technology, OSMF can be taken as the basis for the player.  The option is probably good, but expensive. </li><li>  there is a free but closed <a href="httpdynamicstreaming/">implementation</a> from Adobe itself.  It is a repacker of source files in a certain f4f-format and a module for apache that works with such repacked files.  Minuses - it is impossible to work with mp4 files created by ffmpeg, since the source code is closed, understanding why is the problem. </li><li>  <a href="http://www.unified-streaming.com/index.php">USP</a> from CodeShop.  Pluses are a wonderful open implementation of the server part, cons - the client is closed and, in fact, the software is commercial, albeit OpenSource.  If a site that uses technology, commercial - shows advertising or charges for viewing, you need to buy a license. </li></ul><br>  I have been working in a company that has been involved in video technologies on the Internet for 10 years already and we have some experience and, looking at the documentation of the Adobe HTTP Dynamic Streaming protocols, we decided that for our ‚ÄúTyuba‚Äù project it‚Äôs easier and faster for us to implement server support ourselves .  And the client implementation of the protocol in OSMF is also open under the BSD license. <br><br>  The result is the project OpenHttpStreamer, which we decided to put in the OpenSource under the LGPL. <br>  Official page of the project - <a href="http://inventos.ru/OpenHttpStreamer">http://inventos.ru/OpenHttpStreamer</a> <br>  Sources are available on GitHub - <a href="https://github.com/inventos/OpenHttpStreamer">https://github.com/inventos/OpenHttpStreamer</a> . <br>  We tried to build under Ubuntu 10.10, Fedora 12, Debian (Squeeze).  Of the features - need <a href="http://www.scons.org/">scons</a> , g ++ version 4.3.0 and higher and boost&gt; = 1.39. <br><br>  How to use: <br> <code><a href=""></a> $ git clone https://github.com/inventos/OpenHttpStreamer.git <br> $ cd OpenHttpStreamer/mp4frag <br> $ scons configure &amp;&amp; scons <br> $ sudo scons install <br></code> <br>  If everything went well in / usr / local / bin / mp4frag there will be a compiled static fragment creation utility <br><br> <code>$ mp4frag <br> Allowed options: <br> --help produce help message <br> --src arg source mp4 file name <br> --video_id arg (=some_video) video id for manifest file <br> --manifest arg (=manifest.f4m) manifest file name <br> --fragmentduration arg (=3000) single fragment duration, ms <br> --template make template files instead of full fragments <br> --nofragments make manifest only <br></code> <br>  We encode ffmpeg'om any video in two qualities - 400 and 700 kbit / s (approximately) <br><br> <code>$ ffmpeg -y -i test.mpg -acodec libfaac -ac 2 -ab 96k -ar 44100 -vcodec libx264 -vpre medium -g 100 -keyint_min 50 -b 300k -bt 300k -threads 2 test-q1.mp4 <br> $ ffmpeg -y -i test.mpg -acodec libfaac -ac 2 -ab 96k -ar 44100 -vcodec libx264 -vpre medium -g 100 -keyint_min 50 -b 600k -bt 600k -threads 2 test-q2.mp4 <br></code> <br>  We got two mp4 files - test-q1.mp4 and test-q2.mp4, from which we generate static fragments: <br><br> <code>$ mp4frag --src test-q1.mp4 --src test-q2.mp4 --manifest=test.f4m <br></code> <br>  The result of the work is a file descriptor (‚Äúmanifest‚Äù) - test.f4m and static fragment files in folders 0 / and 1 / <br><br>  We post test.f4m 0/1 / under DocRoot of any web server that can render statics, and it remains for us to write a simple player on a flash using OSMF as the engine, or take a ready player. <br><br>  For a quick test, you can use our OSMF player assembly. <br>  For this <br>  1. under the DocRoot of our server (in the same place as test.f4m) we place the following crossdomain.xml: <br> <code>&lt;?xml version="1.0"?&gt; <br> &lt;!DOCTYPE cross-domain-policy SYSTEM "http://www.adobe.com/xml/dtds/cross-domain-policy.dtd"&gt; <br> &lt;cross-domain-policy&gt; <br> &lt;allow-access-from domain="inventos.ru" /&gt; <br> &lt;/cross-domain-policy&gt; <br></code> <br>  2. go to the browser at the link <a href="http_host/test.f4m">http://inventos.ru/OpenHttpStreamer?url=http://your_http_host/test.f4m</a> <a href="http_host/test.f4m"><br></a> <br><br>  As usual, if something does not work, we look at the logs of our server - is there any access from the player to crossdomain.xml, test.f4m, segment files.  It is convenient to check if everything is correct - to ‚Äúpull‚Äù the necessary addresses by yourself - <br> <code>wget -O - -S ¬´http://your_http_host/test.f4m¬ª <br> wget -O - -S ¬´http://your_http_host/1/Seg1Frag1¬ª <br></code> <br>  In conclusion, a few words about what is now in the repository.  While written only static repacker - mp4frag.  Module for nginx in development.  We have already thought out the architecture and algorithms, we are actively programming and are going to release literally this week or next week - I hope I will write more about this. <br><br>  We need the dynamic generation module to store the content in its original state (mp4 after converting ffmpeg) as it is a fairly universal format suitable for other purposes (streaming to other platforms).  There is an interesting option - the use of fragmented mp4, but it is less versatile. <br><br>  We came up with a simple way - index mp4 for quick access to the desired fragments and put the indices in a separate file next to the content itself.  The size of the index will be only about 1% of the source files.  Due to the fact that even getting quick access to the desired mdat fragment in the original mp4, we still need to remix the data by adding flv - headers (a feature of the OSMF implementation), we lose in performance compared to the statics.  However, by proxying requests for this module through fast web-cache and caching responses, we achieve both high performance and high versatility. </div><p>Source: <a href="https://habr.com/ru/post/110135/">https://habr.com/ru/post/110135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../110126/index.html">Who is responsible for user-generated content? Part 2</a></li>
<li><a href="../110128/index.html">Results of web development market research in Russia</a></li>
<li><a href="../110130/index.html">Fresh material review, November 2010</a></li>
<li><a href="../110131/index.html">TeeWorlds mod update: 1.6.1</a></li>
<li><a href="../110134/index.html">kedDroid - S01E03</a></li>
<li><a href="../110137/index.html">A world without net neutrality: each program has its own tariff</a></li>
<li><a href="../110139/index.html">HP Networking for beginners - where to quickly find information</a></li>
<li><a href="../110140/index.html">Experience New Year's greetings or 1 million cards per year</a></li>
<li><a href="../110141/index.html">Cars are the hottest item on eBay auctions</a></li>
<li><a href="../110142/index.html">Semiconductors in 3D!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>