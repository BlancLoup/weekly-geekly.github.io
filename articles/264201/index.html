<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intervals in C ++, part 1: Intervals with limiters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As we wrote the C ++ Siberia conference in Novosibirsk, Eric Nibler will open. To take a closer look at Habr with this remarkable man, we decided to t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intervals in C ++, part 1: Intervals with limiters</h1><div class="post__text post__text-html js-mediator-article">  <i>As we wrote the <a href="http://meetingcpp.ru/">C ++ Siberia</a> conference in Novosibirsk, Eric Nibler will open.</i>  <i>To take a closer look at Habr with this remarkable man, we decided to translate a cycle of his articles on intervals.</i>  <i>Erik is currently working on the implementation of the Ranges library for a grant received from the standardization committee.</i> <br><br>  Recently, I have been busy with intervals, and it became clear to me that this is more than just a couple of iterators.  In several posts I want to explain the concept of an interval, describe several intervals that cannot be simply or effectively expressed with the help of STL: intervals with limiters and infinite intervals.  In this post, we will consider the problem of representing intervals with delimiters through STL iterators. <br><a name="habracut"></a><br><h2>  Intervals with limiters </h2><br>  To understand the new concepts, you need to have a few good examples.  When thinking about an interval with delimiters, imagine a line in C ending in a null character.  But at the same time we do not know the exact position of the limiter.  The limiter may meet us at a previously unknown position, or, in general, the place of the limiter may be taken by some statement that becomes true.  Another example is the istream interval.  In this case, the limiter will be the moment when the istream extractor does not work.  At the same time, there is a std :: istream_iterator in the standard - therefore, somehow you can still push intervals with delimiters in the STL.  Now I will show how. <br><br><h2>  Intervals with limiters in STL </h2><br>  To show the complexity of the task, I present you an interval with a delimiter for the C-line with iterators that fully comply with the STL standards. <br><pre><code class="hljs rust">#include &lt;cassert&gt; #include &lt;iostream&gt; #include &lt;boost/iterator/iterator_facade.hpp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c_string_range</span></span></span></span> { private: <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *str_; public: using const_iterator = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span></span> : boost::iterator_facade&lt; iterator , <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> , std::forward_iterator_tag &gt; { private: friend class boost::iterator_core_access; friend <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c_string_range</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> * str_; iterator(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) : str_(<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) {} <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> equal(iterator that) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str_ ? (that.str_ == str_ || (!that.str_ &amp;&amp; !*str_)) : (!that.str_ || !*that.str_); } void increment() { assert(str_ &amp;&amp; *str_); ++str_; } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; dereference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert(str_ &amp;&amp; *str_); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *str_; } public: iterator() : str_(nullptr) {} }; c_string_range(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) : str_(<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { assert(str_); } iterator begin() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator{str_}; } iterator end() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator{}; } explicit operator <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!*str_; } }; int main() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> c : c_string_range(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>)) std::cout &lt;&lt; c; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">'n'</span></span>; }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The code iterates over the sequence of characters without first searching for the end.  This is done by creating a final signaling dummy interpreter, which each time it compares with a real iterator checks whether the real iterator shows a null character.  All logic is in the function c_string_range :: iterator :: equal member function.  It is unlikely that anyone would call such a decision beautiful. <br><br>  In modern STL, intervals are defined by two iterators - the initial and final.  For iterators like std :: istream_iterator or c_string_range :: iterator, where the iterator can be signaling, this method adds ramifications of the checking code of the iterators, because first you need to determine if one or both of the iterators are signaling.  The expression a == b is calculated according to the following table: <br><table width="639" cellpadding="7"><tbody><tr><td width="198">  a == end? <br><br></td><td width="199">  b == end? <br><br></td><td width="198">  a == b? <br><br></td></tr><tr><td width="198">  true <br><br></td><td width="199">  true <br><br></td><td width="198">  true <br><br></td></tr><tr><td width="198">  true <br><br></td><td width="199">  false <br><br></td><td width="198">  * b == 0 <br><br></td></tr><tr><td width="198">  false <br><br></td><td width="199">  true <br><br></td><td width="198">  * a == 0 <br><br></td></tr><tr><td width="198">  false <br><br></td><td width="199">  false <br><br></td><td width="198">  &amp; * a == &amp; * b <br><br></td></tr></tbody></table><br>  And these checks must be performed while the program is running.  It is impossible to say in advance whether the iterator will be real or empty.  And all these checks take away processor time.  So pushing the intervals in the STL is not very convenient. <br><br><h2>  Compiler agrees </h2><br>  And the inconvenience here is not just my opinion.  I generated the code for the following two functions: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> c_strlen(<span class="hljs-type"><span class="hljs-type">char</span></span> const *sz) { <span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; *sz; ++sz) ++i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-type"><span class="hljs-type">int</span></span> range_strlen( c_string_range::iterator <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>, c_string_range::iterator <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ++<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>) ++i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br><br>  These two functions do exactly the same thing, and, in theory, they should lead to the generation of the same code.  True, intuition tells us that all these complex logical constructions around c_string_range :: iterator :: equal will not lead to anything good.  In fact, the two versions of machine codes are not at all similar to each other. <br><br><table><tbody><tr><td><pre> <code class="hljs mel">; C_STRLEN pushl %ebp movl %esp, %ebp movl <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %ecx xorl %eax, %eax cmpb $0, (%ecx) je LBB1_3 xorl %eax, %eax .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB1_2: cmpb $0, <span class="hljs-number"><span class="hljs-number">1</span></span>(%ecx,%eax) leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%eax), %eax jne LBB1_2 LBB1_3: popl %ebp ret</code> </pre><br></td><td><pre> <code class="hljs mel">; RANGE_STRLEN pushl %ebp movl %esp, %ebp pushl %esi leal <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %ecx movl <span class="hljs-number"><span class="hljs-number">12</span></span>(%ebp), %esi xorl %eax, %eax testl %esi, %esi movl <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %edx jne LBB2_4 jmp LBB2_1 .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB2_8: incl %eax incl %edx movl %edx, (%ecx) LBB2_4: testl %edx, %edx jne LBB2_5 cmpb $0, (%esi) jne LBB2_8 jmp LBB2_6 .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB2_5: cmpl %edx, %esi jne LBB2_8 jmp LBB2_6 .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB2_3: leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%edx,%eax), %esi incl %eax movl %esi, (%ecx) LBB2_1: movl %edx, %esi addl %eax, %esi je LBB2_6 cmpb $0, (%esi) jne LBB2_3 LBB2_6: popl %esi popl %ebp ret</code> </pre><br></td></tr></tbody></table><br>  Well well!  How many branches and checks there are!  The code is obtained using clang 3.4 with -O3 -DNDEBUG.  In practice, for range_strlen, the compiler can generate better code.  If he can assume that ‚Äúend‚Äù is a signal iterator.  But this is only an assumption. <br><br>  In addition, people usually do not write the c_string_range class for working with delimited strings.  They call strlen, and then do the algorithm, thus passing the string twice.  But take the same istream.  With the input interval, such a focus will not pass, since the very finding of the final iterator absorbs the entire interval.  Therefore, there was no alternative but to make a dummy from std :: istream_iterator. <br><br>  Finally, note that c_string_range :: iterator is a forward (forward) iterator, since the signal iterator cannot be reduced.  The interval iterator is as strong as its signal iterator is strong - and it‚Äôs not particularly strong. <br><br><h2>  And now what? </h2><br>  Now it is clear that it is impossible to effectively use STL-algorithms on C-lines.  So what?  Well, the fact that, in general, all string algorithms cannot be used on C-lines.  Look at the beautiful string algorithms in Boost.String_algo.  The documentation is written about support for string types: <br><br><blockquote>  ‚ÄúDefinition: a string is a range of characters that can be accessed sequentially.  The first requirement for a string type is to access it through Boost.Range.  This library allows you to access the elements of a string using iterators. " </blockquote><br><br>  So in Boost.String_algo do not like C-strings.  By the way, what happens if you call std :: regex_search with a C-string?  He will first call strlen!  Even if your line is in megabytes, and the required substring is at the beginning, you still have to go through the entire line, only to find out where it is at the end.  What is the meaning of exactly zero. <br><br>  "Well, do not use the C-line," - you say.  But the problem is more than C-lines.  All intervals with limiters have the same problem.  Only in the standard library there are istream_iterator, istreambuf_iterator, regex_iterator and regex_token_iterator, and all have signal soothers, and all of them are pushed into the library by the same method that I demonstrated earlier. <br><br>  But didn‚Äôt you have such a case, that you had a desire to call a certain general algorithm, but you couldn‚Äôt do this because you wanted to leave the middle of the cycle according to some condition?  Imagine that you can construct an interval with a delimiter, which will have both such a condition and an end iterator.  And you can pass this interval to an algorithm that stops either when the condition is met or when the end is reached.  Voila  But this type of iterator would have to be crammed just like everyone else, and the algorithms that require something more than direct iterators would not work, since the signal iterator cannot be reduced ... <br><br><h2>  What to do </h2><br>  What I am following is this: the abstraction of the interval with a pair of iterators, familiar to all of us, was done with the aim of simple construction of abstractions.  But, in the case of intervals with limiters, it turned out to be difficult to build abstractions.  In addition, these intervals must be modeled by less powerful concepts than they might otherwise be.  What to do?  I have a solution, but we have not reached it yet - at first I want to speculate about infinite intervals.  So stay with us. <br><br>  <i>The first five to get to the end of the article a small gift: 30% discount on a ticket to the conference on the promotional code Ranges</i> <i><br><br></i>  <i><b>Continued:</b></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264473/">Intervals in C ++, part 2: Infinite intervals</a></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264975/">Intervals in C ++, part 3: we represent incrementors (Iterable)</a></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/265355/">Intervals in C ++, part 4: to infinity and beyond</a></i> <i><br><br></i> </div><p>Source: <a href="https://habr.com/ru/post/264201/">https://habr.com/ru/post/264201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264191/index.html">Interpolation of data: we connect points so that it was beautiful</a></li>
<li><a href="../264193/index.html">How to find out the year of release of the song on the set of audio characteristics?</a></li>
<li><a href="../264195/index.html">Hybrid Conf - the first conference on programmatic-advertising in Russia</a></li>
<li><a href="../264197/index.html">HDD sled - cost effective grain</a></li>
<li><a href="../264199/index.html">Triggers and Background Jobs in Windows Store Applications</a></li>
<li><a href="../264207/index.html">Is there a problem with the MTS mobile traffic in some regions, or the skis do not travel?</a></li>
<li><a href="../264209/index.html">PHP library for integration with the New Mail API</a></li>
<li><a href="../264213/index.html">Are you still using CJSON?</a></li>
<li><a href="../264217/index.html">Apply correlation in retail</a></li>
<li><a href="../264219/index.html">ipgeobase in nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>