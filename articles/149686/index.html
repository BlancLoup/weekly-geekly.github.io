<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Forth processor on VHDL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will tell how to write the processor on VHDL. There won't be a lot of code (at least I hope so). The full code is laid out on the gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Forth processor on VHDL</h1><div class="post__text post__text-html js-mediator-article">  In this article I will tell how to write the processor on VHDL.  There won't be a lot of code (at least I hope so).  The full code is laid out on the githaba, and in the same place, you can see several iterations of writing. <br><br>  The processor falls under the class of <a href="http://ru.wikipedia.org/wiki/Soft-%25D0%25BC%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580">soft-processors</a> . <br><a name="habracut"></a><br><h4>  Architecture </h4><br>  First of all, you need to choose a processor architecture.  I will use the <a href="http://ru.wikipedia.org/wiki/RISC">RISC</a> architecture for the processor and the <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2580%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">Harvard</a> memory organization <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2580%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">architecture</a> . <br>  The processor will be without a two-state pipeline: <br><br><ol><li>  Sampling commands and operands </li><li>  Execution of the command and saving the result </li></ol><br>  Since we write the forth-processor, it will be a stack.  This will reduce the bit team, because  <abbr title="team">it</abbr> will not need to store indexes of registers with which calculations are performed.  For operations, the processor will have two upper stacks available. <br>  The data stack and the return stack will be separate. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In FPGA there is a block memory with a configuration of 18 bits * 1024 cells.  Focusing on it, I choose the bit width of a 9-bit command (2048 commands fit in one block of memory). <br>  Let the data memory capacity be ‚Äústandard‚Äù at 32 bits. <br>  I ‚Äúcommunicate‚Äù with peripheral devices using a bus. <br><br>  The scheme of all this disgrace will be approximately the following. <br><img src="https://habrastorage.org/getpro/habr/post_images/b11/5f0/d3e/b115f0d3eba6cefa8d071ab19c23c861.png"><br><br><h4>  Command system </h4><br>  With the architecture decided, now "let's try with all this take off."  Now you need to come up with a system of commands. <br>  All processor commands can be divided into several groups: <br><ul><li>  Load literal (numbers) onto stack </li><li>  Transitions (conditional transition, subroutine call, return) </li><li>  Accessing data memory (read and write) </li><li>  Access to the bus (the meaning is the same as accessing the memory). </li><li>  Teams ALU. </li><li>  Other teams. </li></ul><br>  So, we have 9 discharges of the team, in which we need to meet. <br><br><h5>  Loading literals </h5><br>  The size of the command is less than the digit capacity of the data, so you need to come up with a mechanism for loading numbers. <br><br>  I chose the following command format to load literals onto the stack: <br><table><tbody><tr><th>  <b>Mnemonics</b> </th><th>  <b>eight</b> </th><th>  <b>7</b> </th><th>  <b>6</b> </th><th>  <b>five</b> </th><th>  <b>four</b> </th><th>  <b>3</b> </th><th>  <b>2</b> </th><th>  <b>one</b> </th><th>  <b>0</b> </th></tr><tr><th>  Lit </th><th>  one </th><th colspan="8">  Lit </th></tr></tbody></table><br>  Elder, 8 bits of the command will be a sign of loading numbers.  The remaining 8 bits are the actual number loaded onto the stack. <br>  But the data width is 32 bits, and only 8 bits can be loaded so far. <br>  We agree that if there are several LIT commands in a row, then this is considered to be loading one number.  The first command loads a number on the stack (by expanding it), each subsequent modifies the top number on the stack, shifting it 8 bits to the left and entering the value from the command in the lower part.  Thus, it is possible to load a number of any bit depth with a sequence of several LIT commands. <br>  To separate multiple numbers, you can use any command (for example, NOP). <br><br><h5>  Command grouping </h5><br>  I decided to break all other commands into groups for easy decoding.  We will group by how they affect the stack. <br><table><tbody><tr><th>  <b>Mnemonics</b> </th><th>  <b>eight</b> </th><th>  <b>7</b> </th><th>  <b>6</b> </th><th>  <b>five</b> </th><th>  <b>four</b> </th><th>  <b>3</b> </th><th>  <b>2</b> </th><th>  <b>one</b> </th><th>  <b>0</b> </th></tr><tr><th>  Lit </th><th>  0 </th><th colspan="4">  Group </th><th colspan="4">  Team </th></tr></tbody></table><br><br>  Team groups: <br><table><tbody><tr><th>  <b>Group</b> </th><th>  <b>Takes from the stack</b> </th><th>  <b>Puts on the stack</b> </th><th>  <b>Example</b> </th></tr><tr><th>  0 </th><th>  0 </th><th>  0 </th><th>  NOP </th></tr><tr><th>  one </th><th>  0 </th><th>  one </th><th>  DEPTH </th></tr><tr><th>  2 </th><th>  one </th><th>  0 </th><th>  Drop </th></tr><tr><th>  3 </th><th>  one </th><th>  one </th><th>  DUP @ </th></tr><tr><th>  four </th><th>  2 </th><th>  0 </th><th>  ! OUTPORT </th></tr><tr><th>  five </th><th>  2 </th><th>  one </th><th>  Arithmetic (+, -, AND) </th></tr></tbody></table><br><br>  Transitions: <br><table><tbody><tr><th>  <b>Mnemonics</b> </th><th>  <b>eight</b> </th><th>  <b>7</b> </th><th>  <b>6</b> </th><th>  <b>five</b> </th><th>  <b>four</b> </th><th>  <b>3</b> </th><th>  <b>2</b> </th><th>  <b>one</b> </th><th>  <b>0</b> </th></tr><tr><th>  <b>Jmp</b> </th><th>  0 </th><th colspan="4">  2 </th><th colspan="4">  0 </th></tr><tr><th>  <b>CALL</b> </th><th>  0 </th><th colspan="4">  2 </th><th colspan="4">  one </th></tr><tr><th>  <b>IF</b> </th><th>  0 </th><th colspan="4">  four </th><th colspan="4">  0 </th></tr><tr><th>  <b>RET</b> </th><th>  0 </th><th colspan="4">  0 </th><th colspan="4">  one </th></tr></tbody></table><br>  JMP and CALL commands take the address from the stack and go through it (call additionally puts the return address on the appropriate stack). <br>  The IF command takes the transition address (the top number on the stack) and the transition flag (the next number).  If the sign is equal to zero, then go to the address. <br>  The RET command works with the return stack, picking up the top number and navigating through it. <br>  If the command is not a transition, then the command counter is incremented by one. <br><br><h5>  Command table </h5><br>  For the description of commands the <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">stack notation is used</a> , which looks like this: <br>  <i>&lt;State of the stack before the execution of the word&gt; - &lt;State of the stack after the execution</i> <i><br></i>  <i>words&gt;</i> <br>  The top of the stack is on the right, i.e.  2 3 - 5 means that before the word is executed <br>  at the top of the stack was the number 3, and below it the number 2;  after doing these numbers <br>  turned out to be removed, and on top instead of them was the number 5. <br>  Example: <br>  DUP (a - aa) <br>  DROP (ab - a) <br><br>  Take the minimum set of commands with which you can at least do something. <br><table><tbody><tr><th>  <b>H \ L</b> </th><th>  <b>0</b> </th><th>  <b>one</b> </th><th>  <b>2</b> </th><th>  <b>3</b> </th><th>  <b>four</b> </th><th>  <b>five</b> </th><th>  <b>6</b> </th><th>  <b>7</b> </th><th>  <b>eight</b> </th><th>  <b>9</b> </th></tr><tr><th>  <b>0</b> </th><th>  NOP </th><th>  RET </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr><tr><th>  <b>one</b> </th><th>  TEMP&gt; </th><th>  DEPTH </th><th>  RDEPTH </th><th>  DUP </th><th>  Over </th><th></th><th></th><th></th><th></th><th></th></tr><tr><th>  <b>2</b> </th><th>  Jmp </th><th>  CALL </th><th>  Drop </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr><tr><th>  <b>3</b> </th><th>  @ </th><th>  INPORT </th><th>  NOT </th><th>  SHL </th><th>  SHR </th><th>  SHRA </th><th></th><th></th><th></th><th></th></tr><tr><th>  <b>four</b> </th><th>  IF </th><th>  ! </th><th>  Ouptort </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr><tr><th>  <b>five</b> </th><th>  Nip </th><th>  + </th><th>  - </th><th>  AND </th><th>  OR </th><th>  XOR </th><th>  = </th><th>  &gt; </th><th>  &lt; </th><th>  * </th></tr></tbody></table><br><br><table><tbody><tr><th>  <b>Team</b> </th><th>  <b>Stack notation</b> </th><th>  <b>Description</b> </th></tr><tr><td>  <b>NOP</b> </td><td></td><td>  No operation.  One processor wait time </td></tr><tr><td>  <b>DEPTH</b> </td><td>  <nobr>- D</nobr> </td><td>  Putting on the stack the number of numbers on the data stack before executing this word </td></tr><tr><td>  <b>RDEPTH</b> </td><td>  <nobr>- D</nobr> </td><td>  Placing the number of numbers on the stack on the return stack before the word is executed </td></tr><tr><td>  <b>DUP</b> </td><td>  <nobr>A - AA</nobr> </td><td>  Duplicate top number </td></tr><tr><td>  <b>Over</b> </td><td>  <nobr>AB - ABA</nobr> </td><td>  Copy to the top of the second top number </td></tr><tr><td>  <b>Drop</b> </td><td>  <nobr>A -</nobr> </td><td>  Deleting the top number </td></tr><tr><td>  <b>@</b> </td><td>  <nobr>A - D</nobr> </td><td>  Reading data memory at address A </td></tr><tr><td>  <b>INPORT</b> </td><td>  <nobr>A - D</nobr> </td><td>  Reading data from the bus at A </td></tr><tr><td>  <b>NOT</b> </td><td>  <nobr>A - 0 | -1</nobr> </td><td>  Logical NOT upper number (0 is replaced by -1, any other number is replaced by 0) </td></tr><tr><td>  <b>SHL</b> </td><td>  <nobr>A - B</nobr> </td><td>  Shift the top number by 1 digit to the left </td></tr><tr><td>  <b>SHR</b> </td><td>  <nobr>A - B</nobr> </td><td>  Shift the top number by 1 digit to the right </td></tr><tr><td>  <b>SHRA</b> </td><td>  <nobr>A - B</nobr> </td><td>  Arithmetic shift of the upper number by 1 digit to the right (the sign of the number is preserved) </td></tr><tr><td>  <b>!</b> </td><td>  <nobr>DA -</nobr> </td><td>  Writing data D to address A in the data memory </td></tr><tr><td>  <b>Ouptort</b> </td><td>  <nobr>DA -</nobr> </td><td>  Data record D at address A to the ‚Äúbus‚Äù (the iowr signal will be set for one clock cycle, the periphery must ‚Äúcatch‚Äù its address with a high level of this signal) </td></tr><tr><td>  <b>Nip</b> </td><td>  <nobr>AB - B</nobr> </td><td>  Remove the second from the top of the number from the stack (the number is stored in the register TempReg) </td></tr><tr><td>  <b>TEMP&gt;</b> </td><td>  <nobr>- A</nobr> </td><td>  Extracting the contents of the TempReg register </td></tr><tr><td>  <b>+</b> </td><td>  <nobr>AB - A + B</nobr> </td><td>  Adding top numbers to the stack </td></tr><tr><td>  <b>-</b> </td><td>  <nobr>AB - AB</nobr> </td><td>  Subtract the top number from the second from the top </td></tr><tr><td>  <b>AND</b> </td><td>  <nobr>AB - A and B</nobr> </td><td>  Bitwise AND over upper numbers </td></tr><tr><td>  <b>OR</b> </td><td>  <nobr>AB - A or B</nobr> </td><td>  Bitwise OR over upper numbers </td></tr><tr><td>  <b>XOR</b> </td><td>  <nobr>AB - A xor B</nobr> </td><td>  Bitwise XOR over upper numbers </td></tr><tr><td>  <b>=</b> </td><td>  <nobr>AB - 0 | -1</nobr> </td><td>  Check for equality of upper numbers.  If the numbers are equal, leaves -1 on the stack, otherwise 0 </td></tr><tr><td>  <b>&gt;</b> </td><td>  <nobr>AB - 0 | -1</nobr> </td><td>  Comparison of upper numbers.  If A&gt; B, leaves -1 on the stack, otherwise 0. Comparing with the sign </td></tr><tr><td>  <b>&lt;</b> </td><td>  <nobr>AB - 0 | -1</nobr> </td><td>  Comparison of upper numbers.  If A &lt;B, leaves -1 on the stack, otherwise 0. Comparing with the sign </td></tr><tr><td>  <b>*</b> </td><td>  <nobr>AB - A * B</nobr> </td><td>  Multiplication of the upper numbers </td></tr></tbody></table><br><br>  On the stack for one processor clock cycle, you can write 1 number;  in the fort there is a <b>SWAP</b> command that swaps the top 2 numbers on the stack.  To implement it you need 2 teams.  The first command is <b>NIP</b> (ab - b), deletes the second number ‚Äúa‚Äù from above and stores it in a temporary register, and the second command <b>TEMP&gt;</b> (- a) extracts this number from the temporary register and puts it on top of the stack. <br><br><h4>  We start coding </h4><br>  Realization of memory. <br>  Memory code and data is implemented through a template: <br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rising_edge(clk) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WeA = <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Ram(AddrA) &lt;= DinA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; DoutA &lt;= Ram(AddrA); DoutB &lt;= Ram(AddrB); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>;</code> </pre> <br><br>  Ram is a signal declared as follows: <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">subtype</span></span> RamSignal <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std_logic_vector</span></span>(RamWidth-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRam <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> RamSize-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> RamSignal; <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> Ram: TRam;</code> </pre><br><br>  Memory can be initialized as follows: <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> Ram: TRam := (<span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; conv_std_logic_vector(<span class="hljs-number"><span class="hljs-number">0</span></span>, RamWidth), <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; conv_std_logic_vector(<span class="hljs-number"><span class="hljs-number">1</span></span>, RamWidth), <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; conv_std_logic_vector(<span class="hljs-number"><span class="hljs-number">2</span></span>, RamWidth), <span class="hljs-comment"><span class="hljs-comment">-- ... others =&gt; (others =&gt; '0'));</span></span></code> </pre><br><br>  Stacks are implemented through a similar pattern. <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rising_edge(clk) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WeA = <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Stack(AddrA) &lt;= DinA; DoutA &lt;= DinA; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> DoutA &lt;= Stack(AddrA); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; DoutB &lt;= Stack(AddrB); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>;</code> </pre><br><br>  The only difference from the memory template is that it ‚Äúforwards‚Äù the recorded value to the output.  With the previous template, the recorded value would have been received at the next, after recording, tact. <br><br>  The synthesizer automatically recognizes these patterns and generates the appropriate memory blocks.  This is evident in the report.  For example, for a data stack, it looks like this: <br><pre> <code class="tex hljs">----------------------------------------------------------------------- | ram_type | Distributed | | ----------------------------------------------------------------------- | Port A | | aspect ratio | 16-word x 32-bit | | | clkA | connected to signal &lt;clk&gt; | rise | | weA | connected to signal &lt;DSWeA&gt; | high | | addrA | connected to signal &lt;DSAddrA&gt; | | | diA | connected to signal &lt;DSDinA&gt; | | | doA | connected to internal node | | ----------------------------------------------------------------------- | Port B | | aspect ratio | 16-word x 32-bit | | | addrB | connected to signal &lt;DSAddrB&gt; | | | doB | connected to internal node | | -----------------------------------------------------------------------</code> </pre><br><br>  I think it makes no sense to give the full code for the implementation of memory, it is, in fact, a template. <br><br>  The main cycle of the processor - on the first clock, the command is sampled, on the second - execution.  To determine which processor is on, a fetching signal is made. <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rising_edge(clk) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">--   ip &lt;= (others =&gt; '0'); fetching &lt;= '1'; else if fetching = '1' then fetching &lt;= '0'; else fetching &lt;= '1'; --  ,     end if; end if; end if; end process;</span></span></code> </pre><br>  The easiest option to decode and execute a command is a large ‚Äúcase‚Äù for all options.  For ease of writing, it is better to divide it into several components. <br>  In this project, I broke it into 3 parts: <br><ul><li>  case, which will be responsible for the formation of the address of the data stack, and generate a recording signal; </li><li>  case execution team; </li><li>  case of the formation of a new team counter (ip). </li></ul><br><br><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">-- Data stack addr and we case conv_integer(cmd(8 downto 4)) is when 16 to 31 =&gt; -- LIT if PrevCmdIsLIT = '0' then DSAddrA &lt;= DSAddrA + 1; end if; DSWeA &lt;= '1'; when 0 =&gt; -- group 0; pop 0; push 0 null; when 1 =&gt; -- group 1; pop 0; push 1; DSAddrA &lt;= DSAddrA + 1; DSWeA &lt;= '1'; when 2 =&gt; -- group 2; pop 1; push 0; DSAddrA &lt;= DSAddrA - 1; when 3 =&gt; -- group 3; pop 1; push 1; DSWeA &lt;= '1'; when 4 =&gt; -- group 4; pop 2; push 0; DSAddrA &lt;= DSAddrA - 2; when 5 =&gt; -- group 5; pop 2; push 1; DSAddrA &lt;= DSAddrA - 1; DSWeA &lt;= '1'; when others =&gt; null; end case;</span></span></code> </pre><br><br>  Sampling is part of the command, the lower 4 bits are not used. <br>  All declared groups of teams are painted.  You will only need to change this case when a new group of teams appears. <br><br>  The next case will be responsible for the execution of the command.  It generates data for the data stack (sorry for the tautology), the signal iowr for the OUTPORT command, etc. <br><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">-- Data stack value case conv_integer(cmd) is when 256 to 511 =&gt; -- LIT if PrevCmdIsLIT = '1' then DSDinA &lt;= DSDoutA(DataWidth - 9 downto 0) &amp; Cmd(7 downto 0); else DSDinA &lt;= sxt(Cmd(7 downto 0), DataWidth); end if; when cmdPLUS =&gt; DSDinA &lt;= DSDoutA + DSDoutB; when others =&gt; null; end case;</span></span></code> </pre><br><br>  So far only 2 teams have been implemented.  Loading numbers on the stack and adding the top two numbers on the stack.  This is enough for ‚Äútesting the idea‚Äù, and if these 2 teams work, most of the rest will be implemented ‚Äúon a template‚Äù without any problems. <br><br>  And the last case - the formation of the following address for the command counter: <br><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">-- New ip and ret stack; case conv_integer(cmd) is when cmdJMP =&gt; -- jmp ip &lt;= DSDoutA(ip'range); when cmdIF =&gt; -- if if conv_integer(DSDoutB) = 0 then ip &lt;= DSDoutA(ip'range); else ip &lt;= ip + 1; end if; when cmdCALL =&gt; -- call RSAddrA &lt;= RSAddrA + 1; RSDinA &lt;= ip + 1; RSWeA &lt;= '1'; ip &lt;= DSDoutA(ip'range); when cmdRET =&gt; -- ret RSAddrA &lt;= RSAddrA - 1; ip &lt;= RSDoutA(ip'range); when others =&gt; ip &lt;= ip + 1; end case;</span></span></code> </pre><br><br>  Implemented basic transition commands.  The jump address is taken from the stack. <br><br><h4>  Testing </h4><br>  Before moving on, it is advisable to test already written code.  I created TestBench, in which I entered only the output of the reset signal to the processor in the first 100 ns. <br><br>  The code memory is initialized as follows: <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> CodeMemory: TCodeMemory := ( <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"000000000"</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- lit tests 1 =&gt; "100000000", 2 =&gt; "100000001", 3 =&gt; "100000010", 4 =&gt; "000000000", 5 =&gt; "100001111", 6 =&gt; "000000000", 7 =&gt; "100010000", 8 =&gt; "100001000", 9 =&gt; conv_std_logic_vector(cmdPLUS, CodeWidth), 10 =&gt; conv_std_logic_vector(cmdPLUS, CodeWidth), 11 =&gt; conv_std_logic_vector(cmdDROP, CodeWidth), 12 =&gt; "100010011", 13 =&gt; conv_std_logic_vector(cmdJMP, CodeWidth), -- jmp to 19 14 =&gt; "100000010", 15 =&gt; "000000000", 16 =&gt; "100000010", 17 =&gt; conv_std_logic_vector(cmdPLUS, CodeWidth), 18 =&gt; conv_std_logic_vector(cmdRET, CodeWidth), -- ret 19 =&gt; "100001110", 20 =&gt; conv_std_logic_vector(cmdCALL, CodeWidth), -- call to 14 21 =&gt; "111111111", others =&gt; (others =&gt; '0') );</span></span></code> </pre><br><br>  First, several numbers are put, the addition operation is tested and the stack is cleared with the DROP command.  Next, the transition, subroutine call, and return are tested. <br><br>  The result of the simulation is shown in the following pictures (clickable): <br><br>  The whole test: <br> <a href=""><img src="http://habrastorage.org/storage2/f10/9bf/d2a/f109bfd2a0cc7f0a22f2bab5bafdcc73.png"><br></a> <br><br>  Test load numbers: <br> <a href=""><img src="http://habrastorage.org/storage2/8f4/abd/a83/8f4abda8357c85c01d48edacdbb909cd.png"><br></a> <br><br><h5>  Analysis of loading numbers </h5><br><img src="http://habrastorage.org/storage2/5f5/940/252/5f5940252336801fc77e8962daaebd38.png"><br><br>  The figure shows the execution of the Lit 0 command. After removing the reset signal, the command counter is zero (ip = 0) and the processor is told that it is in the command fetch phase (fetching = '1').  At the first tact sampling is done.  The first NOP command does nothing but increase the command counter (however, any unknown command will increase the command counter, and also can do something with the data stack, depending on the group in which it is located). <br><br>  Team # 1 is loading number 0 onto the stack.  At the execution step, 3 signals are set: the address of the data stack is incremented by 1, the data is set, and the write enable signal is set. <br>  At the next clock cycle of the sample, the value ‚Äú0‚Äù is written to the stack at the address ‚Äú1‚Äù.  The value, also, is immediately "forwarded" to the output (so that the next command operates with a new value).  The write enable signal is removed. <br><br>  Team # 2 is also a command for loading numbers onto the stack.  Because  it follows the LIT command, then the new number per stack will not be loaded, but the upper one will be modified.  It is shifted 8 bits to the left, the lower part is written to the value from the command (which is 0x01). <br><br>  The command # 3 performs the same operations as the command # 2.  The number on the stack, after its operation, is 0x0102. <br><br><h4>  Conclusion </h4><br>  The first teams are tested.  Almost all the remaining commands are written in a pattern (‚Äúdraw circles, draw the rest of the owl‚Äù). <br>  The purpose of the article was to show that you can write the processor yourself, and, I hope, I did it at least to some extent.  The next step is to write the bootloader and cross-compiler, if the habrasoobschestvu would be interested in this article. <br><br>  Github Project: <a href="https://github.com/whiteTigr/vhdl_cpu">github.com/whiteTigr/vhdl_cpu</a> <br>  Processor Code: <a href="">github.com/whiteTigr/vhdl_cpu/blob/master/cpu.vhd</a> <br>  Testbench code (although there is almost nothing in it): <a href="">github.com/whiteTigr/vhdl_cpu/blob/master/cpu_tb.vhd</a> </div><p>Source: <a href="https://habr.com/ru/post/149686/">https://habr.com/ru/post/149686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149684/index.html">Review of Content Designers (Content Construction Kit) for CMS Joomla</a></li>
<li><a href="../149685/index.html">Black color - taboo, myth or necessity?</a></li>
<li><a href="../149687/index.html">Create a Qt interface style using a table as an example.</a></li>
<li><a href="../149691/index.html">Pleasant trifle in the "Express Office" - comfortable keyboard</a></li>
<li><a href="../149693/index.html">KNN classifier</a></li>
<li><a href="../149694/index.html">RabbitMQ tutorial 1 - Hello World</a></li>
<li><a href="../149695/index.html">Monitoring PHP Code Performance with Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>