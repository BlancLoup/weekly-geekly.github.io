<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate Ansible</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under the hood d2c.io we use Ansible. With it, we create virtual machines with cloud providers, install software, as well as manage Docker-containers ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate Ansible</h1><div class="post__text post__text-html js-mediator-article"><p>  Under the hood <a href="https://d2c.io/">d2c.io</a> we use Ansible.  With it, we create virtual machines with cloud providers, install software, as well as manage Docker-containers with client applications. </p><br><p><img align="left" src="https://habrastorage.org/webt/hj/29/qz/hj29qzfukunzphhiwdu3uto1erw.png">  Ansible is a handy tool that is ready for use with almost no configuration.  This is possible due to the absence of agents (agentless system), so there is no need to pre-install anything on the hosts to be serviced. </p><br><p> In most cases, <code>ssh</code> used to connect to hosts.  However, the flip side of this medal is a certain slowness, since all the logic is on the management server and forms each task (task) Ansible locally and sends it to execution via an SSH connection.  It then takes the result, analyzes it, and proceeds to the next step.  In the article we will discuss how to speed up the work of Ansible. </p><a name="habracut"></a><br><h1 id="nachnem-s-izmereniy">  Let's start with the measurements </h1><br><p>  It is impossible to improve what is impossible to measure, so we will write a small script to calculate the execution time. </p><br><p>  First, create a test playbook: </p><br><div class="spoiler">  <b class="spoiler_title">test.yml</b> <div class="spoiler_text"><pre> <code class="hljs delphi">--- - hosts: all # gather_facts: no tasks: - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: Create directory <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>: path: /tmp/ansible_speed state: directory - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: Create <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> copy: content: SPEED dest: /tmp/ansible_speed/speed - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: Remove directory <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>: path: /tmp/ansible_speed state: absent</code> </pre> </div></div><br><p>  And now we will write a script to calculate the execution time: </p><br><div class="spoiler">  <b class="spoiler_title">time_test.sh</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">#!/bin/bash # calculate the mean average of wall clock time from multiple /usr/bin/time results. # credits to https://stackoverflow.com/a/<span class="hljs-number"><span class="hljs-number">8216082</span></span>/<span class="hljs-number"><span class="hljs-number">2795592</span></span> cat /dev/null &gt; time.log for i in `seq <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>`; do echo <span class="hljs-comment"><span class="hljs-comment">"Iteration $i: $@"</span></span> /usr/bin/time -p -a -o time.log <span class="hljs-string"><span class="hljs-string">$@</span></span> rm -rf /home/ubuntu/.ansible/cp/* done file=time.log cnt=<span class="hljs-number"><span class="hljs-number">0</span></span> if [ <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-symbol"><span class="hljs-symbol">#file</span></span>} -lt <span class="hljs-number"><span class="hljs-number">1</span></span> ]; then echo <span class="hljs-comment"><span class="hljs-comment">"you must specify a file containing output of /usr/bin/time results"</span></span> exit <span class="hljs-number"><span class="hljs-number">1</span></span> elif [ <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-symbol"><span class="hljs-symbol">#file</span></span>} -gt <span class="hljs-number"><span class="hljs-number">1</span></span> ]; then samples=(`grep --color=never real <span class="hljs-string"><span class="hljs-string">${</span></span>file} | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> | cut -dm -f2 | cut -ds -f1`) for sample in `grep --color=never real <span class="hljs-string"><span class="hljs-string">${</span></span>file} | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> | cut -dm -f2 | cut -ds -f1`; do cnt=<span class="hljs-string"><span class="hljs-string">$(</span></span>echo <span class="hljs-string"><span class="hljs-string">${</span></span>cnt}+<span class="hljs-string"><span class="hljs-string">${</span></span>sample} | bc -l) done # <span class="hljs-type"><span class="hljs-type">Calculate</span></span> the <span class="hljs-string"><span class="hljs-string">'Mean'</span></span> average (sum / samples). mean_avg=<span class="hljs-string"><span class="hljs-string">$(</span></span>echo <span class="hljs-string"><span class="hljs-string">${</span></span>cnt}/<span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-symbol"><span class="hljs-symbol">#samples</span></span>[@]} | bc -l) mean_avg=<span class="hljs-string"><span class="hljs-string">$(</span></span>echo <span class="hljs-string"><span class="hljs-string">${</span></span>mean_avg} | cut -b1<span class="hljs-number"><span class="hljs-number">-6</span></span>) printf <span class="hljs-comment"><span class="hljs-comment">"\tSamples:\t%s \n\tMean Avg:\t%s\n\n"</span></span> <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-symbol"><span class="hljs-symbol">#samples</span></span>[@]} <span class="hljs-string"><span class="hljs-string">${</span></span>mean_avg} grep --color=never real <span class="hljs-string"><span class="hljs-string">${</span></span>file} fi</code> </pre> </div></div><br><p>  Run our test playbook 10 times and take the average. </p><br><h1 id="ssh-multiplexing">  Ssh multiplexing </h1><br><blockquote>  In the local network: it was 7.68 s, it was 2.38 s <br>  On remote hosts: it was 26.64 s, it was 10.85 s </blockquote><p>  The first thing to check is whether the reuse of SSH connections is working.  Since Ansible performs all actions via SSH, any delay in establishing a connection slows down the execution of the playbook as a whole.  By default, this setting is enabled in Ansible.  In the configuration file, it looks like this: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">ssh_connection</span></span>] ssh_args = -o ControlMaster=auto -o ControlPersist=<span class="hljs-number"><span class="hljs-number">60</span></span>s</code> </pre> <br><p>  However, be careful, if for some reason you override the <code>ssh_args</code> parameter, then you must explicitly specify values ‚Äã‚Äãfor <code>ControlMaster</code> and <code>ControlPersist</code> otherwise Ansible will ‚Äúforget‚Äù about them. </p><br><p>  <strong>You can check</strong> whether your reuse of SSH connections works in your case as follows - run Ansible with the <code>-vvvv</code> parameter: </p><br><pre> <code class="hljs dos">ansible test -vvvv -m <span class="hljs-built_in"><span class="hljs-built_in">ping</span></span></code> </pre> <br><p>  In the output, we should see the launch of SSH with the necessary parameters: </p><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">SSH:</span></span> EXEC ssh -vvv -C -o ControlMaster=auto -o ControlPersist=<span class="hljs-number"><span class="hljs-number">60</span></span>s ... -o ControlPath=<span class="hljs-regexp"><span class="hljs-regexp">/home/ubuntu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/.ansible/cp</span></span><span class="hljs-regexp"><span class="hljs-regexp">/7c223265ce</span></span></code> </pre> <br><p>  And further among the set of debug information: </p><br><pre> <code class="hljs perl">Trying existing master Control <span class="hljs-keyword"><span class="hljs-keyword">socket</span></span> <span class="hljs-string"><span class="hljs-string">"/home/ubuntu/.ansible/cp/7c223265ce"</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist setting up multiplex master <span class="hljs-keyword"><span class="hljs-keyword">socket</span></span></code> </pre> <br><p>  You can also make sure that within 60 seconds after the completion of the task, an open socket can be observed as a file (in our example <code>/home/ubuntu/.ansible/cp/7c223265ce</code> ). </p><br><p>  <strong>Attention:</strong> if you work with several identical environments from one management machine (blue / green deployment, stage / prod), make sure not to shoot yourself in the foot!  If, for example, you first downloaded the actual settings with the sales and the next step you want to update the test environment with the new version of the components, and the SSH sockets remain open from the sale, then oh ... So you need to either make the <code>ControlPath</code> different in these environments or force the wizard to close -sessions or remove sockets before starting work with another medium. </p><br><h1 id="pipelining">  Pipelining </h1><br><blockquote>  In the local network: it was 2.38 s, it became 1.96 s <br>  On remote hosts: it was 10.85 seconds, it became 5.23 seconds </blockquote><p>  By default, Ansible runs modules on target hosts as follows: </p><br><ul><li>  Generates a Python file with a module and its parameters to run on the target machine. </li><li>  It connects via SSH, it recognizes the user's home directory </li><li>  Connects via SSH, creates a temporary directory for work </li><li>  Connects via SSH, SFTP copies the Python file to a temporary directory. </li><li>  Connects via SSH, runs the Python file on the target machine, and deletes the temporary directory </li><li>  Gets the output of the module from standard output. </li></ul><br><p>  Given that the entire list is performed for each task, the costs incur significant.  To speed up this process in Ansible there is a pipelining mode, by analogy with the I / O transfer pipeline between commands in Linux.  In the configuration file, the mode setting looks like this: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">ssh_connection</span></span>] pipelining = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  When using pipelining Ansible mode works as follows: </p><br><ul><li>  Generates a Python file with a module and its parameters to run on the target machine. </li><li>  Connects via SSH, runs the Python interpreter. </li><li>  Sends the contents of the Python file to standard interpreter input. </li><li>  Gets the output of the module from standard output. </li></ul><br><p>  Total: there were 4 SSH connections and a few extra commands, now there‚Äôs one.  Acceleration is obvious, especially for remote servers in the WAN. </p><br><p>  To <strong>check</strong> if your pipelining mode works, you need to run Ansible with advanced logging, for example: </p><br><pre> <code class="hljs dos">ansible test -vvv -m <span class="hljs-built_in"><span class="hljs-built_in">ping</span></span></code> </pre> <br><p>  If there are several <code>ssh</code> calls in the output: </p><br><pre> <code class="hljs mel">SSH: EXEC ssh ... SSH: EXEC ssh ... SSH: EXEC sftp ... SSH: EXEC ssh ... <span class="hljs-keyword"><span class="hljs-keyword">python</span></span> ... ping.py</code> </pre> <br><p>  So the conveyor mode does not work.  If the <code>ssh</code> call is one: </p><br><pre> <code class="hljs perl">SSH: EXEC ssh ... python &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  So pipelining works. </p><br><p>  <strong>Important:</strong> By default, this setting is disabled in Ansible, as it may conflict with the <code>requiretty</code> requirement in <code>sudo</code> settings.  At the time of writing this article, Amazon EC2 has <code>requiretty</code> disabled in the latest Ubuntu and RHEL images, so pipelining can be safely used. </p><br><h1 id="preferredauthentications-i-usedns">  PreferredAuthentications and UseDNS </h1><br><blockquote>  In the local network: it was 1.96 s, it became 1.92 s <br>  On remote hosts: it was 5.23 seconds, it was 4.92 seconds </blockquote><p>  If you manage dozens of target machines, any little thing that affects connection speed is important.  Reverse-DNS queries on the server side and the client side can be one of such trifles, especially if you are using a non-local DNS server. </p><br><h3 id="usedns">  UseDNS </h3><br><p>  UseDNS is an SSH server configuration (/ etc / ssh / sshd_config file) that causes it to check the PTR record to the client‚Äôs IP address.  Fortunately, in modern distributions it is disabled by default.  But just in case, it is worth checking on its target hosts if the primary SSH connection is ‚Äúslowed down‚Äù. </p><br><h3 id="preferredauthentications">  PreferredAuthentications </h3><br><p>  This is an SSH client setting that informs the server about the authentication methods that the client is ready to use.  By default, Ansible uses </p><br><pre> <code class="hljs pgsql">-o PreferredAuthentications=gssapi-<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-mic,gssapi-keyex,hostbased,publickey</code> </pre> <br><p>  And if <code>GSSAPIAuthentication</code> enabled on the servers, such as in the RHEL image on Amazon EC2, then this mode will be tested first.  This will lead to unnecessary steps and attempts to verify PTR records by the client. </p><br><p>  Most often, we only need key authentication, so we‚Äôll point this out explicitly in <code>ansible.cfg</code> : </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">ssh_connection</span></span>] ssh_args = -o ControlMaster=auto -o ControlPersist=<span class="hljs-number"><span class="hljs-number">60</span></span>s -o PreferredAuthentications=publickey</code> </pre> <br><p>  This setting will save the client from unnecessary negotiations with the server and speed up the installation of the master session. </p><br><h1 id="sbor-faktov">  Collecting facts </h1><br><blockquote>  In the local network: it was 1.96 s, it became 1.47 s <br>  On remote hosts: it was 4.92 s, it became 4.77 s </blockquote><p>  When executing playbooks (ad-hoc commands this does not apply) Ansible collects facts about the remote system by default.  This step is similar to running the <code>setup</code> module and also requires a separate SSH connection.  In our test playbook, we do not use a single fact, so we can skip this step by specifying the playbook parameter: </p><br><pre> <code class="hljs pgsql">gather_facts: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span></code> </pre> <br><p>  If you often run playbooks using facts, but collecting facts greatly affects the speed at which playbooks are executed, consider using an external fact caching system (this is partly described <a href="http://docs.ansible.com/ansible/latest/playbooks_variables.html">in the Ansible documentation</a> ).  For example, you set up Redis, which you fill with fresh facts once an hour, and in all working playbooks you turn off the forced collection of facts.  They will now be taken from the local cache. </p><br><h1 id="wan--lan">  WAN ‚Üí LAN </h1><br><blockquote>  It was 4.77 s, it became 1.47 s </blockquote><p>  Despite the fast communication channels, in the local network, everything usually works faster than in the global one.  Therefore, if you often run playbooks on multiple servers, say on Amazon EC2 in the eu-west-1 region, then it is reasonable to place the main management server on the same site.  Depending on the usage scenario, moving the management server closer to the target servers will help to significantly speed up the playlist execution. </p><br><h1 id="pull-rezhim">  Pull mode </h1><br><blockquote>  It was 1.47 s, it became 1.25 s </blockquote><p>  If you need more speed, you can perform a playbook locally on the target server.  To do this, there is the utility <code>ansible-pull</code> .  You can also read about it in the <a href="http://docs.ansible.com/ansible/latest/playbooks_intro.html">official documentation of Ansible</a> .  It works as follows: </p><br><ul><li>  Clones the repository to a local directory. </li><li>  Runs the specified playbook locally (with the <code>-c local</code> parameter) </li><li>  If the playbook is not specified, try running: <br><ul><li> <code>&lt;fqdn&gt;.yml</code> </li> <li> <code>&lt;hostname&gt;.yml</code> </li> <li> <code>local.yml</code> </li> </ul></li></ul><br><p>  One of the use cases is to schedule the repository to be polled and execute a playbook if something has changed (the <code>--only-if-changed</code> parameter). </p><br><h1 id="fork">  Fork </h1><br><p>  In the previous sections, we talked about speeding up the execution of a playbook on each host individually.  But if you start the playbook for dozens of servers at once, then the bottleneck may be the number of forks ‚Äî separate parallel processes for performing tasks on different servers.  In the configuration file, this setting looks like this: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">defaults</span></span>] forks = <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br><p>  The default value of "forks" is 5, which means Ansible communicates with no more than five hosts simultaneously.  Often, the capabilities of the CPU on the management server and the communication channel allow servicing a larger number of hosts simultaneously.  The optimal amount is chosen experimentally in a particular environment. </p><br><p>  Another point about concurrency is that if the number of threads is small and there are a lot of servers, then master ssh sessions can ‚Äúfaint‚Äù, which will result in the need to re-establish a full-fledged SSH session.  This is due to the fact that Ansible defaults to the <code>linear</code> execution strategy.  He waits until one task is completed on all servers and only then proceeds to the next task.  It can happen that the ‚Äúfirst‚Äù server quickly performs the task and then waits until the task is completed on all other servers, so long that the <code>ControlPersist</code> time expires. </p><br><h1 id="poll-interval">  Poll interval </h1><br><p>  After launching the module on the target server, the Ansible process on the management machine goes into continuous polling mode (polling) for incoming results of the module execution.  How aggressively he does this affects the CPU load on the management machine.  And we need CPU time to increase the number of parallel processes (see previous section).  The timeout setting between such internal polls is specified in seconds in the settings file: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">defaults</span></span>] internal_poll_interval = <span class="hljs-number"><span class="hljs-number">0.001</span></span></code> </pre> <br><p>  If you need to run ‚Äúlong-playing‚Äù tasks on a large number of hosts, the result of which does not make sense to check so often, or there is not a lot of free CPUs on the controlling machine, you can do more polling, for example, <code>0.05</code> . </p><br><p>  - </p><br><p>  <strong>PS:</strong> From the highlights, perhaps - everything.  Further speed must be sought already in the optimization of the playbooks themselves, but this is a completely different story. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/343368/">https://habr.com/ru/post/343368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343356/index.html">Interpolation polynomial on arbitrary functions</a></li>
<li><a href="../343358/index.html">We collected the user activity in WPF</a></li>
<li><a href="../343362/index.html">Broadcast h264 video without transcoding and delay</a></li>
<li><a href="../343364/index.html">Simplest RESTful service on Kotlin and Spring boot</a></li>
<li><a href="../343366/index.html">UX-design: common misconceptions and myths</a></li>
<li><a href="../343370/index.html">EPAM + universities: how we work with universities in Russia</a></li>
<li><a href="../343372/index.html">Actual man month</a></li>
<li><a href="../343374/index.html">Real-time application on Vue.js</a></li>
<li><a href="../343376/index.html">Camera logic in a 2D platformer</a></li>
<li><a href="../343378/index.html">Errors of PD operators related to personnel work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>