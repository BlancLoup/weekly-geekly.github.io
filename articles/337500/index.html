<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote browser 3D football. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I want to share a story about how I wrote browser-based 3D football. It all started with the fact that my husband loves football. Watching b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote browser 3D football. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I want to share a story about how I wrote browser-based 3D football.  It all started with the fact that my husband loves football.  Watching broadcasts, goes to the game, plays on the phone.  And so, in order to make him a surprise, and also, in order to tear him away from the device with the game, I decided to write my own game. <br><br><img src="https://habrastorage.org/web/f06/37d/8f2/f0637d8f2d014d66aa0546640c39d9dd.png"><br><br>  Under the cut, I'll tell you how TypeScript and Three.js were friends, and what came of it. <br><a name="habracut"></a><br><h2>  A little about the choice of technology </h2><br>  I already had some experience with the Three.js library, so this time I decided to use it to work with 3D graphics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      TypeScript decided to use it because it‚Äôs just good. <br><br><h2>  Environment setup </h2><br>  A few words about setting up the environment.  Directly to the development of the game itself is irrelevant, but, just in case, I will briefly describe the setup of the project assembly, it may be for someone and it will be useful. <br><br>  First thing: <br><br><pre><code class="bash hljs">$ npm init</code> </pre> <br>  initializes the npm package and creates the package.json file. <br><br>  Package.json configures the scripts block, a set of scripts that can later be run like this: <br><br><pre> <code class="bash hljs">$ npm run &lt;SCRIPT_NAME&gt;</code> </pre><br>  Here is my set of scripts: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"clean"</span></span>: <span class="hljs-string"><span class="hljs-string">"rm -rf ./tmp ./dist"</span></span>, <span class="hljs-string"><span class="hljs-string">"copy"</span></span>: <span class="hljs-string"><span class="hljs-string">"./bin/copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>: <span class="hljs-string"><span class="hljs-string">"./node_modules/.bin/tsc"</span></span>, <span class="hljs-string"><span class="hljs-string">"requirejs"</span></span>: <span class="hljs-string"><span class="hljs-string">"./bin/requirejs"</span></span>, <span class="hljs-string"><span class="hljs-string">"js"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run ts &amp;&amp; npm run requirejs"</span></span>, <span class="hljs-string"><span class="hljs-string">"css"</span></span>: <span class="hljs-string"><span class="hljs-string">"./bin/compile-css"</span></span>, <span class="hljs-string"><span class="hljs-string">"build"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run clean &amp;&amp; npm run js &amp;&amp; npm run css &amp;&amp; npm run copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"server"</span></span>: <span class="hljs-string"><span class="hljs-string">"./node_modules/.bin/http-server ./dist"</span></span>, <span class="hljs-string"><span class="hljs-string">"dev"</span></span>: <span class="hljs-string"><span class="hljs-string">"./bin/watcher &amp; npm run server"</span></span> }</code> </pre><br>  Respectively: <br><br><ul><li>  clean - cleansing rebuilt files </li><li>  copy - copy required files </li><li>  ts - typescript compilation </li><li>  requirejs - build requirejs </li><li>  js - run two previous commands in sequence </li><li>  css - compile css </li><li>  build- complete build </li><li>  server - start http server to return statics </li><li>  dev - run in dev mode (tracking changes + http server) </li></ul><br>  Multiple executables: <br><br>  <b>bin / compile-css</b> - creates, if necessary, the directory dist / css and starts the compilation of stylus styles: <br><br><div class="spoiler">  <b class="spoiler_title">bin / compile-css</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if [ ! -d ./dist/css ]; then mkdir -p ./dist/css fi ./node_modules/.bin/stylus ./src/styles/index.styl -o ./dist/css/styles.css</span></span></code> </pre><br></div></div><br>  <b>bin / copy</b> - creates, if necessary, the necessary directories and copies dependencies from node_modules, html files and resources. <br><br><div class="spoiler">  <b class="spoiler_title">bin / copy</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash cp ./src/*.html ./dist if [ ! -d ./dist/js/libs ]; then mkdir -p ./dist/js/libs fi if [ ! -d ./dist/js/libs/three/loaders ]; then mkdir -p ./dist/js/libs/three/loaders fi cp ./node_modules/three/build/three.js ./dist/js/libs/three.js cp -r ./node_modules/three/examples/js/loaders/sea3d ./dist/js/libs/three/loaders/sea3d cp -r ./node_modules/three/examples/js/loaders/TDSLoader.js ./dist/js/libs/three/loaders/TDSLoader.js cp -r ./src/resources ./dist/resources</span></span></code> </pre><br></div></div><br>  <b>bin / requirejs</b> - collects js files in one bundle. <br><br><div class="spoiler">  <b class="spoiler_title">bin / requirejs</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env node const requirejs = require('requirejs'); const config = { baseUrl: "tmp/js", dir: "./dist/js", optimize: 'none', preserveLicenseComments: false, generateSourceMaps: false, wrap: { startFile: './node_modules/requirejs/require.js' }, modules: [ { name: 'football' } ] }; requirejs.optimize(config, function (results) { console.log(results); });</span></span></code> </pre><br></div></div><br><h2>  First problems </h2><br>  The first problems lurked already at the stage of installing dependencies and running compilation typescript. <br><br>  Having installed the Three.js and TypeSript dependencies: <br><br><pre> <code class="bash hljs">$ npm install three --save $ npm install typescript --save-dev</code> </pre><br>  It seemed like a logical step to check if there are any ready taipings for Three.js.  It turned out that there is - <a href="https://www.npmjs.com/package/%40types/three">@ types / three</a> .  And I rushed to install them: <br><br><pre> <code class="bash hljs">$ npm install @types/three --save-dev</code> </pre><br>  However, as it turned out, these taipings turned out to be not quite high-quality, and when the compilation was launched they were immediately sprinkled with a lot of similar errors of the following type: <br><br><pre> <code class="bash hljs">$ npm run ts ... node_modules/@types/three/three-core.d.ts(1611,32): error TS2503: Cannot find namespace <span class="hljs-string"><span class="hljs-string">'THREE'</span></span>.</code> </pre><br>  Looking in <b>node_modules/@types/three/index.d.ts I</b> saw something like this structure: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./three-core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./three-canvasrenderer"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./three-vreffect"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> namespace THREE;</code> </pre><br>  Those.  it turns out that all internal descriptions are connected first, and then all this is declared by the <i>THREE</i> namespace and exported outside.  But, at the same time, in the very first inclusion - in the three-core.d.ts space is already used <i>THREE</i> , which will be announced later. <br><br>  How it worked for someone is unknown (someone after all is commited). <br><br>  I had an assumption that the namespace had ‚Äúretroactive effect‚Äù in some previous versions of typescript, and decided to abandon similar extravagance to the current version, but did not bring a consistent rollback to previous versions. <br><br>  Then I decided to look where exactly <i>THREE</i> is used in <b>three-core.d.ts</b> and as it turned out all uses were concentrated in two adjacent methods: <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/** * Calls before rendering object */</span></span> onBeforeRender: (renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.Camera, geometry: THREE.Geometry | THREE.BufferGeometry, material: THREE.Material, <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>: THREE.<span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">void</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Calls after rendering object */</span></span> onAfterRender: (renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.Camera, geometry: THREE.Geometry | THREE.BufferGeometry, material: THREE.Material, <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>: THREE.<span class="hljs-keyword"><span class="hljs-keyword">Group</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">void</span></span>;</code> </pre><br>  At the same time, all types that were specified in the <i>THREE</i> namespace were described right there, in <b>three-core.d.ts</b> .  This means that in order to use them you do not need a namespace or additional imports.  Just removed <i>THREE</i> , launched the compilation again and - voila, the compilation was successful. <br><br><h2>  Light, camera, <s>motor</s> </h2><br>  The light source and camera are integral parts of any 3D scene.  Which, of course, must also be created: <br><br><pre> <code class="hljs cs">import { Camera, Scene } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'three'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> scene: Scene; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> camera: Camera; constructor() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createScene(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createCamera(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createLight(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">75</span></span>, window.innerWidth / window.innerHeight, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ambient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.AmbientLight(<span class="hljs-number"><span class="hljs-number">0xffffff</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(ambient); } }</code> </pre><br>  You also need to create a canvas for drawing, add it to the document and stretch it to full screen: <br><br><pre> <code class="hljs kotlin">... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> renderer: WebGLRenderer; ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> createRenderer() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = new THREE.WebGLRenderer(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateRendererSize(); document.body.appendChild(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.domElement); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> updateRendererSize() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.setSize(window.innerWidth, window.innerHeight); }</code> </pre><br>  And call <i>createRenderer</i> in the constructor: <br><br><pre> <code class="hljs delphi">... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ this.createRenderer(); }</span></span></span></span></code> </pre><br>  Well, the final touch of the starting scene setting is redrawing: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animate(); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> animate() { window.requestAnimationFrame(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.render(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera); }</code> </pre><br><h2>  Playing field </h2><br>  Having prepared the scene, you can start adding objects related directly to football.  And it seemed to me logical to start from the field. <br><br>  The texture for the field without any problems was found on the Internet (which cannot be said about 3d-models, but more on that below): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8c4/4d5/5fb/8c44d55fbb274b809ce4e5977044ac62.jpg" width="110" height="195"></div><br><br>  <b>field.ts</b> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BASE_URL } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./const'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Scene, Texture } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'three'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FIELD_WIDTH = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FIELD_HEIGHT = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span></span>{ protected scene: Scene; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.TextureLoader(); loader.load(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ BASE_URL }</span></span></span><span class="hljs-string">/resources/textures/field.jpg`</span></span>, (texture: Texture) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial({ <span class="hljs-attr"><span class="hljs-attr">map</span></span>: texture }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PlaneGeometry(FIELD_HEIGHT, FIELD_WIDTH); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plane = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Mesh(geometry, material); plane.rotateX(<span class="hljs-number"><span class="hljs-number">-90</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); plane.rotateZ(<span class="hljs-number"><span class="hljs-number">90</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene.add(plane); }); } }</code> </pre><br>  As you can see, the texture is loaded first, then an object of the class <b>PlaneGeometry is created</b> , this texture is superimposed on it.  After that, the object rotates around the X and Z axes slightly. <br><br>  As a result, we get the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c18/e12/cf4/c18e12cf48e1467dab818b3a39dd3c7a.png"></div><br>  No football will work if there is no goal on the field.  Therefore, I decided to use the next step to find a free 3D-model of a football goal on the Internet, create two-sided goal objects and add them to the stage.  But here I was in for an unpleasant surprise, about which a slight lyrical digression would tell. <br><br><h4>  Lyrical digression </h4><br>  Suddenly for myself, I found out that finding a suitable 3D model is not a trivial exercise.  Most of the good models were paid, and cost quite a lot (in my opinion) money.  And in search of the unfortunate football goal was spent quite a lot of time.  I, of course, do not call for the free distribution of everything and everything, but here in the field of software development there is a huge reservoir of free open source software, one github is worth something.  Free audio, photos and many other file types are also usually easy to find.  Perhaps in all these areas free analogs will somehow lose to commercial offers (and in some ways, by the way, they will win), but at least they are there, and it is not particularly difficult to find them.  What can be said about the field of 3D-modeling. <br><br>  Maybe I‚Äôm missing some detail, or I don‚Äôt know something about 3D modeling, that I would immediately dot the i and explain why there are so few free models, and those that are difficult to find and / or they are noticeably inferior in quality .  I would be glad to hear an alternative point of view in the comments. <br><br>  For the whole game, all I needed was to find models of the goal, players and the ball.  And according to a rough estimate, 20-30% of the total time spent on development was spent searching for suitable models. <br><br><h2>  Like a ram on a new gate </h2><br>  But back to our sheep, more precisely to the gate.  The necessary model was still found, which allowed to realize the class of the gate: <br><br>  <b>Gate.ts</b> <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-type"><span class="hljs-type">BASE_URL</span></span> } from './const'; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-type"><span class="hljs-type">Mesh</span></span>, <span class="hljs-type"><span class="hljs-type">Object3D</span></span> } from <span class="hljs-symbol"><span class="hljs-symbol">'thre</span></span>e'; export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FootballObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> mesh: <span class="hljs-type"><span class="hljs-type">Mesh</span></span>; load() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Promise</span></span>((resolve, reject) =&gt; { const loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">THREE</span></span>.<span class="hljs-type"><span class="hljs-type">TDSLoader</span></span>(); loader.load(`${ <span class="hljs-type"><span class="hljs-type">BASE_URL</span></span> }/resources/models/gate<span class="hljs-number"><span class="hljs-number">.3</span></span>ds`, (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Object3D</span></span>) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">THREE</span></span>.<span class="hljs-type"><span class="hljs-type">Mesh</span></span>((&lt;<span class="hljs-type"><span class="hljs-type">Mesh</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children</span></span></span><span class="hljs-class">[0]).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geometry</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THREE</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshBasicMaterial</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">{color: 0xFFFFFF}</span></span></span><span class="hljs-class">))</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.scale.set(<span class="hljs-number"><span class="hljs-number">.15</span></span>, <span class="hljs-number"><span class="hljs-number">.15</span></span>, <span class="hljs-number"><span class="hljs-number">.15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh); resolve(); }); }); } }</code> </pre><br>  In order for the gate to fit us, we had to squeeze them a little, which happens in the line: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mesh</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scale</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.set</span></span>(<span class="hljs-selector-class"><span class="hljs-selector-class">.15</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.15</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.15</span></span>);</code> </pre><br>  A particularly attentive reader may notice that the <i>Gate</i> class is inherited from the <i>FootballObject</i> class, whose implementation was not cited.  Immediately eliminate this blatant injustice. <br><br>  <b>Object.ts</b> <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Mesh, Scene } from <span class="hljs-string"><span class="hljs-string">'three'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FootballObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> mesh: Mesh; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> scene: Scene; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene = scene; } setPositionX(x: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.position.x = x; } setPositionY(y: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.position.y = y; } setPositionZ(z: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.position.z = z; } getPositionX(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.position.x; } getPositionY(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.position.y; } getPositionZ(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.position.z; } setRotateX(angle: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.rotateX(angle * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } setRotateY(angle: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.rotateY(angle * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } setRotateZ(angle: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mesh.rotateZ(angle * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } }</code> </pre><br>  Subsequently, the <i>Player</i> (players) and <i>Ball</i> (ball) classes will also be inherited from <i>FootballObject</i> , which contains the implementation of methods for setting the position on the stage and rotating at a certain angle, given in degrees. <br><br>  After that we need to create gate objects and place them along the necessary coordinates: <br><br>  <b>app.ts</b> <br><br><pre> <code class="hljs kotlin">... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field, FIELD_HEIGHT, FIELD_WIDTH } from <span class="hljs-string"><span class="hljs-string">'./field'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Gate } from <span class="hljs-string"><span class="hljs-string">'./gate'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> leftGate: Gate; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> rightGate: Gate; ... <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createGates(); } ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> createGates() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DELTA_X = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.leftGate = new Gate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rightGate = new Gate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.leftGate.load() .then(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.leftGate.setPositionX(- FIELD_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span> + DELTA_X); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.leftGate.setPositionY(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.leftGate.setRotateX(-<span class="hljs-number"><span class="hljs-number">90</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.leftGate.setRotateZ(<span class="hljs-number"><span class="hljs-number">180</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rightGate.load() .then(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rightGate.setPositionX(FIELD_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span> - DELTA_X); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rightGate.setPositionY(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rightGate.setRotateX(-<span class="hljs-number"><span class="hljs-number">90</span></span>); }); } }</code> </pre><br>  <i>DELTA_X</i> - some offset, which required to correct the coordinates of the gate, so that they stood clearly on the markings of the field. <br><br>  As you can see, the left gate shifts to half the field in a negative direction (i.e., to the left), the right gate moves to the same half of the field in a positive direction (that is, to the right). <br>  Both models rotate to get their natural position on the field. <br>  The result of this is this picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/951/024/743/95102474361149b7aab8a84ae955595f.png"></div><br>  Initially, I did not plan to stretch it into several articles, but somehow it turns out to be volumetric, therefore, perhaps, on this beautiful note I will complete the first part of the article about self-made football. <br><br>  In the second part I will talk about the creation of teams and players, their placement on the field and strategies. <br><br>  In order not to spoil and keep the intrigue to the end, I will lay out the source code and the demo in the last part of the article. <br><br>  Thank you all for your attention! </div><p>Source: <a href="https://habr.com/ru/post/337500/">https://habr.com/ru/post/337500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337490/index.html">On the culture of development in groups of programmers</a></li>
<li><a href="../337492/index.html">We teach webworkers good manners</a></li>
<li><a href="../337494/index.html">Using Python to process real-time information from sensors that work with Arduino</a></li>
<li><a href="../337496/index.html">How chat bots give reason for Sberbank's IT projects</a></li>
<li><a href="../337498/index.html">How to meet consumer expectations regarding the Internet of Things? (survey results)</a></li>
<li><a href="../337502/index.html">PostgreSQL Indexes - 6</a></li>
<li><a href="../337504/index.html">Bank card instead of travel card</a></li>
<li><a href="../337508/index.html">Era IoT: how to enter?</a></li>
<li><a href="../337512/index.html">Typical use of Observable objects in Angular 4</a></li>
<li><a href="../337516/index.html">Artificial Intelligence for Retail: Skynet level salespeople, God level reviews</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>