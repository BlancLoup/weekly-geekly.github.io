<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The interior of the boolinq for adults</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is for those who are interested in the implementation of the boolinq library from my previous post . In this article I‚Äôll dig into the so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The interior of the boolinq for adults</h1><div class="post__text post__text-html js-mediator-article">  This article is for those who are interested in the implementation of the boolinq library from <a href="http://habrahabr.ru/post/142632/">my previous post</a> .  In this article I‚Äôll dig into the source and show some interesting techniques that made the library lazy and extensible. <br><br><img src="https://habrastorage.org/storage2/971/434/e75/971434e75cdce5b50c3d953248f04558.jpg"><br><a name="habracut"></a><br><br><h3>  What is wrong with iterators? </h3><br>  Before we look at the library code, I would like to draw your attention to STL.  This is a standard library of templates, contains containers, algorithms, etc.  One of the most interesting elements of the library is the entity - <i>iterator</i> .  Iterators were designed to be a layer between containers and algorithms.  So that any algorithm can be applied to any container (well, almost any). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At first glance, everything is fine.  Algorithms and containers are connected through an intermediate entity - an iterator.  But this is only at first glance, if you look at the code: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::iterator it = candles.begin(); it != candles.end(); it++) sum += it-&gt;ClosePrice;</code> </pre> <br>  There is one drawback of STL-iterators, which is not noticeable at first glance, Java iterators are deprived of this minus. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; Iterator it = al.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (it.hasNext()) { it = it.next(); sum += it.ClosePrice; }</code> </pre> <br>  Yes, these are <code>.begin()</code> and <code>.end()</code> - these are two parts of the same entity.  If these two parts were taken and combined into one entity ... It is said - done (the idea was borrowed from Alexandrescu from the <a href="http://www.slideshare.net/rawwell/iteratorsmustgo">‚ÄúIterators Must Go‚Äù</a> presentation): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TIter&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IterRange</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator_traits&lt;TIter&gt;::value_type value_type; IterRange(TIter b, TIter e) : b(b), e(e) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (b == e); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assert(!empty()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(b++); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assert(!empty()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(--e); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assert(!empty()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *b; } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assert(!empty()); TIter tmp = e; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(--tmp); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TIter b; TIter e; };</code> </pre> <br>  Thus, we have one entity, we can ask it if there are more elements in the sequence, request an element and request to proceed to the next element.  In fact, the <code>back()</code> and <code>popBack()</code> methods also do not interfere. <br><br>  Well, then it is not difficult to guess how all the classes of the library look like - these are wrappers over such a Range.  For example, WhereRange looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhereRange</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R::value_type value_type; WhereRange(R r, F f) : r(r), f(f) , frontReady(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) , backReady(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frontReady) seekFront(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.empty(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frontReady) seekFront(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmp = *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; r.popFront(); frontReady = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp.front(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  } value_type front() { if (!frontReady) seekFront(); return r.front(); } value_type back() { //  } private: void seekFront() { while(!r.empty() &amp;&amp; !f(r.front())) r.popFront(); frontReady = true; } void seekBack() { //  } private: R r; F f; bool frontReady; bool backReady; };</span></span></code> </pre> <br>  In a nutshell: the class accepts a different Range in the constructor, from which it has to take elements, and a predicate that determines the belonging of each element to the resulting sample.  There are 2 variables that determine whether the value "from the beginning" and "from the end" of the Range is found.  The seekFront () and seekBack () functions directly search for the next front and next back. <br><br>  Actually all the other Range-and look similar.  The next problem was to reduce the use to the point notation ... <br><br><h3>  I want a dot notation </h3><br>  On the one hand, I wanted to make use of methods as they are used in .NET LINQ, but after all, C ++ does not have <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">Extension Methods</a> as in C #: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = arr.Where(...).OrderBy(...).Select(...).Max();</code> </pre> <br>  On the other hand, I wanted to make the library extensible ... and <i>this</i> thought came)) The Linq class will be wrapped at the top of all Range, when calling the transforming sequence of methods, the Linq class nested in Linq will turn around, and the Linq class will remain on top of all. <br><br>  I made each Range class for the following mixin class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLinq</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhereRange_mixin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; TLinq&lt;WhereRange&lt;R,F&gt; &gt; where(F f) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boolinq::where(((TLinq&lt;R&gt;*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;r,f); } };</code> </pre> <br>  Then, I inherited the Linq class from all the necessary Mixins: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linq</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SkipRange_mixin&lt;Linq,R&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TakeRange_mixin&lt;Linq,R&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WhereRange_mixin&lt;Linq,R&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SelectRange_mixin&lt;Linq,R&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReverseRange_mixin&lt;Linq,R&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OrderByRange_mixin&lt;Linq,R&gt; <span class="hljs-comment"><span class="hljs-comment">// ...   ... { public: typedef typename R::value_type value_type; Linq(const R &amp; r) : r(r) { } bool empty() { return r.empty(); } value_type popFront() { return r.popFront(); } value_type popBack() { return r.popBack(); } value_type front() { return r.front(); } value_type back() { return r.back(); } public: R r; };</span></span></code> </pre> <br><br><h3>  Reversing the order of elements </h3><br>  I wanted to dwell separately on this feature.  She is remarkable because I really wanted to nail the double reverse of the sequence.  And not to beat a compilation error, but in an amicable way.  Class code is pretty simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReverseRange</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R::value_type value_type; ReverseRange(R r) : r(r) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.empty(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.popBack(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.popFront(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.back(); } <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.front(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> R2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReverseRange&lt;R2&gt; r)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// smart needed private: R r; };</span></span></code> </pre> <br>  Everything in this code is exactly as you expected: the methods working with front and back are changed to the opposite, but a friendly function is lost among them.  And it is Friendly, then, in order to crawl to a private field - a wrapped Range, this is the actual code for this function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; ReverseRange&lt;R&gt; reverse(R r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } <span class="hljs-comment"><span class="hljs-comment">// Unwrap for double-reverse case template&lt;typename R&gt; R reverse(ReverseRange&lt;R&gt; r) { return rr; // smart }</span></span></code> </pre> <br>  Yes!  Function is not one - there are two of them.  The first one works as it should - wraps the Range with our ReaverseRange (here an implicit constructor call occurs).  The second one, on the contrary, unfolds ReverseRange.  It is important that this happens at the compilation level, and not at the execution stage.  But this is not the most difficult thing - hell started when I tried to portray it in Mixin: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLinq</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReverseRange_mixin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TLinq&lt;ReverseRange&lt;R&gt; &gt; reverse() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boolinq::reverse(((TLinq&lt;R&gt;*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;r); } }; <span class="hljs-comment"><span class="hljs-comment">// Unwrap for double-reverse case template&lt;template&lt;typename&gt; class TLinq, typename T&gt; class ReverseRange_mixin&lt;TLinq,ReverseRange&lt;T&gt; &gt; { public: TLinq&lt;T&gt; reverse() const { return boolinq::reverse(((TLinq&lt;ReverseRange&lt;T&gt; &gt;*)this)-&gt;r); } };</span></span></code> </pre> <br><br>  Again, the first Mixin does not do anything unusual, but the second at the compilation stage reveals the type <code>Linq&lt;ReverseRange&lt;XxxRange&lt;...&gt;&gt;&gt;</code> and expands it to <code>Linq&lt;XxxRange&lt;...&gt;&gt;</code> .  Brain broke while got compiled code. <br><br><h3>  How can a user expand a library? </h3><br>  The idea was as follows, let him create his magic Range-class, then create a Mixin-class in the image and likeness of other Mixin-s.  And after that, it creates its own class CustomLinq and uses it when creating the initial sequence (it‚Äôs impossible to inherit from Linq, because its Mixins will wrap everything not in CustomLinq, but in Linq): <br><br><pre> <code class="cpp hljs">boolinq::from&lt;CustomLinq&gt;(arr)</code> </pre> <br>  instead: <br><br><pre> <code class="cpp hljs">boolinq::from(arr)</code> </pre> <br>  Well, the user can do without all this and do not use the dot notation at all.  After all, you can write code like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boolinq; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = sum(select(where(from(arr), [](...){...}), [](...){...}));</code> </pre> <br><br><h3>  Performance tests </h3><br>  I will carry out the test specifically for those interested: we will assume the variance of the random variable.  First, we find the average value of all odd elements of the vector, then we calculate the standard deviation of odd elements from the average. <br><br>  1. Generate 100 million pseudo-random elements: <br><br><pre> <code class="cpp hljs">srand(<span class="hljs-number"><span class="hljs-number">0xDEADBEEF</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec(<span class="hljs-number"><span class="hljs-number">100000000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vec.size(); i++) vec[i] = rand();</code> </pre> <br>  2. Write an algorithm in C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      double sum = 0; int count = 0; for (unsigned i = 0; i &lt; vec.size(); i++) { if (vec[i] % 2 == 1) { sum += vec[i]; count++; } } double avgValue = sum / count; //       avgValue double disperSum = 0; for (unsigned i = 0; i &lt; vec.size(); i++) if (vec[i] % 2 == 1) disperSum += (vec[i] - avgValue)*(vec[i] - avgValue); double disper = disperSum / count;</span></span></code> </pre><br>  3. Let's write the algorithm on boolinq <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      double avgValue = from(vec).where( [](int a){return a%2 == 1;}) .cast&lt;double&gt;() .avg(); //       avgValue double disper = from(vec).where( [](int a){return a%2 == 1;}) .select([=](int a){return (a-avgValue)*(a-avgValue);}) .cast&lt;double&gt;() .avg();</span></span></code> </pre> <br>  Do not see that C ++ code does not use iterators.  I wrote the code with iterators, but let me not upload it - it is absolutely similar.  Now let's compile in the <b>release</b> in MS Visual C ++ 2010 and run it on my machine ... <br><table><tbody><tr><td>  C ++ Code </td><td>  1207 ms </td></tr><tr><td>  C ++ code with iterators </td><td>  1224 ms </td></tr><tr><td>  Boolinq code </td><td>  1564 ms </td></tr></tbody></table><br>  Boolinq, of course, loses a little (by a third) - but again it depends on the tasks.  In theory, you need to test all methods separately.  By the way, .NET LINQ loses analogue on cycles much, much stronger. <br><br>  In the near future, it is planned to add the <code>.begin()</code> and <code>.end()</code> methods to the Linq class for backward compatibility with STL. </div><p>Source: <a href="https://habr.com/ru/post/142657/">https://habr.com/ru/post/142657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142648/index.html">One Nginx config for working with a bunch of different sites</a></li>
<li><a href="../142649/index.html">Valve: how I got here, what it looks like and what I do here</a></li>
<li><a href="../142650/index.html">Kickstarter: Consumer Finance Statistics</a></li>
<li><a href="../142651/index.html">Gift from China - fake external hard drive from WD</a></li>
<li><a href="../142652/index.html">Data collection from recording devices</a></li>
<li><a href="../142658/index.html">UEFA shows how not to make a survey form on the site</a></li>
<li><a href="../142659/index.html">SkyDrive cloud storage received a big update</a></li>
<li><a href="../142661/index.html">New Galaxy</a></li>
<li><a href="../142662/index.html">Dot the C / C ++ structures</a></li>
<li><a href="../142663/index.html">Oh, an! - You've got an App</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>