<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kernel tracing with ftrace</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have already touched upon the problems of kernel tracing and profiling in previous publications . There are many specialized tools for analyzing ev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kernel tracing with ftrace</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f67/772/158/f677721586e93140511c09eca4811988.png" alt="PR-1801-2-2" width="100%" height="100%"><br><br>  We have already touched upon the problems of kernel tracing and profiling <a href="https://blog.selectel.ru/sysdig-instrument-dlya-diagnostiki-linux-sistem/">in previous publications</a> .  There are many specialized tools for analyzing events at the kernel level: <a href="https://sourceware.org/systemtap/" rel="nofollow">SystemTap</a> , <a href="http://www.ktap.org/" rel="nofollow">Ktap</a> , <a href="http://www.sysdig.org/">Sysdig</a> , <a href="http://lttng.org/">LTTNG,</a> and others.  There are many detailed articles and educational materials about these tools. <br><br>  Much less information can be found about Linux's ‚Äúnative‚Äù mechanisms, with which you can monitor system events, receive and analyze debug information.  We would like to consider this topic in today's article.  We will pay special attention to <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" rel="nofollow">ftrace</a> - the first and so far the only trace tool added to the kernel.  Let's start with the definition of basic concepts. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Core profiling and tracing </h2><br><br>  <b>Kernel profiling</b> is the identification of performance bottlenecks.  Using profiling, you can determine where exactly the performance loss occurred in a particular program.  Special programs generate a profile - a summary of events on the basis of which you can find out which functions took the most time to complete.  These programs, however, do not help to identify the cause of the decline in performance. <br><br>  ‚ÄúBottlenecks‚Äù very often arise under certain conditions, which cannot be identified during profiling.  To understand why an event happened, you need to restore the context.  In turn, <b>tracing</b> is required to restore context. <br><br>  Tracing is the receipt of information about what is happening inside the operating system.  For this purpose, special software tools are used.  They record all events in the system just as the tape recorder records all the sounds of the environment. <br><br>  Tracer programs can simultaneously monitor events at the level of individual applications and at the level of the operating system.  Information obtained during tracing may be useful for diagnosing and solving many system problems. <br><br>  Tracing is sometimes compared with logging.  There are similarities between the two procedures, but there are differences. <br><br>  During the trace information about events occurring at a low level is recorded.  Their number is in the hundreds and even thousands.  Logs also record information about high-level events that occur much less frequently: for example, user logons, application errors, database transactions, and others. <br><br>  Like logs, files with trace data can be read "from the sheet."  It is much more interesting and useful, however, to extract information from them that relates to the work of specific applications.  All tracer programs have corresponding functions. <br><br>  In the Linux kernel, there are three main mechanisms by which the procedures for tracing and profiling the kernel are performed: <br><br><ul><li>  tracepoints - a mechanism that works through static code instrumentation; </li><li>  kprobes - a dynamic tracing mechanism, with which you can interrupt the execution of kernel code anywhere, call your own handler, and after completing all necessary operations, go back; </li><li>  perf_events - PMU access interface (Performance Monitoring Unit). </li></ul><br><br>  We will not describe in detail the features of all these mechanisms;  interested readers refer to the <a href="https://habrahabr.ru/company/metrotek/blog/261003/">article of STC MetroTek</a> , as well as the <a href="http://www.brendangregg.com/blog/index.html" rel="nofollow">blog by Brendan Gregg</a> . <br><br>  Using ftrace, you can interact with these mechanisms and receive debugging data while in user space.  We'll talk more about this below.  All command examples are for OS Ubuntu 14.04, kernel version 3.13.0-24. <br><br><h2>  Ftrace: general information </h2><br><br>  The name ftrace is an abbreviation for Function Trace - tracing functions.  However, the capabilities of this tool are much broader: with its help, you can track contextual switches, measure interrupt processing times, calculate time for activating tasks with high priority, and much more. <br><br>  Ftrace was developed by Stephen Rostedt and added to the core in 2008, starting with version 2.6.27.  This is a framework that provides a debug ring buffer for writing data.  These tracers are built into the kernel. <br><br>  The ftrace works on the debugfs file system, which in most modern Linux distributions is mounted by default.  To get started with ftrace, you just need to go to the sys / kernel / debug / tracing directory (it is available only to the root user): <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cd /sys/kernel/debug/tracing</span></span></code> </pre> <br><br>  We will not talk in detail about all the files and subdirectories it contains - this is already done in the <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" rel="nofollow">official documentation</a> .  We briefly describe only those of them that are of interest in the context of our consideration: <br><br><ul><li>  available_tracers ‚Äî available tracers; <br>  current_tracer - the current tracing program; </li><li>  tracing_on - service file, responsible for enabling and disabling data recording in the ring buffer (to enable recording, write number 1 to this file, and to disable it, 0); </li><li>  trace is a file where trace data is stored in a human readable format. </li></ul><br><br><h2>  Available tracers </h2><br><br>  You can view the list of available tracers using the command <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment">#: cat available_tracers blk mmiotrace function_graph wakeup_rt wakeup function nop</span></span></code> </pre><br><br>  We give a brief description for each tracer: <br><br><ul><li>  function - tracer functions of the kernel calls without the possibility of obtaining arguments; </li><li>  function_graph - kernel call function tracer with subcalls; </li><li>  blk - call and event tracer related to input-output to block devices;  that is what is used in the blktrace utility, which we <a href="https://blog.selectel.ru/analiz-proizvoditelnosti-blochnyx-ustrojstv-s-blktrace/">have already written about</a> ; </li><li>  mmiotrace is a tracer of I / O operations reflected in memory. </li><li>  nop is the simplest tracer, which, as the name implies, does nothing (however, in some situations it may be useful, which is discussed below). </li></ul><br><br><h2>  Tracer function </h2><br><br>  We will begin the introduction to ftrace with the function tracer.  We will consider it on the material of such a test script: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh dir=/sys/kernel/debug/tracing sysctl kernel.ftrace_enabled=1 echo function &gt; ${dir}/current_tracer echo 1 &gt; ${dir}/tracing_on sleep 1 echo 0 &gt; ${dir}/tracing_on less ${dir}/trace</span></span></code> </pre><br><br>  Crypts are very simple and generally understandable, but there are moments in it that are worth paying attention to. <br>  The sysctl ftrace.enabled = 1 command enables tracing of functions.  Next, we install the current tracer by writing its name to the current_tracer file. <br><br>  After that we write 1 to the file tracing_on and thereby activate the ring buffer update.  An important feature of the syntax: there must be a space between the 1 and the&gt; sign: a command like echo1&gt; tracing_on will not work.  Literally in one line, we disable it (note: if we write 0 to the tracing_on file, the ring buffer will not be cleared; the ftrace will not be disabled either). <br><br>  Why do we do this?  Between the two echo commands is the sleep 1 command. We enable the buffer update, execute this command, and then immediately disable it.  Due to this, the trace will include information on all system calls that occurred during the execution of this command. <br><br>  In the last line of the script, we give the command to output the trace data to the console. <br><br>  As a result of the execution of this script, we will see the following output (here is a small fragment): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># tracer: function # # entries-in-buffer/entries-written: 29571/29571 #P:2 # # _-----=&gt; irqs-off # / _----=&gt; need-resched # | / _---=&gt; hardirq/softirq # || / _--=&gt; preempt-depth # ||| / delay # TASK-PID CPU# |||| TIMESTAMP FUNCTION # | | | |||| | | trace.sh-1295 [000] .... 90.502874: mutex_unlock &lt;-rb_simple_write trace.sh-1295 [000] .... 90.502875: __fsnotify_parent &lt;-vfs_write trace.sh-1295 [000] .... 90.502876: fsnotify &lt;-vfs_write trace.sh-1295 [000] .... 90.502876: __srcu_read_lock &lt;-fsnotify trace.sh-1295 [000] .... 90.502876: __srcu_read_unlock &lt;-fsnotify trace.sh-1295 [000] .... 90.502877: __sb_end_write &lt;-vfs_write trace.sh-1295 [000] .... 90.502877: syscall_trace_leave &lt;-int_check_syscall_exit_work trace.sh-1295 [000] .... 90.502878: context_tracking_user_exit &lt;-syscall_trace_leave trace.sh-1295 [000] .... 90.502878: context_tracking_user_enter &lt;-syscall_trace_leave trace.sh-1295 [000] d... 90.502878: vtime_user_enter &lt;-context_tracking_user_enter trace.sh-1295 [000] d... 90.502878: _raw_spin_lock &lt;-vtime_user_enter trace.sh-1295 [000] d... 90.502878: __vtime_account_system &lt;-vtime_user_enter trace.sh-1295 [000] d... 90.502878: get_vtime_delta &lt;-__vtime_account_system trace.sh-1295 [000] d... 90.502879: account_system_time &lt;-__vtime_account_system trace.sh-1295 [000] d... 90.502879: cpuacct_account_field &lt;-account_system_time trace.sh-1295 [000] d... 90.502879: acct_account_cputime &lt;-account_system_time trace.sh-1295 [000] d... 90.502879: __acct_update_integrals &lt;-acct_account_cputime</span></span></code> </pre><br><br>  The output starts with information on the number of event entries in the buffer (entries in buffer) and the total number of recorded events (entries written).  The difference between these two numbers is the number of events lost while filling the buffer (in our case there are no lost events). <br><br>  The following is a list of functions, including the following information: <br><br><ul><li>  process identifier (PID); </li><li>  the number of the processor core that is being traced (CPU #); </li><li>  timestamp (TIMESTAMP; indicates the time when the entry to the function occurred); </li><li>  the name of the function being traced and the name of the parent function that called it (FUNCTION);  for example, in the very first line of our output, the function mutex-unlock calls the function rb_simple_write. </li></ul><br><br><h2>  Function_graph tracer </h2><br><br>  The function_graph tracer works just like function, but tracks functions in more detail: for each function, it specifies an entry point and an exit point.  With this tracer, you can track functions with subcalls and measure the execution time for each function. <br><br>  Edit the script used in the previous example: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh dir=/sys/kernel/debug/tracing sysctl kernel.ftrace_enabled=1 echo function_graph &gt; ${dir}/current_tracer echo 1 &gt; ${dir}/tracing_on sleep 1 echo 0 &gt; ${dir}/tracing_on less ${dir}/trace</span></span></code> </pre><br><br>  As a result of this script, we get the following output: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># tracer: function_graph # # CPU DURATION FUNCTION CALLS # | | | | | | | 0) 0.120 us | } /* resched_task */ 0) 1.877 us | } /* check_preempt_curr */ 0) 4.264 us | } /* ttwu_do_wakeup */ 0) + 29.053 us | } /* ttwu_do_activate.constprop.74 */ 0) 0.091 us | _raw_spin_unlock(); 0) 0.260 us | ttwu_stat(); 0) 0.133 us | _raw_spin_unlock_irqrestore(); 0) + 37.785 us | } /* try_to_wake_up */ 0) + 38.478 us | } /* default_wake_function */ 0) + 39.203 us | } /* pollwake */ 0) + 40.793 us | } /* __wake_up_common */ 0) 0.104 us | _raw_spin_unlock_irqrestore(); 0) + 42.920 us | } /* __wake_up_sync_key */ 0) + 44.160 us | } /* sock_def_readable */ 0) ! 192.850 us | } /* tcp_rcv_established */ 0) ! 197.445 us | } /* tcp_v4_do_rcv */ 0) 0.113 us | _raw_spin_unlock(); 0) ! 205.655 us | } /* tcp_v4_rcv */ 0) ! 208.154 us | } /* ip_local_deliver_finish */</span></span></code> </pre><br><br>  In the column DURATION indicates the time spent on the function.  Special attention should be paid to items marked with + and!  The + sign means that the function took more than 10 microseconds, and the exclamation mark - more than 100. <br><br>  In the column FUNCTION_CALLS with information on function calls. <br>  The beginning and end of the execution of each function are indicated in it as it is accepted in the C language: the curly bracket at the beginning of the function and another one at the end.  Functions that are leaves of a graph and do not call any other functions are indicated by a semicolon (;). <br><br><h2>  Function Filters </h2><br><br>  The output of ftrace can sometimes be very large, and it is extremely difficult to find the necessary information in it.  You can simplify the search with the help of filters: the output will not contain information about all the functions, but only about those that really interest us.  To do this, simply write the names of necessary functions to the set_ftrace_filter file, for example: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo kfree &gt; set_ftrace_filter</span></span></code> </pre><br><br>  To disable the filter, you need to write in the same file an empty line: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo &gt; set_ftrace_filter</span></span></code> </pre><br><br>  As a result of the command <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo kfree &gt; set_ftrace_notrace</span></span></code> </pre><br><br>  we will get a completely opposite result: the output will contain information about all functions except kfree (). <br><br>  Another useful option is set_ftrace_pid.  It is designed to trace functions called during the execution of the specified process. <br><br>  Filtering capabilities in ftrace are much wider;  Read more about them in the article by <a href="https://lwn.net/Articles/370423/" rel="nofollow">Stephen Rostedt on LWN.net</a> . <br><br><h2>  Event tracing </h2><br><br>  Above, we already mentioned the tracepoints mechanism.  The word tracepoint in translation means "trace point".  The trace point is a special insertion into the code that records certain system events.  A trace point can be active (this means that some check is assigned to it) or inactive (no check is assigned to it). <br><br>  An inactive trace point has no effect on the operation of the system;  it only adds a few bytes to call the trace function at the end of the instrumented function, and also adds the data structure to a separate section. <br><br>  When the trace point is active, when the corresponding code fragment is executed, the trace function is called.  Trace data is written to the debug ring buffer. <br><br>  Trace points can be inserted anywhere in the code.  They are already present in the code of many nuclear functions.  Consider, for example, the function kmem_cache_alloc (taken <a href="">from here</a> ): <br><br><pre> <code class="hljs php">{ void *ret = slab_alloc(cachep, flags, _RET_IP_); trace_kmem_cache_alloc(_RET_IP_, ret, cachep-&gt;object_size, cachep-&gt;size, flags); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><br>  Pay attention to the <b>trace_kmem_cache_alloc</b> line - this is exactly the trace point.  The number of such examples can be multiplied by referring to the source code of other functions of the kernel. <br><br>  The Linux kernel has a special API that allows you to work with trace points from user space.  In the / sys / kernel / debug / tracing directory there is a subdirectory of events in which system events available for tracking are stored.  The system event in this context is nothing more than the trace points included in the core. <br><br>  Their list can be viewed using the command: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># cat available_events</span></span></code> </pre><br><br>  A long list will be displayed on the console, which is rather inconvenient to view.  You can output the same list in a more structured format like this: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># ls events</span></span></code> </pre><br><br>  Before you start tracking events, check to see if event recording is included in the ring buffer: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># cat tracing_on</span></span></code> </pre><br><br>  If after executing this command the number 0 is displayed on the console, we will execute: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo 1 &gt; tracing_on</span></span></code> </pre><br><br>  In the last article we wrote about the chroot () system call - we will track the entrance to this system call.  As a tracer, we will select nop: function and function_graph record too much information, including information that is irrelevant to the event of interest to us. <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo nop &gt; current_tracer</span></span></code> </pre><br><br>  All events related to system calls are stored in the syscalls directory.  It, in turn, stores directories for entering and exiting various system calls.  Activate the trace point we need by writing 1 to its enable file: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo 1 &gt; events/syscalls/sys_enter_chroot/enable</span></span></code> </pre><br><br>  Then create an isolated file system using the chroot command (see details <a href="https://blog.selectel.ru/mexanizmy-kontejnerizacii-namespaces/">in the previous post</a> ).  After executing the commands of interest to us, turn off tracing so that the output does not contain information about unnecessary and unrelated events: <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># echo 0 &gt; tracing_on</span></span></code> </pre><br><br>  Next, view the contents of the ring buffer.  At the very end of the output will contain information about the system call that we are interested in (here is a small fragment): <br><br><pre> <code class="bash hljs">root@andrei:/sys/kernel/debug/tracing<span class="hljs-comment"><span class="hljs-comment"># at trace ...... chroot-11321 [000] .... 4606.265208: sys_chroot(filename: 7fff785ae8c2) chroot-11325 [000] .... 4691.677767: sys_chroot(filename: 7fff242308cc) bash-11338 [000] .... 4746.971300: sys_chroot(filename: 7fff1efca8cc) bash-11351 [000] .... 5379.020609: sys_chroot(filename: 7fffbf9918cc)</span></span></code> </pre><br><br>  More details about the event trace settings can be found <a href="https://www.kernel.org/doc/Documentation/trace/events.txt" rel="nofollow">here</a> . <br><br><h2>  Conclusion </h2><br><br>  In this article we have done a general overview of the possibilities of ftrace.  We would appreciate any comments and additions.  If you want to dive deeper into the topic, we recommend that you familiarize yourself with the following sources: <br><br><ul><li>  <a href="https://www.kernel.org/doc/Documentation/trace/tracepoints.txt" rel="nofollow">https://www.kernel.org/doc/Documentation/trace/tracepoints.txt</a> - detailed description of the tracepoints mechanism; </li><li>  <a href="https://www.kernel.org/doc/Documentation/trace/events.txt" rel="nofollow">https://www.kernel.org/doc/Documentation/trace/events.txt</a> - a guide to tracing system events in Linux; </li><li>  <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" rel="nofollow">https://www.kernel.org/doc/Documentation/trace/ftrace.txt</a> - official ftrace documentation; </li><li>  <a href="https://lttng.org/files/thesis/desnoyers-dissertation-2009-12-v27.pdf">https</a> ://lttng. </li><li>  <a href="https://lwn.net/Articles/370423/" rel="nofollow">https://lwn.net/Articles/370423/</a> - Stephen Rodstedt article on ftrace features; </li><li>  <a href="http://alex.dzyoba.com/linux/profiling-ftrace.html" rel="nofollow">http://alex.dzyoba.com/linux/profiling-ftrace.html</a> - ftrace review article with practical case study; </li><li>  <a href="http://panda-nox.livejournal.com/2235.html" rel="nofollow">http://panda-nox.livejournal.com/2235.html</a> is the only detailed publication about ftrace in Russian. </li></ul><br>  If you for one reason or another can not leave comments here - we invite you to our <a href="https://blog.selectel.ru/trassirovka-yadra-s-ftrace/">blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/280322/">https://habr.com/ru/post/280322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280308/index.html">Hackathon Angelhack 2016: a week later in the first of 4 cities</a></li>
<li><a href="../280310/index.html">Simple Yii2 application to send mail</a></li>
<li><a href="../280312/index.html">On the value of cards in the game "Drunkard"</a></li>
<li><a href="../280316/index.html">Flow ... or not serious post about serious things</a></li>
<li><a href="../280318/index.html">Creating your own editing mode in the Unreal Engine</a></li>
<li><a href="../280326/index.html">ALM Robot, or moving to a new version of ALM is just</a></li>
<li><a href="../280328/index.html">Sort the queue without using additional resources</a></li>
<li><a href="../280330/index.html">Belgian security forces used WhatsApp because of the attacks</a></li>
<li><a href="../280332/index.html">Device Guard in Windows 10. Code Integrity Policy</a></li>
<li><a href="../280334/index.html">As one programmer Jocly shoe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>