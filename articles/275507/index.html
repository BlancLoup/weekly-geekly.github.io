<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for a variety of regular expressions using the Hyperscan library</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to tell you about my own experience in optimizing the execution of many regular expressions using the hyperscan system. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for a variety of regular expressions using the Hyperscan library</h1><div class="post__text post__text-html js-mediator-article">  In this article, I would like to tell you about my own experience in optimizing the execution of many regular expressions using the <a href="https://github.com/01org/hyperscan">hyperscan</a> system.  It <a href="https://rspamd.com/">turned</a> out that when developing my <a href="https://rspamd.com/">rspamd</a> spam filter <a href="https://rspamd.com/">,</a> I was faced with the need to port a large amount of old rules written for spamassassin over several years of work.  My first decision was to write a <a href="https://rspamd.com/doc/modules/spamassassin.html">plugin</a> that would read these rules and build a syntax tree of them.  Then various optimizations were performed on this tree in order to reduce the overall execution time (I even made a small <a href="https://highsecure.ru/ast-rspamd.pdf">presentation</a> about this). <br><br>  Unfortunately, during the operation, it turned out that pcre is still a bottleneck, and on large letters this set of rules is too slow.  It turned out, for example, that in a megabyte-sized letter, pcre checks around a gigabyte (!) Of text.  Various tricks, such as limiting the amount of text for regular expressions, had a negative effect on the triggering of the rules, and optimizing pcre by using jit fast path through <strong>pcre_jit_exec was</strong> too dangerous - some old expressions were frankly incorrect and combined with incorrect input text, for example, ‚ÄúBroken‚Äù UTF8 characters led to reproducible bugs with program stack corruption.  However, at the <a href="http://highload.ru/">highload</a> conference we talked with Vyacheslav Olkhovchenkov, and he advised me to look at the hyperscan.  Next, I'll get to the point and tell you what came out of it. <br><a name="habracut"></a><br><br><h2>  Hyperscan in brief </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Hyperscan is a project with a rather long history, and it was created to sell deep packets introspection (DPI) solutions.  But last October, Intel decided to open its source code, and even under the BSD license.  The project is written in C ++ with a rather intensive use of boost, which causes certain problems when porting (but more on that later).  Inside, hyperscan is a non-backtracking regular expression engine based on a non-deterministic finite state machine (NFA).  In principle, all modern performance-oriented regular expression engines are written using the same theory and discarding backtracking completely (which, of course, is quite rational if you want to ensure a linear search speed).  The most important hyperscan feature for me was the ability to <strong>simultaneously</strong> perform many regular expressions on some text.  A naive approach to do the same in pcre is to try to combine several expressions with the operator <i>|</i>  in such a "sausage": <pre>  (?: re1) | (?: re2) | ... | (?: reN) </pre>  .  Unfortunately, this approach does not work - after all, the task is to find <strong>all</strong> occurrences from a given set of expressions, and not just those that worked before.  Hyperscan does not work the same way - for each expression found, it calls a callback function with a position in the text (but only the last character of the entry), which can be demonstrated in the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/537/c6c/688/537c6c68898cb1b6ac781eee6e4d78a7.png"><br><br><h2>  Hyperscan architecture </h2><br><br>  Hyperscan consists of two parts: the compiler and, in fact, the engine.  A compiler is a very large part of a library that can take a stack of expressions, compose NFA for it and convert this NFA into assembly code using, for example, vector instructions, in particular AVX2.  This task is difficult and resource intensive, so the compiler also allows you to serialize the resulting code for later use.  The search engine is a smaller library, and it is actually designed to run NFA on a specific text.  For applications that use only precompiled expression sets, you can use the separate library <i>libhs_runtime</i> , which is much smaller than the combined library compiler + engine <i>libhs</i> .  For a start, I tried to build hyperscan, which turned out to be quite an easy task if there was a fresh boost for the system (minimum version 1.57).  The only remark, perhaps, is that when building with debugging symbols, the library turns out to be just gigantic - about 200Mb on my macbook.  And since only the static library is built by default, when connected, its size of binaries is also obtained in the region of 200Mb.  If debugging symbols are not needed, it is better to assemble hyperscan without them, specifying <pre>  -DCMAKE_BUILD_TYPE = MinSizeRel </pre>  at a configuration stage through cmake. <br><br><h2>  Test code </h2><br>  Then I tried to compare hyperscan and pcre, writing a very rough prototype, which you can look under the spoiler (I warn you, this is the code of the prototype, which is written in a hurry without any special claims to quality). <br><br><div class="spoiler">  <b class="spoiler_title">Comparison code pcre and hyperscan</b> <div class="spoiler_text"><pre><code class="hljs lua">#include &lt;iostream&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;stdexcept&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include <span class="hljs-string"><span class="hljs-string">"pcre.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"hs.h"</span></span> #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.h&gt; #ifdef __APPLE__ #include &lt;mach/mach_time.h&gt; #endif using namespace std; double get_ticks(void) { double res; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(__APPLE__) res = mach_absolute_time() / <span class="hljs-number"><span class="hljs-number">1000000000.</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &amp;ts); res = (double)ts.tv_sec + ts.tv_nsec / <span class="hljs-number"><span class="hljs-number">1000000000.</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } struct pcre_regexp { pcre* re; pcre_extra* extra; pcre_regexp(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; pattern) { const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* err; int err_off; re = pcre_compile(pattern.c_str(), PCRE_NEWLINE_ANYCRLF, &amp;err, &amp;err_off, NULL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (re == NULL) { throw invalid_argument(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"cannot compile: '"</span></span>) + pattern + <span class="hljs-string"><span class="hljs-string">"' error: "</span></span> + err + <span class="hljs-string"><span class="hljs-string">" at offset: "</span></span> + to_string(err_off)); } extra = pcre_study(re, PCRE_STUDY_JIT_COMPILE, &amp;err); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extra == NULL) { throw invalid_argument(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"cannot study: '"</span></span>) + pattern + <span class="hljs-string"><span class="hljs-string">"' error: "</span></span> + err + <span class="hljs-string"><span class="hljs-string">" at offset: "</span></span> + to_string(err_off)); } } }; struct cb_context { set&lt;int&gt; approx_re; vector&lt;pcre_regexp&gt; pcre_vec; }; struct cb_data { struct cb_context* ctx; vector&lt;int&gt; matched; const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>* str; }; bool remove_uncompileable(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s, int id, struct cb_context* ctx) { hs_compile_error_t* hs_errors; hs_database_t* hs_db; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hs_compile(s.c_str(), HS_FLAG_ALLOWEMPTY, HS_MODE_BLOCK, NULL, &amp;hs_db, &amp;hs_errors) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pattern: '"</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">"', error: "</span></span> &lt;&lt; hs_errors-&gt;message &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hs_compile(s.c_str(), HS_FLAG_ALLOWEMPTY | HS_FLAG_PREFILTER, HS_MODE_BLOCK, NULL, &amp;hs_db, &amp;hs_errors) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"completely bad pattern: '"</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">"', error: "</span></span> &lt;&lt; hs_errors-&gt;message &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ctx-&gt;approx_re.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(id); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hs_free_database(hs_db); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } int match_cb(unsigned int id, unsigned long long from, unsigned long long to, unsigned int flags, void* context) { auto cbdata = (struct cb_data*)context; auto&amp; matched = cbdata-&gt;matched; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cbdata-&gt;ctx-&gt;approx_re.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(id) != cbdata-&gt;ctx-&gt;approx_re.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()) { int ovec[<span class="hljs-number"><span class="hljs-number">3</span></span>]; auto re = cbdata-&gt;ctx-&gt;pcre_vec[id]; auto* begin = cbdata-&gt;str-&gt;data(); auto* p = begin; auto sz = cbdata-&gt;str-&gt;size(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pcre_exec(re.re, re.extra, p, sz - (p - begin), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ovec, <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { p = p + ovec[<span class="hljs-number"><span class="hljs-number">1</span></span>]; matched[id]++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { matched[id]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>** argv) { ifstream refile(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); vector&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; re_vec; double t1, t2, total_ticks = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct cb_context ctx; int ls; pcre_config(PCRE_CONFIG_LINK_SIZE, &amp;ls); cout &lt;&lt; ls &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; std::getline(refile, line);) { re_vec.push_back(line); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> re_pipe; const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>** pats = new const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*[re_vec.size()]; unsigned int i = <span class="hljs-number"><span class="hljs-number">0</span></span>, *ids = new unsigned int[re_vec.size()]; //re_vec.erase(remove_if(re_vec.begin(), re_vec.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), remove_uncompileable), re_vec.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; re_vec.size(); i++) { const auto&amp; r = re_vec[i]; remove_uncompileable(r, i, &amp;ctx); pats[i] = r.c_str(); ids[i] = i; re_pipe = re_pipe + <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"("</span></span>) + r + <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">")|"</span></span>); } // Last | re_pipe.erase(re_pipe.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); total_ticks = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const auto&amp; r : re_vec) { t1 = get_ticks(); ctx.pcre_vec.emplace_back(r); t2 = get_ticks(); total_ticks += t2 - t1; } cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PCRE compile time: "</span></span> &lt;&lt; total_ticks &lt;&lt; endl; ifstream <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>(argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> in_str((std::istreambuf_iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>)), std::istreambuf_iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;()); hs_compile_error_t* hs_errors; hs_database_t* hs_db; hs_platform_info_t plt; hs_populate_platform(&amp;plt); unsigned int* flags = new unsigned int[re_vec.size()]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; re_vec.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.approx_re.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(i) != ctx.approx_re.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()) { flags[i] = HS_FLAG_PREFILTER; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { flags[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } t1 = get_ticks(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hs_compile_multi(pats, flags, ids, re_vec.size(), HS_MODE_BLOCK, &amp;plt, &amp;hs_db, &amp;hs_errors) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"BAD pattern: '"</span></span> &lt;&lt; re_vec[hs_errors-&gt;expression] &lt;&lt; <span class="hljs-string"><span class="hljs-string">"', error: "</span></span> &lt;&lt; hs_errors-&gt;message &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-101</span></span>; } t2 = get_ticks(); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hyperscan compile time: "</span></span> &lt;&lt; (t2 - t1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; approx re: "</span></span> &lt;&lt; ctx.approx_re.size() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; total re: "</span></span> &lt;&lt; re_vec.size() &lt;&lt; endl; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* bytes = NULL; size_t bytes_len; t1 = get_ticks(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hs_serialize_database(hs_db, &amp;bytes, &amp;bytes_len) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"BAD"</span></span> &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-101</span></span>; } t2 = get_ticks(); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hyperscan serialize time: "</span></span> &lt;&lt; (t2 - t1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; size: "</span></span> &lt;&lt; bytes_len &lt;&lt; <span class="hljs-string"><span class="hljs-string">" bytes"</span></span> &lt;&lt; endl; hs_database_t* hs_db1 = NULL; t1 = get_ticks(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hs_deserialize_database(bytes, bytes_len, &amp;hs_db1) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"BAD1"</span></span> &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-101</span></span>; } t2 = get_ticks(); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hyperscan deserialize time: "</span></span> &lt;&lt; (t2 - t1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; size: "</span></span> &lt;&lt; bytes_len &lt;&lt; <span class="hljs-string"><span class="hljs-string">" bytes"</span></span> &lt;&lt; endl; auto matches = <span class="hljs-number"><span class="hljs-number">0</span></span>; total_ticks = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const auto&amp; re : ctx.pcre_vec) { int ovec[<span class="hljs-number"><span class="hljs-number">3</span></span>]; auto* begin = in_str.data(); auto* p = begin; auto sz = in_str.size(); t1 = get_ticks(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pcre_exec(re.re, re.extra, p, sz - (p - begin), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ovec, <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { p = p + ovec[<span class="hljs-number"><span class="hljs-number">1</span></span>]; matches++; } t2 = get_ticks(); total_ticks += t2 - t1; } //cout &lt;&lt; re_pipe &lt;&lt; endl; cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Time for individual re: "</span></span> &lt;&lt; total_ticks &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; matches: "</span></span> &lt;&lt; matches &lt;&lt; endl; //cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Time for piped re: "</span></span> &lt;&lt; (t2 - t1) &lt;&lt; endl; hs_scratch_t* scratch = NULL; int rc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((rc = hs_alloc_scratch(hs_db1, &amp;scratch)) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"bad scratch: "</span></span> &lt;&lt; rc &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-102</span></span>; } struct cb_data cbdata; cbdata.ctx = &amp;ctx; cbdata.matched = vector&lt;int&gt;(re_vec.size(), <span class="hljs-number"><span class="hljs-number">0</span></span>); cbdata.str = &amp;in_str; t1 = get_ticks(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((rc = hs_scan(hs_db1, in_str.data(), in_str.size(), <span class="hljs-number"><span class="hljs-number">0</span></span>, scratch, match_cb, &amp;cbdata)) != HS_SUCCESS) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"bad scan: "</span></span> &lt;&lt; rc &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-103</span></span>; } t2 = get_ticks(); matches = <span class="hljs-number"><span class="hljs-number">0</span></span>; for_each(cbdata.matched.begin(), cbdata.matched.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [&amp;matches](int elt) { matches += elt; }); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Time for hyperscan re: "</span></span> &lt;&lt; (t2 - t1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; matches: "</span></span> &lt;&lt; matches &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><br>  The result was quite impressive: on a megabyte spam letter and a set of ~ 1000 regular expressions, I got the following results: <br><br><pre> PCRE compile time: 0.0138553
 Hyperscan compile time: 4.94309;  approx re: 191;  total re: 971
 Hyperscan serialize time: 0.00312218;  size: 5242956 bytes
 Hyperscan deserialize time: 0.00359501;  size: 5242956 bytes
 Time for individual re: 0.440707;  matches: 7
 Time for hyperscan re: 0.0770988;  matches: 7
</pre><br><br><h2>  Prefilter </h2><br><br>  One of the most impressive features of hyperscan is the ability to work as a pre-filter.  This mode is useful when there are unsupported constructions in the expression, for example, the same backtracking.  In this mode, the hyperscan creates an expression that is a <strong>guaranteed</strong> superset of the given unsupported expression.  That is, the new expression is guaranteed to be guaranteed in all cases of the initial one, but it can also work in other cases, giving false positive operations.  Therefore, the result should be checked on the traditional regular expression engine, for example, pcre (although in this case it is not necessary to chase the entire text, but it is necessary to check it from the beginning to the point of occurrence of the expression).  This is graphically shown in the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/043/d63/0c5043d63f824fb6b6b4e2ca2ff99069.png"><br><br><h2>  Compilation issues </h2><br><br>  Unfortunately, it turned out, and two unpleasant moments.  The first of these is compile time ‚Äî it just takes an unrealistic long time compared to pcre.  The second point is related to the fact that some expressions simply compile during pre-filter compilation.  The simplest ‚Äúlofty‚Äù expression was, for example, the following: <br><br><pre> &lt;a \ s [^&gt;] {0.2048} \ bhref = (?: 3D)?.? (https?: [^&gt; "'\ #] {8.29} [^&gt;"' \ #: \ /? &amp; =]) [^&gt;] {0.2048}&gt; (?: [^ &lt;] {0.1024} &lt;(?! \ / A) [^&gt;] {1.1024}&gt;) {0, 99} \ s {0.10} (?! \ 1) https? [^ \ W &lt;] {1,3} [^ &lt;] {5}
</pre><br><br>  As a result, I made sure that before compiling the expressions, all the pre-filter expressions are first checked in a separate process fork.  And if the expression is compiled too long, then this process is nailed, and the expression is marked as hopeless, that is, pcre is always used for it.  There were about ten such expressions from 4 thousand.  All of them came from my beloved spamassassin and are quite characteristic products of the disease called ‚Äúperl brain‚Äù.  After some communication with Intel engineers, they fixed the infinite compilation, but the above regexp still compiles about a minute, which is unacceptable for practical purposes. <br><br>  For hyperscan to work, it also turned out to be necessary to break sets of expressions into so-called ‚Äúclasses‚Äù - this is the type of input text that is checked through regular expressions from the set, for example, the letter header with a specific name or the full body of the letter, or only text parts.  Such classes are shown in the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/352/6cc/bfc/3526ccbfcbba2befc0f7934e054bcbad.png"><br><br>  To compile, I used the following approach: <br><ul><li>  In a separate process, start checking the expression classes, and for each class, look for whether there is already a compiled and valid file for it. </li><li>  If there is no such file or it contains an incorrect set of expressions (checked by the hash from the expression pattern), then compile it by checking the compile time of the preliminary filters. </li><li>  When all expressions are compiled in the cache, then send a message to all processes for the scanners to get the scanners to load the cached expressions and switch from pcre to hyperscan. </li></ul><br><br>  This approach made it possible to start checking email immediately after starting (using pcre), rather than wait for hyperscan‚Äôs expensive and long compilation, and upon completion of the compilation, immediately switch from pcre to hyperscan (which is called, without departing from the cash register).  And the use of sets of bits for checked and triggered regular expressions also makes it possible not to disturb when switching the work of letters already running in the check. <br><br><h2>  findings </h2><br><br>  In the course of rspamd + hyperscan, I got something like this: <br><br>  It was: <br><pre> len: 610591, time: 2492.457ms real, 882.251ms virtual
 regexp statistics: 4095 pcre regexps scanned, 18 regexps matched, 694M bytes scanned using pcre
</pre><br><br>  It became: <br><pre> len: 610591, time: 654.596ms real, 309.785ms virtual
 regexp statistics: 34 pcre regexps scanned, 41 regexps matched, 8.41M bytes scanned using pcre, 
 9.56M bytes scanned total
</pre><br><br>  More regexps matched in the hyperscan version are caused by syntax tree optimizations that are done for pcre, but are useless in the hyperscan case (because all expressions are checked at the same time). <br><br>  The Hyperscan version is already in production, and is included in the <a href="https://rspamd.com/announce/2016/01/18/rspamd-1.1.0.html">new version of rspamd</a> .  I can confidently recommend hyperscan for performance-critical projects for checking regular expressions (DPI, proxy, etc.), as well as for applications to search for static strings in the text. <br><br>  For the last task, I did a hyperscan comparison with the <a href="https://en.wikipedia.org/wiki/Aho%25E2%2580%2593Corasick_algorithm">aho-corasick</a> algorithm traditionally used for such purposes.  I compared the fastest Mischa Sandberg <a href="https://github.com/mischasan/aho-corasick">implementation to</a> me. <br><br>  Comparison results for 10 thousand static lines on a megabyte letter with a large number of such lines (that is, the worst possible conditions for aho-corasic, having complexity O (M + N), where M is the number of found lines): <br><br><pre> actrie compile time: 0.0743811
 Hyperscan compile time: 0.1547;  approx re: 0;  total re: 7400
 Hyperscan serialize time: 0.000178297;  size: 1250856 bytes
 Hyperscan deserialize time: 0.000312379;  size: 1250856 bytes
 Time for hyperscan re: 0.117938;  matches: 3001024
 Time for actrie: 0.100427;  matches: 3000144
</pre><br><br>  Unfortunately, it also turned out that the number of hits did not converge due to an error in the ac-trie code, while the hyperscan was never mistaken. <br><br>  Also the materials of this article are available in the <a href="https://highsecure.ru/rspamd-hyperscan.pdf">presentation</a> .  The code can be viewed in the rspamd project <a href="">on the githab</a> </div><p>Source: <a href="https://habr.com/ru/post/275507/">https://habr.com/ru/post/275507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275497/index.html">Objects in PHP 7</a></li>
<li><a href="../275499/index.html">Five-year postponement for Ukrainian enterprises: the action ends on 12/31/2016</a></li>
<li><a href="../275501/index.html">New lectures, courses, discounts and other updates</a></li>
<li><a href="../275503/index.html">Why is it difficult to program the UI and how does the perfect framework look like?</a></li>
<li><a href="../275505/index.html">Have you thought about the safety of ... a car?</a></li>
<li><a href="../275509/index.html">Used servers as a reasonable alternative</a></li>
<li><a href="../275511/index.html">Using Kanban to Prepare Scrum Backlog</a></li>
<li><a href="../275513/index.html">Docker: Environment for testing</a></li>
<li><a href="../275515/index.html">Gradle: managing dependencies</a></li>
<li><a href="../275517/index.html">AnyConnect and Address Space Intersection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>