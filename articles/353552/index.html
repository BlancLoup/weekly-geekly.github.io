<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive programming in Objective-C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Over time, programming languages ‚Äã‚Äãare constantly changing and evolving due to the emergence of new technologies, modern requirements or a simple desi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive programming in Objective-C</h1><div class="post__text post__text-html js-mediator-article">  Over time, programming languages ‚Äã‚Äãare constantly changing and evolving due to the emergence of new technologies, modern requirements or a simple desire to refresh the style of writing code.  Reactive programming can be implemented using various frameworks such as Reactive Cocoa.  It changes the framework of the imperative Objective-C language and this approach to programming has something to offer the standard paradigm.  This, of course, attracts the attention of iOS developers. <br><br>  ReactiveCocoa brings a declarative style to Objective-C.  What do we mean by this?  The traditional imperative style used by such languages ‚Äã‚Äãas C, C ++, Objective-C, and Java, etc., can be described as follows: You write directives for a computer program that must be executed in a certain way.  In other words, you say "how to do" something.  While declarative programming allows you to describe a control flow as a sequence of actions, ‚Äúwhat to do,‚Äù without defining ‚Äúhow to do‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/ffe/ac9/7a0ffeac9cce2e40032517f28bfb1cb5.jpg" alt="ReactiveCocoa"></div><a name="habracut"></a><br><h3>  Imperative vs Functional Programming </h3><br>  An imperative programming approach involves a detailed description of each step that a computer must take to complete tasks.  In fact, the imperative style is used in native programming languages ‚Äã‚Äã(or used when writing machine code).  This, by the way, is a feature of most programming languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the contrary, the functional approach solves problems using a set of functions that must be performed.  You define the input parameters for each function, and what each function returns.  These two programming approaches are very different. <br><br>  Here are the main differences of languages: <br><br><h4>  1. State changes </h4><br>  For pure functional programming, a state change does not exist, since there are no side effects.  A side effect implies state changes in addition to the return value due to some external interaction.  SP (reference transparency) subexpressions are often defined as ‚Äúno side effects‚Äù and primarily relate to pure functions.  The SP does not allow the execution of the function to have external access to the non-constant state of the function, because each subexpression is a function call by definition. <br><br>  To clarify the essence of the matter, the pure functions have the following attributes: <br><br><ul><li>  the only noticeable output is the return value </li><li>  the only dependence of the input parameters - the arguments </li><li>  arguments are fully qualified before generating any output. </li></ul><br>  Despite the fact that the functional approach minimizes side effects, they cannot be completely avoided, since they are an internal part of any development. <br><br>  On the other hand, functions in imperative programming do not have reference transparency, and this may be the only difference between the declarative approach and the imperative one.  Side effects are widely used for state and I / O.  Commands in the source language can change state, which results in different values ‚Äã‚Äãfor a single language expression. <br><br>  What about ReactiveCocoa?  This is a functional framework for Objective-C, which is a conceptually imperative language, not including explicitly pure functions.  When trying to avoid a change in state, side effects are not limited. <br><br><h3>  2. First Class Objects </h3><br>  In functional programming, there are objects and functions that are first class objects.  What does it mean?  This means that functions can be passed as a parameter, assigned to a variable, or returned from a function.  Why is this convenient?  This allows you to easily manage execution blocks, create and combine functions in various ways without difficulty, such as function pointers (char * (* (** foo [] [8]) ()) []; - have fun!). <br><br>  Languages ‚Äã‚Äãthat use the imperative approach have their own peculiarities regarding first class expressions.  What about Objective-C?  It has blocks as closure implementations.  Higher order functions (PID) can be modeled by taking blocks as parameters.  In this case, the block is a closure, and a higher order function can be created from a specific set of blocks. <br><br>  However, the process of manipulating FPP in functional languages ‚Äã‚Äãis faster and requires fewer lines of code. <br><br><h3>  3. Mainstream Management </h3><br>  Cycles in the imperative style are represented as calls to the recursion function in functional programming.  Iteration in functional languages ‚Äã‚Äãis usually performed through recursion.  Why?  Probably for the sake of complexity.  For Objective-C developers, loops seem to be much more favorable for the programmer.  Recursion can cause difficulties, for example, excessive consumption of RAM. <br><br>  But!  We can write a function without using cycles or recursions.  For each of the infinitely possible specialized actions that can be applied to each element of the collection, functional programming uses reusable iterative functions, such as ‚Äú <i>map</i> ‚Äù, ‚Äú <i>fold</i> ‚Äù, ‚Äú <i>filter</i> ‚Äù.  These functions are useful for reorganizing source code.  They reduce duplication and do not require writing a separate function.  (read on, we have more information about this!) <br><br><h3>  4. Order of execution </h3><br>  Declarative expressions only show the logical connections of the arguments of the subexpression function and the constant state relations.  So in the absence of side effects, the transition state of each function call occurs independently of the others. <br><br>  The functional order of execution of imperative expressions depends on a non-constant state.  Therefore, the order of execution matters and is implicitly determined by the organization of the source code.  In this question, we can point out the difference between the evaluation strategies of both approaches. <br><br>  Deferred computations or computations, of necessity, in functional programming languages ‚Äã‚Äãare strategies.  In this case, the evaluation of the expression is postponed until its value is necessary; there we avoid duplicate evaluations ourselves.  In other words, expressions are evaluated only when evaluating a dependent expression.  The order of operations becomes uncertain. <br><br>  In contrast, vigorous computation in an imperative language means that an expression will be evaluated as soon as it is bound to a variable.  This implies dictation of the order of execution. Thus, it is easier to determine when subexpressions (including functions) will be calculated, because subexpressions can have side effects that affect the miscalculation of other expressions. <br><br><h3>  5. Amount of code </h3><br>  This is important, the functional approach requires writing less code than imperative.  This means fewer failures, less code for testing, and a more productive development cycle.  Since the system is constantly evolving and growing, it is important. <br><br><h3>  Main components of ReactiveCocoa </h3><br>  Functional programming works with concepts known as the future (read-only variable presentation) and promise (the read-only future representation of the variable).  What is good about them?  In imperative programming, you must work with already existing values, which leads to the need to synchronize asynchronous code and other difficulties.  But the concepts of futures and promises allow working with values ‚Äã‚Äãthat have not yet been created (the asynchronous code is written in a synchronous way). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/390/796/bda/390796bda3a80fd3720128597bd966ca.jpg" alt="Signalal"></div><br><h3>  Signal </h3><br>  Future and promise are presented as signals in reactive programming.  <b>RACSignal</b> is the core component of ReactiveCocoa.  It gives the opportunity to present a stream of events that will be presented in the future.  You subscribe to a signal and get access to events that will occur with time.  A signal is a push-driven stream and can be a button click, asynchronous network operations, timers, other UI events, or anything else that changes over time.  They can link the results of asynchronous operations and effectively combine multiple event sources. <br><br><h3>  Sequence </h3><br>  Another type of stream is sequence.  Unlike a signal, a sequence is a pull-driven flow.  This is a kind of collection that has a similar purpose as NSArray.  RACSequence allows certain operations to be performed when you need them, rather than sequentially, as with the <i>NSArray</i> collection.  Values ‚Äã‚Äãin a sequence are evaluated only when this is specified by default.  Using only part of the sequence potentially improves performance.  <i>RACSequence</i> allows Cocoa collections to be processed in a universal and declarative way.  RAC adds the -rac_sequence method to most of the classes in the Cocoa collection so that they can be used as <i>RACSequences</i> . <br><br><h3>  Team </h3><br>  In response to certain actions, a <i>RACCcommand</i> is created and subscribes to the signal.  This applies primarily to UI interactions.  The <i>UIKit</i> categories provided by ReactiveCocoa for most <i>UIKit</i> controls give us the correct way to handle UI events.  Let's imagine that we have to register a user in response to a button click.  In this case, the command can represent a network request.  When the process starts, the button changes its state to ‚Äúinactive‚Äù and vice versa.  What else?  We can transmit an active signal in a team (reachability is a good example).  Therefore, if the server is unavailable (which is our ‚Äúenabled signal‚Äù), then the command will be unavailable, and each command of the associated control will reflect this state. <br><br><h4>  Examples of basic operations </h4><br>  Here are some diagrams of how basic operations work with RACSignals: <br><h4>  Merge / Merge </h4><br><pre><code class="objectivec hljs">+ (RACSignal *)merge:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFastEnumeration</span></span>&gt;)signals;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/389/c4f/30c389c4f7644620bed78106bb7a528f.png" alt="Merge"></div><br>  The result streams have both event streams combined together.  Thus, "+ merge" is useful when you do not care about a particular source of events, but would like to process them in one place.  In our example, stateLabel.text uses 3 different signals: execution, completion, errors. <br><br><pre> <code class="objectivec hljs">RACCommand *loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> input) { <span class="hljs-comment"><span class="hljs-comment">// let's login! }]; RACSignal *executionSignal = [loginCommand.executionSignals map:^id(id value) { return @"Connecting.."; }]; RACSignal *completionSignal = [loginCommand.executionSignals flattenMap:^RACStream *(RACSignal *next) { return [[[next materialize] filter:^BOOL(RACEvent *event) { return event.eventType == RACEventTypeCompleted; }] map:^id(id value) { return @"Done"; }]; }]; RACSignal *errorSignal = [loginCommand.errors map:^id(id value) { return @"Sorry :("; }]; RAC(self.stateLabel, text) = [RACSignal merge:@[executionSignal, completionSignal, errorSignal]];</span></span></code> </pre><br><h3>  CombineLatest </h3><br><pre> <code class="objectivec hljs">+ (RACSignal *)combineLatest:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFastEnumeration</span></span>&gt;)signals reduce:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (^)())reduceBlock;</code> </pre><br>  As a result, the stream contains the last values ‚Äã‚Äãof the streams being transmitted.  If one of the threads does not matter, the result will be empty. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b1/227/b28/7b1227b2814d7a8e6bb89b1da6d9e5b8.png" alt="CombineLatest"></div><br>  When can we use it?  Let's take our previous example and add more logic to it.  It is useful to enable the login button only in the case when the user has entered the correct email and password, right?  We can declare this rule as follows: <br><br><pre> <code class="objectivec hljs">ACSignal *enabledSignal = [RACSignal combineLatest:@[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.emailField.rac_textSignal, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.passwordField.rac_textSignal] reduce:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *email, <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @([email isValidEmail] &amp;&amp; password.length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>); }];</code> </pre><br>  * Now let's change our login command a bit and connect it to the actual loginButton <br><br><pre> <code class="objectivec hljs">RACCommand *loginCommand = [[RACCommand alloc] initWithEnabled:enabledSignal signalBlock:^RACSignal *(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> input) { <span class="hljs-comment"><span class="hljs-comment">// let's login! }]; [self.loginButton setRac_command:loginCommand];</span></span></code> </pre><br><h3>  Flattenmap </h3><br><pre> <code class="objectivec hljs">- (RACSignal *)flattenMap:(RACStream * (^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> value))block;</code> </pre><br>  You create new streams for each value in the original stream using this function (f).  The result stream returns new signals based on the values ‚Äã‚Äãgenerated in the original streams.  Therefore, it can be asynchronous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/dc1/13a/5f5dc113a2cddf010bacf49b97e8d1f8.png" alt="Flattenmap"></div><br>  Let's imagine that your authorization request to the system consists of two separate parts: get data from Facebook (ID, etc.) and transfer it to Backend.  One of the requirements must be able to cancel the login.  Therefore, client code must process the state of the login process in order to be able to cancel it.  This gives a lot of generic code, especially if you can log in from multiple places. <br><br>  How does ReactiveCocoa help you?  This could be a login implementation: <br><br><pre> <code class="objectivec hljs">- (RACSignal *)authorizeUsingFacebook { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[[FBSession rac_openedSession] flattenMap:^RACStream *(FBSession *session) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [session rac_fetchProfile]; }] flattenMap:^RACStream *(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *profile) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> authorizeUsingFacebookProfile:profile]; }]; }</code> </pre><br><h3>  Legend: </h3><br>  <i>+ [FBSession rac_openedSession]</i> - a signal that leads to the opening of the <i>FBSession</i> .  If necessary, this can lead to logging into <i>Facebook</i> . <br><br>  <i>- [FBSession rac_fetchProfile]</i> - a signal that extracts profile data through a session, which is transmitted as <i>self</i> . <br><br>  The advantage of this approach is that for the user the entire stream is fuzzy, represented by the only signal that can be canceled at any ‚Äústage‚Äù, be it Facebook login or Backend call. <br><br><h3>  Filter / Filter </h3><br><pre> <code class="objectivec hljs">- (RACSignal *)filter:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> (^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> value))block;</code> </pre><br>  As a result, the stream contains the stream values ‚Äã‚Äã‚Äúa‚Äù, filtered according to the specified function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/fcc/782/c8afcc7828ef50785a40dbf5ec4cd0bf.png" alt="Filter"></div><br><pre> <code class="objectivec hljs">RACSequence *sequence = @[<span class="hljs-string"><span class="hljs-string">@"Some"</span></span>, <span class="hljs-string"><span class="hljs-string">@"example"</span></span>, <span class="hljs-string"><span class="hljs-string">@"of"</span></span>, <span class="hljs-string"><span class="hljs-string">@"sequence"</span></span>].rac_sequence; RACSequence *filteredSequence = [sequence filter:^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [value hasPrefix:<span class="hljs-string"><span class="hljs-string">@"seq"</span></span>]; }];</code> </pre><br><h3>  Map </h3><br><pre> <code class="objectivec hljs">- (RACSignal *)map:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> value))block;</code> </pre><br>  Unlike FlattenMap, Map runs synchronously.  The value of the property ‚Äúa‚Äù passes through the specified function f (x + 1) and returns the displayed initial value. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/436/58a/764/43658a7643a44a703ca901d873a24fb9.png" alt="Map"></div><br>  Suppose you need to enter the model header on the screen, applying some attributes to it.  A map comes into play when ‚ÄúApplying certain attributes‚Äù is described as a separate function: <br><br><pre> <code class="objectivec hljs">RAC(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleLabel, text) = [RACObserve(model, title) map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *modelTitle) { <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *attributes = @{<span class="hljs-comment"><span class="hljs-comment">/*your custom font, paragraph style, etc*/</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[<span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> alloc] initWithString:modelTitle attributes:attributes]; }];</code> </pre><br>  How it works: combines <i>self.titleLabel.text</i> with the <i>model.title</i> changes, applying custom attributes to it. <br><br><h3>  Zip </h3><br><pre> <code class="objectivec hljs">+ (RACSignal *)zip:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFastEnumeration</span></span>&gt;)streams reduce:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (^)())reduceBlock;</code> </pre><br>  Results stream events are created when each of the threads has generated an equal number of events.  It contains values, one from each of the 3 combined threads. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/b82/43a/527b8243a5839ac8da307cb49c517040.png" alt="Zip"></div><br>  For some practical examples, zip can be described as <i>dispatch_group_notify</i> For example, you have 3 separate signals and you need to combine their answers at a single point: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *signals = @[retrieveFacebookContactsSignal, retrieveAddressBookContactsSignal]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [RACSignal zip:signals reduce:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *facebookContacts, <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *addressBookContacts){ <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *mergedContacts = <span class="hljs-comment"><span class="hljs-comment">// let's merge them somehow ^_^ return mergedContacts; }];</span></span></code> </pre><br><h3>  Throttle </h3><br><pre> <code class="objectivec hljs">- (RACSignal *)throttle:(<span class="hljs-built_in"><span class="hljs-built_in">NSTimeInterval</span></span>)interval;</code> </pre><br>  With the help of a timer set for a certain period of time, the first value of stream ‚Äúa‚Äù is transmitted to the result stream only at the end of the timer.  If a new value is produced within a specified time interval, it holds the first value, preventing it from being transmitted to the result stream.  Instead, a second value appears in the result stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/514/54c/b92/51454cb92f32ce22219448d2eeab9bca.png" alt="Throttle"></div><br>  Amazing case: we need to perform a search query when the user changes the searchField.  Standard task, yes?  However, it is not very effective for building and sending a network request with every text change, since a textField can generate many such events per second, and you will come to inefficient use of the network. <br>  The solution here is to add a delay, after which we will actually execute the network request.  This is usually accomplished by adding NSTimer.  With ReactiveCocoa, this is much easier! <br><br><pre> <code class="objectivec hljs">[[[seachField rac_textSignal] throttle:<span class="hljs-number"><span class="hljs-number">0.3</span></span>] subscribeNext:^(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *text) { <span class="hljs-comment"><span class="hljs-comment">// perform network request }];</span></span></code> </pre><br>  * An important note here is that all ‚Äúprevious‚Äù textFields are changed before the ‚Äúlast‚Äù ones are deleted. <br><br><h3>  Delay / Delay </h3><br><pre> <code class="objectivec hljs">- (RACSignal *)delay:(<span class="hljs-built_in"><span class="hljs-built_in">NSTimeInterval</span></span>)interval;</code> </pre><br>  The value received in stream ‚Äúa‚Äù is delayed and transmitted to the result stream after a certain time interval. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c0/145/360/2c0145360343813e628ce2f15902816d.png" alt="Delay"></div><br><br>  As an analogue of - [RACSignal throttle:], delay will only delay sending ‚Äúnext‚Äù and ‚Äúcompleted‚Äù events. <br><br><pre> <code class="objectivec hljs">[[textField.rac_textSignal delay:<span class="hljs-number"><span class="hljs-number">0.3</span></span>] subscribeNext:^(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *text) { }];</code> </pre><br><h3>  What we like about Reactive Cocoa </h3><br><ul><li>  Introduces <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CocoaBindingsRef/CocoaBindingsRef.html">Cocoa Bindings</a> to iOS </li><li>  Ability to create operations for future data.  Here's a bit of Scala <a href="http://docs.scala-lang.org/overviews/core/futures.html">futures &amp; promises</a> . </li><li>  The ability to represent asynchronous operations in a synchronous manner.  Reactive Cocoa simplifies asynchronous software, such as network code. </li><li>  Convenient decomposition.  Code that is associated with user events and application state changes can become very complex and confusing.  Reactive Cocoa makes dependent operation models particularly simple.  When we present operations in the form of combined streams (for example, processing of network requests, user events, etc.), we can achieve high modularity and free connection, which leads to more frequent use of the code again. </li><li>  The behaviors and relationships between properties are defined as declarative. </li><li>  Solves problems with synchronization - if you combine several signals, then there is one single place for processing all the results (whether it is the next value, a completion signal or an error signal) </li></ul><br>  With the help of the RAC framework, you can create and convert value sequences in a better, higher level way.  RAC makes it easier to manage everything that is waiting for the completion of an asynchronous operation: network response, change of dependent value and subsequent reaction.  At first glance, it is difficult to deal with him, but ReactiveCocoa is contagious! </div><p>Source: <a href="https://habr.com/ru/post/353552/">https://habr.com/ru/post/353552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353540/index.html">The digest of interesting materials for the mobile developer # 249 (April 9 - April 15)</a></li>
<li><a href="../353542/index.html">How to develop a SIEM (Information Security Incident Management System) in one day</a></li>
<li><a href="../353546/index.html">JupyterHub, or how to manage hundreds of Python users. Yandex lecture</a></li>
<li><a href="../353548/index.html">[Yekaterinburg, Announcement] UralJS # 7 - three reports on React Native, convenient navigation in the SPA and the principles of working with DateTime</a></li>
<li><a href="../353550/index.html">Microsoft Exchange Server Development Basics</a></li>
<li><a href="../353554/index.html">Improving Redux</a></li>
<li><a href="../353556/index.html">Postgres enum</a></li>
<li><a href="../353558/index.html">The digest of fresh materials from the world of the frontend for the last week No. 310 (April 9 - 15, 2018)</a></li>
<li><a href="../353560/index.html">Million, million, million ... blue certificates</a></li>
<li><a href="../353562/index.html">[1] + [2] - [3] === 9 !? Examination of internal type conversion mechanisms in JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>