<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Study protection Artmoney. Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings ArtMoney itself was zaigengen me a long time ago. This is not the first time I've been trying to start writing an article about how this pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Study protection Artmoney. Part one</h1><div class="post__text post__text-html js-mediator-article">  Greetings  <b>ArtMoney</b> itself was zaigengen me a long time ago.  This is not the first time I've been trying to start writing an article about how this program was cached, but it has always stopped somewhere.  This time, I decided to finish everything to the end!  Plus, this article can be considered a continuation of a series of articles on cracking for beginners. <br><br>  So, in this article you will learn how I wrote the keygen to <b>ArtMoney</b> (version <i>7.45.1</i> will be described <i>here</i> ). <br><a name="habracut"></a><br><h3>  Stage One: Analysis of the executable file </h3><br>  I installed the English version of the program so that <b>IDA</b> and other utilities look for the text normally. <br><br>  First of all, you need to find out what <b>AM is</b> written / packed with.  Open it (am745.exe <b>file</b> ) in my favorite <a href="http://exeinfo.atwebpages.com/">ExeInfo PE</a> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/cce/7bc/f0e/cce7bcf0e265423c9d0a4ac7d3a81093.png"></div><br><br>  We are told that this is <b><i>Aspack v2.24 - 2.34</i></b> .  Well, seemingly not a complicated packer.  I will remove it by the first automatic unpacker (for the article is not about unpacking). <br><br><h3>  Stage Two: Analyzes Again </h3><br>  We look again at <b>ExeInfo PE</b> , and we see that the program is written in <b>Borland Delphi</b> .  Perfectly!  Let's use the super program for analyzing <b>Delphi</b> programs: <a href="http://kpnc.org/idr32/ru/"><b>IDR</b> ( <i>Interactive Delphi Reconstructor</i> )</a> .  By the way, she also has <a href="https://github.com/crypto2011/IDR">open source</a> .  The IDE version is there and defined. <br><br>  Download all available databases and put in the directory with the <b>IDR</b> .  We are dragging our unpacked test subject into the reconstructor, waiting for the end of the analysis. <br><br>  I will do the whole research process in <b>IDA Pro</b> (plus <b>Hex Rays</b> ), so let's generate an <b>IDC</b> script that tells her about all the names of forms, methods, classes, etc.  Click <i><b>Tools</b> ‚Üí <b>IDC Generator</b></i> in the <b>IDR</b> menu.  We are waiting for the script to be created. <br><br>  Next, open the <b>IDA</b> , and also shove our program into it.  Let's wait for the end of the analysis.  Then apply the generated <b>IDC</b> script: in <b>IDA Pro,</b> click <i><b>File</b> ‚Üí <b>Script File ...</b></i> , select the script.  We are waiting for the application. <br><br>  In order for <b>IDA</b> to properly decompile <b>Delphi</b> code, it needs to say that we are dealing with a <b>Delphi</b> compiler, and <b>__fastcall</b> calls.  Unfortunately, the generated <b>IDC</b> , like the <b>IDA</b> itself, doesn‚Äôt say / know about it. <br><br>  Go to the settings of the <b>IDA</b> compiler: <i><b>Options</b></i> ‚Üí <b><i>Compiler ...</i></b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/366/6c5/c92/3666c5c926a7406c8ffd2e961e0a756d.png"></div><br>  Next, click to re-analyze the program: <b><i>Options</i></b> ‚Üí <i><b>General</b></i> ‚Üí <b><i>Analysis</i></b> ‚Üí <b><i>Reanalyze program</i></b> and <b>OK</b> . <br><br>  Not everything ... :) The <b>IDC-</b> script for some reason did not mark the boundaries of library functions.  Because of what the process of disassembling and decompiling does not become easier.  We'll have to mark up and specify the types ( <b>Y</b> key).  We take <b>call</b> on the known function and we look at its borders.  If the function does not start where the <b>call</b> leads, correct it.  Go to the instruction that is above the beginning of the function (most often, it is <b>retn</b> ), and press <b>E</b> (specify the address of the end of the function) there.  That's better. <br><br>  Now you need to specify the type of function.  Take for example <b>@LStrClr</b> .  The caring <b>IDR</b> pointed out in the comments that this function takes one argument - the address of the string, which means we denote the function's prototype as (remember that in <b>Delphi the</b> <b>fastcall</b> call <b>convention</b> ): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LStrClr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span></code> </pre> <br>  I hope it is clear why.  Well, <b>void</b> because the <b>procedure</b> . <br><br>  And so we repeat with many and many functions ... When specifying prototypes, we use these simple rules: <br><br><ul><li>  Arguments are passed via <b>eax</b> , <b>edx</b> , <b>ecx</b> , <b>stack</b> (from left to right).  This will help if the decompiler stumbles upon a " <b><i>positive sp value</i></b> "; </li><li>  In any <b>StrCatN</b> functions, if <b>ArgCnt: Integer</b> is specified, then this is the <b>vararg</b> function, and the prototype will contain <b>....</b>  In the decompiler, you need to get at each place you call such functions, and press <b>+</b> / <b>-</b> on the <b>Numpad-</b> keyboard, adding / removing arguments.  The amount can be viewed in disasm-listing.  Prototype example: " <b>void LStrCatN (char *, char *, ...)</b> "; </li><li>  If the function, judging by the <b>Delphi</b> prototype, returns a pointer to a string, then, most often, this is an implicit output argument in the prototype, and it should be added as the last argument too. </li></ul><br>  Well, now you can start searching for the registration procedure ... <br><br><h3>  Stage three: Where are you, my beloved, where? </h3><br>  We turn to <b>IDR</b> to the forms, and (I‚Äôll say right away, open the <b>Form28</b> form), switch to the visual viewing.  We see the registration window.  Scroll through the window and find the three outlines of the buttons.  The left one is the <b>OK</b> button, the registration application: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/40e/3e3/2d7/40e3e32d7d2e40398a01cc61708e308f.png"></div><br><h3>  Stage four: Analyze onclick ().  Surface </h3><br>  <b>Right-click</b> on it and go to the <b>OKClick</b> handler.  In <b>IDA,</b> go to the address of the beginning of this procedure (button <b>G</b> ). <br><br>  First, we point out that this is a <b>bp-based</b> function (i.e., addressing local variables goes through the <b>EBP</b> register minus offset), otherwise local variables are not recognized.  We press <b>Alt + P</b> (or PKM by function, <b>Edit function ...</b> ), and set the <b>BP-based frame</b> . <br><br>  Let's try to decompile ... If everything went well, we will see a terrible pseudocode decompiler, otherwise fix the prototypes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ac4/46f/8c0/ac446f8c0b094077b0d90da1be3fe641.png"></div><br>  We press <b>Y</b> on each call to the library / self-writing function, and make sure that the prototypes are with <b>__fastcall</b> , and the arguments are correctly specified. <br><br>  The first cycle, judging by the <b>IDR</b> , is checking the key for alphabetic belonging of characters, and gluing them into a global variable.  Call it <b>g_LicKey</b> . <br><br>  Next comes the call to an unknown function so far, and, apparently, this is actually the key verification function itself ... <br><br><h3>  Stage Five: Key Verification (Side View) </h3><br>  This function takes two arguments: the first is the <b>out</b> parameter, it will contain some error code, and the second is the letter (' <b>A</b> ' is in the English version, or ' <b>B</b> ' is in Russian). <br><br>  Decompiling ... <br><br>  The code is quite large, I agree, but if you approach it correctly, slowly, and without shying away from the abundance of code, you can successfully figure out what is happening here. <br><br>  Very often you can come across similar code that issued a decompiler (variable names, of course, may differ): <br><br><pre> <code class="cpp hljs"> v2 = g_LicKey; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( g_LicKey ) v2 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)*((_DWORD *)g_LicKey - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Here it is worth saying that <b>Delphi has</b> its own special string type, and in the form of a structure it can be described as follows: <br><br><pre> <code class="hljs cs">d_str struc ; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>=<span class="hljs-number"><span class="hljs-number">0x8</span></span>, mappedto_243, variable size) _top dd ? length dd ? <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span> dup(?) ; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(C) delphi_string ends</code> </pre> <br>  The first dvd is always <b>0xFFFFFFFF</b> , the second is the length of the string, and then the string itself goes.  Therefore, similar code constructs only get the length of the string. <br><br>  Another important note: <b>Delphi</b> row indices because of this come with <b>1</b> , so you will often see subtraction 1 from the index in the decompiler / disassembler (to match the actual arrangement of characters in memory). <br><br>  Next comes the length check: <i>&gt; = 70</i> and <i>&lt;= 500</i> . <br><br>  Further, we see the verification of the first key symbol for equality to the second argument of the function, i.e.  ' <b>A</b> ' or ' <b>B</b> ', and setting the flag depending on the character.  I called this flag <b><i>rus_ver</i></b> . <br><br>  Agree, it looks cumbersome: <br><br><pre> <code class="cpp hljs">LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;v193, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int8)g_LicKey[<span class="hljs-number"><span class="hljs-number">2</span></span>]); gvar_006F58C0 = Pos(v193, *(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)_abcdefghijklmnopqrstuvwxyzABCDEFGHIJ1234567890KLMNOPQRSTUVWXYZ_); gvar_006F58C8 = *(_BYTE *)(*(_DWORD *)_abcdefghijklmnopqrstuvwxyzABCDEFGHIJ1234567890KLMNOPQRSTUVWXYZ_ + (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int8)gvar_006F58C0 - <span class="hljs-number"><span class="hljs-number">3</span></span>); gvar_006F58C9 = *(_BYTE *)(*(_DWORD *)_abcdefghijklmnopqrstuvwxyzABCDEFGHIJ1234567890KLMNOPQRSTUVWXYZ_ + (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int8)gvar_006F58C0 - <span class="hljs-number"><span class="hljs-number">4</span></span>); LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;v192, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int8)g_LicKey[<span class="hljs-number"><span class="hljs-number">1</span></span>]); v242 = Pos(v192, *(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)_abcdefghijklmnopqrstuvwxyzABCDEFGHIJ1234567890KLMNOPQRSTUVWXYZ_);</code> </pre> <br>  And so much better: <br><br><pre> <code class="cpp hljs">LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;lic_key, g_LicKey[<span class="hljs-number"><span class="hljs-number">2</span></span>]); g_PosChar2 = Pos(lic_key, str_EngAlpha); g_AlphaChar1 = str_EngAlpha[g_PosChar2 - <span class="hljs-number"><span class="hljs-number">3</span></span>]; g_AlphaChar2 = str_EngAlpha[g_PosChar2 - <span class="hljs-number"><span class="hljs-number">4</span></span>]; LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;key_char_1, g_LicKey[<span class="hljs-number"><span class="hljs-number">1</span></span>]); key_char1_pos = Pos(key_char_1, str_EngAlpha);</code> </pre> <br>  Next - check <b>key_char1_pos</b> for equality <b>12</b> . <br><br>  Now there is a summation of the key symbols, except for the last two, and, as long as the sum is greater than <b>0xFF</b> , division by 2, and increment by 1: <br><br><pre> <code class="cpp hljs">idx = key_len_minus_2 - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( key_len_minus_2 - <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { key_idx = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { key_sum += (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int8)g_LicKey[key_idx++ - <span class="hljs-number"><span class="hljs-number">1</span></span>]; --idx; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx ); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; key_sum &gt; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; key_sum = (key_sum &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> ) ;</code> </pre> <br>  We convert the resulting amount to a hex-string, and then to <b>lowercase</b> . <br><br>  Now we get the last two characters of the key, transfer each of them to some function, and at the output we get by the transformed character.  Let's take this function ... <br><br><h3>  Stage Six: Character Conversion </h3><br>  In general, the character conversion function looks like this: <br><br><pre> <code class="cpp hljs">LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;inChar_2, inChar); v3 = Pos(inChar_2, str_EngAlpha); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( v3 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( g_PosChar2 &gt; <span class="hljs-number"><span class="hljs-number">0xA</span></span>u ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; g_PosChar2 - <span class="hljs-number"><span class="hljs-number">5</span></span>; i += <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( i == v3 ) { v3 = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( v3 == i + <span class="hljs-number"><span class="hljs-number">1</span></span> ) { v3 = i; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( j = g_PosChar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">60</span></span>; j += <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( j == v3 ) { v3 = j + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( v3 == j + <span class="hljs-number"><span class="hljs-number">1</span></span> ) { v3 = j; } } v6 = v3 - g_PosChar2 + ((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(v3 - g_PosChar2) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0x3E</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( flag_1 ) v2 = str_RusAlpha1[v6 - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> v2 = str_EngAlpha1[v6 - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v2;</code> </pre> <br>  It seems simple.  I have to say, we have to invert it.  <b>Let's</b> call it <b>DecodeChar</b> . <br><br>  As a result, the last two characters of the key are converted by this function, and compared with the previously obtained hex-sum of all the other key characters. <br><br><blockquote>  <b>ToRevert</b> (with <i>this word I will mark the important points in the reverse of the key verification function</i> ): At the very end, when the key is ready, we consider the sum of its characters, convert to <i>hex</i> ( <i>0xXX</i> ), then each nibbl is inverted <b>DecodeChar</b> , and paste to the key. </blockquote><br>  We see further that the third character of the key is converted, translated from hex to <b>int</b> , and the bits are checked.  So let's call it all: <br><br><pre> <code class="cpp hljs">v202 = meffi_DecodeChar(g_LicKey[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); PStrCpy(&amp;v132, str_Hex); v134 = v202; v133 = <span class="hljs-number"><span class="hljs-number">1</span></span>; PStrNCat(&amp;v132, &amp;v133, <span class="hljs-number"><span class="hljs-number">2</span></span>); LStrFromString((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;v129, &amp;v132); key_char_3 = StrToInt(v129); k3_flag1 = (key_char_3 &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>; k3_flag2 = (key_char_3 &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>; k3_flag3 = (key_char_3 &amp; <span class="hljs-number"><span class="hljs-number">4</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>; k3_flag4 = (key_char_3 &amp; <span class="hljs-number"><span class="hljs-number">8</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  While we do not know the purpose of the bits, we therefore give them at least some meaningful names. <br><br>  Again a function that we do not know, and one of the flags is passed to it: <br><br><pre> <code class="cpp hljs">key_idx = <span class="hljs-number"><span class="hljs-number">5</span></span>; sub_66408C(&amp;key_idx, k3_flag1, &amp;v128);</code> </pre> <br>  The last parameter seems to be the output string, since  passed on to <b>Trim ()</b> and used later. <br><br>  Immediately give this function the corresponding prototype: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_66408C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *output)</span></span></span></span></code> </pre> <br><h3>  Stage seven: Reading a string from the key </h3><br>  Yes, this is exactly what this function does.  That shows debugging, and a quick overview of the code.  But first things first. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( g_LicKey[*(_DWORD *)idx_1 - <span class="hljs-number"><span class="hljs-number">1</span></span>] != g_AlphaChar1 &amp;&amp; LStrLen(g_LicKey) &gt;= *(_DWORD *)idx_1 )</code> </pre> <br>  Immediately, we note that the first parameter is used as a pointer to dword (int), so we change its type to <b>int *</b> (in <b>Delphi,</b> this is called <b>var</b> arguments). <br><br>  After all type conversions, and adjustment of arguments, our function takes the form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( g_LicKey[*idx_1 - <span class="hljs-number"><span class="hljs-number">1</span></span>] != g_AlphaChar1 &amp;&amp; LStrLen(g_LicKey) &gt;= *idx_1 ) { c1 = g_LicKey[*idx_1 - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( c1 == g_AlphaChar2 ) { LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;c1_str, c1); c1_str_ = c1_str; LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;c2_str, g_LicKey[*idx_1]); c2_str_ = c2_str; LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;c3_str, g_LicKey[*idx_1 + <span class="hljs-number"><span class="hljs-number">1</span></span>]); LStrCatN(c3_str, c2_str_, c1_str_, gvar_0070DF4C); PStrCpy(&amp;str_hex, str_Hex_0); cc[<span class="hljs-number"><span class="hljs-number">1</span></span>] = meffi_DecodeChar(g_LicKey[*idx_1], <span class="hljs-number"><span class="hljs-number">0</span></span>); cc[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; PStrNCat(&amp;str_hex, cc, <span class="hljs-number"><span class="hljs-number">2</span></span>); PStrCpy(&amp;hexVal, &amp;str_hex); cc[<span class="hljs-number"><span class="hljs-number">1</span></span>] = meffi_DecodeChar(g_LicKey[*idx_1 + <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); cc[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; PStrNCat(&amp;hexVal, cc, <span class="hljs-number"><span class="hljs-number">3</span></span>); LStrFromString((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;hexVal_1, &amp;hexVal); value = ValLong(hexVal_1, &amp;outCode); LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;value_1, value); LStrCat((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;output_2, value_1); *idx_1 += <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;keyChar, g_LicKey[*idx_1 - <span class="hljs-number"><span class="hljs-number">1</span></span>]); LStrCat((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;gvar_0070DF4C, keyChar); c = meffi_DecodeChar(g_LicKey[*idx_1 - <span class="hljs-number"><span class="hljs-number">1</span></span>], flag_1); LStrFromChar((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;c_str, c); LStrCat((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;output_2, c_str); } ++*idx_1; } ++*idx_1;</code> </pre> <br>  We see that the key characters are being read, until <b>g_AlphaChar1 is encountered</b> .  If the symbol is not equal to <b>g_AlphaChar2</b> , we glue it into a global variable, and <b>glue the</b> symbol converted with <b>DecodeChar ()</b> into the output buffer. <br><br>  If we got the <b>g_AlphaChar2</b> character, we read the two characters following it, transform them, convert them to a number, and paste them to the output buffer.  In the non-converted form, we add the same two symbols together with <b>g_AlphaChar2</b> to the global variable.  <b>Let's</b> call it <b>g_stringFromKey1</b> . <br><br>  Apparently, this function can be called <b>DecodeString</b> . <br><br><blockquote>  <b>ToRevert</b> : The string that we want to encode into a key will have to be converted using the inverse function for <b>DecodeString ()</b> . </blockquote><br>  <b>PS</b> On this, the first part of the article about the keying of <b>ArtMoney</b> I probably finish.  In the second part, we will continue to decompile the key verification code, faced with new difficulties, and stupid-looking code.  But, does it stop us? <br>  <b>PPS</b> <i>Give us more interesting articles on reverse!</i> </div><p>Source: <a href="https://habr.com/ru/post/255767/">https://habr.com/ru/post/255767/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255753/index.html">Creating dials for Android Wear on OpenGL ES 2.0</a></li>
<li><a href="../255757/index.html">1C: Enterprise Development Tools, or Eclipse in Russian</a></li>
<li><a href="../255759/index.html">Sugar injections in C #</a></li>
<li><a href="../255761/index.html">Algorithms for fast calculation of factorial</a></li>
<li><a href="../255763/index.html">Coffee with cucumbers (Espresso + Cucumber)</a></li>
<li><a href="../255769/index.html">Very subjective review of JS frameworks. AmpersandJS, part 0</a></li>
<li><a href="../255773/index.html">Java-based configuration of embedded Jetty / Spring MVC / Spring Security</a></li>
<li><a href="../255775/index.html">Algorithms of intellectual autogeneration of levels in iOS game</a></li>
<li><a href="../255779/index.html">Microsoft and Adobe released a set of updates for their products, April 2015</a></li>
<li><a href="../255781/index.html">A new issue of the journal "In the clouds. RF"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>