<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular onPush Complete Change Detection Strategy Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Default change detection strategy 


 By default, Angular uses the ChangeDetectionStrategy.Default change detection strategy. 


 ChangeDetectionStrat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular onPush Complete Change Detection Strategy Guide</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/jm/5d/yi/jm5dyiipzat3zakd81_2szw50es.jpeg" alt="image"></p><br><h2 id="default-ctrategiya-obnaruzheniya-izmeneniy">  Default change detection strategy </h2><br><p>  By default, Angular uses the <strong>ChangeDetectionStrategy.Default</strong> change detection strategy. </p><br><p>  <strong>ChangeDetectionStrategy.Default</strong> works in such a way that every time something changes in our application, as a result of various user events, timers, XHR, promises, etc., change detection will run on all components. </p><a name="habracut"></a><br><p>  We can see this with a simple example.  Create a getter component and use it in our template.  For example: </p><br><pre><code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'hello'</span></span></span><span class="hljs-meta">, template: ` &lt;h1&gt;Hello {{name}}!&lt;/h1&gt; {{runChangeDetection}} ` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> name: string; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> runChangeDetection() { console.log(<span class="hljs-string"><span class="hljs-string">'Checking the view'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><pre> <code class="hljs coffeescript">@Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, template: `<span class="javascript"><span class="javascript"> &lt;hello&gt;</span><span class="xml"><span class="hljs-tag"><span class="javascript"><span class="xml"><span class="hljs-tag">&lt;/</span></span></span><span class="hljs-name"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-name">hello</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></span><span class="javascript"> &lt;button (click)=</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"onClick()"</span></span></span><span class="javascript">&gt;Trigger change detection&lt;</span><span class="hljs-regexp"><span class="javascript"><span class="hljs-regexp">/button&gt; </span></span></span></span>` }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">onClick</span></span></span><span class="hljs-class">() {} }</span></span></code> </pre> <br><p>  Every time we press a button, Angular will launch a change detection cycle and in the console we will see two ‚ÄúChecking the view‚Äù logs (or one in the production mode). </p><br><p>  This cycle is called dirty checking.  The essence of the test is that Angular compares the new values ‚Äã‚Äãwith the old ones and updates the view if they are not equal. </p><br><p>  Now imagine a large application with a huge number of components and a variety of conditions.  If we allow Angular, each time the change detection cycle starts, to check each of these conditions, it will negatively affect performance. </p><br><p>  Despite the fact that Angular is well optimized, as the application grows, it will have to work more and more. </p><br><p>  What if we help Angular and give it more explicit indicators when to check our components? </p><br><h2 id="onpush-strategiya-obnaruzheniya-izmeneniy">  OnPush change detection strategy </h2><br><p>  We can change <strong>ChangeDetectionStrategy.Default</strong> to <strong>ChangeDetectionStrategy.OnPush</strong> . </p><br><p>  This means that the component now depends only on <strong>@inputs ()</strong> parameters, and will be checked only under the following conditions: </p><br><h4 id="1-izmenilas-ssylka-input-parametra">  1. The parameter input reference has changed. </h4><br><p>  Having established the OnPush strategy, we kind of sign a contract with Angular, which obliges us to work with immutable objects (or observables, as we will see later). </p><br><p>  The advantage of working with immutable data in the context of detecting changes is that Angular performs a simple reference check to decide whether to check the presentation.  This is much faster than a deep comparison of objects. </p><br><p>  Let's try to mutate an object and look at the result: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'tooltip'</span></span></span><span class="hljs-meta">, template: ` &lt;h1&gt;{{config.position}}&lt;/h1&gt; {{runChangeDetection}} `, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TooltipComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> config; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> runChangeDetection() { console.log(<span class="hljs-string"><span class="hljs-string">'Checking the view'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-root'</span></span></span><span class="hljs-meta">, template: ` &lt;tooltip [config]=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config"</span></span></span><span class="hljs-meta">&gt;&lt;/tooltip&gt; &lt;button (click)</span></span>=<span class="hljs-string"><span class="hljs-string">"onClick()"</span></span>&gt;Click&lt;/button&gt; ` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ config = { position: <span class="hljs-string"><span class="hljs-string">'top'</span></span> }; onClick() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config.position = <span class="hljs-string"><span class="hljs-string">'bottom'</span></span>; } }</code> </pre> <br><p>  After clicking on the button, we will not see any logs in the console.  Angular simply compared the old and new values ‚Äã‚Äãby reference, which remained the same. </p><br><pre> <code class="hljs vbscript">/** Returns <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> our <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> */ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( oldValue !== newValue ) { runChangeDetection(); }</code> </pre> <br><p>  As we know, numbers, booleans, strings, null and undefined are primitive types.  All primitive types are passed by value.  Objects, arrays, and functions are passed by reference. </p><br><p>  To start the change detection mechanism, we need to change the object reference itself. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-root'</span></span></span><span class="hljs-meta">, template: ` &lt;tooltip [config]=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config"</span></span></span><span class="hljs-meta">&gt;&lt;/tooltip&gt; &lt;button (click)</span></span>=<span class="hljs-string"><span class="hljs-string">"onClick()"</span></span>&gt;Click&lt;/button&gt; ` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ config = { position: <span class="hljs-string"><span class="hljs-string">'top'</span></span> }; onClick() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = { position: <span class="hljs-string"><span class="hljs-string">'bottom'</span></span> } } }</code> </pre> <br><p>  After this change, we will see that the view has been verified and the value has changed, as we expected. </p><br><h4 id="2-sobytie-vnutri-komponenta-ili-ego-potomkah">  2. The event inside the component or its descendants </h4><br><p>  A component can have an internal state that is updated when an event from the component itself or its descendants occurs. </p><br><p>  For example click: </p><br><pre> <code class="hljs axapta">@Component({ template: ` &lt;button (click)=<span class="hljs-string"><span class="hljs-string">"add()"</span></span>&gt;Add&lt;/button&gt; {{<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>}} `, changeDetection: ChangeDetectionStrategy.OnPush }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; add() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; } }</code> </pre> <br><p>  When we click on the button, Angular starts the change detection cycle and the view is updated as expected. </p><br><p>  Perhaps you think that all asynchronous operations should also be a trigger for starting the change detection mechanism, as we said at the beginning, but no.  The rule applies only to DOM events, so the following code will not trigger the mechanism. </p><br><pre> <code class="hljs javascript">@Component({ <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`...`</span></span>, <span class="hljs-attr"><span class="hljs-attr">changeDetection</span></span>: ChangeDetectionStrategy.OnPush }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterComponent</span></span></span><span class="hljs-class"> </span></span>{ count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get(<span class="hljs-string"><span class="hljs-string">'https://count.com'</span></span>).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = res; }); } add() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count++; } }</code> </pre> <br><p>  Notice that the count property has changed, so the next cycle for detecting changes, when we click the button, the value will be 6 (5 + 1). </p><br><h4 id="3-ruchnoy-zapusk-obnaruzheniya-izmeneniy">  3. Manual start of change detection </h4><br><p>  Angular provides us with three methods for launching the change detection mechanism ourselves and we can call them in the places we need. </p><br><p>  The first <strong>detectChanges ()</strong> tells Angular to start detecting changes in a component and its descendants. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'counter'</span></span></span><span class="hljs-meta">, template: `{{count}}`, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterComponent</span></span></span><span class="hljs-class"> </span></span>{ count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> cdr: ChangeDetectorRef) { setTimeout(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cdr.detectChanges(); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre> <br><p>  The second <strong>ApplicationRef.tick ()</strong> tells Angular to start detecting changes in the entire application. </p><br><pre> <code class="hljs coffeescript">tick() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._views.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function"> =&gt;</span></span> view.detectChanges()); ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { ... } }</code> </pre> <br><p>  And the third <strong>markForCheck ()</strong> , which <strong>does not</strong> trigger the start of change detection.  Instead, it marks the component and all its parents that they should be checked in the current or next change detection cycle. </p><br><pre> <code class="hljs javascript">markForCheck(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { markParentViewsForCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._view); } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">markParentViewsForCheck</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">view: ViewData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currView: ViewData|<span class="hljs-literal"><span class="hljs-literal">null</span></span> = view; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (currView) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currView.def.flags &amp; ViewFlags.OnPush) { currView.state |= ViewState.ChecksEnabled; } currView = currView.viewContainerParent || currView.parent; } }</code> </pre> <br><p>  It is worth noting that manual starting the change detection mechanism is not a bad practice.  The use of these methods is quite by design and permissible (of course, if necessary). </p><br><h2 id="angular-async-payp">  Angular Async Pipe </h2><br><p>  Async pipe subscribes to the observed object or promise and returns the last value given to it. </p><br><p>  Let's look at a simple example of a component with OnPush and an observable input parameter. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-root'</span></span></span><span class="hljs-meta">, template: ` &lt;button (click)</span></span>=<span class="hljs-string"><span class="hljs-string">"add()"</span></span>&gt;Add&lt;/button&gt; &lt;app-list [items]=<span class="hljs-string"><span class="hljs-string">"items$"</span></span>&gt;&lt;/app-list&gt; ` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ items = []; items$ = new BehaviorSubject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items); add() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items.push({ title: Math.random() }) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items$.next(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items); } }</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-list'</span></span></span><span class="hljs-meta">, template: ` &lt;div *ngFor=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"let item of _items"</span></span></span><span class="hljs-meta">&gt;{{item.title}}&lt;/div&gt; `, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> items: Observable&lt;Item[]&gt;; _items: Item[]; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items.subscribe(items =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._items = items; }); } }</code> </pre> <br><p>  After clicking on the button, we will not see the updated view.  This is due to the fact that none of the conditions described above has happened.  Therefore, Angular will not check the component in the current change detection cycle. </p><br><p>  Now let's use async pipe. </p><br><pre> <code class="hljs axapta">@Component({ template: ` &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> *ngFor=<span class="hljs-string"><span class="hljs-string">"let item of items | async"</span></span>&gt;{{item.title}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; `, changeDetection: ChangeDetectionStrategy.OnPush }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ @Input() items; }</code> </pre> <br><p>  As you can see, the view is now updated.  When a new value arrives, the async pipe marks the component as needed for the check.  We can see it in the <a href="">source</a> : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _updateLatestValue(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>: any, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: Object): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._obj) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._latestValue = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ref.markForCheck(); } }</code> </pre> <br><p>  Angular calls <strong>markForCheck ()</strong> , so the view is updated even when the links have not changed. </p><br><p>  If a component depends only on incoming parameters, and they are observable, then this component can change only if one of the parameters generates an event. </p><br><p>  Tip: Antipatter is considered to be given to the outside world by subject, it is better to always give the observed object using the asObservable () method. </p><br><h2 id="onpush-i-shablonnye-peremennye">  OnPush and template variables </h2><br><p>  Consider the following components: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-tabs'</span></span></span><span class="hljs-meta">, template: `&lt;ng-content&gt;&lt;/ng-content&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabsComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ContentChild(TabComponent)</span></span> tab: TabComponent; ngAfterContentInit() { setTimeout(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tab.content = <span class="hljs-string"><span class="hljs-string">'Content'</span></span>; }, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } }</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-tab'</span></span></span><span class="hljs-meta">, template: `{{content}}`, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> content; }</code> </pre> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tabs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tab</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tab</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tabs</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  You probably think that Angular will update the app-tab view of the component with a new value in 3 seconds. </p><br><p>  We have seen that if we update the link in the OnPush component, this should trigger a change detection mechanism, shouldn‚Äôt it? </p><br><p>  Unfortunately, in this example it does not work.  Angular does not know that we have updated the property in the app-tab component.  Only by defining the input parameter in the template, Angular will understand that this property should be checked in the next change detection cycle. </p><br><p>  For example: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tabs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tab</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tab</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-tabs</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Since we have explicitly defined the input parameter in the template, Angular will create the <strong>updateRenderer ()</strong> function, which tracks the changes in the parameter values ‚Äã‚Äãin each change detection cycle. </p><br><p><img src="https://habrastorage.org/webt/o2/lg/em/o2lgem7b-4tkb-vf8yhsgtueaz0.png" alt="image"><br>  AppComponent.ngfactory.ts </p><br><p>  A simple solution in this case is to create a setter and call <strong>markForCheck ()</strong> . </p><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-tab'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`{{_content}}`</span></span>, <span class="hljs-attr"><span class="hljs-attr">changeDetection</span></span>: ChangeDetectionStrategy.OnPush }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabComponent</span></span></span><span class="hljs-class"> </span></span>{ _content; @Input() set content(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._content = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cdr.markForCheck(); } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private cdr: ChangeDetectorRef) {} }</code> </pre> <br><h2 id="-onpush">  === onPush ++ </h2><br><p>  Once we understand (hopefully) the full power of OnPush, we can create more optimized applications.  The more components with the OnPush strategy we have, the fewer checks Angular will perform.  Consider a real example: </p><br><p>  Suppose we have a todos component in which the todos property is defined with the Input decorator. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-todos'</span></span></span><span class="hljs-meta">, template: ` &lt;div *ngFor=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"let todo of todos"</span></span></span><span class="hljs-meta">&gt; {{todo.title}} - {{runChangeDetection}} &lt;/div&gt; `, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodosComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> todos; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> runChangeDetection() { console.log(<span class="hljs-string"><span class="hljs-string">'TodosComponent - Checking the view'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ template: ` &lt;button (click)</span></span>=<span class="hljs-string"><span class="hljs-string">"add()"</span></span>&gt;Add&lt;/button&gt; &lt;app-todos [todos]=<span class="hljs-string"><span class="hljs-string">"todos"</span></span>&gt;&lt;/app-todos&gt; ` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ todos = [{ title: <span class="hljs-string"><span class="hljs-string">'One'</span></span> }, { title: <span class="hljs-string"><span class="hljs-string">'Two'</span></span> }]; add() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos = [...<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos, { title: <span class="hljs-string"><span class="hljs-string">'Three'</span></span> }]; } }</code> </pre> <br><p>  The disadvantage of this example is that when you click the Add button, Angular will check each todo for changes.  And at the first click we will see three logs in the console. </p><br><p>  In the example above, only one check is done, but imagine a component from a real large application, with several conditions and data bindings (ngIf, ngClass, expressions, etc.).  This can significantly affect performance. </p><br><p>  <em>We run change detection for no reason.</em> </p><br><p>  An effective solution is to create a component with OnPush strategy for a specific todo.  For example: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-todos'</span></span></span><span class="hljs-meta">, template: ` &lt;app-todo [todo]=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"todo"</span></span></span><span class="hljs-meta"> *ngFor=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"let todo of todos"</span></span></span><span class="hljs-meta">&gt;&lt;/app-todo&gt; `, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodosComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> todos; }</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-todo'</span></span></span><span class="hljs-meta">, template: `{{todo.title}} {{runChangeDetection}}`, changeDetection: ChangeDetectionStrategy.OnPush })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> todo; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> runChangeDetection() { console.log(<span class="hljs-string"><span class="hljs-string">'TodoComponent - Checking the view'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Now when you click on the button, we will see only one log.  Since none of the input parameters of the other todo has changed, their presentation will not be checked. </p><br><p>  Also, the logical separation of components will make your code more readable and reusable. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/358860/">https://habr.com/ru/post/358860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358848/index.html">To bypass blocking Telegram uses the obvious idea described in the patents of the Ministry of Defense of the Russian Federation</a></li>
<li><a href="../358850/index.html">Multi-agent system for parallel programming (Java, C ++)</a></li>
<li><a href="../358852/index.html">Information systems with conceptual models. Part one</a></li>
<li><a href="../358856/index.html">In pursuit of efficient processes and a successful product - Whale Rider</a></li>
<li><a href="../358858/index.html">Sync command with SCRUM</a></li>
<li><a href="../358862/index.html">Patenting, desktop for programmers, networks in Kubernetes and scooter as a gift</a></li>
<li><a href="../358864/index.html">Intelligence agencies have problems with interception of messages in all instant messengers except ICQ</a></li>
<li><a href="../358866/index.html">And again: do not use public WiFi</a></li>
<li><a href="../358870/index.html">Saga of options</a></li>
<li><a href="../358872/index.html">Compact serializer for cache using System.Reflection.Emit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>