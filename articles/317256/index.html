<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Promise JavaScript Guide for Newbies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have prepared this material for JavaScript programmers who are just starting to deal with ‚ÄúPromise‚Äù. Promises in JavaScript is a new tool for worki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Promise JavaScript Guide for Newbies</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4aa/262/17c/4aa26217cf3c4d8e9122555b6c6f9e1b.png" alt="image"><br><br>  We have prepared this material for JavaScript programmers who are just starting to deal with ‚ÄúPromise‚Äù.  <b>Promises</b> in JavaScript is a new tool for working with deferred or asynchronous computing, added to ECMAScript 2015 (6th version of ECMA-262). <br><a name="habracut"></a><br>  Before the appearance of ‚Äúpromises‚Äù, asynchronous tasks could be solved with the help of callback functions or with the help of event handling.  A universal approach to solving asynchronous tasks is event handling.  A less convenient, but also valid, way to use callback functions.  Of course, the choice of solution depends on the task before you.  The solution to problems with the help of "promises", rather, is intended to replace the approach to callback functions. <br><br>  There is a significant drawback to using callback functions in terms of code organization: " <b>callback hell</b> ".  This disadvantage is that there is a parameter in the callback function, which, in turn, is also a callback function - and this can continue indefinitely. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/eb6/f44/e8d/eb6f44e8d7664f0f97fd5a4879daa16b.png"><br><br>  There may be several levels of such nestings.  This leads to poor code reading and confusion between calls to callback functions.  This, in turn, will lead to errors.  With such a code structure, it is very difficult to find errors. <br><blockquote>  If you still use this approach, it will be more efficient to initialize the callback functions separately, creating them in the right place. </blockquote><br>  Let's look at the work of "promises" on the example of a specific task: <br>  <i>After loading the browser page, you need to display images from the specified list</i> . <br><br>  The list is an array in which the path to the image.  For example, to display images in the slider of your banner system on the site or asynchronously download images in the photo album. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * (,   1.jpg, 2.jpg, 3.jpg, 4.jpg ,  * fake.jpg - ) * * @type {string[]} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgList = [<span class="hljs-string"><span class="hljs-string">"img/1.jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"img/2.jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"img/fake.jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"img/3.jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"img/4.jpg"</span></span>];</code> </pre> <br>  First, we write a function that loads one image at the specified url. <br><br><div class="spoiler">  <b class="spoiler_title">function loadImage (url)</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * *     url * * @param url * @returns {Promise} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// "" return new Promise(function(resolve, reject) { var img = new Image(); img.onload = function() { //    ,  ""  url   return resolve(url); } img.onerror = function() { //     ,  ""  url   return reject(url); } img.src = url; }); }</span></span></code> </pre><br></div></div><br>  The ‚Äúpromise‚Äù object is created using the new Promise (...) constructor, to which an anonymous function with two parameters is passed as an argument: resolve, reject.  They, in turn, are also functions.  Resolve () - reports that the code is executed "successfully", reject () - the code is executed with "error" (what is considered an "error" when executing your code, you decide. This is something like if (true) {. ..} else {...}). <br><br><blockquote>  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise">The Promise interface (promise)</a> is a wrapper for a value unknown at the time the promise is created.  It allows processing the results of asynchronous operations as if they were synchronous: instead of the final result of the asynchronous method, a promise is returned, the result of which can be obtained at some point in the future. <br><br>  When creating, the promise is pending (pending state), and then it can become fulfilled, returning the result (value), or rejected, returning the reason for the refusal. </blockquote><br>  You can pass any objects to the resolve () and reject () methods.  In the reject () method, as a rule, an object of the Error type is passed indicating the cause of the error (the ‚Äúrejected‚Äù state of the ‚Äúpromise‚Äù).  In any case, it is not necessary.  The decision how further you will handle such situations is yours. <br><br>  At the moment it may seem that the "promise" absolutely does not need to be used in this situation.  So far we are only setting up some kind of indicator of whether the image has been loaded.  However, soon you will see that this mechanism can easily, intuitively understand what happens after the task is completed (the image is loaded or not). <br><br><h3>  Then () and catch () methods </h3><br>  Whenever you create a promise object, two methods become available: <b>then ()</b> and <b>catch ()</b> .  Using them, you can execute the necessary code with the successful resolution of the "promise" (resolve (...)) or the code that handles the situation with the "error" (reject (...)). <br><br><div class="spoiler">  <b class="spoiler_title">then () and catch ()</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   var ascync = true; // false if (!ascync) return reject(new Error("  ...")); return resolve(1); }); } myPromise() .then(function(res) { console.log(res); // 1 }) .catch(function(err){ console.log(err.message); //  "  ..." });</span></span></code> </pre><br>  <i>Note: it is</i> not necessary to return (return) resolve (...) or reject (...) :.  In the example above, one would write: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var ascync = true; // false if (!ascync) { reject(new Error("  ...")); } else { resolve(1); }</span></span></code> </pre><br></div></div><br>  As a result of the myPromise () call, the then () or catch () method would still work.  The best thing to do right away is to always return resolve (...) or reject (...).  In the future, this will help to avoid a situation where the code will not work as expected. <br><br>  Two anonymous functions are passed to the then () and catch () methods.  The syntax of the then () method is generally as follows: <br><br><pre> <code class="javascript hljs">then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSuccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFail</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{});</code> </pre><br>  The function onSuccess () {} parameter will be called in case of successful execution of the ‚Äúpromise‚Äù, function onFail () {} - in case of an error.  For this reason, the following code will work the same way: <br><br><div class="spoiler">  <b class="spoiler_title">Examples of the then () method</b> <div class="spoiler_text"><pre> <code class="javascript hljs">myPromise() .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); <span class="hljs-comment"><span class="hljs-comment">// 1 }) .catch(function(err){ console.log(err.message); //  "  ..." }); myPromise() .then(function(res) { console.log(res); // 1 }, function(error) { console.log(err.message); //  "  ..." }); myPromise() .then(function(res) { console.log(res); // 1 }) .then(undefined, function(error) { console.log(err.message); //  "  ..." });</span></span></code> </pre><br></div></div><br>  It is much more familiar and clearer to use catch (...).  You can also call the catch () method ‚Äúin the middle‚Äù of the then () call chain if the logic of your code requires: then (). Catch (). Then (). Don't forget to call catch () last in the chain: this will allow you to always catch "Erroneous" situations. <br><br>  Call our loadImage (url) method and, for example, add one image to the page: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//,       id="images", , div loadImage(imgList[0]) .then(function(url) { $('#images').append('&lt;img src="'+url+'" style="width: 200px;" /&gt;'); }) .catch(function(url) { //   ,  ,      Error //,          ,   ,   -   ... console.log("      : ", url); });</span></span></code> </pre><br><h3>  Sequential recursive loading and display of images </h3><br>  Let's write a function for sequential display of images: <br><br><div class="spoiler">  <b class="spoiler_title">function displayImages (images)</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       * * @param images -   url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayImages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">images</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgSrc = images.shift(); <span class="hljs-comment"><span class="hljs-comment">//      if (!imgSrc) return; //        //     ,   return loadImage(imgSrc) .then(function(url) { $('#images').append('&lt;img src="'+url+'" style="width: 200px;"/&gt;'); return displayImages(images); // }) .catch(function(url) { // -    ,     console.log('      : ', url); return displayImages(images); // }); }</span></span></code> </pre><br></div></div><br>  The displayImages (images) function sequentially traverses the array with the url of the images.  In case of a successful upload, we add an image to the page and proceed to the next url in the list.  In the opposite case - just go to the next url in the list. <br><br>  Perhaps this image display behavior is not exactly what is needed in this case.  If you want to show the entire image only after they have been loaded, you need to implement the work with an array of "promises". <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseImgs = []; promiseImgs = imgList.map(loadImage); <span class="hljs-comment"><span class="hljs-comment">//  promiseImgs = imgList.map(function(url){ return loadImage(url); });</span></span></code> </pre><br>  The promiseImgs array now contains ‚Äúpromises‚Äù, in which the state can be either ‚Äúallowed‚Äù or ‚Äúrejected‚Äù, since the image fake.jpg does not physically exist. <br><br>  To complete the task, one could use the Promise.all (...) method. <br>  Promise.all (iterable) returns a promise that will be fulfilled after all promises are fulfilled in the passed iterated argument. <br><br>  However, we have an image in the list that does not physically exist.  Therefore, the Promise.all method cannot be used: we need to check the state of the object ‚Äúpromise‚Äù (resolved | rejected). <br><br>  If there is at least one in the array of ‚Äúpromises‚Äù that is ‚Äúrejected‚Äù, then the Promise.all method will also return a ‚Äúpromise‚Äù with this state, without waiting for the passage through the entire array. <br><br>  Therefore we will write the loadAndDisplayImages function. <br><br><h3>  We load images, and show them on the page all at once </h3><br><div class="spoiler">  <b class="spoiler_title">function loadAndDisplayImages</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * * @param imgList -  url * @returns {Promise} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAndDisplayImages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">imgList</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notLoaded = [];<span class="hljs-comment"><span class="hljs-comment">// url,     var loaded = [];// url,    var promiseImgs = imgList.map(loadImage); //    reduce(...) -  Promise,         : //loadAndDisplayImages(...).then(...).catch(...); return promiseImgs.reduce(function (previousPromise, currentPromise) { return previousPromise .then(function() { //   ,   previousPromise -   resolved (= Promise.resolve()) return currentPromise; }) .then(function(url) // ""   resolved { $('#images').append('&lt;img src="'+url+'" style="width: 200px;"/&gt;'); loaded.push(url); return Promise.resolve(url); }) .catch(function(url)// ""   rejected { console.log('      : ', url); notLoaded.push(url); return Promise.resolve(url); }); }, Promise.resolve()) .then(function (lastUrl) { console.log('lastUrl:', lastUrl); let res = {loaded: loaded, notLoaded: notLoaded}; //   Promise,     return Promise.resolve(res); }); } loadAndDisplayImages(imgList) .then(function(loadRes) { console.log(loadRes); }) .catch(function(err) { console.log(err); });</span></span></code> </pre><br></div></div><br>  You can view network activity in the browser and make sure of parallel operation (for clarity, Chrome has Wi-Fi connection emulation enabled (2ms, 30Mb / s, 15M / s): <br><br><img src="https://habrastorage.org/files/ebb/537/41a/ebb53741a39b41459b1487a328edddf9.png"><br><br>  Having figured out how to work with Promise, it will be easier for you to understand the principles of operation, for example, with the Yandex.Maps API, or the <a href="https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers">Service Worker</a> - this is where they are used. <br><br>  <b>UPD:</b> The article did not mention one important point, which, in part, was related to the advice to write return resolve () or return reject (). <br><br>  When these methods are called, the ‚Äúpromise‚Äù is set to its final state ‚Äúfulfilled‚Äù or ‚Äúrejected‚Äù, respectively.  After this state can not be changed.  Examples can be found in the <a href="https://habrahabr.ru/company/zerotech/blog/317256/">comments</a> . </div><p>Source: <a href="https://habr.com/ru/post/317256/">https://habr.com/ru/post/317256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317246/index.html">Prediction of the severity of insurance claims for Allstate. Graduation project of our graduate</a></li>
<li><a href="../317248/index.html">Unchangeable JavaScript: how it is done with ES6 and higher</a></li>
<li><a href="../317250/index.html">How to increase the Open Rate by 50%: tips and case from SendPulse</a></li>
<li><a href="../317252/index.html">Development for Sailfish OS: Work with LocalStorage</a></li>
<li><a href="../317254/index.html">Overview of the Instana application monitoring system</a></li>
<li><a href="../317258/index.html">Blocking duplicate symfony —Åommand</a></li>
<li><a href="../317262/index.html">DIY Genetic Algorithm</a></li>
<li><a href="../317264/index.html">HighLoad ++ 2016: how it was</a></li>
<li><a href="../317268/index.html">Russian AI Cup. Intermediate results of the championship</a></li>
<li><a href="../317270/index.html">Elusive bugs: errors that have escaped all tests and checks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>