<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Descriptor guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Short review 
 In this article I will talk about descriptors, descriptors protocol, and show how descriptors are called. I will describe the creation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Descriptor guide</h1><div class="post__text post__text-html js-mediator-article"><h4>  Short review </h4><br>  In this article I will talk about descriptors, descriptors protocol, and show how descriptors are called.  I will describe the creation of my own and explore several built-in descriptors, including functions, properties, static methods and class methods.  Using a simple application, I will show you how each of them works, and give equivalents to the internal implementation of the operation of descriptors by code on pure python. <br><br>  Learning how the descriptors work will open up access to more working tools, help you better understand how the python works, and feel the elegance of its design. <br><br><a name="habracut"></a><br><h4>  Introduction and Definitions </h4><br>  Generally speaking, a descriptor is an attribute of an object with bound behavior (i.e. binding behavior), i.e.  one whose access behavior is overridden by descriptor protocol methods.  These methods are: <code>__get__</code> , <code>__set__</code> and <code>__delete__</code> .  If at least one of these methods is defined for an object, then it becomes a handle. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The standard behavior when accessing attributes is getting, setting and deleting an attribute from the object dictionary.  For example, <code>ax</code> has the following attribute search chain: <code>a.__dict__['x']</code> , then in <code>type(a).__dict__['x']</code> , and further along the base classes <code>type(a)</code> not including metaclasses.  If the desired value is an object in which there is at least one of the methods that define the descriptor, then the python can change the standard search chain and call one of the descriptor methods.  How and when this happens depends on which descriptor methods are defined for the object.  Descriptors are called only for objects or classes of a new style (a class is such if it inherits from <code>object</code> or <code>type</code> ). <br><br>  Descriptors are a powerful protocol with a wide range of applications.  They are the mechanism behind the properties, methods, static methods, class methods, and the call to <code>super()</code> .  Inside the python itself, with their help, classes of a new style are implemented, which were introduced in version 2.2.  Descriptors simplify understanding of the underlying C code, and also provide a flexible set of new tools for any programs on python. <br><br><h4>  Handle Protocol </h4><br><pre> <code class="python hljs">descr.__get__(self, obj, type=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) --&gt;  descr.__set__(self, obj, value) --&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> descr.__delete__(self, obj) --&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br>  Actually that's all.  Define any of these methods and the object will be treated as a descriptor, and will be able to override the standard behavior if it is searched for as an attribute. <br><br>  If the object immediately identifies both <code>__get__</code> and <code>__set__</code> , then it is considered a data descriptor (data descriptor).  Descriptors that define only <code>__get__</code> are called no-data descriptors.  They are called so because they are used for methods, but other ways of using them are also possible. <br><br>  Data descriptors and not data differ in how the search behavior will be changed if there is already an entry in the object dictionary with the same name as the descriptor.  If a data descriptor is encountered, it is called before the entry from the object dictionary.  If the data descriptor is in the same situation, the entry from the object dictionary takes precedence over this descriptor. <br><br>  To create a read-only data descriptor, define both <code>__get__</code> and <code>__set__</code> , and have <code>__set__</code> throw an <code>AttributeError</code> exception.  Defining the <code>__set__</code> method and throwing an exception is enough for this descriptor to be considered a data descriptor. <br><br><h4>  Calling Handles </h4><br>  The handle can be called directly through its method.  For example, <code>d.__get__(obj)</code> . <br><br>  However, the most frequent variant of invoking a descriptor is an automatic invocation during access to an attribute.  For example, <code>obj.d</code> searches for <code>d</code> in the dictionary <code>obj</code> .  If <code>d</code> specifies the <code>__get__</code> method, then <code>d.__get__(obj)</code> will be called.  The call will be made according to the rules described below. <br><br>  Call details differ from what an <code>obj</code> object or class is.  In any case, descriptors work only for objects and classes of the new style.  A class is a new style class if it is a descendant of <code>object</code> . <br><br>  For objects, the algorithm is implemented using <code>object.__getattribute__</code> , which converts the <code>bx</code> record to <code>type(b).__dict__['x'].__get__(b, type(b))</code> .  The implementation works through the predecessor chain, in which data descriptors take precedence over object variables, object variables take precedence over non-data descriptors, and the <code>__getattr__</code> method has the lowest priority, if defined.  The full C implementation can be found in <code>PyObject_GenericGetAttr()</code> in the <code>Objects/object.c</code> . <br><br>  For classes, the algorithm is implemented using <code>type.__getattribute__</code> , which converts the <code>Bx</code> record to <code>B.__dict__['x'].__get__(None, B)</code> .  On pure python, it looks like this: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getattribute__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">" type_getattro()  Objects/typeobject.c"</span></span> v = object.__getattribute__(self, key) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasattr(v, <span class="hljs-string"><span class="hljs-string">'__get__'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.__get__(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, self) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v</code> </pre><br>  Important parts to remember: <ul><li>  descriptors are called using the <code>__getattribute__</code> method </li><li>  overriding <code>__getattribute__</code> stop automatically <code>__getattribute__</code> handles </li><li>  <code>__getattribute__</code> is available only inside classes and objects of a new style. </li><li>  <code>object.__getattribute__</code> and <code>type.__getattribute__</code> make different calls to <code>__get__</code> </li><li>  data descriptors always take precedence over object variables </li><li>  no data descriptors may lose their advantage due to object variables </li></ul><br>  The object that is returned after calling <code>super()</code> also has its own implementation of the <code>__getattribute__</code> method, with which it calls the descriptors.  The call <code>super(B, obj).m()</code> searches in <code>obj.__class__.__mro__</code> base class <code>A</code> , followed immediately by <code>B</code> , and returns <code>A.__dict__['m'].__get__(obj, A)</code> .  If it is not a descriptor, then <code>m</code> returned unchanged.  If <code>m</code> not in the dictionary, then we return to the search through <code>object.__getattribute__</code> . <br><br>  Note: in python 2.2, <code>super(B, obj).m()</code> called <code>__get__</code> only if <code>m</code> was a data descriptor.  In Python 2.3, no data descriptors are also called, except when using old-style classes.  Implementation details can be found in <code>super_getattro()</code> in the <code>Objects/typeobject.c</code> , and the equivalent on pure python can be found in <a href="http://www.python.org/2.2.3/descrintro.html">the Guido manual</a> . <br><br>  The details above describe that the callback algorithm is implemented using the <code>__getattribute__()</code> method for <code>object</code> , <code>type</code> and <code>super</code> .  Classes inherit this algorithm when they inherit from <code>object</code> or if they have a metaclass that implements this functionality.  Thus, classes can disable the invocation of descriptors if they override <code>__getattribute__()</code> . <br><br><h4>  Descriptor example </h4><br>  The following code creates a class whose objects are data descriptors and all they do is type a message for each <code>get</code> or <code>set</code> call.  Overriding <code>__getattribute__</code> is an alternative approach with which we could do this for each attribute.  But if we want to monitor only individual attributes, then this is easier to do with a descriptor. <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RevealAccess</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ,     ,     ,     . """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, initval=None, name=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'var'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.val = initval self.name = name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, objtype)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>, self.name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> , self.name self.val = val &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> x = RevealAccess(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'var "x"'</span></span>) y = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; m = MyClass() &gt;&gt;&gt; mx  var <span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; mx = <span class="hljs-number"><span class="hljs-number">20</span></span>  var <span class="hljs-string"><span class="hljs-string">"x"</span></span> &gt;&gt;&gt; mx  var <span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; my <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  This simple protocol provides simply fascinating features.  Some of them are so often used that they were combined into separate functions.  Properties, related and unrelated methods, static methods and class methods are all based on this protocol. <br><br><h4>  Properties </h4><br>  Calling <code>property()</code> enough to create a data descriptor that calls the functions you need during attribute access.  Here is its signature: <br><pre> <code class="python hljs">property(fget=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, fset=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, fdel=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, doc=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) --&gt; ,  </code> </pre><br>  The documentation shows a typical use of <code>property()</code> to create a managed attribute <code>x</code> : <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self.__x = value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> self.__x x = property(getx, setx, delx, <span class="hljs-string"><span class="hljs-string">"  'x'."</span></span>)</code> </pre><br>  Here is the equivalent of <code>property</code> on pure python, so that it is clear how <code>property()</code> implemented using the descriptor protocol: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Property</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">" PyProperty_Type()  Objects/descrobject.c"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, fget=None, fset=None, fdel=None, doc=None)</span></span></span><span class="hljs-function">:</span></span> self.fget = fget self.fset = fset self.fdel = fdel self.__doc__ = doc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, objtype=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.fget <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> AttributeError, <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.fget(obj) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.fset <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> AttributeError, <span class="hljs-string"><span class="hljs-string">"   "</span></span> self.fset(obj, value) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__delete__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.fdel <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> AttributeError, <span class="hljs-string"><span class="hljs-string">"   "</span></span> self.fdel(obj)</code> </pre><br>  The built-in <code>property()</code> implementation can help when an attribute access interface existed and some changes occurred that resulted in the intervention of the method. <br><br>  For example, a spreadsheet class can give access to a cell's value via <code>Cell('b10').value</code> .  As a result of subsequent changes in the program, it was necessary to ensure that this value is recalculated with each access to the cell, but the programmer does not want to change the client code that accesses the attribute directly.  This problem can be solved by wrapping the <code>value</code> attribute with a data descriptor that will be created with <code>property()</code> : <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"     "</span></span> self.recalc() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj._value value = property(getvalue)</code> </pre><br><h4>  Functions and methods </h4><br>  In python, all object-oriented features are implemented using a functional approach.  This is done completely unnoticed using no data descriptors. <br><br>  Class dictionaries store methods as functions.  When defining a class, the methods are written using <code>def</code> and <code>lambda</code> - standard tools for creating functions.  The only difference between these functions and ordinary ones is that the first argument is reserved for an object instance.  This argument is usually called <code>self</code> , but it can be called <code>this</code> or any other word that can be called variables. <br><br>  In order to support <code>__get__</code> methods, the functions include the <code>__get__</code> method, which automatically makes them descriptors of no data when searching for attributes.  Functions return related or unrelated methods, depending on what this descriptor was called through. <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, objtype=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">" func_descr_get()  Objects/funcobject.c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> types.MethodType(self, obj, objtype)</code> </pre><br>  Using the interpreter, we can see how the function handle actually works: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &gt;&gt;&gt; d = D() &gt;&gt;&gt; D.__dict__[<span class="hljs-string"><span class="hljs-string">'f'</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     &lt;function f at 0x00C45070&gt; &gt;&gt;&gt; Df #       &lt;unbound method Df&gt; &gt;&gt;&gt; df #        &lt;bound method Df of &lt;__main__.D object at 0x00B18C90&gt;&gt;</span></span></code> </pre><br>  The interpreter's output tells us that related and unrelated methods are two different types.  Even if they could be implemented in this way, in fact, the <code>PyMethod_Type</code> implementation in the <code>Objects/classobject.c</code> contains a single object with two different mappings that depend only on whether there is a value in the <code>im_self</code> field or whether it contains <code>NULL</code> (C equivalent <code>None</code> values). <br><br>  Thus, the effect of calling a method depends on the <code>im_self</code> field.  If it is set (i.e., the method is bound), then the original function (stored in the <code>im_func</code> field) is called, as expected, with the first argument set to the value of the object instance.  If it is not connected, then all arguments are passed without changing the original function.  The real C implementation of the <code>instancemethod_call()</code> bit more complicated because it involves some type checks and the like. <br><br><h4>  Static methods and class methods </h4><br>  No data descriptors provide a simple mechanism for various options to bind functions to methods. <br><br>  Repeat again.  Functions have a <code>__get__</code> method, with which they become methods, during the search for attributes and automatic calling of handles.  No data <code>obj.f(*args)</code> convert the <code>obj.f(*args)</code> call <code>obj.f(*args)</code> to the <code>f(obj, *args)</code> call, and the <code>klass.f(*args)</code> call becomes the <code>f(*args)</code> call. <br><br>  This table shows the binding and the two most popular options: <br><table><tbody><tr><th colspan="2">  Transformation </th><th>  Called through object </th><th>  Called through class </th></tr></tbody><tbody><tr><td rowspan="3">  Descriptor </td><td>  function </td><td>  f (obj, * args) </td><td>  f (* args) </td></tr><tr><td>  staticmethod </td><td>  f (* args) </td><td>  f (* args) </td></tr><tr><td>  classmethod </td><td>  f (type (obj), * args) </td><td>  f (klass, * args) </td></tr></tbody></table><br>  Static methods return function without changes.  Calls to <code>cf</code> or <code>Cf</code> equivalent to calls to <code>object.__getattribute__(c, "f")</code> or <code>object.__getattribute__(C, "f")</code> .  As a result, the function is equally accessible from both the object and the class. <br><br>  Good candidates for static methods are methods that do not need a reference to the <code>self</code> variable. <br><br>  For example, a package for statistics may include a class for experimental data.  The class provides the usual methods for calculating the mean, expectation, median, and other statistics that depend on the data.  However, there may be other functions that are conceptually related, but do not depend on data.  For example, <code>erf(x)</code> is a simple conversion function that is needed in statistics, but does not depend on the specific data set in this class.  It can be called both from an object and from a class: <code>s.erf(1.5) --&gt; 0.9332</code> or <code>Sample.erf(1.5) --&gt; 0.9332</code> . <br><br>  Since <code>staticmethod()</code> returns a function unchanged, this example is not surprising: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x f = staticmethod(f) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ef(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> E().f(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  If you use the data descriptor protocol, then on a pure python <code>staticmethod()</code> would look like this: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticMethod</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">" PyStaticMethod_Type()  Objects/funcobject.c"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, f)</span></span></span><span class="hljs-function">:</span></span> self.f = f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, objtype=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.f</code> </pre><br>  In contrast to static methods, class methods substitute a reference to a class at the beginning of a function call.  The format of the call is always the same, and it does not depend on whether we call the method through an object or through a class. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(klass, x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> klass.__name__, x f = classmethod(f) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ef(<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> E().f(<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  This behavior is convenient when our function always needs a reference to a class and does not need data.  One way to use <code>classmethod()</code> is to create alternative class constructors.  In Python 2.3, the class method <code>dict.fromkeys()</code> creates a new dictionary from the list of keys.  The equivalent on pure python will be: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dict</span></span></span><span class="hljs-class">:</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromkeys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(klass, iterable, value=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">" dict_fromkeys()  Objects/dictobject.c"</span></span> d = klass() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable: d[key] = value <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d fromkeys = classmethod(fromkeys)</code> </pre><br>  Now a new dictionary of unique keys can be created in the following way: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Dict.fromkeys(<span class="hljs-string"><span class="hljs-string">'abracadabra'</span></span>) {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>}</code> </pre><br>  If you use the data descriptor protocol, then on a pure python the <code>classmethod()</code> would look like this: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassMethod</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">" PyClassMethod_Type()  Objects/funcobject.c"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, f)</span></span></span><span class="hljs-function">:</span></span> self.f = f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, klass=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> klass <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: klass = type(obj) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newfunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.f(klass, *args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newfunc</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/122082/">https://habr.com/ru/post/122082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122072/index.html">Canobuvosti, 96th edition</a></li>
<li><a href="../122075/index.html">Open letter to Silverlight / WPF developers to Microsoft</a></li>
<li><a href="../122077/index.html">We assort on screws: iOs and Android, AppStore and Android Market</a></li>
<li><a href="../122080/index.html">Work with commercial IT tenders</a></li>
<li><a href="../122081/index.html">Rebus captcha</a></li>
<li><a href="../122086/index.html">Podcasts and presentations by Steve Blenk (Steven Blank)</a></li>
<li><a href="../122087/index.html">nanoCAD 3.0: some statistics for the first day</a></li>
<li><a href="../122088/index.html">Make the interface easier</a></li>
<li><a href="../122089/index.html">By adding one thing you always take something else away.</a></li>
<li><a href="../122090/index.html">15th issue of PROGRAMIST</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>