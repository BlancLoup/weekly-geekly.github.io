<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search tips from the inside</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Night hall. Thousands of mysterious faces in the dark, illuminated by the bluish glow of monitors. The deafening crackle of a million keys. Similar to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search tips from the inside</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/76d/66e/863/76d66e863e8c4b619f080c63d37604f5.png"></div><br><br>  Night hall.  Thousands of mysterious faces in the dark, illuminated by the bluish glow of monitors.  The deafening crackle of a million keys.  Similar to shots of a machine gun, hitting the ‚ÄúEnter‚Äù keys.  The ominous chirping of hundreds of thousands of mice ... So, for certain, the imagination of every developer of a highly loaded system played.  And if it is not stopped in time, then a whole thriller or horror movie can come out.  But in this article we will be much closer to the ground.  We briefly consider the well-known approaches to solving the problem of search hints, how we learned to make them full-text, and also tell about a couple of tricks that we went to give them speed, but it does not teach greed for resources.  At the end of the article you will find a bonus - a small working example. <br><a name="habracut"></a><br><h1>  What should be "under the hood"? </h1><br><ol><li>  Search by prompts should be <i>full-text</i> , that is, should be able to search through the texts of prompts all the words from the user query in any sequence.  For example, if the user entered the query <b>‚Äúview‚Äù</b> , and in the database we have the following prompts: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/731/715/c43/731715c434064d6e8d9b3f469c834159.png"></div><br>  then the user should see all three, despite the fact that the word "look" is in different places of these prompts. </li><li>  A user request may be incomplete while typing it on the keyboard.  Therefore, you need to search not by words, but by their prefixes.  For the previous example, we should see all three hints not only for the whole word ‚Äúlook‚Äù, but also for any of its prefix parts.  For example, " <b>review</b> ". </li><li>  Mail.Ru search is a general purpose search engine, which means that the variety of possible queries is large, and the system should be able to search among tens of millions of clues. </li><li>  The speed of the reaction is extremely important, so we want to give an answer in milliseconds. </li><li>  Finally, the service should be a reliable system operating in 24/7/365 mode.  From all over Russia and the CIS countries, our prompts every second process thousands of requests.  For fault tolerance, and, therefore, for the sake of ease of implementation and debugging, it is highly desirable for us to have some kind of idea at the heart of the service that would be extremely simple and elegant. </li></ol><br><h1>  Known approaches </h1><br>  <b>1. Prefix autocompletion</b> <br><br>  a.  Tips with weights (weight == popularity) are sorted in lexicographical order by hint texts. <br>  b.  When a user enters a query (prefix), a binary search is a subset of prompts, the beginning of which satisfies this prefix. <br>  c.  The found subset is sorted by descending weight, and the TOP of the ‚Äúheaviest‚Äù prompts is given to the user as a result. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/866/25a/b8b/86625ab8b6ea4a9db3ca25d9df661f0e.png"></div><br><br>  The obvious optimization of this approach is <a href="http://en.wikipedia.org/wiki/Radix_tree">Patricia Tree</a> with weights in the nodes of the tree.  When selecting the most "heavy" queries, as a rule, a <a href="https://en.wikipedia.org/wiki/Binary_heap">queue with priorities is used</a> , or a <a href="http://en.wikipedia.org/wiki/Segment_tree">segment tree</a> , which gives a logarithmic search time.  If you wish, you can spend the server memory using the <a href="http://cglab.ca/~morin/teaching/5408/refs/bf-c00.pdf">LCA</a> algorithm <a href="http://cglab.ca/~morin/teaching/5408/refs/bf-c00.pdf">via RMQ</a> , and then we get <a href="http://dhruvbird.com/autocomplete.pdf">very fast prefix prompts</a> .  There are three advantages to this approach: speed, compactness and ease of implementation.  However, the obvious and most unpleasant drawback is the impossibility to look for word swaps in the text of hints.  In other words, such hints will only be prefix, not full-text. <br><br>  <b>2. Full-text autocompletion</b> <br><br>  a.  The texts of the prompts and the user's request are considered as a sequence of words. <br>  b.  When a user enters a query, a subset of prompts is searched in the database, which contain all the user's words (or rather, prefixes), regardless of their position in the prompt. <br>  c.  The found subset is sorted by descending words matching the hint to the words of the query, then descending by weight, and the user gets the TOP ‚Äúheaviest‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/70d/011/f2a/70d011f2ab774372a9795d635eeeb102.png"></div><br><br>  Actually, this is the full-text approach, which will be discussed later.  An extensive number of publications by domestic and foreign authors are available on this topic on the Internet.  For example: <br><ul><li>  <a href="http://habrahabr.ru/post/123320/">The implementation of a fuzzy search</a> - the author has implemented search hints for the names of bars, restaurants and other institutions, combined with the correction of typos.  Since there were only ~ 2.5 thousand prompts, it turned out to be enough to search through all the prompts using the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Wagner-Fisher</a> algorithm, which was modified to search for word prefixes.  The method is qualitative, but does not suit us due to low speed. </li><li>  <a href="http://dbgroup.cs.tsinghua.edu.cn/ligl/papers/sigmod09-tastier-db.pdf">TASTIER approach</a> is a live-search for articles that finds not only an exact match, but also related publications.  It stores the user's context in RAM in order to adapt it as a user request is entered, which is quite expensive in memory and detrimental to speed. </li><li>  <a href="http://sphinxsearch.com/blog/2013/05/21/simple-autocomplete-and-correction-suggestion/">Sphinx Simple autocomplete and correction suggestions</a> - autocompletion based on the well-known open search engine Sphinx.  The main idea of ‚Äã‚Äãautocompletion is to use wildcard in the MySQL query language: ‚Äú <b>the wor *</b> ‚Äù.  The correction of typos is based on the <a href="http://polibits.gelbukh.com/2009_40/40_06.pdf">n-gram approach</a> .  Of course, such a search is not exactly what we need: after all, the user does not necessarily type the last word;  and as practice shows, the user can enter the words of the query as you like, in any sequence.  In addition, the n-gram approach will require a lot of resources to apply it in real-time prompts. </li></ul><br>  The above and other approaches not considered here did not satisfy us in combination: economy + speed + simplicity.  Therefore, we have developed our own algorithm that meets our needs. <br><br><h1>  Formal statement of the problem </h1><br>  Before describing the algorithm, we formulate our problem more formally.  So, given: <br><ul><li>  The set of hint texts is S = {s <sub>1</sub> , s <sub>2</sub> , ..., s <sub>N</sub> }, each of which consists of the words W (s <sub>i</sub> ) = {w <sub>i1</sub> , w <sub>i2</sub> , ..., w <sub>iK</sub> }.  We get the text of hints from the logs of the queries that users specify to our search engine. </li><li>  The set of the popularity scales of the prompts F = {f <sub>1</sub> , f <sub>2</sub> , ..., f <sub>N</sub> }.  Here, by popularity, we mean the frequency of use of a particular query, that is, how often users search for something in our search engine for a given query. </li><li>  Incomplete user request consisting of an ordered sequence of prefixes Q = {p <sub>1</sub> , p <sub>2</sub> , ..., p <sub>M</sub> }.  As we said above, we view the user's request as a sequence of prefixes, since the request may be incomplete. </li></ul><br>  Required: <br><ul><li>  Find the set R of all prompts s <sub>i</sub> from S, such that each prefix p <sub>j</sub> from Q corresponds to one unique word w <sub>k</sub> from W (s <sub>i</sub> ). </li><li>  Sort the found set of tips R by two criteria: <br><ul><li>  by descending order correspondence of words w <sub>k</sub> from W (s <sub>i</sub> ) to the order of prefixes p <sub>i</sub> from user request Q; </li><li>  descending weight popularity f <sub>l</sub> from F tips s <sub>i</sub> from R. </li></ul><br></li></ul><br><h1>  Index </h1><br>  Since we need full-text search through prompts, then our index is based on a classic approach to the implementation of a general-purpose full-text search, on which any modern web search engine is based.  In general, full-text search is conducted among so-called documents, that is, texts within which we want to search for words from a user's request.  The essence of the algorithm is reduced to two simple data structures, direct and inverse indices: <br><ul><li>  <b>direct index</b> - a list of documents in which you can find this document by its id.  In other words, a direct index is an array of strings (a vector of documents), where the id of the document is its index. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a66/bf8/8cf/a66bf88cfccd475fb65f578f73970217.png"></div><br></li><li>  <b>reverse index</b> - a list of words that we "blew out" of all documents.  Each word is assigned a list of sorted id documents (posting list) in which this word is found. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/ce3/74c/189/ce374c1892464f479f8ec18ae558ce14.png"></div></li></ul><br><br>  For these two data structures, it is easy enough to find all the documents that satisfy the user query.  For this you need: <br><ol><li>  In the reverse index: according to the words from the query, find the id lists of those documents where these words were encountered.  Get the intersection of these lists - the resulting list of id documents, where all the words from the query are found. </li><li>  In the direct index: using the obtained id, find the source documents and ‚Äúgive‚Äù them to the user. </li></ol><br>  This is quite enough for this article, so for details about the search, we refer you to Stanford University‚Äôs book <a href="http://nlp.stanford.edu/IR-book/pdf/irbookprint.pdf">An Introduction to Information Retrieval</a> . <br><br>  The classic algorithm is simple and good, but in its pure form it is not applicable to prompts, because the words in the query are generally ‚Äúunfinished‚Äù.  Or, as we said above, a query does not consist of words, but rather of prefixes.  To solve this problem, we finalized the reverse index, and this is what we did: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e2c/d78/7dd/e2cd787ddc5d480f92edf0a70e3a2909.png"></div><br><br>  <i><u>Note</u> : in the picture hereinafter for brevity, some nodes of the tree are ‚Äúmerged‚Äù into one transition of several characters.</i> <br><br>  Let's sort the index by example: <br><ol><li>  Suppose that we have the above index, and the user has already entered part of the request.  The next letter entered on the keyboard, and now we received an incomplete query ‚Äú <b>omnia v</b> ‚Äù. </li><li>  We split the query into prefix words: we get ‚Äú <b>omnia</b> ‚Äù and ‚Äú <b>v</b> ‚Äù. </li><li>  By analogy with the search engine, first, using predefined prefix words, we find lists of id prompts in the reverse index.  Note that our reverse index consists of two parts: <br>  a.  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">a prefix tree</a> (it is also ‚Äútrie‚Äù, it is also ‚Äúbor‚Äù), containing words that we ‚Äúgutted‚Äù from the hint texts; <br>  b.  tips id lists - indexes of the text of hints in the direct index, which will be discussed below.  Lists are sorted in ascending id values ‚Äã‚Äãand are located in those vertices where words end. <br>  I must say that trie is good for us for two reasons: <br><ul><li>  it can be used to find any word prefix in <i>O (log (n)) time</i> , where <i>n</i> is the prefix length; </li><li>  for a given prefix, it is easy to determine all variants of its continuations. </li></ul><br>  So, for each prefix we go deep down the tree and find ourselves in intermediate nodes.  Now you need to get the <i>correct</i> lists of tips ids. </li><li>  We unite lists of all child nodes.  For what?  By analogy with the usual search engine, we should cross the lists of id for each prefix, however there are two ‚ÄúBUT‚Äù: <br>  a.  first, not every node contains a list of id prompts, but only those nodes in which the <i>whole</i> word is being pumped; <br>  b.  and secondly, each tree node has some continuation, with the exception of leaf nodes.  This means that the continuations of one prefix can be a whole set, and these continuations must be taken into account. <br>  Therefore, before you find a suppression, you need to "sum up" the lists of id prompts for each individual prefix.  Thus, for each prefix we go around the tree recursively into depth, starting from the node where we stopped in the tree using the given prefix, and we construct the union of all the lists of its children by the merge algorithm.  In the figure, the nodes where we stopped by the prefix are marked with a red circle, and the <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2">merge operation is</a> marked with a ‚Äú <b>U</b> ‚Äù. </li><li> Now we intersect the synthetic lists-associations of each of the prefixes.  It must be said that the various intersection algorithms of sorted lists are simply a sea, and each one is more suitable for different types of sequences.  One of the most effective is the <a href="https://cs.uwaterloo.ca/~ajsaling/papers/paper-spire.pdf">algorithm of Ricardo Baeza-Yates and Alejandro Salinger</a> .  In the combat prompts, we use our own algorithm, which is most suitable for solving a specific problem, but the algorithm of Baeza-Yates-Salinger was inspiring for us at one time. </li><li>  Now, by the id found, we are looking for hint texts.  The direct index in our case is no different from the direct index of any search engine, that is, it is a simple array (vector) of strings.  In addition to the text of hints here can be any additional information.  In particular, here we store the weight of popularity. </li></ol><br>  So, by the end of the sixth stage, we already have all the prompts that contain all the prefixes from the user request.  Obviously, in fact, the number of hints we get to this stage can be very many - thousands or even hundreds of thousands, and we only need the best to ‚Äúprompt‚Äù the user.  This problem is solved by another algorithm - the ranking algorithm. <br><br>  Next, we will look at one small trick that will allow us to ‚Äúhalf‚Äù otranzhdiruya tips, doing absolutely nothing.  And we'll talk about it below, in the course of the consideration of two problems. <br><br><h1>  Speeding up </h1><br>  ‚ÄúPremature optimization is the root of all evil‚Äù - repeats popular programmer wisdom formulated by Donald Knut.  But if we implement the above algorithm in its pure form, then we grab two performance problems.  Therefore, for us, the absence of a struggle for speed will be that evil. <br><br>  <i>The first problem is the slow merging of lists</i> .  Consider this problem in more detail: <br><ol><li>  Suppose, in our tree (traa), there are already 1000 words beginning with the letter ‚Äú <b>a</b> ‚Äù (in a real situation there are even more such words). <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a3e/771/e7b/a3e771e7bbcf414ba833d88e04392f86.png"></div></li><li>  It is obvious that for 1000 words the minimum average number of id prompts will also be about 1000. That is, there will be at least 1000 prompts on average, in which there are words beginning with the letter ‚Äúa‚Äù. </li><li>  Now imagine that the user decided to search for something with this letter " <b>a</b> ".  According to our algorithm, for the prefix ‚Äúa‚Äù, the operation of combining lists for all child nodes that lie below node ‚Äúa‚Äù begins.  Obviously, this operation will require decent resources: firstly, to allocate memory for a new list, and secondly, to copy id into this new list. </li></ol><br>  Combining can be optimized using two techniques: <br><ul><li>  reserve memory for the final list, so as not to allocate it with each new request; </li><li>  to unite in a "lazy" way, that is, as necessary. </li></ul><br>  However, our experiments have shown that any tricks with the union can not be compared with optimization due to caching.  Yes, yes, we simply began to add id prompts to each node of the tree, and not just to leafy vertices.  Total: there is no need to combine - ready lists for each possible prefix are right in the nodes of the tree.  And our reverse index has acquired the following form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4a1/5d6/46e/4a15d646eb9a44efa63dc5e724897907.png"></div><br><br>  But stand still!  In each node of the tree to put the id of the tooltip ?!  It looks extremely wasteful, is not it?  But is it wasteful?  We reason: <br><ul><li>  For each new hint, we will have to add its id as many times as there are characters in its text.  This is in the worst case, since there is no need to add id spaces, and for duplicate words (‚ÄúWinnie the Pooh and everything <s>is all</s> ‚Äù), it is not necessary to add an id again. </li><li>  For example, with an average prompt length of 25 characters, 1 million search hints contain 25 million characters.  And if the id of the hint is a 4-byte integer (standard int), then in the worst case, all the lists of the id of the hints in the reverse index will be in memory: <b>4 bytes * 25,000,000 = 100 MB</b> .  And such a volume, obviously, is not so wasteful, even for an ordinary person.  In proportion, for 50 million prompts, the index will take 5 GB, which is quite appropriate for a full-scale search engine service. </li></ul><br>  So, we solved the problem of combining lists by caching all lists for each possible prefix. <br><br>  <i>The second problem is the slow intersection of lists and the ranking (sorting) of weight tips</i> .  According to our algorithm, two important steps follow after merging, and each has performance problems: <br><ol><li>  Intersection of merged lists.  In a large database, real lists are too long, especially for short prefixes.  Therefore, the intersection of lists for short queries, like ‚Äú <b>a b</b> ‚Äù, will be too long. </li><li>  Ranking tips, above all, by decreasing weight.  The final list after the intersection can also be quite large, so sorting thousands of id, as for the query " <b>a b</b> ", also turns out to be expensive. </li></ol><br>  Remembering that for the result we need only 7-10 "very good" tips, we found a very simple solution, which consists of two points: <br><ol><li>  The correct order is id prompts.  We make lists of id in such a way that the hint with the greatest weight has the smallest id.  In other words, hints need to be added to the index in descending order of their weight.  Thus, the resulting list after the intersection will be sorted at the same time in descending order of weight and id value.  We call this approach ‚Äú <i>pre-ranking</i> ‚Äù. </li><li>  We do not need a complete intersection.  It was established experimentally: when crossing, you can take not everything, but it is enough to take the first K prompts (where K&gt; N and in proportion to the target number of prompts N), and among them there are already those from which you can choose something suitable as by weight, and in word order.  For example, if we need TOP N = 10 of the most good prompts, then we only need to choose from the resulting intersection about the first K = 100. For this, at the intersection, we can count how many id in the resulting list, and as soon as we have typed the first 100, we stop intersection <br><div style="text-align:center;"><img src="https://habrastorage.org/files/bef/778/2b9/bef7782b983d45609a70c042ce96deaa.png"></div><br></li></ol><br>  Thus, we optimized both the weight ranking and the intersection to the ‚Äúlazy‚Äù K first clues. <br><br><h1>  Implementation </h1><br>  As promised in the beginning, we post a <a href="http://pastebin.com/3PvN6YmS">working C ++ example</a> that implements the algorithm described in the article.  As a source base, you can use any text file, where each line is a hint.  You can fill it, for example, with <a href="http://pastebin.com/raw.php%3Fi%3DnNYRkmeS">proverbs and winged expressions in Latin</a> ( <a href="http://www.graecolatini.narod.ru/r_stud_posl_1200.htm">primary source</a> ) in order to be able to quickly receive their translation into Russian and vice versa. <br><br><img src="https://habrastorage.org/files/ddb/7bf/215/ddb7bf215cd94f50a7f1aead08286e6d.jpg"><br><br>  We will not dwell on the features of the implementation, giving it to the reader: the good example is quite simple. <br><br><h1>  Instead of a conclusion: what is left "overboard" </h1><br>  Of course, the algorithm presented here is described in the most general form, and many questions were left out of the scope of the article.  What else it would be useful to think of the hint developer: <br><ul><li>  algorithm for ranking hints taking into account the positions of words; </li><li>  <b>Invert the</b> keyboard language layout: <b>‚Äúghbdtn‚Äù -&gt; ‚Äúhello‚Äù</b> ; </li><li>  correction of typos in a user request;  here we will send you to a good article from Microsoft developers: <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/sigmod513.pdf">S. Chaudhuri, R. Kaushik, Extending Autocompletion To Tolerate Errors</a> ; </li><li>  constructing the user's request ending for the case when we have nothing to tell from the base of the prepared hints: <b>‚Äúwhat sang in the mid-80s alla poo‚Äù -&gt; ‚Äúwhat sang in the mid-80s alla pugacheva‚Äù</b> ; </li><li>  taking into account the user's geography: <b>‚Äúcinema‚Äù -&gt;</b> for a user from Saratov you should not suggest Moscow and St. Petersburg cinemas, which are often sought because of the large audience of users; </li><li>  scaling the algorithm for 2, 3 or more servers when we want to add 100-200-500 million hints and focus on memory and processor resources; </li><li>  and so on and so forth, that only can be oriented to our favorite user and our needs. </li></ul><br>  That's all.  Thanks for attention. <br><br>  <i>Alex Medvezhek,</i> <i><br></i>  <i>Search Engine Tips</i> . </div><p>Source: <a href="https://habr.com/ru/post/267469/">https://habr.com/ru/post/267469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267457/index.html">Imitate, repeat, apply! English grammar at the count of three</a></li>
<li><a href="../267459/index.html">Hackathon at school InterSystems 2015</a></li>
<li><a href="../267461/index.html">Another algorithm for determining the intersection of two segments</a></li>
<li><a href="../267465/index.html">Exploit a million</a></li>
<li><a href="../267467/index.html">3 Attacks on TACACS + from Cisco</a></li>
<li><a href="../267471/index.html">gulpfile in 10 lines? Easy! - we simplify the creation of standard tasks</a></li>
<li><a href="../267473/index.html">Understand Open Source</a></li>
<li><a href="../267475/index.html">How to bypass the lock screen in iOS without knowing the password</a></li>
<li><a href="../267477/index.html">Create a REST service on PostgreSQL and Rust. Part 1: prototype</a></li>
<li><a href="../267483/index.html">(Archive) Matreshka.js 1.1: even more cool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>