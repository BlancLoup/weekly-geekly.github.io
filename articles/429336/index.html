<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Driver and device communication using the _HID method of ACPI using the example of a GPIO Lynxpoint controller</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Formulation of the problem 
 Linux has a standard interface for working with GPIO via sysfs. Documentation on it can be found here . 

 In short, the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Driver and device communication using the _HID method of ACPI using the example of a GPIO Lynxpoint controller</h1><div class="post__text post__text-html js-mediator-article"><h3>  Formulation of the problem </h3><br>  Linux has a standard interface for working with GPIO via sysfs.  Documentation on it can be found <a href="https://www.kernel.org/doc/Documentation/gpio/sysfs.txt">here</a> . <br><br>  In short, the "/ sys / class / gpio" folder contains the files "export" and "unexport".  By writing the number X to the export file, you can open the interface in the user space to control GPIOX <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    user space   GPIO12 $ echo 12 &gt; /sys/class/gpio/export</span></span></code> </pre> <br>  After opening the interface, the folder / sys / class / gpio / gpioX / will appear in which there will be such files as ‚Äúvalue‚Äù or ‚Äúdirection‚Äù, and by writing ‚Äúin‚Äù or ‚Äúout‚Äù to the file ‚Äúdirection‚Äù and writing 1 or 0 to the file "Value" can be controlled by the output of GPIO directly via the command line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GPIO   $ echo "out" &gt; /sys/class/gpio/gpio12/direction #  1   GPIO $ echo 1 &gt; /sys/class/gpio/gpio12/value</span></span></code> </pre> <br>  In order for the ‚Äúecho X&gt; / sys / class / gpio / export‚Äù command to create the ‚ÄúgpioX‚Äù folder, the GPIO controller driver must be registered in the kernel, opening the interface to the GPIO lines. <br><br>  It so happened that I'm working on porting a coreboot for a custom card based on the Intel Haswell i7 processor [For those who don't know, coreboot is an open source BIOS project with open source ( <a href="https://www.coreboot.org/">https://www.coreboot.org/</a> ) ].  I have a LynxpointLP south bridge embedded in my processor with 94 GPIO lines.  And I wanted to open them in sysfs ... <br><a name="habracut"></a><br><h3>  Problem solving (driver and device communication in Linux) </h3><br>  After doing a little search through the kernel code, I found that the driver was already written, is in the drivers \ gpio \ gpio-lynxpoint.c file, and is enabled using Kconfig <br><br><pre> <code class="hljs pgsql">config GPIO_LYNXPOINT tristate "Intel Lynxpoint GPIO support" <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ACPI &amp;&amp; X86 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> GPIOLIB_IRQCHIP help driver <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GPIO functionality <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Intel Lynxpoint PCH chipset Requires ACPI device enumeration code <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up a platform device.</code> </pre> <br>  The GPIO_LYNXPOINT option was enabled in the kernel with which I worked, but in the folder "/ sys / class / gpio /" there was not a single folder "gpiochipN" for the GPIO controller (which should be), and even such a script did not result in exporting any lines. <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {0..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Having looked at the coreboot code or having examined the documentation for this south bridge, it can be understood that the GPIO controller is not a separate PCI device.  It is part of another PCI device: LPC Interface Bridge.  Using the PCI configuration space registers of this device, you must enable the GPIO controller and assign it BASE_ADDRESS in the I / O space.  This will open a window in I / O space of 1kV size.  By writing / reading the bytes in this window, you can manage the lines of GPIO. <br><br>  What we can see in the coreboot code: <br><br>  southbridge \ intel \ lynxpoint \ pch.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOBASE 0x1400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOSIZE 0x400 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BASE 0x48 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_CNTL 0x4C </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Control Register */</span></span></span><span class="hljs-meta"> ... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PCI Configuration Space (D31:F0): LPC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCH_LPC_DEV PCI_DEV(0, 0x1f, 0)</span></span></code> </pre><br>  southbridge \ intel \ lynxpoint \ early_pch.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup GPIO Base Address */</span></span> pci_write_config32(PCH_LPC_DEV, GPIO_BASE, DEFAULT_GPIOBASE|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO functionality. */</span></span> pci_write_config8(PCH_LPC_DEV, GPIO_CNTL, <span class="hljs-number"><span class="hljs-number">0x10</span></span>);</code> </pre> <br>  If we look at the LPC device registers in Linux through ‚Äúlspci -xxx‚Äù, we will see that we have recorded information in these registers.  So everything seems to be set up as it should. <br><br>  Continuing to watch the driver code, I noticed that the Linux driver communicates with the device through the .acpi_match_table field.  Since our device cannot be enumerated (it is not located either on the PCI or on the USB bus), then the driver is required for it, and the driver is connected to the device via the ACPI table.  The usual case for x86, in the case of ARM, we would have registered our device in DeviceTree, or in the old hardcode in the kernel. <br><br>  drivers \ gpio \ gpio-lynxpoint.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acpi_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lynxpoint_gpio_acpi_match</span></span></span><span class="hljs-class">[] = {</span></span> { <span class="hljs-string"><span class="hljs-string">"INT33C7"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"INT3437"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { } }; MODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lp_gpio_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = lp_gpio_probe, .remove = lp_gpio_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"lp_gpio"</span></span>, .pm = &amp;lp_gpio_pm_ops, .acpi_match_table = ACPI_PTR(lynxpoint_gpio_acpi_match), }, };</code> </pre><br>  It works like this: if the kernel, when parsing the ACPI table, sees in it a device with _HID identifier "INT33C7", then it will try to find a platform driver for it with matching identifiers in the ".driver-&gt; acpi_match_table" structure fields. <br><br>  When a match is found, Linux will execute the .probe driver function. <br><br>  As it turned out, the ACPI code for this device was presented in the coreboot, I just had it commented out.  Commented out for the reason that for this device, Windows could not find the driver and output "Unknown device" in the device manager.  More on this will be below. <br><br>  So we are interested in information from the file. <br>  src \ southbridge \ intel \ lynxpoint \ acpi \ serialio.asl (the code is a bit simplified): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     * src\southbridge\intel\lynxpoint\pch.h * #define DEFAULT_GPIOBASE 0x1400 * #define DEFAULT_GPIOSIZE 0x400 */</span></span> Scope (\_SB) { Device (PCI0) { ... Device (GPIO) { <span class="hljs-comment"><span class="hljs-comment">// GPIO Controller Name (_HID, "INT33C7") Name (_CID, "INT33C7") Name (_UID, 1) Name (RBUF, ResourceTemplate() { DWordIo (ResourceProducer, MinFixed, // IsMinFixed MaxFixed, // IsMaxFixed PosDecode, // Decode EntireRange, // ISARanges 0x00000000, // AddressGranularity 0x00000000, // AddressMinimum 0x00000000, // AddressMaximum 0x00000000, // AddressTranslation 0x00000001, // RangeLength , // ResourceSourceIndex , // ResourceSource BAR0) Interrupt (ResourceConsumer, Level, ActiveHigh, Shared, , , ) {14} }) Method (_CRS, 0, NotSerialized) { CreateDwordField (^RBUF, ^BAR0._MIN, BMIN) CreateDwordField (^RBUF, ^BAR0._MAX, BMAX) CreateDwordField (^RBUF, ^BAR0._LEN, BLEN) Store (DEFAULT_GPIOSIZE, BLEN) Store (DEFAULT_GPIOBASE, BMIN) Store (Subtract (Add (DEFAULT_GPIOBASE, DEFAULT_GPIOSIZE), 1), BMAX) Return (RBUF) } Method (_STA, 0, NotSerialized) { Return (0xF) } } ... } }</span></span></code> </pre><br>  To parse this code in detail, you should familiarize yourself with the ASL language syntax in <a href="https://www.uefi.org/sites/default/files/resources/ACPI_6_2.pdf">the ACPI specification</a> . <br><br>  But in short, this code creates a device with the identifier "INT33C7" which has 2 resources: <br><br><pre> <code class="hljs mel">I/O <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-number"><span class="hljs-number">1400</span></span><span class="hljs-number"><span class="hljs-number">-17</span></span>ff; IRQ: <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre> <br>  Inside its .probe Linux function, the driver obtains the above-indicated device resources as follows: <br><br><pre> <code class="cpp hljs">io_rc = platform_get_resource(pdev, IORESOURCE_IO, <span class="hljs-number"><span class="hljs-number">0</span></span>); irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Based on this data, the driver code will fill in the gpio_chip structure and register the gpio controller in the system, making it available through the sysfs interface. <br><br>  Having returned the device's ASL code and recompiled the BIOS image, the system managed to access the GPIO via sysfs. <br><br>  For a start, the folder "gpiochip162" appeared in / sys / class / gpio.  This folder contains the file "base" and "ngpio".  The base file is responsible for the number of the first GPIO of this controller, ngpio for their number. <br><br><pre> <code class="bash hljs">$ cat /sys/class/gpio/gpiochip162/base 162 $ cat /sys/class/gpio/gpiochip162/ngpio 94</code> </pre> <br>  So everything was exported as it should.  Run the script: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {162..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  After that, gpioN subfolders appear in the / sys / class / gpio / folder, inside which there will be files for managing the state of the line. <br><br>  A couple of comments: <br><br><ul><li>  The folder / sys / class / gpio162 / is responsible for managing GPIO0, the folder / sys / class / gpio163 / is responsible for GPIO1, etc.  Such a shift occurred due to the fact that the driver, during the initialization of the ‚Äústruct gpio_chip‚Äù control structure, assigned ‚Äúgc-&gt; base = -1;‚Äù.  That is, provided the kernel to choose the numbers themselves.  This is generally not critical, but it is worth remembering that. </li><li>  Access is opened only to GPIO lines that are configured as GPIO, and not as any native functions of the south bridge.  For such lines, the driver displays information in dmesg: "gpio% d reserved for ACPI".  In the case of coreboot, the GPIO setting is made in the ‚Äúgpio.h‚Äù file in the folder with the motherboard. </li><li>  Comparison of the device and the driver can also go according to the _CID (Compatible ID) method, and documentation on our topic in the kernel is presented in the document <a href="https://www.kernel.org/doc/Documentation/acpi/enumeration.txt">‚ÄúACPI based device enumeration‚Äù</a> </li></ul><br>  It should be noted that the ‚ÄúINT33C7‚Äù device is not in ACPI tables of 2 proprietary motherboards on the same chipset (from IBASE and DFI).  The truth is, there most likely the GPIO lines are not displayed (I did not look at the documentation in detail at this point). <br><br><h3>  ID "INT33C7" </h3><br>  After raising the sysfs functionality, I had a question, where did the identification number ‚ÄúINT33C7‚Äù come from? <br><br>  Looking at the documentation for the _HID method, it became clear that it is worth looking at <a href="http://www.uefi.org/PNP_ACPI_Registry">http://www.uefi.org/PNP_ACPI_Registry</a> <br><br><div class="spoiler">  <b class="spoiler_title">_HID (Hardware ID)</b> <div class="spoiler_text">  <b>_HID (Hardware ID)</b> <br>  This object is used to supply OSPM with the device's PNP ID or ACPI ID * <br>  When describing a platform, use of any _HID objects is optional.  However, a _HID object must be <br>  Used by OSPM.  OSPM only enumerates a device <br>  when no bus enumerator can detect the device ID.  For example, devices on an ISA bus are <br>  enumerated by OSPM.  Use the _ADR object to describe devices enumerated by bus enumerators <br>  other than OSPM. <br><br>  <b>Arguments:</b> <br>  None <br><br>  <b>Return Value:</b> <br>  An Integer or String containing the HID <br>  A _HID object evaluates a 32-bit compressed EISA type ID or a string.  If a <br>  alphanumeric PNP or ACPI ID with no asterisk or other leading <br>  characters. <br><br>  A valid PNP ID where the form is "AAA ####" where A is an uppercase letter and # is a hex <br>  digit.  A valid ACPI ID must be NNNN #### where N is an uppercase letter or a <br>  digit ('0' - '9') and # is a hex digit.  This specification reserves the string "ACPI" for use only <br>  with devices defined herein.  It further reserves all strings of 4 HEX digits for <br>  exclusive use with PCI-assigned Vendor IDs. <br><br>  * -PNP ID and ACPI ID Registry is at <a href="http://www.uefi.org/PNP_ACPI_Registry">http://www.uefi.org/PNP_ACPI_Registry</a> <br></div></div><br>  This link has 3 points: <br><br><ul><li>  all kinds of 3 letter identifiers (PNP ID) are indicated <a href="http://www.uefi.org/pnp_id_list">here</a> </li><li>  PNP IDs that begin with ‚ÄúPNP‚Äù are reserved by Microsoft <a href="http://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/devids.txt">here.</a> <br></li><li>  All kinds of 4 letter identifiers (ACPI ID) are indicated <a href="http://www.uefi.org/acpi_id_list">here.</a> </li></ul><br>  It is not very clear why, but according to the PNP ID list, you can find that the identifiers "INT" are reserved at INTERPHASE CORPORATION: <br><br><pre> <code class="hljs pgsql">INTERPHASE CORPORATION <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">1996</span></span></code> </pre> <br>  Apparently, a single list of full device identifiers (letter part + numeric) is not published.  But with the help of Google, we managed to find lists of devices and their _HID, for example, <a href="http://www.kebe.com/~danmcd/webrevs/acpica/usr/src/common/acpica/common/ahids.c.html">here</a> or <a href="">here</a> . <br><br>  They indicate: <br><br><pre> <code class="hljs pgsql">INT33C7=Intel <span class="hljs-type"><span class="hljs-type">Serial</span></span> I/O GPIO Host Controller</code> </pre> <br>  And judging by the remaining lines from this list, all INTxxxx devices are Intel devices (now it sounds quite obvious, but the connection with INTERPHASE CORPORATION is not clear; it is also not very clear why the numbering starts with such large numbers, but it seems to be Intel discretion). <br><br><h3>  Driver and device communication in Windows </h3><br>  Satisfying my curiosity, I decided to download Windows on my board.  As expected, the system could not find a driver for the device.  There was no help from the drivers for the IBASE and DFI boards, which is understandable, because this device is not indicated in the BIOS of these boards. <br><br>  I managed to find a driver <a href="http://www.catalog.update.microsoft.com/Search.aspx%3Fq%3DIntel%2520Serial%2520IO%2520GPIO%2520Host%2520Controller%2520INT33C7">on the Microsoft website</a> <br><br>  However, there this driver is presented only for Windows 8.1 and higher.  I'm still working with Windows 7. <br><br>  Nevertheless, I tried to download one of the drivers and specify its folder when searching for a driver for my unknown device. <br><br>  However, the dispatcher could not match the driver to the device.  Although the inf file clearly contained information about the device INT33C7. <br><br><pre> <code class="hljs mel">[Manufacturer] %INTEL%=Intel,NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> [Intel.NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>] %iaLPSS_GPIO.DeviceDesc_LPT%=iaLPSS_GPIO_Device, ACPI\INT33C7 %iaLPSS_GPIO.DeviceDesc_WPT%=iaLPSS_GPIO_Device, ACPI\INT3437</code> </pre> <br>  In the process of parsing the INF file, it turned out that in the [Manufacturer] section it was clearly stated that it was not intended for my system: <br><br>  What Intel.NTamd64.6.3 means can be understood <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-manufacturer-section">by the description</a> : <br><br><pre> <code class="hljs markdown">nt[<span class="hljs-string"><span class="hljs-string">Architecture</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">.[OSMajorVersion</span></span>][<span class="hljs-string"><span class="hljs-string">.[OSMinorVersion</span></span>] OSMajorVersion=6 =&gt; Windows 7/Windows 8.1/Windows Server 2012 R2/... OSMinorVersion=3 =&gt; Windows 8.1/Windows Server 2012 R2</code> </pre> <br>  I did not succeed in trying to push the Windows 7 driver by replacing Intel.NTamd64.6.3 with Intel.NTamd64.6.1, as it gave me a blue screen of death and an unbootable OS, and I had to restore it. <br><br>  The driver for Win7 was found only on an incomprehensible website on the Internet, and then the device is displayed in the device manager with an exclamation mark. <br><br>  Realizing his impotence, I decided to test the functionality on Windows 10. There was a pleasant surprise.  <a href="https://downloadcenter.intel.com/download/20775/Intel-Chipset-Device-Software-INF-Update-Utility-%3Fproduct%3D1145">"Intel Chipset Device Software (INF Update Utility)"</a> installed the driver for my controller without any problems. <br><br><img src="https://habrastorage.org/webt/xb/28/jq/xb28jqet9w3tieq0atau1f2aoum.png"><br><br>  As you can see, this device has resources indicated by us. <br><br><img src="https://habrastorage.org/webt/2o/fs/p0/2ofsp055fsxm4smnghgxc3eye8u.png"><br><br>  In theory, after installing the driver with the GPIO controller, it will most likely be possible to work through the IOCTL functions ( <a href="http://www.ctcom.com.tw/doc/324257.pdf">such as in this document)</a> . <br><br>  However, there were no GPIO programming tasks from Windows, so the search for a similar document for my chipset was postponed. <br><br><hr><br><h3>  Conclusion: </h3><br>  This article has reviewed the driver and device communication using the _HID ACPI method.  Such a connection may be required on an x86 system for devices that cannot be enumerated. <br><br><ul><li>  In the case of Linux, communication with the driver is done via .acpi_match_table </li><li>  In the case of Windows, communication with the driver is carried out through the INF file </li></ul></div><p>Source: <a href="https://habr.com/ru/post/429336/">https://habr.com/ru/post/429336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429324/index.html">Unreal Engine 4.21 release</a></li>
<li><a href="../429326/index.html">App Store will not call. Or how I made my application, but it will not get to users</a></li>
<li><a href="../429328/index.html">Software module for digitizing damaged documents</a></li>
<li><a href="../429330/index.html">Myths and legends of Agile - from the Pharaohs to the present day</a></li>
<li><a href="../429332/index.html">Self-made laser installation "Lightsaber" - as it were, part 1</a></li>
<li><a href="../429338/index.html">Android Storage: Internal, External, Removable. Part 1/3</a></li>
<li><a href="../429340/index.html">Think twice before using Helm</a></li>
<li><a href="../429342/index.html">Angular 6+ complete dependency deployment guide. providedIn vs providers: []</a></li>
<li><a href="../429344/index.html">Weekend Reading: Audio Tuning and Speaker Design Materials</a></li>
<li><a href="../429346/index.html">To the magistracy without exams: a new direction "Big data" at the Olympiad "I am a professional"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>