<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a Rubik's Cube Emulator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenGL is a platform-independent specification that describes a software interface for creating computer applications using two-dimensional and three-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a Rubik's Cube Emulator</h1><div class="post__text post__text-html js-mediator-article">  OpenGL is a platform-independent specification that describes a software interface for creating computer applications using two-dimensional and three-dimensional graphics. <br>  In this article I will describe how you can create a Rubik's Cube emulator on OpenGL. <br><br>  The cube will be in 3D and can be rotated with the mouse, and you can turn the faces by clicking the arrows on the arrows.  At the same time, arrows appear at the face closest to the viewer. <br><br><img src="https://habrastorage.org/storage2/28e/708/9e1/28e7089e1014b0a3330792cecb23c12e.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will describe the creation of the Rubik's Cube emulator in the C # language, for OpenGL I will use the <a href="http://www.opentk.com/">OpenTK</a> library.  It is necessary to download it, and make a link to this library in Visual Studio. <br><br><h4>  3D tour </h4><br>  Now a short description about 3D.  Objects in 3D have 3 x, y, z coordinates, and on the monitor screen only two coordinates.  Obviously, the projection should be shown on the monitor screen. <br><br><img src="https://habrastorage.org/storage2/f99/520/a88/f99520a88e1ca6540b162d8fbd108cc0.png"><br><br>  But we don‚Äôt have to project rear objects or which stand to the side.  Also, we should not project ideas that are too far away.  (Remember, as in racing, distant objects appear when you start to approach them). <br><br>  Therefore, we must limit what we can see: <br><br><img src="https://habrastorage.org/storage2/310/574/dce/310574dce24985e51c848d62b5e61122.png"><br><br>  Such a truncated pyramid called FrustRum (FrustRum), to show the object on the screen, we determine whether it fits in Frustrum (those parts that do not fit we cut off), then we project on the screen.  OpenGL does all this for us. <br><br><h4>  Attempt at writing </h4><br>  <a href="http://www.opentk.com/files/download-opentk.html">Download the OpenTK library</a> .  Run the file, unpack the library. <br><br>  Create a project, add a link to the file OpenTK.dll.  And since, we will use the GLControl control, on which the Rubik's Cube will be displayed, we also add a link to OpenTK.GLControl.dll <br>  OpenTK also requires a link to System.Drawing.dll, so once again we enter the interface for adding a link, and select the .Net tab and look for System.Drawing, and add it. <br><br><div class="spoiler">  <b class="spoiler_title">Add OpenTK Library</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/6c1/126/776/6c11267765f2c037ad3bc6a3879e3c41.png"><br><img src="https://habrastorage.org/storage2/5a6/2af/0d1/5a62af0d167578d195704fe9793b95e8.png"><br></div></div><br><br>  I will use OpenGL, inside a regular GUI program.  Therefore, in the constructor mode, right-click on the toolbar, and select ‚ÄúSelect elements‚Äù, go to the ‚Äú.NET Framework Components‚Äù tab and select the OpenTK.GLControl.dll file.  A new element GLControl will appear in the list, put a check mark in front of it.  OK.  A new GLControl item will appear on the toolbar.  We transfer it to the form and stretch it to its entire shape. <br><br><div class="spoiler">  <b class="spoiler_title">Adding a GLControl control (canvas, canvas)</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/91e/6bb/28c/91e6bb28c3af0dd5aa61f4b43aea5955.png"><br><img src="https://habrastorage.org/storage2/70f/618/0dc/70f6180dcb1e3a267bc82fc6bc9f30fb.png"><br><img src="https://habrastorage.org/storage2/456/770/d8a/456770d8a6e3b09b90f1ac181c1c4075.png"><br><img src="https://habrastorage.org/storage2/e21/79f/ae6/e2179fae61a8d75ec3219b279e005b1d.png"><br></div></div><br><br>  The GLControl element has a Load event, it fires when this element has loaded. <br>  (Click on it to fill the body of the handler, the glControl1_Load method will appear) <br>  The creators of OpenTK do not recommend starting working with GLControl before it is loaded, so you need to set a variable that will store the value of whether GLControl was loaded: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics.OpenGL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">habr</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> loaded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;<span class="hljs-comment"><span class="hljs-comment">//&lt;-------------------------------------- public Form1() { InitializeComponent(); } private void glControl1_Load(object sender, EventArgs e) { loaded = true;//&lt;-------------------------------------- } private void glControl1_Paint(object sender, PaintEventArgs e) { if (!loaded)//&lt;-------------------------------------- return;//&lt;-------------------------------------- } } }</span></span></code> </pre> <br></div></div><br><br>  glControl1_Load - the method that handles the Load event <br>  glControl1_Paint - the method that handles the Paint event, works, for example, when we hide, and then open the window again, or, for example, resize the window. <br><br>  Actually draw a cube. <br><br><div class="spoiler">  <b class="spoiler_title">Code that draws a small cube</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics.OpenGL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">habr</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> loaded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Form1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { loaded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; GL.ClearColor(Color.SkyBlue); GL.Enable(EnableCap.DepthTest); Matrix4 p = Matrix4.CreatePerspectiveFieldOfView((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(<span class="hljs-number"><span class="hljs-number">80</span></span> * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); GL.MatrixMode(MatrixMode.Projection); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> p); Matrix4 modelview = Matrix4.LookAt(<span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.MatrixMode(MatrixMode.Modelview); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> modelview); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_Paint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PaintEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!loaded) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Color3(Color.Red); GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.Vertex3(width, width, width); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Color3(Color.Black); GL.Begin(BeginMode.LineLoop); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); GL.Begin(BeginMode.LineLoop); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); GL.Begin(BeginMode.LineLoop); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.End(); GL.Begin(BeginMode.LineLoop); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); glControl1.SwapBuffers(); } } }</code> </pre><br></div></div><br><br>  using OpenTK;  - needed for the Matrix4 class (4x4 matrix) <br>  using OpenTK.Graphics.OpenGL;  - needed to gain access to the GL object. <br><br>  GL is an object through which to actually call OpenGL commands. <br>  GL.ClearColor (Color.SkyBlue);  - fills in blue <br>  GL.Enable (EnableCap.DepthTest);  - this line is needed to distant elements overlap neighbors. <br><br><pre> <code class="cs hljs">Matrix4 p = Matrix4.CreatePerspectiveFieldOfView((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(<span class="hljs-number"><span class="hljs-number">80</span></span> * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); GL.MatrixMode(MatrixMode.Projection); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> p);</code> </pre><br><br>  Here we set the matrix, which is responsible for Frustum: <br>  1) viewing angle of 80 degrees <br>  2) the ratio of length to height - 1 <br>  3) the distance to the first face is 20 <br>  4) distance to the far edge - 500 <br><br>  Go to the projection mode, and set this matrix.  About the modes will be discussed later. <br><br><pre> <code class="cs hljs">GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);</code> </pre><br>  Initialize ColorBufferBit and DepthBuffer <br><br>  ColorBuffer.  Color Buffer.  Each pixel on the screen is associated with a color value, which is recorded in a color buffer.  The call to GL.Clear (ClearBufferMask.ColorBufferBit) will flood the window with the SkyBlue color (see above). <br><br>  DepthBuffer.  He is a Z-Buffer.  Depth buffer  The fact is that two points in 3D space can be projected onto one point on the screen.  It is necessary that the near point overlaps the furthest.  To do this, calculate the ‚Äúdepth‚Äù of the point (the value is inversely proportional to the distance from the camera to the point) and record its value in the buffer (the peekel is such and such, the depth is such and such) <br>  if the next point is projected on the same pixel, then it is necessary to compare the ‚Äúdepth‚Äù of the new point with the recorded Depth-buffer.  If the new point is ‚Äúless deep‚Äù (more closer to the camera), then its projection should overlap the existing one, otherwise leave everything as it is. <br>  At the beginning of the cube drawing, we need to clear the Depth-Buffer. <br><br><pre> <code class="cs hljs">Matrix4 modelview = Matrix4.LookAt(<span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.MatrixMode(MatrixMode.Modelview); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> modelview);</code> </pre><br><br>  Here we set our camera at the point (30, 70, 80), the direction of gaze to the center of the coordinate system (0, 0, 0).  The orientation is such that the axis OY is directed upwards. <br><br>  If we do <br><pre> <code class="cs hljs">Matrix4 modelview = Matrix4.LookAt(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  Then we will look at the cube at an angle, as if we tilted our head 45 degrees to the left. <br><br>  Next, the cube itself is drawn: first, the faces are red, then black - the edges <br><br>  Then the command is called. <br><pre> <code class="cs hljs">glControl1.SwapBuffers();</code> </pre><br><br>  The fact is that the default OpenGL in OpenTK is double-buffer: each buffer (ColorBuffer, DepthBuffer and others that I did not mention) is duplicated.  When we draw an image, we use some buffers.  And at this time on the screen displays an image that is received from other buffers. <br>  The command glControl1.SwapBuffers ();  we display the image using the buffers in which we painted it. <br>  By the way, if you clear the color buffer only for the first time <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_Paint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PaintEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!loaded) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; GL.Clear(ClearBufferMask.DepthBufferBit); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b) { GL.Clear(ClearBufferMask.ColorBufferBit); } b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ‚Ä¶</code> </pre><br><br>  That is, clear only one color buffer (in fact, fill it with blue color), and not clear the other.  And then minimize / maximize the window.  That background color will change from blue to black.  (however, if you resize the window, it will always become black (apparently, both buffers are reset during resize). <br><br><h4>  Now about the modes </h4><br>  Objects are defined in 3-dimensional coordinates.  These coordinates are called object.  Each object can be defined in its object coordinates.  To build a world of different 3d objects that stand relative to each other in different positions, <br>  you need to multiply the object coordinates of each object by the corresponding <i>model matrix</i> .  Then we get the new coordinates of each object in the new common world space. <br><br>  At the same time, we can look at the world of objects from different sides, we can flip the camera, we can move closer to the object and move away from it.  Multiplying the coordinates of the objects (coordinates in world space) by the corresponding view transformation matrixes (view Matrix), we get the view coordinates of each object. <br><br>  In OpenGL, the model transformation matrix (model Matrix) is combined with the view transformation matrix (view Matrix) into one (modelView Matrix).  (After all, we can postpone the object in two ways: change its world coordinates (postpone the object itself), or move the camera away from it (get new view coordinates)). <br><br>  Then the coordinates are multiplied by the projection matrix (projection Matrix), which either sets the Frustrum (perspective projection): <br><img src="https://habrastorage.org/storage2/5a4/d99/8b6/5a4d998b6362325dc7632891b45e4a5e.png"><br><br>  or sets the orthogonal projection: <br><img src="https://habrastorage.org/storage2/5ee/47b/b26/5ee47bb26422da1fa9653e0d943c4c4b.png"><br><br>  Multiplying the view coordinates by the projection matrix, we get the truncated coordinates (clip coordinates).  By dividing each coordinate (x, y, z) by 4 œâ, we get the normalized device coordinates (Normalize Device Coordinates, NDC) each of which is from -1 to 1, with the Z axis already deployed from us (that is, Frustum turns into a cube and turns around 180 degrees from us), <br>  then, the coordinates by shift and scaling are converted to window coordinates (window coordinates), which are finally involved in the construction of a 2D image on the screen. <br><br>  To switch to the projection matrix control mode, we need to call the GL.MatrixMode function with the MatrixMode.Projection parameter: <br>  GL.MatrixMode (MatrixMode.Projection); <br><br>  And in order to switch to the matrix-model transformation mode, we need to call the GL.MatrixMode function with the MatrixMode.Modelvew parameter: <br>  GL.MatrixMode (MatrixMode.ModelView); <br><br>  Add a code to glControl1_Paint that draws the OX, OY, OZ axes: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Color3</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Black</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Begin</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">BeginMode</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Lines</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Vertex3</span></span>(0, 0, 0); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Vertex3</span></span>(50, 0, 0); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Vertex3</span></span>(0, 0, 0); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Vertex3</span></span>(0, 50, 0); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Vertex3</span></span>(0, 0, 0); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Vertex3</span></span>(0, 0, 50); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.End</span></span>();</code> </pre><br><br>  Also in the form designer, you need to add an event handler for the KeyDown event, the glControl1_KeyDown function will appear.  Fill it with the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_KeyDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, KeyEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!loaded) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.KeyCode == Keys.A) { GL.MatrixMode(MatrixMode.Projection); GL.Rotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.KeyCode == Keys.B) { GL.MatrixMode(MatrixMode.Modelview); GL.Rotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } glControl1.Invalidate(); }</code> </pre><br><br>  That is, when you press the A key on the keyboard, we switch to the projection mode and rotate around the OZ axis 30 degrees counterclockwise, <br>  and when you press the B key, the rotation around the OZ axis is also performed, but already in the mode-model transformation mode. <br><br>  I give the full code here: <br><div class="spoiler">  <b class="spoiler_title">a small cube that rotates by pressing A and B</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics.OpenGL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">habr</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> loaded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Form1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Form1_Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { loaded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; GL.ClearColor(Color.SkyBlue); GL.Enable(EnableCap.DepthTest); Matrix4 p = Matrix4.CreatePerspectiveFieldOfView((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(<span class="hljs-number"><span class="hljs-number">80</span></span> * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); GL.MatrixMode(MatrixMode.Projection); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> p); Matrix4 modelview = Matrix4.LookAt(<span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.MatrixMode(MatrixMode.Modelview); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> modelview); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_KeyDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, KeyEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!loaded) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.KeyCode == Keys.A) { GL.MatrixMode(MatrixMode.Projection); GL.Rotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.KeyCode == Keys.B) { GL.MatrixMode(MatrixMode.Modelview); GL.Rotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } glControl1.Invalidate(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glControl1_Paint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PaintEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!loaded) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Color3(Color.Red); GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.Vertex3(width, width, width); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.End(); <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> GL.Begin(BeginMode.Polygon); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); GL.Color3(Color.Black); GL.Begin(BeginMode.LineLoop); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); GL.Begin(BeginMode.LineLoop); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(width, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); GL.Begin(BeginMode.LineLoop); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(width, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.End(); GL.Begin(BeginMode.LineLoop); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, width); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); GL.Color3(Color.Black); GL.Begin(BeginMode.Lines); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); GL.End(); glControl1.SwapBuffers(); } } }</code> </pre><br></div></div><br>  If we press the letter A on the keyboard, then we will rotate the 2D image on the screen: <br><img src="https://habrastorage.org/storage2/cee/501/c34/cee501c3449ae42db77947322a8c172c.gif"><br><br>  Thus, in perspective coordinates, the OZ axis is also the Frustrum axis. <br><br>  If you press B on the keyboard, then we will rotate the coordinate system around the OZ axis: <br><img src="https://habrastorage.org/storage2/efb/99f/8b6/efb99f8b696a7b10ee4a978257d40641.gif"><br><br>  Code <br><pre> <code class="cs hljs">GL.MatrixMode(MatrixMode.Projection); GL.Rotate(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  With the same success it was possible to replace this: <br><br><pre> <code class="cs hljs">Matrix4d projection_matrix;<span class="hljs-comment"><span class="hljs-comment">// 4x4,   double GL.GetDouble(GetPName.ProjectionMatrix, out projection_matrix);//    projection_matrix //     OZ double cos = Math.Cos(-30 * Math.PI / 180); double sin = Math.Sin(-30 * Math.PI / 180); Matrix4d rotating_matrix = new Matrix4d( cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); projection_matrix *= rotating_matrix;//      GL.MatrixMode(MatrixMode.Projection);//    GL.LoadMatrix(ref projection_matrix);//   </span></span></code> </pre><br><br>  The same code above the ModelView matrix will give the same result. <br><br>  Actually, let's move on to the description of the Rubik's cube emulator program, which you can download here: <a href="">http: //trukoding.rf/files/opengl.zip</a> <br><br><h4>  Finally </h4><br>  I will not describe everything, as there will be a lot of text.  I will describe the key points. <br><br><h5>  Key data structures </h5><br>  <b>1)</b> Rubik's Cube, the edge of which consists of 3 cubes consists of 27 small cubes. <br>  In the process of rotating the faces of the Rubik's Cube (KR), small cubes will change their location.  In the process of rotation of the face of the CD, you need to know which small cubes to rotate (after all, different cubes can appear on the face), also after the next rotation of the face of the CD, you need to check whether the cube is going to. <br><br>  To track the positions of the cubes, I applied an array of positions: <br>  int [] positions; <br><br>  His keys are the numbers of the cubes, and the values ‚Äã‚Äãof the position numbers. <br><br>  By the way, I marked the position as follows: <br><img src="https://habrastorage.org/storage2/40e/2a7/880/40e2a788063676e1d837e10b8010122e.png"><br><br>  <b>2)</b> When you rotate the face of the CD, the corresponding small cubes change not only the location, but turn other sides.  When we turned the face one turn (90 degrees), <br>  then the new state of the cube can be obtained in two ways: <br>  1) turn the corresponding cubes around a certain axis by 90 degrees (which was done when turning) <br>  2) either rearrange the cubes, to new places, and rotate each cube around its axis by 90 degrees. <br><br>  The next class is used to describe a cube in space. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">angleXYZ</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">angleXYZ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.X = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Z = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><br>  the fields X, Y, Z are the angles relative to the axes OX, OY, OZ <br>  when we rotate any face, the corresponding angle of the corresponding cubes changes. <br>  After completing the rotation, I reset these angles, move the cubes to new positions (that is, change the position array accordingly), and rotate the cubes around its axis (I will show what I mean by this).  The user sees only the rotation itself. <br><br>  The object of class angleXYZ is in each cube and is stored in the angles collection: <br><pre> <code class="cs hljs">List&lt;angleXYZ&gt; angles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;angleXYZ&gt;();</code> </pre><br><br>  <b>3)</b> Each cube contains 8 corner points.  Knowing these points, drawing a cube is not a problem. <br>  The coordinates of the points are stored in the 3-dimensional array of edges.  To transfer and rotate coordinates using only multiplication operations (and not addition and multiplication), I use 1x4 matrices for coordinates and 4x4 matrices for transfer matrices and multiplication. <br>  The use of 4x4 matrices allows us to combine the multiplication operation together and the transfer matrix, and rotation.  Thus, in one multiplication operation, two things can be done: the transfer and the multiplication. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][][] edges; ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// edges = new float[n][][];//n -   (27,  3x3x3) ‚Ä¶ for (int i = 0; i &lt; n; i++) { float[][] vectors = new float[8][] { //w-   new float[4] { 0, 0, 0, 1 }, new float[4] { 0, 0, w, 1 }, new float[4] { 0, w, 0, 1 }, new float[4] { 0, w, w, 1 }, new float[4] { w, 0, 0, 1 }, new float[4] { w, 0, w, 1 }, new float[4] { w, w, 0, 1 }, new float[4] { w, w, w, 1 }, }; edges[i] = vectors; ‚Ä¶ //  List&lt;int&gt; data = getOffsets(i); int offset_x = data[0]; int offset_z = data[1]; int offset_y = data[2]; for (int j = 0; j &lt; edges[i].Length; j++) { //w -  , spacing -    //(    ) edges[i][j][0] += offset_x * (w + spacing); edges[i][j][1] += offset_y * (w + spacing); edges[i][j][2] += offset_z * (w + spacing); } }</span></span></code> </pre><br><br>  To find out the displacement of the next small cube (of which the Rubik's Cube consists) relative to the zero position in the assembled CD, I wrote a special function getOffsets, which takes the number of the cube and returns how many cubes to retreat on each of the axes. <br><br>  <b>4)</b> There is another dictionary intersect_planes. <br>  Dictionary keys are axes (Axis enumeration object (public enum Axis {X, Y, Z};)), <br>  and values ‚Äã‚Äãare the faces on the corresponding axis, objects of my class Plane (plane). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Axis { X, Y, Z }; Dictionary&lt;Axis, Plane[]&gt; intersect_planes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Axis,Plane[]&gt;();</code> </pre><br><br>  The class Plane is needed to store the coordinates of the points of the corner points of each face. <br><br><pre> <code class="cs hljs">side = N * w + (N - <span class="hljs-number"><span class="hljs-number">1</span></span>) * spacing;<span class="hljs-comment"><span class="hljs-comment">// -   //   Vector3 p1 = new Vector3(0, side, side);//&lt;---- Vector3 p2 = new Vector3(side, 0, side); Vector3 p3 = new Vector3(side, side, side);//&lt;---- Vector3 p4 = new Vector3(side, 0, 0); Vector3 p5 = new Vector3(0, 0, 0); Vector3 p6 = new Vector3(0, side, 0);//&lt;---- Vector3 p7 = new Vector3(0, 0, side); Vector3 p8 = new Vector3(side, side, 0); intersect_planes[Axis.X] = new Plane[2] { new Plane(p2, p3, p8),// 2, 5, 8, 11, 14, 17, 23, 20, 26  X new Plane(p1, p7, p5)// 0, 3, 6, 9, 12, 15, 18, 21, 24  X }; intersect_planes[Axis.Y] = ... ‚Ä¶.</span></span></code> </pre><br><br>  the object of the class Plane simply stores the coordinates of the 3 points, and the constructor of this class checks that they are different.  But it was possible and not to get a separate class, but just to manage a two-dimensional array: <br><br><pre> <code class="cs hljs">intersect_planes[Axis.X] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">2</span></span>][] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[]{p2, p3, p8},<span class="hljs-comment"><span class="hljs-comment">// 2, 5, 8, 11, 14, 17, 23, 20, 26  X new Vector3[]{p1, p7, p5},// 0, 3, 6, 9, 12, 15, 18, 21, 24  X };</span></span></code> </pre><br><br>  but it strains to access the elements of the array through a series of square brackets. <br><br>  This dictionary is needed in order to determine on the plane of which face we clicked the mouse, respectively, which part of the Rubik's Cube must be rotated.  The definition of the plane, the arrows which clicked the mouse, will be written later. <br><br>  <b>5)</b> An important object of my vp ViewPoint class. <br><pre> <code class="cs hljs">ViewPoint vp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewPoint();</code> </pre><br><br>  which stores the value of the coordinates of the point of view of the Rubik's Cube, the fact is that when I rotate with the mouse of the Rubik's Cube, I actually change the position of the point of view, and the cube stands still. <br><br>  The ViewPoint class is needed to get the closest axis to the viewpoint (getNearestAxis method).  This is necessary to determine on which face to show the arrows, that is, which parts to rotate, when you click the mouse. <br><br>  The point of view rotates around the Rubik's Cube on the sphere, so it is convenient to operate with an angle relative to the axis OX (angle Œ±) and an angle relative to the oci OY (angle Œ≤): <br><img src="http://habrastorage.org/storage2/904/711/a52/904711a5254769bc11a69f65089fe94d.png"><br><br>  At the vp object, the setter properties angle_view_alpha and angle_view_beta are opened, the angle Œ± and angle Œ≤ are changed through them, and the coordinates of the camera (viewpoints) are calculated in these body angles. <br>  Also, this class has getter properties that can be used to determine if the camera is not upside down, from which side of a certain axis we are looking at a cube (for example, from positive X values, or from negative Z values). <br>  This is necessary in order to correctly determine in which direction to turn the faces of the Rubik's Cube.  The Rubik's Cube itself is located so that its center is at the center of the origin of coordinates. <br><br><h4>  Let's go to the code </h4><br>  <b>I will describe only the key points, otherwise it will be very long.</b>  I already feel Lev Nikolayevich. <br><br><h5>  <b>Render method</b> </h5><br>  The Rubik's Cube itself I want to draw so that its center coincides with the center of the origin, therefore, going into the ModelView matrix mode, I do the translation of the coordinate system half the length of the Rubik's Cube along all axes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> offset0 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w * N + (N - <span class="hljs-number"><span class="hljs-number">1</span></span>) * spacing;<span class="hljs-comment"><span class="hljs-comment">//   w -   , N -   (3), spacing -    . double offset = offset0 / 2; GL.Translate( -offset, -offset, -offset );</span></span></code> </pre><br><br>  Then, by the number of cubes (27 times), the cube function is called, which draws small cubes except that it is in the center of the CU, because it will never be seen. <br><br><h5>  <b>Cube</b> function </h5><br><br>  I first save the current ModelView matrix in the stack that OpenGL provides: <br><pre> <code class="cs hljs">GL.PushMatrix();</code> </pre><br>  and at the end I restore this matrix from the stack: <br><pre> <code class="cs hljs">GL.PopMatrix();</code> </pre><br><br>  It is necessary that changing the ModelView matrix (turns, transfers) of one cube does not affect the matrices of other cubes.  In other words, if we want to spin one small cube, then we should not spin others. <br><br>  To animate the scrolling of a face, I turn around around any of the axes. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = (w * N + (N - <span class="hljs-number"><span class="hljs-number">1</span></span>) * spacing) / <span class="hljs-number"><span class="hljs-number">2</span></span>;<span class="hljs-comment"><span class="hljs-comment">//    GL.Translate( offset, offset, offset ); GL.Rotate(angle.X, Vector3.UnitX); GL.Rotate(angle.Y, Vector3.UnitY); GL.Rotate(angle.Z, Vector3.UnitZ); GL.Translate( -offset, -offset, -offset );</span></span></code> </pre><br><br>  The code is written in such a way that only one of the angles angle.X, angle.Y, angle.Z at one moment can be non-zero, so here you can only rotate around one axis, or not at all. <br><br>  But, bearing in mind that the coordinate system is shifted, you must first return it to its place, make a turn, and again make a reverse transfer, which is what I have done: <br><br><img src="http://habrastorage.org/storage2/560/d19/636/560d19636cd83fd0ade4f36994c8d248.png"><br><br>  Next, the <b>edges</b> array is used to draw the cube, the colors of the cube faces are determined from the cube number, which is passed to the cube function. <br><br><h5>  <b>Arrows</b> </h5><br><br>  The center of the coordinate system using GL.Translate returns to its original location. <br>     vp  ViewPoint           .      GL.Rotate   GL.Translate   ,      . <br><br>       ,         ,         ,   ,         ,         . <br><br>   2-        (NDC,    ),      ,      ModelView  . <br>       ,       . <br><br><pre> <code class="cs hljs">System.Windows.Forms.MouseEventArgs me = (e <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> System.Windows.Forms.MouseEventArgs); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = me.Y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = me.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = glControl1.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = glControl1.Height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xpos = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span> * (x / w) - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ypos = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - y / h) - <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector4 startRay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(xpos, ypos, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector4 endRay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(xpos, ypos, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Reverse Project Matrix4 modelview = new Matrix4(); Matrix4 projection = new Matrix4(); GL.GetFloat(GetPName.ModelviewMatrix, out modelview); GL.GetFloat(GetPName.ProjectionMatrix, out projection); Matrix4 trans = modelview * projection; trans.Invert(); startRay = Vector4.Transform(startRay, trans); endRay = Vector4.Transform(endRay, trans); sr = startRay.Xyz / startRay.W; er = endRay.Xyz / endRay.W;</span></span></code> </pre><br><br><h5>     <b>Render</b> </h5><br><br>       ,       ,         (      intersect_planes,   ). <br><br>       .              ( ),        .    ,     ,      XOY, XOZ, YOZ (     /      4-  ). <br>       . <br><br><h5> <b> </b> </h5><br>        EasingTimer,   System.Timers.Timer,     Singleton,       .     ,       .    run,      ,      ,    . <br><br>  duration   EasingTimer     . <br>    : <br><br><ol><li>    </li><li>       100 . </li><li>   ,     <b>rotatePart</b> ,     angles  . ,            . <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">angleXYZ</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">angleXYZ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.X = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Z = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  ,      X,  Y,  Z, <br>     100 ,         ,   ,      . <br>  ,    glControl1.Invalidate();,    <b>Render</b> ,       <b>cube</b>     ,          <b>angles</b> ,     .    ,   . <br></li><li>     <b>rotatePart</b> ,    duration . <br>      ,   (      <b>Render</b> ,       ,     ). <br>    positions ( ,    ,  ),      .     ‚Äî   ,        ,        . <br>        ,          : <br><img src="http://habrastorage.org/storage2/1c2/539/b2b/1c2539b2b6adcef40dd61d2a3e674f3d.png"><br></li></ol><br><br>    edges,   8   ,       . <br>     glControl1.Invalidate();   Render,     cube,         . <br><br>       positions,        (27 , 27 ).   ,       ,        ,        ‚Äú   3  90    X‚Äù,     ‚Äú ,     3,  90    X‚Äù. <br><br>  ,        angles,      .   ,     .    X,     Y   ,     Y,      X. <br><br>       ,      cube,    <br><br>       ,   ,     :  X,  Y,  Z. <br><pre> <code class="cs hljs">GL.Rotate(angle.X, Vector3.UnitX); GL.Rotate(angle.Y, Vector3.UnitY); GL.Rotate(angle.Z, Vector3.UnitZ);</code> </pre><br>      ,     .  edges      ,     ,    ,       .       edges      . <br><br><h5> <b>   </b> </h5><br>           .     MouseDown, MouseMove, MouseUp.  ,       ,      ,    . <br><br>     vp  ViewPoint,      X,  Y (  ),     ViewPoint        ,     ModelView: <br><br><pre> <code class="cs hljs">G_modelview = Matrix4.LookAt(vp.viewX, vp.viewY, vp.viewZ, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, vp.orintation_y, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  3    , <br>  3  ,        . <br>  3  ,    <br>  ,   Y    ,  vp.orintation_y == 1,    vp.orintation_y == -1 <br><br>   . <br>  ,      ,     .  Thanks for attention.     : <a href="">http://xn--c1abmgrdmpk4e.xn--p1ai/files/opengl.zip</a> </div><p>Source: <a href="https://habr.com/ru/post/173131/">https://habr.com/ru/post/173131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../17312/index.html">The official release of a competitor Android</a></li>
<li><a href="../173123/index.html">CSS3 Flower Bouquet</a></li>
<li><a href="../173125/index.html">Preparing Nginx for PCI Compliance</a></li>
<li><a href="../173127/index.html">Samba System troubleshooting</a></li>
<li><a href="../17313/index.html">Personal Blog Description</a></li>
<li><a href="../173133/index.html">CeBIT 2013. Mobile devices. The final post about the exhibition</a></li>
<li><a href="../173135/index.html">Scoring, assessment of borrowers for the Webmoney system. Short review. Instruments</a></li>
<li><a href="../173137/index.html">NHibernate 3.3.3.GA released</a></li>
<li><a href="../17314/index.html">Google does not speak Albanian?</a></li>
<li><a href="../173141/index.html">WebKit for developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>