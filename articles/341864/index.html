<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[DotNetBook] IDisposable implementation: proper use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this article, I begin to publish a series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole. The I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[DotNetBook] IDisposable implementation: proper use</h1><div class="post__text post__text-html js-mediator-article"><img align="left" width="350" src="https://habrastorage.org/webt/34/ua/e6/34uae6usmglyw10vxga3sgfgh8c.jpeg">  With this article, I begin to publish a series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole.  The IDisposable theme was chosen as an overclocking test.  The whole book will be available on GitHub: <a href="https://github.com/mumusan/dotnetbook">DotNetBook</a> .  So Issues and Pull Requests are welcome :) <br><br><h1>  Disposing (Disposable Design Principle) </h1><br><br>  Now, probably, almost any programmer who develops on the .NET platform will say that there is nothing simpler than this pattern.  What it is known from the famous templates that are applied on the platform.  However, even in the simplest and most famous problem area there is always a second bottom, and behind it there are a number of hidden pockets that you have never looked into.  However, both for those who are watching the topic for the first time, and for all the others (just so that each of you remembers the basics (do not skip these paragraphs (I follow!))) - we will describe everything from the very beginning to the very end. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  IDisposable </h2><br><br>  If you ask what is IDisposable, you will surely answer that this <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br><br>  What is the interface for?  After all, if we have a smart Garbage Collector, which cleans all memory for us, makes sure that we don‚Äôt even think about how to clean memory, it becomes not quite clear why it should be cleaned at all.  However, there are nuances. <br><br><blockquote><h3>  Note </h3><br>  The chapter published on Habr√© is not updated and it is possible that it is already somewhat outdated.  So, please ask for a more recent text to the original: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub, table of contents</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="">GitHub, chapter</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 of the book, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><br><a name="habracut"></a>  There is some misconception that <code>IDisposable</code> is made to free unmanaged resources.  And this is only part of the truth.  In order to understand at once that this is not the case, it suffices to recall examples of unmanaged resources.  Is the <code>File</code> class unmanaged?  Not.  Maybe <code>DbContext</code> ?  Again - no.  An unmanaged resource is something that is not part of the .NET type system.  That which was not created by the platform, and is outside of its scopa.  A simple example is a handle to an open file in the operating system.  A handle is a number that uniquely identifies a file opened by the operating system.  Not by you, but by the operating system.  Those.  all control structures (such as file system coordinates on the file system, its fragments in the case of fragmentation and other service information, cylinder numbers, heads, sectors in the case of magnetic HDD) are not inside the .NET platform, but inside the OS.  And the only unmanaged resource that goes into the .NET platform is the IntPtr-number.  This number in turn turns around FileSafeHandle, which in turn turns around the File class.  Those.  File class itself is not an unmanaged resource, but it accumulates an unmanaged resource in itself through an additional layer ‚Äî the open file descriptor IntPtr.  How do you read from such a file?  Through a series of methods WinAPI or OS Linux. <br><br>  The second example of unmanaged resources are synchronization primitives in multithreaded and multiprocess programs.  Such as mutexes, semaphores.  Or the data arrays that are transmitted via p / invoke. <br><br>  Good.  With unmanaged resources sorted out.  Why IDisposable in these cases?  Because the .NET Framework has no idea about what is happening where it does not exist.  If you open a file using OS functions, .NET will not know anything about this.  If you allocate a section of memory for your own needs (for example, with the help of VirtualAlloc), .NET also does not know anything about it.  And if he doesn‚Äôt know anything about it, he will not free the memory that was busy calling VirtualAlloc.  Or it will not close the file opened directly through the OS API call.  The consequences of this can be completely different and unpredictable.  You can get OutOfMemory if you add too much memory and you do not free it (for example, you simply reset the pointer for old memory) or block the file on the file ball for a long time if it was opened through the OS, but was not closed .  The example with file balls is especially good, because the lock will remain even after the application is closed: the openness of the file is controlled by the side on which it is located.  And the remote side will not receive the signal to close the file if you have not closed it yourself. <br><br>  In all these cases, a universal and recognizable interaction protocol between the type system and the programmer is needed, which will unambiguously identify those types that require forced closure.  This _protocol_ is the IDisposable interface.  And it sounds like this: if the type contains an implementation of the IDisposable interface, then after you finish working with its instance, you must call <code>Dispose()</code> . <br><br>  And for this reason, there are two standard ways to call it.  After all, as a rule, you either create an instance of an entity in order to work with it quickly within the framework of one method, or within the lifetime of an instance of your entity. <br><br>  The first option is when you wrap an instance in <code>using(...){ ... }</code> .  Those.  You expressly indicate that at the end of the block using the object must be destroyed.  Those.  must be called <code>Dispose()</code> .  The second option is to destroy it at the end of the lifetime of the object, which contains a link to the one that must be released.  But after all, in .NET, apart from the finalization method, there is nothing that would hint at the automatic destruction of an object.  Right?  But the finalization does not suit us at all for the reason that it will be unknown when called.  And we need to release exactly when it is necessary: ‚Äã‚Äãright after we no longer need, for example, an open file.  That is why we also need to implement IDisposable on ourselves and in the Dispose method, call Dispose on everyone we owned in order to release them too.  Thus, we observe the _protocol_ and this is very important.  After all, if someone began to observe a certain protocol, all participants in the process must observe it: otherwise there will be problems. <br><br><h3>  IDisposable implementation variations </h3><br><br>  Let's go in implementations of IDisposable from simple to complex. <br><br>  The first and simplest implementation that can come to mind is simply to take and implement IDisposable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResourceHolder</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { DisposableResource _anotherResource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DisposableResource(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _anotherResource.Dispose(); } }</code> </pre><br><br>  Those.  for starters, we create an instance of some resource that needs to be freed and in the Dispose () method it is freed. <br>  The only thing that is not here and what makes the implementation non-consistent is the possibility of further working with an instance of the class after its destruction with the <code>Dispose()</code> method: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResourceHolder</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DisposableResource _anotherResource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DisposableResource(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_disposed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _anotherResource.Dispose(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckDisposed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_disposed) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectDisposedException(); } } }</code> </pre><br><br>  The call <code>CheckDisposed()</code> must be called the first expression in all public methods of the class.  However, if for destroying a managed resource, which is a <code>DisposableResource</code> , the resulting structure of the <code>ResourceHolder</code> class looks fine, then for the case of encapsulating an unmanaged resource, it is not. <br><br>  Let's think up a variant with an uncontrollable resource. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileWrapper</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { IntPtr _handle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _handle = CreateFile(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr.Zero); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CloseHandle(_handle); } [DllImport(<span class="hljs-string"><span class="hljs-string">"kernel32.dll"</span></span>, EntryPoint = <span class="hljs-string"><span class="hljs-string">"CreateFile"</span></span>, SetLastError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile</span></span></span><span class="hljs-function">)</span></span>; [DllImport(<span class="hljs-string"><span class="hljs-string">"kernel32.dll"</span></span>, SetLastError=<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloseHandle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr hObject</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><br>  So what's the difference in the behavior of the last two examples?  In the first variant, we describe the interaction of a managed resource with another managed one.  This means that if the program works correctly, the resource will be released anyway.  After all, we have <code>DisposableResource</code> - managed, which means that the .NET CLR knows it perfectly well and, in the case of incorrect behavior, will free up memory from under it.  Notice that I intentionally make no assumption that the type of <code>DisposableResource</code> encapsulates.  There can be any kind of logic and structure.  It can contain both managed and unmanaged resources.  <b>We should not care</b> .  We are not asked to decompile other people's libraries every time and see which types they use: managed or unmanaged resources.  And if <i>our type</i> uses an unmanaged resource, we cannot but know.  We do this in the <code>FileWrapper</code> class.  So what happens in this case? <br><br>  If we use unmanaged resources, it turns out that we again have two options: when everything is fine and Dispose method volunteered (then everything is fine :)) and when something happened and Dispose method could not work.  Immediately make a reservation why this may not happen: <br><ul><li>  If we use <code>using(obj) { ... }</code> , then an exception may occur in the internal code block, which is intercepted by a <code>finally</code> block that is not visible to us (this is C # syntactic sugar).  In this block, Dispose is implicitly called.  However, there are cases when this does not happen.  For example, <code>StackOverflowException</code> , which is not caught by either <code>catch</code> or <code>finally</code> .  It is always necessary to take into account.  After all, if you have a certain stream go into recursion and at some point take off via a <code>StackOverflowException</code> , then those resources that were captured and not released are forgotten by .NET.  After all, he has no idea how to release unmanaged resources: they will hang in memory until the OS releases them themselves (for example, when you exit your program. And sometimes indefinitely after the application has finished). </li><li>  If we call Dispose () from another Dispose ().  Then it may happen that, again, we cannot reach it.  And then the question is not in the forgetfulness of the author of the application: they say, I forgot to call Dispose ().  Not.  Again, the question is in any exceptions.  But now it‚Äôs not just about exceptions that crash the application.  Here we are talking about any exceptions, which will lead to the fact that the algorithm does not reach the call to an external Dispose () that ours will call. </li></ul><br><br>  In all such cases, there will be a situation of uncontrolled resources suspended in the air.  After all, Garbage Collector has no idea what they need to collect.  The maximum that he will do - during the next pass he will understand that the graph of the objects containing our <code>FileWrapper</code> object is lost, the last link is lost and the memory will be erased by those objects to which there are links. <br><br>  How to protect against this?  For these cases, we must implement the object finalizer.  It is not by chance that the finalizer has this name.  This is not a destructor at all, as it may initially seem because of the similarity of the declaration of finalizers in C # and destructors in C ++.  The finalizer, unlike the destructor, will invoke * guaranteed *, whereas the destructor may not be called (exactly like <code>Dispose()</code> ).  The finalizer is called when the Garbage Collection is launched (so far this knowledge is enough, but in fact everything is somewhat more complicated), and is intended to guarantee the release of the captured resources if <i>something went wrong</i> .  And for the case of the release of unmanaged resources, we <i>are obliged to</i> implement the finalizer.  Also, I repeat, due to the fact that the finalizer is called when the GC starts, in general, you have no idea when this will happen. <br><br>  Let's expand our code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileWrapper</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { IntPtr _handle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _handle = CreateFile(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr.Zero); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InternalDispose(); GC.SuppressFinalize(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> other methods }</span></span></code> </pre><br><br>  We strengthened the example of knowledge about the process of finalization and thus secured the application from losing information about resources, if something went wrong and Dispose () would not be called.  Additionally, we made a call to GC.SuppressFinalize in order to disable the finalization of an instance of a type if Dispose () was called for it.  We do not need to release the same resource twice?  It is also worth doing for another reason: we remove the load from the queue for finalization, speeding up a random piece of code, in parallel with which finalization will work in a random future. <br><br>  Now let us further strengthen our example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileWrapper</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { IntPtr _handle; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _handle = CreateFile(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr.Zero); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_disposed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _disposed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; InternalDispose(); GC.SuppressFinalize(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } [MethodImpl(MethodImplOptions.AggressiveInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckDisposed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_disposed) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectDisposedException(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> other methods }</span></span></code> </pre><br><br>  Now our example implementation of a type that encapsulates an unmanaged resource looks complete.  Re- <code>Dispose()</code> , unfortunately, is the de facto standard of the platform and we allow it to be called.  I note that often people allow <code>Dispose()</code> to be called again in order to avoid a hassle with the calling code, and this is not correct.  However, a user of your library with an eye on MS documentation may not consider this and allow multiple calls to <code>Dispose()</code> .  Calling other public methods in any case breaks the integrity of the object.  If we destroyed an object, then it is no longer possible to work with it.  This in turn means that we are obliged to insert a <code>CheckDisposed</code> call at the beginning of each public method. <br><br>  However, in this code there is a very serious problem that will prevent it from working as we had in mind.  If we remember how the garbage collection process works, then we notice one detail.  When garbage collection GC <i>in the first place</i> finalizes everything that is directly inherited from <i>Object</i> , and then is taken for those objects that implement the <i>CriticalFinalizerObject</i> .  In our case, it turns out that both the classes we designed inherit Object: and this is a problem.  We have no idea in what order we will go to the "last mile."  However, a higher-level object may try to work with an object that stores an unmanaged resource ‚Äî in its finalizer (although this already sounds like a bad idea).  Here the order of finalization would be very useful to us.  And in order to set it - we must inherit our type, which encapsulates an unmanaged resource, from CriticalFinalizerObject. <br><br>  The second reason has deeper roots.  Imagine that you allowed yourself to write an application that does not care much about memory.  Allotsiruet in large quantities without caching and other intricacies.  Once such an application fails with an OutOfMemoryException.  And when the application crashes with this exception, special conditions for the execution of the code arise: it cannot try to allocate anything.  After all, this will lead to re-exclusion, even if the previous one was caught.  This does not mean that we should not create new instances of objects.  A simple method call can cause this exception.  For example, a call to the finalization method.  Recall that methods are compiled when they are called for the first time.  And this is the usual behavior.  How to protect yourself from this problem?  Easy enough.  If you inherit an object from CriticalFinalizerObject, then all methods of this type will be compiled immediately when loading the type into memory.  Moreover, if you mark methods with the <code>[PrePrepareMethod]</code> attribute, they will also be precompiled and will be safe from the point of view of the call if there are not enough resources. <br><br>  Why is this so important?  Why spend so much effort on those who go into another world?  And the thing is that unmanaged resources can hang in the system for a very long time.  Even after your application has finished.  Even after restarting the computer (if the user opens a file with file balls in your application, it will be blocked by the remote host and released either by timeout or when you release the resource by closing the file. If your application crashes during the open file, it will not be closed even after a reboot. You have to wait long enough for the remote host to release it).  Plus, you should not allow throwing exceptions in finalizers - this will lead to an accelerated death of the CLR and the final release from the application: the finalizer calls do not turn into <code>try .. catch</code> .  Those.  when freeing a resource, you need to be sure that it can still be released.  And the last no less interesting fact is that if the CLR performs emergency unloading of the domain, the finalizers of types derived from CriticalFinalizerObject will also be called, unlike those who inherit directly from Object. <br><br><h4>  SafeHandle / CriticalHandle / SafeBuffer / derivatives </h4><br><br>  I have some feeling that I‚Äôll open a Pandora‚Äôs box for you now.  Let's talk about special types: SafeHandle, CriticalHandle and their derivatives.  And finally, we finish our type template, which provides access to the unmanaged resource.  But before that, let's try to list everything that comes to us from the unmanaged world: <br><br><ul><li>  The first and most anticipated thing that usually comes from there are handles.  For a .NET developer, this may be an absolutely empty word, but it is a very important part of the operating system world.  But in essence, a handle is a 32-bit or 64-bit number that defines an open session of interaction with the operating system.  Ie, for example, you open the file to work with it, and in response to the WinApi-function, you received a handle.  Then, using it, you can continue to work with it: do * Seek *, * Read *, * Write * operations.  The second example: open the socket to work with the network.  And again: the operating system will give you a handle.  In the .NET world, descriptors are stored in the * IntPtr * type; </li><li>  The second is data arrays.  There are several ways to work with unmanaged arrays: either work with it through unsafe code (unsafe keyword), or use SafeBuffer, which will wrap the data buffer with a convenient .NET class.  I note that even though the first method is faster (you can greatly optimize cycles, for example), then the second method is much safer.  After all, he uses SafeHandle as the basis for work; </li><li>  Strings.  With strings, everything is somewhat simpler, because our task is to determine the format and encoding of the string we are taking.  Next, the line is copied to us (the string class is immutable) and we don‚Äôt think further about anything. </li><li>  ValueTypes, which are taken by copying and whose fate there is no need to think at all. </li></ul><br><br>  SafeHandle is a special .NET CLR class that inherits CriticalFinalizerObject and is designed to wrap operating system descriptors as safely and conveniently as possible. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SecurityCritical, SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode=true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SafeHandle</span></span> : <span class="hljs-title"><span class="hljs-title">CriticalFinalizerObject</span></span>, <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IntPtr handle; <span class="hljs-comment"><span class="hljs-comment">// ,    private int _state; //  (,  ) private bool _ownsHandle; //    handle.   ,     handle       private bool _fullyInitialized; //   [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle) { } //     Dispose(false) [SecuritySafeCritical] ~SafeHandle() { Dispose(false); } //  hanlde    ,     p/invoke Marshal -  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected void SetHandle(IntPtr handle) { this.handle = handle; } //    ,   IntPtr     .  //   ,    ,       //   .  ,      : // -        SetHandleasInvalid, DangerousGetHandle //       . // -        .     // ,       .       // IntPtr   ,             //      IntPtr [ResourceExposure(ResourceScope.None), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public IntPtr DangerousGetHandle() { return handle; } //   (    ) public bool IsClosed { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get { return (_state &amp; 1) == 1; } } //      .    ,  . public abstract bool IsInvalid { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get; } //     Close() [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Close() { Dispose(true); } //     Dispose() [SecuritySafeCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Dispose() { Dispose(true); } [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected virtual void Dispose(bool disposing) { // ... } //       ,  ,  handle    . //     ,    [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void SetHandleAsInvalid(); //   ,  ,     // .       , ..   //    ,      . //   -     . //     = false,    // SafeHandleCriticalFailure,     SafeHandleCriticalFailure // Managed Debugger Assistant    . [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected abstract bool ReleaseHandle(); //    .      [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void DangerousAddRef(ref bool success); public extern void DangerousRelease(); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To evaluate the usefulness of a group of classes derived from SafeHandle, it is enough to remember what all the .NET types are good for: the automation of garbage collection. Thus, wrapping an unmanaged resource, SafeHandle gives it the same properties, because is manageable. Plus, it contains an internal counter for external links that cannot be counted by the CLR.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">links from unsafe code. There is almost no need to manually increase and decrease the counter: when you declare any type that derives from SafeHandle as an unsafe method parameter, then when entering the method, the counter will be increased, and when you exit, it will be reduced. This property was introduced for the reason that when you went into unsafe code, passing a descriptor there, then in another thread (if you, of course, work with one descriptor from several threads), reset the link to it, you will get the assembled SafeHandle. With the counter of links, everything is simpler: SafeHandle will not be assembled until the counter is additionally reset. That is why manually change the counter is not worth it. Either this must be done very carefully: returning it as soon as it becomes possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second assignment of the reference counter is the task of the order of finalization</font></font><code>CriticalFinalizerObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that link to each other. If one SafeHandle-based type refers to another SafeHandle-based type, then in the constructor of the referencing it is necessary to further increase the reference count, and in the ReleaseHandle method - to decrease. Thus, your object will not be destroyed until the one to which you referred is destroyed. However, in order not to be confused, you should avoid such situations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's write the final version of our class, but now with the latest knowledge about SafeHandlers:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileWrapper</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { SafeFileHandle _handle; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _handle = CreateFile(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr.Zero); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_disposed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _disposed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _handle.Dispose(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckDisposed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_disposed) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectDisposedException(); } } [DllImport(<span class="hljs-string"><span class="hljs-string">"kernel32.dll"</span></span>, EntryPoint = <span class="hljs-string"><span class="hljs-string">"CreateFile"</span></span>, SetLastError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> SafeFileHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> other methods }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What makes it different? Knowing that if you set any SafeHandle-based type as the return value in the DllImport method, Marshal will correctly create and initialize it by setting the usage counter to 1, we set the SafeFileHandle type as the return value for the CreateFile kernel function. When we receive it, we will use it when we call ReadFile and WriteFile (because when we call, the counter will increase again, and when it exits, it will decrease, which will give us a guarantee of the existence of a handle for the entire time of reading and writing to the file). This type is designed correctly, which means that it is guaranteed to close the file descriptor. Even when the process crashes. And this means that we do not need to implement our finalizer and everything connected with it. Our type is much simpler.</font></font><br><br><h3>  Multithreading </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's talk about thin ice. In the previous parts of the story about IDisposable, we spoke about one very important concept, which lies not only at the basis of the design of Disposable types, but also in the design of any type: the concept of the integrity of an object. This means that at any time an object is in a strictly defined state and any action on it translates its state into one of the predetermined ones - when designing the type of this object. In other words - no action on an object should be able to transfer its state to one that was not defined. This implies a problem in the previously designed types: they are not thread-safe. There is a potential possibility of calling public methods of these types while the object is being destroyed. Let's solve this problem and decide whether to solve it at all.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileWrapper</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { IntPtr _handle; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _disposingSync = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _handle = CreateFile(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr.Zero); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Seek</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(_disposingSync) { CheckDisposed(); <span class="hljs-comment"><span class="hljs-comment">// Seek API call } } public void Dispose() { lock(_disposingSync) { if(_disposed) return; _disposed = true; } InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { lock(_disposingSync) { if(_disposed) { throw new ObjectDisposedException(); } } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation of the critical section on the verification code </font></font><code>_disposed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Dispose () and in fact</font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">installation of the critical section on the entire code of public methods. </font><font style="vertical-align: inherit;">This will solve our problem of simultaneously entering the public method of the type instance and the method of its destruction, however, it will create a delayed-action timer for a number of other problems:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intensive work with instance methods of the type, as well as work on the creation and destruction of objects will lead to a strong subsidence in performance. </font><font style="vertical-align: inherit;">The thing is that taking a lock takes some time. </font><font style="vertical-align: inherit;">This time is necessary for the allocation of the SyncBlockIndex tables, checks for the current stream and much more (we will look at all of this separately - in the section on multithreading).</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it turns out that for the sake of the ‚Äúlast mile‚Äù of the life of the object, we will pay productivity all the time of its life! </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional memory traffic for synchronization objects </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional steps to bypass the object graph with GC </font></font></li></ul><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second, and in my opinion, the most important. </font><font style="vertical-align: inherit;">We assume a situation of simultaneous destruction of an object with the opportunity to work with it once more. </font><font style="vertical-align: inherit;">What should we hope for in this case? </font><font style="vertical-align: inherit;">What does not shoot? </font><font style="vertical-align: inherit;">After all, if Dispose works first, then further handling of the object's methods must result in </font></font><code>ObjectDisposedException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This leads to a simple conclusion: the synchronization between calls to Dispose () and other public methods of the type must be delegated to the serving party.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the code that created the class instance </font></font><code>FileWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">After all, only the creating side is aware of what it is going to do with the class instance and when it is going to destroy it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two Levels Disposable Design Principle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the most popular implementation pattern </font></font><code>IDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">found in books on .NET development and on the World Wide Web? What kind of template do people in companies expect from you when you go to interview for a potentially new job? Most likely this:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Disposable</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Dispose(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); GC.SuppressFinalize(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(disposing) { <span class="hljs-comment"><span class="hljs-comment">//    } //    } protected void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } ~Disposable() { Dispose(false); } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is wrong here and why have we never written like that earlier in this book? </font><font style="vertical-align: inherit;">In fact, the template is good and without unnecessary words covers all life situations. </font><font style="vertical-align: inherit;">But its use everywhere, in my opinion, is not the rule of good tone: after all, we practically never see real unmanaged resources in practice, and in this case, the half-template works as idle. </font><font style="vertical-align: inherit;">Moreover, it violates the principle of sharing responsibility. </font><font style="vertical-align: inherit;">After all, it simultaneously manages both managed resources and unmanaged ones. </font><font style="vertical-align: inherit;">In my humble opinion, this is completely wrong. </font><font style="vertical-align: inherit;">Let's look at a slightly different approach. </font><font style="vertical-align: inherit;">* Disposable Design Principle *. </font><font style="vertical-align: inherit;">In short, the essence is as follows: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disposing is divided into two levels of classes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Level 0 types directly encapsulate unmanaged resources. </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> They are either abstract or packed. </font></font></li><li>     : <br><ul><li> PrePrepareMethod,         </li><li> SecuritySafeCritical,       ,    </li><li> ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success / MayFail)]   CER        </li></ul><br></li><li>      ,      ,      ¬´ ¬ª </li></ul></li><li>  Level 1     <br><ul><li>     Level 1   IDisposable  </li><li>      Level 0  CriticalFinalizerObject </li><li>     Level 1  Level 0 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement IDisposable.Dispose by destroying the encapsulated objects in order: Level 0 types first, then Level 1 types </font></font></li><li>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> they do not have unmanaged resources - they don‚Äôt implement the finalizer </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It must contain a protected property giving access to Level 0 types. </font></font></li></ul><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is why from the very beginning I introduced division into two types: into a containing managed resource and containing an unmanaged resource. </font><font style="vertical-align: inherit;">They have to work completely differently.</font></font><br><br><h3>  Results </h3><br><h4>  pros </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have learned a lot about this simplest pattern. </font><font style="vertical-align: inherit;">Let's define its advantages:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The main advantage of the template is the possibility of deterministic release of resources: when necessary </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introducing a well-known way to find out that a particular type requires the destruction of its instances at the end of its use. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With proper implementation of the template, the work of the designed type will become safe from the point of view of using third-party components, as well as from the point of view of unloading and destruction of resources during the process collapse (for example, due to lack of memory) </font></font></li></ol><br><br><h4>  Minuses </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I see a lot more disadvantages of the template than advantages: </font></font><br><ol><li>    ,   ,   ,     ,    :  ,    .     ,             ,      . , ,   IDE ( ,  Dis‚Ä¶  ,        ).   Dispose ,    .               ,    .  :     <pre> <code class="hljs xml">IEnumerator<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre>    <code>IDisposable</code> ? </li><li> ,    ,    IDisposable    :       IDisposable.      ¬´¬ª   ,   .    ,       .   ,    * -*,   .  Dispose() ‚Äî    .       * *.    ‚Äî  ,    ; </li><li>   , Dispose()     .        **.    .     ,    CheckDisposed()     .      ,     : ¬´  !¬ª; </li><li>      ,   <code>IDisposable</code>  *explicit* .   ,  IDisposable   ,    . ,     .      Dispose(),       ; </li><li>   .       .         GC   . , ,    DisposableObject,    ,  <code>virtual void Dispose()</code>   ,      ,   ; </li><li>   <code>Dispose()</code>      ,   <code>tor</code>   .              disposing  . </li><li> ,     ,      , ‚Äî       **   .      ,  Dispose()      .         . ,  Lifetime. </li></ol><br><br><h4>  Grand total </h4><br><ol><li> IDisposable            .  ,         ,        ; </li><li>  IDisposable    .     ,        ,  Garbage Collector; </li><li>   IDisposable      Dispose()    .       :      ,    IDisposable ; </li><li>           .  Those.     ,       :  ,   SafeHandle / CriticalHandle / CriticalFinalizerObject.                  Dispose():      . </li><li>         ,     . ,    Inversion of Control       <code>Lifetime</code> ,       . </li></ol><br><br><blockquote><h3>  Link to the whole book </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 books, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/341864/">https://habr.com/ru/post/341864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341854/index.html">Digital Transformation: The Beginning</a></li>
<li><a href="../341856/index.html">On the issue of statistics (in terms of SDR)</a></li>
<li><a href="../341858/index.html">Preparing for release in the App Store. Instructions for beginners and life hacking</a></li>
<li><a href="../341860/index.html">uSpeech - startup development (2). Run Android version and where to get the first customers</a></li>
<li><a href="../341862/index.html">Prometheus</a></li>
<li><a href="../341866/index.html">‚ÄúHouston, we have problems‚Äù: what difficulties of web studios will the hosting provider help to figure out</a></li>
<li><a href="../341868/index.html">Problems with data management? How AI and machine learning can solve one of the biggest problems.</a></li>
<li><a href="../341870/index.html">Selected chapters of the control theory on fingers: linear observers of dynamic systems</a></li>
<li><a href="../341872/index.html">The announcement of the mitap ThinkPHP # 15 in Kharkov</a></li>
<li><a href="../341874/index.html">Web application on Node and Vue, part 3: client and server development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>