<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ruby Memory Troubleshooting Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surely there are lucky Ruby developers who have never suffered from memory problems. But everyone else has to spend an incredible amount of energy to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ruby Memory Troubleshooting Guide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/424/36e/010/42436e010844446a90e82f023fb90442.jpg"><br><br>  Surely there are lucky Ruby developers who have never suffered from memory problems.  But everyone else has to spend an incredible amount of energy to figure out why memory usage has gone out of control and eliminate the causes.  Fortunately, if you have a fairly modern version of Ruby (starting with 2.1), then you have access to great tools and techniques for solving common problems.  It seems to me that memory optimization can bring joy and satisfaction, but I can be alone in my opinion. <br><a name="habracut"></a><br>  As with all forms of optimization, it is possible that this will lead to more complex code.  So it‚Äôs not worth it if you don‚Äôt get measurable and significant benefits. <br><br>  All the procedures described below are performed using canonical MRI Ruby 2.2.4, but other versions 2.1+ should work in the same way. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  This is not a memory leak! </h1><br>  When a memory problem arises, only one thing comes to mind first - a leak.  For example, you can see in a web application that after starting a server, repeated calls to the same function consume more and more memory each time.  Of course, there are indeed leaks, but I‚Äôm ready to argue that there are many more problems that look like leaks, but they are not. <br><br>  Consider a fictional example: over and over again we will create and drop a large array of hashes.  Here is the part of the code that will be used in various examples in this article: <br><br><pre><code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># common.rb require "active_record" require "active_support/all" require "get_process_mem" require "sqlite3" ActiveRecord::Base.establish_connection( adapter: "sqlite3", database: "people.sqlite3" ) class Person &lt; ActiveRecord::Base; end def print_usage(description) mb = GetProcessMem.new.mb puts "#{ description } - MEMORY USAGE(MB): #{ mb.round }" end def print_usage_before_and_after print_usage("Before") yield print_usage("After") end def random_name (0...20).map { (97 + rand(26)).chr }.join end</span></span></code> </pre> <br>  Build an array: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># build_arrays.rb require_relative "./common" ARRAY_SIZE = 1_000_000 times = ARGV.first.to_i print_usage(0) (1..times).each do |n| foo = [] ARRAY_SIZE.times { foo &lt;&lt; {some: "stuff"} } print_usage(n) end</span></span></code> </pre><br>  <a href="https://github.com/schneems/get_process_mem">get_process_mem</a> is a convenient way to get information about the memory used by the current Ruby process.  We see the behavior described above: a gradual increase in memory consumption. <br><br><pre> <code class="ruby hljs">$ ruby build_arrays.rb <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">330</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">481</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">492</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">559</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">584</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">588</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">591</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">603</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">613</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">621</span></span></code> </pre><br>  But if you perform more iterations, consumption growth will stop. <br><br><pre> <code class="ruby hljs">$ ruby build_arrays.rb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">323</span></span> ... <span class="hljs-number"><span class="hljs-number">32</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">700</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">699</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">698</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">698</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">696</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">696</span></span> <span class="hljs-number"><span class="hljs-number">38</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">696</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">701</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">697</span></span></code> </pre><br>  This suggests that we are not dealing with a leak.  Either the leak is so small that we do not notice it compared to the rest of the memory used.  But it is not clear why memory consumption grows after the first iteration.  Yes, we create a large array, but then correctly reset it to zero and begin to create a new one of the same size.  Is it not possible to take the same memory that was used by the previous array? <br><br>  Not. <br><br>  In addition to setting up the garbage collector, you cannot control the time it starts.  In our example of <code>build_arrays.rb</code> we see that new memory allocations are made before the garbage collector cleans up our old, dropped objects. <br><br>  <b>Do not worry if you find an unexpected increase in memory consumption by your application.</b>  <b>There can be many reasons for this, not just leaks.</b> <br><br>  I must point out that we are not talking about some kind of nightmare memory management characteristic of Ruby.  But the question as a whole is related to all languages ‚Äã‚Äãused by garbage collectors.  To verify this, I reproduced the above example on Go and got a similar result.  True, it uses Ruby libraries, which could be the cause of this memory problem. <br><br><h1>  Divide and rule </h1><br>  So, if we need to work with large amounts of data, then we are doomed to lose a lot of RAM?  Fortunately, this is not the case.  If we take the previous example and reduce the size of the array, we will find that the memory consumption will even out earlier. <br><br><img src="https://habrastorage.org/files/7da/cd2/40b/7dacd240b7e040d1951d0d2e09a90e57.jpg"><br><br>  This means that if we can break our work into smaller fragments and process it to eliminate the simultaneous use of a large number of objects, we will avoid a strong increase in memory consumption.  Unfortunately, for this, you often have to take clean and beautiful code and turn it into a more cumbersome one, which does the same thing, but more efficiently in terms of memory. <br><br><h1>  Isolating memory hot spots </h1><br>  Often in the code, the source of the memory problem is not as obvious as in the <code>build_arrays.rb</code> example.  You must first isolate the cause and only then begin to study it, because erroneous conclusions about the cause of the problem can easily be made. <br><br><img src="https://habrastorage.org/files/bfa/a0b/142/bfaa0b142a8448bfbe66fed33a5bb295.gif"><br><br>  I usually use two approaches to identify memory problems, often combining: <br><br><ul><li>  I leave the code unchanged and wrap it in the profiler; </li><li>  I track the memory usage of the process, removing / adding different parts of the code that may be causing the problem. </li></ul><br>  Here, as a profiler, I will use <a href="https://github.com/SamSaffron/memory_profiler">memory_profiler</a> ( <a href="https://github.com/ruby-prof/ruby-prof">ruby-prof is</a> also popular), and for monitoring I'll take <a href="https://github.com/schneems/derailed_benchmarks">derailed_benchmarks</a> , which has some great features that are typical of Rails. <br><br>  Here is a sample code that uses a lot of memory.  It is not clear on the fly at what stage it is consumed the most: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># people.rb require_relative "./common" def run(number) Person.delete_all names = number.times.map { random_name } names.each do |name| Person.create(name: name) end records = Person.all.to_a File.open("people.txt", "w") { |out| out &lt;&lt; records.to_json } end</span></span></code> </pre><br>  With <a href="https://github.com/schneems/get_process_mem">get_process_mem,</a> you can quickly find out what is the most memory used to create <code>Person</code> records. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># before_and_after.rb require_relative "./people" print_usage_before_and_after do run(ARGV.shift.to_i) end</span></span></code> </pre><br>  Result: <br><br><pre> <code class="ruby hljs">$ ruby before_and_after.rb <span class="hljs-number"><span class="hljs-number">10000</span></span> Before - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">37</span></span> After - MEMORY USAGE(MB): <span class="hljs-number"><span class="hljs-number">96</span></span></code> </pre><br>  There are several places in this code that can take a lot of memory: creating a large array of strings, calling <code>#to_a</code> to create a large array of Active Record objects (not the best idea, but this is for demonstration) and serializing an array of Active Record objects. <br><br>  Perform code profiling to understand where memory allocations take place: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># profile.rb require "memory_profiler" require_relative "./people" report = MemoryProfiler.report do run(1000) end report.pretty_print(to_file: "profile.txt")</span></span></code> </pre><br>  Please note that <code>run</code> here is fed ten times less than in the previous example.  The profiler itself consumes a lot of memory, and this can lead to its exhaustion during the profiling of code that has already occupied a large amount. <br><br>  The file is quite long, it includes the allocation and retention of memory and objects in the gem, files, as well as levels of accommodation.  The real abundance of information in which there are a couple of interesting parts: <br><br><pre> <code class="ruby hljs">allocated memory by gem ----------------------------------- <span class="hljs-number"><span class="hljs-number">17520444</span></span> activerecord-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7305511</span></span> activesupport-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">2551797</span></span> activemodel-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">2171660</span></span> arel-<span class="hljs-number"><span class="hljs-number">6.0</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2002249</span></span> sqlite3-<span class="hljs-number"><span class="hljs-number">1.3</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ... allocated memory by file ----------------------------------- <span class="hljs-number"><span class="hljs-number">2840000</span></span> /Users/bruz/.rvm/gems/ruby-<span class="hljs-number"><span class="hljs-number">2.2</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>/gems/activesupport-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span>/lib/activ e_support/hash_with_indifferent_access.rb <span class="hljs-number"><span class="hljs-number">2006169</span></span> /Users/bruz/.rvm/gems/ruby-<span class="hljs-number"><span class="hljs-number">2.2</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>/gems/activerecord-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span>/lib/active _record/type/time_value.rb <span class="hljs-number"><span class="hljs-number">2001914</span></span> /Users/bruz/code/mem_test/people.rb <span class="hljs-number"><span class="hljs-number">1655493</span></span> /Users/bruz/.rvm/gems/ruby-<span class="hljs-number"><span class="hljs-number">2.2</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>/gems/activerecord-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span>/lib/active _record/connection_adapters/sqlite3_adapter.rb <span class="hljs-number"><span class="hljs-number">1628392</span></span> /Users/bruz/.rvm/gems/ruby-<span class="hljs-number"><span class="hljs-number">2.2</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>/gems/activesupport-<span class="hljs-number"><span class="hljs-number">4.2</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span>/lib/activ e_support/json/encoding.rb</code> </pre><br>  Most distributions occur within Active Record.  This seems to indicate either instantiating all the objects in the <code>records</code> array, or serializing with <code>#to_json</code> .  Next, we can test the memory usage without a profiler, removing suspicious places.  We cannot disable the extraction of <code>records</code> , so let's start with serialization. <br><br> <code># File.open("people.txt", "w") { |out| out &lt;&lt; records.to_json }</code> <br> <br>  Result: <br><br><pre> <code class="ruby hljs">$ ruby before_and_after.rb <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">Before:</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> MB <span class="hljs-symbol"><span class="hljs-symbol">After:</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span> MB</code> </pre><br>  It seems that this is where the most memory is consumed: the ratio between before and after is 81%.  You can see what happens if we stop forcing to create a large archive of records. <br><br><pre> <code class="ruby hljs"> <span class="hljs-comment"><span class="hljs-comment"># records = Person.all.to_a records = Person.all # File.open("people.txt", "w") { |out| out &lt;&lt; records.to_json }</span></span></code> </pre><br>  Result: <br><br><pre> <code class="ruby hljs">$ ruby before_and_after.rb <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">Before:</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> MB <span class="hljs-symbol"><span class="hljs-symbol">After:</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> MB</code> </pre><br>  Memory consumption is also reduced, although an order of magnitude less than when serialization is disabled.  Now we know the main culprit, and we can decide on optimization. <br><br>  Although this is a made-up example, the approaches described here are applicable to real-world problems.  The results of profiling may not give a clear result and a specific source of the problem, and besides, they can be interpreted incorrectly.  So it is better to additionally check the actual memory usage, including and disabling parts of the code. <br><br>  Next, we look at some common situations where memory usage becomes a problem, and find out what optimizations can be done. <br><br><h1>  Deserialization </h1><br>  Memory problems often arise when deserializing large amounts of data from XML, JSON, or other data serialization formats.  Methods like <code>JSON.parse</code> or <code>Hash.from_xml</code> from Active Support are extremely convenient, but if there is a lot of data, a giant structure can be loaded into memory. <br><br>  If you have control over the data source, you can limit the amount of information received by adding filtering or support for loading by parts.  But if the source is external or you cannot control it, then you can use the stream deserializer.  In the case of XML, you can take <a href="https://github.com/ohler55/ox">Ox</a> , and for JSON you can <a href="https://github.com/brianmario/yajl-ruby">use yajl-ruby</a> .  Apparently, they work about the same. <br><br>  <b>The fact that you have limited memory does not mean that you cannot parse large XML or JSON documents safely.</b>  <b>Stream deserializers allow you to gradually extract what you need, while maintaining low memory consumption.</b> <br><br>  Here is an example of parsing a 1.7 MB XML file using <code>Hash#from_xml</code> . <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># parse_with_from_xml.rb require_relative "./common" print_usage_before_and_after do # From http://www.cs.washington.edu/research/xmldatasets/data/mondial/mondial-3.0.xml file = File.open(File.expand_path("../mondial-3.0.xml", __FILE__)) hash = Hash.from_xml(file)["mondial"]["continent"] puts hash.map { |c| c["name"] }.join(", ") end $ ruby parse_with_from_xml.rb Before - MEMORY USAGE(MB): 37 Europe, Asia, America, Australia/Oceania, Africa After - MEMORY USAGE(MB): 164</span></span></code> </pre><br>  111 MB per file 1.7 MB!  Absolutely inappropriate ratio.  But the version with streaming parser. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># parse_with_ox.rb require_relative "./common" require "ox" class Handler &lt; ::Ox::Sax def initialize(&amp;block) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@yield</span></span></span><span class="hljs-comment">_to = block end def start_element(name) case name when :continent </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@in</span></span></span><span class="hljs-comment">_continent = true end end def end_element(name) case name when :continent </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@yield</span></span></span><span class="hljs-comment">_to.call(</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">) if </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@in</span></span></span><span class="hljs-comment">_continent = false </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment"> = nil end end def attr(name, value) case name when :name </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment"> = value if </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@in</span></span></span><span class="hljs-comment">_continent end end end print_usage_before_and_after do # From http://www.cs.washington.edu/research/xmldatasets/data/mondial/mondial-3.0.xml file = File.open(File.expand_path("../mondial-3.0.xml", __FILE__)) continents = [] handler = Handler.new do |continent| continents &lt;&lt; continent end Ox.sax_parse(handler, file) puts continents.join(", ") end $ ruby parse_with_ox.rb Before - MEMORY USAGE(MB): 37 Europe, Asia, America, Australia/Oceania, Africa After - MEMORY USAGE(MB): 37</span></span></code> </pre><br>  Memory consumption increases slightly, and now we can handle much larger files.  But a compromise could not be avoided: now we have 28 lines of processing code, which was not needed before.  This increases the likelihood of errors, so in the production of this part must be further tested. <br><br><h1>  Serialization </h1><br>  As we saw in the chapter on isolating hot spots in memory consumption, serialization can lead to large losses.  Here is the key part of the <code>people.rb</code> example <code>people.rb</code> . <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># to_json.rb require_relative "./common" print_usage_before_and_after do File.open("people.txt", "w") { |out| out &lt;&lt; Person.all.to_json } end</span></span></code> </pre><br>  If we run it with a database of 100,000 entries, we get: <br><br><pre> <code class="ruby hljs">$ ruby to_json.rb <span class="hljs-symbol"><span class="hljs-symbol">Before:</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> MB <span class="hljs-symbol"><span class="hljs-symbol">After:</span></span> <span class="hljs-number"><span class="hljs-number">505</span></span> MB</code> </pre><br>  Here the problem with <code>#to_json</code> is that it creates an object instance for each record, and then encodes it in JSON.  You can significantly reduce memory consumption by generating JSON record by record so that there is only one record object at a time.  It seems that none of the popular Ruby JSON libraries can do this, and it is usually recommended to manually create a JSON string.  A good API for this is provided by gem <a href="https://github.com/camertron/json-write-stream">json-write-stream</a> , and then our example can be converted: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># json_stream.rb require_relative "./common" require "json-write-stream" print_usage_before_and_after do file = File.open("people.txt", "w") JsonWriteStream.from_stream(file) do |writer| writer.write_object do |obj_writer| obj_writer.write_array("people") do |arr_writer| Person.find_each do |people| arr_writer.write_element people.as_json end end end end end</span></span></code> </pre><br>  Once again, the optimization required to write more code, but the result is worth it: <br><br><pre> <code class="ruby hljs">$ ruby json_stream.rb <span class="hljs-symbol"><span class="hljs-symbol">Before:</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> MB <span class="hljs-symbol"><span class="hljs-symbol">After:</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> MB</code> </pre><br><h1>  Be lazy </h1><br>  Starting with Ruby 2.0, there is a great opportunity to do lazy enumerators (lazy enumerator).  This makes it possible to greatly reduce memory consumption when invoking an enumerator's chain of methods.  Let's start with the non-lazy code: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># not_lazy.rb require_relative "./common" number = ARGV.shift.to_i print_usage_before_and_after do names = number.times .map { random_name } .map { |name| name.capitalize } .map { |name| "#{ name } Jr." } .select { |name| name[0] == "X" } .to_a end</span></span></code> </pre><br>  Result: <br><br><pre> <code class="ruby hljs">$ ruby not_lazy.rb <span class="hljs-number"><span class="hljs-number">1_000_000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">Before:</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> MB <span class="hljs-symbol"><span class="hljs-symbol">After:</span></span> <span class="hljs-number"><span class="hljs-number">546</span></span> MB</code> </pre><br><img src="https://habrastorage.org/files/3a9/ccc/b34/3a9cccb34dc24ef2b62dfdd0338f51d2.gif"><br><br>  At each stage of the chain, iteration is performed on all elements and a new array is created that has the following method in the chain, and so on. Let's see what happens when we do it in a lazy way, simply adding the <code>lazy</code> call to the resulting enumerator: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># lazy.rb require_relative "./common" number = ARGV.shift.to_i print_usage_before_and_after do names = number.times.lazy .map { random_name } .map { |name| name.capitalize } .map { |name| "#{ name } Jr." } .select { |name| name[0] == "X" } .to_a end</span></span></code> </pre><br>  Result: <br><br><pre> <code class="ruby hljs">$ ruby lazy.rb <span class="hljs-number"><span class="hljs-number">1_000_000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">Before:</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> MB <span class="hljs-symbol"><span class="hljs-symbol">After:</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> MB</code> </pre><br>  Finally an example, giving us a huge gain in memory consumption without adding a lot of code!  Please note that if we don‚Äôt need to accumulate the results at the end, for example, if each item has been saved to the database and can be forgotten, then memory will be spent even less.  To get the enumerator result, just add the final <code>force</code> call at the end of the chain. <br><br>  It should also be noted that the first is called <code>times</code> , and then <code>lazy</code> , because the first consumes very little memory, just returning the enumerator, which generates an integer at each call.  So if you can use an enumerator instead of an array at the beginning of the chain, this is also a plus, reducing memory consumption. <br><br>  <b>It is convenient to keep everything in huge arrays and collections (map), but in real situations it is allowed only in rare cases.</b> <br><br>  You can create an enumerable for lazy data processing, for example, when working with data divided into pages.  Instead of requesting all the pages and putting them into one large array, you can output them through an enumerator, which remarkably hides all the pagination details.  For example: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">records</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enumerator</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yielder</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">has_more</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">true</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page</span></span></span><span class="hljs-function"> = 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">while</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">has_more</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page)</span></span></span></span> response.records.each { <span class="hljs-params"><span class="hljs-params">|record|</span></span> yielder record } page += <span class="hljs-number"><span class="hljs-number">1</span></span> has_more = response.has_more <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><h1>  Conclusion </h1><br>  We described Ruby's memory usage, looked at a few basic tools for tracking memory problems, and looked at common situations and optimization methods.  The considered situations do not claim to be comprehensive and illustrate the most diverse problems that I personally encountered.  However, the main result of the article is an attempt to think about how the code affects memory consumption. </div><p>Source: <a href="https://habr.com/ru/post/305426/">https://habr.com/ru/post/305426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305414/index.html">IoT and ViaLatM. Automation of sending commands to Internet of Things objects</a></li>
<li><a href="../305418/index.html">Some Hibernate Practice</a></li>
<li><a href="../305420/index.html">Invitation to the webinar "Automation of end-to-end business processes on the Oracle BPM platform"</a></li>
<li><a href="../305422/index.html">Gogs: lightweight git service</a></li>
<li><a href="../305424/index.html">Techno Breakfast "Effective work with Percona Server for MySQL on high-load web cluster projects"</a></li>
<li><a href="../305430/index.html">Hyper-Converged Solution - FusionCube and FusionSphere Openstack for the cloud service provider</a></li>
<li><a href="../305432/index.html">Yii 2.0.9</a></li>
<li><a href="../305436/index.html">New version of GitLab 8.9</a></li>
<li><a href="../305438/index.html">On the other side of the online consultant</a></li>
<li><a href="../305444/index.html">Fifth Generation Framework Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>