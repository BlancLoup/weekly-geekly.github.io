<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fighting packet loss in video conferencing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 When they talk about the transmission of video over the network, basically we are talking about video codecs and resolution. Actually,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fighting packet loss in video conferencing</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/2564771&amp;xid=17259,15700019,15700043,15700186,15700191,15700253&amp;usg=ALkJrhg0x6TrQiBcmUBdHUH-42JMHbx0PA" width="560" height="315" frameborder="0" title="Compression reel" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br>  When they talk about the transmission of video over the network, basically we are talking about video codecs and resolution.  Actually, not much is heard about video transmission.  Here I would like to shed some light on the problem of dealing with losses in the network during video transmission in the mode of video conferencing.  Why is losing so important?  Yes, because you can not just take and miss at least one video package (as opposed to audio), because  Any decent video codec is based on the fact that successive frames are not very different and it is enough to encode and transmit only the difference between frames.  It turns out that (almost) any frame depends on the previous ones.  And the picture falls apart at the loss ( <a href="http://david-o.net/wordpress/2010/08/accouchement-sonique-jerome-blanquet/">although some even like it</a> ).  Why video conferencing?  Because there is a very tough limit on real time, because the delay of 500ms per lap (round trip) is already beginning to annoy users. <br>  What are the methods to combat the loss of video packages? <a name="habracut"></a><br>  Here we consider the most common option - the transfer of media via RTP - over UDP. <br><br>  <i><b>RTP and UDP</b></i> <br>  Real-time media is typically transmitted over the RTP protocol ( <a href="http://www.ietf.org/rfc/rfc3550">RFC 3550</a> ).  Here it is important for us to know three things about him: <ol><li>  Packages are numbered in order.  So any gap in the sequence number means a loss (although it can mean a packet delay ‚Äî the difference can be very subtle). </li><li>  In addition to RTP packets, the standard also provides for service RTCP packets, with the help of which anything can be done (see below). </li><li>  As a rule, RTP is implemented over UDP.  This ensures the speedy delivery of each individual package.  A little more about TCP is written below. </li></ol><br>  Immediately, I note that here we are talking about packet networks, such as IP.  And in such networks, data is spoiled (lost) at once in large chunks - packets.  So many methods of recovering single / few errors in the signal (popular, for example, in DVB) do not work here. <br>  We will consider the fight against losses in a historical perspective (the benefit of video conferencing technology is quite young and no method is completely outdated). <br><br><h2>  Passive methods </h2><br>  <i><b>Splitting video into independent chunks</b></i> <br>  The first successful video codec for an online conference is H.263.  It was well developed basic passive methods of dealing with losses.  The easiest of them - to break the video into pieces that will be independent of each other.  Thus, the loss of a packet from one piece does not affect the decoding of the others. <br>  You need to break into pieces at least in time, but you can also in space.  The break in time consists in the periodic (usually every 2 s) keyframe generation.  This is a frame that does not depend on the entire previous history, and therefore is encoded significantly (~ 5-10 times) worse than a regular frame.  Without generating key frames for any number of losses, sooner or later the picture will fall apart. <br>  In space, the frame can also be broken.  GOBs are used for this in H.263, and slices are used in H.264.  In essence, this is the same thing - fragments of a frame, the coding of which is independent of each other.  But for proper operation, it is also necessary to ensure for each slice independence from other slices of the previous frames.  It turns out, as if in parallel, several video sequences are coded from which the final picture is geometrically collected at the output.  This, of course, spoils the quality of coding (or increases the bitrate, which, in essence, is the same). <br><img src="https://habrastorage.org/files/eb8/cba/861/eb8cba861339492cbb4c75c2aa527c62.png"><br>  <i>Dependencies between slices of two consecutive images.</i>  <i>Orange indicates areas that could have been predicted from the previous image, if not for the slice restrictions (which means these areas could be compressed 5-10 times more efficiently)</i> <br>  It is important to note here that if generating key frames is a standard procedure (for example, the first frame is always key), then ensuring true independence of slices is a very non-trivial task that may require redesigning the encoder (and how you have an encoder and how difficult it is to remake ). <br>  <i><b>Error recovery</b></i> <br><img src="https://habrastorage.org/files/3d7/d50/0f8/3d7d500f8b5649a2ab804e9ef07bdf6e.jpg"><br>  <i>Example of recovery of one lost slice (package)</i> <br>  If a loss has already occurred, you can try to recover the lost data as much as possible by the available (error resilience).  There is one standard method laid out in the H.263 codec: the lost GOB is restored by linear interpolation of the surrounding GOBs.  But in general, the picture is more complex and the decoding error propagates with each new frame (since there may be links to damaged parts of the previous frame on new frames), so that sophisticated mechanisms will come for a clever smearing of spoiled places.  In general, there is a lot of work, and in 2 seconds the keyframe will come and update the whole picture, so good implementations of this method seem to exist only in the imagination of the developers. <br>  <i><b>Forward error correction</b></i> <br>  Another good way to deal with losses is to use redundant data, i.e.  send more than you need.  But simple duplication here does not look very good exactly because there are better-quality methods in all respects.  This is called FEC ( <a href="http://www.ietf.org/rfc/rfc5109">RFC 5109</a> ) and is structured as follows.  A group of media (information) packets of a given size (for example, 5) is selected, and on their basis several (approximately the same or less) FEC packets are recognized.  It is easy to ensure that the FEC packet recovers any packet from the information group (parity-codes, for example <a href="https://tools.ietf.org/html/rfc6015">RFC 6015</a> ).  It is somewhat more difficult, but it is possible, to ensure that <i>N</i> FEC packets recover <i>N</i> information at group losses (for example, Reed-Solomon codes, <a href="https://tools.ietf.org/html/rfc5510">RFC 5510</a> ).  In general, the method is effective, often easily implemented, but very expensive in terms of the communication channel. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Active methods </h2><br>  <i><b>Package and Keyframe Retrieval</b></i> <br>  With the development of video conferencing, it quickly became clear that using passive methods would not achieve much.  We began to use active methods that are inherently obvious - you need to resend the lost packets.  There are three different re-queries: <br><ol><li>  Re-request package (NACK - negative acknowledgment).  Lost the package - asked for it again - received - decoded. </li><li>  Keyframe request (FIR - full intra-frame request).  If the decoder understands that everything went bad and for a long time, you can immediately request a keyframe that will erase the whole story and you can start decoding from scratch. </li><li>  Request to update a specific area of ‚Äã‚Äãthe frame.  The decoder may inform the encoder that some packet has been lost.  Based on this information, the encoder calculates how far the error has spread across the frame and updates the damaged region in some way.  How to realize this is clear only theoretically, I have not met any practical implementations. </li></ol><br>  With methods like decided - and how it is implemented in practice.  But in practice there are RTCP packages - that‚Äôs what you can use.  There are at least three standards for sending such requests: <br><ul><li>  <a href="http://www.ietf.org/rfc/rfc2032">RFC 2032</a> .  In fact, this is the standard for packaging the H.261 codec stream in RTP packets.  But this standard provides for re-queries of the first two types.  This standard is outdated and replaced by <a href="http://www.ietf.org/rfc/rfc4587">RFC 4587</a> , which proposes to ignore such packets. </li><li>  <a href="http://www.ietf.org/rfc/rfc4585">RFC 4585</a> .  The current standard.  Provides all three options and more.  In practice, it uses exactly NACK and FIR. </li><li> <a href="https://tools.ietf.org/html/rfc5104">RFC 5104</a> .  Also the current standard.  Partially duplicates RFC 4585 (but not compatible with it), plus a bunch of other functionality. </li></ul><br>  It is clear that active methods are much more difficult to implement than passive ones.  And not because it is difficult to form a request or re-send a package (although the support of three standards at the same time complicates the issue).  And because here you need to control what is happening, so that the re-requests are not too early (when the ‚Äúlost‚Äù package just has not reached) or too late (when it would be time to display the picture).  Well, in the case of temporary big problems in the network, passive methods restore communication within 2 seconds (the arrival of a keyframe), while the naive implementation of the re-requests can easily overload the network and never recover (something like hanging a video on Skype several years ago ). <br><img src="https://habrastorage.org/files/5a6/6a5/36c/5a66a536c1a54cef8e074c07de7e7034.png"><br>  <i>An example of video lag after a 3 second break in connection with the naive implementation of re-requests.</i> <br>  But these methods with adequate implementation are also much better.  There is no need to reduce quality by generating keyframes, splitting into slices, or to make room for FEC packets.  In general, you can achieve a very small overhead of bitrate with the same result as the ‚Äúexpensive‚Äù passive methods. <br>  <i><b>Tcp</b></i> <br>  It became more or less clear why TCP is not used.  This is the most naive method for re-requesting packages without serious control over it.  In addition, it only provides for the re-request of the package, and in any case, the re-request of the key frame will have to be implemented on top. <br><br><h2>  Intellectual methods </h2><br>  For the time being we have been concerned only with the fight against losses.  But what about the width of the channel?  Yes - channel width is important, and it ultimately manifests itself with the same losses (plus an increase in packet delivery time).  If the video codec is set to a bitrate that exceeds the width of the communication channel, then trying to deal with losses in this case is a little meaningful exercise.  In this case, you need to reduce the codec bit rate.  This is where the whole trick begins.  How to determine which bitrate to set? <br>  The main ideas are as follows: <br><ul><li>  It is necessary to accurately and quickly monitor the current situation in the network.  For example, through RTCP XR ( <a href="http://www.ietf.org/rfc/rfc3611">RFC 3611</a> ) you can receive a report on the delivered packets and their delays. </li><li>  When conditions deteriorate, reset the bitrate (what is the deterioration of conditions? How to quickly reset?). </li><li>  When conditions are normalized, you can begin to feel the upper limit of the bitrate.  To prevent the picture from falling apart, for example, you can enable FEC and raise the bitrate.  If problems occur, FEC will allow the picture to remain correct. </li></ul><br>  In general, it is intellectual methods for assessing network parameters and adjusting them for today and determine the quality of video conferencing systems.  Every serious manufacturer has its own proprietary solution.  And the development of this technology is the main competitive advantage of video conferencing systems today. <br>  By the way, the <a href="http://www.qtc.jp/3GPP/Specs/26114-7b0.pdf">3GPP TS 26.114 standard</a> (one of the main standards for building industrial VoIP networks) states that it contains a description of a similar algorithm for audio.  It‚Äôs not quite clear how good the described algorithm is, but it‚Äôs not suitable for video. <br><img src="https://habrastorage.org/files/f12/acc/7bc/f12acc7bc76a4cb1a4441d3032ebfc09.png"><br>  <i>State machine of adaptation to network conditions in the artist's view (from 3GPP TS 26.114)</i> </div><p>Source: <a href="https://habr.com/ru/post/246153/">https://habr.com/ru/post/246153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246133/index.html">Ad Visualization 1.1 - Decisions and Conclusion</a></li>
<li><a href="../246135/index.html">Home automation system TAIYITO</a></li>
<li><a href="../246137/index.html">Alex Schulz (part 1): an introduction to growth hacking</a></li>
<li><a href="../246139/index.html">Turing A-Machine and Hoara Pit-Stop Coffee Machine</a></li>
<li><a href="../246143/index.html">BEM with a human face and backend integration</a></li>
<li><a href="../246155/index.html">How the developers sat in St. Petersburg and quietly ate mushrooms, and then they wrote the OS for data storage systems</a></li>
<li><a href="../246159/index.html">Curious ecommerce statistics for 2014</a></li>
<li><a href="../246161/index.html">C # for AS3 developers. Part 1: Class Basics</a></li>
<li><a href="../246169/index.html">Meet the service HockeyApp - your assistant for analyzing the work of mobile applications</a></li>
<li><a href="../246171/index.html">How to organize an online conference in a minute: Integration of the Kato messenger and UberConference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>