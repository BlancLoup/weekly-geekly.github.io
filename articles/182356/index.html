<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization options in C and C ++ languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is believed that C ++ has significant overhead compared to C and is therefore slower. In addition, there are even articles showing advantages in sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization options in C and C ++ languages</h1><div class="post__text post__text-html js-mediator-article">  It is believed that C ++ has significant overhead compared to C and is therefore slower.  In addition, there are even articles showing advantages in speed of languages ‚Äã‚Äãwith compilation on the fly (JIT - Just-in-time compilation), such as Java and C #.  We will leave the last to those who consider them fast, but we will explain why this is not so.  And we compare C and C ++ using the example of a data retrieval task. <br>  The task of data retrieval is often found in: web services, database management systems (DBMS), geo-search and analytics. <br>  First, for simplicity of explanation, we will set the task of searching for elements by a complete pass through an array of 10,000,000 elements (structures) containing 5 fields with ranges of values: amount_of_money (0-1000000), gender (0-1), age (0-100), code (0-1000000), height (0-300).  And in the following articles we will add an index search to the solution. <br>  We will write cross-platform under MSVC11 (MSVS2012) and GCC 4.7.2, and use in them a partially implemented C ++ 11 standard. <br><a name="habracut"></a><br><h4>  1. Solution in C </h4><br>  The simplest solution to this problem in C is to create a structure of bit fields occupied by 8 bytes (the general rule, in the absence of the <code>#pragma pack(push,1)</code> , the fields cannot cross the size limits of their basic types, in our case unsigned - 32 bits): <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Fields */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> T_field_enum { amount_of_money_e, gender_e, age_e, code_e, height_e, last_e }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 ‚Äì double word (32 bits) unsigned code:20; // 0 - 1000000 unsigned gender:1; // 0 - 1 unsigned age:7; // 0 - 100 // 2 ‚Äì double word (32 bits) unsigned amount_of_money:20; // 0 - 1000000 unsigned height:9; // 0 ‚Äì 300 };</span></span></code> </pre><br>  Allocate memory for 10 million such elements: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> c_array_size = <span class="hljs-number"><span class="hljs-number">10000000</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_ptr</span></span></span><span class="hljs-class"> = ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">calloc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c_array_size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class">));</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array_ptr == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"calloc error\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  In the cycle, fill with random values ‚Äã‚Äãwithin the ranges specified by the condition: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Generate random data for the one row */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> struct T_cash_account_row </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cash_account_row</span></span></span><span class="hljs-class">;</span></span> cash_account_row.age = rand() % <span class="hljs-number"><span class="hljs-number">100</span></span>; cash_account_row.amount_of_money = (rand() % <span class="hljs-number"><span class="hljs-number">1000</span></span>)*(rand() % <span class="hljs-number"><span class="hljs-number">1000</span></span>); cash_account_row.code = (rand() % <span class="hljs-number"><span class="hljs-number">1000</span></span>)*(rand() % <span class="hljs-number"><span class="hljs-number">1000</span></span>); cash_account_row.gender = rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>; cash_account_row.height = rand() % <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cash_account_row; } <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------- */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* in int main() { ‚Ä¶ } */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Fill table random data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; c_array_size; ++i) array_ptr[i] = generate_row();</code> </pre><br>  Create a search query filter structure, where <code>last_e</code> is an enumeration with the value of the number of fields in a string <a href="https://code.google.com/p/openassist/downloads/detail%3Fname%3DC%252B%252B%2520Standard%2520-%2520ANSI%2520ISO%2520IEC%252014882%25202003.pdf">(C ++ 03 7.2 Enumeration declarations)</a> : <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Filters */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_range_filters</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* bytes array or bitset from https://gist.github.com/jmbr/667605 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> use_filter[last_e]; }; <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------- */</span></span></code> </pre><br>  Here, <code>use_filter[]</code> used to specify whether to filter by this condition-field or not. <br>  And perform a search by checking the specified fields passing through all the elements of the array in a loop: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Compare row with filters */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_predicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct T_cash_account_row </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row, struct T_range_filters </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range_filters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!range_filters-&gt;use_filter[amount_of_money_e] || (row-&gt;amount_of_money &gt;= range_filters-&gt;begin.amount_of_money &amp;&amp; row-&gt;amount_of_money &lt;= range_filters-&gt;end.amount_of_money)) &amp;&amp; (!range_filters-&gt;use_filter[gender_e] || (row-&gt;gender &gt;= range_filters-&gt;begin.gender &amp;&amp; row-&gt;gender &lt;= range_filters-&gt;end.gender)) &amp;&amp; (!range_filters-&gt;use_filter[age_e] || (row-&gt;age &gt;= range_filters-&gt;begin.age &amp;&amp; row-&gt;age &lt;= range_filters-&gt;end.age)) &amp;&amp; (!range_filters-&gt;use_filter[code_e] || (row-&gt;code &gt;= range_filters-&gt;begin.code &amp;&amp; row-&gt;code &lt;= range_filters-&gt;end.code)) &amp;&amp; (!range_filters-&gt;use_filter[height_e] || (row-&gt;height &gt;= range_filters-&gt;begin.height &amp;&amp; row-&gt;height &lt;= range_filters-&gt;end.height)); } <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------- */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* search */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct T_cash_account_row </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c_array_size, struct T_cash_account_row *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result_ptr, struct T_range_filters </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range_filters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/* loop index */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; c_array_size; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(test_predicate(array_ptr + i, range_filters)) result_ptr[result_size] = array_ptr[i], ++result_size; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_size; }</code> </pre><br>  Link to the working code entirely on <a href="">GitHub.com</a> <br>  It would seem that here you can still speed up and optimize with a full pass without indexes? <br><ul><li>  Expand the cycle, to reduce the number of comparisons with the condition of the cycle and do several filterings test_predicate?  - This is too small compared to from 5 to 15 comparisons of our string in the embedded function test_predicate and compared with the call to RAM. </li><li>  Do prefetching-cache?  - It is possible both on C, and on C ++, but as part of our task, this will give little, because  multiple searches and so caches in LLC (L3) as much as they can, and the whole array of 80 MB in any case will not. </li><li>  Use vector comparison commands from <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html">SSE: CMPSS, COMISS, UCOMISS</a> ?  - It is possible both in C, and in C ++.  But this optimization is not portable to non-x86 / x64 processors such as ARM or Power [PC]. </li><li>  You can use compiler optimization keys and PGO, in C and C ++.  <a href="http://habrahabr.ru/post/138132/">PGO</a> is a compromise anyway, because  optimized code is created for one program execution path to the detriment of the other paths, i.e.  with some input data will be faster, and with some input slower.  I will show how to create an optimized code for each of the possible execution paths, and only in the most critical part of the program speed. </li></ul><br>  This is where the low-level (non-architectural) optimization in C ends, and any of these optimizations are applicable in C ++. <br><br><h4>  2. What is another optimization in C and C ++? </h4><br><ol><li>  First, the above solution in C is easily compiled on a C ++ compiler without any changes, since  in most cases backward compatibility occurs. <br>  Result in the online compiler on C: <a href="http://ideone.com/yfUYfk">ideone.com</a> <br>  Result in the online compiler in C ++ 11: <a href="http://ideone.com/zdZY4n">ideone.com</a> <br>  I commented out the random seed count. <pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* srand (time(NULL)); */</span></span></code> </pre>  to compare the results of different program launches.  But you can uncomment it and make sure that the absolute execution time varies, but the relative acceleration from my optimizations remains about the same. </li><li>  Secondly, especially clever C-developers could offer one more optimization - create 2 ^ 5 = 32 variants of test_predicate / search functions for each variant of the number of search conditions, save pointers to them into an array and select the desired variant during execution depending on the conditions search.  This will significantly reduce the number of comparisons. </li></ol><br>  Let's say the search condition for 2 fields from 5 came: age and code.  Then we call the <code>search_12()</code> function: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Compare row with filters */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_predicate_12</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct T_cash_account_row </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __restrict row, struct T_range_filters </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __restrict range_filters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (row-&gt;age &gt;= range_filters-&gt;begin.age &amp;&amp; row-&gt;age &lt;= range_filters-&gt;end.age) &amp;&amp; (row-&gt;code &gt;= range_filters-&gt;begin.code &amp;&amp; row-&gt;code &lt;= range_filters-&gt;end.code); } <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------- */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* search */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search_12</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct T_cash_account_row </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __restrict array_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c_array_size, struct T_cash_account_row *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __restrict result_ptr, struct T_range_filters </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __restrict range_filters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/* loop index */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; c_array_size; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(test_predicate_12(array_ptr + i, range_filters)) result_ptr[result_size] = array_ptr[i], ++result_size; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_size; }</code> </pre><br><br>  Although the number of conditions in this function has decreased to 4 from the original 15.  In reality, in the version of the solution on C comparisons, only 9 out of 15 were executed; for the search condition for 2 fields, this can be seen in the disassembler of the <code>test_predicate</code> function: <a href="">github.com</a> .  This happened because after each comparison of <code>use_filter[] == false</code> was a conditional transition to comparisons in the next field.  Those.  in addition to these 4-ex comparisons, only 5 more comparisons with <code>use_filter[]</code> were performed there. <br>  The solution described here, for example, for searching by 2 fields of 5, will give an acceleration of 1.3 times.  Not bad, but there is a small problem - C-developers will have to manually create these 32 functions, never make mistakes in them, going through all the options and changing the necessary functions with any change in the number and field names.  Well, if you need a similar solution for a table with 10 fields, then you have to create 1024 functions.  In general, just a fairy tale when finalizing the code! <br>  In addition, confusion is created when adding type fields with non-trivial comparison, such as the string <code>char[]</code> compared via <code>strcmp()</code> .  In C ++, this is solved by creating a custom type with an overloaded comparison operator.  (Operators for <a href="http://www.cplusplus.com/reference/type_traits/is_fundamental/">fundamental types</a> in C ++ cannot be overloaded - one of the operator parameters must be a custom class.) <br>  And the task of automatically creating the necessary number of optimized functions in C ++ is easily solved by unrolling of template. <br>  It may seem to someone that it can be solved on C and at run-time, and there is no need to fence 32 to 1024 functions optimized in compile-time.  Suppose you create an array of pointers to a function with a number equal to the number of conditions, in our case 5, and with each search, fill this array with only those functions with the conditions that are used for this search query.  And at the end add a pointer to the function returns 1 (true).  And each of such functions receives a pointer to an array of functions of the same type as itself, and the index of the next function being called.  I will disappoint, but in this case, the functions are not built in (inline), and their call is no faster than comparisons with conditional transitions. <br>  Here is the working version of this run-time solution on C: <a href="">GitHub.com</a> <br>  As you can see in MSVC, the speed dropped from 74 ms to 84ms.  And in the GCC even more - up to 117ms.  On C, such optimization is not possible, and only optimization through the creation of a large number of functions is possible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  3. C ++ Solution </h4><br>  Template promotion is performed by instantiating (instantiating) one template with another template, with the template parameter value one less than that of the creating one.  And for a template with a parameter value of 0, we create an empty, do nothing specialization.  As a result, by instantiating the promotion of the template with the N parameter, we get N - instances of the template being spun, in each of which the constructor or <code>inline</code> operator is called to call the next instance of the template.  In this promotion can participate, as template functions, and template classes. <br>  To take out promotion from the logic of the templates themselves, we will create a template promotion class.  One parameter will take the number to which it is necessary to unwind, and the second parameter will take the pattern that needs to be unwound: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The templated constructor of unrolling of the class (no return, mandatory call to the constructor, called once) template&lt;unsigned unroll_count, template&lt;unsigned&gt; class T&gt; struct T_unroll_constructor { T_unroll_constructor&lt;unroll_count-1, T&gt; next_unroll; T&lt;unroll_count-1&gt; functor; template&lt;typename T1&gt; inline T_unroll_constructor(T1 &amp; val1) : next_unroll(val1), functor(val1) {} }; // End of unroll template&lt;template&lt;unsigned&gt; class T&gt; struct T_unroll_constructor&lt;0, T&gt; { template&lt;typename T1&gt; inline T_unroll_constructor(T1 &amp;) {} }; // -------------------------------------------------------------------------</span></span></code> </pre><br><br>  Now create the base abstract search class.  We will inherit from it a template child class that takes a 32-bit <code>unsigned int</code> value as a template parameter, each bit of which will mean whether or not the corresponding filter is used: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Abstract base class of filters for each search variant (range_filters) struct T_filter { // search virtual size_t search(T_cash_account_row const*const __restrict array_ptr, const size_t c_array_size, T_cash_account_row *const __restrict result_ptr, T_range_filters const*const __restrict range_filters) = 0; }; // ------------------------------------------------------------------------- // The filters for each search variant (range_filters) template&lt;unsigned index_pred&gt; struct T_custom_filter : T_filter { inline unsigned char test_predicate(T_cash_account_row const*const __restrict row, T_range_filters const*const __restrict range_filters) { return (!(index_pred &amp; 1&lt;&lt;amount_of_money_e) || (row-&gt;amount_of_money &gt;= range_filters-&gt;begin.amount_of_money &amp;&amp; row-&gt;amount_of_money &lt;= range_filters-&gt;end.amount_of_money)) &amp;&amp; (!(index_pred &amp; 1&lt;&lt;gender_e) || (row-&gt;gender &gt;= range_filters-&gt;begin.gender &amp;&amp; row-&gt;gender &lt;= range_filters-&gt;end.gender)) &amp;&amp; (!(index_pred &amp; 1&lt;&lt;age_e) || (row-&gt;age &gt;= range_filters-&gt;begin.age &amp;&amp; row-&gt;age &lt;= range_filters-&gt;end.age)) &amp;&amp; (!(index_pred &amp; 1&lt;&lt;code_e) || (row-&gt;code &gt;= range_filters-&gt;begin.code &amp;&amp; row-&gt;code &lt;= range_filters-&gt;end.code)) &amp;&amp; (!(index_pred &amp; 1&lt;&lt;height_e) || (row-&gt;height &gt;= range_filters-&gt;begin.height &amp;&amp; row-&gt;height &lt;= range_filters-&gt;end.height)); } // ------------------------------------------------------------------------- // search virtual size_t search(T_cash_account_row const*const __restrict array_ptr, const size_t c_array_size, T_cash_account_row *const __restrict result_ptr, T_range_filters const*const __restrict range_filters) final { size_t result_size = 0; size_t i; // loop index for(i = 0; i &lt; c_array_size; ++i) { if(test_predicate(array_ptr + i, range_filters)) result_ptr[result_size] = array_ptr[i], ++result_size; } return result_size; } }; // -------------------------------------------------------------------------</span></span></code> </pre><br>  Since  template parameter <code>index_pred</code> and enumeration <code>amount_of_money_e, gender_e ‚Ä¶</code> known at the compilation stage, the compiler will throw out some of the conditions, as always true.  In fact, we help the compiler to optimize our program.  This is the most important decision in this! <br>  And now we will show how this template child class <code>template&lt;unsigned index_pred&gt; struct T_custom_filter</code> into 32 classes.  Create 32 objects of each of them and store the pointers of the base type on them into a static array <code>std::array&lt;&gt;</code> .  And at the time of execution we will polymorphically refer to the desired object, depending on the search conditions: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_optimized_search</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// unroll tamplates template&lt;unsigned index_pred&gt; struct T_unroll_find { template&lt;typename T&gt; T_unroll_find(T &amp;filters) { filters[index_pred].reset( new T_custom_filter&lt;index_pred&gt;() ); } }; // ------------------------------------------------------------------------- // Get index of T_test_pred version for current search range inline unsigned get_index_pred(T_range_filters const*const __restrict range_filters) { unsigned result = 0; for(size_t i = 0; i &lt; last_e; ++i) result |= range_filters-&gt;use_filter[i]?(1&lt;&lt;i):0; return result; } std::array&lt;std::unique_ptr&lt;T_filter&gt;, 1&lt;&lt;last_e&gt; filters; T_unroll_constructor&lt; 1&lt;&lt;last_e, T_unroll_find&gt; fill_filter; public: T_optimized_search() : fill_filter(filters) {} // C++ optimized search inline size_t search(T_cash_account_row const*const __restrict array_ptr, const size_t c_array_size, T_cash_account_row *const __restrict result_ptr, T_range_filters const*const __restrict range_filters) { auto const&amp; filter = filters[get_index_pred(range_filters)]; return filter-&gt;search(array_ptr, c_array_size, result_ptr, range_filters); } }; // -------------------------------------------------------------------------</span></span></code> </pre><br>  Here, the <code>unsigned get_index_pred((T_range_filters const*const __restrict range_filters)</code> returns the index number of the required search object for the given search condition <code>range_filters</code> . <br>  Used in a similar way as the solution on C: <br><pre> <code class="cpp hljs">T_optimized_search optimized_search; <span class="hljs-comment"><span class="hljs-comment">// C++ optimized search result_size = optimized_search.search(array_ptr, c_array_size, result_ptr, &amp;range_filters);</span></span></code> </pre><br><br>  Here is a comparison of the disassembled code of the two <code>test_predicate</code> functions on C and optimized in C ++ compiled on MSVC11 (MSVS 2012) with my comments - the difference is clearly visible if you look through <a href="https://code.google.com/p/tortoisegit/">TortoiseDiff</a> : diff link on <a href="https://github.com/AlexeyAB/cpp_find_order/commit/06a80340ff403c4693bfe0ff8b80584f029c71a3">GitHub.com</a> <br>  We see that from 15 comparisons, 9 of which are performed under our search conditions, only 4 comparisons remain - cmp assembler commands. <br>  ‚ÄúPicture disasm from TortoiseDiff with my comments‚Äù <br><img src="http://s2.ipicture.ru/uploads/20130604/8lNV41kR.png" alt="image"><br><br>  In fact, with the help of templates, we‚Äôve out-of-cycle a check for using each of the filters.  And inside the loop, the use values ‚Äã‚Äãof the <code>use_filter[]</code> filters <code>use_filter[]</code> known in compile-time were obtained, which allowed the compiler to exclude them during optimization.  Those.  This optimization is applicable to all similar cases of the removal of calculations or checks from a loop to an out. <br><br><blockquote>  In the C ++ example, I used the C-style method of passing parameters to a function using the constant pointer <code>*const</code> , so that in diff between C and C ++, the changes related only to the discussed optimization.  However, using interfaces in C ++ - style, the function can also take parameters via the &amp; link, which will exclude the possibility of forgetting <code>const</code> after * and this is somewhat shorter.  But <a href="">Google C ++ Style Guide</a> recommends transferring immutable parameters via a constant link <code>const&amp;</code> , and modifiable using a constant pointer <code>*const</code> .  If the code is written in this style, then you completely control the change (or not change) of your variables passed to another function - that is,  if you pass by value <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// function of other developer in Google C++ Style int* a = new int(1); int b = 2; func(*a, b);</span></span></code> </pre><br>  then the compiler will generate an error stating that the function wants to change your b parameter.  This is especially important when developing through TDD testing, when external calls to tests rigidly specify the interface format, and in this case such a call in external tests would tell the developer of the function that b cannot be changed. <br>  And if we pass by the pointer (or by taking the address): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// function of other developer in Google C++ Style int* a = new int(1); int b = 2; func(*a, &amp;b);</span></span></code> </pre><br>  it will compile without errors.  And even from the function call, it is obvious to us that the function <code>a</code> does not change the variable, and the variable <code>b</code> changes.  And in the case of TDD, we say that the developer must take <code>b</code> by pointer, and therefore must change it.  And <code>a</code> he will have to take a constant link or value, and will not be able to change its external value. <br>  But in C, where there are no links, this approach is not possible, since  if the function always accepts only by the pointer, then it is impossible to guarantee on the side of the caller that they cannot be modified, and passing on the value of variables of a custom type can have significant overhead costs. </blockquote><br><br><h4>  4. Conclusion </h4><br>  Here is a fully working version of this solution in C ++: <a href="">GitHub.com</a> <br>  I have GCC4.7.2 with ‚ÄìO3 ‚Äìmarch = native, CPUCore i5 K750 keys and the exe-file size of 74KB, the result is this: <br><blockquote>  Generated rows: 10,000,000 <br>  C ++ - Searching ... <br>  C ++ - optimized search took 0.061000 seconds. <br>  Found rows: 38 <br>  C-Searching ... <br>  C-search took 0.089000 seconds. <br>  The C ++ is faster than C: 1.459016 times <br>  Found rows: 38 </blockquote><br>  And on MSVC11 (MSVS2012) with the / O2 / Ob2 / Oi keys, CPU Core i5 K750 and the size of the exe-file in 138KB the result was: <br><blockquote>  Generated rows: 10,000,000 <br>  C ++ - Searching ... <br>  C ++ - optimized search took 0.056000 seconds. <br>  Found rows: 38 <br>  C-Searching ... <br>  C-search took 0.074000 seconds. <br>  The C ++ faster than C: 1.321429 times <br>  Found rows: 38 </blockquote><br>  As we can see, the execution time dropped from 74ms to 56ms, i.e.  speed increased <b>1.3</b> times.  In principle, not bad. <br>  Just <b>1.3</b> times?  And what about acceleration <b>3.5 - 5.3</b> times for a full pass search, any ideas? <br>  Conclusion - the more the compiler knows at compile time, the better he can optimize the program.  And templates (templates) help him like nothing else. <br>  By the way, this optimization is not applicable in Java and C #, since  in generics, it is not possible to use the parameter value, not the type <br>  In the <a href="http://habrahabr.ru/post/182428/">next article, a</a> hardcore solution with acceleration in <b>3.5 - 5.3</b> and still without indices.  But the solution will be used further in the index search. </div><p>Source: <a href="https://habr.com/ru/post/182356/">https://habr.com/ru/post/182356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182344/index.html">About proteins and complex networks</a></li>
<li><a href="../182346/index.html">Procedural texturing: cobblestone texture generation</a></li>
<li><a href="../182348/index.html">Experience with AngularJS on the example of a game project</a></li>
<li><a href="../182352/index.html">Pitfalls of using sessions in PHP</a></li>
<li><a href="../182354/index.html">Xamarin + PCL + MVVM - how to facilitate writing mobile applications for different platforms</a></li>
<li><a href="../182358/index.html">Speaker Cheat Sheet, or How I Gave My First Report</a></li>
<li><a href="../182360/index.html">Yandex supported Wikidata</a></li>
<li><a href="../182362/index.html">Quest for IT people on our nine-year anniversary. Google Nexus 7 Main Prize</a></li>
<li><a href="../182366/index.html">Why it is not necessary to develop applications for VK.com</a></li>
<li><a href="../182368/index.html">DevCon 2013: how it was (+ a lot of photos)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>