<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cross-platform https server with non-blocking sockets. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the articles: 
 The easiest cross-platform server with ssl support 
 Cross-platform https server with non-blocking s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cross-platform https server with non-blocking sockets. Part 2</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the articles: <br>  <a href="http://habrahabr.ru/post/211474/">The easiest cross-platform server with ssl support</a> <br>  <a href="http://habrahabr.ru/post/211661/">Cross-platform https server with non-blocking sockets</a> <br>  In these articles, I gradually from an unpretentious example that is part of OpenSSL try to make a full-fledged single-threaded web server. <br>  In the previous article, I ‚Äútaught‚Äù the server to accept the connection from one client and send back the html page with the request headers. <br>  Today I will correct the server code so that it can handle connections from an arbitrary number of clients in one thread. <br><a name="habracut"></a><br>  To begin, I will break the code into two files: serv.cpp and server.h <br>  At the same time, the serv.cpp file will contain such a ‚Äúhighly integrated‚Äù code: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"server.h"</span></span></span><span class="hljs-meta"> int main() { server::CServer(); return 0; }</span></span></code> </pre> <br><br>  Yes, you can kick me with your feet, but I still wrote, I write and I will write code in the header files if it is convenient for me.  For this I actually love with ++, that it gives the freedom of choice, but this is a separate conversation ... <br><br>  Go to the file server.h <br>  In its beginning, I transferred all the headers, macros and definitions that were previously in serv.cpp, and added a couple more headings from STL: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SERVER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SERVER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;memory.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #ifndef WIN32 #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netdb.h&gt; #else #include &lt;io.h&gt; #include &lt;Winsock2.h&gt; #pragma comment(lib, "ws2_32.lib") #endif #include &lt;openssl/rsa.h&gt; /* SSLeay stuff */ #include &lt;openssl/crypto.h&gt; #include &lt;openssl/x509.h&gt; #include &lt;openssl/pem.h&gt; #include &lt;openssl/ssl.h&gt; #include &lt;openssl/err.h&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;map&gt; #include &lt;memory&gt; #ifdef WIN32 #define SET_NONBLOCK(socket) \ if (true) \ { \ DWORD dw = true; \ ioctlsocket(socket, FIONBIO, &amp;dw); \ } #else #include &lt;fcntl.h&gt; #define SET_NONBLOCK(socket) \ if (fcntl( socket, F_SETFL, fcntl( socket, F_GETFL, 0 ) | O_NONBLOCK ) &lt; 0) \ printf("error in fcntl errno=%i\n", errno); #define closesocket(socket) close(socket) #define Sleep(a) usleep(a*1000) #define SOCKET int #define INVALID_SOCKET -1 #endif /* define HOME to be dir for key and cert files... */ #define HOME "./" /* Make these what you want for cert &amp; key files */ #define CERTF HOME "ca-cert.pem" #define KEYF HOME "ca-cert.pem" #define CHK_ERR(err,s) if ((err)==-1) { perror(s); exit(1); }</span></span></span></span></code> </pre><br><br>  Next, we first create the CServer and CClient classes inside the namespace server: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> server { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   SOCKET m_hSocket; //        vector&lt;unsigned char&gt; m_vRecvBuffer; //        vector&lt;unsigned char&gt; m_vSendBuffer; //    OpenSSL SSL_CTX* m_pSSLContext; SSL* m_pSSL; //       explicit CClient(const CClient &amp;client) {} public: CClient(const SOCKET hSocket) : m_hSocket(hSocket), m_pSSL(NULL), m_pSSLContext(NULL) {} ~CClient() { if(m_hSocket != INVALID_SOCKET) closesocket(m_hSocket); if (m_pSSL) SSL_free (m_pSSL); if (m_pSSLContext) SSL_CTX_free (m_pSSLContext); } }; class CServer { //      map&lt;SOCKET, shared_ptr&lt;CClient&gt; &gt; m_mapClients; //       explicit CServer(const CServer &amp;server) {} public: CServer() {} }; } #endif</span></span></code> </pre><br><br>  As you can see, this is just a blank for our server.  Let's start slowly filling this blank with a code, most of which is already in the <a href="http://habrahabr.ru/post/211661/">previous article</a> . <br>  For each client, its own SSL context is initiated; obviously, this should be done in the constructor of the CClient class. <br><pre> <code class="cpp hljs"> CClient(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOCKET hSocket) : m_hSocket(hSocket), m_pSSL(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_pSSLContext(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 const SSL_METHOD *meth = SSLv23_server_method(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> SSL_METHOD *meth = SSLv23_server_method(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> m_pSSLContext = SSL_CTX_new (meth); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!m_pSSLContext) ERR_print_errors_fp(stderr); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (SSL_CTX_use_certificate_file(m_pSSLContext, CERTF, SSL_FILETYPE_PEM) &lt;= 0) ERR_print_errors_fp(stderr); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (SSL_CTX_use_PrivateKey_file(m_pSSLContext, KEYF, SSL_FILETYPE_PEM) &lt;= 0) ERR_print_errors_fp(stderr); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!SSL_CTX_check_private_key(m_pSSLContext)) fprintf(stderr,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Private key does not match the certificate public key\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre><br><br>  Library initialization, creation and binding of the listening socket will be transferred with minimal changes to the CServer constructor: <br><pre> <code class="cpp hljs"> CServer() { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 WSADATA wsaData; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( WSAStartup( MAKEWORD( 2, 2 ), &amp;wsaData ) != 0 ) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Could not to find usable WinSock in WSAStartup\n"</span></span></span><span class="hljs-meta">); return; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> SSL_load_error_strings(); SSLeay_add_ssl_algorithms(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ----------------------------------------------- */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Prepare TCP socket for receiving connections */</span></span></span><span class="hljs-meta"> SOCKET listen_sd = socket (AF_INET, SOCK_STREAM, 0); CHK_ERR(listen_sd, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"socket"</span></span></span><span class="hljs-meta">); SET_NONBLOCK(listen_sd); struct sockaddr_in sa_serv; memset (&amp;sa_serv, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\0'</span></span></span><span class="hljs-meta">, sizeof(sa_serv)); sa_serv.sin_family = AF_INET; sa_serv.sin_addr.s_addr = INADDR_ANY; sa_serv.sin_port = htons (1111); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Server Port number */</span></span></span><span class="hljs-meta"> int err = ::bind(listen_sd, (struct sockaddr*) &amp;sa_serv, sizeof (sa_serv)); CHK_ERR(err, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bind"</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Receive a TCP connection. */</span></span></span><span class="hljs-meta"> err = listen (listen_sd, 5); CHK_ERR(err, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"listen"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre><br><br>  Further in the same constructor, I propose to accept incoming TCP connections. <br>  No one has so far brought me a single argument against, so we will listen to TCP connections in an infinite loop, as in the previous article. <br>  After each call to accept, we can do something with the newly connected and already connected clients by calling the callback function. <br>  Add the following code to the CServer constructor after the listen function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sa_cli</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> client_len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sa_cli); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 const SOCKET sd = accept (listen_sd, (struct sockaddr*) &amp;sa_cli, (int *)&amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> const SOCKET sd = accept (listen_sd, (struct sockaddr*) &amp;sa_cli, &amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> Callback(sd); }</span></span></code> </pre><br><br>  And immediately after the constructor, the actual callback function: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SOCKET hSocket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hSocket != INVALID_SOCKET) m_mapClients[hSocket] = <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;CClient&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CClient(hSocket)); <span class="hljs-comment"><span class="hljs-comment">//   auto it = m_mapClients.begin(); while (it != m_mapClients.end()) //   { if (!it-&gt;second-&gt;Continue()) // -   m_mapClients.erase(it++); //   false,    else it++; } }</span></span></code> </pre><br><br>  On this code class CServer finished!  All other application logic will be in the CClient class. <br>  <b>It is important to note</b> that for speed-critical projects, instead of going through all the clients in the loop, you need to go through only those clients whose sockets are ready for reading or writing. <br>  It's easy to do this using the select functions in Windows or epoll in Linux.  <b>I will show how this is done in the next article,</b> <br>  In the meantime (risking again to run into criticism) I‚Äôll confine myself to a simple cycle. <br><br>  Moving on to the main workhorse of our server: the CClient class. <br>  The CClient class should keep in itself not only information about its socket, but also information about what stage its interaction with the server is at. <br>  Add the following code to the CClient class definition: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//    .     . enum STATES { S_ACCEPTED_TCP, S_ACCEPTED_SSL, S_READING, S_ALL_READED, S_WRITING, S_ALL_WRITED }; STATES m_stateCurrent; //    //      void SetState(const STATES state) {m_stateCurrent = state;} const STATES GetState() const {return m_stateCurrent;} public: //      const bool Continue() { if (m_hSocket == INVALID_SOCKET) return false; switch (GetState()) { case S_ACCEPTED_TCP: break; case S_ACCEPTED_SSL: break; case S_READING: break; case S_ALL_READED: break; case S_WRITING: break; case S_ALL_WRITED: break; default: return false; } return true; }</span></span></code> </pre><br><br>  Here, Continue () is so far only a stub function, just below we will teach her to perform all actions with the connected client. <br><br>  In the constructor, change: <br><pre> <code class="cpp hljs">CClient(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOCKET hSocket) : m_hSocket(hSocket), m_pSSL(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_pSSLContext(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)</code> </pre><br>  on <br><pre> <code class="cpp hljs">CClient(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOCKET hSocket) : m_hSocket(hSocket), m_pSSL(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_pSSLContext(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_stateCurrent(S_ACCEPTED_TCP)</code> </pre><br><br>  Depending on the current state, the client calls different functions.  We agree that client states can only be changed in the constructor and in the Continue () function, this will slightly increase the size of the code, but it will greatly facilitate its debugging. <br><br>  So the first state that the client receives when created in the constructor: S_ACCEPTED_TCP. <br>  Let's write a function that will be called by the client as long as it has this state: <br>  For this line: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ACCEPTED_TCP: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  Change to the following: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ACCEPTED_TCP: { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (AcceptSSL()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_READY: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"SSL connection using %s\n"</span></span>, SSL_get_cipher (m_pSSL)); SetState(S_ACCEPTED_SSL); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  And also add the following code to the CClient class: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RETCODES { RET_WAIT, RET_READY, RET_ERROR }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_pSSLContext) <span class="hljs-comment"><span class="hljs-comment">//     SSL return RET_ERROR; if (!m_pSSL) { m_pSSL = SSL_new (m_pSSLContext); if (!m_pSSL) return RET_ERROR; SSL_set_fd (m_pSSL, m_hSocket); } const int err = SSL_accept (m_pSSL); const int nCode = SSL_get_error(m_pSSL, err); if ((nCode != SSL_ERROR_WANT_READ) &amp;&amp; (nCode != SSL_ERROR_WANT_WRITE)) return RET_READY; return RET_WAIT; }</span></span></code> </pre><br><br>  Now the AcceptSSL () function will be called by the client until an encrypted connection occurs or an error occurs. <br><br>  1. In case of an error, the CClient :: AcceptSSL () function returns the RET_ERROR code in its calling CClient :: Continue () function, which in this case returns false the CServer :: Callback function that caused it, which in this case will remove the client from the server memory. <br>  2. In case of a successful connection, the CClient :: AcceptSSL () function will return the RET_READY code to the CClient :: Continue () function that called it, which in this case will change the client state to S_ACCEPTED_SSL. <br><br>  Now add the state processing function S_ACCEPTED_SSL.  For this line <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ACCEPTED_SSL: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  fix for the following: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ACCEPTED_SSL: { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetSertificate()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_READY: SetState(S_READING); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  And add a function to CClient: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSertificate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_pSSLContext || !m_pSSL) <span class="hljs-comment"><span class="hljs-comment">//     SSL return RET_ERROR; /* Get client's certificate (note: beware of dynamic allocation) - opt */ X509* client_cert = SSL_get_peer_certificate (m_pSSL); if (client_cert != NULL) { printf ("Client certificate:\n"); char* str = X509_NAME_oneline (X509_get_subject_name (client_cert), 0, 0); if (!str) return RET_ERROR; printf ("\t subject: %s\n", str); OPENSSL_free (str); str = X509_NAME_oneline (X509_get_issuer_name (client_cert), 0, 0); if (!str) return RET_ERROR; printf ("\t issuer: %s\n", str); OPENSSL_free (str); /* We could do all sorts of certificate verification stuff here before deallocating the certificate. */ X509_free (client_cert); } else printf ("Client does not have certificate.\n"); return RET_READY; }</span></span></code> </pre><br><br>  This function, unlike the previous one, will be called only once and will return either RET_ERROR or RET_READY to CClient :: Continue.  Accordingly, CClient :: Continue will return either false, or it will change the client state to S_READING. <br><br>  Then everything is the same: change the code <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_READING: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ALL_READED: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_WRITING: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  on this: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_READING: { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ContinueRead()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_READY: SetState(S_ALL_READED); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ALL_READED: { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (InitRead()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_READY: SetState(S_WRITING); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_WRITING: { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ContinueWrite()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_READY: SetState(S_ALL_WRITED); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RET_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  And add the appropriate state processing functions: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContinueRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_pSSLContext || !m_pSSL) <span class="hljs-comment"><span class="hljs-comment">//     SSL return RET_ERROR; unsigned char szBuffer[4096]; const int err = SSL_read (m_pSSL, szBuffer, 4096); //      if (err &gt; 0) { //     m_vRecvBuffer m_vRecvBuffer.resize(m_vRecvBuffer.size()+err); memcpy(&amp;m_vRecvBuffer[m_vRecvBuffer.size()-err], szBuffer, err); //  http     const std::string strInputString((const char *)&amp;m_vRecvBuffer[0]); if (strInputString.find("\r\n\r\n") != -1) return RET_READY; return RET_WAIT; } const int nCode = SSL_get_error(m_pSSL, err); if ((nCode != SSL_ERROR_WANT_READ) &amp;&amp; (nCode != SSL_ERROR_WANT_WRITE)) return RET_ERROR; return RET_WAIT; } const RETCODES InitRead() { if (!m_pSSLContext || !m_pSSL) //     SSL return RET_ERROR; //      const std::string strInputString((const char *)&amp;m_vRecvBuffer[0]); // html     const std::string strHTML = "&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello! Your HTTP headers is:&lt;/h2&gt;&lt;br&gt;&lt;pre&gt;" + strInputString.substr(0, strInputString.find("\r\n\r\n")) + "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"; //    http  std::ostringstream strStream; strStream &lt;&lt; "HTTP/1.1 200 OK\r\n" &lt;&lt; "Content-Type: text/html; charset=utf-8\r\n" &lt;&lt; "Content-Length: " &lt;&lt; strHTML.length() &lt;&lt; "\r\n" &lt;&lt; "\r\n" &lt;&lt; strHTML.c_str(); // ,    m_vSendBuffer.resize(strStream.str().length()); memcpy(&amp;m_vSendBuffer[0], strStream.str().c_str(), strStream.str().length()); return RET_READY; } const RETCODES ContinueWrite() { if (!m_pSSLContext || !m_pSSL) //     SSL return RET_ERROR; int err = SSL_write (m_pSSL, &amp;m_vSendBuffer[0], m_vSendBuffer.size()); if (err &gt; 0) { //    ,      if (err == m_vSendBuffer.size()) return RET_READY; //    ,      ,     vector&lt;unsigned char&gt; vTemp(m_vSendBuffer.size()-err); memcpy(&amp;vTemp[0], &amp;m_vSendBuffer[err], m_vSendBuffer.size()-err); m_vSendBuffer = vTemp; return RET_WAIT; } const int nCode = SSL_get_error(m_pSSL, err); if ((nCode != SSL_ERROR_WANT_READ) &amp;&amp; (nCode != SSL_ERROR_WANT_WRITE)) return RET_ERROR; return RET_WAIT; }</span></span></code> </pre><br><br>  Our server is only designed to show the client the headers of its http request. <br>  After the server has fulfilled its purpose, it can close the connection and forget about the client. <br>  Therefore, it remains to make the last small change in our code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ALL_WRITED: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  need to fix on <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_ALL_WRITED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br><br>  That's all!  Now we have a cross-platform single-threaded https server on non-blocking sockets, which can handle an arbitrary (limited only by memory and operating system settings) number of connections. <br><br>  The archive with the project for Visual Studio 2012 can be downloaded here: <a href="http://01.3s3s.org/">01.3s3s.org</a> <br>  To compile to Linux, you need to copy the following files into one directory: serv.cpp, server.h, ca-cert.pem and type in the command line: ‚Äúg ++ -std = c ++ 0x -L / usr / lib -lssl -lcrypto serv .cpp <br><br>  <a href="http://habrahabr.ru/post/212101/">Continuation</a> </div><p>Source: <a href="https://habr.com/ru/post/211853/">https://habr.com/ru/post/211853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211843/index.html">Porridge, sir! Build a project on InterSystems Cach√© using Jenkins</a></li>
<li><a href="../211845/index.html">How I hacked the githab again</a></li>
<li><a href="../211847/index.html">Basics of creating a 2D character in Unity 3D 4.3. Part 2: Running Character</a></li>
<li><a href="../211849/index.html">Beginner musicians: why it is worth laying out albums on Jamendo</a></li>
<li><a href="../211851/index.html">On the Poincare conjecture. Lecture in Yandex</a></li>
<li><a href="../211855/index.html">IBM can get rid of semiconductor business</a></li>
<li><a href="../211863/index.html">Polyfill to work around browser forms autocomplete</a></li>
<li><a href="../211865/index.html">MDIF announced the creation of a free network Outernet</a></li>
<li><a href="../211867/index.html">Qwt and Qt Creator. Quick and easy. Part 2: Display and Control Elements</a></li>
<li><a href="../211869/index.html">Arista. Acquaintance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>