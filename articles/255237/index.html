<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Details about objects and classes in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today objects are used very actively, although it was hard to imagine after the release of PHP 5 in 2005. Then I still knew little about the possibili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Details about objects and classes in PHP</h1><div class="post__text post__text-html js-mediator-article">  Today objects are used very actively, although it was hard to imagine after the release of PHP 5 in 2005.  Then I still knew little about the possibilities of this language.  The fifth version of PHP was compared with the previous, fourth, and the main advantage of the new release was a new, very powerful object model.  And today, ten years later, about 90% of all PHP code contains objects that have not changed since PHP 5.0.  This convincingly indicates the role played by the introduction of the object model, which has repeatedly improved over the coming years.  In this post I would like to talk about how everything is arranged "under the hood."  So that people understand the essence of the processes - why it was done this way and not otherwise - and better, more fully used the possibilities of the language.  I will also touch on the topic of memory usage by objects, including comparing with equivalent arrays (when possible). <br><br>  I will talk about the PHP 5.4 version as an example, and the things I describe are valid for 5.5 and 5.6, because the object model device is almost unchanged there.  Please note that in version 5.3, everything is not so good in terms of features and overall performance. <br><br>  In PHP 7, which is still being actively developed, the object model is not much reworked, only minor changes have been made.  Just because everything works so well, and the best is the enemy of the good.  Opportunities that did not affect the core were added, but this will not be the case here. <br><a name="habracut"></a><br>  As a demonstration, I'll start with synthetic benchmarks: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $a = <span class="hljs-string"><span class="hljs-string">"foobarstring"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $c = [<span class="hljs-string"><span class="hljs-string">'some'</span></span>, <span class="hljs-string"><span class="hljs-string">'values'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $i++) { $m = memory_get_usage(); ${<span class="hljs-string"><span class="hljs-string">'var'</span></span>.$i} = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() - $m<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre> <br>  A simple class with three attributes is declared here, and then 1000 objects of this class are created in a loop.  Notice how this example uses memory: when creating an object of class Foo and a variable to store it, 262 bytes of PHP dynamic memory are allocated. <br><br>  Let's replace an object with an equivalent array: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $i++) { $m = memory_get_usage(); ${<span class="hljs-string"><span class="hljs-string">'var'</span></span>.$i} = [[<span class="hljs-string"><span class="hljs-string">'some'</span></span>, <span class="hljs-string"><span class="hljs-string">'values'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'foobarstring'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() - $m . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br>  In this case, the same elements are used: the array itself, null, and the string variable <code>foobarstring</code> .  That's just consumed already 1160 bytes of memory, which is 4.4 times more. <br><br>  Here is another example: <br><br><pre> <code class="php hljs">$class = &lt;&lt;&lt;<span class="hljs-string"><span class="hljs-string">'CL'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $a = <span class="hljs-string"><span class="hljs-string">"foobarstring"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $c = [<span class="hljs-string"><span class="hljs-string">'some'</span></span>, <span class="hljs-string"><span class="hljs-string">'values'</span></span>]; } CL; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>($class); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre><br>  Since the class is declared at compile time, we use the <code>eval()</code> operator to declare and measure the memory used (using the PHP memory manager <code>eval()</code> .  In this case, no objects in this code are not created.  The volume of involved memory (diff memory) is 2216 bytes. <br><br>  Now let's look at how it all works in the depths of PHP, supported by theory of practical observations. <br><br><h1>  It all starts with classes </h1><br>  Inside the PHP class is represented using the structure zend_class_entry: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_class_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; zend_uint name_length; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_class_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parent</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> refcount; zend_uint ce_flags; HashTable function_table; HashTable properties_info; zval **default_properties_table; zval **default_static_members_table; zval **static_members_table; HashTable constants_table; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> default_properties_count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> default_static_members_count; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *constructor; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *destructor; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *clone; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__get; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__set; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__unset; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__isset; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__call; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__callstatic; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *__tostring; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *serialize_func; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *unserialize_func; zend_class_iterator_funcs iterator_funcs; <span class="hljs-comment"><span class="hljs-comment">/* handlers */</span></span> zend_object_value (*create_object)(zend_class_entry *class_type TSRMLS_DC); zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> by_ref TSRMLS_DC); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type TSRMLS_DC); <span class="hljs-comment"><span class="hljs-comment">/* a class implements this interface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *(*get_static_method)(zend_class_entry *ce, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* method, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> method_len TSRMLS_DC); <span class="hljs-comment"><span class="hljs-comment">/* serializer callbacks */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*serialize)(zval *object, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **buffer, zend_uint *buf_len, zend_serialize_data *data TSRMLS_DC); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*unserialize)(zval **object, zend_class_entry *ce, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC); zend_class_entry **interfaces; zend_uint num_interfaces; zend_class_entry **traits; zend_uint num_traits; zend_trait_alias **trait_aliases; zend_trait_precedence **trait_precedences; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *filename; zend_uint line_start; zend_uint line_end; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *doc_comment; zend_uint doc_comment_len; } user; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_function_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">builtin_functions</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_module_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class">;</span></span> } internal; } info; };</code> </pre><br>  The size of the structure, based on the LP64 model, is <b>568 bytes</b> .  That is, each time PHP declares a class, it is forced to create <code>zend_class_entry</code> , using more than half a kilobyte of dynamic memory for this purpose.  Of course, this is not limited to this: as you noticed, the structure contains quite a few pointers, which also need to be placed in memory.  That is, classes themselves consume much more memory than all objects created from them afterwards. <br><br>  Among other things, classes contain attributes (static and dynamic), as well as methods.  All this also requires memory.  As for the methods, it is difficult to calculate the exact dependency, but one thing is true: the larger the method body, the more <code>OPArray</code> it <code>OPArray</code> , which means the more memory it consumes.  Add to this static variables that can be declared in the method.  Next are the attributes, later they will also be placed in memory.  The volume depends on their default values: the integers will take a little, but a large static array will eat a lot of memory. <br><br>  It is important to know about one more thing related to <code>zend_class_entry</code> - about PHP comments.  They are also known as annotations.  These are string variables (in C language, <code>char*</code> buffers) that must also be stored in memory.  For C, which does not use Unicode, unlike PHP, the rule is very simple: one character = one byte.  The more annotations you have in a class, the more memory will be used after parsing. <br><br>  In <code>zend_class_entry</code> field contains class annotations.  Methods and attributes also have such a field. <br><br><h1>  User and internal classes </h1><br>  A custom class is a class defined using PHP, and the inner class is defined either by embedding the source code in PHP itself, or using an extension.  The biggest difference between these two types of classes is that user classes operate on memory allocated on request, while internal ones use ‚Äúpermanent‚Äù memory. <br><br>  This means that when PHP finishes processing the current HTTP request, it removes from memory and destroys all user classes, preparing to process the next request.  This approach is known as ‚Äúthe share nothing architecture‚Äù.  So it was laid in PHP from the very beginning, and it is not planned to change it yet. <br><br>  So, each time a query is formed and classes are parsed, memory is allocated for them.  After using the class, everything connected with it is destroyed.  So be sure to use all the declared classes, otherwise memory will be lost.  Use autoloaders, they delay parsing / declaration at runtime, when PHP needs to use a class.  Despite the slowdown in execution, the autoloader allows you to correctly use memory, since it will not run until you really need a class. <br><br>  The inner classes are different.  They are placed in the memory constantly, regardless of whether they are used or not.  That is, they are destroyed only when PHP itself stops working - after the completion of processing all requests (implies SAPI web, for example, PHP-FPM).  Therefore, internal classes are more efficient than user classes (at the end of the query, only static attributes are destroyed, nothing else). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EG(full_tables_cleanup)) { zend_hash_reverse_apply(EG(function_table), (<span class="hljs-keyword"><span class="hljs-keyword">apply_func_t</span></span>) clean_non_persistent_function_full TSRMLS_CC); zend_hash_reverse_apply(EG(class_table), (<span class="hljs-keyword"><span class="hljs-keyword">apply_func_t</span></span>) clean_non_persistent_class_full TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zend_hash_reverse_apply(EG(function_table), (<span class="hljs-keyword"><span class="hljs-keyword">apply_func_t</span></span>) clean_non_persistent_function TSRMLS_CC); zend_hash_reverse_apply(EG(class_table), (<span class="hljs-keyword"><span class="hljs-keyword">apply_func_t</span></span>) clean_non_persistent_class TSRMLS_CC); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_non_persistent_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_class_entry **ce TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((*ce)-&gt;type == ZEND_INTERNAL_CLASS) ? ZEND_HASH_APPLY_STOP : ZEND_HASH_APPLY_REMOVE; }</code> </pre><br>  Note that even when opcodes are cached, like OPCache, the class is created and destroyed with every request, as is the case with custom classes.  OPCache just speeds up both of these processes. <br><br>  As you noticed, if you activate a lot of PHP extensions, each of which declares a lot of classes, but only a small number of them are used, then the memory is lost.  Remember that PHP extensions declare classes during PHP startup, even if these classes will not be used in subsequent requests.  Therefore, it is not recommended to keep the extensions active if they are not being applied at the moment, otherwise you will lose memory.  Especially if these extensions declare many classes - although they can clog the memory with something else. <br><br><h1>  Classes, interfaces or traits - no difference </h1><br>  To manage classes, interfaces, and traits in PHP, the same structure is <code>zend_class_entry</code> - <code>zend_class_entry</code> .  And as you have seen, this structure is very cumbersome.  Sometimes developers declare interfaces in code to be able to use their names in catch blocks.  This allows you to catch only certain types of exceptions.  For example: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BarException</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BarException</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $foo-&gt;bar(): } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (BarException $e) { }</code> </pre><br>  It's not good that 912 bytes are used here, just to declare the BarException interface. <br><br><pre> <code class="php hljs">$class = &lt;&lt;&lt;<span class="hljs-string"><span class="hljs-string">'CL'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ } CL; $m = memory_get_usage(); <span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>($class); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() - $m . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 912 bytes */</span></span></code> </pre><br>  I do not want to say that this is bad or stupid, I am not trying to blame anyone or anything.  Just draw your attention to this moment.  From the point of view of the internal structure of PHP, classes, interfaces and traits are used in exactly the same way.  Attributes cannot be added to the interface, the parser or compiler simply will not allow this.  However, the <code>zend_class_entry</code> structure <code>zend_class_entry</code> not go anywhere, just a number of fields, including the <code>static_members_table</code> , will not be pointers in memory.  Declaring a class, equivalent trait, or equivalent interface will require the same amount of memory, since they all use the same structure. <br><br><h1>  Class binding </h1><br>  Many developers don‚Äôt recall class binding until they start asking questions about how things really work.  Class binding can be described as ‚Äúthe process during which the class itself and all the data associated with it are prepared for the full use of the developer.‚Äù  This process is very simple and does not require a lot of resources if we are talking about one class that does not complement the other, does not use traits and does not implement the interface.  The binding process for such classes takes place entirely at compile time, and in the course of execution, resources are no longer spent on this.  Please note that this was a binding class declared by the user.  For inner classes, the same process is performed when the classes are registered with the kernel or PHP extensions, just before the user scripts are run ‚Äî and this is done only once during the entire PHP run time. <br><br>  Everything is much more complicated when it comes to the introduction of interfaces or the inheritance of classes.  Then, during class binding, parent and child objects (whether classes or interfaces) copy everything. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Single class */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_DECLARE_CLASS: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (do_bind_class(CG(active_op_array), opline, CG(class_table), <span class="hljs-number"><span class="hljs-number">1</span></span> TSRMLS_CC) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } table = CG(class_table); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  In the case of a simple class declaration, we run <code>do_bind_class()</code> .  This function only registers a fully defined class in the class table for further use at runtime, and also checks for possible abstract methods: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_verify_abstract_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_class_entry *ce TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ zend_abstract_info ai; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ce-&gt;ce_flags &amp; ZEND_ACC_IMPLICIT_ABSTRACT_CLASS) &amp;&amp; !(ce-&gt;ce_flags &amp; ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ai, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ai)); zend_hash_apply_with_argument(&amp;ce-&gt;function_table, (<span class="hljs-keyword"><span class="hljs-keyword">apply_func_arg_t</span></span>) zend_verify_abstract_class_function, &amp;ai TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ai.cnt) { zend_error(E_ERROR, <span class="hljs-string"><span class="hljs-string">"Class %s contains %d abstract method%s and must therefore be declared abstract or implement the remaining methods ("</span></span> MAX_ABSTRACT_INFO_FMT MAX_ABSTRACT_INFO_FMT MAX_ABSTRACT_INFO_FMT <span class="hljs-string"><span class="hljs-string">")"</span></span>, ce-&gt;name, ai.cnt, ai.cnt &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-string"><span class="hljs-string">"s"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, DISPLAY_ABSTRACT_FN(<span class="hljs-number"><span class="hljs-number">0</span></span>), DISPLAY_ABSTRACT_FN(<span class="hljs-number"><span class="hljs-number">1</span></span>), DISPLAY_ABSTRACT_FN(<span class="hljs-number"><span class="hljs-number">2</span></span>) ); } } }</code> </pre><br>  There is nothing to add, a simple case. <br><br>  When binding a class that implements an interface, the following actions should be taken: <br><ul><li>  Check if the interface has already been declared. </li><li>  Check whether the desired class is really a class, and not the interface itself (as mentioned above, from the point of view of the internal structure, they are the same). </li><li>  Copy constants from the interface to the class, checking for possible collisions. </li><li>  Copy methods from the interface to the class, checking for possible collisions and inconsistencies in the declaration (for example, turning the interface methods into static in the child class). </li><li>  Add an interface and all possible parent interfaces to the list of interfaces implemented by the class. </li></ul><br>  By "copying" is meant not a complete deep copy.  For constants, attributes, and functions, one by one recalculates how many entities in memory use them. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_do_implement_interface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_class_entry *ce, zend_class_entry *iface TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ce-&gt;num_interfaces &gt;= current_iface_num) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ce-&gt;type == ZEND_INTERNAL_CLASS) { ce-&gt;interfaces = (zend_class_entry **) <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(ce-&gt;interfaces, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_class_entry *) * (++current_iface_num)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ce-&gt;interfaces = (zend_class_entry **) erealloc(ce-&gt;interfaces, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_class_entry *) * (++current_iface_num)); } } ce-&gt;interfaces[ce-&gt;num_interfaces++] = iface; zend_hash_merge_ex(&amp;ce-&gt;constants_table, &amp;iface-&gt;constants_table, (<span class="hljs-keyword"><span class="hljs-keyword">copy_ctor_func_t</span></span>) zval_add_ref, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zval *), (<span class="hljs-keyword"><span class="hljs-keyword">merge_checker_func_t</span></span>) do_inherit_constant_check, iface); zend_hash_merge_ex(&amp;ce-&gt;function_table, &amp;iface-&gt;function_table, (<span class="hljs-keyword"><span class="hljs-keyword">copy_ctor_func_t</span></span>) do_inherit_method, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_function), (<span class="hljs-keyword"><span class="hljs-keyword">merge_checker_func_t</span></span>) do_inherit_method_check, ce); do_implement_interface(ce, iface TSRMLS_CC); zend_do_inherit_interfaces(ce, iface TSRMLS_CC); } }</code> </pre><br>  Note the difference between internal and custom classes.  The first will use <code>realloc()</code> for memory allocation, the second - <code>erealloc()</code> .  <code>realloc()</code> allocates ‚Äúpermanent‚Äù memory, and <code>erealloc()</code> ‚Äúallocated on demand‚Äù memory. <br><br>  You can see that when two constant tables (interface-1 and class-1) are combined, they do this with the zval_add_ref <code>zval_add_ref</code> .  It does not copy constants from one table to another, but shares their pointers, simply by adding the number of references. <br><br>  For each of the tables of functions (methods), <code>do_inherit_method</code> used: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_inherit_method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_function *function)</span></span></span><span class="hljs-function"> </span></span>{ function_add_ref(function); } <span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_add_ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_function *function)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (function-&gt;type == ZEND_USER_FUNCTION) { zend_op_array *op_array = &amp;function-&gt;op_array; (*op_array-&gt;refcount)++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_array-&gt;static_variables) { HashTable *static_variables = op_array-&gt;static_variables; zval *tmp_zval; ALLOC_HASHTABLE(op_array-&gt;static_variables); zend_hash_init(op_array-&gt;static_variables, zend_hash_num_elements(static_variables), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ZVAL_PTR_DTOR, <span class="hljs-number"><span class="hljs-number">0</span></span>); zend_hash_copy(op_array-&gt;static_variables, static_variables, (<span class="hljs-keyword"><span class="hljs-keyword">copy_ctor_func_t</span></span>) zval_add_ref, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) &amp;tmp_zval, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zval *)); } op_array-&gt;run_time_cache = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br>  The refcount is added to the OPArray function, and all possible static variables declared in the function are copied using <code>zval_add_ref</code> (here it is a method).  Thus, a lot of computational resources are needed for the entire copying process, because many cycles and checks are involved here.  But memory is used a little.  Unfortunately, today the interface binding runs completely at runtime, and you will feel it with every request.  Perhaps the developers will soon change it. <br><br>  As for inheritance, here, in principle, everything is the same as in the implementation of the interface.  Only more "participants" are involved.  But I want to note that if PHP already knows about the class, then the binding is performed at compile time, and if it does not, at run time.  So it is better to declare this: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* good */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  instead: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* bad */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  By the way, the routine class binding procedure can lead to very strange behavior: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> Fatal error: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">Class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">' </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">found</span></span></span><span class="hljs-class"> */ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><br>  In the first variant, class B binding is postponed for execution time, because when the compiler reaches the declaration of this class, it still does not know anything about class A. When execution begins, class A binding occurs without question, because it is already compiled, being single class.  In the second case, everything is different.  The binding of class C is postponed until runtime, because the compiler still does not know anything about B, trying to compile it.  But when class C starts at runtime, it searches for B, which does not exist, because it is not compiled because B is a complement.  The message ‚ÄúClass B does not exist‚Äù flies. <br><br><h1>  Objects </h1><br>  So now we know that: <br><br><ul><li>  Classes take up a lot of memory. </li><li>  Internal classes are much better optimized than custom ones, because the latter must be created and destroyed with each request.  Inner classes exist constantly. </li><li>  Classes, interfaces and traits use the same structure and procedures, the differences are very small. </li><li>  During inheritance or declarations, the binding process loads the processor heavily and for a long time, but the memory is used a little, since many things are not duplicated, but are shared.  In addition, it is better to run the class binding at compile time. </li></ul><br><br>  Now let's talk about the objects.  The first chapter shows that the creation of a ‚Äúclassic‚Äù object (a ‚Äúclassic‚Äù user class) required very little memory, about 200 bytes.  It's all about the class.  Further compilation of the class also consumes memory, but this is for the better, because it takes less bytes to create a single object.  In essence, an object is a tiny set of tiny structures. <br><br><h1>  Management of object methods </h1><br>  At the engine level, the methods and functions are the same - the structure of <code>zend_function_structure</code> .  Only the names are different.  Methods are compiled and added to the <code>function_table</code> attribute in <code>zend_class_entry</code> .  Therefore, at run time, each method is presented; it is only a matter of translating a pointer to execution. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function { zend_uchar type; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> zend_uchar type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *function_name; zend_class_entry *scope; zend_uint fn_flags; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_function *prototype; zend_uint num_args; zend_uint required_num_args; zend_arg_info *arg_info; } common; zend_op_array op_array; zend_internal_function internal_function; } zend_function;</code> </pre><br>  When an object tries to call a method, the default engine searches the table of values ‚Äã‚Äãof functions of the class of this object.  If the method does not exist, <code>__call()</code> called.  It also checks the visibility - public / protected / private - depending on what the following actions are taken: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _<span class="hljs-function"><span class="hljs-function">zend_function *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_std_get_method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zval **object_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *method_name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> method_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zend_literal *key TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ zend_function *fbc; zval *object = *object_ptr; zend_object *zobj = Z_OBJ_P(object); ulong hash_value; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *lc_method_name; ALLOCA_FLAG(use_heap) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(key != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { lc_method_name = Z_STRVAL(key-&gt;constant); hash_value = key-&gt;hash_value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lc_method_name = do_alloca(method_len+<span class="hljs-number"><span class="hljs-number">1</span></span>, use_heap); zend_str_tolower_copy(lc_method_name, method_name, method_len); hash_value = zend_hash_func(lc_method_name, method_len+<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* If the method is not found */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(zend_hash_quick_find(&amp;zobj-&gt;ce-&gt;function_table, lc_method_name, method_len+<span class="hljs-number"><span class="hljs-number">1</span></span>, hash_value, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)&amp;fbc) == FAILURE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(!key)) { free_alloca(lc_method_name, use_heap); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zobj-&gt;ce-&gt;__call) { <span class="hljs-comment"><span class="hljs-comment">/* if the class has got a __call() handler */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_get_user_call_function(zobj-&gt;ce, method_name, method_len); <span class="hljs-comment"><span class="hljs-comment">/* call the __call() handler */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* else return NULL, which will likely lead to a fatal error : method not found */</span></span> } } <span class="hljs-comment"><span class="hljs-comment">/* Check access level */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;op_array.fn_flags &amp; ZEND_ACC_PRIVATE) { zend_function *updated_fbc; updated_fbc = zend_check_private_int(fbc, Z_OBJ_HANDLER_P(object, get_class_entry)(object TSRMLS_CC), lc_method_name, method_len, hash_value TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(updated_fbc != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { fbc = updated_fbc; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zobj-&gt;ce-&gt;__call) { fbc = zend_get_user_call_function(zobj-&gt;ce, method_name, method_len); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zend_error_noreturn(E_ERROR, <span class="hljs-string"><span class="hljs-string">"Call to %s method %s::%s() from context '%s'"</span></span>, zend_visibility_string(fbc-&gt;common.fn_flags), ZEND_FN_SCOPE_NAME(fbc), method_name, EG(scope) ? EG(scope)-&gt;name : <span class="hljs-string"><span class="hljs-string">""</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> }</code> </pre><br>  You may have noticed an interesting thing, look at the first lines: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(key != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { lc_method_name = Z_STRVAL(key-&gt;constant); hash_value = key-&gt;hash_value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lc_method_name = do_alloca(method_len+<span class="hljs-number"><span class="hljs-number">1</span></span>, use_heap); <span class="hljs-comment"><span class="hljs-comment">/* Create a zend_copy_str_tolower(dest, src, src_length); */</span></span> zend_str_tolower_copy(lc_method_name, method_name, method_len); hash_value = zend_hash_func(lc_method_name, method_len+<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  This is a manifestation of PHP immunity to different registers.  The system must first reduce each function to lower case ( <code>zend_str_tolower_copy()</code> ) before calling it.  Not really everyone, but those where there is an <code>if</code> .  The <code>key</code> variable prevents the execution of a function that converts to lower case (the part with the <code>else</code> ) - this is part of the PHP optimization implemented in version 5.4.  If the method call is not dynamic, then the compiler has already calculated the <code>key</code> , and less resources are spent during the execution. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BAR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } } $a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; $b = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; $a-&gt;bar(); <span class="hljs-comment"><span class="hljs-comment">/* static call : good */</span></span> $a-&gt;$b(); <span class="hljs-comment"><span class="hljs-comment">/* dynamic call : bad */</span></span></code> </pre><br>    /      .   <code>BAR()</code>   <code>bar()</code>        . <br><br>      :   <code>key</code>   ‚Äúbar‚Äù,      ,     .    ,      ‚Äú$b‚Äù,    <code>key</code>   . ,   ,            ( <code>zend_hash_func()</code> ),       . <br><br>   <code>__call()</code> ,       .   ,      ,     . <br><br><h1>    </h1><br>   : <br><br><img src="//habrastorage.org/files/882/846/778/8828467783294a50b6135da7669ebc77.png"><br><br>  ,      ,        ,       .         , , ,     .      ‚Äî      PHP.       ,        .         ,     , ,     $a  Foo #2: <br><br><img src="//habrastorage.org/files/dd9/93a/0ce/dd993a0ce12f4de8847a510c8bcef322.png"><br><br>  ,  ,  ¬´ ¬ª   <code>zend_object</code>  32 : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object</span></span></span><span class="hljs-class"> {</span></span> zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; <span class="hljs-comment"><span class="hljs-comment">/* protects from __get/__set ... recursion */</span></span> } zend_object;</code> </pre><br>      .  ,   ,   <code>zend_object_store</code> .      Zend ‚Äî ,         : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ZEND_API zend_object_value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_objects_new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_object **object, zend_class_entry *class_type TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ zend_object_value retval; *object = emalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_object)); (*object)-&gt;ce = class_type; (*object)-&gt;properties = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; (*object)-&gt;properties_table = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; (*object)-&gt;guards = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Add the object into the store */</span></span> retval.handle = zend_objects_store_put(*object, (<span class="hljs-keyword"><span class="hljs-keyword">zend_objects_store_dtor_t</span></span>) zend_objects_destroy_object, (<span class="hljs-keyword"><span class="hljs-keyword">zend_objects_free_object_storage_t</span></span>) zend_objects_free_object_storage, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> TSRMLS_CC); retval.handlers = &amp;std_object_handlers; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br>       : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object_properties_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_object *object, zend_class_entry *class_type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (class_type-&gt;default_properties_count) { object-&gt;properties_table = emalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zval*) * class_type-&gt;default_properties_count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; class_type-&gt;default_properties_count; i++) { object-&gt;properties_table[i] = class_type-&gt;default_properties_table[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (class_type-&gt;default_properties_table[i]) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ZTS ALLOC_ZVAL( object-&gt;properties_table[i]); MAKE_COPY_ZVAL(&amp;class_type-&gt;default_properties_table[i], object-&gt;properties_table[i]); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> Z_ADDREF_P(object-&gt;properties_table[i]); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } } object-&gt;properties = NULL; } }</span></span></code> </pre><br>  ,     / (   )  <code>zval*</code> ,      .    PHP      refcount,     Zend (ZTS, Zend thread safety),     <code>zval</code> .     ,        ZTS     ZTS PHP. <br><br> ,     : <br><br><ul><li>   <code>properties_table</code>  properties   <code>zend_object</code> ? </li><li>        -,     ?     (  )? </li></ul><br><br>      <code>zend_property_info</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_property_info</span></span></span><span class="hljs-class"> {</span></span> zend_uint flags; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> name_length; ulong h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *doc_comment; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> doc_comment_len; zend_class_entry *ce; } zend_property_info;</code> </pre><br>  <b></b>  ()       ,    <code>property_info</code>  <code>zend_class_entry</code> .         : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $a = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $b; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $c; } struct _zend_class_entry { <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> HashTable function_table; HashTable properties_info; <span class="hljs-comment"><span class="hljs-comment">/* here are the properties infos about $a, $b and $c */</span></span> zval **default_properties_table; <span class="hljs-comment"><span class="hljs-comment">/* and here, we'll find $a, $b and $c with their default values */</span></span> int default_properties_count; <span class="hljs-comment"><span class="hljs-comment">/* this will have the value of 3 : 3 properties */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span></code> </pre><br> <code>Properties_infos</code>   ,      .    ,        <code>object-&gt;properties</code> .        scope (public/protected/private). <br><br>           ,     <code>__set()</code> .      ,      <code>object-&gt;property_table</code> . <br><br><pre> <code class="cpp hljs">property_info = zend_get_property_info_quick(zobj-&gt;ce, member, (zobj-&gt;ce-&gt;__set != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), key TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(property_info != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) &amp;&amp; ((EXPECTED((property_info-&gt;flags &amp; ZEND_ACC_STATIC) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; property_info-&gt;offset &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) ? (zobj-&gt;properties ? ((variable_ptr = (zval**)zobj-&gt;properties_table[property_info-&gt;offset]) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) : (*(variable_ptr = &amp;zobj-&gt;properties_table[property_info-&gt;offset]) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) : (EXPECTED(zobj-&gt;properties != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) &amp;&amp; EXPECTED(zend_hash_quick_find(zobj-&gt;properties, property_info-&gt;name, property_info-&gt;name_length+<span class="hljs-number"><span class="hljs-number">1</span></span>, property_info-&gt;h, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **) &amp;variable_ptr) == SUCCESS)))) { <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zend_guard *guard = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zobj-&gt;ce-&gt;__set &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">/* class has a __set() ? */</span></span> zend_get_property_guard(zobj, property_info, member, &amp;guard) == SUCCESS &amp;&amp; !guard-&gt;in_set) { Z_ADDREF_P(object); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PZVAL_IS_REF(object)) { SEPARATE_ZVAL(&amp;object); } guard-&gt;in_set = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* prevent circular setting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_std_call_setter(object, member, value TSRMLS_CC) != SUCCESS) { <span class="hljs-comment"><span class="hljs-comment">/* call __set() */</span></span> } guard-&gt;in_set = <span class="hljs-number"><span class="hljs-number">0</span></span>; zval_ptr_dtor(&amp;object); <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span></code> </pre><br>      ,     .        (   ),       . <br><br><h1> ,        </h1><br>    .     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($var)</span></span></span><span class="hljs-function"> </span></span>{ $var = <span class="hljs-number"><span class="hljs-number">42</span></span>; } $o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass; foo($o); var_dump($o); <span class="hljs-comment"><span class="hljs-comment">/* this is still an object, not the integer 42 */</span></span></code> </pre><br>   ,  ¬´ PHP 5   ¬ª,      .    .   ,      ,   . ,    ,   ,       . <br><br>   ,  <code>zval</code> ,    ,    ,    ,       .      .       <code>zval</code> ,           . <br><br> <code>object(MyClass)#1 (0) { } /* #1 is the object handle (number), it is unique */</code> <br> <br><img src="//habrastorage.org/files/633/fbc/1df/633fbc1dfb914465a76ea9cec923a672.png"><br><br> <code>Zend_object_store</code>      .              <code>new</code> ,  <code>unserialize()</code> , reflection API    <code>clone</code> .            . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_objects_store</span></span></span><span class="hljs-class"> {</span></span> zend_object_store_bucket *object_buckets; zend_uint top; zend_uint size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> free_list_head; } zend_objects_store; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_store_bucket</span></span></span><span class="hljs-class"> {</span></span> zend_bool destructor_called; zend_bool valid; zend_uchar apply_count; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _store_bucket { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">store_object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *object; <span class="hljs-keyword"><span class="hljs-keyword">zend_objects_store_dtor_t</span></span> dtor; <span class="hljs-keyword"><span class="hljs-keyword">zend_objects_free_object_storage_t</span></span> free_storage; <span class="hljs-keyword"><span class="hljs-keyword">zend_objects_store_clone_t</span></span> clone; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers *handlers; zend_uint refcount; gc_root_buffer *buffered; } obj; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; } free_list; } bucket; } zend_object_store_bucket;</code> </pre><br><h1>   $this? </h1><br>   <code>$this</code>    ,           :  ,         .. <code>$this</code>      ,      ‚Äî  , ¬´¬ª .       . <br><br> -,      <code>$this</code> .        ,     <code>$this</code> ,    . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opline_is_fetch_this(last_op TSRMLS_CC)) { zend_error(E_COMPILE_ERROR, <span class="hljs-string"><span class="hljs-string">"Cannot re-assign $this"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> zend_bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opline_is_fetch_this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zend_op *opline TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((opline-&gt;opcode == ZEND_FETCH_W) &amp;&amp; (opline-&gt;op1_type == IS_CONST) &amp;&amp; (Z_TYPE(CONSTANT(opline-&gt;op1.constant)) == IS_STRING) &amp;&amp; ((opline-&gt;extended_value &amp; ZEND_FETCH_STATIC_MEMBER) != ZEND_FETCH_STATIC_MEMBER) &amp;&amp; (Z_HASH_P(&amp;CONSTANT(opline-&gt;op1.constant)) == THIS_HASHVAL) &amp;&amp; (Z_STRLEN(CONSTANT(opline-&gt;op1.constant)) == (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-string"><span class="hljs-string">"this"</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>)) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(Z_STRVAL(CONSTANT(opline-&gt;op1.constant)), <span class="hljs-string"><span class="hljs-string">"this"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-string"><span class="hljs-string">"this"</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>   <code>$this</code> ?      ,       OPCode <code>INIT_METHOD_CALL</code> .  ,   ,    <code>$a-&gt;foo()</code>  <code>$a</code> .     <code>$a</code>     .       <code>OPCode DO_FCALL</code> .        (  )     <code>$this</code> - ‚Äî <code>EG(This)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;type == ZEND_USER_FUNCTION || fbc-&gt;common.scope) { should_change_scope = <span class="hljs-number"><span class="hljs-number">1</span></span>; EX(current_this) = EG(This); EX(current_scope) = EG(scope); EX(current_called_scope) = EG(called_scope); EG(This) = EX(object); <span class="hljs-comment"><span class="hljs-comment">/* fetch the object prepared in previous INIT_METHOD opcode and affect it to EG(This) */</span></span> EG(scope) = (fbc-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? fbc-&gt;common.scope : <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; EG(called_scope) = EX(call)-&gt;called_scope; }</code> </pre><br> ,   ,       <code>$this</code>        (, <code>$this-&gt;a</code> = 8),     OPCode <code>ZEND_ASSIGN_OBJ</code> , ,   ,   <code>$this</code>  <code>EG(This)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> zend_always_inline zval **_get_obj_zval_ptr_ptr_unused(TSRMLS_D) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(EG(This) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;EG(This); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zend_error_noreturn(E_ERROR, <span class="hljs-string"><span class="hljs-string">"Using $this when not in object context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br>   ,    <code>$this</code>    (, <code>$this-&gt;foo()</code> )      ( <code>$this-&gt;foo($this);</code> ),     <code>$this</code>    ,        .            : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_array-&gt;this_var != <span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; EG(This)) { Z_ADDREF_P(EG(This)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EG(active_symbol_table)) { EX_CV(op_array-&gt;this_var) = (zval **) EX_CV_NUM(execute_data, op_array-&gt;last_var + op_array-&gt;this_var); *EX_CV(op_array-&gt;this_var) = EG(This); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_hash_add(EG(active_symbol_table), <span class="hljs-string"><span class="hljs-string">"this"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-string"><span class="hljs-string">"this"</span></span>), &amp;EG(This), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zval *), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **) EX_CV_NUM(execute_data, op_array-&gt;this_var))==FAILURE) { Z_DELREF_P(EG(This)); } } }</code> </pre><br>    ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;type == ZEND_USER_FUNCTION || fbc-&gt;common.scope) { <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> EG(scope) = (fbc-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? fbc-&gt;common.scope : <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> }</code> </pre><br> <code>EG(scope)</code>    <code>zend_class_entry</code> .  ,     .         ,           : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> zend_always_inline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_verify_property_access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_property_info *property_info, zend_class_entry *ce TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (property_info-&gt;flags &amp; ZEND_ACC_PPP_MASK) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ACC_PUBLIC: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ACC_PROTECTED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_check_protected(property_info-&gt;ce, EG(scope)); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ACC_PRIVATE: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ce==EG(scope) || property_info-&gt;ce == EG(scope)) &amp;&amp; EG(scope)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>         ,   ,          : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A $obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; $obj-&gt;a = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* yes, this is possible */</span></span> } } $a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A; $b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A; $a-&gt;foo($b);</code> </pre><br>       -  .       PHP ‚Äî   ,        ,  .      ‚ÄúFoo‚Äù,       Foo   Foo,   . <br><br><h1>   </h1><br>  ,    ,  PHP        : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__destruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"byebye foo"</span></span>; } } $f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; thisfunctiondoesntexist(); <span class="hljs-comment"><span class="hljs-comment">/* fatal error, function not found, the Foo's destructor is NOT run */</span></span></code> </pre><br>         ,   - ?     : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdown_destructors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TSRMLS_D)</span></span></span><span class="hljs-function"> </span></span>{ zend_try { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> symbols; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { symbols = zend_hash_num_elements(&amp;EG(symbol_table)); zend_hash_reverse_apply(&amp;EG(symbol_table), (<span class="hljs-keyword"><span class="hljs-keyword">apply_func_t</span></span>) zval_call_destructor TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (symbols != zend_hash_num_elements(&amp;EG(symbol_table))); zend_objects_store_call_destructors(&amp;EG(objects_store) TSRMLS_CC); } zend_catch { <span class="hljs-comment"><span class="hljs-comment">/* if we couldn't destruct cleanly, mark all objects as destructed anyway */</span></span> zend_objects_store_mark_destructed(&amp;EG(objects_store) TSRMLS_CC); } zend_end_try(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zval_call_destructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zval **zv TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_PP(zv) == IS_OBJECT &amp;&amp; Z_REFCOUNT_PP(zv) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZEND_HASH_APPLY_REMOVE; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZEND_HASH_APPLY_KEEP; } }</code> </pre><br>      : <br><br><ul><li>             ,   refcount = 1. </li><li>    ,        ,  refcount &gt; 1. </li><li>        ,     . </li></ul><br>    : <br><br> <code>class Foo { public function __destruct() { var_dump("destroyed Foo"); } }</code> <br> <code>class Bar { public function __destruct() { var_dump("destroyed Bar"); } }</code> <br> <br>  : <br><br><pre> <code class="php hljs">$a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; $b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar; <span class="hljs-string"><span class="hljs-string">"destroyed Bar"</span></span> <span class="hljs-string"><span class="hljs-string">"destroyed Foo"</span></span></code> </pre><br>   : <br><br><pre> <code class="php hljs">$a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar; $b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; <span class="hljs-string"><span class="hljs-string">"destroyed Foo"</span></span> <span class="hljs-string"><span class="hljs-string">"destroyed Bar"</span></span></code> </pre><br>  : <br><br><pre> <code class="php hljs">$a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar; $b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; $c = $b; <span class="hljs-comment"><span class="hljs-comment">/* increment $b's object refcount */</span></span> <span class="hljs-string"><span class="hljs-string">"destroyed Bar"</span></span> <span class="hljs-string"><span class="hljs-string">"destroyed Foo"</span></span></code> </pre><br>  : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__destruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var_dump(<span class="hljs-string"><span class="hljs-string">"destroyed Foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>();} } <span class="hljs-comment"><span class="hljs-comment">/* notice the die() here */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__destruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var_dump(<span class="hljs-string"><span class="hljs-string">"destroyed Bar"</span></span>); } } $a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; $a2 = $a; $b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar; $b2 = $b; destroyed Foo</code> </pre><br>       .      ,      .      <code>__destruct()</code> .    PHP    ,       .         ,    . <br><br> PHP       -  .   ,     Zend  ,        ,        ,  ,   PHP.      ‚Äî     . ,  PHP 7 -  . <br><br>   ,   PHP   ,       <code>__get()</code>  <code>__set()</code> .      -    ,      ,        ( 8 , <code>ulimit ‚Äìs</code> )   PHP. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> function __destruct() { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; } <span class="hljs-comment"><span class="hljs-comment">/* you will crash */</span></span> }</code> </pre><br>  :      , ,    (lock mechanism),  PHP           .  -    ,        . PHP  ,  refcount     ,   ,          . <br><br><h1>  Conclusion </h1><br> ,          .     ,        .         .      ,         -,     ,         . </div><p>Source: <a href="https://habr.com/ru/post/255237/">https://habr.com/ru/post/255237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255225/index.html">Interview with skype-cheater</a></li>
<li><a href="../255229/index.html">MWC-2015: applicants for the role of 5G and a number of interesting innovations</a></li>
<li><a href="../255231/index.html">Layer caching over Linq to SQL</a></li>
<li><a href="../255233/index.html">14 tips on how to make tabs on the site more convenient</a></li>
<li><a href="../255235/index.html">Available fresh update ReSharper Ultimate</a></li>
<li><a href="../255239/index.html">Frame object in Python. What can and cannot be done with it (in production and in another decent place)</a></li>
<li><a href="../255241/index.html">Informer Vkontakte extension for Opera, Chrome and other browsers</a></li>
<li><a href="../255243/index.html">Overview of updates of the Microsoft Azure platform for March 2015. Many Open Source</a></li>
<li><a href="../255245/index.html">Run PHP script on schedule cron. When it's not so clear</a></li>
<li><a href="../255247/index.html">Step-by-step instructions for creating a portlet platform: Portlet description</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>