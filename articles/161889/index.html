<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Handling asynchronous errors with saving the request context in connect / express</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Those who had to develop more or less large web-projects for node.js, probably faced with the problem of handling errors that occurred within asynchro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Handling asynchronous errors with saving the request context in connect / express</h1><div class="post__text post__text-html js-mediator-article">  Those who had to develop more or less large web-projects for node.js, probably faced with the problem of handling errors that occurred within asynchronous calls.  This problem usually pops up not immediately, but when you already have a lot of written code that does something more than ‚ÄúHello, World!‚Äù <br><br><h4>  The essence of the problem </h4><a name="habracut"></a><br>  For example, take a simple connect application: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'connect'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Can\'t get name'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'World'</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = connect() .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = getName(); res.end(<span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + name + <span class="hljs-string"><span class="hljs-string">'!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { next(e); } }) .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, req, res, next</span></span></span><span class="hljs-function">) </span></span>{ res.end(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> + err.message); }); app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre> <br>  Here we have a synchronous function that, with some probability, generates an error.  We catch this error and pass it to the general error handler, which, in turn, shows the error to the user.  In this example, the function call occurs synchronously and error handling is no different from a similar task in other languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will try to do the same, but the getName function will be asynchronous: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'connect'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ process.nextTick(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { callback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Can\'t get name'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'World'</span></span>); } }); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = connect() .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ getName(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(err); res.end(<span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + name + <span class="hljs-string"><span class="hljs-string">'!'</span></span>); }); }) .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, req, res, next</span></span></span><span class="hljs-function">) </span></span>{ res.end(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> + err.message); }); app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre><br>  In this example, we can no longer catch the error through try / catch, since  it does not occur during a function call, but inside an asynchronous call that occurs later (in this example, at the next iteration of the event loop).  Therefore, we used the approach recommended by the developers of node.js ‚Äî we pass the error in the first argument of the callback function. <br><br>  This approach completely solves the problem of handling errors within asynchronous calls, but it greatly inflates the code when there are many such calls.  In a real application, there are many methods that call each other, can have nested calls and be part of chains of asynchronous calls.  And every time an error occurs somewhere in the depth of the call stack, we need to ‚Äúdeliver‚Äù it to the very top, where we can properly handle it and inform the user about the abnormal situation.  In a synchronous application, try / catch does it for us - there we can throw an error inside several nested calls and catch it where we can handle it correctly, without having to manually transfer it up the stack of calls. <br><br><h4>  Decision </h4><br><br>  In Node.JS, starting from version 0.8.0, a mechanism called <a href="http://nodejs.org/api/domain.html">Domain appeared</a> .  It allows you to catch errors inside asynchronous calls, while maintaining the execution context, unlike process.on ('uncaughtException').  I think there is no sense in retelling the Domain documentation here, because  the mechanism of its operation is quite simple, so I will immediately move on to the specific implementation of the universal error handler for connect / express. <br><br>  Connect / express wraps all middleware into try / catch blocks, so if you do a throw inside the middleware, the error will be passed to the error handler chain (middleware with 4 input arguments), and if there is no such middleware, to the default error handler which will output trace errors to the browser and console.  But this behavior is relevant only for errors that occurred in the synchronous code. <br><br>  With Domain, we can redirect errors that occur within asynchronous calls, in the context of a request, into the chain of error handlers of this request.  Now for us, ultimately, the processing of synchronous and asynchronous errors will look the same. <br><br>  For this purpose, I wrote a small middleware module for connect / express, which solves this problem.  The module is available on <a href="https://github.com/baryshev/connect-domain">GitHub</a> and in <a href="https://npmjs.org/package/connect-domain">npm</a> . <br><br>  Usage example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'connect'</span></span>), connectDomain = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'connect-domain'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = connect() .use(connectDomain()) .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Simple error'</span></span>); } setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Asynchronous error from timeout'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { res.end(<span class="hljs-string"><span class="hljs-string">'Hello from Connect!'</span></span>); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }) .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, req, res, next</span></span></span><span class="hljs-function">) </span></span>{ res.end(err.message); }); app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre><br>  In this example, errors thrown inside a synchronous and asynchronous call will be treated the same.  You can throw an error at any depth of calls in the context of the request, and it will be processed by a chain of error handlers for this request. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'connect'</span></span>), connectDomain = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'connect-domain'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = connect() .use(connectDomain()) .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Simple error'</span></span>); } setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { process.nextTick(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Asynchronous error from process.nextTick'</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { res.end(<span class="hljs-string"><span class="hljs-string">'Hello from Connect!'</span></span>); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }) .use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, req, res, next</span></span></span><span class="hljs-function">) </span></span>{ res.end(err.message); }); app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre><br><br>  In conclusion, I note that officially, the stability of the Domain module at the time of writing this article remains experimental, but I already use the described approach, even though I have not seen any problems in a small production.  The site using this module has never crashed and does not suffer from memory leaks.  Uptime process more than a month. </div><p>Source: <a href="https://habr.com/ru/post/161889/">https://habr.com/ru/post/161889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161879/index.html">Video: Mom first tests Windows 8, Ubuntu 12.10, Windows 1.0, Windows 3.1, Linux Mint Cinnamon 14, OSX 10.2, Elementary OS Luna, Kubuntu, Zorin OS 6.1, MS-DOS 6.22 and Microsoft Bob!</a></li>
<li><a href="../161881/index.html">Stallman called Ubuntu "spyware"</a></li>
<li><a href="../161883/index.html">Superparol concept - as additional protection for web-based email accounts</a></li>
<li><a href="../161885/index.html">Unofficial guide to the brain of Rich Hickey</a></li>
<li><a href="../161887/index.html">3D chess on HTML / CSS3 / JS</a></li>
<li><a href="../161891/index.html">AdMob integration into Cocos2d-x</a></li>
<li><a href="../161893/index.html">Pick your color - color matching and ideas for development.</a></li>
<li><a href="../161895/index.html">Twitter.Bootstrap.MVC4 - Twitter Bootstrap for ASP.NET MVC 4</a></li>
<li><a href="../161897/index.html">How I met the new year</a></li>
<li><a href="../161899/index.html">System-level optimization and its contribution to solving the problems of energy consumption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>