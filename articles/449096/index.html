<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We expand and supplement Kubernetes (review and video of the report)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On April 8, at the Saint HighLoad ++ 2019 conference, within the DevOps and Operation section, the report ‚ÄúExpand and supplement Kubernetes‚Äù was heard...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We expand and supplement Kubernetes (review and video of the report)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/kv/co/ra/kvcoraarvayusctrljjfqzvmukq.jpeg"><br><br>  On April 8, at the <a href="http://www.highload.ru/spb/2019/">Saint HighLoad ++ 2019</a> conference, within the DevOps and Operation section, the report ‚ÄúExpand and supplement Kubernetes‚Äù was heard, in the creation of which three Fleet employees took part.  In it, we talk about the many situations in which we wanted to expand and complement the capabilities of Kubernetes, but for which we did not find a ready and simple solution.  The necessary solutions appeared in the form of Open Source-projects, and this presentation is also devoted to them. <br><br>  By tradition, we are glad to present a <a href="https://www.youtube.com/watch%3Fv%3D6VHk1R1TNgk%26list%3DPL1mJ-PkCYnmB9vljnjxCMP3dlxQY3Dfcq"><b>video with the report</b></a> (50 minutes, much more informative than the article) and the main squeeze in text form.  Go! <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Kernel and add-ons in K8s </h2><br>  Kubernetes is changing the industry and administrative approaches that have long been established: <br><br><ul><li>  Thanks to his <b>abstractions</b> , we no longer operate with such concepts as configuring a config or launching a command (Chef, Ansible ...), but using grouping of containers, services, etc. </li><li>  We can prepare applications without thinking about the nuances of the <b>specific site</b> on which it will be launched: bare metal, the cloud of one of the providers, etc. </li><li>  With K8s, <b>best practices</b> in the organization of infrastructure have become more available than ever: scaling, self-healing, fault tolerance, etc. </li></ul><br>  However, of course, everything is not so smooth: with Kubernetes came their own - new - challenges. <br><br>  Kubernetes is <b>not</b> a combine that solves all the problems of all users.  <b>The</b> Kubernetes <b>kernel</b> is responsible only for the set of minimally necessary functions that are present in <b>each</b> cluster: <br><br><img src="https://habrastorage.org/webt/j4/bi/2r/j4bi2rovwoaeg30vtxmqvkf3gr0.png"><br><br>  The core set of primitives is defined in the Kubernetes core - for grouping containers, traffic control, and so on.  We talked about them in more detail in <a href="https://habr.com/company/flant/blog/331188/">a 2-year-old report</a> . <br><br> <a href="https://goo.gl/y4fXUF"><img src="https://habrastorage.org/webt/ri/3r/bh/ri3rbhiadlucbkmjxoi7evenkoc.png"></a> <br><br>  On the other hand, the K8s offers remarkable opportunities to expand the available features, which help to close and other - <b>specific</b> - user needs.  For additions to Kubernetes, cluster administrators are responsible, who must install and configure everything they need to ensure that their cluster ‚Äútakes on the necessary form‚Äù [to solve their specific tasks].  What are these additions?  Consider some examples. <br><br><h2>  Examples of additions </h2><br>  Having established Kubernetes, we may be surprised that the network, so necessary for the interaction of the pods both within the node and between the nodes, does not work by itself.  The Kubernetes kernel does not guarantee the necessary connections ‚Äî instead, it defines the network <b>interface</b> ( <a href="https://habr.com/ru/company/flant/blog/329830/">CNI</a> ) for third-party add-ons.  We must install one of these add-ons, which will be responsible for the network configuration. <br><br><img src="https://habrastorage.org/webt/y1/dz/kh/y1dzkhba60lopgq_nokdcisaols.png"><br><br>  A close example is storage solutions (local disk, network block device, Ceph ...).  Initially, they were in the kernel, but with the advent of <a href="https://habr.com/ru/company/flant/blog/424211/">CSI, the</a> situation changes to a similar one already described: in Kubernetes interface, and its implementation - in third-party modules. <br><br>  Among other examples: <br><br><ul><li>  <b>Ingress</b> controllers <i>(for a review, see <a href="https://habr.com/ru/company/flant/blog/447180/">our recent article</a> )</i> . </li><li>  <a href="https://github.com/jetstack/cert-manager"><b>cert-manager</b></a> : <br><br><img src="https://habrastorage.org/webt/jd/be/oc/jdbeocyiociiucegto-own0o6g0.gif"></li><li>  <a href="https://habr.com/ru/company/flant/blog/326414/"><b>Operators</b></a> are a whole class of add-ons (to which the cert-manager mentioned also applies), they define the primitive (s) and controller (s).  The logic of their work is limited only by our imagination and allows you to turn ready-made infrastructure components (for example, a DBMS) into primitives, which are much easier to work with (than with a set of containers and their settings).  There are a lot of operators written - even if many of them are not yet ready for production, it‚Äôs just a matter of time: <br><br><img src="https://habrastorage.org/webt/uu/yp/gi/uuypgi9fy-7ot0uho2vh27uq7nq.png"></li><li>  <b>Metrics</b> are another illustration of how Kubernetes separated the interface (Metrics API) from implementation (third-party add-ons such as the Prometheus adapter, Datadog cluster agent ...). </li><li>  For <b>monitoring and statistics</b> , where in practice you need not only <a href="https://habr.com/ru/company/flant/blog/412901/">Prometheus and Grafana</a> , but also kube-state-metrics, node-exporter, etc. </li></ul><br>  And this is far from a complete list of add-ons ... For example, we at the company "Flant" currently install <b>29 add-ons</b> for each Kubernetes-cluster (all of them create a total of 249 Kubernetes objects).  Simply put, we do not see the life of a cluster without additions. <br><br><h2>  Automation </h2><br>  Operators are designed to automate routine operations that we face every day.  Here are examples from life, an excellent solution for which is to write an operator: <br><br><ol><li>  There is a private (i.e. requiring login) registry with images for the application.  It is assumed that each pod has a special secret associated with it, allowing it to be authenticated in the registry.  Our task is to ensure that this secret is found in the namespace, so that pods can download images.  There can be a lot of applications (each of which needs a secret), and it is useful to regularly update the secrets themselves, so the option of unfolding secrets with your hands disappears.  This is where the operator comes to the rescue: we create a controller that will wait for the namespace to appear and add a secret to the namespace for this event. </li><li>  Let the default access from pods to the Internet is prohibited.  But sometimes it may be required: it is logical that the access resolution mechanism works simply, without requiring specific skills, for example, by the presence of a certain label in the namespace.  How can the operator help us here?  A controller is created that waits for a label to appear in the namespace and adds the appropriate policy for Internet access. </li><li>  A similar situation: even if we needed to add a certain <a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">taint</a> to the node, if it has a similar label (with some kind of prefix).  Operator actions are obvious ... </li></ol><br>  In any cluster, it is necessary to solve routine tasks, and <b>to</b> do it <b>correctly</b> - with the help of operators. <br><br>  Summing up all the described stories, we came to the conclusion that <b>for comfortable work in Kubernetes it is required</b> : a) to <b>install add-ons</b> , b) to <b>develop operators</b> (to solve everyday admin tasks). <br><br><h2>  How to write an operator for Kubernetes? </h2><br>  In general, the scheme is simple: <br><br><img src="https://habrastorage.org/webt/qt/jo/7u/qtjo7ujblxe_kbzr05hw0ixow1y.png"><br><br>  ... but it turns out that: <br><br><ul><li>  Kubernetes API is a fairly non-trivial thing that takes a lot of time to master; </li><li>  programming is not for everyone either (Go is selected as preferred because there is a special framework for it - <a href="https://github.com/operator-framework/operator-sdk">Operator SDK</a> ); </li><li>  with the framework itself, a similar situation. </li></ul><br>  Bottom line: <b>to write a controller</b> (operator) you have <b>to spend significant resources</b> to study the materiel.  This would be justified for ‚Äúlarge‚Äù operators - say, for MySQL DBMS.  But if we recall the examples described above (unfolding secrets, accessing pods to the Internet ...), which we also want to do right, we will understand that the effort expended will outweigh the result we need now: <br><br><img src="https://habrastorage.org/webt/zn/w3/9b/znw39bssazgqnsoe9mrsh8e7o6o.png"><br><br>  In general, a dilemma arises: spend a lot of resources and find the right tool for writing operators or act in the old way (but quickly).  To solve it - finding a compromise between these extremes - we created our own project: a <a href="https://github.com/flant/shell-operator"><b>shell-operator</b></a> <i>(see also its <a href="https://habr.com/ru/company/flant/blog/447442/">recent announcement</a> on Habr√©)</i> . <br><br><h2>  Shell-operator </h2><br>  How does he work?  In the cluster there is a pod in which the Go-binary with a shell-operator lies.  A set of <b>hooks</b> is stored next to it <i>(for more details, see below)</i> .  The shell-operator itself subscribes to certain <b>events</b> in the Kubernetes API, upon the occurrence of which it launches the corresponding hooks. <br><br>  How does a shell-operator understand what hooks to trigger on what events?  This information is passed to the shell-operator by the hooks themselves and they make it very simple. <br><br>  A hook is a script in Bash or any other executable file that supports the single argument <code>--config</code> and returns JSON in response.  The latter determines which objects it is interested in and which events (for these objects) should be responded to: <br><br><img src="https://habrastorage.org/webt/6m/7f/ei/6m7feilxyvybractmb6aoxj-olm.png"><br><br>  I will illustrate the implementation on a shell-operator of one of our examples - unfolding secrets for accessing a private registry with application images.  It consists of two stages. <br><br><h3>  Practice: 1. We write a hook </h3><br>  First of all, in the hook, we will process <code>--config</code> , indicating that we are interested in namespaces, and specifically - the moment of their creation: <br><br><pre> <code class="bash hljs">[[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> == <span class="hljs-string"><span class="hljs-string">"--config"</span></span> ]] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cat &lt;&lt; EOF { <span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>: [<span class="hljs-string"><span class="hljs-string">"add"</span></span>] } ] } EOF ‚Ä¶</code> </pre> <br>  What would logic look like?  Pretty simple too: <br><br><pre> <code class="bash hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> createdNamespace=$(jq -r <span class="hljs-string"><span class="hljs-string">'.[0].resourceName'</span></span> <span class="hljs-variable"><span class="hljs-variable">$BINDING_CONTEXT_PATH</span></span>) kubectl create -n <span class="hljs-variable"><span class="hljs-variable">${createdNamespace}</span></span> -f - &lt;&lt; EOF Kind: Secret ... EOF <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  The first step is to find out which namespace was created, and the second is to create a secret for this namespace through <code>kubectl</code> . <br><br><h3>  Practice: 2. Putting an image </h3><br>  It remains to pass the shell-operator created hook - how to do it?  The shell-operator itself comes in the form of a Docker image, so our task is to add a hook to a special directory in this image: <br><br><pre> <code class="plaintext hljs">FROM flant/shell-operator:v1.0.0-beta.1 ADD my-handler.sh /hooks</code> </pre> <br>  It remains to collect it and push it: <br><br><pre> <code class="bash hljs">$ docker build -t registry.example.com/my-operator:v1 . $ docker push registry.example.com/my-operator:v1</code> </pre> <br>  The final touch is to enclose the image in a cluster.  To do this, write <i>Deployment</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-operator spec: template: spec: containers: - name: my-operator image: registry.example.com/my-operator:v1 # 1 serviceAccountName: my-operator # 2</code> </pre> <br>  It is necessary to pay attention to two points: <br><br><ol><li>  an indication of the newly created image; </li><li>  This is a system component, which (at a minimum) needs rights to subscribe to events in Kubernetes and to lay out secrets by namespaces, so we create a ServiceAccount (and a set of rules) for the hook. </li></ol><br>  Result - we solved our problem in the Kubernetes way, creating an operator for unfolding secrets. <br><br><h3>  Other shell-operator features </h3><br>  To restrict the objects of the type you <b>choose</b> with which the hook will work, <b>you can filter them by</b> selecting them by specific labels (or using <code>matchExpressions</code> ): <br><br><pre> <code class="plaintext hljs">"onKubernetesEvent": [ { "selector": { "matchLabels": { "foo": "bar", }, "matchExpressions": [ { "key": "allow", "operation": "In", "values": ["wan", "warehouse"], }, ], } ‚Ä¶ } ]</code> </pre> <br>  There is <b>a deduplication mechanism</b> , which - using the jq-filter - allows you to convert large JSON's of objects into small ones, where only those parameters remain that we want to monitor for changes. <br><br>  When calling a hook, a shell-operator sends it <b>data about the object</b> that can be used for any needs. <br><br>  Events that occur when hooks are triggered are not limited to Kubernetes events: the shell operator has support for <b>calling hooks by time</b> (similar to crontab in the traditional scheduler), as well as the special <b>onStartup</b> event.  All these events can be combined and assigned to the same hook. <br><br>  And two more features of a shell-operator: <br><br><ol><li>  It works <b>asynchronously</b> .  From the moment the Kubernetes event was received (for example, the creation of an object) other events could have occurred in the cluster (for example, the deletion of the same object), and this should be taken into account in hooks.  If the hook was executed with an error, then by default it will <b>be recalled</b> until successful completion (this behavior can be changed). </li><li>  It exports <b>metrics</b> for Prometheus, with the help of which you can understand whether a shell-operator works, find out the number of errors for each hook and the current queue size. </li></ol><br>  Summing up this part of the report: <br><br><img src="https://habrastorage.org/webt/v2/aa/zo/v2aazotslqg8mvbgb4wbkrwz1do.png"><br><br><h2>  Install Add-ons </h2><br>  For comfortable work with Kubernetes, the need to install add-ons was also mentioned.  I will tell about it on the example of the way of our company to how we do it now. <br><br>  We started working with Kubernetes with several clusters, the only addition in which was Ingress.  It was required to install it in each cluster differently, and we made several YAML configurations for different environments: bare metal, AWS ... <br><br>  Clusters became more - more became and configurations.  In addition, we improved these configurations themselves, as a result of which they became quite heterogeneous: <br><br><img src="https://habrastorage.org/webt/sx/bb/3n/sxbb3ndabtfctyjimx7lzwvg-sk.png"><br><br>  To put everything in order, we started with a script ( <code>install-ingress.sh</code> ), which took as an argument the type of cluster into which we deploy, generated the necessary YAML configuration and rolled it into Kubernetes. <br><br>  In short, our further path and reasoning related to it were as follows: <br><br><ul><li>  To work with YAML configurations, a template engine is required (in the first stages, this is a simple sed); </li><li>  as the number of clusters grows, the need for an automatic update came (the earliest solution was to put the script in Git, we update and run it using cron); </li><li>  A similar script was needed for Prometheus ( <code>install-prometheus.sh</code> ), however, it is remarkable that it requires much more input data, as well as their storage (in a good way - centralized and in a cluster), and some data (passwords) could be automatically generated : <br><br><img src="https://habrastorage.org/webt/u9/3s/oe/u93soes0m24zohi4oy0ugk2uvcg.png"></li><li>  the risk of rolling out something wrong on a growing number of clusters was constantly growing, so we realized that the installers <i>(i.e. two scripts: for Ingress and Prometheus)</i> needed staging (several branches in Git, several cron'ov to update them in the corresponding: stable or test clusters); </li><li>  it became difficult to work with <code>kubectl apply</code> , because it is not declarative and can only create objects, but not make decisions on their status / delete them; </li><li>  some functions that we didn‚Äôt realize at all at that time were missing: <br><ul><li>  full control of the result of the cluster update, </li><li>  automatic detection of certain parameters (input for installation scripts) based on data that can be obtained from the cluster (discovery), </li><li>  its logical development in the form of continuous discovery. </li></ul></li></ul><br>  We have implemented all this accumulated experience as part of our other project, the <a href="https://github.com/flant/addon-operator"><b>addon-operator</b></a> . <br><br><h2>  Addon-operator </h2><br>  It is based on the shell-operator already mentioned.  The whole system looks like this: <br><br>  The shell-operator hooks are added: <br><br><ul><li>  <b>repository values</b> , </li><li>  <b>Helm chart</b> </li><li>  the component that <b>keeps</b> track of the <b>values' storage</b> and, in case of any changes, asks Helm to re-roll the chart. </li></ul><br><img src="https://habrastorage.org/webt/w8/8f/kf/w88fkfrbrukitlgx_u5jzauwtzq.gif"><br><br>  Thus, we can react to the event in Kubernetes, run the hook, and from this hook make changes to the repository, after which the chart will be redrawn.  In the resulting scheme, we select a set of hooks and a chart into one component, which we call a <b>module</b> : <br><br><img src="https://habrastorage.org/webt/b9/3j/qj/b93jqjumemaiju4cwcji2qnmaqw.png"><br><br>  There can be many modules, and to them we add global hooks, global values ‚Äã‚Äãstore and component that monitors this global store. <br><br>  Now that something is happening in Kubernetes, we can react to it with a global hook and change something in the global repository.  This change will be noticed and will cause all modules in the cluster to roll out: <br><br><img src="https://habrastorage.org/webt/ad/hh/e-/adhhe-ml3wrrqjks5dniduqxecg.gif"><br><br>  This scheme satisfies all the requirements for installing add-ons that have been voiced above: <br><br><ul><li>  Helm is responsible for standardization and declarativeness. </li><li>  The issue of auto-update has been resolved with the help of a global hook, which, according to the schedule, goes to the registry and, if it sees a new image of the system there, re-rolls it (ie, ‚Äúitself‚Äù). </li><li>  The storage of settings in the cluster is implemented using <i>ConfigMap</i> , in which the primary data for the storages are recorded (at startup they are loaded into the storages). </li><li>  Problems of password generation, discovery and continuous discovery are solved with the help of hooks. </li><li>  Staging is achieved thanks to tags that Docker supports out of the box. </li><li>  The control of the result is made with the help of metrics by which we can understand the status. </li></ul><br>  This entire system is implemented as a single binary on Go, which is called the addon-operator.  Thanks to this scheme looks simpler: <br><br><img src="https://habrastorage.org/webt/ip/2n/cf/ip2ncf-unok3h5azr8-icyby3hs.png"><br><br>  The main component on this diagram is a set of modules <i>(highlighted in gray below)</i> .  Now we can, with little effort, write a module for the desired add-on and be sure that it will be installed in each cluster, updated and respond to the events it needs in the cluster. <br><br>  "Flant" uses <a href="https://github.com/flant/addon-operator">addon-operator</a> on 70+ Kubernetes-clusters.  The current status is <b>alpha version</b> .  Now we are preparing documentation to release a beta, but for now <a href="https://github.com/flant/addon-operator/tree/master/examples">examples are available</a> in the repository, on the basis of which you can create your addon. <br><br>  Where can I get the modules for addon-operator?  Publishing our library is the next stage for us, we plan to do it in the summer. <br><br><h2>  Video and slides </h2><br>  Video from the performance (~ 50 minutes): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6VHk1R1TNgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Presentation of the report: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Other reports on our blog: <br><br><ul><li>  " <a href="https://habr.com/company/flant/blog/431500/">Databases and Kubernetes</a> ";  <i>(Dmitry Stolyarov; November 8, 2018 on HighLoad ++)</i> ; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/412901/">Monitoring and Kubernetes</a> ‚Äù;  <i>(Dmitry Stolyarov; May 28, 2018 on RootConf)</i> ; </li><li>  " <a href="https://habr.com/company/flant/blog/345116/">Best Practices CI / CD with Kubernetes and GitLab</a> ";  <i>(Dmitry Stolyarov; November 7, 2017 on HighLoad ++)</i> ; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> ‚Äù;  <i>(Dmitry Stolyarov; June 6, 2017 at RootConf)</i> . </li></ul><br>  You may also be interested in the following publications: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/447442/">Introducing shell-operator: creating operators for Kubernetes has become even easier</a> ." </li></ul></div><p>Source: <a href="https://habr.com/ru/post/449096/">https://habr.com/ru/post/449096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449086/index.html">Inside the flame: a new method for studying high-temperature reactive systems</a></li>
<li><a href="../449088/index.html">It is time for investors and entrepreneurs to start solving mental health problems in startups.</a></li>
<li><a href="../449090/index.html">Dynamically changing the JSON schema in Go using gob</a></li>
<li><a href="../449092/index.html">Three paradigms of asynchronous programming in Vertx</a></li>
<li><a href="../449094/index.html">Startup Psychology: Transformations That Not All Will Survive</a></li>
<li><a href="../449098/index.html">As a ‚Äúspy‚Äù company, it made its way into the Mozilla certificate store and what came of it</a></li>
<li><a href="../4491/index.html">Privacy died in the information age</a></li>
<li><a href="../44910/index.html">Minucion: and happiness seems so close!</a></li>
<li><a href="../449100/index.html">In the footsteps of RTM. Forensic investigation of a computer infected with a banking trojan</a></li>
<li><a href="../449106/index.html">UPS for banking and financial institutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>