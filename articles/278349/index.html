<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interesting ways to use Go channels (translation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer you a translation of the article by Gary Willoughby ‚ÄúInteresting ways of using the go channels‚Äù . 

 This article is intended for those who ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interesting ways to use Go channels (translation)</h1><div class="post__text post__text-html js-mediator-article">  <i>I offer you a translation of the article by <a href="http://nomad.so/author/admin/">Gary Willoughby</a> <a href="http://nomad.so/2016/01/interesting-ways-of-using-go-channels/">‚ÄúInteresting ways of using the go channels‚Äù</a> .</i> <br><br>  <i>This article is intended for those who are already a little versed in Go.</i> <br><br> <a href="https://habrahabr.ru/post/278349/"><img src="https://habrastorage.org/files/0be/61c/112/0be61c1121d04bb6984359dbd0a47576.jpg" alt="gopher"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Interesting ways to use go channels </h2><br>  I wrote this post to document the John Graham-Cumming Channels report on Go at the 2014 GopherCon conference. The report was called ‚ÄúA Quick Guide to Channels‚Äù and is available for viewing on <a href="https://www.youtube.com/watch%3Fv%3DSmoM1InWXr0">youtube.com</a> . <br><br>  Throughout the report, we are presented with interesting ways to use Go channels and reveal the possibilities and advantages of competitive programming.  Personally, this report opened my eyes to several new ways of structuring programs and new techniques for synchronizing across several processor cores. <br><br>  The following examples demonstrate different techniques for how to use feeds in Go.  The code has been specially simplified for their understanding.  You should not use it for production versions.  For example, all error handling is missing. <br><a name="habracut"></a><br><h3>  Signals </h3><br><h4>  Waiting for event </h4><br>  In this example, the gorutin starts, does some work (in this case waits 5 seconds), then closes the channel.  Unbuffered channels always stop the execution of the current gorutine until a message arrives.  The closure of the channel signals the gorutina that it can continue its execution, because no more data can be obtained.  Closed channels never stop the execution of gorutiny. <br><br><pre><code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ...  - time.Sleep(time.Second * 5) close(c) }() //          . &lt;-c fmt.Println("Done") }</span></span></code> </pre> <br><h4>  Coordination of several gorutin </h4><br>  In this example, a hundred gorutin is started, waiting for data transmission through the start channel (or its closing).  In the case when it is closed, all the gorutiny will start. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { &lt;-start <span class="hljs-comment"><span class="hljs-comment">// ...  - } func main() { start := make(chan bool) for i := 0; i &lt; 100; i++ { go worker(start) } close(start) // ...  worker's   }</span></span></code> </pre><br><h4>  Coordinated termination of workers </h4><br>  In this example, a hundred gorutin is launched, waiting for data transmission through the die channel (or its closing).  In the case when it will be closed, all the gorutines will stop executing. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main func worker(<span class="hljs-keyword"><span class="hljs-keyword">die</span></span> chan bool) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...  -   case case &lt;-<span class="hljs-keyword"><span class="hljs-keyword">die</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } func main() { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> := make(chan bool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++ { go worker(<span class="hljs-keyword"><span class="hljs-keyword">die</span></span>) } //   worker<span class="hljs-string"><span class="hljs-string">'. close(die) }</span></span></code> </pre><br><h4>  Check for worker stopping </h4><br>  In this example, the Gorutin is launched, waiting for data transmission from the die channel (or its closure).  In the case when the signal arrives, the gorutina will perform the final actions and send a signal to the main function (through the same die channel) that it is complete. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main func worker(<span class="hljs-keyword"><span class="hljs-keyword">die</span></span> chan bool) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...  -   case case &lt;-<span class="hljs-keyword"><span class="hljs-keyword">die</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...     . <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> &lt;- true <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } func main() { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> := make(chan bool) go worker(<span class="hljs-keyword"><span class="hljs-keyword">die</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> &lt;- true // ,      &lt;-<span class="hljs-keyword"><span class="hljs-keyword">die</span></span> }</code> </pre><br><h3>  Encapsulate state </h3><br><h4>  Unique Service ID </h4><br>  In this example, the gorutin is run to generate unique hex id's.  Each id is sent through the channel id and the gorutin is suspended until the message from the channel is read.  Each time a channel is read, the horoutine increments the counter and sends its value. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { id := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { id &lt;- fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%x"</span></span>, counter) counter += <span class="hljs-number"><span class="hljs-number">1</span></span> } }() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, &lt;-id) <span class="hljs-comment"><span class="hljs-comment">// will be 1 fmt.Printf("%s\n", &lt;-id) // will be 2 }</span></span></code> </pre><br><h4>  Memory reuse </h4><br>  In this example, the gorutin is run to reuse the memory buffers.  The give channel gets old memory buffers and saves them to the list.  At this time, the get channel allocates these buffers for use.  If there are no available buffers in the list, a new one is created. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>Simply put, we actively reuse memory in order not to allocate it once again (as we know, the OS can allocate memory for a very long time).</i>  <i>A list is used, in which there is always at least 1 buffer.</i>  <i>And already used buffers are sent back to the same list.</i> <br></div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"container/list"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { give := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) get := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { q := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(list.List) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> q.Len() == <span class="hljs-number"><span class="hljs-number">0</span></span> { q.PushFront(<span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)) } e := q.Front() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s := &lt;-give: q.PushFront(s) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> get &lt;- e.Value.([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>): q.Remove(e) } } }() <span class="hljs-comment"><span class="hljs-comment">//    buffer := &lt;-get //   give &lt;- buffer //    buffer = &lt;-get }</span></span></code> </pre><br><h4>  Limited memory reuse </h4><br>  In this example, the buffered channel is used as buffer storage.  The channel is configured to store five buffers at any one time.  This means that the channel does not block the current gorutin, if it has room for another record. <br><br>  Select provides non-blocking access to this channel in case it is filled.  The first select creates a new buffer if it cannot be retrieved from the repository.  The second select does not do anything by default if it is not possible to put a buffer in the storage, which causes the GC to clear this buffer. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>Here again I want to add from myself.</i>  <i>We simply create a buffered channel that limits the number of buffers that we want to ‚Äúreuse‚Äù.</i>  <i>And if an ‚Äúextra‚Äù buffer comes to us, we ignore it, allowing the garbage collector to work.</i>  <i>In this case, both functions are non-blocking, that is, they do not expect to receive data from anyone.</i> <br></div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(store </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> b := &lt;-store: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(store </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> store &lt;- b: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . store := make(chan []byte, 5) //     . buffer := get(store) //     . give(store, buffer) //      . buffer = get(store) }</span></span></code> </pre><br><h3>  Nil feeds </h3><br><h4>  Disabling the receipt of messages in the case statement </h4><br>  In this example, the Gorutin is started and select is used to receive messages from two channels.  If the channel is closed, it is set to nil.  Since nil channels always block execution, this case is no longer executed.  If both channels are set to nil, we will exit the mountain because it can no longer receive anything. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>In the example, the second displayed value is false, because after closing c1 we got x = false and ok = false.</i>  <i>If we did not assign the value nil to the channel c1, then in our infinite loop we would continue to receive infinitely x = false, ok = false.</i> <br><br>  <i>An important thought.</i>  <i>If you close a channel, then its case will always receive the default value.</i>  <i>Therefore, you should assign nil to the closed channel.</i>  <i>And after that you should not forget to check all the channels on nil, otherwise you can permanently block your mountain.</i> <br></div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c1 := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) c2 := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x, ok := &lt;-c1: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { c1 = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } fmt.Println(x) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x, ok := &lt;-c2: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { c2 = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } fmt.Println(x) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c1 == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> &amp;&amp; c2 == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } }() c1 &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">//   case  select'a . close(c1) c2 &lt;- true }</span></span></code> </pre><br><h4>  Disabling the sending of messages in the case statement </h4><br>  In this example, Gorutin is launched and used to generate random numbers and send them to channel c.  When a message arrives on channel d, channel c is set to nil, disabling the corresponding case statement.  A disabled Gorutin never generates random numbers again. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>Here, checking for nil would not hurt, otherwise our gorutin does not finish its execution.</i>  <i>It was blocked on select, since the first case will never be executed, and the second has lost its meaning.</i> <br><br>  <i>There is an error in the comment - c in the second last line is not equal to nil, nil was set only for the local variable src.</i>  <i>And deadlock occurs because our channel c is no longer recorded by anyone.</i> <br></div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"math/rand"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) d := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> src &lt;- rand.Intn(<span class="hljs-number"><span class="hljs-number">100</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-d: src = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } }(c) <span class="hljs-comment"><span class="hljs-comment">//    . fmt.Printf("%d\n", &lt;-c) fmt.Printf("%d\n", &lt;-c) //    . d &lt;- true //   ,    c  nil. fmt.Printf("%d\n", &lt;-c) }</span></span></code> </pre><br><h3>  Timers </h3><br><h4>  Time-out </h4><br>  In this example, Gorutina is launched to do some work.  The timeout channel is created to ensure that case executes if select takes too long.  In this case, the gorutina ends after 30 seconds of waiting.  The timeout is recreated every select iteration to ensure that it is successfully executed.  In each subsequent iteration, the timeout is reset. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>There is a small misprint - in the code 5 seconds, and in article 30.</i> </div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeout := time.After(<span class="hljs-number"><span class="hljs-number">5</span></span> * time.Second) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ...  - case &lt;-timeout: //      . return } } } func main() { go worker() }</span></span></code> </pre><br><h4>  Heartbeat </h4><br>  In this example, Gorutina is started to do some work.  The heartbeat channel is designed to execute a case statement at regular intervals.  The heartbeat channel is not reset at each iteration so that the case statement is always executed on time. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { heartbeat := time.Tick(<span class="hljs-number"><span class="hljs-number">30</span></span> * time.Second) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ...  - case &lt;-heartbeat: // ...  -   } } } func main() { go worker() }</span></span></code> </pre><br><h3>  Examples </h3><br><h4>  Network multiplexer </h4><br>  This example demonstrates a simple network multiplexer.  In our main gorutin, a channel is created for processing the transmitted messages and a network connection is established.  Then, hundreds of gorutin runs to generate strings (which act like our messages) and send them through this channel.  Each message is read from the channel over an infinite loop and sent to the network connection. <br><br>  This example does not start (because we are trying to connect to the test domain), but it shows how easy it is to run many asynchronous processes that send messages to a single network connection. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...   messages &lt;- msg } } func main() { messages := make(chan string) conn, _ := net.Dial("tcp", "example.com") for i := 0; i &lt; 100; i++ { go worker(messages) } for { msg := &lt;-messages conn.Write([]byte(msg)) } }</span></span></code> </pre><br><h4>  First answer </h4><br>  In this example, each url from the array is transferred to a separate gorutina.  Each gorutina is executed asynchronously and requests the url passed to it.  Each response to the request is transmitted to the first channel, which, of course, ensures that the first response received will go to the channel first.  Then we can read this response from the channel and process it accordingly. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>The example is again not working (swears at the unused variable r).</i>  <i>Here is a similar example - <a href="https://youtu.be/f6kdp27TYZs%3Ft%3D33m43">youtube.com</a> .</i>  <i>I recommend to watch this video entirely.</i> <br></div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { resp *http.Response url <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> resp, err := http.Get(url); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { r &lt;- response{resp, url} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { first := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> response) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"http://code.jquery.com/jquery-1.9.1.min.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"</span></span>} { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get(url, first) } r := &lt;-first <span class="hljs-comment"><span class="hljs-comment">// ...  - }</span></span></code> </pre><br><h4>  Send response channel </h4><br>  In this example, the channel w is created to transfer tasks to Gorutin.  Gorutina receives the task and makes a request to the url contained in it.  The resp channel also comes to the mountain as part of the task.  As soon as the request is completed, the response is sent back through the resp.  This allows this gorutina to process tasks and send the result back through different channels configured for each individual task. <br><br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  <i>If it is simpler, for each of our tasks we create our own channel for the answer, through which we send the results to us.</i> <br></div></div><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> work <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { url <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> resp <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *http.Response } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { do := &lt;-w resp, _ := http.Get(do.url) do.resp &lt;- resp } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { w := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> work) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> getter(w) resp := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *http.Response) w &lt;- work{<span class="hljs-string"><span class="hljs-string">"http://cdnjs.cloudflare.com/jquery/1.9.1/jquery.min.js"</span></span>, resp} r := &lt;-resp <span class="hljs-comment"><span class="hljs-comment">// ...  - }</span></span></code> </pre><br><h4>  HTTP load balancer </h4><br>  This example creates a load balancer based on the previous examples.  It processes read from stdin url'y and for everyone starts the gorutina for processing.  Each request passes through a load balancer to filter out these tasks for a limited number of workers.  These workers process requests and return results to a single answer channel. <br><br>  Using a load balancer like this allows you to send a huge number of requests, distribute them to all available resources and process them in an ordered manner. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> job <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { url <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> resp <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *http.Response } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> worker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { jobs <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *job count <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w *worker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(done </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *worker)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { j := &lt;-w.jobs resp, _ := http.Get(j.url) j.resp &lt;- resp done &lt;- w } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jobs </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *job, url </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, answer </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { resp := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *http.Response) jobs &lt;- &amp;job{url, resp} r := &lt;-resp answer &lt;- r.Request.URL.String() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balancer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(count </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, depth </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">job</span></span></span></span> { jobs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *job) done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *worker) workers := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*worker, count) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++ { workers[i] = &amp;worker{<span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *job, depth), <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> workers[i].getter(done) } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> free *worker min := depth <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, w := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> workers { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.count &lt; min { free = w min = w.count } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jobsource <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *job <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> free != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { jobsource = jobs } <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> j := &lt;-jobsource: free.jobs &lt;- j free.count++ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> w := &lt;-done: w.count-- } } }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobs } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { jobs := balancer(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) answer := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Scanln(&amp;url); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get(jobs, url, answer) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> u := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> answer { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, u) } }</code> </pre><br><h3>  Conclusion </h3><br>  Go is a language that, from my point of view, has problems, but it is a language that I am willing to learn and use.  The ideas from this presentation opened up new concepts for me and after it I wanted to start a new project that will take advantage of the fantastic support for competitiveness in Go.  She also stressed the need to read and understand the standard library provided by languages ‚Äã‚Äãsuch as Go in order to better understand the nature and design of the language. </div><p>Source: <a href="https://habr.com/ru/post/278349/">https://habr.com/ru/post/278349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278339/index.html">Microsoft can integrate the Linux subsystem in the new release of Windows 10</a></li>
<li><a href="../278341/index.html">Why Habr died. What to do and where to run</a></li>
<li><a href="../278343/index.html">Chapter 21. Part 1 - Creating objects and data output objects. PowerShell in depth - Don Jones, Richard Siddaway</a></li>
<li><a href="../278345/index.html">MSLibrary. Capture and verify phone numbers using regular expressions, for iOS and not only ... Part 1</a></li>
<li><a href="../278347/index.html">Oracle IaaS and PaaS - all for you</a></li>
<li><a href="../278351/index.html">How to create objects in PowerShell</a></li>
<li><a href="../278353/index.html">No, "Habr" does not die</a></li>
<li><a href="../278359/index.html">MSLibrary. Capturing and verifying phone numbers using regular expressions, for iOS and not only ... Part 2</a></li>
<li><a href="../278361/index.html">Preparing for the CISA exam. Benefits of Business Continuity</a></li>
<li><a href="../278363/index.html">Alljoyn: embedded view of the developer. Part 3: Porting on MK SAMD21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>