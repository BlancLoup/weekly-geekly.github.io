<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tasks, microtasks, queues and plans</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I bring to your attention a translation of the article ‚ÄúTasks, microtasks, queues and schedules‚Äù by Jake Archibald (Jake Achibald), who is in the posi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tasks, microtasks, queues and plans</h1><div class="post__text post__text-html js-mediator-article">  <i>I bring to your attention a translation of the <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">article ‚ÄúTasks, microtasks, queues and schedules‚Äù by</a> Jake Archibald (Jake Achibald), who is in the position of Developer Advocate for Google Chrome.</i> <br><br>  When I told my colleague Matt Gant that I was thinking about writing an article about the sequence of microtasks and the order of their execution within the browser‚Äôs event cycle, he said, "Jake, I will be honest, I will not read about this."  Well, I nevertheless wrote, so sit back and let‚Äôs see it together, okay? <br><br>  In fact, if it will be easier for you to watch the video, there is a <a href="https://www.youtube.com/watch%3Fv%3D8aGhZQkoFbQ">wonderful speech by</a> Philip Roberts at JSConf, which talks about the event cycle - it does not cover microtasks, but otherwise it is a great introduction to the topic.  In any case, they drove ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's look at the following javascript code: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'promise1'</span></span>); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'promise2'</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'script end'</span></span>);</code> </pre> <br>  What do you think, in what order should the logs be displayed? <br><a name="habracut"></a><br>  The correct answer is: <code>script start</code> , <code>script end</code> , <code>promise1</code> , <code>promise2</code> and <code>setTimeout</code> , however, while the order in different browsers is quite often different. <br><br>  Microsoft Edge, Firefox 40, iOS Safari and Desktop Safari 8.0.8 log <code>setTimeout</code> before <code>promise1</code> and <code>promise2</code> .  What is really strange is that Firefox 39 and Safari 8.0.7 worked correctly. <br><br><h3>  Why it happens </h3><br>  For a more accurate understanding of the process, you must first imagine how the event loop processes tasks and microtasks.  For the first time, this may seem too complicated.  Deep breath‚Ä¶ <br><br>  Each ‚Äústream‚Äù has its own event loop, and therefore every web worker, so that they can run independently, while all windows from the same domain (according to the same origin rule) share the same event loop, because they can Communicate synchronously with each other.  The event cycle runs continuously, executing queued tasks.  Tasks are performed sequentially and cannot intersect.  Okay, okay, don't leave ... <br><br>  Tasks are planned in such a way that the browser can step out of their wilds to the ground of JavaScript / DOM and be sure that these actions take place alternately.  Handling a mouse click event callback requires task scheduling, as well as parsing HTML and <code>setTimeout</code> from the example above. <br><br>  <code>setTimeout</code> waits for a specified delay and then plans a new task for its callback.  Therefore, <code>setTimeout</code> is output to the log after <code>script end</code> , since <code>script end</code> logging is part of the first task, and the output of the word <code>setTimeout</code> is the second.  Have patience, we are almost at the goal, ahead of the most interesting ... <br><br>  Microtasks are usually planned for things that should be executed immediately after the current executable script.  For example, responding to a stack of actions or to do something asynchronously without having to lose performance from scratch because of a completely new task.  The microtask queue unfolds at the end of each complete task, as well as after callbacks in the event that no other JavaScript is at the execution stage.  Any additional microtasks that are queued during the deployment of a microtask queue are added to the end of the queue and are also processed.  Microtasks include mutation observer callouts and promises, as in the example above. <br><br>  As soon as the promise is solved or if it has already been resolved, he queues the microtask for the execution of the kolbek.  This makes sure that promise callbacks are executed asynchronously, even if they are already solved.  So, the <code>.then(func)</code> call for a resolved promise immediately queues a microtask.  That is why <code>promise1</code> and <code>promise2</code> are output to the log after the <code>script end</code> , because the current executable script must complete before microtasks are processed.  <code>promise1</code> and <code>promise2</code> are logged before <code>setTimeout</code> for microtasks are always deployed to the next big task. <br><br>  <i>Note</i>  <i>translator: in this place, the author originally inserted a great <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">visual presentation of the work of the JavaScript scheduler</a> , but I hardly have the technical opportunity to repeat this on Habr√©, for this I am sending an inquisitive reader to the original page.</i> <br><br>  Yes, I really did a step-by-step animated diagram.  How did you spend your Saturday, probably walking somewhere outdoors with friends?  Well, I - no.  In case something is not clear in my awesome UI, try clicking the arrows left and right. <br><br><h4>  What is wrong with some browsers? </h4><br>  They log <code>script start</code> , <code>script end</code> , <code>setTimeout</code> , <code>promise1</code> and <code>promise2</code> .  Promise calls are executed after these <code>setTimeout</code> .  It seems that for the promise callbacks there is a whole separate task instead of a simple microsadget.  This behavior can lead to performance problems when using promises, because Kolbek can unfairly be postponed until rendering and other things related to a large task.  Here are applications for correcting anomalies in <a href="https://connect.microsoft.com/IE/feedback/details/1658365">Edge</a> and <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1195336">Firefox</a> <i>(note of the translator: by the time the translation was written in the application for Firefox, it turned out that only the 40th and 41th versions suffer from unexpected behavior, and since the 42nd anomaly is not reproduced)</i> .  The nightly builds of WebKit are behaving as expected, so I guess that soon Safari will return to the righteous path again. <br><br><h3>  How to understand when tasks are used, and when micro tasks are used. </h3><br>  Although this is how we make the assumption that the implementation is correct, the only way is to test.  See order of log output regarding promises and <code>setTimeout</code> . <br><br>  The exact way is to see the specification.  For example, <a href="https://html.spec.whatwg.org/multipage/webappapis.html">step 14 <code>setTimeout</code></a> task, whereas <a href="https://dom.spec.whatwg.org/">in the mutation fix specification step 5</a> creates a microtask. <br><br>  In the ECMAScript world, microtasks are called jobs.  In <a href="http://www.ecma-international.org/ecma-262/6.0/">step 8.a of the PerformPromiseThen specification</a> for queuing microtasks, EnqueueJob is <code>EnqueueJob</code> .  Unfortunately, for the time being there is no explicit relationship between tasks (‚Äújobs‚Äù) and microtasks, however, <a href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers">in one of the es-discuss mailings it</a> was mentioned that they should use a common queue. <br><br>  Now let's take a look at a more comprehensive example.  <i>In the hall, someone will cry out in confusion, ‚ÄúNo, they are not ready!‚Äù.</i>  Do not pay attention, you are ready. <br><br><h3>  Level One: Fight with the Boss </h3><br>  The following problem might seem complicated to me before I wrote this post.  Here is a small piece of HTML: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"outer"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inner"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Logically, what will the next javascript code log if I click the <code>div.inner</code> ? <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      var outer = document.querySelector('.outer'); var inner = document.querySelector('.inner'); //     //    outer new MutationObserver(function() { console.log('mutate'); }).observe(outer, { attributes: true }); //    ‚Ä¶ function onClick() { console.log('click'); setTimeout(function() { console.log('timeout'); }, 0); Promise.resolve().then(function() { console.log('promise'); }); outer.setAttribute('data-random', Math.random()); } // ‚Ä¶      inner.addEventListener('click', onClick); outer.addEventListener('click', onClick);</span></span></code> </pre><br>  Try to think before you go to the answer.  Hint: logs can be displayed more times. <br><br><h3>  Test </h3><br>  <i>Note</i>  <i>translator: the author in this place in the blog has <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">an interactive DOM element</a> (direct link) where you can personally check the behavior of your browser.</i> <br><br>  You thought it would be different?  I hasten to reassure you, perhaps you were right.  Unfortunately, different browsers have different degrees of acceptance of this opinion: <br><table><tbody><tr><th><img src="https://habrastorage.org/files/464/898/c98/464898c9861e47c192bed9eb7b0daddb.png" width="100"></th><th><img src="https://habrastorage.org/files/f7a/98f/24c/f7a98f24c81046a794e37470778894f1.png" width="100"></th><th><img src="https://habrastorage.org/files/a09/08d/f60/a0908df603174d5f92b5d8bb543cbafa.png" width="100"></th><th><img src="https://habrastorage.org/files/5e1/458/b02/5e1458b02a804e13be7c1b5abb386b66.png" width="100"></th></tr><tr><td><ul><li>  click </li><li>  promise </li><li>  mutate </li><li>  click </li><li>  promise </li><li>  mutate </li><li>  timeout </li><li>  timeout </li></ul><br></td><td><ul><li>  click </li><li>  mutate </li><li>  click </li><li>  mutate </li><li>  timeout </li><li>  promise </li><li>  promise </li><li>  timeout </li></ul></td><td><ul><li>  click </li><li>  mutate </li><li>  click </li><li>  mutate </li><li>  promise </li><li>  promise </li><li>  timeout </li><li>  timeout </li></ul></td><td><ul><li>  click </li><li>  click </li><li>  mutate </li><li>  timeout </li><li>  promise </li><li>  timeout </li><li>  promise </li></ul></td></tr></tbody></table><h3>  Who is right? </h3><br>  Handling a click event is a task.  Kolki Mutation observer and promise are queued as microtasks.  Kolbek <code>setTimeout</code> is a task.  <i>(Note of the translator: here again <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">an interactive diagram</a> explaining step by step the principle of operation of the code given earlier, I recommend to take a look.)</i> <br><br>  So Chrome behaves correctly.  For me, the news was to find out that microtasks are deployed after callbacks (unless this is part of the execution of another JavaScript script), I thought that their deployment is limited only by the end of the task.  This rule is described in the HTML specification for calling callbacks: <br><blockquote>  <a href="https://html.spec.whatwg.org/multipage/webappapis.html">Perform a microtask checkpoint</a> <br>  - <a href="https://html.spec.whatwg.org/multipage/webappapis.html">HTML: Cleaning up after a callback</a> , step 3 <br></blockquote>  ... and checkpoint microtasks means nothing more than deploying a queue of microtasks, unless we are already deploying a queue of microtasks.  And this is what the ECMAScript job specification tells us (‚Äújobs‚Äù): <br><blockquote>  There is no running for you. <br>  - <a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript: Jobs and Job Queues</a> <br></blockquote>  ... although "can be" in the context of HTML has the character of "must be", i.e.  "must". <br><br><h3>  What did the browsers misunderstand? </h3><br>  <b>Firefox</b> and <b>Safari</b> rightly empty the queue of microtasks between click handlers, as can be seen from the callback mutations, but promises are queued differently.  This could be forgiven, especially given the nebula of communication between the task (‚Äújobs‚Äù) and the microtask, but I expected them to be executed between the processors.  <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1193394">Application for Firefox.</a>  <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D147933">Application for Safari.</a> <br><br>  We already understood that Edge did not place the promises in the queue correctly, but he also did not empty the microtasks queue between click handlers, instead, the queue turned around only after calling all the handlers, which explains the only output <code>mutate</code> after both <code>click</code> in the magazine.  <a href="https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners">This is mistake.</a> <br><br><h3>  Boss's Evil Brother from Level One </h3><br>  Pancake!  And what if to add to the previous example: <br><pre> <code class="javascript hljs">inner.click();</code> </pre><br>  The event will begin to be processed in the same way as before, but by calling from the script, and not from the actual user interaction. <br><br><h3>  Test </h3><br>  <i>Note</i>  <i>translator: in the original there is another <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">interactive platform</a> where you can click a button and find out the correct answer for your browser (direct link).</i> <br><table><tbody><tr><th><img src="https://habrastorage.org/files/464/898/c98/464898c9861e47c192bed9eb7b0daddb.png" width="100"></th><th><img src="https://habrastorage.org/files/f7a/98f/24c/f7a98f24c81046a794e37470778894f1.png" width="100"></th><th><img src="https://habrastorage.org/files/a09/08d/f60/a0908df603174d5f92b5d8bb543cbafa.png" width="100"></th><th><img src="https://habrastorage.org/files/5e1/458/b02/5e1458b02a804e13be7c1b5abb386b66.png" width="100"></th></tr><tr><td><ul><li>  click </li><li>  click </li><li>  promise </li><li>  mutate </li><li>  promise </li><li>  timeout </li><li>  timeout </li></ul></td><td><ul><li>  click </li><li>  click </li><li>  mutate </li><li>  timeout </li><li>  promise </li><li>  promise </li><li>  timeout </li></ul></td><td><ul><li>  click </li><li>  click </li><li>  mutate </li><li>  promise </li><li>  promise </li><li>  timeout </li><li>  timeout </li></ul></td><td><ul><li>  click </li><li>  click </li><li>  mutate </li><li>  timeout </li><li>  promise </li><li>  timeout </li><li>  promise </li></ul></td></tr></tbody></table>  And I do not cease to receive various results in Chrome, I have already updated this table a hundred times thinking that I had previously mistakenly checked in Canary.  If you have other results in Chrome, tell me in the comments on which version you are. <br><br><h3>  Why is it different now? </h3><br>  <i>Note</i>  <i>translator: in this place, one more last time, the author gives us the opportunity to enjoy the <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">visualization of the wonders of</a> browser <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">builders' engineering ideas</a> (link, again, direct).</i> <br><br>  So the correct order is the following: <code>click</code> , <code>click</code> , <code>promise</code> , <code>mutate</code> , <code>promise</code> , <code>timeout</code> and the last <code>timeout</code> , which seems to mean that Chrome is working correctly. <br><br>  After each of the click handlers is called ... <br><blockquote>  <a href="https://html.spec.whatwg.org/multipage/webappapis.html">Perform a microtask checkpoint</a> <br>  - <a href="https://html.spec.whatwg.org/multipage/webappapis.html">HTML: Cleaning up after a callback</a> , step 3 <br></blockquote>  Previously, this meant that microtasks would be executed between click handlers, however explicit <code>.click()</code> happens synchronously, so the script that caused <code>.click()</code> between click handlers will still be on the stack.  This rule ensures that microtasks do not interrupt the execution of JavaScript code.  This means that the microtask queue will not be deployed until all the handlers are executed;  the queue to microtasks comes only after all event handlers. <br><br><h3>  Is it important? </h3><br>  Still, it will eat you from the inside (phew).  I ran into this when I tried to create a <a href="">concise wrapper over IndexedDB</a> , using promises instead of terrible IDBRequest objects.  With her, the <a href="">IDB <i>almost</i> became pleasant to me</a> . <br><br>  When a success event is triggered in the IDB, <a href="http://w3c.github.io/IndexedDB/">the transaction object becomes inactive after transferring control</a> (step 4).  If I create a promise that is solved during the initiation of this event, the handlers should execute before step 4 while the transaction is still active, but this does not happen in any browser other than Chrome, because of which the library becomes useless as it were. <br><br>  In Firefox, you can cope with this, because polymes of promises, such as <a href="https://github.com/jakearchibald/es6-promise">es6-promise</a> , use Mutation observers for callbacks that are nothing more than microtasks.  Safari with this fix enters a race condition, but the matter is most likely in their <a href="http://www.raymondcamden.com/2014/09/25/IndexedDB-on-iOS-8-Broken-Bad">broken implementation of the IDB</a> .  Unfortunately, IE / Edge is currently not subject to correction, as mutation events do not occur after callbacks. <br><br>  It remains only to hope that in this matter we will sometime be able to observe interchangeability. <br><br><h3>  We did it! </h3><br>  Finally: <br><ul><li>  Tasks are executed in order and the browser can render in the intervals between them. </li><li>  Microtasks are executed in order and executed: <br><ul><li>  after each callback, unless it is part of executing some other script </li><li>  at the end of each task </li></ul><br></li></ul>  I hope after all that I‚Äôve read, it‚Äôs easier to think in terms of the event loop;  at least, there was an extra reason to relax. <br><br>  Has anyone stayed here?  Alia ?!  Hello? </div><p>Source: <a href="https://habr.com/ru/post/264993/">https://habr.com/ru/post/264993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264983/index.html">In search of an analogue of first-order functions in the Cach√© DBMS</a></li>
<li><a href="../264985/index.html">Sync CI Notifications with Telegram</a></li>
<li><a href="../264987/index.html">Median: precisely, sometimes precisely and almost exactly</a></li>
<li><a href="../264989/index.html">Cartesius - a method of storing and retrieving tree structures in relational databases or SQL trees without worms and cockroaches</a></li>
<li><a href="../264991/index.html">Total Mobilization with MobilizeToday</a></li>
<li><a href="../264997/index.html">Bayes and the challenge about Morpheus</a></li>
<li><a href="../265001/index.html">Build system for large modular projects</a></li>
<li><a href="../265007/index.html">How to easily understand logistic regression</a></li>
<li><a href="../265009/index.html">JQuery - separation of events on–°lick and onDbl–°lick</a></li>
<li><a href="../265011/index.html">Gartner agency named IBM the Magic Quadrant leader in the category of mobile application development platforms.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>