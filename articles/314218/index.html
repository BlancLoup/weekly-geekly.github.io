<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimal Spline Approximation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let us be given a set of points  and the corresponding set of positive weights  . We believe that some points may be more important than others (if no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimal Spline Approximation</h1><div class="post__text post__text-html js-mediator-article">  Let us be given a set of points <img src="https://habrastorage.org/files/f0d/403/8c0/f0d4038c02204f1cbb7cba71c5dba9fc.png">  and the corresponding set of positive weights <img src="https://habrastorage.org/files/3fc/d83/f89/3fcd83f893424620a0d1a78d9b8e1c4d.png">  .  We believe that some points may be more important than others (if not, then all the weights are the same).  Informally speaking, we want a beautiful curve to be drawn at the appropriate interval so that it ‚Äúbest of all‚Äù passes through this data. <br><img src="https://habrastorage.org/files/767/93c/7de/76793c7dedd64b16ae3e957bc852163c.png"><br>  Under the cat is an algorithm that reveals how the splines allow you to build such a beautiful regression, as well as its <a href="https://github.com/Quanteeks/Splines">implementation in Python</a> : <br><img src="https://habrastorage.org/files/e3c/e94/ff7/e3ce94ff72bd4305837c9d530b8cb4a4.png"><br><a name="habracut"></a><h4>  <font color="#089">Basic definitions</font> </h4><br>  The function s (x) on the interval [a, b] is called a <i><b>spline of degree k</b></i> on a grid with horizontal nodes <img src="https://habrastorage.org/files/eab/a4f/26a/eaba4f26aea143d6aed5aaf7944a7baf.png">  if the following properties are true: <br><br><ul><li>  At intervals <img src="https://habrastorage.org/files/bfa/7c5/7cc/bfa7c57cc8a24009b66d6241bd78e5ac.png">  The function s (x) is a kth power polynomial. </li><li>  The n-th derivative of the function s (x) is continuous at any point [a, b] for any n = 1, ..., k-1. </li></ul><br>  Note that to build a spline, you first need to create a grid of horizontal nodes.  Arrange them in such a way that within the interval (a, b) there are g nodes, and at the edges - k + 1: <img src="https://habrastorage.org/files/c59/cf0/cda/c59cf0cdaadc4f55965f1cc2cc0ec020.png">  and <img src="https://habrastorage.org/files/9e8/5eb/1ea/9e85eb1ea5264a2e90f9f3ba3a842145.png">  . <br><br>  Every spline at point <img src="https://habrastorage.org/files/1fc/a36/8c6/1fca368c69b04ca38cfd6920d12c7218.png">  can be presented in basic form: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/bf0/3a9/022/bf03a902279e4f5fa11a848b6066487b.png"></div><br>  Where <img src="https://habrastorage.org/files/199/957/081/199957081ea943ff90133bc9e3221c35.png">  - <i><b>B-spline k + 1st order</b></i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/872/584/874/872584874fd641e0b646b529d084dc0c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d5a/b7f/882/d5ab7f8826684361aaabd0c691814276.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e21/e92/8c3/e21e928c3cef4d8b8c2bfb9d74b7184e.png"></div><br>  Here's how, for example, looks like a basis on a grid of g = 9 nodes, evenly distributed on the interval [0, 1]: <br><img src="https://habrastorage.org/files/9cb/fc2/6b3/9cbfc26b33a4471cad716a718a464d39.png"><br>  Immediately understand the construction of splines through B-splines is very difficult.  More information can be found <a href="http://www.brnt.eu/phd/node11">here</a> . <br><br><h4>  <font color="#089">Approximation with given horizontal nodes</font> </h4><br>  So, we found out that the spline is determined uniquely by nodes and coefficients.  Assume that the nodes <img src="https://habrastorage.org/files/eab/a4f/26a/eaba4f26aea143d6aed5aaf7944a7baf.png">  we are known.  Also at the entrance is a set of data <img src="https://habrastorage.org/files/f0d/403/8c0/f0d4038c02204f1cbb7cba71c5dba9fc.png">  with appropriate weights <img src="https://habrastorage.org/files/3fc/d83/f89/3fcd83f893424620a0d1a78d9b8e1c4d.png">  .  It is necessary to find the coefficients <img src="https://habrastorage.org/files/61a/9d2/9df/61a9d29dffdd46d3a6a57bc978d9f1ce.png">  approximating the spline curve to the data.  Strictly speaking, they must deliver a minimum of function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a7e/2f5/ce2/a7e2f5ce2b5447988640e14f84690a5f.png"></div><br>  For convenience, we write in matrix form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/214/cd7/e5a/214cd7e5a62d44fc852e89e655e4f057.png"></div><br>  Where <br><div style="text-align:center;"><img src="https://habrastorage.org/files/238/8d2/8b3/2388d28b33424d4bb01f40c62329dca8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f5b/f44/23c/f5bf4423cd7a44c787b2e177f5955ca3.png"></div><br>  Note that the matrix E is block-diagonal.  The minimum is reached when the gradient of the error in the coefficients is zero: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/def/3f9/60f/def3f960f95c404890b97d5bb097ee3c.png"></div><br>  Set the operator <img src="https://habrastorage.org/files/c91/ee4/982/c91ee4982a2046beb5aea4b4252b8fb6.png">  denoting a weighted scalar product: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/72e/e09/bcb/72ee09bcb9434b8d995f457d8c960526.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/79b/39f/9e7/79b39f9e774f4b1e9c5388b66c3d31ba.png"></div><br>  Let also <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e47/5fc/12f/e475fc12fb73485ea25db1167dae04a3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c0e/44b/227/c0e44b2279344ecabbaaa3779a651f8f.png"></div><br><br>  Then the whole task and all previous formulas are reduced to solving a simple system of linear equations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6c9/aa4/5dd/6c9aa45ddc144cdc95131c613bf9b46d.png"></div><br>  where matrix A is (2k + 1) -diagonal, since <img src="https://habrastorage.org/files/b25/e32/f26/b25e32f26ff7419aba245d38d2f7d2a7.png">  if | i - j |  &gt; k.  Also, matrix A is symmetric and positive-definite, hence the solution can be quickly found using the Cholesky decomposition (there is also an algorithm for sparse matrices). <br>  And so, solving the system, we get the desired result: <br><img src="https://habrastorage.org/files/e3c/e94/ff7/e3ce94ff72bd4305837c9d530b8cb4a4.png"><br><h4>  <font color="#089">Smoothing</font> </h4><br>  However, everything is not always so good.  With a small amount of data in relation to the number of nodes and the degree of the spline, a so-called problem may arise.  overfitting.  Here is an example of a ‚Äúbad‚Äù cubic spline, while ideally passing through the data: <br><img src="https://habrastorage.org/files/940/b7a/eba/940b7aebae8d4602bdb1d3bc670f1870.png"><br>  OK, the curve is not so beautiful anymore.  We will try to reduce the so-called oscillations of the spline.  To do this, we will try to ‚Äúsmooth out‚Äù its kth derivative.  In other words, we minimize the difference between the derivative to the left and the derivative to the right of each node: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/eb4/dcc/a4b/eb4dcca4b0764a86b60d1610758eaf67.png"></div><br>  Expanding the spline in the basic form, we get: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2d5/89e/a39/2d589ea39a1048cf8bb9b908f3a1eab4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/edd/826/15a/edd82615ac1343978f6149c7e72848bd.png"></div><br>  Let's look at the error <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/943/f3a/8bc/943f3a8bc46346dc9d08e7f37202b0c5.png"></div><br>  Here q is the weight of the function that affects smoothing, and <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c63/b60/da6/c63b60da69224b00bec24aeb66d6b2c9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ea2/7c4/87b/ea27c487b2f943c1b647054e9e8acce6.png"></div><br>  New system of equations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b48/686/35a/b4868635a1af4aedb962633290bf6331.png"></div><br>  Where <br><div style="text-align:center;"><img src="https://habrastorage.org/files/299/b53/260/299b532601c04f3b837210d86e699717.png"></div><br>  The rank of matrix B is g.  It is symmetric and, since q&gt; 0, A + qB will be positive definite.  Therefore, the Cholesky decomposition is still applicable to the new system of equations.  However, the matrix B is degenerate and if q values ‚Äã‚Äãare too large, numerical errors may occur. <br>  For a very small value of q = 1e-9, the shape of the curve changes very little. <br><img src="https://habrastorage.org/files/75b/70f/6fc/75b70f6fc8094d9aa91d46d3677dea74.png"><br>  But at q = 1e-7 in this example, sufficient smoothing is already achieved. <br><img src="https://habrastorage.org/files/cbd/af8/918/cbdaf8918b274f03b854757993dbbe7a.png"><br><h4>  <font color="#089">Approximation with unknown horizontal nodes</font> </h4><br>  Imagine now that the task is the same as before, except that we do not know how the nodes are located on the grid.  Apart from the data, only the number of nodes g, the interval [a, b] and the degree of the spline k are fed to the input.  Let us naively assume that it is best to arrange the nodes evenly on the interval: <br><img src="https://habrastorage.org/files/476/81f/56f/47681f56f4ad48d08f1a168e996bd6d9.png"><br>  Oops.  Apparently, it is necessary to position the nodes somehow differently.  Formally, arrange the nodes so that the error value <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c0a/7c1/6c4/c0a7c16c44bc4f5b99d7530c81882de7.png"></div><br>  was minimal.  The last term plays the role of the penalty function so that the nodes do not closely approach each other: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c2f/6f0/fcb/c2f6f0fcbc154a9aba09f386540cb811.png"></div><br>  The positive parameter p is the weight of the penalty function.  The greater its value, the faster the nodes will move away from each other and tend to a uniform location. <br><br>  To solve this problem, we use the conjugate gradient method.  Its charm lies in the fact that for a quadratic function it converges in a fixed (in this case, g) number of steps. <br><br><ol><li>  Initialize the direction <img src="https://habrastorage.org/files/625/ccb/cbc/625ccbcbcae7400aab2ff5a57fdb8823.png">  . <br><br><div class="spoiler">  <b class="spoiler_title">How to calculate the derivative of the error on the nodes?</b> <div class="spoiler_text">  The derivative of the sum of squares by node: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c31/0a8/5a1/c310a85a12a148069091c91f66558802.png"></div><br>  In order to calculate the influence of the position of the node on the values ‚Äã‚Äãof the spline, it is necessary to consider the B-splines. <img src="https://habrastorage.org/files/ae9/1fd/f1c/ae91fdf1c0754871adac188519043b4b.png">  on new nodes <img src="https://habrastorage.org/files/46d/7aa/0a3/46d7aa0a3c75422fb2dac4b4644babb3.png">  and with new coefficients <img src="https://habrastorage.org/files/356/cd7/383/356cd73833794ef09164961bbaa01287.png"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/531/0f2/447/5310f244765b42d0af68a5740cb31a15.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7d6/4d9/2ab/7d64d92abd2f40809cfad525fee47362.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f71/641/4c1/f716414c18af4eb1ac42d929c33df8ac.png"></div><br><br>  Derivative of the penalty function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bcc/175/6ea/bcc1756ea6394b7b88de8b9cf152e046.png"></div><br><br>  You can‚Äôt look at the derivative smoothing function without tears: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/976/a92/3bd/976a923bd2544dce81631d08981af741.png"></div><br><br></div></div><br></li><li>  For j = 0, ..., g-1 <br><br><ul><li>  Set the function <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fb9/f08/d27/fb9f08d2777b4c258edfb8027db7a86b.png"></div><br>  returning an error depending on the choice of step along a given direction.  At this step, we find the optimal value of Œ± * that delivers the minimum of this function.  To do this, we solve the problem of one-dimensional optimization.  How it will be discussed later. <br><br></li><li>  Update node values: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e05/62e/893/e0562e893acf47ed9a5b409a58086b6f.png"></div></li><li>  Update the direction vector: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/de9/442/376/de94423761724153b771a34e58b023b8.png"></div></li></ul></li><li>  If a <br><div style="text-align:center;"><img src="https://habrastorage.org/files/b88/fb7/630/b88fb763023e4e9eaf911931614aad0f.png"></div><br>  and <br><div style="text-align:center;"><img src="https://habrastorage.org/files/ba2/81a/20b/ba281a20bb824aa89fdf40d0ba6c7daa.png"></div><br>  where Œµ <sub>1</sub> and Œµ <sub>2</sub> are predetermined values ‚Äã‚Äãthat are responsible for the accuracy of the algorithm, then we exit.  Otherwise, reset the counter and return to the first step. </li></ol><br><h4>  <font color="#089">Solving the problem of one-dimensional minimization</font> </h4><br>  To find the value <img src="https://habrastorage.org/files/950/af0/84b/950af084b8b1434fbb7013548c67eef0.png">  minimum function <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fb9/f08/d27/fb9f08d2777b4c258edfb8027db7a86b.png"></div><br>  we use an algorithm that allows us to reduce the number of calls to the oracle, namely the number of approximation operations with given nodes and the calculation of the error function.  We will use the notation <img src="https://habrastorage.org/files/14f/355/58f/14f35558faa54eb8a49465e73a1ad990.png">  . <br><br><ol><li>  Let the first and last components of the direction vector be zero: <img src="https://habrastorage.org/files/37e/f4d/765/37ef4d765da04e20a441dfa7c04f03f4.png">  .  We will also set the maximum possible step along this direction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d1c/4c6/c85/d1c4c6c852354885a91c36cda21aefc0.png"></div><br>  This choice is due to the fact that the nodes should not intersect. <br></li><li>  Initiate k = 0 and initial steps: <img src="https://habrastorage.org/files/a7e/0b9/654/a7e0b96540fa4dbea6aaa25578c2a1d9.png">  , <img src="https://habrastorage.org/files/cf5/6c8/33a/cf56c833a31c44aca9307f62006bace0.png">  , <img src="https://habrastorage.org/files/c80/770/b32/c80770b32fb445899dd7290a18c629ba.png">  . </li><li>  Until <img src="https://habrastorage.org/files/a84/7ea/551/a847ea5514924f57a989a3e0bf63fff6.png">  : <br><ul><li>  Ask <br><div style="text-align:center;"><img src="https://habrastorage.org/files/aaa/cf1/bf6/aaacf1bf69d44571ae45045355f99eeb.png"></div><br>  and reduce the step <br><div style="text-align:center;"><img src="https://habrastorage.org/files/903/325/864/903325864dba460b9ac5c8b8f705c63f.png"></div></li><li>  k = k + 1 </li></ul><br></li><li>  If k&gt; 0, then we return Œ± * = Œ± <sub>1</sub> .  Otherwise: <br><br><ul><li>  Until <img src="https://habrastorage.org/files/ed9/710/93a/ed971093ab75420fad0c2ca5431b9c47.png">  : Œ± <sub>0</sub> = Œ± <sub>1</sub> , Œ± <sub>1</sub> = Œ± <sub>2</sub> and <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0ec/1c1/22f/0ec1c122f5634e0db3a2dc70a8ef5f4c.png"></div><br></li><li>  Return <img src="https://habrastorage.org/files/787/199/305/78719930528c49bf9570b7bb2beea3e3.png">  where <img src="https://habrastorage.org/files/ec2/ac7/5fe/ec2ac75fe19b4d898a6a55ee6a3ac878.png">  - the root of the equation I '(Œ±) = 0 and I (Œ±) - approximation of the error function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/33e/bce/bac/33ebcebac78d48b69eeb628dd2a5a66c.png"></div><br>  Where <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1b6/49b/9b4/1b649b9b4ff04bca900247509c975c41.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e9e/210/da0/e9e210da039e4f3599883a2569c6b396.png"></div><br></li></ul></li></ol><br>  The coefficients a <sub>i</sub> and b <sub>i</sub> can be found from the equations <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1df/b31/ede/1dfb31ede82f4be48811dce41aadb8c2.png"></div><br>  and <br><div style="text-align:center;"><img src="https://habrastorage.org/files/6ff/c40/41b/6ffc4041bf6a4ae09a3073f0b2ce6d55.png"></div><br>  Explanation of the algorithm: <br><br>  The idea is to arrange three points Œ± <sub>0</sub> &lt;Œ± <sub>1</sub> &lt;Œ± <sub>2</sub> in such a way that a simple approximating function can be constructed from the error values ‚Äã‚Äãachieved at these points and return its minimum.  Moreover, the error value in Œ± <sub>1</sub> must be less than the error value in Œ± <sub>0</sub> and Œ± <sub>2</sub> . <br><br>  Find the initial approximation Œ± <sub>1</sub> from the condition S '(Œ± <sub>1</sub> ) = 0, where S (Œ±) is a function of the form <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/609/fc2/025/609fc20256e04407a04fa5f08d07b554.png"></div><br>  The constants c <sub>0</sub> and c <sub>1</sub> are found from the conditions <img src="https://habrastorage.org/files/f21/827/296/f21827296c954412a8f48306f71b623d.png">  and <img src="https://habrastorage.org/files/8cf/a02/95c/8cfa0295c09e40159a26a274bdc3e548.png">  . <br><br>  If we miscalculated with the initial approximation, then we decrease the step Œ± <sub>1</sub> as long as it delivers a larger error value than Œ± <sub>0</sub> .  Selection <img src="https://habrastorage.org/files/fb0/3e4/090/fb03e409006041698caf2b4973a3befb.png">  proceeds from the condition <img src="https://habrastorage.org/files/f1d/a00/0b0/f1da000b0aec4f8cb59975abedad7992.png">  where Q (Œ±) is the parabola interpolating error function <img src="https://habrastorage.org/files/5d6/a6d/98b/5d6a6d98b48d41e98ff5ea7bd8d90084.png">  : <img src="https://habrastorage.org/files/c35/cb3/1c9/c35cb31c9c9c4e2ba38f0bb7b1f5d3b7.png">  , <img src="https://habrastorage.org/files/e2d/a52/986/e2da52986f4e4dd6b4ffc18798d92b83.png">  and <img src="https://habrastorage.org/files/5ff/ed2/e5f/5ffed2e5fd8847719863502d52f173b0.png">  . <br>  If k&gt; 0, then we have found the value of Œ± <sub>1</sub> , such that when choosing it, the error value will be less than when choosing Œ± <sub>0</sub> and Œ± <sub>2</sub> , and we return it as a rough approximation of Œ± *. <br><br>  If our initial approximation was correct, then we are trying to find a step Œ± <sub>2</sub> such that <img src="https://habrastorage.org/files/820/1b2/93c/8201b293ce7242e281ca84ff030df83b.png">  .  It will be found between Œ± <sub>1</sub> and Œ± <sub>max</sub> , since Œ± <sub>max</sub> is the singularity point for the penalty function. <br><br>  When all three Œ± <sub>0</sub> , Œ± <sub>1</sub> and Œ± <sub>2</sub> values ‚Äã‚Äãare found, we represent the error function as the sum of two functions approximating the difference of squares and the penalty function.  The function Q (Œ±) is a parabola whose coefficients can be found, since we know its values ‚Äã‚Äãat three points.  The function R (Œ±) goes to infinity as Œ± tends to Œ± <sub>max</sub> .  The coefficients b <sub>i</sub> can also be found from a system of three equations.  As a result, we arrive at an equation that can be quadratic and easily solved: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f94/e98/91d/f94e9891d64542b498220427981fa3fa.png"></div><br>  And so, for comparison, the result of an optimally constructed spline: <br><img src="https://habrastorage.org/files/d80/2d4/ec3/d802d4ec3af342ffb4aebb2473e29b48.png"><br>  Well and for those to whom it can be useful: <a href="https://github.com/Quanteeks/Splines">implementation on Python</a> . </div><p>Source: <a href="https://habr.com/ru/post/314218/">https://habr.com/ru/post/314218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314206/index.html">November 2 - the most IT day of the year</a></li>
<li><a href="../314208/index.html">Announce Dart Sass</a></li>
<li><a href="../314210/index.html">Development Indie RPG: analysis of two years of development</a></li>
<li><a href="../314212/index.html">Monitoring Docker Hosts, Containers, and Container Services</a></li>
<li><a href="../314216/index.html">How we adjusted the process from storage to software licensing: SupplyLab project</a></li>
<li><a href="../314220/index.html">goader - console benchmark with a bias for writing and reading files</a></li>
<li><a href="../314222/index.html">Artificial intelligence in the search. How Yandex learned to use neural networks in order to search by meaning, not by words</a></li>
<li><a href="../314224/index.html">Video recordings of the best reports of the .NET conference DotNext 2016 Piter</a></li>
<li><a href="../314226/index.html">We continue to check Microsoft projects: PowerShell analysis</a></li>
<li><a href="../314228/index.html">Google learned how to filter fake installations on Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>