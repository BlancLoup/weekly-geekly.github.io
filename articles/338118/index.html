<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your first Linux device driver. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to the readers! 

 In the previous section, we looked at the basic structures, as well as the initialization and deletion of the device. 

 In t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your first Linux device driver. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Hello to the readers! <br><br>  In the previous <a href="https://habrahabr.ru/post/337946/">section,</a> we looked at the basic structures, as well as the initialization and deletion of the device. <br><br>  In this article, we will add the scull_open read / write function, scull_read / scull_write read / write function to our driver, and get the first working device driver. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/59/d0/da/59d0da145f4fd127632442.png"><br><br>  I want to thank all users who have read, liked and commented on my previous article.  Special thanks for clarifying <a href="https://habrahabr.ru/users/kolyuchkin/" class="user_link">Kolyuchkin</a> and <a href="https://habrahabr.ru/users/dlinyj/" class="user_link">dlinyj</a> . <br><br><img src="https://habrastorage.org/webt/59/d0/d3/59d0d3c9c75c1568934077.png"><br><br>  Last time there was a proposal not to examine in detail the insides of each function, so in this article I will try to present them in a broader sense. <br><br>  Go to the point! <br><a name="habracut"></a><br>  In the previous article, we did not consider one function that is part of scull_cleanup_module, namely scull_trim.  As you can see in the function, there is a loop that simply goes through the linked list and returns memory to the kernel.  We will not focus our attention here.  The main thing to come! <br><br><div class="spoiler">  <b class="spoiler_title">scull_trim</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scull_trim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct scull_dev *dev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_qset</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dptr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> qset = dev-&gt;qset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (dptr = dev-&gt;data; dptr; dptr = next) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dptr-&gt;data) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; qset; i++) kfree(dptr-&gt;data[i]); kfree(dptr-&gt;data); dptr-&gt;data = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } next = dptr-&gt;next; kfree(dptr); } dev-&gt;size = <span class="hljs-number"><span class="hljs-number">0</span></span>; dev-&gt;quantum = scull_quantum; dev-&gt;qset = scull_qset; dev-&gt;data = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br>  Before considering the function sull_open, I would like to make a small digression. <br><br>  Much of the Linux system can be represented as a file.  What operations are performed with files more often - opening, reading, writing and closing.  Also with device drivers, we can open, close, read and write to the device. <br><br>  Therefore, in the file_operations structure, we see such fields as: .read, .write, .open, and .release are the basic operations that the driver can perform. <br><br><h3>  Scull_open function </h3><br>  And immediately the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scull_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, struct file *flip)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_dev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> dev = container_of(inode-&gt;i_cdev, struct scull_dev, cdev); flip-&gt;private_data = dev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((flip-&gt;f_flags &amp; O_ACCMODE) == O_WRONLY) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (down_interruptible(&amp;dev-&gt;sem)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ERESTARTSYS; scull_trim(dev); up(&amp;dev-&gt;sem); } printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"scull: device is opened\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The function takes two arguments: <br><br><ol><li>  A pointer to an inode structure.  An inode structure is an inode that stores information about files, directories, and file system objects. <br></li><li>  A pointer to the file structure.  The structure that is created by the kernel each time the file is opened contains the information needed by the upper levels of the kernel. </li></ol><br>  The main function of scull_open is to initialize the device (if the device is opened for the first time) and fill in the necessary fields of the structures for its correct operation. <br>  Since our device does nothing, we have nothing to initialize :) <br><br>  But to create the appearance of work, we will perform several actions: <br><br><pre> <code class="cpp hljs">dev = container_of(inode-&gt;i_cdev, struct scull_dev, cdev); flip-&gt;private_data = dev;</code> </pre> <br>  In the above code, using container_of, we get a pointer to cdev of type struct scull_dev, using inode-&gt; i_cdev.  The resulting pointer is written in the private_data field. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((flip-&gt;f_flags &amp; O_ACCMODE) == O_WRONLY) { ...</code> </pre><br>  Further, it is still easier if the file is open for writing - we will clear it before use and display the message that the device is open. <br><br><h3>  Scull_read function </h3><br><div class="spoiler">  <b class="spoiler_title">Function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> scull_read(struct file *flip, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> *f_pos) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_dev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flip</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private_data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_qset</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dptr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quantum = dev-&gt;quantum, qset = dev-&gt;qset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemsize = quantum * qset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> item, s_pos, q_pos, rest; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> rv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (down_interruptible(&amp;dev-&gt;sem)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ERESTARTSYS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*f_pos &gt;= dev-&gt;size) { printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"scull: *f_pos more than size %lu\n"</span></span>, dev-&gt;size); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*f_pos + count &gt; dev-&gt;size) { printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"scull: correct count\n"</span></span>); count = dev-&gt;size - *f_pos; } item = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)*f_pos / itemsize; rest = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)*f_pos % itemsize; s_pos = rest / quantum; q_pos = rest % quantum; dptr = scull_follow(dev, item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dptr == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || !dptr-&gt;data || !dptr-&gt;data[s_pos]) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; quantum - q_pos) count = quantum - q_pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (copy_to_user(buf, dptr-&gt;data[s_pos] + q_pos, count)) { rv = -EFAULT; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } *f_pos += count; rv = count; out: up(&amp;dev-&gt;sem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br></div></div><br>  Now I will try to describe the meaning of using the read function. <br>  Since our device is symbolic, we can work with it as a stream of bytes.  And what can you do with the stream of bytes?  Correct - read.  So, as is clear from the name of the function, it will read from the baytik device. <br><br>  When the read function is called, several arguments are passed to it, the first of which we have already considered, now we will look at the rest. <br><br>  <i>buf</i> is a pointer to a string, and <i>__user</i> tells us that this pointer is in user space.  <i>The argument is passed by the user.</i> <br>  <i>count</i> - the number of bytes to read.  <i>The argument is passed by the user.</i> <br>  <i>f_pos</i> - offset.  <i>The argument passes the core.</i> <br><br>  That is, when the user wants to read from the device, he calls the read function (not scull_read) while indicating the buffer where the information will be written and the number of bytes read. <br>  Now let's take a closer look at the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*f_pos &gt;= dev-&gt;size) { printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"scull: *f_pos more than size %lu\n"</span></span>, dev-&gt;size); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*f_pos + count &gt; dev-&gt;size) { printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"scull: correct count\n"</span></span>); count = dev-&gt;size - *f_pos; }</code> </pre><br>  The first step is to check: <br><br><ol><li>  If the offset is greater than the file size, then, for obvious reasons, we can no longer read.  We will display an error and exit the function. </li><li>  If the sum of the current offset and the size of the data to be read is larger than the size of the quantum, then we adjust the size of the data to be read and report the message to the top. </li></ol><br>  Here is the subject of conversation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (copy_to_user(buf, dptr-&gt;data[s_pos] + q_pos, count)) { rv = -EFAULT; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; }</code> </pre><br>  <i>copy_to_user</i> - copies data to buf (which is in user space) from the memory allocated by the kernel <i>dptr-&gt; data [s_pos]</i> size <i>count</i> . <br><br>  If all these variables are not clear to you now: <i>s_pos, q_pos, item, rest</i> - it doesn't matter, here the main thing is to understand the meaning of the read function, and in 3 parts of the article we will test our driver, and there it will be clear what each of them is responsible for.  But if you want to know about it now, you can always use printk (if you know what I mean :)). <br><br><h3>  Scull_write function </h3><br>  In view of the fact that the scull_write function is very similar to scull_read, and its difference from the above one is clear from the name, I will not describe this function, but I suggest you consider it on your own. <br><br><div class="spoiler">  <b class="spoiler_title">Function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> scull_write(struct file *flip, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> *f_pos) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_dev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flip</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private_data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_qset</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dptr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quantum = dev-&gt;quantum, qset = dev-&gt;qset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemsize = quantum * qset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> item, s_pos, q_pos, rest; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> rv = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (down_interruptible(&amp;dev-&gt;sem)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ERESTARTSYS; item = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)*f_pos / itemsize; rest = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)*f_pos % itemsize; s_pos = rest / quantum; q_pos = rest % quantum; dptr = scull_follow(dev, item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dptr == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dptr-&gt;data) { dptr-&gt;data = kmalloc(qset * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dptr-&gt;data) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(dptr-&gt;data, <span class="hljs-number"><span class="hljs-number">0</span></span>, qset * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dptr-&gt;data[s_pos]) { dptr-&gt;data[s_pos] = kmalloc(quantum, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dptr-&gt;data[s_pos]) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; quantum - q_pos) count = quantum - q_pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (copy_from_user(dptr-&gt;data[s_pos] + q_pos, buf, count)) { rv = -EFAULT; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } *f_pos += count; rv = count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;size &lt; *f_pos) dev-&gt;size = *f_pos; out: up(&amp;dev-&gt;sem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br></div></div><br>  Everything, we wrote a full-fledged <s>useless</s> driver, the full code will be given below, and in the next article we will test it. <br><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/slab.h&gt; #include &lt;asm/uaccess.h&gt; int scull_major = 0; int scull_minor = 0; int scull_nr_devs = 1; int scull_quantum = 4000; int scull_qset = 1000; struct scull_qset { void **data; struct scull_qset *next; }; struct scull_dev { struct scull_qset *data; int quantum; int qset; unsigned long size; unsigned int access_key; struct semaphore sem; struct cdev cdev; }; struct scull_dev *scull_device; int scull_trim(struct scull_dev *dev) { struct scull_qset *next, *dptr; int qset = dev-&gt;qset; int i; for (dptr = dev-&gt;data; dptr; dptr = next) { if (dptr-&gt;data) { for (i = 0; i &lt; qset; i++) kfree(dptr-&gt;data[i]); kfree(dptr-&gt;data); dptr-&gt;data = NULL; } next = dptr-&gt;next; kfree(dptr); } dev-&gt;size = 0; dev-&gt;quantum = scull_quantum; dev-&gt;qset = scull_qset; dev-&gt;data = NULL; return 0; } int scull_open(struct inode *inode, struct file *flip) { struct scull_dev *dev; dev = container_of(inode-&gt;i_cdev, struct scull_dev, cdev); flip-&gt;private_data = dev; if ((flip-&gt;f_flags &amp; O_ACCMODE) == O_WRONLY) { if (down_interruptible(&amp;dev-&gt;sem)) return -ERESTARTSYS; scull_trim(dev); up(&amp;dev-&gt;sem); } printk(KERN_INFO "scull: device is opend\n"); return 0; } int scull_release(struct inode *inode, struct file *flip) { return 0; } struct scull_qset *scull_follow(struct scull_dev *dev, int n) { struct scull_qset *qs = dev-&gt;data; if (!qs) { qs = dev-&gt;data = kmalloc(sizeof(struct scull_qset), GFP_KERNEL); if (qs == NULL) return NULL; memset(qs, 0, sizeof(struct scull_qset)); } while (n--) { if (!qs-&gt;next) { qs-&gt;next = kmalloc(sizeof(struct scull_qset), GFP_KERNEL); if (qs-&gt;next == NULL) return NULL; memset(qs-&gt;next, 0, sizeof(struct scull_qset)); } qs = qs-&gt;next; continue; } return qs; } ssize_t scull_read(struct file *flip, char __user *buf, size_t count, loff_t *f_pos) { struct scull_dev *dev = flip-&gt;private_data; struct scull_qset *dptr; int quantum = dev-&gt;quantum, qset = dev-&gt;qset; int itemsize = quantum * qset; int item, s_pos, q_pos, rest; ssize_t rv = 0; if (down_interruptible(&amp;dev-&gt;sem)) return -ERESTARTSYS; if (*f_pos &gt;= dev-&gt;size) { printk(KERN_INFO "scull: *f_pos more than size %lu\n", dev-&gt;size); goto out; } if (*f_pos + count &gt; dev-&gt;size) { printk(KERN_INFO "scull: correct count\n"); count = dev-&gt;size - *f_pos; } item = (long)*f_pos / itemsize; rest = (long)*f_pos % itemsize; s_pos = rest / quantum; q_pos = rest % quantum; dptr = scull_follow(dev, item); if (dptr == NULL || !dptr-&gt;data || !dptr-&gt;data[s_pos]) goto out; if (count &gt; quantum - q_pos) count = quantum - q_pos; if (copy_to_user(buf, dptr-&gt;data[s_pos] + q_pos, count)) { rv = -EFAULT; goto out; } *f_pos += count; rv = count; out: up(&amp;dev-&gt;sem); return rv; } ssize_t scull_write(struct file *flip, const char __user *buf, size_t count, loff_t *f_pos) { struct scull_dev *dev = flip-&gt;private_data; struct scull_qset *dptr; int quantum = dev-&gt;quantum, qset = dev-&gt;qset; int itemsize = quantum * qset; int item, s_pos, q_pos, rest; ssize_t rv = -ENOMEM; if (down_interruptible(&amp;dev-&gt;sem)) return -ERESTARTSYS; item = (long)*f_pos / itemsize; rest = (long)*f_pos % itemsize; s_pos = rest / quantum; q_pos = rest % quantum; dptr = scull_follow(dev, item); if (dptr == NULL) goto out; if (!dptr-&gt;data) { dptr-&gt;data = kmalloc(qset * sizeof(char *), GFP_KERNEL); if (!dptr-&gt;data) goto out; memset(dptr-&gt;data, 0, qset * sizeof(char *)); } if (!dptr-&gt;data[s_pos]) { dptr-&gt;data[s_pos] = kmalloc(quantum, GFP_KERNEL); if (!dptr-&gt;data[s_pos]) goto out; } if (count &gt; quantum - q_pos) count = quantum - q_pos; if (copy_from_user(dptr-&gt;data[s_pos] + q_pos, buf, count)) { rv = -EFAULT; goto out; } *f_pos += count; rv = count; if (dev-&gt;size &lt; *f_pos) dev-&gt;size = *f_pos; out: up(&amp;dev-&gt;sem); return rv; } struct file_operations scull_fops = { .owner = THIS_MODULE, .read = scull_read, .write = scull_write, .open = scull_open, .release = scull_release, }; static void scull_setup_cdev(struct scull_dev *dev, int index) { int err, devno = MKDEV(scull_major, scull_minor + index); cdev_init(&amp;dev-&gt;cdev, &amp;scull_fops); dev-&gt;cdev.owner = THIS_MODULE; dev-&gt;cdev.ops = &amp;scull_fops; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE "Error %d adding scull %d", err, index); } void scull_cleanup_module(void) { int i; dev_t devno = MKDEV(scull_major, scull_minor); if (scull_device) { for (i = 0; i &lt; scull_nr_devs; i++) { scull_trim(scull_device + i); cdev_del(&amp;scull_device[i].cdev); } kfree(scull_device); } unregister_chrdev_region(devno, scull_nr_devs); } static int scull_init_module(void) { int rv, i; dev_t dev; rv = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs, "scull"); if (rv) { printk(KERN_WARNING "scull: can't get major %d\n", scull_major); return rv; } scull_major = MAJOR(dev); scull_device = kmalloc(scull_nr_devs * sizeof(struct scull_dev), GFP_KERNEL); if (!scull_device) { rv = -ENOMEM; goto fail; } memset(scull_device, 0, scull_nr_devs * sizeof(struct scull_dev)); for (i = 0; i &lt; scull_nr_devs; i++) { scull_device[i].quantum = scull_quantum; scull_device[i].qset = scull_qset; sema_init(&amp;scull_device[i].sem, 1); scull_setup_cdev(&amp;scull_device[i], i); } dev = MKDEV(scull_major, scull_minor + scull_nr_devs); printk(KERN_INFO "scull: major = %d minor = %d\n", scull_major, scull_minor); return 0; fail: scull_cleanup_module(); return rv; } MODULE_AUTHOR("AUTHOR"); MODULE_LICENSE("GPL"); module_init(scull_init_module); module_exit(scull_cleanup_module);</span></span></span></span></code> </pre><br></div></div><br>  After I read the article, I realized that I got too much code and unnecessary functions, so the simplest version of the implementation of this driver is given below. <br><br><div class="spoiler">  <b class="spoiler_title">Simplified code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/semaphore.h&gt; #include &lt;linux/uaccess.h&gt; int scull_minor = 0; int scull_major = 0; struct char_device { char data[100]; } device; struct cdev *p_cdev; ssize_t scull_read(struct file *flip, char __user *buf, size_t count, loff_t *f_pos) { int rv; printk(KERN_INFO "scull: read from device\n"); rv = copy_to_user(buf, device.data, count); return rv; } ssize_t scull_write(struct file *flip, char __user *buf, size_t count, loff_t *f_pos) { int rv; printk(KERN_INFO "scull: write to device\n"); rv = copy_from_user(device.data, buf, count); return rv; } int scull_open(struct inode *inode, struct file *flip) { printk(KERN_INFO "scull: device is opend\n"); return 0; } int scull_release(struct inode *inode, struct file *flip) { printk(KERN_INFO "scull: device is closed\n"); return 0; } struct file_operations scull_fops = { .owner = THIS_MODULE, .read = scull_read, .write = scull_write, .open = scull_open, .release = scull_release, }; void scull_cleanup_module(void) { dev_t devno = MKDEV(scull_major, scull_minor); cdev_del(p_cdev); unregister_chrdev_region(devno, 1); } static int scull_init_module(void) { int rv; dev_t dev; rv = alloc_chrdev_region(&amp;dev, scull_minor, 1, "scull"); if (rv) { printk(KERN_WARNING "scull: can't get major %d\n", scull_major); return rv; } scull_major = MAJOR(dev); p_cdev = cdev_alloc(); cdev_init(p_cdev, &amp;scull_fops); p_cdev-&gt;owner = THIS_MODULE; p_cdev-&gt;ops = &amp;scull_fops; rv = cdev_add(p_cdev, dev, 1); if (rv) printk(KERN_NOTICE "Error %d adding scull", rv); printk(KERN_INFO "scull: register device major = %d minor = %d\n", scull_major, scull_minor); return 0; } MODULE_AUTHOR("Name Surname"); MODULE_LICENSE("GPL"); module_init(scull_init_module); module_exit(scull_cleanup_module);</span></span></span></span></code> </pre><br></div></div><br><h3>  Poll </h3><br>  So there were circumstances that at the moment I have the task of porting device drivers from one kernel version to another.  Would you be interested in reading how this process takes place with specific examples? <br><br>  If you already have this experience, you can share it and write to me about the problems / errors you encountered when migrating device drivers.  And I, in turn, will try to add your experience to the article (I will definitely show you in it). <br>  Thank!  :) </div><p>Source: <a href="https://habr.com/ru/post/338118/">https://habr.com/ru/post/338118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338106/index.html">Nuklear + - mini cross-platform GUI</a></li>
<li><a href="../338108/index.html">5 rules for working with amounts</a></li>
<li><a href="../338110/index.html">Do WAFs dream about statistical analyzers?</a></li>
<li><a href="../338114/index.html">The digest of interesting materials for the mobile developer # 221 (September 11-17)</a></li>
<li><a href="../338116/index.html">Reverse engineering of the first smart watch Seiko UC-2000</a></li>
<li><a href="../338120/index.html">Metrics in the software development process: GQM model</a></li>
<li><a href="../338122/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ280 (September 11 - 17, 2017)</a></li>
<li><a href="../338124/index.html">‚ÄúUse the Power of Machine Learning, Luke!‚Äù Or automatic classification of luminaires according to the CIL</a></li>
<li><a href="../338126/index.html">Travis CI: automatic loading of collected modules on GitHub</a></li>
<li><a href="../338128/index.html">Where to go after ‚ÄúKickstarter‚Äù: difficulties of promotion of manufacturers of niche electronics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>