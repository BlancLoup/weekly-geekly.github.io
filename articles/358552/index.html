<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Best practices for designing productive mobile APIs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many informative articles about high performance on mobile devices on the web, and as many about general API design. But very little is disc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Best practices for designing productive mobile APIs</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/qy/ak/yb/qyakybqkiu54-x2yuagdfumyv5u.png"><br><br>  There are many informative articles about high performance on mobile devices on the web, and as many about general API design.  But very little is discussed about the architectural solutions needed to optimize the performance of backend APIs designed for use by mobile clients. <br><a name="habracut"></a><br>  Of course, it is necessary to optimize the performance of mobile applications themselves.  But we, infrastructure engineers, can do a lot to ensure that mobile customers are reliably and quickly provided with data and software resources - thereby maintaining a positive experience in the use of mobile applications. <br><br>  Here is what you need to consider when designing mobile software: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Limited screen size</b> .  Little space for data, small images. </li><li>  <b>Less concurrent connections</b> .  This is important because, unlike desktop browsers that can perform many simultaneous asynchronous requests, mobile browsers have a limited number of connections to a single domain. </li><li>  <b>Network slower</b> .  Network performance is greatly affected by the overall signal reception level, servicing numerous subscribers (and although some of them are sitting on Wi-Fi, some networks become overloaded and perform additional search operations if the user connects to another base station). </li><li>  <b>Lower computing power</b> .  Intensive client computing, 3D rendering, and the active use of JavaScript can dramatically decrease performance. </li><li>  <b>Less caches</b> .  Mobile clients are generally limited in memory, so for the sake of increased performance, it‚Äôs better not to rely too much on cached content. </li><li>  <b>"Special" browsers</b> .  The ecosystem of mobile browsers is a lot like a fragmented desktop browser environment several years ago, when developers released all new versions with fatal flaws and incompatibilities. </li></ul><br>  There are many ways to solve the described difficulties, but this article is mostly about what can be done with an API or backend to improve the performance (or its perception) of mobile clients.  We will look at two main questions: <br><br><ol><li>  <b>Minimize network connections and data transfer requirements</b> .  Efficient multimedia processing, efficient caching and the use of more time-consuming data-oriented operations and with fewer connections. </li><li>  <b>Sending the network "correct" data</b> .  Designing such APIs that only return the required / requested data, as well as optimization for different types of mobile devices. </li></ol><br>  Although the article focuses on the mobile segment, many lessons and ideas can be applied to API clients in other areas. <br><br><h2>  Minimizing connectivity and data transfer over the network </h2><br>  One of the most important tasks that needs to be addressed to improve performance on mobile devices is to minimize the number of HTTP requests necessary to render a web page.  This can be solved in different ways, and the choice of approach may depend on your data. <br><br><h2>  Images </h2><br>  If you make one request for each image on the page, then you can improve the speed and take advantage of the caching of individual images.  The desktop browser is able to process requests quickly and in parallel, so that their number does not greatly reduce performance (and due to caching, the ‚Äústrength‚Äù margin becomes even higher).  However, on mobile devices, a large number of requests can be deadly. <br><br>  Minimizing requests for images can reduce the total number of requests, and in some cases - the amount of transmitted data (which also has a positive effect on performance).  What strategies can you follow? <br><br><h2>  Sprites </h2><br>  Using image sprites helps to reduce the number of individual images that need to be downloaded from the server.  But this solution has a flaw: sprites can cause trouble in support, and in some situations they are not easy to generate (for example, when searching through a catalog of products, you need to show a large number of thumbnails). <br><br><h2>  Applying CSS instead of images </h2><br>  If, wherever possible, to avoid images and use CSS rendering for <a href="https://www.w3schools.com/cssref/css3_pr_box-shadow.asp">shadows</a> , <a href="https://css-tricks.com/css3-gradients/">gradients</a> and other effects, you can reduce the number of bytes that need to be transferred and downloaded. <br><br><h2>  Responsive image support </h2><br>  <a href="https://github.com/filamentgroup/Responsive-Images">Adaptive images</a> are a common way to deliver the right picture to the appropriate device.  <a href="http://blog.cloudfour.com/how-apple-com-will-serve-retina-images-to-new-ipads/">Apple does this</a> by loading regular images, and then using JavaScript, replacing them with higher resolution images.  There are a <a href="https://css-tricks.com/which-responsive-images-solution-should-you-use/">number of other approaches</a> , but we are <a href="https://www.w3.org/community/respimg/">still far from solving this problem</a> . <br><br>  To use responsive images, make sure they are supported on the server and that the APIs support different versions of the same image.  And the specific implementation will depend on client decisions. <br><br><h2>  Reduce additional requests by using data URIs to inline images </h2><br>  An alternative to sprites is to use URI data to inline images in HTML.  As a result, the pictures become part of the whole page.  And although their size in bytes may increase, such images are better compressed using Gzip, which compensates for the increase in the amount of information transmitted. <br><br>  <b>Tip</b> : if you are using a URI, then: <br><br><ul><li>  Reduce the pictures to the desired size before embedding in the URI. </li><li>  Make sure Gzip compresses the answers to the queries (to take advantage of the compression). </li><li>  Please note that the images embedded in the URI are part of the CSS page, and thus it will be more difficult to cache individual images.  Therefore avoid inlining if there are good reasons for local caching of images (for example, if they are often used on different pages). </li></ul><br><h2>  Using local storage and caching </h2><br>  Since mobile networks can run slowly, HTML, CSS, and images can be stored in local storage (localStorage).  <a href="http://www.stevesouders.com/blog/2011/03/28/storager-case-study-bing-google/">Here is an excellent study</a> on <a href="http://www.stevesouders.com/blog/2011/03/28/storager-case-study-bing-google/">how</a> to improve Bing performance using local storage, using which it was possible to reduce the size of an HTML document from ‚âà200 KB to ‚âà30 KB. <br><br>  A great way to improve the subjective assessment of performance by users is to pre-select the data that will be used on mobile devices in order to send them to customers without additional requests.  These include paged search results, popular searches, and user data.  If you think about this approach and take it into account in the architecture, then you can create APIs that can prepare and cache data before the user requests them, which will improve the subjective perception of performance. <br><br>  <b>Tip</b> : Data that is unlikely to change when an application is updated (for example, categories or main navigation) should be delivered inside the application in order not to waste time and resources transferring over the network. <br><br>  Ideally, the data should be transferred as needed, and loaded in advance when it is justified.  If the user does not see the image or content, then do not send it (this is especially important for responsive websites, since some simply ‚Äúhide‚Äù some elements).  An excellent application for preliminary preparation of images is the gallery of search results.  It is better to immediately load the next and previous images to speed up the interface.  But do not get carried away, do not upload too many pictures, because the user may not even see them. <br><br>  Retrieving data from local storage <a href="http://calendar.perfplanet.com/2011/localstorage-read-performance/">may degrade performance</a> , but this effect is much weaker compared to transferring data over the network.  In addition, some applications other than local storage use to improve performance and speed of launch and <a href="https://googlecode.blogspot.com/2010/04/google-apis-html5-new-era-of-mobile.html">other features of HTML5</a> , for example, <a href="https://www.html5rocks.com/en/tutorials/appcache/beginner/">appCache</a> . <br><br>  <b>Tip</b> : if you embed CSS and JavaScript directly into a separate request, then save the links to these files and transfer them to the server via cookies, the client will not have to download these resources again (only new files will be transferred over the network).  This will save a lot of time and is a great tool for using local caching.  Learn more about how to directly embed and link to the mentioned files, it is written here: <a href="http://calendar.perfplanet.com/2011/mobile-ui-performance-considerations/">http://calendar.perfplanet.com/2011/mobile-ui-performance-considerations/</a> . <br><br><h2>  Non-blocking I / O </h2><br>  When it comes to client optimization, it is recommended to monitor the <a href="https://www.nczonline.net/blog/2010/08/10/what-is-a-non-blocking-script/">blocking JavaScript execution</a> , which can severely degrade performance.  But for the API, this is even more important.  If you have a lengthy API call, for example, with a call to a third-party resource that can complete with a timeout, then it is important to implement the call as non-blocking (or even make it long to wait) and choose either polling or a triggering model. <br><br><ul><li>  <b>Polling (pull model)</b> : in the polling-API, the client makes a request and then periodically checks for the result, reducing the frequency of checks if necessary. </li><li>  <b>Triggering (push model)</b> : in a trigger-API, the call generates a request and then listens while waiting for a server response.  He provides a callback that triggers an event by which the caller will know when the query result appears. </li></ul><br>  Triggering APIs are usually harder to implement, because mobile clients are not reliable.  So most often it is better to use the polling model. <br><br>  For example, in the <a href="https://www.decide.com/">Decide mobile app,</a> product pages displayed local prices for countries in which these products were available.  Since the results were provided by a third-party service, we were able to make queries using the polling API, and then get results without stopping the application and not supporting an open connection waiting for results. <br><br>  Make sure your APIs respond quickly and do not block execution, waiting for results, because mobile clients have a limited number of connections. <br><br>  <b>Tip: Avoid the "chatty" API</b> .  In the case of a slow network, several API calls should be avoided.  A good rule of thumb: put all the data needed to render the returned page in one API call. <br><br>  If on the server side some components are much slower than others, it may be advisable to split the API into separate calls, focusing on the characteristic response time.  Thus, the client can start page rendering after the first quick calls, while waiting for answers to slower ones.  That is, we reduce the time required for the text to appear on the screen. <br><br><h2>  Avoiding Redirects and Minimizing DNS Requests </h2><br>  As for requests, redirects can degrade performance, especially if these are redirects between domains that require the DNS query to be performed. <br><br>  For example, many sites work with their mobile versions using client redirects.  That is, when a mobile client accesses the URL of the main site (for example, <a href="http://katemats.com/">katemats.com</a> ), it redirects to the mobile site <a href="http://m.katemats.com/">m.katemats.com</a> (this is very often found where the sites are built on different technology stacks).  Here is an example of such a scheme: <br><br><ol><li>  The user is googling for the request ‚Äúyahoo‚Äù and clicks on the first link in the issue. </li><li>  Google captures a click with its URL tracking, and then redirects to <a href="http://www.yahoo.com/">www.yahoo.com</a> <b>[redirect]</b> </li><li>  The answer to the Google redirect goes through the base station of the mobile operator, and then gets on the client phone. </li><li>  Running a DNS query for <a href="http://www.yahoo.com/">www.yahoo.com</a> . </li><li>  Found IP is transmitted via BS to the phone. </li><li>  When the phone accesses <a href="http://www.yahoo.com/">www.yahoo.com</a> , it will be recognized as a mobile client and redirected to <a href="http://m.yahoo.com/">m.yahoo.com</a> <b>[redirect]</b> </li><li>  Then the phone again needs to perform a DNS query, this time for the <a href="http://m.yahoo.com/">m.yahoo.com</a> subdomain. </li><li>  Found IP is transmitted via BS to the phone. </li><li>  Finally, the final HTML and the necessary resources are transmitted through the BS to the phone. </li><li>  Some pictures on the pages of the mobile site are provided via CDN through links to another domain, say, <a href="http://l2.yimg.com/">l2.yimg.com</a> . </li><li>  The phone again performs the DNS query ‚Äî for the <a href="http://l2.yimg.com/">l2.yimg.com</a> subdomain. </li><li>  Found IP is transmitted via BS to the phone. </li><li>  Pictures are drawn, the page is ready. </li></ol><br>  As you can see, there is a lot of overhead that can be avoided by using redirects on the server side (that is, by routing through the server and minimizing the number of DNS requests and redirects on the client), or by using <a href="https://googlewebmastercentral.blogspot.com/2012/04/responsive-design-harnessing-power-of.html">adaptive techniques</a> . <br><br>  <b>Tip</b> : if you cannot avoid a DNS query, then to save time, try using a <a href="https://dev.chromium.org/developers/design-documents/dns-prefetching">preliminary DNS query</a> for known domains. <br><br><h2>  HTTP and SPDY pipelining </h2><br>  Another useful technique is <a href="https://ru.wikipedia.org/wiki/HTTP_pipelining">HTTP pipelining</a> .  It allows you to combine multiple requests into one.  Although I would choose <a href="https://ru.wikipedia.org/wiki/SPDY">SPDY</a> , which optimizes HTTP requests so that they are much more efficient.  This protocol is supported in the Amazon Kindle browser, Twitter and Google. <br><br><h2>  Sending the "correct" data </h2><br>  Different clients need to send different files, CSS and JavaScript.  Even the number of results can vary.  Designing APIs that support different combinations and versions of results and files will give you maximum flexibility when creating a wonderful interaction experience. <br><br><h4>  For results use limit and offset. </h4><br>  As with conventional APIs, extracting results using <code>limit</code> and <code>offset</code> allows clients to request various data required for a specific use (there will be less results for mobile clients).  I prefer the <code>limit</code> and <code>offset</code> notation, because it is more common (than, say, <code>start</code> and <code>next</code> ), well understood by many databases, and therefore easy to use. <br><br> <code>/products?limit=25&amp;offset=75</code> <br> <br>  Choose the default value that corresponds to the largest or the smallest common denominator, with which you can identify the most important clients for your business (fewer - if your audience is based on mobile clients, more - if you come in mainly with desktop computers, this is usually true for B2B sites and services). <br><br><h2>  Support partial response and partial update </h2><br>  Design your APIs so that customers can request only the information they need.  This means that APIs must support a set of fields, rather than returning the full representation of the resource each time.  If the client does not have to collect and parse unnecessary data, the queries are simplified, and the performance is improved. <br><br>  Partial update allows clients to do the same with the data they write to the API (and then you don‚Äôt need to define all the elements within the resource classification). <br>  Google supports partial response with optional optional comma-separated list fields: <br><br> <code><a href="https://cacm.acm.org/cdn-cgi/l/email-protection">http://www.gogle.com/calendar/feeds/[emil prtected</a> ]/private/full? <b>fields=entry(title,gd:when)</b></code> <br> <br>  If <code>entry</code> is specified for a call, this means that the caller requests only a partial set of fields. <br><br><h4>  Avoid or minimize the use of cookies. </h4><br>  Every time a client sends a request to a domain, all cookies from this domain are included in it - even duplicated or extraneous values.  Therefore, another way to reduce the amount of transmitted data and improve performance is to maintain a small size of cookies (and not request them if they are not necessary).  Do not unnecessarily use or require cookies.  Provide static content that does not need permissions from a domain without cookies (for example, images from a static domain or from a CDN).  Here is a description of some methods of working with cookies: <a href="https://developers.google.com/speed/docs/best-practices/request">https://developers.google.com/speed/docs/best-practices/request</a> . <br><br><h4>  Creating device profiles for the API </h4><br>  Given the variety of screen sizes and resolutions on desktops, tablets and smartphones, it is helpful to create profiles that you will support.  For each profile, you can provide different images, data and files suitable for specific devices.  This is done using <a href="https://www.html5rocks.com/en/mobile/cross-device/">media queries to the client</a> . <br><br>  The more profiles, the better the interaction experience with respect to a particular device.  But then it will be harder to accompany all sorts of supported functions and scenarios (because the devices are constantly changing and evolving).  So it is better to maintain only the absolutely necessary number of profiles  As for the compromises and opportunities for creating a good experience of interaction, I recommend reading this article: <a href="https://mobiforge.com/design-development/effective-design-multiple-screen-sizes">https://mobiforge.com/design-development/effective-design-multiple-screen-sizes</a> . <br><br>  For most applications, three profiles are enough: <br><br><ol><li>  Mobile phones: less images, touch control is available, low network bandwidth. </li><li>  Tablets: more images, but adapted for a network with low bandwidth, touch control is available, more data is being transmitted in the request. </li><li>  Desktop computers: images for tablets and higher resolution images for Wi-Fi and desktop browsers. </li></ol><br>  The desired profile can be selected on the client.  The server-side APIs should be designed to take these profiles and send different information depending on which device sent the request.  For example, smaller images will be sent, or the size of the results will be reduced, or CSS and JavaScript will be inline. <br><br>  Suppose if one of your API returns search results, then the profiles may be: <br><br> <code>/products?limit=25&amp;offset=0</code> <br> <br>  The default profile (desktop) is used, a standard page is given, which requests each image separately, so subsequent views can be loaded from the cache. <br><br> <code>/products?profile= <b>mobile</b> &amp;limit=10&amp;offset=0</code> <br> <br>  10 results are returned, images with low resolution are transmitted as URIs in one HTTP request. <br><br> <code>/products?profile= <b>tablet</b> &amp;limit=25&amp;offset=0</code> <br> <br>  20 results are returned, pictures with low resolution, but larger in size are transmitted as URIs in one HTTP request. <br><br>  You can even create profiles for gadgets such as <a href="https://en.wikipedia.org/wiki/Feature_phone">feature phones</a> .  They, unlike smartphones, allow you to cache files only page by page.  So for such clients it is better to use profiles than to send CSS and JavaScript in each request. <br><br>  It is recommended that profiles be used instead of partial responses if the server responses vary greatly depending on the profile.  For example, if in one case the answer contains inline URI-images and a compact layout, and in the other case - no longer.  Of course, profiles can also be defined using ‚Äúpartial answers‚Äù, although they are usually used to define a part (or portion) of a standard scheme (for example, a subset of a larger classification), rather than the entire other data set, formats, etc. <br><br><h2>  Finally </h2><br>  There are many ways to make the web faster, including on mobile devices.  I hope this article will be a useful guide for API developers who design server parts for working with mobile clients. </div><p>Source: <a href="https://habr.com/ru/post/358552/">https://habr.com/ru/post/358552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358540/index.html">First Atlassian User Group in Minsk</a></li>
<li><a href="../358544/index.html">One day as a user support employee. What does it change?</a></li>
<li><a href="../358546/index.html">How to plan the capacity of the Apache Ignite cluster</a></li>
<li><a href="../358548/index.html">Create a fighting game in Unity: the implementation of Hitbox and Hurtbox</a></li>
<li><a href="../358550/index.html">Monitoring Elasticsearch without pain and suffering</a></li>
<li><a href="../358554/index.html">Confrontation: results</a></li>
<li><a href="../358558/index.html">The whole program Backend Conf: from microservices to endless data</a></li>
<li><a href="../358560/index.html">Digest news from the world of PostgreSQL. Issue number 6</a></li>
<li><a href="../358562/index.html">Open Testing Conference Free Broadcast - Heisenbug 2018 Piter</a></li>
<li><a href="../358564/index.html">Automatic generation of test scripts using neural networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>