<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lazy computing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of Haskell‚Äôs ‚Äúbusiness cards‚Äù is deferred, or lazy, calculations. This feature of the language not only opens up many possibilities, but also crea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lazy computing</h1><div class="post__text post__text-html js-mediator-article">  One of Haskell‚Äôs ‚Äúbusiness cards‚Äù is deferred, or lazy, calculations.  This feature of the language not only opens up many possibilities, but also creates some problems, especially with the speed of the programs. <br><br>  In this article I will try to explain what lazy calculations are, what they can be used for and how to avoid performance loss when using them. <br><a name="habracut"></a><br><h4>  What is lazy computing? </h4><br>  In ordinary, not lazy programming languages, computations are strict ‚Äî that is, the function arguments are evaluated before the function itself is executed. <br>  For example, in some abstract strict programming language: <br><br> <code>max(5+3, 4*4) -&gt; <br> max(8, 4*4) -&gt; <br> max(8, 16) <br> 16</code> <br> <br>  And in lazy languages, including Haskele, calculations are postponed.  All calculations (except for some I / O functions) are not performed immediately, but, as it were, are postponed until real need. <br>  The same example in Haskell: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>max (5+3) (4*4) -&gt; <br> let x = 5+3; y = 4*4 in if x &gt;= y then x else y -&gt; <br> let x = 8; y = 4*4 in if 8 &gt;= y then 8 else y -&gt; <br> let x = 8; y = 16 in if 8 &gt;= 16 then 8 else 16 -&gt; <br> 16</code> <br> <br>  In this example, it is clearly seen that the calculation of the subexpressions (5 + 3 and 4 * 4) was postponed until the last, namely until the moment when they had to be compared. <br>  Here, the ‚Äúforce‚Äù that caused the calculation to execute can be considered the console output, i.e  Io.  But this is not the only way. <br><br><h4>  Promises </h4><br>  Take this example: <br><br> <code>let z = (sum [1..10], reverse "haskell") in ...</code> <br>  (we assume below that z is used in the in part, otherwise the let expression will not be evaluated at all) <br><br>  z is a promise (thunk), just not a calculated value. <br>  And what will happen if we compare it with sample z? <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = (sum [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span> <span class="hljs-string"><span class="hljs-string">"haskell"</span></span>) (x, y) = z <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...</code> </pre> <br>  At first, z is a simple promise, as in the previous example, but in order for the compiler to check that z really matches the pattern, it has to ‚Äúunfold‚Äù z to the form: <code>(**, **)</code> .  x and y here are promises corresponding to the components of the pair z. <br>  Add another comparison with the sample: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = (sum [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span> <span class="hljs-string"><span class="hljs-string">"haskell"</span></span>) (x, y) = z 'l':ys = y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...</code> </pre> <br>  To check that y is a list, the compiler evaluates it to the form: <code>** : **</code> <br>  Then, it calculates the first promise: <code>'l' : **</code> <br>  And after making sure that y is a list starting with 'l', it performs pattern matching: <code>'l':ys = 'l':**</code> <br>  In this example, ys will be a promise corresponding to the rest of the y list. <br><br>  Let's look at how the depth of calculation for z has changed throughout all the examples: <br><br> <code>** <br> (**, **) <br> (**, 'l':**)</code> <br> <br>  z was partially computed, and as you can guess, almost all values ‚Äã‚Äãin Haskell can be computed in this way.  For example, the minimum possible calculation for a pair is simply to calculate the constructor: <code>(**, **)</code> .  For a list, this is <code>**:**</code> or [].  And for the numbers of this form does not exist - they are either computed or not. <br>  When a value is not fully computed, it is said to be in the <b>Weak Head Normal Form</b> (WHNF), and when fully, it is said to be in the <b>Normal Form</b> .  The value in WHNF, when fully computed, ‚Äútransitions‚Äù to the Normal Form.  For example, if we print z to the screen, then its Normal Form will be <code>(55,"lleksah")</code> .  Obviously, values ‚Äã‚Äãwhose constructor has no arguments cannot be in WHNF.  That is, such types as Bool, Ord, Int, etc. do not have WHNF, and the types Maybe, [a], Either, etc.  have <br><br><h4>  Lazy features </h4><br>  Functions are lazy and strict in their arguments.  Lazy - do not calculate their arguments, and rigorous - calculate, to any depth.  It is worth noting that a function can be lazy in one argument and strict in another.  Of course, most functions need to somehow use their arguments, which implies their calculation.  For example, the function length.  To find out the length of a list, it has to calculate its constructors, but not its values.  That is, <code>length **</code> "opens" into something like: <code>length (** : ** : ** : [])</code> . <br><br>  There is an easy way to check if a function is lazy in any argument.  You just need to pass it the argument undefined instead of it, and if the result is an error, then the function is strict in this argument, and if not, it is lazy. <br>  Will not lead to an error: <br><br> <code>const 5 undefined <br> Just undefined</code> <br> <br>  And these will lead: <br><br> <code>length undefined <br> head undefined</code> <br> <br><h4>  Lazy pattern comparison </h4><br>  Lazy can be not only functions, but also comparisons with the sample.  In contrast to the strict pattern comparisons that we have already considered, the lazy ones do not force promises to be calculated, that is, they do not ‚Äúunfold‚Äù them during compilation. <br>  For example: <br><br> <code>&gt; let f ~(x, y) = 1 <br> &gt; f undefined <br> 1</code> <br> <br>  Here <code>~(x, y)</code> is a lazy pattern.  It has the same property as the argument of the lazy function: when we pass undefined there, an error does not occur. <br>  Such a comparison with the sample can be found in Control.Arrow: <br><br> <code>(***) fg ~(x, y) = (fx, gy)</code> <br> <br> <code>&gt; (const 1 *** const 2) undefined <br> (1, 2)</code> <br> <br>  But we must remember that a lazy sample should be used only when the type has one constructor. <br>  For example: <br><br> <code>head' :: [a] -&gt; a <br> head' ~[] = undefined <br> head' ~(x:xs) = x</code> <br> <br>  Since we indicated that it is not necessary to calculate the function argument until it is needed, it is not possible to know what is before us: an empty list or one of its links.  The function will always return undefined, because in the first expression we used an irrefutable sample. <br><br><h4>  Using lazy computing </h4><br><h5>  Calculation on demand </h5><br>  The most obvious plus of lazy calculations is that if something is not required, it will not be calculated. <br>  For example: <br><br> <code>(&amp;&amp;) False _ = False <br> (&amp;&amp;) True a = a</code> <br> <br>  If the first argument of the function and is False, why calculate the second, if it is clear that the result is False?  It is possible to find out the value of the second argument, you will need to make a lot of time-consuming calculations, which, using lazy calculations, can be avoided. <br><br>  Imagine that you want to find the 3 smallest list items. <br>  In Haskell it can be done like this: <br><br> <code>take 3 (sort xs)</code> <br> <br>  But in a strict language it is wasteful, because you have to sort the entire list.  But with lazy calculations, we will sort the list down to the third item and stop, because it doesn't make sense to continue the calculation. <br><br><h5>  Memoization </h5><br>  Consider this function: <br><br> <code>plus a = a+a</code> <br> <br> <code>&gt; plus (5+3) <br> 16</code> <br> <br>  How many times was the sum of 5 and 3 calculated?  The correct answer is: once.  At first (5 + 3) was just a promise, but when it was passed to the plus function, it was calculated and its answer replaced the promise itself.  When the value of a was needed a second time, the program simply took the finished result from the former promise, without performing any calculations.  This is one of the most important properties of lazy computing - memoization.  A promise in a lazy language is calculated only once, and then the result of the calculation "overwrites" the promise, thereby allowing the program to simply find out the answer, without having to calculate it again. <br>  This property of lazy computing is used in dynamic programming, which was well shown in the article <a href="http://habrahabr.ru/blogs/Haskell/130945/">Dynamic programming and lazy computing</a> . <br><br><h5>  Infinite and cyclic data structures </h5><br>  Another fairly well known application of deferred computation is the creation of infinite data structures. <br><br> <code>&gt; [1, 3..] !! 10 <br> 21</code> <br> <br>  Here we create an infinite list of odd numbers, and take its 10th element. <br><br>  The example is more complicated: <br><br> <code>&gt; fibs = 1:1:zipWith (+) fibs (tail fibs) <br> &gt; fibs !! 100 <br> 573147844013817084101</code> <br> <br>  Creating endless lists is possible only because they are not calculated immediately.  In the second example, fibs will first be <code>1:1:**</code> , but when we request the following items from this list, the program will have to fulfill promises until our needs are met.  One promise can spawn others, so from a small list and a promise, fibs can turn into a huge chain of Fibonacci numbers. <br><br>  We now turn to cyclic data structures. <br><br> <code>data List a = List {value :: a, next :: List a}</code> <br> <br>  How do we tie two elements of this type into a ring, so that the next field of one object points to another? <br>  If we wanted to implement this in an imperative language, we would use pointers, but in Haskell there are no pointers.  So how to create such a structure? <br>  Very simple: <br><br> <code>let x = List "x" y <br> y = List "y" x <br> in x</code> <br> <br>  That's all.  Since the List field next is lazy (we must remember that the type constructor is the same function and its arguments can be lazy) creating such a ‚Äúring‚Äù will not cause the program to freeze in attempts to calculate the entire structure. <br><br> <code>&gt; value . next $ x <br> "y"</code> <br> <br><h5>  Lazy I / O </h5><br>  Only simple I / O functions are really strict, and the rest are lazy.  This makes it possible to read and write to files on the fly, as a pipeline, without the use of buffers. <br>  For example: <br><br> <code>import Data.Char <br> <br> main = print . map toUpper =&lt;&lt; getContents</code> <br> <br>  The program will display text in upper case as it becomes available. <br><br><h4>  Problems associated with the use of lazy computing </h4><br>  Throughout the article, I used the term ‚Äúpromise‚Äù to denote a unit of lazy evaluation, but the fact is that this is not just an abstract concept.  The compiled program on Haskell actually uses promises that take place in memory and on the stack.  That is, garbage collection, memory allocation, and unfolding of promises are added to the cost of ordinary calculations.  This is the main problem of lazy calculations - you can pay for their illiterate use by a strong decrease in performance, stack overflows and large memory consumption. <br><br>  But there are ways to make calculations less lazy, which we now consider. <br><br><h5>  Seq </h5><br>  Consider this simple example: <br><br><pre> <code class="hljs axapta">main = print . <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span><span class="hljs-string"><span class="hljs-string">' $ [1..1e6] sum'</span></span> [] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span><span class="hljs-string"><span class="hljs-string">' (l:ls) = l + sum'</span></span> ls</code> </pre> <br>  Here we find the sum of the numbers from 1 to 1e6 and output it to the console.  But if you try to start the program, you will see the following message: <br><br> <code>$ ./test <br> Stack space overflow: current size 8388608 bytes. <br> Use `+RTS -Ksize -RTS' to increase it.</code> <br> <br>  Why does a stack overflow occur?  Let's see how the sum 'function will be calculated: <br> <code>1 + (1 + (1 + ... (1 + sum' [])))</code> <br> <br>  Since the calculation of <code>sum' ls</code> postponed, we get a lot of nested promises that occupy space on the stack.  To get rid of this, we must somehow make promises to be calculated, and not accumulated.  And for this we have the seq function.  It takes two arguments, the first of which is calculated, and the second is returned.  Let's try applying it here. <br><br>  First, let's rewrite the sum function to use tail recursion: <br><br><pre> <code class="hljs mel">main = <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> . sum<span class="hljs-string"><span class="hljs-string">' $ [1..1e6] sum'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> = go <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> where go n [] = n go n (l:<span class="hljs-keyword"><span class="hljs-keyword">ls</span></span>) = go (l + n) <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span></code> </pre> <br>  Now to force addition to be calculated will not be difficult: <br><br><pre> <code class="hljs mel">main = <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> . sum<span class="hljs-string"><span class="hljs-string">' $ [1..1e6] sum'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> = go <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> where go n [] = n go n (l:<span class="hljs-keyword"><span class="hljs-keyword">ls</span></span>) = let s = l + n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s <span class="hljs-string"><span class="hljs-string">`seq`</span></span> go s <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span></code> </pre> <br>  Seq forces the sum to be calculated, instead of postponing the addition until later. <br><br> <code>$ ./test <br> 5.000005e11</code> <br> <br>  Now the error does not occur. <br><br>  Let's try a slightly complicated example: in addition to the sum of the elements, we calculate their number. <br><br><pre> <code class="hljs mel">main = <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> . sum<span class="hljs-string"><span class="hljs-string">' $ [1..1e6] sum'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> = go (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span> where go (n, d) [] = (n, d) go (n, d) (l:<span class="hljs-keyword"><span class="hljs-keyword">ls</span></span>) = let t = (l + n, d + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> t <span class="hljs-string"><span class="hljs-string">`seq`</span></span> go t <span class="hljs-keyword"><span class="hljs-keyword">ls</span></span></code> </pre> <br> <code>$ ./test <br> Stack space overflow: current size 8388608 bytes. <br> Use `+RTS -Ksize -RTS' to increase it.</code> <br> <br>  Again the same mistake.  But why?  After all, we made the amounts calculated? <br>  It‚Äôs time to talk about one seq property: it calculates the value before the WHNF.  Ordinary numbers, as mentioned earlier, do not have WHNF, so addition has been completely calculated by seq.  But in this case we are trying to calculate a pair that has the WHNF, namely <code>(**, **)</code> .  So the promises still accumulate, which leads to a stack overflow.  We can force the fields to be calculated using seq: <br><br><pre> <code class="hljs go">main = <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> . sum<span class="hljs-string"><span class="hljs-string">' $ [1..1e6] sum'</span></span> ls = <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ls where <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> (n, d) [] = (n, d) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> (n, d) (l:ls) = let s = l + n d<span class="hljs-string"><span class="hljs-string">' = d + 1 in s `seq` d'</span></span> <span class="hljs-string"><span class="hljs-string">`seq`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> (s, d<span class="hljs-string"><span class="hljs-string">') ls</span></span></code> </pre> <br> <code>$ ./test <br> (5.000005e11,1000000)</code> <br> <br>  A little ugly, but it works.  The situation when you need to calculate something completely is not so rare, so a special module was created for this.  Let's try it out: <br><br><pre> <code class="hljs perl">import Control.DeepSe<span class="hljs-string"><span class="hljs-string">q (deepseq)</span></span> main = <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> . sum<span class="hljs-string"><span class="hljs-string">' $ [1..10^6] sum'</span></span> :: [Integer] -&gt; (Integer, Int) sum<span class="hljs-string"><span class="hljs-string">' ls = go (0, 0) ls where go (n, d) [] = (n, d) go (n, d) (l:ls) = let t = (l + n, d + 1) in t `deepseq` go t ls</span></span></code> </pre> <br>  The deepseq function calculates values ‚Äã‚Äãcompletely, up to the Normal Form. <br><br><h5>  Bang patterns </h5><br>  For a more convenient indication of strictness, a compiler extension, Bang patterns, was created.  It allows you to specify the severity of the arguments just an exclamation point.  Using this extension, we can rewrite our code like this: <br><br><pre> <code class="hljs pgsql">{-# <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> BangPatterns #-} main = print . sum<span class="hljs-string"><span class="hljs-string">' $ [1..10^6] sum'</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] -&gt; (<span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) sum<span class="hljs-string"><span class="hljs-string">' ls = go (0, 0) ls where go (!n, !d) [] = (n, d) go (!n, !d) (l:ls) = go (l + n, d + 1) ls</span></span></code> </pre> <br>  Everything will work as before. <br>  Bang patterns allow us to specify the severity of not only the arguments of the functions, but also the fields of the data structures, for example: <br><br><pre> <code class="hljs haskell"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE BangPatterns #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> !a !b </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> main = print . sum' $ [1..10^6] sum' :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class">] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> sum' ls = go (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> 0 0) ls where go (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nd</span></span></span><span class="hljs-class">) [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> nd go (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nd</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ls</span></span></span><span class="hljs-class">) = go (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPair</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d</span></span></span><span class="hljs-class"> + 1)) ls</span></span></code> </pre> <br> <code>$ ./test <br> SPair 500000500000 1000000</code> <br> <br>  SPair is a strict pair.  The values ‚Äã‚Äãin its fields will always be computed, which, again, does not allow promises to accumulate. <br><br><h4>  Conclusion </h4><br>  In this article, I tried to explain how to cope with lazy calculations.  I hope after reading it you will begin to understand where and how best to use deferred calculations, why they are needed at all. <br><br><h4>  List of materials used </h4><br>  <a href="http://en.wikibooks.org/wiki/Haskell/Laziness">Haskell / Laziness</a> <br>  <a href="http://book.realworldhaskell.org/read/profiling-and-optimization.html">Profiling and optimization</a> </div><p>Source: <a href="https://habr.com/ru/post/131910/">https://habr.com/ru/post/131910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131905/index.html">Startup "Avatar"</a></li>
<li><a href="../131906/index.html">Which social network to post? Instruction</a></li>
<li><a href="../131907/index.html">Microsoft has released a patch for Windows that prevents the Duqu worm from entering the system</a></li>
<li><a href="../131908/index.html">External interrupts for 8-bit avr, using buttons</a></li>
<li><a href="../131909/index.html">All-In-One Note: All Inclusive</a></li>
<li><a href="../131915/index.html">Catastrophic backtracking in regular expressions</a></li>
<li><a href="../131916/index.html">Redis, hiredis, libev and multithread. Part 1</a></li>
<li><a href="../131917/index.html">Competition for the creation of HTML5 applications with a prize pool of $ 50,000</a></li>
<li><a href="../131918/index.html">Difficult questions - simple answers or not an ordinary question and answer service</a></li>
<li><a href="../131919/index.html">Macros in Scala, Eugene Burmaco. Screencast, slides and photo with scalaby # 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>