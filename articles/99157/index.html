<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory on demand</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memory on demand - automatic allocation of memory to the virtual machine as needed. 

 I already wrote about this idea a bit earlier: Memory managemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory on demand</h1><div class="post__text post__text-html js-mediator-article">  Memory on demand - automatic allocation of memory to the virtual machine as needed. <br><br>  I already wrote about this idea a bit earlier: <a href="http://habrahabr.ru/blogs/cloud_computing/97998/">Memory management of the guest machine in the cloud</a> .  Then it was a theory and some sketches with evidence that this idea would work. <br><br>  Now, when this technology has found practical implementation, and the client and server parts are ready and (seemingly) debugged, you can no longer talk about the idea, but about how it works.  Both from user, and from server part.  At the same time, let's talk about what turned out not as perfect as we would like. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The essence of the technology of <em>memory on demand</em> is to provide the guest with the amount of memory that he needs at any given time.  Changing the amount of memory occurs automatically (without the need to change something in the control panel), on the go (without rebooting) and in a very short time (about a second or less).  To be precise, the amount of memory allocated by the applications and the guest OS kernel, plus a small amount to the cache, is allocated. <br><a name="habracut"></a><br>  Technically, for the Xen Cloud Platform, this is organized very simply: we have an agent in our guest machine (self-written, because regular utilities are too voracious and inconvenient), written in C.  I chose to write on it - shell, python or C.  The simplicity of implementation (5 lines) spoke for the shell, for the python - the reliability and beauty of the code.  But C won (about 150 lines of code) for two reasons: information about the state of the machine needs to be sent often - and it would be dishonest to ‚Äúeat‚Äù someone else‚Äôs machine time and someone else‚Äôs memory on a convenient and beautiful code (instead of a not very elegant, but very fast code on C). <br><br>  Against python, among other things, it was also said that it is not in the minimum installation of Debian. <br><br>  The server part (in fact, deciding how much memory is needed and allocating it) is still on python - there are not so many mathematics there, but there are a lot of boring operations for C related to converting from strings to numbers, working with lists, dictionaries, etc.  In addition, this machine consumes service resources and does not affect the costs of customers. <br><br>  The server part receives data from the guest system and changes the memory size of the guests according to the memory management policy.  The policy is determined by the user (from the control panel or via the guest API). <br><br>  There are no perfect things.  Memory on demand also has its own problems - and I think that it is better to talk about them in advance than to shock the client post factum. <br><br><h1>  disadvantages </h1><br><h2>  Asynchronous memory allocation </h2><br><br>  Scripts that regulate memory do not follow requests to the OS, they only monitor indicators in the OS itself.  In other words, if someone asks the OS for a couple of gigabytes of memory at a time, they can refuse it.  But if he, at intervals, asks 10 times for 200, then they will give it completely.  As the tests showed, in a server environment this is exactly the case - memory consumption grows as forks of daemons and load increases, moreover, it grows with quite a finite speed (so that mod-server has enough time to throw in memory until the next large request). <br><br>  Another insurance against this - swap.  Those who are used to working on openVZ-based VDS will probably be surprised.  Those who are used to Xen or ordinary cars will not even pay attention to it.  Yes, virtual machines have a swap.  And it is even used!  After some time of the machine operation (in real conditions, and not in laboratory idleness) several hundred megabytes of data appear in the swap. <br><br>  Fortunately, Linux is very, very neat with a swap, and throws there only unused data (and you can regulate this behavior with vm.swapiness). <br><br>  So, the main task of the swap in the conditions of Memory on demand is in insurance against too fast / thick requests.  Such requests will be successfully processed without oom_killer, albeit at the cost of some brakes.  The user has the ability to influence this behavior with the help of policies. <br><br>  If a <s>person</s> program in the guest system asked for a lot of memory at a time and a part of a little-used code was thrown into a swap, then mod-server (MOD = Memory On Demand) works again, which throws in memory.  It is enough to clear the swap, but Linux is a lazy creature, and it is not in a hurry to unload unused data from the swap.  Due to this, a large amount of memory is given to the disk cache (performance increase).  If Linux needs something from a swap, then the memory is ready to accept this data. <br><br><h2>  Overhead </h2><br><br>  The second drawback is more fundamental.  Dynamic memory management requires ... memory.  Yes, and quite a lot.  For 256MB, this is about 12MB of the overhead projector, for 512 - about 20, for 2GB - about 38, for 6GB - about 60MB of the overhead projector.  The overhead is ‚Äúeaten up‚Äù by either the hypervisor, or the kernel of the guest system ... It does not even show up in 'free' in TotalMem. <br><br>  You might think that this overhead is not very big.  However, if you have a 5GB margin, and the actual consumption is 200, then you will have a 50Mb overhead (i.e. pay for + 25% of memory for the right to grow to 5GB).  If to lower a ceiling to 2 Gb, then the overhead projector will decrease to 10% of memory at 256 bases. <br><br>  Thus, the overhead projector is a fee for the willingness to get a lot of memory from the hypervisor.  From our side (mercantile, self-serving, etc.) it is a small insurance that a person will not just reserve 64 GB of memory for himself (he will have to have an overhead of about 6 GB, which is quite expensive for a machine with a consumption of 200 MB).  But to make yourself a machine with an interval of 300-2GB - the most it.  The overhead is small, there is a memory reserve. <br><br>  Another disadvantage is that you can change the upper memory limit only with a reboot. <br><br><h2>  Anlim </h2><br><br>  Anlim (any amount of memory on first request - emphasis on the words "any") is not and never will.  There are several reasons. <br><br>  First, we do not physically have for you 500 GB of memory right-here-and-now for a single virtual machine.  Even if you ask.  So much memory levels in the server can not hold.  Secondly, the technology itself requires (for the moment) the presence of a ceiling, and, preferably, not much higher than the average consumption (no more than one and a half orders of magnitude, with large numbers the overhead grows strongly, it was higher, the margin up to 500GB will consume That way you have 30 gigabytes of memory "to nowhere" - a little expensive pleasure is obtained). <br><br>  They promised anlim.  But did not.  More precisely, it can be formally done within the cloud's host capability, but such ranges (128-48GB) are not economically viable. <br><br>  Alas, the beautiful picture with the complete absence of the upper memory bar failed.  But it was possible to implement the technology of payment for consumption.  If you (your VM) consumes little memory, then little money is paid.  And the stock on a case of "crazy habr-effect" with the swelling Apaches is. <br><br><h2>  Disk cache </h2><br><br>  A special conversation with the cache.  We can not set the amount of virtual machine memory strictly on consumption, because the cache is still needed.  Despite the fact that there are two levels of caching and dozens of gigabytes of memory with a cache (for general use) before the physical screws.  Your local cache allows you to reduce the number of disk operations (and they, by the way, are paid separately). <br><br>  Thus, we can reserve a small amount of memory in the machine, which, on the one hand, serves requests for new memory inside the virtual machine (ie, reduces the number of operations for changing the memory quota of the machine), and on the other hand, it is used as a disk cache.  Since we monitor the amount of memory in the guest, the memory for the cache is almost always, except for moments of acute peak memory consumption (on the graph it can be seen). <br><br><h2>  Make me a server with 8MB of RAM </h2><br><br>  Will not work.  Modern kernels want a lot of memory, so that even the figure of 64 MB does not suit them.  As the test showed, it makes sense to talk about numbers from 96MB, or, with a small correction for the cache, from 128MB.  If you try to cut the memory below this value (we do not provide this opportunity for users, but I tried it in the laboratory), it turns out very badly - the kernel starts to panic, start doing stupid things.  Thus, the reasonable limit fixed in our interface is a conscious decision after tests, and not a ban on savings. <br><br><h2>  I looked back to see if you looked back, because the stack overflow </h2><br>  Another potential problem may be applications whose strategy is to use all available memory.  In this situation, a bad recursion is enabled: <br><ol><li>  The program sees that 32MB is free </li><li>  The program requests from the OS 30 MB </li><li>  MOD agent informs server that OS has 2MB of free memory left </li><li>  MOD-server throws guest OS 64MB more memory </li><li>  The program sees that another 66 MB of memory is free. </li><li>  The program asks the OS for another 64MB of memory. </li></ol><br>  This recursion will end at the moment when the MOD server is unable to increase the amount of memory (due to the upper limit). <br><br>  I know that this is how Exchange 2007 and above behaves, some versions of SQL servers.  What to do in this situation? <br><ul><li>  Disable the ability to allocate memory.  Memory as much as put in the socket.  Boring decision </li><li>  Disable automatic memory allocation, go to the API (need memory, asked).  The main problem is that this approach contradicts the idea of ‚Äã‚Äãmemory on demand - automatic memory allocation. </li><li>  Change program settings (all such programs allow you to change the behavior) </li><li>  Change the memory allocation policy setting (for example, make the memory allocation memory happen at the moment the swap begins to be used). </li></ul><br><br>  I do not know which approach will be better, practice will show. <br><br><h1>  How is this implemented? </h1><br>  Well, there is no special secret. <br><br>  <code>xe vm-memory-dyniamic-range-set max=XXX min=YYY uuid=...</code> - and that's in the bag.  The very possibility of changing the memory of a virtual machine on the go is present in zena long ago.  However, the existing implementation (xenballoond) was too optimistic (i.e., reserved for a virtual machine a lot more memory than necessary) and slow - it did not work out bursts and consumption peaks.  In addition, she strongly relied on the swap, which is not a good idea in the conditions of paid disk operations.  Not to mention the fact that the demon itself was written on the shell. <br><br><h1>  Perspectives </h1><br><br>  At present, memory management is carried out according to a very clumsy algorithm with three modes (init / run / stop) and simple hysteresis, in the near future writing an algorithm with an eye to the statistics of previous requests and adjusting the level of optimism of memory allocation. <br><br>  PS It was planned to add a <s>system to</s> this article <s>..</s> consumption graphs and memory allocation, however, making a stand, where it was not quite synthetic, turned out to be more complicated than I thought, so the graphs will be in a few days. <br><br>  PPS As a teaser - a habraeffect schedule for 140 users simultaneously walking around the site.  The blue line is allocated memory, the red line is occupied memory, the yellow line is free, cyan is a swap file.  In Y - bytes (i.e., the top is 1.2GB), in X - seconds since the start of the test. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c84/ad3/543/c84ad35438faad22a4ae7c78aab04018.png"></div><p>Source: <a href="https://habr.com/ru/post/99157/">https://habr.com/ru/post/99157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99146/index.html">Code That Cannot Be Supported (Part 2)</a></li>
<li><a href="../99147/index.html">The most expensive domains in the zone .RU</a></li>
<li><a href="../99150/index.html">Relatively new features in GMail labs: partial removal of the read mark and manual update of POP accounts</a></li>
<li><a href="../99152/index.html">Opera habragost - we approve the schedule</a></li>
<li><a href="../99155/index.html">How to make yourself push up in the morning</a></li>
<li><a href="../99159/index.html">GRUB Almighty, or Making a bootable USB flash drive</a></li>
<li><a href="../99160/index.html">Bill Gates invests $ 24 million in eco-friendly engine</a></li>
<li><a href="../99162/index.html">Compilation. 1: lexer</a></li>
<li><a href="../99163/index.html">openSUSE 11.3 "Teal"</a></li>
<li><a href="../99164/index.html">Linux fdisk and partition alignment on SDD and Advanced Format HDD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>