<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux distribution from scratch to build Docker images - our experience with dappdeps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Building images for a Docker based on a base image usually involves invoking commands in the environment of this base image. For example, invoking the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux distribution from scratch to build Docker images - our experience with dappdeps</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uy/gw/ey/uygweyxouk2t1fg0948fq4mws0w.png"></div><br>  Building images for a Docker based on a base image usually involves invoking commands in the environment of this base image.  For example, invoking the apt-get command, which is in the base image, to install new packages. <br><br>  Often there is a need to install some set of utilities into the base system, with the help of which some files that are required in the final image are installed or assembled.  For example, to build a Go application, you need to install the Go compiler, put all the application source in the base image, and compile the required program.  However, the final image requires only a compiled program without the entire set of utilities that was used to compile this program. <br><br>  The problem is known: one of the ways to solve it can be to build an auxiliary image and transfer files from the auxiliary image to the resulting one.  For this, <a href="https://docs.docker.com/develop/develop-images/multistage-build/">Docker</a> appeared <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage builds</a> or <a href="https://flant.github.io/dapp/artifact_for_advanced_build.html">artifact images in dapp</a> .  And this approach ideally solves a problem similar to transferring the results of compiling source codes into the final image.  However, it does not solve all possible problems ... <br><a name="habracut"></a><br>  Here's another example: Chef is used in local mode to build an image.  To do this, chefdk is put in the base image, recipes are mounted or added, these recipes are launched that customize the image, install new components, packages, configs files and so on.  Similarly, another configuration management system can be used - for example, Ansible.  However, the installed chefdk takes about 500 MB and significantly increases the size of the final image - leaving it there makes no sense. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But Docker's multi-stage builds <b>will no longer solve this problem</b> .  What if the user doesn‚Äôt want to know about the side effect of the program - in particular, what files does it create?  For example, in order not to keep unnecessary explicit descriptions of all exported paths from an image.  I just want to start the program, get some result in the image, but so that the program and the whole environment needed for its work <b>remain outside the final image</b> . <br><br>  In the case of chefdk, it would be possible to mount a directory with this chefdk into an assembly image for the duration of the build.  But there are problems with this solution: <br><br><ol><li>  Not any program needed for assembly is installed in a separate directory that is easy to mount into the build image.  In the case of Ansible, you need to install Python in a nonstandard place so as not to conflict with system Python, which may cause problems. </li><li>  The mounted program will depend on the base image used.  If the program is compiled for Ubuntu, then it may not start in an environment not intended for it - for example, in Alpine.  Even chefdk, which is an omnibus package with all its dependencies, still depends on the system glibc and will not work in Alpine, where musl libc is used. </li></ol><br>  But what if we can prepare a kind of static unchanging set of all possible useful utilities that will be so cleverly linked that it <b>will work in any basic image</b> , even scratch?  After connecting such / such images to the base, in the final image there will be only an empty mount-point directory into which these utilities were connected. <br><br><h2>  In search of adventures </h2><br><h3>  Theory </h3><br>  You need to get an image that contains a set of programs in some statically defined non-standard directory - for example, <code>/myutils</code> .  Any program in <code>/myutils</code> should depend only on the libraries in <code>/myutils</code> . <br><br>  A dynamically compiled Linux program depends on the location of the <a href="https://linux.die.net/man/8/ld-linux">ld-linux</a> linker in the system.  For example, the <code>bash</code> binary in <code>ubuntu:16.04</code> compiled so that it depends on the linker <code>/lib64/ld-linux-x86-64.so.2</code> : <br><br><pre> <code class="bash hljs">$ ldd /bin/bash linux-vdso.so.1 =&gt; (0x00007ffca67d8000) libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007fd8505a6000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fd8503a2000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd84ffd8000) /lib64/ld-linux-x86-64.so.2 (0x00007fd8507cf000)</code> </pre> <br>  Moreover, this dependence is static and compiled into the binary itself: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"/lib64/ld-linux-x86-64.so.2"</span></span> /bin/bash Binary file /bin/bash matches</code> </pre> <br>  Thus, it is necessary: ‚Äã‚Äãa) to compile the conditional <code>/myutils/bin/bash</code> so that it uses the linker <code>/myutils/bin/bash</code> <code>/myutils/lib64/ld-linux-x86-64.so.2</code> ;  b) that the linker <code>/myutils/{lib64,lib}</code> <code>/myutils/lib64/ld-linux-x86-64.so.2</code> be configured to dynamically link libraries from <code>/myutils/{lib64,lib}</code> . <br><br>  The first step is to build a <code>toolchain</code> image, which will contain everything that is necessary for the assembly and subsequent work of other programs in a non-standard root directory.  To do this, we will come in handy to the instructions of the <a href="http://www.linuxfromscratch.org/lfs/view/stable/"><b>Linux From Scratch</b></a> project. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ac/7f/j2/ac7fj2pqeovpzxc3opjxvjh8l9k.png"></div><br><h3>  We build the distribution kit dappdeps </h3><br>  Why a set of images of our "distribution" is called <a href="https://github.com/flant/dapp/tree/master/dappdeps"><b>dappdeps</b></a> ?  Because these images are used by the <a href="https://github.com/flant/dapp">dapp</a> collector - they are going to the needs of this project. <br><br>  So, our <b>ultimate goal</b> : <br><br><ul><li>  A <a href="https://github.com/flant/dapp/blob/master/dappdeps/toolchain"><b>dappdeps / toolchain</b></a> image with a GCC compiler for building other applications and the glibc library. </li><li>  Image of <a href="https://github.com/flant/dapp/blob/master/dappdeps/base"><b>dappdeps / base</b></a> with a set of programs and all dependent libraries: bash, gtar, sudo, coreutils, findutils, diffutils, sed, rsync, shadow, termcap. </li><li>  Image of <a href="https://github.com/flant/dapp/blob/master/dappdeps/gitartifact"><b>dappdeps / gitartifact</b></a> with Git utility and all dependencies. </li><li>  An image of <a href="https://github.com/flant/dapp/blob/master/dappdeps/chefdk"><b>dappdeps / chefdk</b></a> with an omnibus chefdk package that contains all the Chef dependencies, including  Ruby interpreter. </li><li>  An image of <a href="https://github.com/flant/dapp/blob/master/dappdeps/ansible"><b>dappdeps / ansible</b></a> with the Ansible utility, which contains all the dependencies, including  Python interpreter. </li></ul><br>  Images of dappdeps may <b>depend on each other</b> .  For example, when building dappdeps / base, you need a toolchain and glibc from the dappdeps / toolchain image.  After compiling all the utilities in dappdeps / base, they will need files from dappdeps / toolchain to run at runtime. <br><br>  The main condition is that the utilities from these images <b>are located in a non-standard place</b> , namely, in <code>/.dapp/deps/</code> , and <b>do not depend on any utilities or libraries</b> in standard system paths.  Also in the dappdeps images there should not be any other files besides / <code>/.dapp/deps</code> . <br><br>  Such images will allow you to create on their basis containers with volumes containing utilities, and mount them to other containers using the <code>--volumes-from</code> option for Docker. <br><br><h3>  Putting dappdeps / toolchain </h3><br>  <a href="http://www.linuxfromscratch.org/lfs/view/stable/chapter05/chapter05.html">Chapter 5, ‚ÄúConstructing a Temporary System,‚Äù of</a> the Linux From Scratch tutorial, describes the process of building a temporary chroot environment in <code>/tools</code> with some set of utilities, which the main distribution kit then compiles. <br><br>  In our case, slightly alter the directory chroot-environment.  In the <code>--prefix</code> parameter we will specify <code>/.dapp/deps/toolchain/0.1.1</code> when compiling.  This is the directory that will appear in the assembly container when you mount dappdeps / toolchain into it - it contains all the necessary utilities and libraries.  We only need GNU binutils, GCC and glibc. <br><br>  Going image using Docker multi-stage builds.  In an image based on <code>ubuntu:16.04</code> whole environment is prepared and the programs are compiled and installed in <code>/.dapp/deps/toolchain/0.1.1</code> .  Then this directory is copied into the scratch-image dappdeps / toolchain: 0.1.1.  <i>Dockerfile can be found <a href="https://github.com/flant/dapp/blob/master/dappdeps/toolchain/Dockerfile">here</a> .</i> <br><br>  <b>The final dappdeps / toolchain image</b> is the ‚Äútemporary system‚Äù in LFS terminology.  GCC in this system is still tied to the system library paths, however, we will not ensure that GCC works in any basic image.  The image of dappdeps / toolchain is auxiliary, it will be used later, incl.  to build already really independent of the general system libraries of programs. <br><br><h3>  Use Omnibus with dappdeps / toolchain </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u8/n3/ki/u8n3kiqgq8fyaushhi091__szpk.png"></div><br>  For projects such as <a href="https://github.com/chef/chef-dk">chefdk</a> or <a href="https://gitlab.com/gitlab-org/omnibus-gitlab">GitLab</a> , <a href="https://github.com/chef/omnibus"><b>Omnibus is</b></a> used.  It allows you to create self-contained bundles with the program and all dependent libraries, except the system linker and libc.  All instructions are described by easy-to-read Ruby recipes.  Also, the Omnibus project has a library of already written <a href="https://github.com/chef/omnibus-software/">omnibus-software</a> recipes. <br><br>  So, let's try to describe the <b>build of the remaining dappdeps distributions using Omnibus</b> .  However, to get rid of the dependency on the system linker and libc, we will collect all the programs in Omnibus using the compiler from dappdeps / toolchain.  In this case, the programs will be tied to glibc, which is also in dappdeps / toolchain. <br><br>  To do this, save the contents of dappdeps / toolchain as an archive: <br><br><pre> <code class="bash hljs">$ docker pull dappdeps/toolchain:0.1.1 $ docker save dappdeps/toolchain:0.1.1 -o dappdeps-toolchain.tar</code> </pre> <br>  Add this archive via the <code>Dockerfile ADD</code> directive and unpack the contents of the archive into the root of the building container: <br><br><pre> <code class="bash hljs">ADD ./dappdeps-toolchain.tar /dappdeps-toolchain RUN tar xf /dappdeps-toolchain/**/layer.tar -C /</code> </pre> <br>  Before running the assembly via omnibus, add the path <code>/.dapp/deps/toolchain/0.1.1/bin</code> to the <code>PATH</code> variable as a priority so that GCC from dappdeps / toolchain is used. <br><br>  <b>The output of</b> Omnibus is a package (in our case, DEB), the contents of which is unpacked and transferred to <code>/.dapp/deps/{base|gitartifact|...}</code> using Docker multi-stage builds similar to dappdeps / toolchain. <br><br><h3>  Putting dappdeps / base </h3><br>  The project for Omnibus is described using the project file <a href=""><code>dapp/dappdeps/base/omnibus/config/projects/dappdeps-base.rb</code></a> : <br><br><pre> <code class="ruby hljs">name <span class="hljs-string"><span class="hljs-string">'dappdeps-base'</span></span> license <span class="hljs-string"><span class="hljs-string">'MIT'</span></span> license_file <span class="hljs-string"><span class="hljs-string">'LICENSE.txt'</span></span> DOCKER_IMAGE_VERSION = <span class="hljs-string"><span class="hljs-string">"0.2.3"</span></span> install_dir <span class="hljs-string"><span class="hljs-string">"/.dapp/deps/base/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{DOCKER_IMAGE_VERSION}</span></span></span><span class="hljs-string">"</span></span> build_version DOCKER_IMAGE_VERSION build_iteration <span class="hljs-number"><span class="hljs-number">1</span></span> dependency <span class="hljs-string"><span class="hljs-string">"dappdeps-base"</span></span></code> </pre> <br>  This file shows all dependencies of the Omnibus-package dappdeps-base and the target directory for installation.  Dependencies can be located either in a separate repository (for example, <a href="https://github.com/chef/omnibus-software/">omnibus-software</a> ) or in the <code>omnibus/config/software</code> directory.  Each file in this directory describes the instructions for installing a package / component.  For dappdeps-base, Omnibus has software recipes that are missing from the standard omnibus-software repository: <code>acl</code> , <code>attr</code> , <code>coreutils</code> , <code>diffutils</code> , <code>findutils</code> , <code>gtar</code> , <code>rsync</code> , <code>sed</code> , <code>shadow</code> , <code>sudo</code> , <code>termcap</code> . <br><br>  Consider the example of <code>rsync</code> , as the software recipe for Omnibus looks like: <br><br><pre> <code class="ruby hljs">name <span class="hljs-string"><span class="hljs-string">'rsync'</span></span> default_version <span class="hljs-string"><span class="hljs-string">'3.1.2'</span></span> license <span class="hljs-string"><span class="hljs-string">'GPL-3.0'</span></span> license_file <span class="hljs-string"><span class="hljs-string">'COPYING'</span></span> version(<span class="hljs-string"><span class="hljs-string">'3.1.2'</span></span>) { source <span class="hljs-symbol"><span class="hljs-symbol">md5:</span></span> <span class="hljs-string"><span class="hljs-string">'0f758d7e000c0f7f7d3792610fad70cb'</span></span> } source <span class="hljs-symbol"><span class="hljs-symbol">url:</span></span> <span class="hljs-string"><span class="hljs-string">"https://download.samba.org/pub/rsync/src/rsync-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{version}</span></span></span><span class="hljs-string">.tar.gz"</span></span> dependency <span class="hljs-string"><span class="hljs-string">'attr'</span></span> dependency <span class="hljs-string"><span class="hljs-string">'acl'</span></span> dependency <span class="hljs-string"><span class="hljs-string">'popt'</span></span> relative_path <span class="hljs-string"><span class="hljs-string">"rsync-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{version}</span></span></span><span class="hljs-string">"</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> env = with_standard_compiler_flags(with_embedded_path) command <span class="hljs-string"><span class="hljs-string">"./configure --prefix=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{install_dir}</span></span></span><span class="hljs-string">/embedded"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">env:</span></span> env command <span class="hljs-string"><span class="hljs-string">"make -j </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{workers}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">env:</span></span> env command <span class="hljs-string"><span class="hljs-string">'make install'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">env:</span></span> env <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The <code>source</code> directive specifies the URL from which to download the source code.  Dependencies on other components are indicated by <code>dependency</code> by name.  The name of the component being assembled is specified by the <code>name</code> directive.  Each software recipe in turn may indicate dependencies on other components.  Inside the <code>build</code> block, there are standard build commands from source codes. <br><br>  <i>The Omnibus project and the Dockerfile for dappdeps / base can be found <a href="https://github.com/flant/dapp/tree/master/dappdeps/base">here</a> .</i> <br><br><h3>  Putting dappdeps / gitartifact </h3><br>  In the case of dappdeps-gitartifact, only a recipe for building Git is needed, and it is already in omnibus-software - all that remains is to plug it into the current Omnibus.  The rest is all the same. <br><br>  <i>The Omnibus and Dockerfile project for dappdeps / gitartifact can be found <a href="https://github.com/flant/dapp/tree/master/dappdeps/gitartifact">here</a> .</i> <br><br><h3>  We collect dappdeps / chefdk </h3><br>  For chefdk, there is also a ready-made <a href="https://github.com/chef/chef-dk">Omnibus project</a> .  It only remains to add it to the assembly container through Dockerfile and replace the standard installation paths chefdk <code>/opt/chefdk</code> with <code>/.dapp/deps/chefdk/2.3.17-2</code> (our installation path will include the Chef version). <br><br>  <i>Dockerfile to build dappdeps / chefdk can be found <a href="https://github.com/flant/dapp/blob/master/dappdeps/chefdk/Dockerfile">here</a> .</i> <br><br><h3>  Putting dappdeps / ansible </h3><br>  To build Ansible, we also start an Omnibus project, in which we install the Python interpreter, pip and describe the software recipe for Ansible: <br><br><pre> <code class="ruby hljs">name <span class="hljs-string"><span class="hljs-string">"ansible"</span></span> ANSIBLE_GIT_TAG = <span class="hljs-string"><span class="hljs-string">"v2.4.4.0+dapp-6"</span></span> dependency <span class="hljs-string"><span class="hljs-string">"python"</span></span> dependency <span class="hljs-string"><span class="hljs-string">"pip"</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> command <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{install_dir}</span></span></span><span class="hljs-string">/embedded/bin/pip install https://github.com/flant/ansible/archive/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ANSIBLE_GIT_TAG}</span></span></span><span class="hljs-string">.tar.gz"</span></span> command <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{install_dir}</span></span></span><span class="hljs-string">/embedded/bin/pip install pyopenssl"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  As you can see, the Ansible image is a built-in Python, pip and installed via Ansible pip with dependencies. <br><br>  <i>The Omnibus and Dockerfile project for dappdeps / ansible can be found <a href="https://github.com/flant/dapp/tree/master/dappdeps/ansible">here</a> .</i> <br><br><h2>  How to use the dappdeps distribution? </h2><br>  To use dappdeps images via mounting volumes, <b>you must first create a container for each image</b> and specify which volume is stored in this container.  This requires Docker at the moment. <br><br><pre> <code class="bash hljs">$ docker create --name dappdeps-toolchain --volume /.dapp/deps/toolchain/0.1.1 dappdeps/toolchain:0.1.1 no-such-cmd 13edda732176a44d7d822202d8327565b78f4a2190368bb1df46cdad1e127b6e $ docker ps -a | grep dappdeps-toolchain 13edda732176 dappdeps/toolchain:0.1.1 <span class="hljs-string"><span class="hljs-string">"no-such-cmd"</span></span> About a minute ago Created dappdeps-toolchain</code> </pre> <br>  The container is called <code>dappdeps-toolchain</code> : by this name, all declared volumes of this container can be used for mounting to other containers with the help of <code>--volumes-from</code> .  The <code>no-such-cmd</code> command-line parameter is required for the Docker, but this container will never be launched - it will remain in the <code>Created</code> state. <br><br>  Create the remaining containers: <br><br><pre> <code class="bash hljs">$ docker create --name dappdeps-base --volume /.dapp/deps/base/0.2.3 dappdeps/base:0.2.3 no-such-cmd 20f524c5b8b4a59112b4b7cb85e47eee660c7906fb72a4935a767a215c89964e $ docker create --name dappdeps-ansible --volume /.dapp/deps/ansible/2.4.4.0-10 dappdeps/ansible:2.4.4.0-10 no-such-cmd cd01ae8b69cd68e0611bb6c323040ce202e8e7e6456a3f03a4d0a3ffbbf2c510 $ docker create --name dappdeps-gitartifact --volume /.dapp/deps/gitartifact/0.2.1 dappdeps/gitartifact:0.2.1 no-such-cmd 2c12a8743c2b238d90debaf066e29685b41b138c10f2b893a815931df866576d $ docker create --name dappdeps-chefdk --volume /.dapp/deps/chefdk/2.3.17-2 dappdeps/chefdk:2.3.17-2 no-such-cmd 4dffe74c49c8e4cdf9d749177ae9efec3bdae6e37c8b6df41b6eb527a5c1d891</code> </pre> <br>  So we have reached the climax, for the sake of which all this fuss was conceived.  So, as a demonstration of the possibilities, <b>install the <code>nginx</code> and <code>tree</code> packages in the Alpine image by running Ansible from dappdeps / ansible via Bash from dappdeps / base</b> : <br><br><pre> <code class="bash hljs">$ docker run -ti --name mycontainer --volumes-from dappdeps-toolchain --volumes-from dappdeps-base --volumes-from dappdeps-gitartifact --volumes-from dappdeps-ansible --volumes-from dappdeps-chefdk alpine:latest /.dapp/deps/base/0.2.3/embedded/bin/bash -lc <span class="hljs-string"><span class="hljs-string">'/.dapp/deps/ansible/2.4.4.0-10/embedded/bin/ansible localhost -m apk -a "name=nginx,tree update_cache=yes"'</span></span> [WARNING]: Unable to parse /etc/ansible/hosts as an inventory <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> [WARNING]: No inventory was parsed, only implicit localhost is available [WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match <span class="hljs-string"><span class="hljs-string">'all'</span></span> localhost | SUCCESS =&gt; { <span class="hljs-string"><span class="hljs-string">"changed"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"failed"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"msg"</span></span>: <span class="hljs-string"><span class="hljs-string">"installed nginx tree package(s)"</span></span>, <span class="hljs-string"><span class="hljs-string">"packages"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"pcre"</span></span>, <span class="hljs-string"><span class="hljs-string">"nginx"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span> ], <span class="hljs-string"><span class="hljs-string">"stderr"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stderr_lines"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"stdout"</span></span>: <span class="hljs-string"><span class="hljs-string">"(1/3) Installing pcre (8.41-r1)\n(2/3) Installing nginx (1.12.2-r3)\nExecuting nginx-1.12.2-r3.pre-install\n(3/3) Installing tree (1.7.0-r1)\nExecuting busybox-1.27.2-r7.trigger\nOK: 6 MiB in 14 packages\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"stdout_lines"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"(1/3) Installing pcre (8.41-r1)"</span></span>, <span class="hljs-string"><span class="hljs-string">"(2/3) Installing nginx (1.12.2-r3)"</span></span>, <span class="hljs-string"><span class="hljs-string">"Executing nginx-1.12.2-r3.pre-install"</span></span>, <span class="hljs-string"><span class="hljs-string">"(3/3) Installing tree (1.7.0-r1)"</span></span>, <span class="hljs-string"><span class="hljs-string">"Executing busybox-1.27.2-r7.trigger"</span></span>, <span class="hljs-string"><span class="hljs-string">"OK: 6 MiB in 14 packages"</span></span> ] }</code> </pre> <br>  The final chord - create an image from the resulting container and ... see that <b>from the dappdeps there are only empty mount-point directories left in it!</b> <br><br><pre> <code class="bash hljs">$ docker commit mycontainer myimage sha256:9646be723b91daeaf538b7d92bb8844578abc7acd3028394f543e883eeb382bb $ docker run -ti --rm myimage tree /.dapp /.dapp ‚îî‚îÄ‚îÄ deps ‚îú‚îÄ‚îÄ ansible ‚îÇ ‚îî‚îÄ‚îÄ 2.4.4.0-10 ‚îú‚îÄ‚îÄ base ‚îÇ ‚îî‚îÄ‚îÄ 0.2.3 ‚îú‚îÄ‚îÄ chefdk ‚îÇ ‚îî‚îÄ‚îÄ 2.3.17-2 ‚îú‚îÄ‚îÄ gitartifact ‚îÇ ‚îî‚îÄ‚îÄ 0.2.1 ‚îî‚îÄ‚îÄ toolchain ‚îî‚îÄ‚îÄ 0.1.1 11 directories, 0 files</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iu/mo/8_/iumo8_obxqjgejx4jeg7_4jwytg.jpeg"></div><br>  It would seem, what else can you dream? .. <br><br><h2>  Further work and problems </h2><br><h3>  What are the problems with dappdeps? </h3><br>  It is necessary to work on reducing the size of dappdeps / toolchain.  To do this, you need to divide the toolchain into 2 parts: the part needed to build new utilities in dappdeps, and the part with the base libraries of type glibc, which must be installed at runtime already to run these utilities. <br><br>  To work with the Ansible apt module in dappdeps / ansible, I had to add the contents of the python-apt package in Ubuntu directly to the image without rebuilding.  In this case, the apt module works without problems in basic DEB-based images, but glibc of a certain version is required.  Since apt itself is a distribution-specific module, this is valid. <br><br><h3>  What is missing in the Dockerfile? </h3><br>  To use a volume from a dappdeps / toolchain image, you must first create an archive of this image, and then add it to another image via the <code>Dockerfile ADD</code> directive (see the section ‚ÄúUsing Omnibus with dappdeps / toolchain‚Äù).  On the part of Dockerfile, there is not enough functionality that would allow you to simply connect the directory of another image for the build time as <code>VOLUME</code> , i.e.  analogue of the <code>--volumes-from</code> option for Dockerfile. <br><br><h2>  findings </h2><br>  We made sure that the idea works and allows you to use GNU and other CLI utilities in assembly instructions, run the Python or Ruby interpreter, even run Ansible or Chef in Alpine or scratch images.  At the same time, the writer of the assembly instructions does not need to know the side effect of the execution of running commands and explicitly list which files need to be imported, as is the case with Docker multi-stage builds. <br><br>  The results of this work <b>are also applied in practice</b> : dapp uses dappdeps images in building containers.  For example, Git from dappdeps / gitartifact is used to work with patches, and the Git utility with some guarantee behaves the same in all basic images.  However, how dapp uses dappdeps is beyond the scope of this article (links to code for the most curious: <a href="https://github.com/flant/dapp/tree/master/lib/dapp/dapp/deps">dapp / deps</a> , <a href="">dapp / dimg / builder / chef.rb</a> , <a href="">dapp / dimg / builder / ansible.rb</a> ). <br><br>  The purpose of this article was to convey the very idea and show the possibility of its application using a real practical example. <br><br>  PS All described dappdeps images <b>are available on hub.docker.com</b> : <code>dappdeps/toolchain:0.1.1</code> , <code>dappdeps/base:0.2.3</code> , <code>dappdeps/gitartifact0.2.1</code> , <code>dappdeps/ansible:2.4.4.0-10</code> , <code>dappdeps/chefdk:2.3.17-2</code> - you can use them. </div><p>Source: <a href="https://habr.com/ru/post/352432/">https://habr.com/ru/post/352432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352422/index.html">Payloads for testing web applications</a></li>
<li><a href="../352424/index.html">Analysis of the results of the presidential election of 2018. At the federal and regional level</a></li>
<li><a href="../352426/index.html">React v.16.3.0 released</a></li>
<li><a href="../352428/index.html">Friday JS: minus without minus</a></li>
<li><a href="../352430/index.html">Tarantool application: stored procedures</a></li>
<li><a href="../352434/index.html">Ransomware is gaining strength</a></li>
<li><a href="../352436/index.html">Blondes, monsters and artificial intelligence addictions</a></li>
<li><a href="../352438/index.html">Java Puzzlers NG S02: Wonderful and Wonderful</a></li>
<li><a href="../352440/index.html">The book "Security in PHP" (part 2). Code injection attacks</a></li>
<li><a href="../352442/index.html">The book "Security in PHP" (part 3). Cross-site scripting (XSS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>