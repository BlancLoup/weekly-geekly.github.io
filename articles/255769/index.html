<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Very subjective review of JS frameworks. AmpersandJS, part 0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: when I started to deal with MVC frameworks for the front end, this article by Henrik Joreteg somehow caught my eye. Now they have...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Very subjective review of JS frameworks. AmpersandJS, part 0</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: when I started to deal with MVC frameworks for the front end, <a href="http://blog.andyet.com/2014/08/13/opinionated-rundown-of-js-frameworks">this article by Henrik Joreteg</a> somehow caught my eye.</i>  <i>Now they have reached out to translate it for Habr, all the more so that AmpersandJS <a href="http://habrahabr.ru/search/%3Fq%3Dampersand.js">on Habr√© is not audible at all</a> .</i>  <i>I will try to organize a cycle of articles on this tool from &amp; yet, I think it is worthy of attention.</i> <br><br><img src="https://habrastorage.org/files/72a/bde/646/72abde6469814a5c86cfa60ede1833ac.jpg" alt="seals and bicycles"><br><br>  As part of our educational seminars, I give a brief overview of JS frameworks.  I didn‚Äôt really want to publish most of my opinions about these tools on the Web, because such things tend to stir up the masses, offend people, and unlike face-to-face conversations, there‚Äôs no really good bidirectional Internet discussion. communication with the audience. <br>  But I was often told that my review is extremely useful and helps to get a concise and, at the same time, a good understanding of the question ‚Äúwho is who in JS frameworks for creating single-page applications‚Äù.  On this occasion, I decided to materialize it and publish it as <i>Something</i> , but please remember that I just express my opinion, I am not telling you what to do, and you should use those tools that better suit you and your team.  You can easily disagree with me, write about it on Twitter, or, even better, post a separate post explaining your position. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>Angular.js</b> </h4><br><h5>  <b>behind</b> </h5><br><ol><li>  very easy to start using.  you can simply insert the script tag, add some ng-attributes to your application, and you magically get the behavior you need </li><li>  Angular is well supported by its core development team, many of whom work on Google on an ongoing basis. </li><li>  large audience / community </li></ol><br><a name="habracut"></a><br><h5>  <b>vs</b> </h5><br><ol><li>  If you choose Angular, then you learn Angluar.js instead of learning how to solve problems with JavaScript.  If I translated our team to write applications using Angular, what would happen when {here the name of the beautiful new JS framework} wants to change the world of front-end development?  Or if we find out that in specific tasks Angular cannot do exactly what we want from it and we want to do this part using something else?  How relevant are Angular development skills in this case?  Instead of JS developers, I would get people who have Angular as their main skill, not necessarily JavaScript itself. </li><li>  Violates the division of responsibility.  You can say that I have outdated views, but I still think that CSS should be used for decoration, HTML for the structure, and JavaScript for the application logic.  But in the case of Angular, you spend a lot of time describing the behavior inside HTML instead of JS.  For me personally, this is the most significant minus in Angular's reputation.  I do not want to describe the application logic in HTML, it is simply not enough expressive means for such a task, because it is a markup language for defining the structure of the document, and not for describing the logic of behavior.  To get around this point, Angular creates, in fact, another language inside HTML and sprinkles it with a small amount of JS to describe additional details.  Again, instead of learning how to build applications in JavaScript, you learn Angular, and everything gets complicated.  That's why my friend Ari's book on Angular is 600 pages thick! </li><li>  Too much magic.  For the magic you have to pay.  When you work with something at a high level of abstraction, it becomes much more difficult to figure out what exactly is wrong when something starts to work crookedly.  And, of course, when you get off the beaten path, very few people can help you.  I may be mistaken, but I assume that most people using Angular have little understanding of the framework to such an extent that they can change or even debug Angular as such. </li><li>  Almost does not provide structure for applications.  I'm not sure that there is any canonical way to build a single-page application on Angular.  Do not misunderstand me, I think that this is good, at least there is definitely nothing wrong with tools that do not impose any particular style of work, but it also means that it will be harder to understand someone else‚Äôs angular application or someone else. understand yours, because the writing styles are likely to be very different. </li></ol><br><h5>  <b>my subjective (and not insured from errors) conclusion</b> </h5><br>  Too much logic is described using a pseudo-language inside HTML instead of JS, and all this gives the impression of being too abstract and magical. <br>  I would rather like my team to be well versed with DOM and JS instead of learning high-level abstraction. <br><br><h4>  <b>Ember.js</b> </h4><br><h5>  <b>behind</b> </h5><br><ol><li>  A strong emphasis on doing the ‚ÄúThe Ember Way‚Äù (note the first point in the ‚Äúagainst‚Äù).  This is a double edged sword.  If you have a large team, which can potentially lead to a lot of confusion, the presence of a rigid structure can reconcile the desire to have common basic code and new developers who want to throw out everything written earlier to go away.  If they are all Ember-developed, they are likely to quickly join a new Ember project for them. </li><li>  Gives most of the complex problems encountered when building single-page applications to some incredibly intelligent people who will make a lot of difficult decisions for you (see the item in ‚Äúagainst‚Äù). </li><li>  Great responsive community. </li><li>  Good site with docks. </li></ol><br><h5>  <b>vs</b> </h5><br><ol><li>  A strong emphasis on doing the ‚ÄúThe Ember Way‚Äù (this is also in the pros).  There are a lot of rules in Ember.  Despite the fact that there is an opportunity to turn off the standard path, few people actually do it.  For example, you are not required to use handlebars with Ember, but I would be very surprised if there are many Ember applications in production that do not. </li><li>  The Ember code contains many specific opinions on how to solve a particular task.  If you do not agree with these views and decide to replace individual pieces of functionality with your own, you still send all the unused code to the browser.  Not that I like to count bytes, but it is conceptually better to be able to give the client only what is actually used.  In addition, if you give only what you use, then you will have less code that you need to look through to detect the bug. </li><li>  Big appetites for memory can also be considered a disadvantage, especially when Ember is <a href="http://discuss.emberjs.com/t/ember-memory-consumption/528/3">launched on mobile devices</a> . </li><li>  Ember intentionally has no structural flexibility.  Do not believe me?  <a href="https://twitter.com/wycats/status/446520058848624640">Then believe Yehuda (one of the two main Ember developers; the rest of the discussion is also quite interesting).</a> </li></ol><br><h5>  <b>my subjective conclusion</b> </h5><br>  The lack of flexibility and the feeling that when using Ember you either need to take it entirely or not to take it at all - these are the main reasons why I would not really like to deal with it. <br><br><h4>  <b>React</b> </h4><br>  It is worth noting that the truth is not quite honest to include React in this list.  This is not a framework, but a presentation layer.  But he is being so actively discussed that I decided to include it in this review.  Basically, when you add a Facebook flux to it, it can already be considered a framework. <br><br><h5>  <b>behind</b> </h5><br><ol><li>  The ability to rebuild the DOM without worrying about cleaning it up.  React compares the virtual DOM that you have rendered to those in the real DOM at the moment, and makes minimal changes to synchronize them. </li><li>  Virtual DOM also makes it easy to solve problems related to event handling in different browsers, providing a browser-independent and standards-compliant model of the emergence and "ascent" of events.  As a result, you get a compatible event model in any browser. </li><li>  React is just a presentation layer, not a framework as such.  So you can use any tool when developing an application that you like.  It fits well with Backbone, since Backbone does not provide a boxed solution to bind a view to a model, offering to re-render the view when the model changes, and it is for this process that React is sharpened. </li></ol><br><h5>  <b>vs</b> </h5><br><ol><li>  The template syntax and DOM creation method (using JSX) is a bit strange for a JS developer, simply because you need to store unquoted HTML in Javascript code as if it were valid.  Yes, JSX is optional, but alternative: React.DOM.div (null, "Hello", this.props.name);  - in my opinion, not much better. </li><li> If you really need complete and explicit control over changes in the DOM, React will not give it to you.  For example, you need to clearly control how changes in style-attributes occur to create interfaces with the ability to drag and drop elements.  You can not easily establish the order in which classes are added and so on (I want to note that I would call it a disadvantage, but I personally have no problems because of this, at the same time I communicated with the developers who suffered precisely with this feature React; in general, do not rely heavily on my opinion in this matter) </li><li>  Despite the fact that it is possible to rebuild the entire view of React at once, if its components are complex enough, there is a strong suspicion that in some cases, finding out the differences between a virtual and a real DOM can become quite a laborious process.  I heard that some developers using React implemented updating only those elements that were known to have changed, and this, in my opinion, discredits the very idea of ‚Äã‚Äãnon-interference in the model rendering process.  Again, in this matter I have little experience. </li></ol><br><h5>  <b>my subjective conclusion</b> </h5><br>  A quick note about the ‚ÄúFLUX‚Äù architecture.  For me, this is not a new information or idea, just a new name.  And it seems that <a href="https://twitter.com/jashkenas/status/497062452195250176">I am not alone in this opinion</a> . <br>  I understand the concept of FLUX as having a data layer with a reasonably made event system in something like Ampersand or Backbone with the transformation of all user operations and updates from the server into changes in the state of this layer. <br>  If you want to ensure that user actions never lead directly to a DOM update, you will eventually come to the same unidirectional chain of events as in FLUX + React.  We intentionally did not include any bidirectional binding of the model and representation in Ampersand for this reason.  In my opinion, bidirectional binding is a potential source of danger.  We have been using an architecture for many years in which only one layer deals with inbound events, no matter whether it is user input or server response. <br><br><h4>  <b>Polymer</b> </h4><br>  This guy is a bit weird for me.  It is built on the basis of a standard that was developed to enable custom elements (document.registerElement for creating new HTML tags with embedded behavior), import HTML (‚Äπlink type = 'html'‚Ä∫) in order to import these custom elements into other documents ), and shadow DOM (to isolate CSS from the rest of the document) <br>  All these things are great (except for HTML import, in my opinion). <br>  But judging by the description of Polymer, there is a feeling that this is a universal tool to make all web development easy and beautiful, and that this framework is good for virtually everything.  Here is a quote from the official site: <br><blockquote>  Web components are entering a new era of web development, based on encapsulated and interoperable custom elements that extend HTML as such.  Made on the basis of these standards, Polymer makes it easier and faster to create anything from a simple button to an entire application for the desktop, mobile devices and anything else you can imagine. </blockquote><br>  Despite the fact that I consider the possibility of creating custom elements and encapsulating their behavior just fantastic, I am disappointed with the positioning of the framework.  It feels like we now have to use it literally for everything. <br>  A simple argument: I don‚Äôt know of any significant Google apps that would use polymer at least for something. <br>  This is for me as a red traffic light.  Don't get me wrong, obviously this is a new thing, but change takes time.  The problem is simply that the text on the site, which is also an appeal from Google engineers working on Polymer, does not reflect this novelty. <br>  In addition, even if you were creating a bunch of custom elements covering all your code for the presentation layer in a single-page application, the process of managing the creation / deletion of these elements should be organized.  All of you also have to manage the state and choose the tools to build the internals of the application, which leads us to the fact that all these custom elements are in truth just another way of writing the equivalent Backbone view.  In the world of one-page applications, I don‚Äôt see a big gain from the fact that we just go into coding these things inside custom elements. <br><h5>  <b>behind</b> </h5><br><ol><li>  A wonderful opportunity to create such things as custom form elements, without waiting for their support in browsers. </li><li>  Polymer is quite polyphilic, so you can start using and experimenting with its functionality right now. </li><li>  Isolating widget creation styles has been a web problem for many years.  New standards solve this problem at the browser level, which is just great. </li></ol><br><h5>  <b>vs</b> </h5><br><ol><li>  Personally, it seems to me that one of the main incentives for Google to create such a tool is the desire to embed their services, which include behavior, styles and functionality, into pages so simple that you don‚Äôt even need to know JS itself.  I may be completely wrong in this assumption, but I cannot get rid of the feeling that marketing motivation is the main driving force for promoting new standards in this case. </li><li>  HTML import seems like a bad idea to me.  In fact, this is the same rake as in the case of CSS <a href="https://habrahabr.ru/users/import/" class="user_link">import</a> .  If you import something, you need to wait until the answer comes from the server, after which it turns out that this is something that imports another component and so on.  Thus, if you really stick to a component-oriented approach for building a page that is presented as the best, you will have to deal with a bunch of network requests.  True, there is a ‚Äúvulcanizer‚Äù for the layout of dependencies.  But the inline layout does not seem to me the right decision.  A <a href="http://tjvantoll.com/2014/08/12/the-problem-with-using-html-imports-for-dependency-management/">voluminous post about problems with HTML import</a> was recently written, where this issue and some other problems are discussed. </li><li>  I just don‚Äôt understand why Google is so aggressively promoting Polymer as if it were a panacea for development, despite the fact that the only example of a Google product where they use it that I managed to find is the Polymer site itself.  The site states that "Polymer makes it easier and faster to create anything from a simple button to a whole application for the desktop, mobile devices and everything that you can imagine."  From my experience with Polymer, the opposite is rather obvious, I feel that they want to deceive me. </li></ol><br><h5>  <b>my subjective conclusion</b> </h5><br>  For some reason, Google does not eat what he himself is preparing.  The specification on document.registerElement is fascinating, I see no other use for Polymer, except as a polyfile for this functionality, I'm sorry. <br><br><h4>  <b>Backbone</b> </h4><br>  There is no more common framework for building single-page applications used in production versions of sites than Backbone I know of.  The <a href="http://backbonejs.org/">examples section in the Backbone documentation</a> lists a large number of known sites, and it‚Äôs far from complete. <br><h5>  <b>behind</b> </h5><br><ol><li>  This is a fairly small and flexible set of well-tested blocks for building applications. <br><ul><li>  Models </li><li>  Collections </li><li>  Views </li><li>  Router </li></ul><br></li><li>  He solves most of the major problems. </li><li>  Its focused functionality allows you to quickly figure it out.  I always let me examine the Backbone.js documentation as the first task for all new front-end developers who come to the &amp; yet team. </li></ol><br><h5>  <b>vs</b> </h5><br><ol><li>  Backbone does not provide solutions for all problems that you encounter during development.  Therefore, from my experience, everyone who uses backbone has to create their own ‚Äúframework‚Äù on top of the Backbone base. </li><li>  Most likely when using pure Backbone you will miss the following things: <br><ul><li>  Ways to create secondary properties for models </li><li>  The way of binding properties, including those secondary to the representation </li><li>  The way to render a set of views inside any element </li><li>  A simple way to work with subviews, dependent layouts and the like </li></ul><br></li><li>  Despite the minimalism of Backbone, its components are too connected with each other.  For example, until a release involving the merge of <a href="https://github.com/jashkenas/backbone/pull/3052">my pull request</a> , it was impossible to use any other type of Model within the Backbone Collections without local changes to internal methods.  This may be noncritical for some applications, but this is necessary if, for example, I want the model to store observable data in a library, with which other code, not necessarily dependent on Backbone, should be able to work.  The only way to use Backbone Models is to include the entire Backbone in the project, which seems to me wrong and ineffective. </li></ol><br><h5>  <b>my subjective conclusion</b> </h5><br>  Backbone was the discoverer of many wonderful things.  I have been using it since version 0.3 and I am very impressed with its minimalistic concept. <br>  He stimulated the emergence of a new generation of applications that have begun to use the browser as a medium of execution, and not as an engine for rendering documents.  But its narrow specialization leads to the fact that developers have to write their solutions on top of Backbone.  Despite the fact that this is not bad in and of itself, it just becomes obvious that the development will have to deal with a large number of problems. <br><br><h4>  <b>No framework</b> </h4><br>  There is a subset of developers who believe that frameworks should not be used at all.  This point of view is close to me in many respects and I agree with the main arguments, but such an approach is simply not expedient, especially in the case of team development. <br>  I tend to agree with the position indicated in the <a href="http://blog.ryanflorence.com/you-cant-not-have-a-framework.html">post by Ryan Florence</a> , which is best described in this quote: <br>  When you decide not to use a public framework, in the end you will come to the conclusion that you still use the framework, only it will be your own. <br>  He further says that this is not a bad decision by default, but you need to be serious, maintain your code, and so on.  I highly recommend reading this post, it is just great. <br><h5>  <b>behind</b> </h5><br><ul><li>  Ultimate flexibility </li><li>  You can include in the assembly only the code that you actually use in your application. </li></ul><br><h5>  <b>vs</b> </h5><br><ul><li>  A large amount of work on the invention of bicycles and, as a result, the high cost of development </li><li>  It is more difficult to understand which modules to use and which ones are better suited in this situation. </li><li>  Lack of clear documentation and agreements for new developers </li><li>  Difficult adaptation and reuse of code in new projects </li><li>  You will have to learn from your mistakes instead of taking advantage of someone else‚Äôs proven code. </li></ul><br><br><h4>  <b>HUGE abyss</b> </h4><br>  In the process of conducting our seminars and preparing <a href="http://humanjavascript.com/">my book Human JavaScript</a> , as well as within our team as such, we came to understand that there is a huge gap between the process of choosing a tool, framework or library, and directly developing a complete application. <br>  I‚Äôm not saying that the question ‚Äúhow to create an application by the team‚Äôs forces so as not to crush each other‚Äôs legs and other parts of the body?‚Äù Confronts us with a number of serious problems.  After all, apart from the question of choosing a framework, we still have a lot of ways and patterns that we can use to structure, build and deploy applications. <br>  A very small number of people write about these issues, although this rabbit hole seems no less profound than the one we find ourselves trying to choose a framework. <br><br><h4>  <b>What we really want</b> </h4><br><ul><li>  To make it clear where to start </li><li>  Understandable, but not the only possible way to solve typical problems. </li><li>  Extremely clear division of responsibility for easy replacement and combination of different parts of the application. </li><li>  Easy dependency management </li><li>  Ability to use existing proven solutions without inventing bicycles </li><li>  Development infrastructure, in which we can switch between dev and prod modes by simply changing the boolean variable in the config </li></ul><br><h4>  <b>What do we offer about this?</b> </h4><br>  So, if you have not yet guessed, we have done a terrible thing for the world of JavaScript.  Namely, the "new" framework: <a href="http://ampersandjs.com/">Ampersand.js</a> .  Slightly reminiscent of the lightweight Backbone or its offshoot. <br>  Feedback is extremely positive so far, we announced it in the middle of summer, and a <a href="http://ampersandjs.com/contribute">number of great guys</a> have already joined the work on its development.  There were already <a href="https://www.youtube.com/watch%3Fv%3DUzJCz1qAiHg">reports about him at conferences</a> , and Jeremy Ashkenaz, the creator of Backbone.js, Underscore.js, and CoffeeScript asked me to make a keynote about Ampersand.js on BackboneConf 2014. <br>  How did we try to take into account all the shortcomings that I listed above with respect to other frameworks? <br><ol><li>  Flexibility and Extensibility <br><ul><li>  Ampersand has a set of ‚Äúkernel‚Äù modules (see the documentation) that roughly correspond to the set of Backbone components.  But they can all be installed and used separately.  It is not assumed that you must use RESTful or the Ajax API in general.  If you do not need these things, you simply use Ampersand-State, and not its decorated version, the Ampersand-Model, which complements State RESTful methods. </li><li>  Included is no template.  Templates can be specified by elementary strings with HTML, functions that return such strings, or functions that return DOM elements.  In the demo application, there are examples of using more complex templatizer templates, but in fact, templating can be done with anything.  For example, there is a remarkable approach in the style of handlebars / htmlbars + Ember with the declaration of bindings inside the template itself, implemented in <a href="https://github.com/latentflip/domthing">domthing by</a> Philip Roberts.  There are developers using React in conjunction with Ampersand views. </li><li>  In views (views), you can set data bindings, regardless of the template engine.  That is, if necessary, you can use just HTML strings as templates and still completely control the process of linking data with their presentation.  The lack of a template in the standard package allows you to create modular / reusable views without having to drag the template with them. </li></ul><br></li><li>  There must be some obvious starting point and a conceptual scheme for setting the structure of the application, but these things should not be turned into obligatory ones.  We created a CLI that you can use to create a framework for new applications.  It takes as a basis a number of such agreements, and can serve both for the initial stage of development, and simply as a source of useful knowledge.  More information can be found in the <a href="http://ampersandjs.com/learn/quick-start-guide">manual</a> . </li><li>  We decided that it is better to base something with a good reputation than to create a new framework, just to create a new framework.  Therefore, we took Backbone as a basis, and did not do everything from scratch. </li><li>  I also wanted to have a more complete manual that eliminates this chasm, which I mentioned above.  It should pay attention to all surrounding concepts, tools and paradigms.  To do this, we wrote the book Human JavaScript.  It can be read entirely <a href="http://read.humanjavascript.com/">online</a> for free, and it is also available in e-book format. </li><li>  We wanted to make it easy to use existing solutions of common problems to minimize cycling in projects.  Therefore, we use npm to manage all the packages, and have made a <a href="http://tools.ampersandjs.com/">catalog of our favorite clientside modules</a> with a convenient search. </li><li>  I also wanted to have the possibility of a smooth transition from the dev-environment to the production.  We solve this problem using <a href="https://github.com/HenrikJoreteg/moonboots">moonboots</a> , which adds this functionality to browserify.  Moonboots has a plugin for <a href="http://hapijs.com/">hapi.js</a> and <a href="http://expressjs.com/">express.js</a> , where everything you need to do to change the mode of the application from the production version (minified, cached static assemblies with unique names) to dev (reassemble the code for each new request, do not minify and do not cache anything) - this is to change the value of one boolean variable. </li><li>  We did not want this project to belong exclusively to ours &amp; yet.  We already have about 40 contributors since we told everyone about Ampersand.js and we recently added the first of, I hope, many non-of-yet-contributors to the framework core project.  All parts use the extremely loyal MIT license, and the modular weakly-connected framework structure in itself makes it possible to replace or expand any of its components to meet your requirements.  We also got a separate organization for this project on GitHub. </li><li>  I also wanted to provide additional support and training if necessary.  To do this, we made the IRC channel # &amp; yet available on freenode for questions and support.  In addition to free resources, we did an online course ‚ÄúHuman JavaScript code-along‚Äù and offline seminars with practical exercises and feedback. </li></ol><br><h4>  <b>So you want to say that Ampersand is definitely the best choice?</b> </h4><br>  Not.  He certainly has his own list of compromise solutions.  Here are some of them that are obvious to me, probably, there are more: <br><ul><li>  Naturally, Ampersand has a few more immature code base compared to some other similar tools.  Recognizing this, we, however, use it in all single-page applications developed by us, and all basic modules have good test coverage.  It is worth noting that if you still encounter a problem, most likely you will be able to deal with it yourself.  ,         ,      ,     -   .               .           npm    -.    <a href="http://semver.org/"> </a> ,      ,        .  ,    ,      -   .  ,   ,  -     -,        .         ,     ,          . </li><li>    Ampersand        .    , ,    ,      ,    . ,  ,   ,      Ampersand. </li><li>       Ampersand.       , ,      IE8.      , <a href="http://jquery.com/browser-support/">jQuery 2.0     </a> , Google         IE   <a href="http://googlesystem.blogspot.com/2013/11/google-drops-support-for-ie9.html">    IE9 </a> ,    <a href="http://blogs.msdn.com/b/ie/archive/2014/08/07/stay-up-to-date-with-internet-explorer.aspx">Microsoft      </a> .    ?  ,          .    ,   ,    ,  .  ,     ,     (  ,     ).  ,       IE8   .     -     browserify transform,    ,       .    ,     , , ,    ,      IE 7  8  Ampersand-State. </li></ul><br><h4>  <b>Finally</b> </h4><br> ,             .             -   - ,     <a href="http://twitter.com/henrikjoreteg"> </a> . <br>        .  ,       .          <a href="http://issues.ampersandjs.com/"> </a>        . </div><p>Source: <a href="https://habr.com/ru/post/255769/">https://habr.com/ru/post/255769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255757/index.html">1C: Enterprise Development Tools, or Eclipse in Russian</a></li>
<li><a href="../255759/index.html">Sugar injections in C #</a></li>
<li><a href="../255761/index.html">Algorithms for fast calculation of factorial</a></li>
<li><a href="../255763/index.html">Coffee with cucumbers (Espresso + Cucumber)</a></li>
<li><a href="../255767/index.html">Study protection Artmoney. Part one</a></li>
<li><a href="../255773/index.html">Java-based configuration of embedded Jetty / Spring MVC / Spring Security</a></li>
<li><a href="../255775/index.html">Algorithms of intellectual autogeneration of levels in iOS game</a></li>
<li><a href="../255779/index.html">Microsoft and Adobe released a set of updates for their products, April 2015</a></li>
<li><a href="../255781/index.html">A new issue of the journal "In the clouds. RF"</a></li>
<li><a href="../255785/index.html">Lumen - a new PHP microframe from the developer Laravel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>