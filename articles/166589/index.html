<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We continue to invent function</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under the influence of the previous article, I propose to continue the theme of creating your own implementation of such a useful idiom as function in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We continue to invent function</h1><div class="post__text post__text-html js-mediator-article">  Under the influence of the <a href="http://habrahabr.ru/post/159389/">previous article, I</a> propose to continue the theme of creating your own implementation of such a useful idiom as <i>function</i> in C ++, and consider some aspects of its use. <br><a name="habracut"></a><br><h2>  What is function and why write another </h2><br>  I will try to give a brief free formulation: <i>this is an object that has semantics of meaning and allows you to bring free functions and member functions of classes to a single call interface</i> .  If necessary, the object saves the context of the call, talking about <i>this</i> , which is relevant for member functions of classes. <br>  Advanced implementations, such as <a href="http://www.boost.org/doc/libs/1_52_0/doc/html/function.html">boost</a> , offer such interesting tools as adapting functions with an inappropriate signature to the required call interface, as well as the possibility of associating arguments with parameters at the time of initialization.  But, in my opinion, such opportunities are beyond the scope of the main theme, noticeably inflate the implementation, but at the same time, they are far from always necessary.  Such tools are certainly convenient and sometimes even useful, but, in my subjective opinion, they complicate the reading and debugging of the code.  Let your own implementation be somewhat simpler, while possessing such advantages as relative conciseness and simplicity. <br><br><h2>  Motivation to continue the search </h2><br>  Thus, the statement of the problem: a class is required that is parameterized by the signature of the function that defines the call interface, which allows you to associate and later call both free functions and member functions of classes, saving the call context for the latter.  Returning to the solution from the <a href="http://habrahabr.ru/post/159389/">previous article</a> , does it meet the specified requirements, what can be noticed in it, which can be corrected?  The solution does not preserve the calling context for the member functions of the classes and, thus, loses its universality of application.  Inside, virtual functions are used, inheritance and dynamic memory allocation, which, as will be seen later, is not necessary, can be made easier.  I will make a reservation that the dynamic allocation of memory is considered to be the main aspect that needs improvement.  If it is necessary to link and transfer a function somewhere in a code with a high call frequency, which requires at least high performance, the first thought that arises when using a certain <i>function</i> , but will it not be inside memory allocations? .. fixed buffer of the required conservative size, use the <abbr title="placement new">placement in place</abbr> , do not forget about the correct alignment, but - there is another way. <br><br><h2>  Its implementation </h2><br>  To solve the problem, the language C ++ 11 is used.  Code tested in <abbr title="Apple clang version 4.1 (tags / Apple / clang-421.11.66) (based on LLVM 3.1svn)">Xcode 4.5.2 environment</abbr> .  The implementation of C ++ 11 in Visual Studio 2012 is late, but when installing <a href="http://blogs.msdn.com/b/vcblog/archive/2012/11/02/visual-c-c-11-and-the-future-of-c.aspx">November 2012 Compiler CTP,</a> you can get the level of support required for building the example, although there is no full practical application of speech.  In the code there is a slight reverence towards VS2012 for compatibility.  If necessary, the solution can be rewritten for C ++ 03 at the cost of a significant increase in the amount of code, but retaining the main advantages. <br>  I'll start from the end.  What a fancy usage example might look like: <br><pre><code class="hljs mel">#include &lt;iostream&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&gt; #include <span class="hljs-string"><span class="hljs-string">"function.hpp"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foo(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"foo: "</span></span> &lt;&lt; v &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; } struct bar { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> baz(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"bar::baz: "</span></span> &lt;&lt; v &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-comment"><span class="hljs-comment">//         typedef bc::function&lt;int (int)&gt; function_ptr; std::vector&lt;function_ptr&gt; functions; //     functions.push_back(BC_BIND(&amp;foo)); //   -       bar obj; functions.push_back(BC_BIND(&amp;bar::baz, &amp;obj)); int i = 0, c = 0; for (auto f : functions) c += f ? f(++i) : 0; std::cout &lt;&lt; "result: " &lt;&lt; c &lt;&lt; std::endl; }</span></span></code> </pre> <br>  It can be seen that objects can be located in the same container, pointing to different free functions and member functions of different classes.  The only requirement for them is a single format of parameters and a type of return value.  Because of the implementation features, the macro <i>BC_BIND</i> is used for the less short and uniform binding record.  It is interesting to note that the macro takes a different number of arguments, one and two, but the preprocessor does not support overloading macros of the same name by the number of arguments, however, it supports the transmission of a variable number of arguments through an ellipsis, which, combined with some magic, allows simulation of the overload by the number of arguments.  I will not go further, it‚Äôs not difficult at all to figure it out on my own, but I‚Äôll notice that Visual C ++ has manifested itself with its special vision of the standard, and for compatibility with its preprocessor it took a little more powerful magic. <br>  The story goes to the most interesting.  How can you store different pointers to different functions and member functions in a uniform way, and without dynamic allocations?  The standard does not say anything definite about the size of the pointers to functions and their structure, which would allow them to bring to a common denominator.  If for pointers to free functions at least POSIX <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html">requires</a> their safe conversion to <i>void *</i> and back, then for member functions there is nothing like that.  However, there is a way out.  Let the spectrum of processed functions that you want to bring to a single call interface in pseudocode looks like this: <br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_type</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_ptr</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">; };</span></span></code> </pre> <br>  It seems, but not the same.  Let's transform the second method: <br><pre> <code class="hljs php">return_type member_function_wrapper(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">Class</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">, ...) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context-&gt;member_function(...); }</code> </pre> <br>  Already better.  Another iteration: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">return_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free_function_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *unused, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> free_function(...); } <span class="hljs-function"><span class="hljs-function">return_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member_function_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *context, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Class*&gt;(context)-&gt;member_function(...); }</code> </pre> <br>  Great, both functions, <i>free_function_wrapper</i> and <i>member_function_wrapper,</i> have the same signature.  If there shouldn't be any questions from the first, then it remains for the second to figure out how to bring the class information and the pointer to the member function to its context.  And this possibility is also due to the templates, which can be parameterized not only by the types and integral compilation time constants, but also by the addresses of functions and member functions.  A simple abstract example: <br><pre> <code class="hljs vbscript">#include &lt;iostream&gt; struct bar { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> baz(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> v) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"bar::baz: "</span></span> &lt;&lt; v &lt;&lt; std::endl; return v; } }; template &lt;<span class="hljs-built_in"><span class="hljs-built_in">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>::*MemberFunctionPtr)(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>)&gt; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> function_wrapper(void *self, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> v) { return (static_cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>*&gt;(self)-&gt;*MemberFunctionPtr)(v); } <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { typedef <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (*function_ptr)(void*, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); function_ptr f = &amp;function_wrapper&lt;bar, &amp;bar::baz&gt;; bar obj; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> i = f(&amp;obj, <span class="hljs-number"><span class="hljs-number">1</span></span>); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"result: "</span></span> &lt;&lt; i &lt;&lt; std::endl; }</code> </pre> <br>  Thus, in <i>function, it</i> suffices to store a pointer to the template wrapper instantiated with the necessary parameters and a pointer to the context, which in the case of the member function will be equal to the pointer to the object instance, in the context of which the function must be executed, otherwise just <i>NULL</i> .  No memory allocations, a trivial copy constructor and an assignment operator - in my opinion, great. <br>  In conclusion, it remains to give the source text of the header with the implementation of the first example.  I do not see its meaning line by line, the main idea is indicated.  I note that the processing of a different number of function parameters is implemented using <abbr title="variadic templates">templates with a variable number of arguments</abbr> from C ++ 11, and this will require the most additional code in the case of migration to C ++ 03. <br><div class="spoiler">  <b class="spoiler_title">function.hpp</b> <div class="spoiler_text"><pre> <code class="hljs lua">#pragma once //#define BC_NO_EXCEPTIONS #include &lt;utility&gt; #include &lt;functional&gt; #define BC_SUBST(Arg) Arg #define BC_BIND_DISAMBIGUATE2(has_args, ...) BC_SUBST(BC_BIND_ ## has_args (__VA_ARGS__)) #define BC_BIND_DISAMBIGUATE(has_args, ...) BC_BIND_DISAMBIGUATE2(has_args, __VA_ARGS__) #define BC_HAS_ARGS_IMPL(TWO, ONE, N, ...) N #define BC_HAS_ARGS(...) BC_SUBST(BC_HAS_ARGS_IMPL(__VA_ARGS__, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ERROR)) #define BC_BIND(...) BC_BIND_DISAMBIGUATE(BC_HAS_ARGS(__VA_ARGS__), __VA_ARGS__) #define BC_BIND_1(fp) bc::detail::bind&lt;decltype(fp), fp&gt;() #define BC_BIND_2(mf, ip) bc::detail::bind&lt;decltype(mf), mf&gt;(ip) namespace bc // bicycle { template &lt;typename Signature&gt; class <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">namespace</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detail</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_traits</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArgumentTypes</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_traits</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*)</span></span></span></span>(ArgumentTypes...)&gt; { //typedef ReturnType (*Signature)(ArgumentTypes...); // MS <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> C3522: parameter pack cannot be expanded <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this context typedef <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes...)</span></span></span></span>&gt; function_type; template &lt;typename Signature, Signature fp&gt; static ReturnType wrapper(void const *, ArgumentTypes&amp;&amp; ... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*fp)(std::forward&lt;ArgumentTypes&gt;(args)...); } }; template &lt;typename ReturnType, typename Class, typename ...ArgumentTypes&gt; struct function_traits&lt;ReturnType (Class::*)(ArgumentTypes...)&gt; { //typedef ReturnType (Class::*Signature)(ArgumentTypes...); // MS <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> C3522: parameter pack cannot be expanded <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this context typedef Class * class_ptr; typedef <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes...)</span></span></span></span>&gt; function_type; template &lt;typename Signature, Signature mf&gt; static ReturnType wrapper(const void *ip, ArgumentTypes&amp;&amp; ... args) { Class* instance = const_cast&lt;Class*&gt;(static_cast&lt;Class const *&gt;(ip)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (instance-&gt;*mf)(std::forward&lt;ArgumentTypes&gt;(args)...); } }; template &lt;typename ReturnType, typename Class, typename ...ArgumentTypes&gt; struct function_traits&lt;ReturnType (Class::*)(ArgumentTypes...) const&gt; { //typedef ReturnType (Class::*Signature)(ArgumentTypes...) const; // MS <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> C3522: parameter pack cannot be expanded <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this context typedef const Class * class_ptr; typedef <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes...)</span></span></span></span>&gt; function_type; template &lt;typename Signature, Signature mf&gt; static ReturnType wrapper(void const *ip, ArgumentTypes&amp;&amp; ... args) { Class const *instance = static_cast&lt;Class const *&gt;(ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (instance-&gt;*mf)(std::forward&lt;ArgumentTypes&gt;(args)...); } }; // bind free <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fp</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_traits</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function">&gt;::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { typedef function_traits&lt;Signature&gt; traits; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typename traits::function_type(&amp;traits::template wrapper&lt;Signature, fp&gt;, <span class="hljs-number"><span class="hljs-number">0</span></span>); } // bind member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mf</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_traits</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signature</span></span></span><span class="hljs-function">&gt;::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typename function_traits&lt;Signature&gt;::class_ptr ip)</span></span></span></span> { typedef function_traits&lt;Signature&gt; traits; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typename traits::function_type(&amp;traits::template wrapper&lt;Signature, mf&gt;, ip); } } template &lt;typename ReturnType, typename ...ArgumentTypes&gt; class <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes...)</span></span></span></span>&gt; { typedef ReturnType (*StaticFuncPtr)(void const*, ArgumentTypes&amp;&amp; ...); public: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : func_(<span class="hljs-number"><span class="hljs-number">0</span></span>), data_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticFuncPtr f, void const *d)</span></span></span></span> : func_(f), data_(d) {} ReturnType operator () (ArgumentTypes... args) const { #ifndef BC_NO_EXCEPTIONS <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!func_) throw std::bad_function_call(); #endif // BC_NO_EXCEPTIONS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*func_)(data_, std::forward&lt;ArgumentTypes&gt;(args)...); } explicit operator bool() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> != func_; } bool operator == (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">other</span></span></span><span class="hljs-function">)</span></span> const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func_ == other.func_ &amp;&amp; data_ == other.data_; } bool operator != (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">other</span></span></span><span class="hljs-function">)</span></span> const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*this == other); } private: StaticFuncPtr func_; void const *data_; }; }</code> </pre> </div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/166589/">https://habr.com/ru/post/166589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166577/index.html">New design Lenta.ru</a></li>
<li><a href="../166579/index.html">Acer S275 Mini Monitor Review</a></li>
<li><a href="../166583/index.html">It is so easy to take and hide information</a></li>
<li><a href="../166585/index.html">Comfortable work at the computer at night</a></li>
<li><a href="../166587/index.html">Convenient CSS editing (Chrome + Save CSS + autoIt)</a></li>
<li><a href="../166593/index.html">Case in the ocean</a></li>
<li><a href="../166595/index.html">The most reliable storage medium</a></li>
<li><a href="../166597/index.html">Competition for the best scheme of the Moscow metro</a></li>
<li><a href="../166599/index.html">3D printing and Nokia Lumia 820</a></li>
<li><a href="../166601/index.html">Bypassing cycles through hard links</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>