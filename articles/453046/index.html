<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We use all index features in PostgreSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the Postgres world, indexes are extremely important for efficiently navigating the database repository (it is called the heap). Postgres does not s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We use all index features in PostgreSQL</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/sm/1h/ajsm1hnpv2mljoxorbwxshprkog.jpeg"></div><br>  In the Postgres world, indexes are extremely important for efficiently navigating the database repository (it is called the heap).  Postgres does not support clustering for it, and the MVCC architecture causes you to accumulate many versions of the same tuple.  Therefore, it is very important to be able to create and maintain efficient indexes to support applications. <br><br>  I offer you some tips on optimizing and improving the use of indexes. <br><br>  <i>Note: the queries shown below work on an unmodified <a href="https://github.com/devrimgunduz/pagila">sample of the pagila database</a> .</i> <br><a name="habracut"></a><br><h3>  Using Covering Indexes </h3><br>  Let's consider a request to retrieve email addresses for inactive users.  In the <code>customer</code> table there is an <code>active</code> column, and the query is simple: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN SELECT email FROM customer WHERE active=0; QUERY PLAN ----------------------------------------------------------- Seq Scan on customer (cost=0.00..16.49 rows=15 width=32) Filter: (active = 0) (2 rows)</span></span></code> </pre> <br>  The request invokes the complete sequence of scanning the <code>customer</code> table.  Let's create an index for the <code>active</code> column: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_cust1 ON customer(active); CREATE INDEX pagila=# EXPLAIN SELECT email FROM customer WHERE active=0; QUERY PLAN ----------------------------------------------------------------------------- Index Scan using idx_cust1 on customer (cost=0.28..12.29 rows=15 width=32) Index Cond: (active = 0) (2 rows)</span></span></code> </pre> <br>  It helped, the subsequent scan turned into an " <code>index scan</code> ".  This means that Postgres will scan the <code>idx_cust1</code> index and then continue searching the table heap to read the values ‚Äã‚Äãof other columns (in this case, the <code>email</code> column) that the query needs. <br><br>  PostgreSQL 11 appeared covering indexes.  They allow you to include in the index itself one or more additional columns - their values ‚Äã‚Äãare stored in the index data storage. <br><br>  If we used this feature and added the email value inside the index, then Postgres would not need to look for the <code>email</code> value in the table heap.  Let's see if this will work: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_cust2 ON customer(active) INCLUDE (email); CREATE INDEX pagila=# EXPLAIN SELECT email FROM customer WHERE active=0; QUERY PLAN ---------------------------------------------------------------------------------- Index Only Scan using idx_cust2 on customer (cost=0.28..12.29 rows=15 width=32) Index Cond: (active = 0) (2 rows)</span></span></code> </pre> <br>  " <code>Index Only Scan</code> " tells us that the query now needs only one index, which helps to avoid all disk I / O operations to read the table heap. <br><br>  Today covering indexes are available only for B-trees.  However, in this case, the accompanying effort will be higher. <br><br><h3>  Using partial indexes </h3><br>  Partial indexes index only a subset of rows in a table.  This saves the size of the indexes and makes scanning faster. <br><br>  Suppose we need to get a list of email addresses of our clients from California.  The request will be as follows: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.email <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customer c <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> address a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c.address_id = a.address_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.district = <span class="hljs-string"><span class="hljs-string">'California'</span></span>; which has a query plan that involves scanning both the tables that are joined: pagila=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN SELECT c.email FROM customer c pagila-# JOIN address a ON c.address_id = a.address_id pagila-# WHERE a.district = 'California'; QUERY PLAN ---------------------------------------------------------------------- Hash Join (cost=15.65..32.22 rows=9 width=32) Hash Cond: (c.address_id = a.address_id) -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=34) -&gt; Hash (cost=15.54..15.54 rows=9 width=4) -&gt; Seq Scan on address a (cost=0.00..15.54 rows=9 width=4) Filter: (district = 'California'::text) (6 rows)</span></span></code> </pre> <br>  What normal indexes will give us: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_address1 ON address(district); CREATE INDEX pagila=# EXPLAIN SELECT c.email FROM customer c pagila-# JOIN address a ON c.address_id = a.address_id pagila-# WHERE a.district = 'California'; QUERY PLAN --------------------------------------------------------------------------------------- Hash Join (cost=12.98..29.55 rows=9 width=32) Hash Cond: (c.address_id = a.address_id) -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=34) -&gt; Hash (cost=12.87..12.87 rows=9 width=4) -&gt; Bitmap Heap Scan on address a (cost=4.34..12.87 rows=9 width=4) Recheck Cond: (district = 'California'::text) -&gt; Bitmap Index Scan on idx_address1 (cost=0.00..4.34 rows=9 width=0) Index Cond: (district = 'California'::text) (8 rows)</span></span></code> </pre> <br>  The <code>address</code> scan was replaced by <code>idx_address1</code> index <code>idx_address1</code> , and then the <code>address</code> heap was scanned. <br><br>  Since this is a frequent query and needs to be optimized, we can use a partial index that indexes only those lines with addresses in which the region <code>'California'</code> : <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_address2 ON address(address_id) WHERE district='California'; CREATE INDEX pagila=# EXPLAIN SELECT c.email FROM customer c pagila-# JOIN address a ON c.address_id = a.address_id pagila-# WHERE a.district = 'California'; QUERY PLAN ------------------------------------------------------------------------------------------------ Hash Join (cost=12.38..28.96 rows=9 width=32) Hash Cond: (c.address_id = a.address_id) -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=34) -&gt; Hash (cost=12.27..12.27 rows=9 width=4) -&gt; Index Only Scan using idx_address2 on address a (cost=0.14..12.27 rows=9 width=4) (5 rows)</span></span></code> </pre> <br>  Now the query reads only <code>idx_address2</code> and does not touch the <code>address</code> table. <br><br><h3>  Using Multi-Value Indexes </h3><br>  Some columns that need to be indexed may not contain a scalar data type.  <code>jsonb</code> types like <code>jsonb</code> , <code>arrays</code> and <code>tsvector</code> contain multiple or multiple values.  If you need to index such columns, you usually have to search through all the individual values ‚Äã‚Äãin these columns. <br><br>  Let's try to find the names of all films containing slices from unsuccessful duplicates.  The <code>film</code> table has a text column called <code>special_features</code> .  If the film has this ‚Äúspecial property‚Äù, then the column contains an element in the form of a text array <code>Behind The Scenes</code> .  To search for all such films, we need to select all rows with ‚ÄúBehind The Scenes‚Äù for <b>any</b> values ‚Äã‚Äãof the <code>special_features</code> array: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> film <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> special_features @&gt; <span class="hljs-string"><span class="hljs-string">'{"Behind The Scenes"}'</span></span>;</code> </pre> <br>  The containment operator <code>@&gt;</code> checks whether the right side is a subset of the left side. <br><br>  Request Plan: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN SELECT title FROM film pagila-# WHERE special_features @&gt; '{"Behind The Scenes"}'; QUERY PLAN ----------------------------------------------------------------- Seq Scan on film (cost=0.00..67.50 rows=5 width=15) Filter: (special_features @&gt; '{"Behind The Scenes"}'::text[]) (2 rows)</span></span></code> </pre> <br>  Which requests a full heap scan with a cost of 67. <br><br>  Let's see if the usual B-tree index will help us: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_film1 ON film(special_features); CREATE INDEX pagila=# EXPLAIN SELECT title FROM film pagila-# WHERE special_features @&gt; '{"Behind The Scenes"}'; QUERY PLAN ----------------------------------------------------------------- Seq Scan on film (cost=0.00..67.50 rows=5 width=15) Filter: (special_features @&gt; '{"Behind The Scenes"}'::text[]) (2 rows)</span></span></code> </pre> <br>  The index was not even considered.  The B-tree index does not know about the existence of individual elements in the indexed values. <br><br>  We need a GIN-index. <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_film2 ON film USING GIN(special_features); CREATE INDEX pagila=# EXPLAIN SELECT title FROM film pagila-# WHERE special_features @&gt; '{"Behind The Scenes"}'; QUERY PLAN --------------------------------------------------------------------------- Bitmap Heap Scan on film (cost=8.04..23.58 rows=5 width=15) Recheck Cond: (special_features @&gt; '{"Behind The Scenes"}'::text[]) -&gt; Bitmap Index Scan on idx_film2 (cost=0.00..8.04 rows=5 width=0) Index Cond: (special_features @&gt; '{"Behind The Scenes"}'::text[]) (4 rows)</span></span></code> </pre> <br>  GIN-index supports the comparison of individual values ‚Äã‚Äãwith indexed composite values, as a result, the cost of the query plan will be more than doubled. <br><br><h3>  We get rid of duplication of indexes </h3><br>  Indices accumulate over time, and sometimes a new index may contain the same definition as one of the previous ones.  You can use the <code>pg_indexes</code> catalog view to <code>pg_indexes</code> human-readable SQL definitions of indexes.  You can also easily find the same definitions: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_agg(indexname) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">indexes</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(indexdef, indexname, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> defn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_indexes <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> defn <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; And here's the result when run on the stock pagila database: pagila=<span class="hljs-comment"><span class="hljs-comment"># SELECT array_agg(indexname) AS indexes, replace(indexdef, indexname, '') AS defn pagila-# FROM pg_indexes pagila-# GROUP BY defn pagila-# HAVING count(*) &gt; 1; indexes | defn ------------------------------------------------------------------------+------------------------------------------------------------------ {payment_p2017_01_customer_id_idx,idx_fk_payment_p2017_01_customer_id} | CREATE INDEX ON public.payment_p2017_01 USING btree (customer_id {payment_p2017_02_customer_id_idx,idx_fk_payment_p2017_02_customer_id} | CREATE INDEX ON public.payment_p2017_02 USING btree (customer_id {payment_p2017_03_customer_id_idx,idx_fk_payment_p2017_03_customer_id} | CREATE INDEX ON public.payment_p2017_03 USING btree (customer_id {idx_fk_payment_p2017_04_customer_id,payment_p2017_04_customer_id_idx} | CREATE INDEX ON public.payment_p2017_04 USING btree (customer_id {payment_p2017_05_customer_id_idx,idx_fk_payment_p2017_05_customer_id} | CREATE INDEX ON public.payment_p2017_05 USING btree (customer_id {idx_fk_payment_p2017_06_customer_id,payment_p2017_06_customer_id_idx} | CREATE INDEX ON public.payment_p2017_06 USING btree (customer_id (6 rows)</span></span></code> </pre><br><h3>  Superset Indexes </h3><br>  It may happen that you have a lot of indexes, one of which indexes a superset of columns that index other indexes.  This may or may not be desirable - a superset can only lead to scanning by index, which is good, but it may take up too much space, or the query that this superset was intended to optimize is no longer used. <br><br>  If you need to automate the definition of such indices, then you can start with <a href="https://www.postgresql.org/docs/current/catalog-pg-index.html">pg_index</a> from the <code>pg_catalog</code> table. <br><br><h3>  Unused indexes </h3><br>  As applications that use databases evolve, so are the queries they use.  The indexes added earlier may no longer be used by any query.  Each time the index is scanned, it is marked by the statistics manager, and in the <code>pg_stat_user_indexes</code> system catalog <code>pg_stat_user_indexes</code> you can see the <code>idx_scan</code> value, which is a cumulative counter.  Tracking this value over a period of time (say, a month) will give a good idea of ‚Äã‚Äãwhich indexes are not used and can be deleted. <br><br>  Here is a request to get current counters for scanning all indexes in the <code>'public'</code> scheme: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname, indexrelname, idx_scan <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_catalog.pg_stat_user_indexes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> schemaname = <span class="hljs-string"><span class="hljs-string">'public'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">output</span></span> <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> this: pagila=<span class="hljs-comment"><span class="hljs-comment"># SELECT relname, indexrelname, idx_scan pagila-# FROM pg_catalog.pg_stat_user_indexes pagila-# WHERE schemaname = 'public' pagila-# LIMIT 10; relname | indexrelname | idx_scan ---------------+--------------------+---------- customer | customer_pkey | 32093 actor | actor_pkey | 5462 address | address_pkey | 660 category | category_pkey | 1000 city | city_pkey | 609 country | country_pkey | 604 film_actor | film_actor_pkey | 0 film_category | film_category_pkey | 0 film | film_pkey | 11043 inventory | inventory_pkey | 16048 (10 rows)</span></span></code> </pre> <br><h3>  Rebuilding indexes with fewer locks </h3><br>  Often, indexes have to be re-created, for example, when they swell in size, and re-creation can speed up scanning.  Also, indexes may be damaged.  Changing the parameters of the index may also require its re-creation. <br><br><h3>  Enable parallel index creation </h3><br>  In PostgreSQL 11, the B-Tree index creation is competitive.  To speed up the creation process, several parallel working workers can be used.  However, make sure these configuration parameters are set correctly: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_maintenance_workers = <span class="hljs-number"><span class="hljs-number">16</span></span>;</code> </pre> <br>  Default values ‚Äã‚Äãare too small.  Ideally, these numbers should be increased along with the number of processor cores.  Read more in the <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html">documentation</a> . <br><br><h3>  Background index creation </h3><br>  You can create an index in the background using the <code>CONCURRENTLY</code> parameter of the <code>CREATE INDEX</code> command: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX CONCURRENTLY idx_address1 ON address(district); CREATE INDEX</span></span></code> </pre> <br><br>  This procedure for creating an index differs from the usual one in that it does not require locking the table, and therefore does not block the write operation.  On the other hand, it takes more time and consumes more resources. <br><br>  Postgres provides many flexible options for creating indexes and ways to solve any particular cases, and also provides ways to manage the database in case of an explosive growth of your application.  We hope that these tips will help you make queries fast, and the base is ready to scale. </div><p>Source: <a href="https://habr.com/ru/post/453046/">https://habr.com/ru/post/453046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453030/index.html">With the help of a 3D printer, it was possible to save the car that participated in the Grand Prix 1914</a></li>
<li><a href="../453032/index.html">We're playing adult-2 cars: how we became a telematics provider for car sharing and opened 5 offices around the world</a></li>
<li><a href="../453034/index.html">Father created a bionic prosthetic arm for his son with a 3D printer and X-Box</a></li>
<li><a href="../453038/index.html">Software Defined Radio - how does it work? Part 4</a></li>
<li><a href="../453044/index.html">The long-awaited step towards complexly structured documents (+ video)</a></li>
<li><a href="../453048/index.html">About beer through the eyes of a chemist. Part 3</a></li>
<li><a href="../453056/index.html">Prototyping a mobile game, where to start, and how to do it. Part 1</a></li>
<li><a href="../453058/index.html">AI learned how to create video from a single frame. Old paintings can now be made alive</a></li>
<li><a href="../45306/index.html">Picasa 3.0 - finally release!</a></li>
<li><a href="../453064/index.html">Harm for the good: the immune system of the lamprey in the fight against human brain cancer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>