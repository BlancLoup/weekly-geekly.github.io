<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hello, World! Deep immersion in terminals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was inspired to write this article by an article on the analysis of Sishny printf . However, there was a missed moment about which path the data tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hello, World! Deep immersion in terminals</h1><div class="post__text post__text-html js-mediator-article"><p> <a href="https://habr.com/ru/post/460257/"><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  I was inspired to write this article by <a href="https://habr.com/ru/post/438044">an article on the analysis of Sishny printf</a> .  However, there was a missed moment about which path the data travels after it enters the terminal device.  In this article I want to correct this defect and analyze the data path in the terminal.  We will also understand how Terminal differs from Shell, what Pseudoterminal is, how terminal emulators work and much more. </p><a name="habracut"></a><br><h2 id="osnovy">  The basics </h2><br><p>  Let's first understand what Terminal, Shell, Console are, what makes Terminal Emulator different from the usual Terminal and why it is so named.  There is already quite a lot of information about this, so you will not hear anything new here.  Almost all the information here was taken from the Internet; I will cite the links at the end of the article.  Who already knows what all these things mean, can safely skip this section. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>A terminal</strong> is a combination of a display and a keyboard, that is, a physical device.  Before the terminals became this particular combination, they were some kind of device called teleprinter (teletype, teletypewriter or TTY for short), that is, a combination of printer and keyboard.  Usually several terminals connected to the same computer.  In this way, it was possible for several users to work on the same computer, with each having their own session, independent of the others.  The terminal was named so because it was located at the end of the terminal cable (terminal end). </p><br><p>  This is <strong>Teletype</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="Teletype" width="430" height="370"><br><br><p>  And this is the <strong>Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  Console </h3><br><p>  <strong>Console (console)</strong> - a terminal that is connected directly to a computer.  The fact is that most of the terminals were connected implicitly, but at least one was connected directly to the computer.  The console was allowed to use a strictly defined circle of people, as it allowed to customize the computer. </p><br><hr><br><h3 id="shell">  Shell </h3><br><p>  If the previous two are physical devices, then this definition refers exclusively to software. </p><br><p>  <strong>Shell</strong> is the command line interpreter.  The main purpose is to run other programs.  There are a large number of different shells.  The most common is Bash (from the English. Bourne Again SHell, which, as <a href="https://ru.wikipedia.org/wiki/Bash">Wikipedia</a> suggests, is a pun for ‚ÄúBorn again‚Äù Shell, that is, ‚Äúrevived‚Äù Shell).  Other examples: Dash (lightweight Shell, available if you run the binary at / bin / sh), Zsh. </p><br><hr><br><p>  Of course, both terminals and consoles could not but find their reflection in modern times.  Therefore, we will look further at such things as <em>Terminal Emulator</em> and <em>Virtual Console</em> . </p><br><h3 id="terminal-emulator">  Terminal emulator </h3><br><p>  <strong>Terminal Emulator</strong> - the good old terminal emulator.  A terminal emulator is required for programs that cannot directly interact with the X Window System - Bash, Vim, and others. </p><br><p>  Let's first establish the duties of the terminal: </p><br><ol><li>  Transfer user input to computer </li><li>  Delivery of computer output to the display </li></ol><br><p>  Similarly, our Terminal Emulator does exactly the same thing: it delivers user input to a running program, and also displays the output of the program to the display.  In any case, the meaning is preserved - between the user and the running program, there is some layer responsible for input / output.  Terminal Terminal examples: gnome-terminal, xterm, konsole. </p><br><p>  <strong>Please do not confuse Shell and Terminal Emulator!</strong> <br>  Terminal Emulator is a GUI application, that is, a window in the X Windows System.  A shell is a command line interpreter, that is, just an executor of commands, it does not have a graphical shell.  If you say quite correctly, you <strong>do not run Bash</strong> , you <strong>run Terminal Emulator, which runs Bash inside</strong> .  Terminal Emulator and Bash are absolutely 2 different programs.  The first is responsible solely for I / O, the second - for processing commands. </p><br><p>  Further in the article, all references to the terminal will refer to the terminal emulator. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Virtual Console (Virtual Terminal) </h3><br><p>  Press Ctrl + Alt + FN, where N usually has values ‚Äã‚Äãfrom 1 to 6. What you have just seen is called Virtual Console (virtual console) or Virtual Terminal (virtual terminal).  Remember what I said earlier about terminals?  Many terminals were connected to one computer and each terminal was a separate session, independent of the others.  The Virtual Console repeats this idea: there may be several independent sessions inside your computer (however, computer resources are obviously shared). </p><br><p>  You can call this entity both Virtual Console and Virtual Terminal, since by definition, the console is a terminal connected directly to a computer, but all virtual terminals are in a sense connected directly to a computer. </p><br><hr><br><h3 id="tty-ustroystva">  Tty devices </h3><br><p>  Each terminal is assigned its own <em>TTY device</em> (terminal device), which provides console operation.  Although you will hardly find teletypes, the TTY abbreviation has reached our days. </p><br><p>  A TTY device consists of two fundamental components: </p><br><ol><li>  <strong>Device driver</strong>  He is responsible for delivering input from the keyboard to the program and for displaying the output of the program on the screen. </li><li>  <strong>TTY Line Discipline</strong> (Russian - line discipline).  Line discipline is the driver access interface, which, however, brings a lot of logic to the TTY device.  We can say that the discipline of the line proxies calls to the driver.  What is the responsibility of this component, we will find out in the course of the article. </li></ol><br><p>  TTY device structure: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Tty device structure"></p><br><p>  There are 3 types of TTY devices: </p><br><ol><li>  <em>Console device</em> - provides operation of the Virtual Console.  The input and output of this device is completely controlled by the kernel. </li><li>  <em>PTY device</em> (pseudo-terminal) - ensures the operation of the terminal in the window interface.  The input and output of this device is controlled by a terminal emulator that works in user space. </li><li>  <em>Serial device</em> - communicates directly with the iron.  It is usually not used directly, but exists as the lowest level in the organization of the architecture of the terminal device. </li></ol><br><p>  In this article we will talk about the second type of TTY devices - pseudo terminals. </p><br><hr><br><h2 id="tty-line-discipline">  TTY Line Discipline </h2><br><p>  We begin to consider the discipline of the line TTY devices. </p><br><p> The first important feature of the discipline line is that it is responsible for I / O processing.  This includes, for example, processing control characters (see <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D1%258F%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258B" title="Control characters">Control Characters</a> ) and output formatting.  For example, you enter any text, but suddenly you realize that you were mistaken in writing something and you want to erase it ‚Äî this is where the discipline of the line comes into play. </p><br><p>  Let us examine in detail what exactly happens when we work in Bash running in the terminal.  By default, the TTY device works in canonical mode with <em>echo enabled</em> .  Echo is the display of the characters you entered on the screen. </p><br><p><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'en', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script> When we enter, for example, the character <code>a</code> , this character is sent to the TTY device, but intercepted by the discipline line of the TTY device.  She reads the character in her internal buffer, sees that <code>echo</code> mode is on and displays the character on the screen.  At this time, nothing is yet available for reading in the program to which the terminal device is attached.  Let us press the <code>backspace</code> on the keyboard.  The symbol <code>^?</code>  again intercepts the line discipline, and the last one, realizing that the user wants to erase the last character entered, deletes the given character from its internal buffer and erases this character also from the screen.  Now, if we press Enter, the TTY Line Discipline will finally send everything that was written to the internal buffer of the discipline, including LF, to the reading buffer of the terminal device.  In this case, the characters CR and LF are displayed in order to move the cursor to a new line - this is the output formatting. </p><br><p>  This is how the canonical mode works - it transfers all the entered characters to the device only after pressing <code>Enter</code> , processes the control characters and formats the output. </p><br><h3 id="tty-line-editing">  Tty line editing </h3><br><p>  <strong>TTY Line Editing</strong> is the component that is responsible for processing input to the line discipline.  It should be said that <em>Line Editing</em> is a general concept and refers to input processing.  For example, Bash and Vim have their Line Editing. </p><br><p>  We can control the discipline settings of the line of the current TTY device using the <strong>stty</strong> program.  Let's experiment a little. </p><br><p>  Open Bash or any other Shell and enter: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Now try typing something - and you won't see your input (don't worry, you can still transfer input to the program).  You have just turned off the echo - that is, the display of the entered characters on the screen.  Now enter: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Try typing something.  You see how the output is broken.  But for more effect, let's go into Dash - enter <code>/bin/sh</code> .  Now try typing special characters ( <code>Ctrl</code> key + any character on the keyboard) or simply press <code>Enter</code> .  You wonder - what are these strange characters on the screen?  The fact is that we, having entered the simplest Shell, besides Line Editing, the discipline itself also turned off the Line Editing Bash, and now we can see the effect of the inclusion of the <em>raw</em> line discipline mode.  This mode does not process input at all and does not format output.  Why raw mode is needed?  For example, for <em>Vim</em> : it opens into the entire terminal window and performs the input processing itself, at least so that the special symbols of the discipline of the line do not overlap with the special symbols of Vim itself. </p><br><p>  For even more understanding, let's consider customizing control characters.  The <code>stty &lt;control-character&gt; &lt;string&gt;</code> command <code>stty &lt;control-character&gt; &lt;string&gt;</code> will help us with this. <br>  Enter in bash: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Now the <code>erase</code> control character will be assigned to the <code>0</code> character.  The <code>backspace</code> button usually matters <code>^?</code>  , but now this special character will be transferred to the PTS device read buffer literally - try it yourself.  Now you can erase characters using the <code>0</code> button on the keyboard, because you yourself asked the tty line discipline to recognize the entered character as the <code>erase</code> control character.  You can <code>stty erase ^\?</code> setting using the command <code>stty erase ^\?</code>  or just closing the terminal, because we only influenced the current tty device. </p><br><p>  More information can be found in <a href="https://www.freebsd.org/cgi/man.cgi%3Fquery%3Dstty%26sektion%3D1%26apropos%3D0%26manpath%3DFreeBSD%2B12.0-RELEASE%2Band%2BPorts" title="man stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  Terminal Emulator and Pseudoterminal </h2><br><p>  Every time we open a new terminal on the X Window System, the GNOME Terminal Server spawns a new process and starts the program that is selected by default.  Usually, this is some kind of Shell (for example, Bash). </p><br><p>  Communication with the running program occurs through the so-called <strong>Pseudoterminal</strong> (pseudo-terminal, PTY).  The pseudo-terminal itself exists in the kernel, but it receives input from user space ‚Äî from a terminal emulator. </p><br><p>  A pseudo-terminal consists of the following two <em>virtual TTY devices</em> : <br>  1) <strong>PTY master (PTM)</strong> - the leading part of the pseudo-terminal.  The GNOME Terminal Server is used to transfer keyboard input to a program running inside the terminal, as well as to read the output of the program and display the output to the display.  GNOME Terminal Server, in turn, communicates with the X Window System over the X protocol. <br>  2) <strong>PTY slave (PTS)</strong> - the pseudo-terminal <strong>slave</strong> .  Used by a program running inside the terminal to read input from the keyboard and display the output to the screen.  At least, the program itself thinks so (I will explain what this means, a little further). </p><br><p>  Any data recorded in the PTS device is the input of the PTM device, that is, it becomes available for reading on the PTM device.  And vice versa: any data recorded in the PTM device is the PTS input of the device.  This is how the GNOME Terminal Server and the program running inside the terminal communicate.  Each PTM device is associated with its own PTS device. </p><br><p>  The process of launching a new terminal looks like this: <br>  1) GNOME Terminal Server creates the master and slave devices by calling the open () function on the special device <strong>/ dev / ptmx</strong> .  The open () call returns the file descriptor of the created PTM device ‚Äî <em>master_fd</em> . <br>  2) GNOME Terminal Server creates a new process by calling the <code>fork()</code> function.  This process will be the new terminal. <br>  3) In the PTS terminal, the device opens on file descriptors 0, 1, 2 (stdin, stdout and stderr, respectively).  Now the standard I / O streams of the terminal lead to this device. <br>  4) The terminal starts the desired program by calling the <code>exec()</code> function.  Usually, some kind of Shell is started (for example, Bash).  Any program subsequently launched from Bash will have the same file descriptors as Bash itself, that is, the program streams will be sent to the PTS device. </p><br><p>  You can see for yourself where the standard output streams of the terminal are directed using the <code>ls -la /proc/self/fd</code> : <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  The PTS device is located along the path <strong>/ dev / pts / N</strong> , and we are absolutely not interested in the path to the PTM device.  The fact is that the GNOME Terminal Server already has a file descriptor for an open PTM device and does not need a path to it, however in the child process we have to open the PTS device on standard output streams by calling the <code>open()</code> function, which requires a file path. </p><br><p>  Remember, I said that a program using a PTS device only thinks that it communicates directly with the terminal?  The fact is that the PTS is also a <em>terminal device</em> (TTY device), but the difference between the PTS device and the actual TTY device is that the PTS device receives input not from the keyboard, but from the master device, and the output goes not to the display, but to master device  That is why the pseudo-terminal is so named - the pseudo-terminal only imitates (again?) The terminal.  The difference between a terminal emulator and a pseudo-terminal is that a terminal emulator is only a graphical program that allows you to run the terminal directly inside the window interface, but this feature is implemented using a pseudo-terminal. </p><br><p>  The fact that the <em>PTS device is a TTY device</em> is very important.  That's why: </p><br><ol><li>  The program to which the terminal device is attached, all the capabilities of a conventional terminal are available.  For example: disable echo, disable / enable canonical view. </li><li>  The program, knowing that a terminal device is attached to it (it says that the program has a controlling terminal), can work interactively and ask the user for input.  For example, ask for username and password. </li><li>  There also exists a TTY Line Discipline, so we have the opportunity to process control characters before they reach the program, as well as format the output of the program. </li></ol><br><p>  A PTM device is also a TTY device, but it does not play any role, since it is not used as a controlling terminal.  Moreover, the discipline of the PTM line of the device is set to raw mode, so processing is not performed when transferring data from PTS to PTM device.  However, the <code>read()</code> and <code>write()</code> calls from user space are still first served by discipline lines on both devices.  This moment will play an even greater role, as we shall see later. </p><br><p>  The process of communication between GNOME Terminal Server and the program running inside the terminal is as follows: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="GNOME Terminal Server"></p><br><p>  It is necessary to consider in more detail the role played by the discipline of the line when communicating between the two parts of the pseudo-terminal.  Here, the line discipline is responsible for processing data <em>from PTM to a PTS device</em> , as well as for delivering data from one part of the pseudo-terminal to another.  When we are in the PTS device driver, we use the discipline line of the PTM device, and vice versa. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Virtual devices </h2><br><p>  You might have thought that you could open a file along the path <em>/ dev / pts / N</em> and write or read data from it, as from a regular text file?  Yes, all devices in Unix-like systems are files thanks to the fundamental principle of Unix, which says that everything is a file.  However, no special device files (device file) are text files.  Such devices are called <strong>virtual devices</strong> (virtual device) - that is, they exist exclusively in memory, and not on disk. </p><br><p>  You should not try to open these files as ordinary text files.  However, you can use these devices through the <code>write()</code> and <code>read()</code> operations, the call of which will serve the device driver.  Let's try to do it. </p><br><p>  Open two terminal windows and type <code>tty</code> in each.  This command will show which TTY device is servicing the current active terminal.  Now type <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> in the first terminal window, where N is the PTS device index of the second window, switch to the second window and you will see your input from the first window.  Now you have recorded the data in the PTS device of the second window <em>as if the program running in that terminal did it</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Pseudo terminal device </h2><br><p>  We are getting closer to the final part of the article, but before that we take a look under the hood of Linux - consider a pseudo-terminal device at the kernel level.  There will be a lot of code, but I will try to explain each block of code as detailed as possible, reduce unimportant details and go consistently. </p><br><p>  Before we start we introduce the so-called "basket of components".  As we move along the core, we will add more and more components to it and find a connection between them.  I hope this helps to understand the pseudo-terminal device even better.  Let's get started </p><br><p>  When Linux starts up, it loads the necessary device drivers.  Such a driver is also available for our pseudo-terminal.  Its registration begins with a call to this function: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  For all modern systems, the function <code>unix98_pty_init()</code> will be called: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Here we are interested in 3 things: </p><br><ol><li>  Call <code>tty_set_operatons</code> for the pty master driver and pty slave devices. </li><li>  The <code>ptmx_open</code> function, which is responsible for creating both parts of the pseudo-terminal when opening the special device <em>/ dev / ptmx</em> .  Important: / dev / ptmx is not a PTM device, but only an interface for creating a new pseudo-terminal. </li><li>  Register driver PTM and PTS devices. </li></ol><br><p>  Let's go in order: </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  The <strong>tty_set_operations ()</strong> function only sets the function table for the current driver: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  The <strong>tty_operations</strong> structure is a function table that is used to access the functions of the TTY device driver. </p><br><p>  I will highlight the most important thing in the <code>pty_unix98_ops</code> and <code>ptm_unix98_ops</code> , which are the table of functions for the corresponding parts of the pseudo-terminal: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Here you can see the pty_write function already familiar with the article about Sishnoy printf - we will return to it a little later. </p><br><p>  Let's add this structure to our component basket: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  As you can see, the basic methods of both drivers do not differ at all.  By the way, notice that there is no function for the read () operation - there is nothing like <code>pty_read()</code> .  The fact is that reading will be served exclusively by the discipline of the line.  Thus, we learn about the second important feature of the line discipline - reading data from the TTY device. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  Now let's go to <strong>ptmx_open ()</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  We are interested in the <code>tty_init_dev()</code> function, where the first argument is the device's PTM driver, and the second is the device index.  Here we leave the area of ‚Äã‚Äãresponsibility of the PTY driver and go to the file that is only responsible for common TTY devices and does not know anything about our pseudo-terminal. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  First we analyze the <code>alloc_tty_struct()</code> function: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  The only thing that interests us here is the <code>tty_ldisc_init()</code> function: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Which calls <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  So, we have considered the call of the function <code>alloc_tty_struct()</code> , which creates the structure <em>tty_struct</em> together with the discipline of the line - the structure <em>tty_ldisc</em> .  Both structures have links to each other.  Let's take a closer look at these structures. </p><br><ul><li>  <strong>tty_struct</strong> is a structure for accessing the device's TTY driver and some other fields.  It looks like this: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> is a structure for disciplining a TTY device line.  It consists of only two fields and is as follows: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  It seems to be nothing complicated?  Let's add all the structures considered up to this point in our basket and link them in the same way as they are connected in the code: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt="Tty_struct structure" title="Tty_struct structure"></p><br><p>  But we created a tty_struct just for a PTM device.  And what about the PTS device?  To do this, let‚Äôs return to the <code>tty_init_dev()</code> function and recall what the <code>tty_driver_install_tty()</code> function is waiting for us next: </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  The comment tells us that this method is responsible for creating various additional structures.  The PTS device will be our additional structure.  I admit, it was extremely surprising for me, because it‚Äôs a hell of a whole device, and not just some kind of additional structure!  But we all understand that all devices are just some kind of structure, so go ahead.  Well, what is <em>driver-&gt; ops-&gt; install</em> ?  To do this, look at the table of functions for the PTM driver again: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  And we <code>pty_unix98_install()</code> understand that we are interested in the <code>pty_unix98_install()</code> function: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Which calls the <code>pty_common_install()</code> function: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  ‚Äî  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p>  Is done.      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title="PTY structure"></p><br><hr><br><h2 id="hello-world"> Hello, World! </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> ‚Äî       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> ‚Äî   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer ‚Äî       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   ‚Äî        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?    .      ,     ,      ‚Äî        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      ‚Äî    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        ‚Äî         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    ‚Äî  <code>n_tty_read()</code> .      ,  ,          ‚Äî <em>read_buf</em> ‚Äî   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  ‚Äî     ,   ! </p><br><h3 id="istochniki">  </h3><br><ul><li> Linux man pages </li><li> <a href="https://unix.stackexchange.com/q/96694/346664">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://unix.stackexchange.com/q/93531/346664">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://unix.stackexchange.com/q/117981/346664">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://askubuntu.com/q/506510">https://askubuntu.com/q/506510</a> </li><li> <a href="http://www.linusakesson.net/programming/tty/">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://habr.com/ru/company/neobit/blog/330764/">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460257/">https://habr.com/ru/post/460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460249/index.html">The solution to the task with pwnable.kr 07 - input. Understanding pwntools</a></li>
<li><a href="../46025/index.html">Revival of the legend: we put the OS on Libretto 50 CT</a></li>
<li><a href="../460251/index.html">Artificial Stupidity: the bot that did not help me</a></li>
<li><a href="../460253/index.html">10 reasons to make your skill for voice assistant</a></li>
<li><a href="../460255/index.html">Backdoor on Node.js: why, why, and how it works</a></li>
<li><a href="../46026/index.html">XNA + C # vs DirectX + C ++ v OpenGL. What's better? And why?</a></li>
<li><a href="../460261/index.html">Amazon: 25 years of success in e-commerce</a></li>
<li><a href="../460263/index.html">Making a really smart search: step by step guide</a></li>
<li><a href="../460265/index.html">Creating an Xcode Project Template</a></li>
<li><a href="../460273/index.html">Authorization in Apple Pay for the smallest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>