<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding how disk space is used in Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prim Trans. : The author of the original article, the Spanish Open Source-enthusiast nachoparker , who develops the NextCloudPlus project (formerly kn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding how disk space is used in Linux</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Prim Trans.</b></i>  <i>: The author of the original article, the Spanish Open Source-enthusiast <a href="https://github.com/nachoparker">nachoparker</a> , who develops the <a href="https://ownyourbits.com/nextcloudplus/">NextCloudPlus</a> project (formerly known as NextCloudPi), shares his knowledge of the Linux disk subsystem, making important clarifications in answers to seemingly simple questions ...</i> <br><br>  How much space does this file take on the hard disk?  How much free space do I have?  How many more files can I fit into the remaining space? <br><br><img src="https://habrastorage.org/webt/f9/xs/if/f9xsifhdxviuaqem-dcqaupu3t0.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The answers to these questions seem obvious.  We all have an instinctive understanding of how file systems work, and often we imagine storing files on a disk like filling a basket with apples. <br><br>  However, in modern Linux systems, such intuition can be misleading.  Let's see why. <a name="habracut"></a><br><br><h2>  file size </h2><br>  What is file size?  The answer seems to be simple: a collection of all the bytes of its contents, from the beginning to the end of the file. <br><br>  Often, the entire contents of the file is presented as located byte by byte: <br><br><img src="https://habrastorage.org/webt/1l/wu/qf/1lwuqfcwjbep8e9evu4j32yc4mi.png"><br><br>  We also perceive the concept of <i>file size</i> .  To find out, run <code>ls -l file.c</code> or the <a href="https://linux.die.net/man/1/stat"><code>stat</code></a> command (ie, <code>stat file.c</code> ), which makes the <a href="https://en.wikipedia.org/wiki/Stat_(system_call)"><code>stat()</code></a> system call. <br><br>  In the Linux kernel, the <i>inode</i> memory structure is a file.  And the metadata that we access with the <code>stat</code> command is in the inode. <br><br>  Fragment <code>include/linux/fs.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* excluded content */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> i_size; <span class="hljs-comment"><span class="hljs-comment">/* file size */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i_atime</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* access time */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i_mtime</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* modification time */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i_ctime</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* change time */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> i_bytes; <span class="hljs-comment"><span class="hljs-comment">/* bytes used (for quota) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_blkbits; <span class="hljs-comment"><span class="hljs-comment">/* block size = 1 &lt;&lt; i_blkbits */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">blkcnt_t</span></span> i_blocks; <span class="hljs-comment"><span class="hljs-comment">/* number of blocks used */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* excluded content */</span></span> }</code> </pre> <br>  Here you can see familiar attributes, such as access time and modifications, as well as <code>i_size</code> ‚Äî this is <i>the file size</i> , as defined above. <br><br>  Thinking in terms <i>of file size is</i> intuitive, but we are more interested in how space is <i>actually</i> used. <br><br><h2>  Blocks and block size </h2><br>  For internal file storage, the file system splits the vault into <i>blocks</i> .  The traditional block size was 512 bytes, but the more current value is 4 kilobytes.  In general, the choice of this value is guided by the supported page size on typical MMU equipment <i>(memory management unit, ‚Äúmemory management <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BB%25D0%25BE%25D0%25BA_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C%25D1%258E">device</a> ‚Äù - <b>approx. Transl.</b> )</i> . <br><br>  The file system inserts the file cut into <i>chunks</i> into these blocks and keeps track of them in the metadata.  Ideally, it looks like this: <br><br><img src="https://habrastorage.org/webt/0i/m9/1i/0im91i0twl3mzxh-kkrbyx8yf40.png"><br><br>  ... but in reality, files are constantly being created, resized, deleted, so the real picture is this: <br><br><img src="https://habrastorage.org/webt/38/qa/p4/38qap4l3htkdfvj7drxtj35tk8u.png"><br><br>  This is called <i>external fragmentation</i> and usually results in a drop in performance.  The reason - the rotating head of the hard disk has to move from place to place to collect all the fragments, and this is a slow operation.  The solution to this problem is the classic defragmentation tools. <br><br>  What happens to files smaller than 4 KB?  What happens to the contents of the last block after the file has been cut into pieces?  Unused space will naturally occur - this is called <i>internal fragmentation</i> .  Obviously, this side effect is undesirable and can lead to the fact that a lot of free space will not be used, especially if we have a large number of very small files. <br><br>  So, the <i>actual disk usage of the</i> file can be seen with <code>stat</code> , <code>ls -ls file.c</code> or <code>du file.c</code>  For example, the contents of a 1-byte file still occupies 4 KB of disk space: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; file.c $ ls -l file.c -rw-r--r-- 1 nacho nacho 1 Apr 30 20:42 file.c $ ls -ls file.c 4 -rw-r--r-- 1 nacho nacho 1 Apr 30 20:42 file.c $ du file.c 4 file.c $ dutree file.c [ file.c 1 B ] $ dutree -u file.c [ file.c 4.00 KiB ] $ <span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> file.c File: file.c Size: 1 Blocks: 8 IO Block: 4096 regular file Device: 2fh/47d Inode: 2185244 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 1000/ nacho) Gid: ( 1000/ nacho) Access: 2018-04-30 20:41:58.002124411 +0200 Modify: 2018-04-30 20:42:24.835458383 +0200 Change: 2018-04-30 20:42:24.835458383 +0200 Birth: -</code> </pre> <br>  Thus, we look at two values: the file size and the blocks used.  We are accustomed to think in terms of the former, but we must - in terms of the latter. <br><br><h2>  File system specific features </h2><br>  In addition to the actual contents of the file, the kernel also needs to store all kinds of metadata.  We have already seen the inode metadata, but there are other data with which every UNIX user is familiar: <i>access rights</i> , <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B4%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258F">owner</a> , <i>uid</i> , <i>gid</i> , flags, <a href="https://ru.wikipedia.org/wiki/ACL">ACL</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* excluded content */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fown_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f_owner</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">umode_t</span></span> i_mode; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> i_opflags; <span class="hljs-keyword"><span class="hljs-keyword">kuid_t</span></span> i_uid; <span class="hljs-keyword"><span class="hljs-keyword">kgid_t</span></span> i_gid; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_flags; <span class="hljs-comment"><span class="hljs-comment">/* excluded content */</span></span> }</code> </pre> <br>  Finally, there are other structures, such as a <i>superblock</i> with the representation of the file system itself, <i><a href="">vfsmount</a></i> with the representation of a mount point, as well as information about redundancy, named spaces, and so on.  As we will see later, some of these metadata may also occupy a significant place. <br><br><h3>  Block allocation metadata </h3><br>  This data is highly dependent on the file system used - in each of them the block-to-file mapping is implemented in its own way.  The traditional ext2 approach is an <code>i_block</code> table with direct and indirect blocks <i>( <a href="https://en.wikipedia.org/wiki/Inode_pointer_structure">direct / indirect blocks</a> )</i> . <br><br><img src="https://habrastorage.org/webt/hf/q9/cq/hfq9cqvxfseh7d-effydfiostxc.png"><br><br>  The same table can be seen in the memory structure (fragment from <code>fs/ext2/ext2.h</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Structure of an inode on the disk */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ext2_inode</span></span></span><span class="hljs-class"> {</span></span> __le16 i_mode; <span class="hljs-comment"><span class="hljs-comment">/* File mode */</span></span> __le16 i_uid; <span class="hljs-comment"><span class="hljs-comment">/* Low 16 bits of Owner Uid */</span></span> __le32 i_size; <span class="hljs-comment"><span class="hljs-comment">/* Size in bytes */</span></span> __le32 i_atime; <span class="hljs-comment"><span class="hljs-comment">/* Access time */</span></span> __le32 i_ctime; <span class="hljs-comment"><span class="hljs-comment">/* Creation time */</span></span> __le32 i_mtime; <span class="hljs-comment"><span class="hljs-comment">/* Modification time */</span></span> __le32 i_dtime; <span class="hljs-comment"><span class="hljs-comment">/* Deletion Time */</span></span> __le16 i_gid; <span class="hljs-comment"><span class="hljs-comment">/* Low 16 bits of Group Id */</span></span> __le16 i_links_count; <span class="hljs-comment"><span class="hljs-comment">/* Links count */</span></span> __le32 i_blocks; <span class="hljs-comment"><span class="hljs-comment">/* Blocks count */</span></span> __le32 i_flags; <span class="hljs-comment"><span class="hljs-comment">/* File flags */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* excluded content */</span></span> __le32 i_block[EXT2_N_BLOCKS];<span class="hljs-comment"><span class="hljs-comment">/* Pointers to blocks */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* excluded content */</span></span> }</code> </pre> <br>  For large files, this scheme leads to large overheads, since a single (large) file requires matching thousands of blocks.  In addition, there is a limit on file size: using this method, the 32-bit ext3 file system supports files no more than 8 TB.  The ext3 developers <a href="http://lkml.iu.edu/hypermail/linux/kernel/0606.1/0268.html">saved the situation by</a> supporting 48 bits and adding <i><a href="https://en.wikipedia.org/wiki/Extent_(file_systems)">extents</a></i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ext3_extent</span></span></span><span class="hljs-class"> {</span></span> __le32 ee_block; <span class="hljs-comment"><span class="hljs-comment">/* first logical block extent covers */</span></span> __le16 ee_len; <span class="hljs-comment"><span class="hljs-comment">/* number of blocks covered by extent */</span></span> __le16 ee_start_hi; <span class="hljs-comment"><span class="hljs-comment">/* high 16 bits of physical block */</span></span> __le32 ee_start; <span class="hljs-comment"><span class="hljs-comment">/* low 32 bits of physical block */</span></span> };</code> </pre> <br>  The idea is really simple: to occupy the neighboring blocks on the disk and simply declare where the extent begins and what is its size.  Thus, we can allocate large groups of blocks to a file, minimizing the amount of metadata and at the same time using faster sequential access. <br><br>  Note to the curious: ext4 provides backward compatibility, that is, it supports both methods: <i>indirect (indirect)</i> and <i>extents</i> .  You can see how space is allocated by the example of a write operation.  Writing does not go directly to the repository - for performance reasons, the data first gets into the file cache.  After that, at a certain point, the cache writes information to the permanent storage. <br><br>  The file system cache is represented by the <a href=""><code>address_space</code></a> structure, in which the <a href=""><i>writepages</i></a> operation is <a href=""><i>invoked</i></a> .  The whole sequence looks like this: <br><br><pre> <code class="hljs erlang-repl">(cache writeback) ext4_aops-&gt; ext4_writepages() -&gt; ... -&gt; ext4_map_blocks()</code> </pre> <br>  ... where <code>ext4_map_blocks()</code> will call the <code>ext4_ext_map_blocks()</code> or <code>ext4_ind_map_blocks()</code> function depending on whether extents are being used.  If you look at the first in <code><a href="">extents.c</a></code> , you can see the references to the <i>holes</i> , which will be discussed below. <br><br><h3>  Checksums </h3><br>  The latest generation of file systems also store <i>checksums</i> for data blocks to avoid <a href="https://en.wikipedia.org/wiki/Data_corruption">imperceptible data corruption</a> .  This feature allows you to <a href="https://en.wikipedia.org/wiki/Error_detection_and_correction">detect and correct</a> random errors and, of course, leads to additional overhead in using the disk in proportion to the file size. <br><br>  More modern systems like BTRFS and ZFS support checksums for data, while older systems such as ext4 have checksums for metadata. <br><br><h3>  Journaling </h3><br>  The <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling</a> capabilities for ext2 appeared in ext3.  The log is a cyclic log that records processed transactions in order to improve the resilience to power failures.  By default, it applies <a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">only to metadata</a> , but you can also activate it for data using the <code>data=journal</code> option, which will affect performance. <br><br>  This is a special hidden file, usually with an inode number of 8 and a size of 128 MB, which can be found in the official documentation: <br><br><blockquote>  The log presented in the ext3 file system is used in ext4 to protect the filesystem from damage in the event of system failures.  A small sequential fragment of the disk (the default is 128 MB) is reserved inside the file system as a place for dropping "important" disk write operations as quickly as possible.  When a transaction with important data is completely written to disk and flushed from <i>disk (disk write cache)</i> , the data record is also recorded in the log.  Later, the log code records transactions in their final positions on the disk (an operation can lead to a long search or a large number of read-delete-erase operations) before the record of this data is erased.  In the event of a system failure during the second slow write operation, the log allows you to reproduce all operations up to the last record, ensuring that everything written to disk through the journal is atomic.  The result is a guarantee that the file system will not get stuck halfway through the metadata update. </blockquote><br><h3>  "Tail packaging" </h3><br>  The ability of tail packing, also called <i>block sub-allocation</i> , allows file systems to use the empty space at the end of the last block (‚Äútails‚Äù) and distribute it among different files, effectively packing the ‚Äútails‚Äù into a single block. <br><br><img src="https://habrastorage.org/webt/qt/zl/-b/qtzl-bzmpogzrcc3jeymsyfoglq.png"><br><br>  It is great to have the ability to save a lot of space, especially if you have a large number of small files ... However, it leads to the fact that existing tools do not accurately report the used space.  Because with it, we cannot simply add all the occupied blocks of all files to get real data on disk usage.  This feature is supported by the BTRFS and ReiserFS file systems. <br><br><h3>  Sparse files </h3><br>  Most modern file systems support <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B5%25D0%25B6%25D1%2591%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2584%25D0%25B0%25D0%25B9%25D0%25BB">sparse files</a> .  Such files may have <i>holes</i> that are not actually written to disk (do not occupy disk space).  This time the actual <i>file size</i> will be larger than the blocks used. <br><br><img src="https://habrastorage.org/webt/8b/um/h0/8bumh0tgc6ry494wzcteg-bd6vm.png"><br><br>  Such a feature can be very useful, for example, for quickly generating large files or for providing free space to a virtual hard disk of a virtual machine upon request. <br><br>  To slowly create a 10-gigabyte file that takes up about 10 GB of disk space, you can run: <br><br><pre> <code class="bash hljs">$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=file bs=2M count=5120</code> </pre> <br>  To create the same large file instantly, you just need to write the last byte ... or even do: <br><br><pre> <code class="bash hljs">$ dd of=file-sparse bs=2M seek=5120 count=0</code> </pre> <br>  Or use the <code>truncate</code> command: <br><br><pre> <code class="bash hljs">$ truncate -s 10G</code> </pre> <br>  The disk space allocated to the file can be changed with the <code><a href="http://man7.org/linux/man-pages/man1/fallocate.1.html">fallocate</a></code> command, which makes the <code><a href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate()</a></code> system call.  More advanced operations are available with this call - for example: <br><br><ul><li>  Preallocate space for the file by inserting zeroes.  This operation increases both disk usage and file size. </li><li>  Free up space.  The operation will create a hole in the file, making it sparse and reducing the use of space without affecting the file size. </li><li>  Optimize space by reducing file size and disk usage. </li><li>  Increase the file space by inserting a hole at its end.  File size increases, and disk usage does not change. </li><li>  Zero holes.  Holes will not be written to disk extents, which will be read as zeros, without affecting disk space and its use. </li></ul><br>  For example, you can create holes in a file, turning it into sparse, like this: <br><br><pre> <code class="bash hljs">$ fallocate -d file</code> </pre> <br>  The <code>cp</code> command supports sparse files.  Using simple heuristics, it tries to determine if the source file is sparse: if so, the resulting file will also be sparse.  You can copy a non-thinned file into a sparse one like this: <br><br><pre> <code class="bash hljs">$ cp --sparse=always file file_sparse</code> </pre> <br>  ... and the reverse action (to make a "dense" copy of a sparse file) looks like this: <br><br><pre> <code class="bash hljs">$ cp --sparse=never file_sparse file</code> </pre> <br>  Thus, if you like working with sparse files, you can add the following alias to your terminal environment ( <code>~/.zshrc</code> or <code>~/.bashrc</code> ): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp --sparse=always'</span></span></code> </pre> <br>  When processes read bytes in sections of <i>holes, the</i> file system provides them with pages with zeros.  For example, you can see what happens when a file cache reads from a file system in the region of holes in ext4.  In this case, the sequence in <code><a href="">readpage.c</a></code> will look something like this: <br><br> <code>(cache read miss) ext4_aops-&gt; ext4_readpages() -&gt; ... -&gt; zero_user_segment()</code> <br> <br>  After that, the memory segment that the process is trying to access using the <code>read()</code> system call will get zeros directly from the fast memory. <br><br><h3>  COW file systems (copy-on-write) </h3><br>  The next (after the ext family) file system generation brought some very interesting features.  Perhaps the most attention among the features of file systems like ZFS and BTRFS deserves their COW (copy-on-write, ‚Äúcopy-on-write‚Äù). <br><br>  When we perform a <i>copy-on-write</i> operation or <i>cloning</i> , or a <i>copy of a reflink</i> , or a <i>shallow copy</i> , in fact, no duplication of quantities occurs.  It simply creates an annotation in the metadata for the new file, which refers to the same extents of the original file, and the extent itself is marked as <i>shared</i> .  At the same time, an illusion is created in user space that there are two separate files that can be separately modified.  When a process wants to write to a shared extent, the kernel will first create a copy of it and an annotation that this extent belongs to a single file (at least for the time being).  After that, the two files have more differences, but they can still share many extents.  In other words, extents in file systems with COW support can be divided between files, and the file system will create new extents only if necessary. <br><br><img src="https://habrastorage.org/webt/mf/tn/ft/mftnfteqfu7ytd0gqvupbscqcfi.png"><br><br>  As you can see, cloning is a very fast operation that does not require doubling of space, which is used in the case of a regular copy.  This technology is behind the ability to create instant snapshots in BTRFS and ZFS.  You can literally clone (or <a href="https://ownyourbits.com/2017/12/27/schedule-btrfs-snapshots-with-btrfs-snp/">snapshot</a> ) the entire root file system in less than a second.  Very useful, for example, before updating packages in case something breaks. <br><br>  BTRFS supports two methods for creating shallow copies.  The first is related to <i>subvolumes</i> and uses the <code>btrfs subvolume snapshot</code> .  The second is for individual files and uses <code>cp --reflink</code> .  Such an alias (again, for <code>~/.zshrc</code> or <code>~/.bashrc</code> ) can be useful if you want to make fast shallow copies by default: <br><br> <code>cp='cp --reflink=auto --sparse=always'</code> <br> <br>  The next step is if there are non-shallow copies or a file, or even files with duplicate extents, you can <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25B4%25D1%2583%25D0%25BF%25D0%25BB%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F"><i>de-duplicate</i></a> them so that they use (via reflink) common extents and free up space.  One of the tools for this is <a href="https://github.com/markfasheh/duperemove">duperemove</a> , but note that this naturally leads to higher file fragmentation. <br><br>  If we try now to figure out how disk space is used by files, everything will not be so simple.  Utilities like <code>du</code> or <a href="https://ownyourbits.com/2018/03/25/analize-disk-usage-with-dutree/">dutree</a> only consider the blocks used, not taking into account that some of them can be shared, so they will show more space than is actually used. <br><br>  Similarly, in the case of BTRFS, the <code>df</code> command should be avoided, since the space occupied by the BTRFS file system will be shown as free.  It is better to use <code>btrfs filesystem usage</code> : <br><br><pre> <code class="bash hljs">$ sudo btrfs filesystem usage /media/disk1 Overall: Device size: 2.64TiB Device allocated: 1.34TiB Device unallocated: 1.29TiB Device missing: 0.00B Used: 1.27TiB Free (estimated): 1.36TiB (min: 731.10GiB) Data ratio: 1.00 Metadata ratio: 2.00 Global reserve: 512.00MiB (used: 0.00B) Data,single: Size:1.33TiB, Used:1.26TiB /dev/sdb2 1.33TiB Metadata,DUP: Size:6.00GiB, Used:3.48GiB /dev/sdb2 12.00GiB System,DUP: Size:8.00MiB, Used:192.00KiB /dev/sdb2 16.00MiB Unallocated: /dev/sdb2 1.29TiB $ sudo btrfs filesystem usage /media/disk1 Overall: Device size: 2.64TiB Device allocated: 1.34TiB Device unallocated: 1.29TiB Device missing: 0.00B Used: 1.27TiB Free (estimated): 1.36TiB (min: 731.10GiB) Data ratio: 1.00 Metadata ratio: 2.00 Global reserve: 512.00MiB (used: 0.00B) Data,single: Size:1.33TiB, Used:1.26TiB /dev/sdb2 1.33TiB Metadata,DUP: Size:6.00GiB, Used:3.48GiB /dev/sdb2 12.00GiB System,DUP: Size:8.00MiB, Used:192.00KiB /dev/sdb2 16.00MiB Unallocated: /dev/sdb2 1.29TiB</code> </pre> <br>  Unfortunately, I don‚Äôt know simple ways to track the occupied space by individual files in file systems with COW.  At the sub-volume level, using utilities like <a href="https://ownyourbits.com/2017/12/06/check-disk-space-of-your-btrfs-snapshots-with-btrfs-du/">btrfs-du,</a> we can get a rough idea of ‚Äã‚Äãthe amount of data that is unique to snapshots and that are shared between snapshots. <br><br><h2>  Links </h2><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems">Comparison oa file systems, Wikipedia</a> ; </li><li>  <a href="https://lwn.net/Articles/187321/">Ext3 for large filesystems, LWN</a> ; </li><li>  <a href="https://ext4.wiki.kernel.org/index.php/Main_Page">Ext4 (and Ext2 / Ext3) Wiki</a> . </li></ul><br><h2>  PS from translator </h2><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habr.com/company/flant/blog/348324/">In defense of the swap [in Linux]: common misconceptions</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/348044/">Rook is a‚Äú self-service ‚Äùdata store for Kubernetes</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/company/flant/blog/329666/">We create a permanent repository with Ceph based provisioning in Kubernetes</a> .‚Äù </li></ul></div><p>Source: <a href="https://habr.com/ru/post/354802/">https://habr.com/ru/post/354802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354792/index.html">Affiliate program and API capabilities on hosting virtual servers VPS.house</a></li>
<li><a href="../354794/index.html">3 minutes to improve any meeting</a></li>
<li><a href="../354796/index.html">I made an API for screenshots of sites, and some guy started mining through it cryptocurrency</a></li>
<li><a href="../354798/index.html">Management Tantrum</a></li>
<li><a href="../354800/index.html">Feature perception filters from your Product Backlog</a></li>
<li><a href="../354804/index.html">If online stores were chairs</a></li>
<li><a href="../354806/index.html">How to make friends React and D3</a></li>
<li><a href="../354808/index.html">Static Analysis in the Video Game Industry: Top 10 Software Errors</a></li>
<li><a href="../354810/index.html">The point of testing is in the process, not in the remaining artifacts. Michael Bolton and Rapid Software Testing</a></li>
<li><a href="../354812/index.html">Fintech Digest: online banking security, 70% of bitcoins extracted, business will lose about $ 2 billion due to RKN blocking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>