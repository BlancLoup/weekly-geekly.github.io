<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming is the materialization of ideas.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The main thesis of this article: Software development should be viewed as the materialization of ideas through the transformation of mental models int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming is the materialization of ideas.</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/post/425321/"><img src="https://habrastorage.org/webt/ca/ha/pc/cahapcznbgjnjjfsimgdlkqovig.jpeg"></a> <br><br>  The main thesis of this article: Software development should be viewed as the materialization of ideas through the transformation of mental models into program code. <br>  The article describes the paradigm of materialization of ideas in software engineering (engl .: RPSE: Reification as Paradigm of Software Engineering). <br><a name="habracut"></a><br>  English version of the article: <a href="http://arxiv.org/abs/1810.01904">RPSE: Reification as Paradigm of Software Engineering</a> .  The abbreviation RPSE is used hereafter to refer to the described paradigm. <br><br><h2>  Basic definitions </h2><br>  Before proceeding to the discussion of the main theses of this article, it is necessary to agree on the meaning of the basic terms used in it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Software engineering </h3><br>  By <b>software engineering,</b> we mean the classic definition of Software Engineering discipline from the IEEE dictionary [1]: Software engineering is "The application of a systematic, disciplined, quantifiable approach to development, operation, and maintenance of software." <br><br><h3>  Paradigm </h3><br>  The term <b>paradigm</b> used in this article is based on the classic definition of the paradigm of Thomas Kuhn [2]: A paradigm is a set of problems, a set of concepts, generally accepted rules and laws, methods of solving problems in a certain field of science. <br><br><div class="spoiler">  <b class="spoiler_title">More on paradigms</b> <div class="spoiler_text">  In order to more accurately define the concept of paradigm used further, it is useful to quote two well-known quotes from the book of Kuhn: <br><blockquote>  By paradigms, I mean the recognized scientific achievements, which for a certain time give the scientific community a model of problem statement and their solutions ... <br><br>  Introducing this term, I meant that some generally accepted examples of actual practice of scientific research ‚Äî examples that include law, theory, their practical application and necessary equipment ‚Äî all together give us models from which specific traditions of scientific research arise. </blockquote><br>  The dualism of this concept is that, on the one hand, the paradigm is characterized through a community of experts recognizing it.  It is the specialists of a certain area who determine, create and develop its parts.  On the other hand, the recognition of a certain paradigm means for a specialist to join such a community. </div></div><br>  Thomas Kuhn considered scientific paradigms in his book.  However, very soon after the release of the first edition of the book, the utility of using this concept in technology and various areas of social life became apparent.  In this regard, numerous publications on paradigms and their change in the automotive industry, urban planning, treatment of certain diseases, etc. began to appear in the special and popular literature. <br><br>  Software engineering and especially its important component - programming, were no exception.  Currently there are many competing programming paradigms.  They are listed in a separate Wikipedia article [3], as well as such interesting reviews as [4]. <br><br><div class="spoiler">  <b class="spoiler_title">On the limitations of programming paradigms</b> <div class="spoiler_text">  The authors of the paradigms described in [3] and [4] concentrate on a narrow sub-field of software engineering, namely, writing programs in one or another programming language.  I think many professionals agree with the opinion that real software projects cannot be done within only one of these paradigms (for example, functional programming). <br><br>  The paradigm described in this article, on the contrary, is applicable to the most different subject areas and phases of software development. </div></div><br><div class="spoiler">  <b class="spoiler_title">On the limitations of software project management paradigms</b> <div class="spoiler_text">  Some authors, for example, in the review [5], call various approaches or models for organizing and conducting software projects as paradigms.  For example, waterfall models, V-model or Agile-model are compared.  It is unlikely that these approaches, unlike the programming paradigms mentioned above, can be called paradigms in the spirit of Kuhn‚Äôs definition because of their relative theoretical simplicity and the absence of a broad theoretical base. <br><br>  The paradigm proposed in this article also does not yet have its own developed theoretical base, however, its development paths are already visible today. </div></div><br><h3>  Materialization of ideas </h3><br>  The term <b>materialization of ideas</b> used in this article (engl: <i>reification</i> ) is an extension of the classical definition of reification in computer science: ‚Äú [6]. <br><br><div class="spoiler">  <b class="spoiler_title">More about the world of ideas, the world of things and materialization</b> <div class="spoiler_text">  The essence of the extension of the classical definition of the concept of materialization used in this article can be defined as follows. <br><br>  Already in the earliest extant philosophical paths, it was customary to oppose the Ideal (world of ideas) to the Material (world of things). <br><br>  We can feel the ideal at best (or think that we feel it).  An indicator of such a feeling of the Ideal may be a change in mood or train of thought after listening to a piece of music, a read fragment of a book, etc.  Of course, I mean the indirect impact, for example, of music, on our consciousness, and not on the primitive physiological subordination of the organism to the rumble of a rock concert or the rhythm of a disco. <br><br>  Attempts to formulate our sense of the Ideal as a rule do not lead to success. <br>  The great Russian poet Fedor Ivanovich Tyutchev remarkably said this: <br><blockquote>  How does the heart express itself? <br>  Other how to understand you? <br>  Will he understand what you live? <br>  The thought expressed is a lie ... [7] </blockquote>  Even practical ideas such as small repairs around the house or preparing a new variation of a familiar dish are difficult to formulate at first.  And only after thinking about or trying to explain to another, the idea gets more and more clear ‚Äúoutlines‚Äù. <br><br>  We now turn from the consideration of the concept of the Ideal to the consideration of the Material.  We can sense and register material objects around us, distinguish their properties qualitatively.  The properties of many objects can be objectively measured.  We can also objectively select hierarchies and other structures of material objects. </div></div><br>  To evaluate or measure (obtain quantitative characteristics) it is not necessary to have an item.  Enough to have his model.  Moreover, in many practically interesting situations, the model can be used without an object.  Models can be discussed with others.  Models can be negotiated.  Models can be standardized (formalized). <br><br>  In some areas of human activity, the standardization of models has gone so far that parts made on the basis of a standardized model (for example, a drawing) by different people or automata (for example, threaded bolts) from a technological point of view will be visually indistinguishable from each other. <br><br>  Being aware of the relative inaccuracy of the proposed definition, later in this article I will divide the world of the phenomena of our internal and external world <b>U</b> into two parts: <br><br>  <b>U = M + I</b> <br><br>  where the set <b>M</b> consists of their phenomena, which can be objectively recorded or measured (the material world) and <b>I</b> - everything else. <br><br>  Whether this formula applies to absolutely all phenomena of the world is an open philosophical question.  Further in this article we will narrow the scope of this formula to the world of phenomena from the world of software engineering. <br><br>  Or, formulated as a thesis: The whole set of phenomena related to software engineering can be divided into a subset of the ideal and a subset of the material.  At the same time, material phenomena are recorded or measured on the basis of their models. <br>  The process of creating or changing a software system ends in most cases with the creation of one or another code that is mapped into a physical process (real-world phenomenon) using a computer. <br><br>  This process begins with the emergence of some ideas about the future system in the heads of customers or developers.  These ideas and ideas will be referred to as the <b>mental model</b> . <br><br><div class="spoiler">  <b class="spoiler_title">About intermediate models</b> <div class="spoiler_text">  In simple systems or with simple additions / changes to large systems, the developer immediately writes code or configures the system based on his mental model.  However, in most cases, intermediate models of varying complexity and level of formalization are created - from a simple list of requirements to extensive formal models (for example, UML or BPMN models) </div></div><br><h2>  Materialization of ideas in the areas adjacent to Software Engineering </h2><br>  It is clear that the definition given above is not radically new and is widely used (consciously or unconsciously) in the fields of intellectual work that are adjacent to programming.  Consider, for example, two such areas - mechanical engineering and mathematics. <br><br>  These two areas use the materialization of ideas for a long time and effectively.  They have a lot to learn from programming. <br><br>  In mechanical engineering, we see a full cycle of materialization of ideas - from the emergence of an idea in the designer‚Äôs head through its thinking through, detailing, mapping into a model, and finally - manufacturing from a certain material. <br><br>  It's different in math <br><br><div class="spoiler">  <b class="spoiler_title">On the materialization of ideas in mathematics</b> <div class="spoiler_text">  Interesting facts and ideas about the materialization of ideas in mathematics can be found in paragraph 7.3 in the book [8]. </div></div><br>  The "final product" of mathematics is formal models with strictly proved properties. <br><br>  From this point of view, programming lies in the middle.  Graphically, this can be represented as follows: <br><br><img src="https://habrastorage.org/webt/8n/ja/84/8nja84baboink2t_bp02narqbja.png"><br><br>  Thus, mathematics uses a larger number of more abstract models and practically does not touch at all the field of extremely specific models such as engineering drawings. <br><br>  Mechanical engineering, on the contrary, uses relatively few abstract models, but many concrete ones.  For example, those for which physical objects can be uniquely manufactured. <br><br>  From this point of view, programming lies in the middle. <br><br><div class="spoiler">  <b class="spoiler_title">Why is programming in the middle?</b> <div class="spoiler_text"> The final programming product is the program code.  Although it is mapped to specific physical objects (electrical signals and fields of different physical nature) when executed on hardware, it is difficult to compare these objects with nuts, gears and machine bodies.  On the other hand, the program code is close to mathematical formulas, and sometimes is their direct mapping.  However, in any real software system it is necessary to take into account the mass of specific aspects of the environment and interaction with users or other systems.  This makes program code more specific than mathematical formulas. </div></div><br><div class="spoiler">  <b class="spoiler_title">What software engineering can learn from neighboring areas in terms of using models</b> <div class="spoiler_text">  Consider first the mathematics. <br><br><h3>  Multi-mode of the world </h3><br>  For several thousand years of its development, mathematics has learned to describe the same phenomena of the real or imaginary world in very different terms.  The ancient Greeks learned to replace purely verbal descriptions of tasks with geometric figures and with their help solve practically important problems.  Later, an understanding emerged about the interchangeability of line segments and numbers.  Then the concept of an algebraic variable and the reduction of geometric problems to systems of algebraic equations crystallized. <br><br>  Today, high school students know that the same problem can be solved in different ways (for example, geometrically or algebraically) and that the same mathematical model, for example, an algebraic equation, describes many different physical, chemical, etc.  phenomena. <br><br><h3>  Model morphism and consistency of concepts and notations </h3><br>  Mathematics has learned well not only to describe the same real or imaginary objects and processes with the help of models of very different mathematical nature.  An important achievement of mathematics is the ability to determine the degree of similarity of models from different branches of mathematics and the ability to transform them into each other.  Many breakthrough solutions to the most important mathematical problems of recent years are in fact chains of separate evidence, each of which uses a specialized apparatus from a special section of mathematics.  At the junctions of these highly specialized proofs of mathematics, they skillfully transform the models of one branch of mathematics into models of another section.  In programming, something like this happens already now when compiling the source code of a program and when generating code from DSL (Domain Specific Language) or metadata.  But the culture of working with models in software engineering is far behind the mathematical one. <br><br><h3>  Models in mechanical engineering </h3><br>  And what software engineering can learn in terms of the materialization of engineering? <br>  In many industries and even within large corporations, there are chains of coordinated formal and semi-formal models.  These chains end with models on the basis of which physical objects ‚Äî devices and machines ‚Äî are manufactured and mounted.  As a rule, for most types of intermediate models there are formal methods for checking their correctness (technical standards).  Models are the main language of communication specialists of different profiles in the design and manufacture of engineering products. <br><br>  Against this background, the situation in IT looks much worse.  Only within very large IT concerns in recent years have attempts been made to build comparable sets of models and processes.  Small firms and IT startups, as a rule, not only do not have developed formal models and processes, but are not even aware of their existence.  This situation is currently determined by the following factors: <br><br><ul><li>  Lack of effectiveness of existing models and processes </li><li>  Lack of fame of these models outside of large concerns </li><li>  The disadvantages of educating developers and especially managers </li><li>  The lag of university education from the real needs of software engineering. </li></ul></div></div><br><h2>  Definition and Outlines of the Ideas Materialization Paradigm (RPSE) </h2><br>  We have defined all the necessary concepts to give a basic definition of the proposed paradigm.  Here it is: <br><blockquote>  Software development is the materialization of ideas through the transformation of mental models into code executed on computers. <br><br>  Within the framework of the proposed paradigm: <br><br><ol><li>  All basic software development processes are concrete variants (implementations) of the process of building chains of mental and material models.  The last most specific model in this chain is, as a rule, program code. </li><li>  The essence of software development is to create such chains. </li><li>  All the main issues of optimizing development, reducing its cost and improving its quality can be reduced to optimizing the construction of an appropriate chain of models. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">Why Materialization and not Modeling?</b> <div class="spoiler_text">  Note that although the definition of RPSE refers to the construction of chains of models, it is nevertheless proposed to call the paradigm a materialization and not a modeling.  Thus, an attempt is made to emphasize the peculiarity of chains of models that are becoming less and less abstract / ideal and more and more concrete / material. </div></div><br>  The above definition has its own characteristics and variations in different areas of software engineering.  Only in a very small number of cases does it happen that at first the programmer‚Äôs head fully matures a clear idea of ‚Äã‚Äãhow to solve the task before him, which he then translates into code in a programming language in a short time.  In most real projects, the processes of finding a solution and its implementation coexist, develop in parallel and interact with each other.  Those.  mental models, code and often intermediate models (in the form of a test, images, formal models like UML) grow and change in parallel, affecting each other. <br><br><div class="spoiler">  <b class="spoiler_title">Definitions</b> <div class="spoiler_text">  Very often several people work on a problem at the same time.  Each of them has its own mental model and, possibly, its own intermediate models and code fragments. <br><br>  Often, the code in a certain programming language is actually absent, since the creation of a new solution is reduced to controlling the masks of configurators or generators, such as when working with development tools in systems like SAP or WebSphere. <br><br>  The variants of turning manually written or automatically generated code into executable code in our time have also become very diverse. <br><br>  Finally, the very concept of the processor on which the code is executed has also expanded significantly in recent years.  If earlier they were processors that were on the boards, which in turn were inserted into the cases of desktops, laptops and server racks, now this set has been expanded with various chips of various sizes, which are built into mobile phones, game consoles, surveillance cameras, " smart home appliances, etc.  Not to mention quantum computers. <br><br>  Nevertheless, RPSE, by virtue of its generality, is applicable to all the areas listed above. </div></div><br>  What else can be said about a certain paradigm today? Is it possible to outline its contours more precisely? <br><br>  The next step to clarifying the paradigm after trying to give its basic definition is to try to list the main categories of phenomena that it affects.  Recalling Kuhn‚Äôs definition, we need to try to list the types of models that RPSE enters and uses. <br><br>  RPSE models can be divided into three main categories: <br><br><ul><li>  Mental models </li><li>  Code in programming languages ‚Äã‚Äãor its equivalents as models of executable code. </li><li>  Intermediate models. </li></ul><br>  The least studied in this triad are mental models.  What exactly is meant by them? <br><br>  <b>Mental models</b> are a term to refer to ideas that exist in the minds of customers, programmers, and other participants in the process and on the basis of which ultimately executable code arises.  The presence of such models is indisputable and can be registered at the mental level, for example, by the programmer himself.  At the present level of technological development, these models cannot be reliably measured by instruments. <br><br>  One of the well-functioning methods of fixing and measuring such models is the introduction of the idea carrier.  It is obvious that the process of interviewing or similar to it dramatically affect the mental model itself.  Each of us probably experienced more than once a situation where only one attempt to formulate a problem in order to consult with a colleague led to an ‚Äúinsight‚Äù, and often to a solution to the problem. <br><br>  Interviewing allows for objectively constructing models of varying complexity on the basis of correctly formulated questions.  The most commonly used are: <br>  Structural models: <br><br><ul><li>  Lists with binary, enumeration, numeric, string and other values. </li><li>  Graph and network data structures </li></ul><br>  Behavior description models: <br><br><ul><li>  Seven-formal behavioral models </li><li>  Formal behavioral models (for example, finite automata) </li></ul><br><div class="spoiler">  <b class="spoiler_title">On the theory of mental models</b> <div class="spoiler_text">  These models are reflections of mental models.  The degree of closeness of mental models to real models should be dealt with by psychology or theoretical pedagogy.  Unfortunately, the author is not aware of serious work in this area.  (This does not mean that such works do not exist). </div></div><br><h2>  Why does software engineering need an end-to-end paradigm? </h2><br>  The presence of the ‚Äúend-to-end‚Äù paradigm opens up the following opportunities for participants using the process of creating, modifying and using software using this paradigm: <br><br><ul><li>  The ability of all participants in the process to use the same terminology. </li><li>  Ability to build through the process of creating new software. </li><li>  The ability to evaluate its process parameters, its intermediate results and manage it. </li></ul>  . <br><h2>  The main objectives of the development paradigm </h2><br><h3>  Theoretical problems </h3><br>  As has been repeatedly noted, including in the book by Kuhn [2], in most cases, scientists are engaged in solving potentially solvable problems, and less often they are taken for those that are not very clear how to approach.  But these are exactly our tasks.  Here are the main ones: <br><br><ol><li>  Constructive definition of the mental model. </li><li>  Finding constructive criteria for assessing the degree of abstractness / ideality vs.  concreteness / materiality of models. </li><li>  Finding criteria for the selection of candidates for the role of intermediate and additional models. </li><li>  Selection and development of criteria and methods for comparing models of various types, including their direct and reverse tracing. </li><li>  Development of methods for automated and automatic transformation of models. </li></ol><br><h3>  Practical tasks </h3><br>  Along with theoretical problems for the development and implementation of the described paradigm in the practice of software engineering, it is necessary to solve at least the following practical tasks: <br><br><ol><li>  Creating tools for: a) Extracting and fixing mental models.  b) Automated and automatic transformation of mental models into intermediate ones.  c) Tracing and evaluation of changes in the content of transformable models </li><li>  Creating the necessary technical and teaching literature and other medial teaching material. </li><li>  Organization of forums and conferences on this topic. </li></ol><br><h2>  Conclusion </h2><br>  This article attempts to define the software engineering paradigm as the materialization of ideas.  The word define (and not open) is not used here by chance.  In fact, participants in IT projects have long been engaged in the creation, transformation, and use of models, but they may not be aware of that. <br><br>  In the strict sense of Kuhn‚Äôs definition, the described approach cannot yet claim the right to be called a paradigm, but only a candidate for a paradigm, since it does not have an extensive community of people supporting it and a well-developed system of interconnected models.  However, I want to believe that the shortcomings will soon be overcome. <br><br>  This is the first article in the scheduled series of articles.  In the following articles I am going to talk about mental and intermediate models. <br><br><h3>  Literature </h3><br>  1. IEEE Standard Glossary of Software Engineering Terminology, IEEE std 610.12-1990, 1990. <br>  2. Kuhn, Thomas S. The Structure of Scientific Revolutions.  3rd ed.  Chicago, IL: University of Chicago Press, 1996. <br>  3. Programming paradigm: <a href="https://en.wikipedia.org/wiki/Programming_paradigm">en.wikipedia.org/wiki/Programming_paradigm</a> (state - 08/27/2018) <br>  4. Peter A. Henning, Holger Vogelsang Taschenbuch Programmiersprachen.  Carl Hanser Verlag GmbH &amp; Co.  KG;  Auflage: 2., neu bearbeitete (5. September 2007).  ISBN-13: 978-3446407442. <br>  5. Software Engineering Paradigms And Models Information Technology Essay <br>  <a href="https://www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php">www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php</a> (state - 08/27/2018) <br>  6. Reification (computer science) <a href="https://en.wikipedia.org/wiki/Reification_">en.wikipedia.org/wiki/Reification_</a> (computer_science) (state - 08/27/2018) <br>  7. Fedor Ivanovich Tyutchev.  Silentium!  (Silence (Latin), 1829 <br>  8. Borovik, Alexandre.  Mathematics under the microscope: notes on the cognitive aspects of mathematical practice.  American Mathematical Society.  ISBN-13: 978-0821847619. <br><br>  Illustration: <a href="https://pixabay.com/de/tablet-computer-hand-schreiben-3711135/">geralt</a> </div><p>Source: <a href="https://habr.com/ru/post/425321/">https://habr.com/ru/post/425321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425309/index.html">AERODISK: DSS in Russian or severe Lyubertsy-Sakhalin startup from the factory</a></li>
<li><a href="../425311/index.html">The book "Programming for children. From the basics to creating robots</a></li>
<li><a href="../425313/index.html">10 best VS Code-extensions of 2018 for front-end developers</a></li>
<li><a href="../425315/index.html">Organize code storage in GitLab and integrate code review in GitFlow</a></li>
<li><a href="../425317/index.html">How it is done: we write "Minesweeper" in 4 minutes</a></li>
<li><a href="../425323/index.html">"Rabbit Hole". UX designer in the product team</a></li>
<li><a href="../425325/index.html">DIY bytecode interpreters</a></li>
<li><a href="../425327/index.html">Functional programming: measure seven times, cut once</a></li>
<li><a href="../425329/index.html">A few tips to the millennials from the "oldies". How to succeed in our digital world</a></li>
<li><a href="../425331/index.html">Alice will help developers find objects in user requests. NER in Dialogues</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>