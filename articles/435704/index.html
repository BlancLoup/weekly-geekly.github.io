<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architectural solutions for mobile games. Part 2: Command and their queues</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, we looked at how the model should be arranged in order to use it was easy, and debugging it and attaching interfaces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architectural solutions for mobile games. Part 2: Command and their queues</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/1n/ji/xq/1njixqpyay22mmuyckufhgouye8.jpeg"><br><br>  In the first part of the article, we looked at how the model should be arranged in order to use it was easy, and debugging it and attaching interfaces to it is simple.  In this part, we will consider the return of commands to changes in the model, in all its beauty and diversity.  As before, the priority for us will be the convenience of debugging, minimizing the gestures that the programmer needs to do in order to create a new feature, as well as the readability of the code for a person. <br><br>  <a href="https://habr.com/post/434582/">Architectural solutions for mobile games.</a>  <a href="https://habr.com/post/434582/">Part 1: Model</a> <br>  <a href="https://habr.com/post/436060/">Architectural solutions for mobile games.</a>  <a href="https://habr.com/post/436060/">Part 3: View on jet propulsion</a> <br><a name="habracut"></a><br><h2>  Why Command </h2><br>  The Command pattern sounds loud, and in fact it is just an object into which everything necessary for the requested operation is stored and stored.  We choose such an approach, at least because our teams will be sent over the network, and we will get several copies of the game-steate for ourselves, for business purposes.  So when a user clicks a button, an instance of the command class is created and sent to the recipient.  The meaning of the letter C in the MVC abbreviation is somewhat different here. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Prediction of results and verification of commands over the network </h2><br>  In this case, the specific code is less important than the idea.  And the idea is this: <br><br>  A self-respecting game cannot wait for a response from the server before responding to a button.  Of course, the Internet is getting better and you may have a cloud of servers around the world, and I know even a couple of successful games waiting for a response from the server, one of them is even Summoning Wars, but still you don‚Äôt need to do so.  Because for the mobile Internet, lag of 5-15 seconds is more the norm than the exception, in Moscow at least, the game should be really great so that the players do not pay attention to it. <br><br>  Accordingly, we have a gamestate that represents all the information required by the interface, and commands are applied to it immediately, and only after that are sent to the server.  Usually hard-working java-programmers are sitting on the server, duplicating all the new functionality one-on-one in another language.  On our ‚Äúdeer‚Äù project, their number reached 3 people, and the mistakes made during porting were a constant source of subtle joy.  Instead, we can do differently.  We launch on the .Net server and run the same command code on the server side as on the client. <br><br>  The model described in the last article gives us a new interesting opportunity for self-testing.  After executing the command on the client, we will calculate the hash of the change in the GameState tree, and apply it to the command.  If the server executes the same command code, and the hash of the changes that have occurred does not match, then something went wrong. <br><br>  First benefits: <br><br><ul><li>  Such a solution greatly accelerates the development and minimizes the number of server programmers. </li><li>  If the programmer made errors leading to non-deterministic behavior, for example, got the first value from the Dictionary, or used DateTime.now, and generally used some values ‚Äã‚Äãnot written in the command fields explicitly, then at the start of the hash server will not match, and we will find out about it. </li><li>  Development of the client can be for the time being without a server at all.  You can even go to friendly alpha without having a server.  This is useful not only for indie developers who play the game of their dreams at night.  When I was in Pixonik, there was a case when the server programmer wiped out all the polymers, and our game was forced to go through pre-moderation, having a gag instead of a server stupidly playing the entire gamestate once in a while. </li></ul><br>  The disadvantage that for some reason is systematically underestimated: <br><br><ul><li>  If the client programmer did something wrong and it is imperceptible to testing, for example, the likelihood of goods in mysteryboxes, then there is no one to write the same thing the second time and find an error.  Autoported code requires a much more responsible attitude to testing. </li></ul><br><h2>  Detailed debug information </h2><br>  One of our stated priorities is the convenience of debugging.  If in the process of executing a command we caught an exception, everything is clear, we roll back the gamestate, send full status to the logs and serialize the dropped command to it, everything is convenient and fine.  The situation is more complicated if we have out of sync with the server.  Because several other teams have already been executed on the client since, and it turns out that it is not easy to find out what state the model was before executing the team that led to the disaster, but I really want to.  Cloning the gamestate in front of each team is too difficult and expensive.  To solve the problem, let's complicate the scheme sewn under the engine hood. <br><br>  In the client, we will have not one gamestate, but two.  The first one serves as the main interface rendering interface, commands are applied to it immediately.  After that, the applied commands appear in the send queue to the server.  The server performs the same action on its side, and confirms that everything is good and correct.  After receiving the confirmation, the client takes the same command and applies it to the second gamestate, bringing it to the state that has already been confirmed by the server as correct.  At the same time, we also have the opportunity to compare the hash of the changes made to insure, and we can also compare the full hash of the entire tree on the client, which we can calculate after executing the command, it weighs little and is considered fast enough.  If the server does not say that everything is fine, he asks the client for details of what happened, and the client can send him the serialized second gamestate exactly as it looked before the successful execution of the command on the client. <br>  The solution looks very attractive, but it gives rise to two problems that need to be solved at the code level: <br><br><ul><li>  Among the command parameters there may be not only simple types, but also references to models.  In another gamestate at the exact same place are other objects of the model.  We solve this problem in the following way: Before the command is executed on the client, we serialize all its data.  Among them may be links to models, which we write in the form of Path to the model from the root of the gamestat.  We do this before the team, because after its implementation, the paths may change.  Then we send this path to the server, and the server gamestart will be able to get a link to its model on the way.  Similarly, when a team is applied to a second gamestate model can be obtained from the second gamestate. </li><li>  In addition to elementary types and models, the team may have links to collections.  Dictionary &lt;key, Model&gt;, Dictionary &lt;Model, key&gt;, List &lt;Model&gt;, List &lt;Value&gt;.  For all, they will have to write serializers.  However, you can not rush to this, in a real project such fields occur surprisingly rarely. </li><li>  Sending commands to the server one by one is not a good idea, because the user can produce them faster than the Internet can carry them back and forth, the pool of commands that are not worked out by the server will grow on a bad Internet.  Instead of sending commands one by one, we will send them in batches of several pieces.  In this case, having received a response from the server that something went wrong, you will first need to apply to the second state all previous commands from the same package that were confirmed by the server, and only then store and send a control second state to the server. </li></ul><br><h2>  Convenience and ease of writing commands </h2><br>  The command execution code is the second in size and the first in responsibility by the code in the game.  The simpler and clearer it will be, and the less a programmer needs to make too much hands to write it, the faster the code will be written, the fewer mistakes made and, very unexpectedly, the happier the programmer will be.  I place the execution code directly in the team itself, except for the common pieces and functions that are located in separate static classes of rules, most often in the form of extensions to the classes of models with which they work.  I will show a couple of examples of commands from my pet project, one very simple and the other a little more complicated: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetSideCostCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//              protected override bool DetaliedLog { get { return true; } } public FCMatchModel match; public int newCost; protected override void HexApply(HexKingdomsRoot root) { match.sideCost = newCost; match.CalculateAssignments(); match.CalculateNextUnassignedPlayer(); } } }</span></span></code> </pre> <br>  And this is how the log looks like, which is left behind by this command, unless the log is turned off. <br><br><pre> <code class="json hljs">[FCSetSideCostCommand id=<span class="hljs-number"><span class="hljs-number">1</span></span> match=FCMatchModel[<span class="hljs-number"><span class="hljs-number">0</span></span>] newCost=<span class="hljs-number"><span class="hljs-number">260</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0027546</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0008689</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"0"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"SIDE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"1"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}}}}</code> </pre> <br>  The first time, which is indicated in the log, is the time during which all necessary changes in the model were made, and the second time, during which all changes were worked out by the interface controllers.  This should be shown in the log in order not to accidentally do something terribly slow, or to notice in time if operations start to take too much time simply because of the size of the model itself. <br><br>  Apart from appeals to Persistent-objects by Id-Schnick, greatly reducing the readability of the log, which, by the way, could have been avoided here, and the command code itself, and the log that he did with the gamestate is surprisingly clear.  Note that in the command text the programmer does not make any unnecessary movement.  Everything you need is done by the engine under the hood. <br><br>  Now look at the example of a larger team. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetUnitForPlayerCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//            protected override bool DetaliedLog { get { return true; } } public FCSelectArmyScreenModel screen; public string unit; public int count; protected override void HexApply(HexKingdomsRoot root) { if (count == 0 &amp;&amp; screen.player.units.ContainsKey(unit)) { screen.player.units.Remove(unit); screen.selectedUnits.Remove(unit); } else if (count != 0) { if (screen.player.units.ContainsKey(unit)) { screen.player.units[unit] = count; screen.selectedUnits[unit].count = count; } else { screen.player.units.Add(unit, count); screen.selectedUnits[unit] = new ReferenceUnitModel() { type = unit, count = count }; } } screen.SetSelectedReferenceUnits(); screen.player.CalculateUnitsCost(); var side = screen.match.sides[screen.side]; screen.match.CalculatePlayerAssignmentsAcceptablity(side); screen.match.CalculateNextUnassignedPlayer(screen.player); } } }</span></span></code> </pre> <br>  And here is the log that the command left behind: <br><br><pre> <code class="json hljs">[FCSetUnitForPlayerCommand id=<span class="hljs-number"><span class="hljs-number">3</span></span> screen=/UI_SCREENS[main] unit=militia count=<span class="hljs-number"><span class="hljs-number">1</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0065625</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0004573</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}}, <span class="hljs-attr"><span class="hljs-attr">"ASSIGNED"</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>}}}, <span class="hljs-attr"><span class="hljs-attr">"UI_SCREENS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"SELECTED_UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"@new"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"TYPE"</span></span>:<span class="hljs-string"><span class="hljs-string">"militia"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"REMARK"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"COUNT"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"SELECTED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"DISABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_GREEN"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_RED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"BUTTON_ENABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}}}}}}}</code> </pre> <br>  As they say, so much clearer.  Take the time to provide the team with a convenient, compact and informative log.  This is the key to your happiness.  The model must work very quickly, so there we used a variety of tricks with the methods of storage and access to the fields.  Commands are executed in the worst case, once per frame, in fact, several times less, therefore we will do serialization and deserialization of the command fields, just through reflex.  Just sort the fields by name so that the order is fixed, well, we will compile the list of fields once in a team‚Äôs life, and read-write with native C # methods. <br><br><h2>  Model information for the interface. </h2><br>  Let's take the next step in complicating our engine, a step that looks scary, but greatly simplifies the writing and debugging of interfaces.  Very often, especially in the related MVP pattern, the model contains only business logic controlled by the server, and information about the state of the interface is stored inside the presenter.  For example, do you want to book five tickets.  You have already chosen their number, but have not yet clicked the "order" button.  Information about exactly how many tickets you have chosen in the mold can be stored somewhere in the secret corners of the class that serves as a gasket between the model and its display.  Or, for example, a player switches from one screen to another, and nothing changes in the model, and where the tragedy happened when the programmer involved in debugging knew only from the words of an extremely disciplined tester.  The approach is simple, clear, almost always used and a bit malicious, in my opinion.  Because if something went wrong, the state of this Presenter, which led to an error, is absolutely no way to know.  Especially if the error occurred on the combat server during the operation on $ 1000, and not at the tester in controlled and reproducible conditions. <br><br>  Instead of this usual approach, we prohibit someone other than the model to contain information about the state of the interface.  This has, as usual, the advantages and disadvantages that one has to contend with. <br><br><ul><li>  <b>(+1)</b> The most important advantage that saves people months of programming is that if something went wrong, the programmer simply loads the gamestate before the accident and receives exactly the same state not only of the business model, but of the entire interface, up to the very last button on the screen. </li><li>  <b>(+2)</b> If some command has changed something in the interface, the programmer can easily go to the log and see what exactly has changed in a convenient json form, as in the previous section. </li><li>  <b>(-1)</b> A lot of extra information appears in the model, which is not needed to understand the business logic of the game and does not need the server two times. </li></ul><br>  To solve this problem we will mark some fields as notServerVerified, it looks like this, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EDictionary&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; uiScreens { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UI_SCREENS.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; UI_SCREENS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt;() { notServerVerified = <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre> <br>  This part of the model and everything below it will relate exclusively to the client. <br><br>  If you still remember, the flags of what is to be exported and what is not are as follows: <br><br><pre> <code class="cpp hljs">[Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ExportMode { all = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, changes = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, serverVerified = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }</code> </pre> <br>  Accordingly, when exporting or calculating the hash, you can specify whether to export the entire tree or only its part that is checked by the server. <br><br>  The first obvious complication that results from this is the need to create separate commands that need to be checked by the server and those that are not needed, but there are also those that need to be checked not entirely.  In order not to load the programmer with unnecessary operations for setting up the command, we will again try to do everything necessary for the engine hood. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;    ,      &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;         &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyClientSide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br>  A programmer creating a command can override one or both of these functions.  All this, of course, is wonderful, but how to make sure that the programmer did not mess up anything, and if he messed up something, how can he help him quickly and easily fix it?  There are two ways.  I applied the first one, but you might like the second one more. <br><br><h3>  First way </h3><br>  We use the cool properties of our model: <br><br><ol><li>  The engine calls the first function, after which it receives a hash of changes in the server part of the gamestay that is being checked.  If there are no changes, then we are dealing with an exclusively client team. </li><li>  We get the model hash changes in the entire model, not only the server-checked.  If it differs from the previous hash, then the programmer has nakosyachil, and changed something in the part of the model that is not checked by the server.  We go around the state tree and drop out to the programmer in the form of a full list of notServerVerified = true fields and lying below the tree, which he changed. </li><li>  Call the second function.  We get from the model hash the changes that occurred in the checked part.  If it does not coincide with the hash after the first call, then in the second function the programmer has done everything.  If we want to get a very informative log in this case, we roll back the entire model to its original state, serialize it to a file, the programmer will then need it for debugging, then we clone it entirely (two lines - serialization-deserialization), and now we apply the first to the clone function, then we fix the changes so that the model looks unchanged, after which we apply the second function.  And then we export all the changes in the part checked by the server as JSON, and we include it into the abusive exceptions so that the shy programmer can immediately see what and where he changed, which should not be changed. </li></ol><br>  It looks, of course, scary, but in fact it‚Äôs 7 lines, because the functions that do this here (except for traversing the tree from the second paragraph) are ready.  And since this is an exception, we can not afford to act optimally. <br><br><h3>  Second way </h3><br>  Slightly more brutal, we now have one lock field in ModelRoot, but we can divide it into two, one will only lock the server the fields being checked, the other is not the server being checked.  In this case, the programmer who has done something wrong will get about this exception immediately with the ration to the place where he did it.  The only drawback of this approach is that if in our tree one model property is marked as not verifiable, then everything in the tree is located below it about counting hashes and controlling changes will not be examined, even if each field is not marked.  And Lok, of course, will not look into the hierarchy, which means you will have to mark all the fields of the unchecked part of the tree, and you will not be able to use the same classes in the UI and the usual part of the tree.  As an option, such a construction is possible (I will write it down simply): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameState</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelData data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelLocal local; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> locked { get; } }</code> </pre> <br>  Then it turns out that each subtree has its own lok.  GameState inherits the model, because it's easier than to invent for it a separate implementation of all the same functionality. <br><br><h3>  Necessary improvements </h3><br>  Of course, the manager who is responsible for processing commands will have to add new functionality.  The essence of the changes will be that not all commands will be sent to the server, but only those that create the checked changes.  The server on its side will not raise the entire gamestate tree, but only the part to be checked, and accordingly the hash will match only for the checked part of the state.  When executing a command, only the first of the two functions of the command will be launched on the server, and when resolving references to models in the game console, if the path goes to an unchecked part of the tree, null will be placed in the command variable instead of the model.  All not sent teams will honestly stand in line along with the usual ones, but at the same time be considered as already confirmed.  As soon as the queue reaches them and before them there will be no unconfirmed they will immediately be applied to the second state. <br><br>  There is nothing fundamentally difficult to implement.  Simply, the property of each field of the model has another condition, tree traversal. <br><br>  Another necessary improvement is that you need separate Factory for ParsistentModel in the checked and untested part of the tree and NextFreeId will be different for them. <br><br><h2>  Commands initiated by the server </h2><br>  There is some problem if the server wants to push its team to the client, because the client state relative to the server state could already have gone a few steps ahead.  The basic idea is that if the server needed to send its team, it sends a server notification to the client with the next answer, and writes it to itself in the field for notifications sent to this client.  The client receives a notification, forms a command on its basis and puts it at the end of its turn, after those who managed to execute on the client, but have not reached the server yet.  After some time, the command is sent to the server as part of the normal process of working with the model.  Having received this command for processing, the server throws the notification out of the outgoing queue.  If the client has not responded to the notification within the set time, with the next package, the command will be restarted.  If the client received the notification has fallen off, connects later or else for some reason loads the game, the server, before giving it, the state turns all notifications into commands, executes them on its side, and only after that gives the joining client its new status.  Please note that there may be a conflict state of the player with negative resources when the player managed to spend the money exactly at the moment when the server took it away from him.  The match is unlikely, but with a large DAU it is almost inevitable.  Therefore, the interface and game rules should not fall to death in such a situation. <br><br><h2>  Commands for which you need to know the server response </h2><br>  A typical mistake is to think that a random number can only be received from the server.  Nothing prevents you from having the same pseudo-random number generator that runs synchronously on the client and on the server, starting from a common view.  Moreover, the current seed can be stored directly in the gamestate.  Some will find it problematic to synchronize the operation of this generator.  In fact, it‚Äôs enough to have one more number in the stack ‚Äî how many exactly numbers were received from the generator up to this point.  If for some reason your generator does not converge, then you have an error somewhere and the code is not deterministic.  And this fact is necessary not to hide under the carpet, but to understand and look for a mistake.  For the vast majority of cases, including even mysteryboxes, this approach is sufficient. <br><br>  However, there are times when this option is not suitable.  For example, you are playing a very expensive prize and do not want an abrupt comrade to decompile the game, and wrote a bot telling you that you will fall out of the diamond box if you open it right now, and what if you twist the drum in a different place before.  You can store the seed for each random value separately, it will protect from frontal hacking, but it does not help from the bot telling you how many boxes the goods you need at the moment.  Well, the most obvious case - you may not want to shine in the client config information about the likelihood of a rare event.  In short, sometimes you need to wait for the server to respond. <br>  Such situations should not be solved through the additional features of the engine, but breaking the team into two - the first prepares the situation and puts the interface in a state of waiting for notification, the second is actually notification, with the answer you need.  Even if you tightly block the interface between them on the client, another team may slip through - for example, a unit of energy will be restored in time. <br><br>  It is important to understand that such situations are not the rule, but the exception.  In fact, most games need only one team waiting for an answer - GetInitialGameState.  Another bundle of such teams is cross-player interaction in a metagame, GetLeaderboard, for example.  All the other two hundred pieces are deterministic. <br><br><h2>  Data storage on the server and the cloudy theme of server optimization </h2><br>  I admit at once, I am a client, and sometimes I heard ideas and algorithms from my familiar servers that would not even have crept into my head.  In a way of communicating with my colleagues, I had a picture of how my architecture should work on the server side, ideally.  However: There are contraindications, it is necessary to consult with a server specialist. <br><br>  First, about storing data.  It is your server part that may have additional restrictions.  For example, you may be prohibited from using static fields.  Further, the code of commands and models is auto-ported, but the code on the client and on the server does not necessarily have to match.  Anything can be hidden there, even lazy initialization of the field values ‚Äã‚Äãfrom the memcache, for example.  Property fields can also receive additional parameters that are used by the server, but do not affect the client‚Äôs work in any way. <br><br>  The first fundamental difference of the server: where fields are serialized and deserialized.  The sensible solution is that most of the state tree is serialized into one huge binary or json field.  At the same time, some fields are taken from the tables.  This is necessary because the values ‚Äã‚Äãof some fields will be constantly needed for the operation of interaction services between players.  For example, the icon and level are constantly twitching by various people.  They are best kept in the usual base.  A full or partial, but the detailed state of a person will be needed by someone other than himself very rarely, when someone decides to look at his territory. <br><br>  Further, it is inconvenient to pull the fields from the base one by one, and it can be a long time to drag everything.  A very non-standard solution, available only for our architecture, may consist in the fact that the client will collect information about all fields stored separately in the tables, the getters have time to touch the team, and add this information to the team so that the server can pick up this field group. one request to the database.  Of course, with reasonable restrictions, so as not to ask for DDOS caused by Krivoruk programmers who carelessly touched everything. <br><br>  With such separate storage, you should consider the mechanisms of transactionalism when one player climbs into the data of another, for example, steals money from him.  But in general, this is done by us as a notification.  That is, the thief receives his money immediately, and the robber receives a notification with the instruction to write off the money then when it comes to this turn. <br><br><h2>  How commands are shared between servers </h2><br>  Now the second important moment for the server.  There are two approaches.  At the first to process any request (or packet of requests), the entire state rises from the database or cache into memory, is processed, and then returns to the database.  Operations are processed atomically on a heap of different executing servers, and they only have a common base, and this is not always the case.  As a client, I‚Äôm shocked by the rise of the entire state for each team, but I‚Äôve seen how it works with my own eyes, and it works very reliably and scalable.  The second option is that the state rises once in the memory and lives there until the client falls off only occasionally adding its current state to the base.            .    -           .        ,       .     ,     ,   .          10 .       ,     ,       ‚Äî          .         ,                .     ‚Äî    . <br><br><h2>    </h2><br>   ,        :       ,      .      .              .   ,          .     ,          .            ‚Äî          ‚Äî            . <br><br>         ,   ,       -                     .     ,    .          ,     VR   CS,  -           . ,  ,         ,          30%. <br><br>   ,      ‚Äî    ,     .          ,      .     ,  , ,     ,    ,       . <br><br> , , -      ,     :       .     ,       .      ,   35                 .     ,       ,    . ,   ,                 ,    ‚Äî         . <br>     :       ‚Äî 30 .          ?  ‚Ññ1:   .  ‚Ññ2:       ,        3000      . <br><br>  ,                   ‚Äî  .  Something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface Command { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; }</code> </pre> <br>    , ,     Unity     ‚Äî .    UnixTime   ,         ,         PTime,   PValue&lt;long&gt;  ,     JSON         :   - .    .   . <br><br>  :     ,       ,  , ,  .   ,   .   ,   .  PTimeOut,                .     ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PTimeOut RESTORE_ENERGY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PTimeOut() {command = (model, property) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestoreEnergyCommand() { model = model}} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> restoreEnergy { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RESTORE_ENERGY.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { RESTORE_ENERGY.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); }} }</code> </pre> <br>                ,      .     ,       ,       .            ,       ,      ,      ,      .          ,         ,              . <br><br>     -   ,        .   ,      ,       ,     ,      ,    .            ,               currentTime,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; } vs <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> event Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; setCurrentTime; }</code> </pre> <br>   ,    ,  ,                ,      .    ,      ,          ,  -       GC. <br><br><h3>  1,  ,     </h3><br>      .             ,    - .       ,    ,           .        ,      ,   ,  ,      callback,       . , .      ,           ,               ,  ,    ¬´  ¬ª , ,    .    ,   ,             . <br><br>  ,    .       ,        inventory,      .     ,   ,      -,  ,     .          ,       ¬´ ¬ª      ,      ,      ,    .     ¬´    ¬ª.         ,        .        ,       ,                 .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenMisterBox</span></span></span><span class="hljs-class"> :</span></span> Command { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BoxItemModel item; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slot; <span class="hljs-comment"><span class="hljs-comment">//        ,  . public override void Apply(GameState state) { state.inventory[item.revardKey] += item.revardCount; } //       . public override void Apply(GameState state) { var cause = state.NewPersistent&lt;WaitForCommand&gt;(); cause.key = item.key; cause.value = item.value; state.ui.delayedInventoryVisualization.Add(cause); state.ui.mysteryBoxScreen.animations.Add(new Animation() {cause = item, slot = slot})); } } public class MysteryBoxView : View { /* ... */ public override void ConnectModel(MysteryBoxScreenModel model, List&lt;Control&gt; c) { model.Get(c, MysteryBoxScreenModel.ANIMATIONS) .Control(c, onAdd = item =&gt; animationFactory(item, OnComleteOrAbort =&gt; { AsincQueue(new RemoveAnimation() {cause = item.cause, animation = item}) }), onRemove = item =&gt; {} ) } } public class InventoryView : View&lt;InventoryItem&gt; { public Text text; public override void ConnectModel(InventoryItem model, List&lt;Control&gt; c) { model.GameState.ui.Get(c, UIModel.DELAYED_INVENTORY_VISUALIZATION). .Where(c, item =&gt; item.key == model.key) .Expression(c, onChange = (IList&lt;InventoryItem&gt; list) =&gt; { int sum = 0; for (int i = 0; i &lt; list.Count; i++) sum += list[i].value; return sum; }, onAdd = null, onRemove = null ) //      .Join (c, model.GameState.Get(GameState.INVENTORY).ItemByKey(model.key)) .Expression(c, (delay, count) =&gt; count - delay) .SetText(c, text); //     ,      ,   ,  ,   ,       ,     : model.inventory.CreateVisibleInventoryItemCount(c, model.key).SetText(c, text); } } public class RemoveDelayedInventoryVisualization : Command { public DelayCauseModel cause; public override void Apply(GameState state) { state.ui.delayedInventoryVisualization.Remove(cause); } } public class RemoveAnimation : RemoveDelayedInventoryVisualization { public Animation animation public override void Apply(GameState state) { base.Apply(state); state.ui.mysteryBoxScreen.animations.Remove(animation); } }</span></span></code> </pre> <br>  What do we have in the end?   View,       ,         ,           .  .          GameState        ,    ,      .    ,       ,    ,    . <br><br><h2>  </h2><br>  -   ,      ,                  ,     , ,   ,      .              .    , ,                        .              ,         ,       . <br>          .      ,     ,       ‚Äî    .            . </div><p>Source: <a href="https://habr.com/ru/post/435704/">https://habr.com/ru/post/435704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435694/index.html">How and why we optimized the algorithm of cleaning SLAB-caches in the Linux kernel</a></li>
<li><a href="../435696/index.html">Antiquities: Computer Advertising 1997</a></li>
<li><a href="../435698/index.html">Writing your own good memory manager</a></li>
<li><a href="../435700/index.html">8 worst questions on Vue.js interview</a></li>
<li><a href="../435702/index.html">Patent trolls start and win: how I was left without a game</a></li>
<li><a href="../435706/index.html">Use rcm to deploy the configuration to any folder</a></li>
<li><a href="../435708/index.html">Faial: a meeting place in the Atlantic</a></li>
<li><a href="../435712/index.html">Procter & Gamble has released a ‚Äúrejuvenating‚Äù skin printer</a></li>
<li><a href="../435714/index.html">Ukrainian developers have been given access to files from all Ring camcorders in the world.</a></li>
<li><a href="../435718/index.html">We pump Angular NGSW with the help of custom logic in the Service Worker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>