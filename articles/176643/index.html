<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a custom component from scratch. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Greetings, colleagues! 

 Quite often, when developing multimedia Android applications (hereinafter simply ‚Äúapplications‚Äù), we are face...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a custom component from scratch. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Greetings, colleagues! <br><br>  Quite often, when developing multimedia Android applications (hereinafter simply ‚Äúapplications‚Äù), we are faced with the task of creating our own components that are not provided for in the system.  It can be all kinds of knobs-switches, spectrum visualizers, etc. Some of them can be obtained by simply replacing the graphic resource, turning the canvas by 90 degrees, etc. But sometimes, you still have to do something different. zero. <br>  In this article, I'm going to talk about creating a component - a simple piano keyboard, using inheritance from the View class and implementing all the internals ‚Äúindependently.‚Äù  Why in quotes - see further. <br><br>  In a series of articles I will try to highlight issues such as: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  component rendering </li><li>  adding scrolling using standard scrollbars </li><li>  interaction, using key selectors </li><li>  Preserving component state when rotating screen </li><li>  adding backlight in overscroll </li><li>  passing parameters to XML </li><li>  pinch zoom </li></ol><br><br>  The first article will be about the first three points. <br><br>  If you are interested in these topics, welcome under cat. <br><a name="habracut"></a><br><h4>  Prehistory </h4><br>  Once upon a time, when I wrote my musical application, which I mentioned in previous articles, I was faced with the need to wash down the piano.  Since this was my very first android application, and even then the android was not at all the same as it is now, in the first version I did more than one perversion to make a less working component.  I kept a giant Bitmap in my memory, made up of 4 pictures with an octave, for scrolling I had a separate stream that cyclically reduced the scrolling speed at a given interval and fell asleep until the next task was received.  Interactivity was zero. <br>  Now, after some time, I am writing a project, in many respects similar to my first, but on a completely different level of quality and functionality, and again I need a piano.  Here I will tell about it. <br><br><h4>  Component development </h4><br><br><h5>  View or SurfaceView? </h5><br>  Rule of thumb, which I brought for myself, is to try to use the View whenever possible, and avoid SurfaceView, unless you need to have a component that constantly draws some changing state with more or less complex graphics (game, video).  In all other cases, View is your choice.  You also need to consider that using SurfaceView, we are depriving ourselves of the possibility in the future to animate this component inside your layout. <br><br><h5>  First stage </h5><br>  So, let's start, the first thing we will do is create a new class, the heir of android.view.View.  Let's call it PianoView. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PianoView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PianoView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, AttributeSet attrs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDraw(canvas); } }</code> </pre> <br>  As we see, we have a constructor in which the context and a set of attributes are passed to us.  In the onDraw method, we will draw our component.  This method is called every time it becomes necessary to redraw the view, for example, for each frame of the animation. <br><br><h5>  Keyboard drawing  Graphic resources. </h5><br>  To draw the keys, I will use the standard Android tools: selector, nine-patch drawable. <br>  For the white keys, I have prepared the following 9-patch images.  I decided to make the selected state using the standard for Holo blue backlight. <br><br><img src="https://habrastorage.org/storage2/cc9/64d/5c3/cc964d5c3afb5f722a1aea40d6ee63d1.png"><img src="https://habrastorage.org/storage2/3bb/503/4c0/3bb5034c0bec943da4b17d0f94667d98.png"><br>  For blacks: <br><img src="https://habrastorage.org/storage2/34a/58b/d24/34a58bd2417d7f606f36a1d6d6381db3.png"><img src="https://habrastorage.org/storage2/08c/431/649/08c431649b72690670fc7b33f0e2b8f7.png"><br><br>  And for each of them created a selector: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">selector</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:drawable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@drawable/white_key_pressed"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:state_pressed</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:drawable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@drawable/white_key"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">selector</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  All that is now left is to get these Drawables in the code with <code>context.getResourses.getDrawable();</code> <br><br><h5>  Keyboard drawing  Code </h5><br>  So, to keep the component code clean, I brought all the keyboard drawing and storing the necessary information to the Keyboard class.  In our <code>onDraw</code> I'll just call its method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (measurementChanged) { measurementChanged = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; keyboard.initializeInstrument(getMeasuredHeight(), getContext()); instrumentWidth = keyboard.getWidth(); } keyboard.draw(canvas); }</code> </pre><br><br>  I will not tell you in great detail how the piano is drawn simply because it takes too much space with boring text and code.  Anyone who wants to see the details can take my code and see.  Here I will explain only the principle. <br><br>  The first stage is initialization.  Initialization includes the calculation of the array of keys. <br><br><pre> <code class="java hljs">Key[] keysArray;</code> </pre><br><br>  This is our model.  Each item is a key.  The key knows its coordinates (in the component's coordinate system) and dimensions, whether it is black or white, and whether it is currently pressed or not. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startX; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> endX; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startY; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> endY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> midiCode; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> black; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> pressed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startX = startX; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startY = startY; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endX = endX; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endY = endY; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> startX &lt;= x &amp;&amp; endX &gt; x &amp;&amp; startY &lt;= y &amp;&amp; endY &gt; y; } }</code> </pre><br><br>  This process occurs every time the physical size of our component changes, our keyboard initializes (the measurementChanged flag is responsible for this, which we simply set to true in the onMeasure method).  Thus, we will not calculate the key positions each time we draw. <br><br><div class="spoiler">  <b class="spoiler_title">Initialization code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeInstrument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measuredHeight, Context context)</span></span></span><span class="hljs-function"> </span></span>{ whiteKeyWidth = Math.round(measuredHeight / WHITE_KEY_ASPECT_RATIO); octaveWidth = whiteKeyWidth * <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blackHalfWidth = octaveWidth / <span class="hljs-number"><span class="hljs-number">20</span></span>; blackKeyHeight = Math.round(measuredHeight / BLACK_KEY_HEIGHT_PERCENT); keysArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key[KEYS_IN_OCTAVE * OCTAVES]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> whiteIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blackIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; KEYS_IN_OCTAVE; i++) { Key key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWhite(i)) { key.black = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; key.setBounds(whiteKeyWidth * whiteIndex, whiteKeyWidth * whiteIndex + whiteKeyWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>, measuredHeight); whiteIndex++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { key.black = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexDisplacement = i == <span class="hljs-number"><span class="hljs-number">1</span></span> || i == <span class="hljs-number"><span class="hljs-number">3</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>; key.setBounds(whiteKeyWidth * (blackIndex + indexDisplacement) - blackHalfWidth, whiteKeyWidth * (blackIndex + indexDisplacement) + blackHalfWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>, blackKeyHeight); blackIndex++; } key.midiCode = START_MIDI_CODE + i; keysArray[i] = key; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = KEYS_IN_OCTAVE; i &lt; KEYS_IN_OCTAVE * OCTAVES; i++) { Key firstOctaveKey = keysArray[i % KEYS_IN_OCTAVE]; Key key = firstOctaveKey.clone(); key.startX += (i / KEYS_IN_OCTAVE) * octaveWidth; key.endX += (i / KEYS_IN_OCTAVE) * octaveWidth; key.midiCode = START_MIDI_CODE + i; keysArray[i] = key; } }</code> </pre><br></div></div><br><br>  Here we calculate the width of the keys based on the height of the component and build an array of keys.  First the first octave is built, then it is cloned and shifted along the X axis the necessary number of times to obtain the remaining octaves.  Also, each key will have a corresponding MIDI code for each sound.  Midi codes are numbered.  Our first key code will be START_MIDI_CODE.  The code of any key is calculated by adding the start code and the key index in the array. <br><br>  Next - drawing keys.  In a loop across the array of keys, we draw as follows: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSingleKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas, Key key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstVisibleKey, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lastVisibleKey)</span></span></span><span class="hljs-function"> </span></span>{ Drawable drawable = key.black ? blackKeyDrawable : whiteKeyDrawable; drawable.setState(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { key.pressed ? android.R.attr.state_pressed : -android.R.attr.state_pressed }); drawable.setBounds((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) key.startX, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) key.startY, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) key.endX, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) key.endY); drawable.draw(canvas); }</code> </pre><br><br>  The drawing takes place in 2 stages, because first we need to draw white keys, then black keys so that no overlaps occur.  We could have avoided this if the 9-patches for the keys were made not rectangular, with cutouts.  Moreover, it could help us remove unnecessary pixel redraws, but for the purposes of this article, let's keep everything as primitive as possible. <br><br>  Done, our tool is successfully drawn: <br><br><img src="https://habrastorage.org/storage2/e2a/2c9/224/e2a2c9224596cc37b5c87fd111da6cc6.png"><br><br>  Not bad.  Of course, when you click on the keys now nothing happens.  Let's fix it. <br><br><h5>  Key interaction </h5><br>  For user-click interactions, the onTouchEvent method is usually overridden and it defines what the user did ‚Äî touched a finger, performed a gesture, double-tapped, long-tailed, and so on. Fortunately, in most cases, you and I are spared from such troubles. <br>  We will use the GestureDetector class, kindly provided by the platform from its early days. <br><br>  Let's add a <code>private GestureDetector gestureDetector;</code> field to our tool <code>private GestureDetector gestureDetector;</code>  and initialize it <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isInEditMode()) { gestureDetector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GestureDetector(getContext(), gestureListener); } }</code> </pre><br><br>  In the constructor, we pass the listener to the gestureListener, this is the place where we get callbacks from the detector when we detect any gestures. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OnGestureListener gestureListener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GestureDetector.SimpleOnGestureListener() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyboard.touchItem(e.getX(), e.getY())) { invalidate(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e1, MotionEvent e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distanceX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distanceY)</span></span></span><span class="hljs-function"> </span></span>{ resetTouchFeedback(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSingleTapUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e)</span></span></span><span class="hljs-function"> </span></span>{ resetTouchFeedback(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSingleTapUp(e); } };</code> </pre><br><br>  So, the algorithm of work is simple, in the onDown method we pass the coordinates of the keystroke to our keyboard, where we perform the search for the key pressed (the touchItem method calculates its index by the coordinates of the key without having to scan the entire array).  If a key is found, it is marked as pressed, and we call invalidate, which leads to a redraw. <br>  In the remaining methods, we reset the key (when scrolling, finger up, etc.).  This is done by analogy, for example, with a ListView, when we start scrolling a sheet, the selection is cleared. <br>  The next step is to connect the detector to our component.  This is done very simply: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTouchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> action = event.getAction(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == MotionEvent.ACTION_CANCEL) { resetTouchFeedback(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onTouchEvent(event) || gestureDetector.onTouchEvent(event); }</code> </pre><br><br>  Please note that we also check if the <code>ACTION_CANCEL</code> action is <code>ACTION_CANCEL</code> , and in this case, we also reset the selection, since the GestureDetector does not react to it, and if it suddenly happened, we risk staying with the selected key forever. <br><br>  Checking: <br><br><img src="https://habrastorage.org/storage2/38f/385/3a9/38f3853a9aac67669f28c10291f262ae.png"><br><br>  Hooray, now it looks a little more alive.  But we still see only a part of the keyboard ... Do not worry, let's fasten the scrolling. <br>  Adding Scrolling to a Component <br>  So, we will consider first of all how we will shift our contents.  The easiest way is to not move anything, but to draw in the same way, but to move the canvas itself.  The Canvas class allows you to perform affine transformations on yourself. <br>  Let's add a simple field <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xOffset;</code> </pre><br><br>  in our class. <br><br>  Now we extend our onDraw method with the following construction: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (measurementChanged) { measurementChanged = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; keyboard.initializeInstrument(getMeasuredHeight(), getContext()); instrumentWidth = keyboard.getWidth(); } canvas.save(); canvas.translate(-xOffset, <span class="hljs-number"><span class="hljs-number">0</span></span>); keyboard.updateBounds(xOffset, canvasWidth + xOffset); keyboard.draw(canvas); canvas.restore(); }</code> </pre><br><br>  Let's take a look at what we did: <br><ul><li>  canvas.save () - remembers the current state of the canvas.  Creates a kind of control point </li><li>  canvas.translate () - shifts the canvas by a specified distance </li><li>  canvas.restore () - restore the original state of the canvas. </li></ul><br><br>  We also added an updateBounds method to our Keyboard class.  It allows you to transfer the left and right visible border, so that we do not draw the keys that go beyond the screen.  Optimization such. <br><br>  Now that we have added support for scrolling at the drawing stage, we will add it to the user interaction - GestureDetector.  Modify onScroll: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e1, MotionEvent e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distanceX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distanceY)</span></span></span><span class="hljs-function"> </span></span>{ resetTouchFeedback(); xOffset += distanceX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xOffset &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { xOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xOffset &gt; instrumentWidth - getMeasuredWidth()) { xOffset = instrumentWidth - getMeasuredWidth(); } invalidate(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br><br>  Done, now, when we move our finger on our keyboard, it will scroll nicely, without going beyond the border of the keyboard.  But this is not enough for us.  We want to be able to pull a finger and start the keyboard to dangle in inertia - to make fling. <br>  Fortunately, we do not have to calculate the speed of the finger and the distance traveled by it on the screen.  All this for us makes our beloved GestureDetector.  We just need to override the onFling method.  It will help us know that the user has completed fling, as well as its initial characteristics.  But in order to track the scrolling state, interpolate between the initial and of course the points, we need another component - Scroller, or rather, its brother - OverScroller (we want to add glow effects in the future).  Scroller is a very useful component for any kind of scrolling in Android, is used in countless internal components, and implements the standard scrolling behavior. <br>  Add our scroller: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OverScroller scroller;</code> </pre><br><br>  and initialize it in the component constructor. <br><br>  Next, modify the GestureDetector as follows: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OnGestureListener gestureListener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GestureDetector.SimpleOnGestureListener() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e)</span></span></span><span class="hljs-function"> </span></span>{ scroller.forceFinished(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyboard.touchItem(e.getX() / scaleX + xOffset, e.getY())) { invalidate(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e1, MotionEvent e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> velocityX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> velocityY)</span></span></span><span class="hljs-function"> </span></span>{ scroller.fling(xOffset, <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) -velocityX, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, instrumentWidth - getMeasuredWidth(), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br><br>  As can be seen from the code, we start the scroller with the initial offset and speed, we indicate to it the minimum and maximum scrolling. <br><br>  The next step is onDraw <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scroller.computeScrollOffset()) { xOffset = scroller.getCurrX(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (measurementChanged) { measurementChanged = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; keyboard.initializeInstrument(getMeasuredHeight(), getContext()); instrumentWidth = keyboard.getWidth(); } canvas.save(); canvas.scale(scaleX, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); canvas.translate(xOffset , <span class="hljs-number"><span class="hljs-number">0</span></span>); keyboard.updateBounds(xOffset , canvasWidth + xOffset ); keyboard.draw(canvas); canvas.restore(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scroller.isFinished()) { ViewCompat.postInvalidateOnAnimation(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre><br><br>  What has changed here?  For each frame of the animation, we call scroller.computeScrollOffset (), this method returns true if the scroller is animated, then we get the current value of the variable xOffset. <br>  Because the animation involves a series of redraws - at the end of the method, we check whether the scroller has finished animating, and, if not, assign the next frame of the animation.  Thus, until the scroller finishes its work, or is not stopped by force, the onDraw method will be called as often as possible and draw your component. <br><br>  Now our component is nicely scrolling and supports fling.  But something is missing, right?  Not enough standard scrollbars below.  No problem. <br><br><h5>  Adding standard scrollbars </h5><br>  Adding standard scrollbars is like a spell, there are no special secrets here, just a sequence of actions. <br>  First, you need to tell our component that it supports all standard scrolling attributes.  To do this, in our values ‚Äã‚Äãdirectory create an file attrs.xml, in which to add the following definition: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">declare-styleable</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"View"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:fadeScrollbars"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarAlwaysDrawHorizontalTrack"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarAlwaysDrawVerticalTrack"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarDefaultDelayBeforeFade"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarFadeDuration"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarSize"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarStyle"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarThumbHorizontal"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarThumbVertical"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarTrackHorizontal"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbarTrackVertical"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:scrollbars"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">declare-styleable</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Now, add to the constructor: <br><br><pre> <code class="java hljs">setVerticalScrollBarEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setHorizontalScrollBarEnabled(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); TypedArray a = context.obtainStyledAttributes(R.styleable.View); initializeScrollbars(a); a.recycle();</code> </pre><br><br>  The next step is to override the three simplest methods in which we will manage the size and position of the scrollbars: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeHorizontalScrollExtent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canvasWidth; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeHorizontalScrollOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xOffset; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeHorizontalScrollRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instrumentWidth; }</code> </pre><br><br>  The code speaks for itself - in the first method we specify the width of our component, in the second, the current scrolling offset, in the third the size of the entire keyboard (which goes beyond the screen).  Now these scrollbars are left to ‚Äúwake up‚Äù when needed.  The base View class provides a special awakenScrollBars () method for this.  Add the following lines: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!awakenScrollBars()) { invalidate(); }</code> </pre><br><br>  to the onScroll and onFling methods of our GestureDetectorListener. <br><br>  The result - standard scrollbars delight our eyes. <br><br><img src="https://habrastorage.org/storage2/419/dad/819/419dad81954d81937b1e1d0b7de6f348.png"><br><br><h4>  Conclusion </h4><br>  So, in this part we considered the creation of a component, drawing with the help of Drawables, various states of drawables, visual feedback when interacting, scrolling, fling-gesture, creating scrollbars. <br><br>  The article was quite long, so I decided to split it into several parts. <br><br>  In the <a href="http://habrahabr.ru/post/176919/">next</a> part I will tell about: <br><br><ol><li>  Preserving component state when rotating screen </li><li>  adding backlight in overscroll </li><li>  XML parameter passing </li><li>  pinch zoom </li></ol><br><br>  I also have plans for the third part, where I will talk about optimization, about the difference between using ready-made bitmaps and drawing on the canvas (drawCircle, drawText, etc), about getting rid of redrawing, etc. I will write the third article only if the first two readers will like it and there will be interest in appearing third <br><br>  The sources of the finished project for this series of articles are on my github at: <a href="http://goo.gl/VDeuw">goo.gl/VDeuw</a> .  I just want to note that these are clippings from the project <i>under</i> development, and if you find some code that doesn‚Äôt seem to be needed, I probably didn‚Äôt notice it and forgot to cut it. </div><p>Source: <a href="https://habr.com/ru/post/176643/">https://habr.com/ru/post/176643/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176631/index.html">Basics of security of the Android operating system. Native user space, part 2</a></li>
<li><a href="../176633/index.html">Mozilla JavaScript Web Chat</a></li>
<li><a href="../176635/index.html">PHP HTML DOM parser with jQuery like selectors</a></li>
<li><a href="../176637/index.html">A few words about the book "Professional TDD with C #"</a></li>
<li><a href="../176641/index.html">Education at the Computer Science Center: R & D and Practices</a></li>
<li><a href="../176649/index.html">NASA has developed a navigation system for interstellar flights</a></li>
<li><a href="../176651/index.html">English translation of Angular.js</a></li>
<li><a href="../176657/index.html">Increase the security of the RemoteApp server</a></li>
<li><a href="../176659/index.html">Project Unity: 15 gaming consoles in one or play "warm tube games"</a></li>
<li><a href="../176665/index.html">QML application integration with web resources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>