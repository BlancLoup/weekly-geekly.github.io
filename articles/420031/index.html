<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Drawing with Render Targets in the Unreal Engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The render target is essentially a texture that can be written to while the application is running. From the point of view of the engine, they store i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Drawing with Render Targets in the Unreal Engine</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/6ee/ee4/2766eeee4fcc87c31919d427c829ee98.gif"></div><br>  The render target is essentially a texture that can be written to while the application is running.  From the point of view of the engine, they store information such as the base color, normals, and ambient occlusion. <br><br>  From the user's point of view, the render target are mainly used as a kind of additional camera.  You can set the scene capture at some point and save the image in the render target.  You can then display the render target in the mesh, for example, to simulate a surveillance camera. <br><br>  After the release of version 4.13 of the engine, Epic added the ability to draw materials directly to the render target using blueprints.  This feature allows you to create complex effects, such as fluid simulation and snow deformation.  Sounds amazing, right?  But before moving on to such complex effects, it is best to get comfortable with something simple.  What could be simpler than drawing on the render target? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this tutorial you will learn the following: <br><br><ul><li>  Dynamically create a render target using blueprints </li><li>  Show render target on mesh </li><li>  Draw texture on render target </li><li>  Change brush size and texture during gameplay </li></ul><a name="habracut"></a><br><blockquote>  <em>Note:</em> this tutorial assumes that you are already familiar with the basics of working with the Unreal Engine.  If you are new to the Unreal Engine, then learn our series of tutorials from ten parts of the <a href="https://habr.com/post/344394/">Unreal Engine for beginners</a> . </blockquote><br><h2>  Getting Started </h2><br>  Let's start by downloading materials for this tutorial (you can take them <a href="">here</a> ).  Unzip them, go to <em>CanvasPainterStarter</em> and open <em>CanvasPainter.uproject</em> .  If you click <em>Play</em> , you will see the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/e6d/01f/9b9e6d01f6955d5a93f737588f4bb730.jpg"></div><br>  The square in the middle (canvas) is what we will draw on.  The UI elements on the left will be the texture that we will draw and its size. <br><br>  To begin, let's deal with the way that is used for drawing. <br><br><h2>  Way of drawing </h2><br>  The first thing we need is the render target, which is used as the canvas.  To determine where to draw on the render target, we trace the line that comes out of the camera forward.  If the line crosses the canvas, then we can get the intersection in the UV-space. <br><br>  For example, if the canvas has an ideal binding of UV-coordinates, then the intersection in the center will return the value <em>(0.5, 0.5)</em> .  If the line crosses the canvas in the lower right corner, then we get the value <em>(1, 1)</em> .  You can then use simple calculations to calculate the drawing location. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f2/369/fe2/5f2369fe21d9655fa5e7fc0914c6c023.gif"></div><br>  But why get coordinates in UV space?  Why not use the coordinates of this space of the world?  When using the space of the world, we first have to calculate the intersection with respect to the plane.  Also have to take into account the rotation and scale of the plane. <br><br>  When using UV space, all these calculations are not required.  On a plane with an ideal reference of UV-coordinates, the intersection with the middle always returns <em>(0.5, 0.5)</em> , regardless of the location and rotation of the plane. <br><br><blockquote>  <em>Note: The</em> method discussed in this tutorial generally works only with planes or surfaces similar to planes.  For other types of geometry, a more complex method is required, which I will discuss in another tutorial. </blockquote><br>  First we will create the material that will display the render target. <br><br><h2>  Creating canvas material </h2><br>  Go to the <em>Materials</em> folder and open <em>M_Canvas</em> . <br><br>  In this tutorial, we will create the render target dynamically using blueprints.  This means that we will have to adjust the texture as a parameter so that we can pass on its render target.  To do this, create a <em>TextureSampleParameter2D</em> and name it <em>RenderTarget</em> .  Then connect it to <em>BaseColor</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/741/68a/43974168a064c39f35acc53ab09f1c65.jpg"></div><br>  Do not worry about choosing a texture yet - we will deal with this further in blueprints.  Click <em>Apply</em> , and then close <em>M_Canvas</em> . <br><br>  The next step is to create a render target, after which we use it as the canvas material. <br><br><h2>  Creating Render Target </h2><br>  There are two ways to create a render target.  First: create in the editor by clicking on <em>Add New \ Materials &amp; Textures \ Render Target</em> .  This method allows you to conveniently refer to the same render target to several actors.  However, if we need several canvases, we will have to create the render target manually for each canvas. <br><br>  Therefore, it is better to create a render target using blueprints.  The advantage of this approach is that we create render targets only when necessary and they do not inflate the size of the project files. <br><br>  First we need to create a render target and save it as a variable for later use.  Go to the <em>Blueprints</em> folder and open <em>BP_Canvas</em> .  Find the <em>Event BeginPlay</em> and add highlighted nodes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/91a/e85/7ed91ae8543ccf5875dad7828c308ed1.jpg"></div><br>  Set the <em>Width</em> and <em>Height</em> parameters to <em>1024</em> .  So we change the render target resolution to <em>1024 √ó 1024</em> .  The higher the values, the higher the image quality, but the higher the video memory costs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/56f/96c/aeb56f96c38d3ae2606d4f3b2d3abeaf.jpg"></div><br>  Next comes the <em>Clear Render Target 2D</em> node.  We can use this node to set the render target color.  Set the <em>Clear Color</em> value <em>(0.07, 0.13, 0.06)</em> .  At the same time, the entire render target will be filled with a greenish color. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d30/eed/94bd30eedc1f590ffd157c8091d7898e.jpg"></div><br>  Now we need to display the render target in the mesh of the canvas. <br><br><h3>  Render Target Mapping </h3><br>  At this stage, the canvas mesh uses the default material.  To render the render target, you need to create a dynamic instance of <em>M_Canvas</em> and pass the render target to it.  Then you need to apply a dynamic copy of the material to the canvas mesh.  To do this, we add the selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/7d8/1aa/c9a7d81aa770c63cc6cf75f52746c4c3.jpg"></div><br>  First, go to the node <em>Create Dynamic Material Instance</em> and set as the <em>Parent</em> value <em>M_Canvas</em> .  So we will create a dynamic instance of <em>M_Canvas</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da7/f26/2bf/da7f262bfda0215098287d3a2286085b.jpg"></div><br>  Next, go to the <em>Set Texture Parameter Value</em> node and set the <em>Parameter Name</em> value to <em>RenderTarget</em> .  So we will pass the render target to the texture parameter created earlier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c7/8d0/377/7c78d0377ef6a592c05f5cd54d08a89e.jpg"></div><br>  Now the render target will be displayed on the canvas mesh.  Click on <em>Compile</em> and return to the main editor.  Click on <em>Play</em> to see how the canvas will change color. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/949/fd6/53f949fd6ad350b4a016545af0eca47c.jpg"></div><br>  Now that we have a canvas, we need to create a material that can be used as a brush. <br><br><h2>  Creating brush material </h2><br>  Go to the <em>Materials</em> folder.  Create an <em>M_Brush</em> material and open it.  First set the <em>Blend Mode</em> to <em>Translucent</em> .  This will allow us to use textures with transparency. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf2/18a/4b7/cf218a4b7b0e2c57f307cd06d8a92860.jpg"></div><br>  As with the canvas material, we set the texture for the brush in blueprints.  Create a <em>TextureSampleParameter2D</em> and name it <em>BrushTexture</em> .  Connect it as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/097/c49/7d1/097c497d1e50af95c004f9bdfe849897.jpg"></div><br>  Click on <em>Apply</em> , and then close <em>M_Brush</em> . <br><br>  The next thing you need to do is create a dynamic copy of the brush material so that you can change the texture of the brush.  Open <em>BP_Canvas</em> and add highlighted nodes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49d/628/860/49d62886060349fc146ce04c150d539c.jpg"></div><br>  Next, go to the <em>Create Dynamic Material Instance</em> node and set the <em>Parent</em> value to <em>M_Canvas</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e0/009/4aa/8e00094aa61fbd27c527f207b360856b.jpg"></div><br>  We created the brush material, and now we need a function to paint on the render target. <br><br><h2>  Paint on Render Target </h2><br>  Create a new function and name it <em>DrawBrush</em> .  First we need the parameters: the texture used, the size of the brush and the place to draw.  Create the following input data: <br><br><ul><li>  <em>BrushTexture:</em> select type <em>2D Texture</em> <br></li><li>  <em>BrushSize:</em> select <em>float</em> type <br></li><li>  <em>DrawLocation:</em> select type <em>Vector 2D</em> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cb/d2f/e6e2cbd2f9e69222d7bcbe616d30f8b2.jpg"></div><br>  Before drawing a brush, we need to set its texture.  To do this, create the schema shown below.  Make sure that the <em>BrushTexture</em> value is selected as the <em>Parameter Name</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ff/645/efc/0ff645efc2374126884a93b9b3a8c25b.jpg"></div><br>  Now we need to perform a render in the render target.  To do this, create the selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c69/b73/c02/c69b73c027dc7280673644d512498492.jpg"></div><br>  <em>Begin Draw Canvas to Render Target</em> will allow the engine to know that we want to start drawing to a specific render target.  <em>Draw Material</em> allows you to draw material at a specified location with the selected size and rotation. <br><br>  Calculating a drawing position is a two-step process.  First we need to <em>scale the DrawLocation</em> to fit in the render target resolution.  To do this, multiply <em>DrawLocation</em> by <em>Size</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/513/4d2/cbb5134d2311305c42095e53939cc130.jpg"></div><br>  By default, the engine will draw materials using the upper left corner as the starting point.  Therefore, the brush texture will not be centered to us where we want to draw.  To fix this, we need to divide the <em>BrushSize</em> by <em>2</em> , and then subtract the result from the previous step. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/58f/e82/50158fe822073487d12a3099f86c7737.jpg"></div><br>  Then we connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/20a/111/d5820a1117491a78e4e020c4fd13e6ca.jpg"></div><br>  Finally, we need to tell the engine that we want to stop the rendering in the render target.  Add the <em>End Draw Canvas to Render Target</em> node and connect it as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/8ff/a3e/86f8ffa3ecad0a4b3b47fe21f4044eb0.jpg"></div><br>  Now, each time <em>DrawBrush is</em> executed <em>,</em> it will first set the transmitted texture as a texture for the <em>BrushMaterial</em> .  Then it will draw the <em>BrushMaterial</em> in the <em>RenderTarget</em> using the position and size transferred. <br><br>  And the drawing function is ready for this.  Click on <em>Compile</em> and close <em>BP_Canvas</em> .  The next step is to trace the line from the camera and draw at the place of the canvas where the intersection occurred. <br><br><h2>  Trace straight from camera </h2><br>  Before drawing on canvas, we need to specify the brush texture and size.  Go to the <em>Blueprints</em> folder and open the <em>BP_Player</em> .  Then we <em>assign the</em> value <em>T_Brush_01</em> to the variable <em>BrushTexture</em> , and the value <em>500 to the</em> variable <em>BrushSize</em> .  So we will assign a monkey brush with a size of <em>500 √ó 500</em> pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/ab2/b26/a76ab2b267bd2f0ea514b319528eeb26.jpg"></div><br>  Next, you need to trace the line.  Locate <em>InputAxis Paint</em> and create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/cf0/68e/775cf068e5c0820fa2d4539ca6ae3960.jpg"></div><br>  This way we will trace the line, directed straight from the camera, while the player holds down the key assigned to <em>Paint</em> (in our case, this is the <em>left mouse button</em> ). <br><br>  Now we need to check whether the straight canvas has crossed.  Add selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da5/f53/97b/da5f5397b6a59eebdb9fce09541a35d8.jpg"></div><br>  Now, at the intersection of the line and the canvas, the <em>DrawBrush</em> function will be executed, using the brush variables and UV coordinates passed to it. <br><br>  In order for the <em>Find Collision UV</em> node to work, we need to change two parameters.  First, go to the <em>LineTraceByChannel</em> node and turn on the <em>Trace Complex</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/207/f4a/759207f4a22689a21f91f6c244648f75.jpg"></div><br>  Second, go to <em>Edit \ Project Settings</em> , and then to <em>Engine \ Physics</em> .  Turn on <em>Support UV From Hit Results</em> and restart the project. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8f/42d/56b/c8f42d56bac2b1ec4ad15884efa7f51d.jpg"></div><br>  After restarting for drawing on canvas, click <em>Play</em> and <em>left mouse button</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/5ff/ad6/2b35ffad6680fa6349018143397310f3.gif"></div><br>  You can even create several canvases and draw on each of them separately.  This is possible because each canvas dynamically creates its own render target. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/9c6/89e/1519c689ef59642b5fbb6a8dfbd304dc.gif"></div><br>  In the next section, we will implement the functionality for changing the size of the brush by the player. <br><br><h2>  Change brush size </h2><br>  Open <em>BP_Player</em> and locate the <em>InputAxis ChangeBrushSize</em> node.  This axis reference is configured to use <em>the mouse wheel</em> .  To change the size of the brush we just need to change the value of <em>BrushSize</em> depending on the <em>Axis Value</em> .  To do this, create the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/da6/2c8/554da62c836912958e8588e582862a69.jpg"></div><br>  It will add or subtract from <em>BrushSize</em> when the player uses the mouse wheel.  The first multiplication determines the speed of addition or subtraction.  <em>Clamp (float) has been</em> added as a security measure.  It guarantees that the size of the brush will not be less than <em>0</em> or greater than <em>1000</em> . <br><br>  Click on <em>Compile</em> and return to the main editor.  Roll <em>the mouse wheel</em> to change the size of the brush while drawing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/6ee/ee4/2766eeee4fcc87c31919d427c829ee98.gif"></div><br>  In the last section, we will create a functional that allows the player to change the texture of the brush. <br><br><h2>  Change brush texture </h2><br>  First we need an array to store the textures that a player can use.  Open <em>BP_Player</em> and create an <em>array</em> variable.  Choose <em>Texture 2D</em> for it and name it <em>Textures</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/425/45f/db9/42545fdb9060f05e84a1e251be28bc3e.jpg"></div><br>  Then create <em>three</em> elements in <em>Textures</em> .  Give them the following values: <br><br><ul><li>  <em>T_Brush_01</em> </li><li>  <em>T_Brush_02</em> </li><li>  <em>T_Brush_03</em> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93e/a5a/9fb/93ea5a9fb103654bac3448131c9b6d11.jpg"></div><br>  These will be the textures the player can draw with.  To add new textures, just add them to this array. <br><br>  Next, we need a variable to store the current index of the array.  Create an <em>integer</em> variable and name it <em>CurrentTextureIndex</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0f/b87/b82/c0fb87b8243042c1ce3a6d441490b63e.jpg"></div><br>  Next, we need a way to traverse all textures in the loop.  For this tutorial, I set up an action mapping called <em>NextTexture</em> and attached it to the <em>right mouse button</em> .  When a player presses this key, the transition to the next texture must be made.  To do this, locate the <em>InputAction NextTexture</em> node and create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f2/3d1/9ad/3f23d19ad803a74af5a11892dc7e3579.jpg"></div><br>  This scheme will increase <em>CurrentTextureIndex</em> with each click on the <em>right mouse button</em> .  If the index reaches the end of the array, it is again reset to <em>0</em> .  Finally, <em>BrushTexture</em> is set to the corresponding texture. <br><br>  Click on <em>Compile</em> and close the <em>BP_Player</em> .  Click <em>Play</em> and <em>right-click</em> to switch between textures. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/ed0/d25/8f4ed0d25ed9f1944327137905ecba2b.gif"></div><br><h2>  Where to go next? </h2><br>  The finished project can be downloaded <a href="">from here</a> . <br><br>  Render target is an extremely powerful tool and in this tutorial we have touched only the very basics.  If you want to know what render targets are capable of, see <a href="https://www.youtube.com/watch%3Fv%3DQGIKrD7uHu8">Content-Driven Multipass Rendering in UE4</a> .  In this video, there are examples of drawing flow maps, volumetric drawing, fluid simulation, and more. <br><br>  Also check out our <a href="https://www.youtube.com/watch%3Fv%3D1Z-V1Buk6z8">Blueprint Drawing to Render Targets</a> tutorial video to learn how to create a height map drawing tool using the render target. </div><p>Source: <a href="https://habr.com/ru/post/420031/">https://habr.com/ru/post/420031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420019/index.html">Client-server interaction in a new mobile PvP-shooter and game server device: problems and solutions</a></li>
<li><a href="../420021/index.html">Why do you need Splunk? IoT and industrial data</a></li>
<li><a href="../420023/index.html">State saving in android applications</a></li>
<li><a href="../420025/index.html">Smart farm. What will it be?</a></li>
<li><a href="../420029/index.html">As we in 1C: Enterprise, we solve systems of algebraic equations</a></li>
<li><a href="../420033/index.html">How we started registering cash desks for our clients</a></li>
<li><a href="../420035/index.html">GUI on Golang: GTK + 3</a></li>
<li><a href="../420037/index.html">Stream with several cameras made from scrap materials</a></li>
<li><a href="../420041/index.html">War of TypeScript or Conquest of Enum</a></li>
<li><a href="../420045/index.html">Bunker for the date: how I was allowed to walk on the data center RUVDS on the territory of the space plant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>