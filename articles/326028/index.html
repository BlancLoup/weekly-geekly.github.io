<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional Perl Programming in the Examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss functional programming using the example of a search script for broken links using AnyEvent :: HTTP . The following topics w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional Perl Programming in the Examples</h1><div class="post__text post__text-html js-mediator-article"><p>  This article will discuss functional programming using the example of a search script for broken links using <a href="https://metacpan.org/pod/AnyEvent::HTTP">AnyEvent :: HTTP</a> .  The following topics will be covered: </p><br><ul><li>  anonymous subroutines; </li><li>  closures; </li><li>  callbacks; </li></ul><a name="habracut"></a><br><h2 id="anonimnye-podprogrammy">  Anonymous routines </h2><br><p> An anonymous subroutine is declared as well as the usual one, but there is no name between the <code>sub</code> keyword and the opening bracket of the program code block.  In addition, this form of writing is regarded as part of an expression, therefore the declaration of an anonymous subroutine must be terminated with a semicolon or another expression separator, as in most cases: </p><br><pre> <code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ ...   ... };</code> </pre> <br><p>  For example, we implement a subroutine tripling the value passed to it: </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $triple = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $val = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> * $val; }; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $triple-&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment"># 6</span></span></code> </pre> <br><p>  The main advantage of anonymous subroutines is the use of "code as data."  In other words, we save the code to a variable (for example, pass it to a function in the case of callbacks) for further execution. </p><br><p>  Also, anonymous subroutines can be used to create recursions, including in combination with callbacks.  For example, using the token <code>__SUB__</code> , which appeared in the version of Perl <code>5.16.0</code> , and allows you to get a link to the current subroutine, we implement the calculation of factorial: </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-number"><span class="hljs-number">5.16</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $factorial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $x = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $x == <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x * __SUB_<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;($x - <span class="hljs-number"><span class="hljs-number">1</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $factorial-&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment"># 120</span></span></code> </pre> <br><p>  An example of using recursion in conjunction with callbacks will be shown below when considering the problem of finding broken links. </p><br><h2 id="zamykaniya-closures">  Closures </h2><br><p>  As stated in Wikipedia </p><br><blockquote>  A closure is a first-class function whose body contains references to variables that are declared outside the body of this function in the surrounding code and are not its parameters. </blockquote><p>  Essentially, a closure is an analogue of a class in OOP: it provides the functionality and data associated and packaged together.  Consider an example of closure in Perl and a class in C ++: </p><br><h3 id="perl">  Perl </h3><br><pre> <code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplicator</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $multiplier = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>() * $multiplier; }; }</code> </pre> <br><h3 id="c">  C ++ </h3><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">multiplicator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: multiplicator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;mul): multiplier(mul) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * multiplier; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> multiplier; };</code> </pre> <br><p>  Let's analyze the given code: </p><br><ul><li><p>  private variable declaration: </p><br><ul><li>  Perl: </li></ul><br><blockquote>  we first define the lexical ( <code>my</code> ) variable <code>$multiplier</code> ( <code>my $multiplier = shift;</code> ); </blockquote><br><ul><li>  C ++: </li></ul><br><blockquote>  declare a <code>multiplier</code> variable of type <code>int</code> after the access token <code>private</code> ; </blockquote><br></li><li><p>  private variable initialization: </p><br><ul><li>  Perl: </li></ul><br><blockquote>  when creating a variable, initialize the passed value; </blockquote><br><ul><li>  C ++: </li></ul><br><blockquote>  overload the constructor so that it takes a number and in the initialization list we initialize the variable <code>multiplier</code> ; </blockquote><br></li><li><p>  creating a subroutine that multiplies the value passed to it from the previously initialized variable: </p><br><ul><li>  Perl: </li></ul><br><blockquote>  return an anonymous subroutine that takes a parameter as an input and multiplies it with the previously initialized variable <code>$multiplier</code> and returns the resulting value; </blockquote><br><ul><li>  C ++: </li></ul><br><blockquote>  we overload the function call operator <code>()</code> , which takes the parameter <code>n</code> as an input, multiplies it with the variable <code>multiplier</code> and returns the value. </blockquote><br></li></ul><br><p>  To use closures in Perl and class in C ++, they need to be defined, i.e.  create object: </p><br><h3 id="perl-1">  Perl: </h3><br><ul><li>  Object Definition: </li></ul><br><blockquote> <code>my $doubled = multiplicator(2);</code> <br> <br> <code>my $tripled = multiplicator(3);</code> </blockquote> <br><ul><li>  Using: </li></ul><br><blockquote> <code>say $doubled-&gt;(3); # 6</code> <br> <br> <code>say $tripled-&gt;(4); # 12</code> </blockquote> <br><h3 id="c-1">  C ++: </h3><br><ul><li>  Object Definition: </li></ul><br><blockquote> <code>multiplicator doubled(2), tripled(3);</code> </blockquote> <br><ul><li>  Using: </li></ul><br><blockquote> <code>cout &lt;&lt; doubled(3) &lt;&lt; endl; // 6</code> <br> <br> <code>cout &lt;&lt; tripled(4) &lt;&lt; endl; // 12</code> </blockquote> <p>  In C ++, the class object in which the definition operator <code>()</code> defined is often called a functional object, or functor.  Functional objects are most often used as arguments for common algorithms.  For example, in order to add elements of a vector, you can use the for_each algorithm, which applies the transferred function to each element of the sequence and the Sum class with an overloaded operand <code>()</code> , which adds all the elements of the sequence and returns the sum.  Also, instead of the Sum class, you can use lambdas that appeared in C ++ 11. </p><br><h3 id="c-2">  C ++: </h3><br><pre> <code class="hljs vbscript">#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using std::cout; using std::endl; using std::vector; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Sum { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sum() : sum(<span class="hljs-number"><span class="hljs-number">0</span></span>) { }; void operator() (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> n) { sum += n; } inline <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> get_sum() { return sum; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sum; }; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { vector&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; nums{<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">267</span></span>}; Sum s = for_each(nums.begin(), nums.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), Sum()); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    Sum: "</span></span> &lt;&lt; s.get_sum() &lt;&lt; endl; long <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sum_of_elems = <span class="hljs-number"><span class="hljs-number">0</span></span>; for_each(nums.begin(), nums.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [&amp;](<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> n) { sum_of_elems += n; }); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; sum_of_elems &lt;&lt; endl; return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="perl-2">  Perl: </h3><br><pre> <code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for_each</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span>($arr, $cb) = @_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $item (@$arr) { $cb-&gt;($item); } } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; for_each [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">267</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $sum += $_[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $sum;</code> </pre> <br><p>  As you can see from the example, in C ++ we declare the <code>Sum</code> class, which contains: </p><br><ul><li>  private variable <code>sum</code> , which is initialized in the standard constructor; </li><li>  overloaded operator <code>()</code> , which gets each value of dividing and adds to variable <code>sum</code> ; </li><li>  <code>get_sum</code> method for accessing the private variable <code>sum</code> . </li></ul><br><p>  In the Perl example, we create a <code>for_each</code> function that accepts an array reference and an anonymous function.  Next we go through the array, and perform an anonymous function (closure), passing it the next element of the array as a parameter. </p><br><p>  When using the <code>for_each</code> function, we first define a lesbian variable <code>$sum</code> , initialized to zero.  Then, in the <code>for_each</code> function, <code>for_each</code> pass the reference to the array and the function closure, in which we summarize each element of the array into the <code>$sum</code> variable.  After the <code>for_each</code> function is <code>for_each</code> , the <code>$sum</code> variable will contain the sum of the array. </p><br><p>  The analogue of the function closure from the example in Perl, in C ++ is the use of lambda, as shown in the code.  In the Perl example, the closure function passed to a function is also called a callback, or callback function. </p><br><h2 id="funkcii-obratnogo-vyzova-callback">  Callback Functions </h2><br><p>  As can be seen from the <code>for_each</code> example, the callback function is the transfer of executable code as one of the parameters of another code.  Often, the passed function works as a closure, i.e.  It has access to lexical variables and can be defined in other contexts of the program code and can not be accessed directly from the parent function (the function to which the closure / callback was transferred). </p><br><p>  In essence, the callback function is analogous to the polymorphism of functions, namely, it allows you to create more general-purpose functions instead of creating a series of functions that are identical in structure but differ only in certain places by the executed subtasks.  Consider an example of the task of reading from a file and writing to a file.  To do this, we will create two functions reader and writer using Perl (the example was taken from Mikhail Ozerov‚Äôs presentation <a href="https://www.youtube.com/watch%3Fv%3DdnUM2zbTqnE">Lazy iterators to parse heterogeneous data</a> ), and using C ++ we will create the classes Reader_base, Writer_base, ReaderWriter. </p><br><h3 id="perl-3">  Perl </h3><br><div class="spoiler">  <b class="spoiler_title">read_write_file.pl</b> <div class="spoiler_text"><pre> <code class="hljs mel">use strict; use warnings; sub reader { my ($fn, $cb) = @_; open my $in, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, $fn; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (my $ln = &lt;$in&gt;) { chomp $ln; $cb-&gt;($ln); #       } close $in; } sub write_file { my ($fn, $cb) = @_; open my $out, <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>, $fn; $cb-&gt;(sub { #        my $ln = shift; syswrite($out, $ln.$/); }); close $out; } write_file(<span class="hljs-string"><span class="hljs-string">'./out.cvs'</span></span>, sub { my $writer = shift; # sub { my $ln = shift; syswrite() } reader(<span class="hljs-string"><span class="hljs-string">'./in.csv'</span></span>, sub { my $ln = shift; my @fields = split /;/, $ln; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unless substr($fields[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">6</span></span>; @fields = @fields[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]; $writer-&gt;(join(<span class="hljs-string"><span class="hljs-string">';'</span></span>, @fields)); #        }); });</code> </pre> </div></div><br><h3 id="c-3">  C ++ </h3><br><div class="spoiler">  <b class="spoiler_title">Reader_base.hpp</b> <div class="spoiler_text"><pre> <code class="hljs lua">#pragma once #include &lt;iostream&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; #include &lt;fstream&gt; //   - using std::ifstream; using std::getline; using std::cout; using std::runtime_error; using std::endl; using std::cerr; using std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; class Reader_base { public: Reader_base(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;fn_in) : file_name(fn_in) { <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file_name); } virtual ~Reader_base() { infile.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); } virtual void <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;fn_in) { infile.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(fn_in); //  ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! infile.is_open()) throw runtime_error(<span class="hljs-string"><span class="hljs-string">"can't open input file \""</span></span> + file_name + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); } virtual void main_loop() { try { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(getline(infile, line)) { rcallback(line); } } catch(const runtime_error &amp;e) { cerr &lt;&lt; e.what() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Try again."</span></span> &lt;&lt; endl; } } protected: virtual void rcallback(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;ln) { throw runtime_error(<span class="hljs-string"><span class="hljs-string">"Method 'callback' must me overloaded!"</span></span>); }; private: ifstream infile; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name; };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Writer_base.hpp</b> <div class="spoiler_text"><pre> <code class="hljs lua">#pragma once #include &lt;iostream&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; #include &lt;fstream&gt; //   - using std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; using std::ofstream; using std::cout; using std::runtime_error; using std::endl; using std::cerr; class Writer_base { public: Writer_base(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;fn_out) : file_name(fn_out) { <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file_name); } virtual ~Writer_base() { outfile.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); } virtual void <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;fn_out) { outfile.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! outfile.is_open()) throw runtime_error(<span class="hljs-string"><span class="hljs-string">"can't open output file \""</span></span> + file_name + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); } virtual void <span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;ln) { outfile &lt;&lt; ln &lt;&lt; endl; } private: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name; ofstream outfile; };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">ReaderWriter.hpp</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">#pragma once #include <span class="hljs-string"><span class="hljs-string">"Reader.hpp"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Writer.hpp"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ReaderWriter : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Reader_base, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Writer_base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriter(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;fn_in, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;fn_out) : Reader_base(fn_in), Writer_base(fn_out) {} virtual ~ReaderWriter() {} protected: virtual void rcallback(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;ln) { write(ln); } };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">#include <span class="hljs-string"><span class="hljs-string">"ReaderWriter.hpp"</span></span> int main() { ReaderWriter rw(<span class="hljs-string"><span class="hljs-string">"charset.out"</span></span>, <span class="hljs-string"><span class="hljs-string">"writer.out"</span></span>); rw.main_loop(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><p>  Compile as follows: </p><br><pre> <code class="hljs swift">$ g++ -std=<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>++<span class="hljs-number"><span class="hljs-number">11</span></span> -o main main.cpp</code> </pre> <br><p>  Let's analyze the code: </p><br><ul><li><p>  read from file: </p><br><ul><li>  Perl: </li></ul><br><blockquote>  in the <code>reader</code> function we pass the name of the file for reading and callbacks.  First we open the file for reading.  Then in the loop we iterate line by line on the file, in each iteration we call the callback, passing it the next line.  After completing the cycle, we close the file.  If we speak in terms of OOP, then the constructor is responsible for initializing and opening the file, the main loop is responsible for the <code>main_loop</code> method, which <code>main_loop</code> over the file with a callback call.  The file is closed in the destructor.  Kolbek is essentially a virtual method that is overloaded in the descendant and called from the parent.  This analogy can be traced in the example in C ++. </blockquote><br><ul><li>  C ++: </li></ul><br><blockquote>  we in the constructor of the <code>Reader_base</code> class initialize the <code>file_name</code> variable, open the file for reading.  Next, we create a virtual function member, <code>main_loop</code> , in which we loop around the file line by line and pass the string to the member function <code>rcallback</code> , which should be loaded in the child. </blockquote><br></li><li><p>  write to file: </p><br><ul><li>  Perl: </li></ul><br><blockquote>  in the <code>writer</code> function, we pass the name of the file to be written and the callback.  As in the example with the <code>reader</code> function, we first open the file for writing.  Then we call a callback into which we pass another callback (closure), in which we get a string and then write it to a file.  After exiting the callback, we close the file.  If we speak in terms of OOP, then the constructor is responsible for initializing and opening the file.  The write method is responsible for writing to the file, which receives a string as input and writes it to a file.  Then the file is closed in the destructor.  This analogy can be traced in the example in C ++. </blockquote><br><ul><li>  C ++: </li></ul><br><blockquote>  we in the constructor of the class <code>Writer_base</code> initialize the variable <code>file_name</code> , open the file for writing.  Next, we create a virtual member function <code>writer</code> , to which a string is passed to write to the file.  Then the file is closed in the destructor. </blockquote><br></li><li><p>  working with created functions in Perl and classes in C ++: </p><br><ul><li>  Perl: </li></ul><br><blockquote>  we first call the <code>writer</code> function, into which we transfer the name of the file to be written and the callback.  In the callback, we get another callback variable in the <code>$writer</code> variable, which will write the string passed to it to the file.  Then we call the <code>reader</code> function, into which we pass the file name for reading and callback.  In the reader function callback, we get the next line from the file, work with it, and use the <code>$writer</code> callback to write to the file.  As can be seen from the example, the reader‚Äôs callback function is essentially a closure, since  contains a link to the lexical variable <code>$writer</code> . </blockquote><br><ul><li>  C ++: </li></ul><br><blockquote>  we create a <code>ReaderWriter</code> class that uses multiple inheritance and inherits the <code>Reader_base</code> and <code>Writer_base</code> .  In the constructor, we initialize the <code>Reader_base</code> and <code>Writer_base</code> classes <code>Reader_base</code> file name for reading and writing, respectively.  Then we create an overloaded <code>rcallback</code> method that receives the next line and writes to the file using the <code>write</code> method of the <code>Writer_base</code> class.  The overloaded <code>rcallback</code> method is <code>rcallback</code> called from the <code>main_loop</code> method of the <code>main_loop</code> class.  As you can see from the example file main.cpp, to work with classes, an <code>rw</code> object of the <code>ReaderWriter</code> class is <code>ReaderWriter</code> , to the constructor of which the names of the files for reading and writing are transferred.  Then we call the member function <code>main_loop</code> object <code>rw</code> . </blockquote><br></li></ul><br><p>  Next, we consider the complex practical task of finding broken links using AnyEvent :: HTTP, which will use the topics described above ‚Äî anonymous subroutines, closures, and callback functions. </p><br><h2 id="zadacha-poiska-bityh-ssylok">  The task of finding broken links </h2><br><p>  In order to solve the problem of finding broken links (links with response codes 4xx and 5xx), you need to understand how to implement a crawl site.  In essence, the site is a link graph, i.e.  URLs can refer to both external pages and internal pages.  To crawl the site, we will use the following algorithm: </p><br><pre> <code class="hljs pgsql">process_page(current_page): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> link <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the current_page: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> target_page <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> already <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> your graph: <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> a Page <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> represent target_page <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> to_be_scanned <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> a link <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> current_page <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> target_page scan_website(start_page) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> Page <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> start_page to_be_scanned = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(start_page) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_be_scanned <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: current_page = to_be_scanned.pop() process_page(current_page)</code> </pre> <br><p>  The implementation of this task lies in the <a href="https://bitbucket.org/TheAthlete/broken-link-check/src/dc84bd531fa3e108429af5fbb7ae1da8d7151a1b/%3Fat%3Dv1.0">Broken link checker</a> repository. Consider the checker_with_graph.pl script.  First, we initialize the variables <code>$start_page_url</code> (url of the start page), <code>$cnt</code> (the number of URLs to download), create a hash <code>$to_be_scanned</code> and graph <code>$g</code> . </p><br><p>  Then we create the <code>scan_website,</code> function <code>scan_website,</code> into which we pass the limit on the maximum number of URLs for downloading and callbacks. </p><br><pre> <code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_website</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($count_url_limit, $cb) = @_;</code> </pre> <br><p>  First, we initialize the <code>$to_be_scanned</code> hash <code>$to_be_scanned</code> start page. </p><br><pre> <code class="hljs mel"># to_be_scanned = set(start_page) $to_be_scanned-&gt;{$start_page_url}{internal_urls} = [$start_page_url];</code> </pre> <br><p>  A complete analysis of the <code>$to_be_scanned</code> structure will be further, and now it‚Äôs worth paying attention to the fact that the link is internal (internal_urls). </p><br><p>  Next, create an anonymous function and execute it.  Record view </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $do; $do = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ ... }; $do-&gt;();</code> </pre> <br><p>  is a standard idiom and allows you to access the <code>$do</code> variable from a closure, for example, to create a recursion: </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $do; $do = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ ...; $do-&gt;(); ... }; $do-&gt;();</code> </pre> <br><p>  or delete circular reference: </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $do; $do = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ ...; <span class="hljs-keyword"><span class="hljs-keyword">undef</span></span> $do; ... }; $do-&gt;();</code> </pre> <br><p>  In the closure of <code>$do</code> we create a <code>%urls</code> hash into which we add the urls from the <code>$to_be_scanned</code> hash. </p><br><pre> <code class="hljs mel">my %urls; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> my $parent_url (keys %$to_be_scanned) { my $type_urls = $to_be_scanned-&gt;{$parent_url}; # $type_urls - internal_urls|external_urls push @{$urls{$parent_url}}, splice(@{$type_urls-&gt;{internal_urls}}, <span class="hljs-number"><span class="hljs-number">0</span></span>, $max_connects); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (my ($root_domain, $external_urls) = each %{$type_urls-&gt;{external_urls}}) { push @{$urls{$parent_url}}, splice(@$external_urls, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><p>  The <code>%urls</code> hash structure is <code>%urls</code> follows: </p><br><pre> <code class="hljs php">{parent_url1 =&gt; [target_url1, target_url2, target_url3], parent_url2 =&gt; [...]}</code> </pre> <br><p>  Then we execute the function <code>process_page</code> , passing it a link to the <code>%urls</code> and hash. </p><br><pre> <code class="hljs perl">process_page(\%urls, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ ... });</code> </pre> <br><p>  In the <code>process_page</code> function, we save the resulting hash and callback. </p><br><pre> <code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_page</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($current_page_urls, $cb) = @_;</code> </pre> <br><p>  Then we cycle through the url hash, getting a pair <code>(parent_url =&gt; current_urls)</code> and then go through the list of current urls (current_urls) </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($parent_url, $current_urls) = <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> %$current_page_urls) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $current_url (@$current_urls) {</code> </pre> <br><p>  Before proceeding to the consideration of receiving data from the pages, we will make a small digression.  The basic algorithm for parsing a page and getting URLs from it assumes one HTTP GET method, regardless of whether this is internal or external.  In this implementation, two HEAD and GET calls were used to reduce the server load as follows: </p><br><ul><li>  HEAD requests are executed for all external URLs (regardless of whether they are in error or not);  for internal with an error and for non-web pages; </li><li>  HEAD and GET requests are executed for internal web pages without errors; </li></ul><br><p>  So, first we perform the <code>http_head</code> function of the AnyEvent :: HTTP module, passing it the current URL, request parameters and callback. </p><br><pre> <code class="hljs perl">$cv-&gt;begin; http_head $current_url, %params, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{</code> </pre> <br><p>  In the callback, we get the headers (HTTP headers) </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $headers = $_[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br><p>  from which we get the real url (url after redirects) </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $real_current_url = $headers-&gt;{URL};</code> </pre> <br><p>  Then we save the <code>%urls_with_redirects</code> pair <code>(current_url =&gt; real_current_url)</code> to the hash. </p><br><pre> <code class="hljs perl">$urls_with_redirects{$current_url} = $real_current_url <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $current_url <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> $real_current_url;</code> </pre> <br><p>  Further, if an error occurs (status codes 4xx and 5xx), then we output the error to the log and save the header to the hash for further use </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $headers-&gt;{Status} =~ <span class="hljs-regexp"><span class="hljs-regexp">/^[45]/</span></span> &amp;&amp; !($headers-&gt;{Status} == <span class="hljs-number"><span class="hljs-number">405</span></span> &amp;&amp; $headers-&gt;{allow} =~ <span class="hljs-regexp"><span class="hljs-regexp">/\bget\b/i</span></span>) ) { $warn_log-&gt;(<span class="hljs-string"><span class="hljs-string">"$headers-&gt;{Status} | $parent_url -&gt; $real_current_url"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $warn; $note_log-&gt;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ p($headers) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $note; $urls_with_errors{$current_url} = $headers; <span class="hljs-comment"><span class="hljs-comment">#      }</span></span></code> </pre> <br><p>  Otherwise, if the site is internal and this is a web page, </p><br><pre> <code class="hljs mel"> elsif ( #   ($start_page_url_root eq $url_normalization-&gt;root_domain($real_current_url)) #   - &amp;&amp; ($headers-&gt;{<span class="hljs-string"><span class="hljs-string">'content-type'</span></span>} =~ m{^<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>/html}) ) {</code> </pre> <br><p>  then we execute the <code>http_get</code> function, with which we transfer the real current URL obtained above, the request parameters and the callback. </p><br><pre> <code class="hljs perl">$cv-&gt;begin; http_get $real_current_url, %params, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{</code> </pre> <br><p>  In the http_get function <code>http_get</code> we get the headers and body of the page, we decode the page. </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($content, $headers) = @_; $content = content_decode($content, $headers-&gt;{<span class="hljs-string"><span class="hljs-string">'content-type'</span></span>});</code> </pre> <br><p>  Using the <a href="https://metacpan.org/pod/Web::Query">Web :: Query</a> module, we perform the page parsing and getting URLs. </p><br><pre> <code class="hljs perl">w<span class="hljs-string"><span class="hljs-string">q($content)</span></span>-&gt;find(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) -&gt;filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $href = $_[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;attr(<span class="hljs-string"><span class="hljs-string">'href'</span></span>); <span class="hljs-comment"><span class="hljs-comment">#           ,   $href !~ /^#/ &amp;&amp; $href ne '/' &amp;&amp; $href !~ m{^mailto:(?://)?[A-Z0-9+_.-]+@[A-Z0-9.-]+}i &amp;&amp; ++$hrefs{$href} == 1 #      if $href }) -&gt;each(sub { # for each link on the current page</span></span></code> </pre> <br><p>  At each iteration of the <code>each</code> method, we get a link in the callback. </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $href = $_-&gt;attr(<span class="hljs-string"><span class="hljs-string">'href'</span></span>);</code> </pre> <br><p>  and transform it </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$h</span></span>ref = <span class="hljs-string"><span class="hljs-string">$u</span></span>rl_normalization-&gt;canonical(<span class="hljs-string"><span class="hljs-string">$h</span></span>ref); #     <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/contact'</span></span>    (//dev.twitter.com/etc) if (<span class="hljs-string"><span class="hljs-string">$h</span></span>ref =~ m{^/[^/].*}) { <span class="hljs-string"><span class="hljs-string">$h</span></span>ref = <span class="hljs-string"><span class="hljs-string">$u</span></span>rl_normalization-&gt;path(<span class="hljs-string"><span class="hljs-string">$r</span></span>eal_current_url, <span class="hljs-string"><span class="hljs-string">$h</span></span>ref) ; } <span class="hljs-string"><span class="hljs-string">$h</span></span>ref = <span class="hljs-string"><span class="hljs-string">$u</span></span>rl_normalization-&gt;without_fragment(<span class="hljs-string"><span class="hljs-string">$h</span></span>ref);</code> </pre> <br><p>  Next, we check if there is no such link in the column. </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">unless</span></span>($g-&gt;has_vertex($href)) { <span class="hljs-comment"><span class="hljs-comment"># if tarteg_page is not already in your graph</span></span></code> </pre> <br><p>  then we get the root domain of the link (or put it in 'fails') </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $root_domain = $url_normalization-&gt;root_domain($href) || <span class="hljs-string"><span class="hljs-string">'fails'</span></span>;</code> </pre> <br><p>  Then we fill in the <code>$new_urls</code> structure, which is similar to the <code>$to_be_scanned</code> structure and has the following form: </p><br><pre> <code class="hljs php">$new_urls = $to_be_scanned = { parent_url =&gt; { external_urls =&gt; { root_domain1 =&gt; [qw/url1 url2 url3/], root_domain2 =&gt; [qw/url1 url2 url3/], }, internal_urls =&gt; [qw/url url url/], }, };</code> </pre> <br><p>  In the <code>$new_urls</code> structure, we create a pair <code>(parent_url =&gt; target_url)</code> , while <code>target_url</code> divide <code>target_url</code> into several parts, namely, we divide into internal URLs, which we save into an array, and external ones, which we also divide by domains and also save into an array.  This structure reduces the load on sites as follows - we select <code>$max_connects (   )</code> internal URLs and one external URL for each domain at a time, as shown in the closure <code>$do</code> higher when constructing <code>%urls</code> hash.  Accordingly, at the beginning of the <code>scan_website</code> function <code>scan_website</code> we saved the start page as follows: </p><br><pre> <code class="hljs php">$to_be_scanned = { $start_page_url =&gt; { internal_urls =&gt; [$start_page_url], }, };</code> </pre> <br><p>  those.  in this case, both the parent and the current page were the start page (in other cases, these pages are different). </p><br><p>  The construction of this structure is as follows - if the site is internal, then we create the structure </p><br><pre> <code class="hljs perl">$new_urls-&gt;{$real_current_url}<span class="hljs-string"><span class="hljs-string">{internal_urls}</span></span> //= []</code> </pre> <br><p>  otherwise, if the site is internal, the structure </p><br><pre> <code class="hljs perl">$new_urls-&gt;{$real_current_url}<span class="hljs-string"><span class="hljs-string">{external_urls}</span></span>{$root_domain} //= []</code> </pre> <br><p>  and save one of these structures to the <code>$urls</code> variable, which we then use to write to the <code>$new_urls</code> structure. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">push</span></span> @<span class="hljs-variable"><span class="hljs-variable">$urls</span></span>, <span class="hljs-variable"><span class="hljs-variable">$href</span></span>; <span class="hljs-comment"><span class="hljs-comment"># add it to to_be_scanned set</span></span></code> </pre> <br><blockquote>  In this case, we use links to create and work with complex data structures.  The <code>$urls</code> refers to the <code>$new_urls</code> structure, and accordingly, when the <code>$urls</code> variable changes, the <code>$urls</code> structure <code>$new_urls</code> .  More information about data structures and algorithms in Perl can be found in the book "Jon Orwant - Mastering Algorithms with Perl". </blockquote><p>  Then we add a pair to the graph <code>(real_current_url (parent) =&gt; href (current))</code> . </p><br><pre> <code class="hljs php">$g-&gt;add_edge($real_current_url, $href);</code> </pre> <br><p>  After that, we check the structure of <code>$new_urls</code> - if the arrays of <code>internal_urls</code> or <code>external_urls</code> not empty, then output the data to the log and execute the callback, passing it the structure of <code>$new_urls</code> </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_to_be_scanned($new_urls)) { $debug_log-&gt;(($parent_url // <span class="hljs-string"><span class="hljs-string">''</span></span>).<span class="hljs-string"><span class="hljs-string">" -&gt; $real_current_url "</span></span>.p($new_urls)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $debug; $cb-&gt;($new_urls); }</code> </pre> <br><p>  If we did not hit any of the options (error or parsing the internal page), i.e.  the site is external and without errors, then we execute Kolbek </p><br><pre> <code class="hljs perl"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $cb-&gt;(); }</code> </pre> <br><p>  This cobble call is needed when all external sites are on the current <code>$current_urls</code> list, but <code>$to_be_scanned</code> still <code>$to_be_scanned</code> in <code>$to_be_scanned</code> .  Without this call, we will go through the <code>$current_urls</code> list, <code>http_head</code> , and <code>http_head</code> . </p><br><p>  In the process_page function callback, we save the resulting <code>$new_urls</code> structure, </p><br><pre> <code class="hljs perl">process_page(\%urls, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_urls = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>;</code> </pre> <br><p>  combine it with the <code>$to_be_scanned</code> variable. </p><br><pre> <code class="hljs perl">$to_be_scanned = merge($to_be_scanned, $new_urls) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $new_urls;</code> </pre> <br><p>  Next, we check if the number of elements in the graph is greater than or equal to the limit on the number of URLs, then we exit by removing the link to the anonymous subroutine and executing <code>$cv-&gt;send()</code> . </p><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">scalar</span></span>($g-&gt;vertices) &gt;= $count_url_limit) { <span class="hljs-keyword"><span class="hljs-keyword">undef</span></span> $do; $cb-&gt;(); $cv-&gt;<span class="hljs-keyword"><span class="hljs-keyword">send</span></span>; }</code> </pre> <br><p>  Otherwise, if there are URLs to check, </p><br><pre> <code class="hljs perl"> <span class="hljs-keyword"><span class="hljs-keyword">elsif</span></span> (is_to_be_scanned($to_be_scanned)) {</code> </pre> <br><p>  then recursively call an anonymous subroutine </p><br><pre> <code class="hljs sql">$<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>-&gt;();</code> </pre> <br><p>  which call was considered above.               <code>$to_be_scanned</code>  <code>process_page</code> (     ). </p><br><p>   ,        GraphViz    ‚Äî svg, png  ..   : </p><br><pre> <code class="hljs sql">$ perl bin/checker_with_graph.pl -u planetperl.ru -m 500 -c 5 \ -g -f svg -o etc/panetperl_ru.svg -l "broken link <span class="hljs-keyword"><span class="hljs-keyword">check</span></span><span class="hljs-string"><span class="hljs-string">" -r "</span></span>http_//planetperl.ru/<span class="hljs-string"><span class="hljs-string">" $ perl bin/checker_with_graph.pl -u habrahabr.ru -m 500 -c 5 \ -g -f svg -o etc/habr_ru.svg -l "</span></span>broken <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span><span class="hljs-string"><span class="hljs-string">" -r "</span></span>https_//habrahabr.ru/<span class="hljs-string"><span class="hljs-string">" $ perl bin/checker_with_graph.pl -u habrahabr.ru -m 100 -c 5 \ -g -f png -o etc/habr_ru.png -l "</span></span>broken <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span><span class="hljs-string"><span class="hljs-string">" -r "</span></span>https_//habrahabr.ru/<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  Where </p><br><pre> <code class="hljs ruby">--url <span class="hljs-params"><span class="hljs-params">| -u   --max_urls |</span></span> -m      --max_connects <span class="hljs-params"><span class="hljs-params">| -c     --graphviz |</span></span> -g    --graphviz_log_level <span class="hljs-params"><span class="hljs-params">| -e       , . perldoc Log::Handler --format |</span></span> -f    - png, svg, etc --output_file <span class="hljs-params"><span class="hljs-params">| -o     --label |</span></span> -l   --root <span class="hljs-params"><span class="hljs-params">| -r     - ..   twopi     </span></span></code> </pre> <br><p>           PERL_ANYEVENT_VERBOSE,   </p><br><pre> <code class="hljs objectivec">$ <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> PERL_ANYEVENT_VERBOSE=n</code> </pre> <br><p>  n: </p><br><ul><li> 5 (warn) ‚Äî   http </li><li> 6 (note) ‚Äî    http (   $headers) </li><li> 7 (info) ‚Äî     URLs </li><li> 8 (debug) ‚Äî   ,    </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>         Perl,  ,     ‚Äî  ,     .      Perl    C++,    (callbacks)  Perl   -  C++.           AnyEvent::HTTP,         . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326028/">https://habr.com/ru/post/326028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326018/index.html">The organization of components in the project</a></li>
<li><a href="../326020/index.html">Automation QA is a separate command?</a></li>
<li><a href="../326022/index.html">Inkscape in action: sunset with stars</a></li>
<li><a href="../326024/index.html">How to fit all applications in 16 GB of RAM on macOS</a></li>
<li><a href="../326026/index.html">Choosing a chart for one-dimensional data: a geometric model</a></li>
<li><a href="../326030/index.html">Pygest # 7. Releases, articles, interesting projects from the world of Python [March 28, 2017 - April 10, 2017]</a></li>
<li><a href="../326032/index.html">Writing a 2d java game</a></li>
<li><a href="../326034/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ257 (April 3 - 9, 2017)</a></li>
<li><a href="../326036/index.html">PHP Digest number 106 - the latest news, materials and tools (March 26 - April 9, 2017)</a></li>
<li><a href="../326040/index.html">php-cs-fixer: Writing Your Fixer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>