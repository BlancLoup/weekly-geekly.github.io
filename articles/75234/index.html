<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exact time: we measure, we apply</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The purpose of this article is to state the material obtained in the course of work on a problem on how to measure time as accurately as possible and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exact time: we measure, we apply</h1><div class="post__text post__text-html js-mediator-article"> <b>The purpose of this article</b> is to state the material obtained in the course of work on a problem on how to measure time as accurately as possible and how to use these methods in practice, and also to consider options for managing something programmed with the maximum achievable accuracy. <br><br>  <b>The article is intended</b> for readers who already have some experience in programming and who have noticed the problem of the accuracy of the exposure of time intervals of standard functions.  The author of the article, <a href="https://habrahabr.ru/users/begin_end/" class="user_link">begin_end</a> , advises its readers programming in the Delphi language, since all methods are implemented in this language. <br><br>  <b>Our task</b> is to find the best method for accurate measurement of small time intervals (the desired accuracy is 10 ^ -6 seconds), to determine the most effective way of programming delays in the execution of a code, with the same accuracy. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A programmer who has already tried to develop various applications, for example, related to data transfer or signal generation / analysis, could notice that all standard functions ( <i>sleep, beep, GetTickCount</i> , timers) have a large error when working with small time intervals. <a name="habracut"></a>  This is determined by the resolution of the system timer, the value of which for different computers may vary somewhat.  You can learn this permission using the GetSystemTimeAdjustment function: <br><br> <code>BOOL GetSystemTimeAdjustment( <br> PDWORD lpTimeAdjustment, // size, in 100-nanosecond units, of a periodic time adjustment <br> PDWORD lpTimeIncrement, // time, in 100-nanosecond units, between periodic time adjustments <br> PBOOL lpTimeAdjustmentDisabled // whether periodic time adjustment is disabled or enabled <br> );</code> <br> <br>  Let's sort this function for use in Delphi.  LpTimeIncrement records the resolution value of the system timer in units of 100 nanoseconds.  We need to get this value, and output it, for example, in milliseconds.  Such program will turn out ( <a href="http://w.ho.by/tmp/pub_etime/opred_razreshen_syst_timer.txt">see example 1</a> ): <br><br> <code>program SysTmrCycle; <br> <br> {$APPTYPE CONSOLE} <br> <br> uses <br> SysUtils, windows; <br> <br> var a,b:DWORD; c:bool; <br> begin <br> GetSystemTimeAdjustment(a,b,c); <br> WriteLn('System time adjustment: '+FloatToStr(b / 10000)+' ms.'); <br> WriteLn; <br> Writeln('Press any key for an exit...'); <br> Readln; <br> end.</code> <br> <br>  The result of the execution is displayed on the screen, my timer value was equal to 10,0144 milliseconds. <br><br>  What does this quantity really mean?  The fact that the time intervals of the functions will almost always be multiples of this value.  If it is 10,0144 ms, then the <i>sleep</i> function <i>(1000)</i> will cause a delay of 1001.44 ms.  When calling <i>sleep (5), the</i> delay will be approximately 10 ms.  The standard Delphi timer, a TTimer object, is naturally prone to error, but to an even greater degree.  The TTimer object is based on the regular Windows timer, and sends WM_TIMER messages to the window that are not asynchronous.  These messages are placed in the normal message queue of the application and are processed, like all the others.  In addition, WM_TIMER has the lowest priority (excluding WM_PAINT), relative to other messages.  <i>GetMessage</i> sends a WM_TIMER message for processing only when the priority messages in the queue no longer remain - WM_TIMER messages may be delayed for a considerable time.  If the delay time exceeds the interval, the messages are combined together, thus, there is also their loss [1]. <br>  In order to at least make measurements for a comparative analysis of the delay functions, a tool is needed to accurately measure the time intervals for the execution of a certain code segment.  <i>GetTickCount</i> will not work in view of the above.  But the author learned about the possibility of relying on the processor clock frequency, for a certain time interval.  Starting with the Pentium III, the processors usually contain a real-time tag counter, available to programmers, the Time Stamp Counter, <i><b>TSC</b></i> , which is a register of 64 bits, the contents of which are incremented with each processor tick [2].  The counter counting starts from zero each time the computer starts (or hardware resets).  You can get the value of the counter in Delphi as follows ( <a href="http://w.ho.by/tmp/pub_etime/vyvod_rdtsc.txt">see example 2</a> ): <br><br> <code>program rdtsc_view; <br> <br> {$APPTYPE CONSOLE} <br> <br> uses <br> SysUtils, windows; <br> <br> function tsc: Int64; <br> var ts: record <br> case byte of <br> 1: (count: Int64); <br> 2: (b, a: cardinal); <br> end; <br> begin <br> asm <br> db $F; <br> db $31; <br> mov [ts.a], edx <br> mov [ts.b], eax <br> end; <br> tsc:=ts.count; <br> end; <br> <br> begin <br> repeat WriteLn(FloatToStr(tsc)) until false; <br> end.</code> <br> <br>  Here the assembler insertion places the result of the counter into the <i>edx</i> and <i>eax</i> registers, the value of which is then transferred to ts, from where it is available as ts.count of type Int64.  The above program continuously displays the counter values ‚Äã‚Äãin the console.  On some versions of Delphi there is a ready-made <i><b>rdtsc</b></i> command (read time stamp counter), which allows you to immediately get the counter value by the <i>RDTSC</i> function [ <a href="http://ru.wikipedia.org/wiki/Rdtsc">3</a> ] like this: <br><br> <code>function RDTSC: Int64; register; <br> asm <br> rdtsc <br> end;</code> <br> <br>  Suppose we have a counter value, but how to use it?  Very simple.  Based on the fact that the value changes with a constant frequency, it is possible to calculate the difference in the number of processor cycles after the command being examined and before it: <br><br> <code>a:=tsc; <br> Command; <br> b:=tsc-a;</code> <br> <br>  In b there will be the number of processor ticks elapsed during the execution of the Command.  But there is one moment.  The <i>tsc</i> call, which gives us the number of <i>ticks</i> , must itself also spend on it a certain number of ticks.  And, for the accuracy of the result, it must be made, as an amendment, subtracted from the received number of measures: <br><br> <code>a:=tsc; <br> C:=tsc-a; <br> a:=tsc; <br> Command; <br> b:=tsc-aC;</code> <br> <br>  Everything would be fine, but experimentally it turns out that sometimes the values ‚Äã‚Äãof our C amendment differ.  The reason for this was found.  The point here is in particular the functioning of the processor, or rather its pipeline.  Promotion of machine instructions for the conveyor is associated with a number of fundamental difficulties, in the case of each of them the conveyor is idle.  The execution time of the instruction is at best determined by the throughput of the pipeline.  The time interval, which can be guaranteed to believe, getting processor clock cycles - from 50 clock cycles [2].  It turns out that in the case of determining the amendment, the most accurate value will be the minimum value.  Experimentally, it is enough to call the correction function up to 10 times: <br><br> <code>function calibrate_runtime:Int64; <br> var i:byte; tstsc,tetsc,crtm:Int64; <br> begin <br> tstsc:=tsc; <br> crtm:=tsc-tstsc; <br> for i:=0 to 9 do <br> begin <br> tstsc:=tsc; <br> crtm:=tsc-tstsc; <br> if tetsc&lt;crtm then crtm:=tetsc; <br> end; <br> calibrate_runtime:=crtm; <br> end;</code> <br> <br>  Now that we have the necessary tool, let's experiment with the delay functions.  Let's start with the well-known and all applicable <i>sleep</i> : <br><br> <code>procedure Sleep(milliseconds: Cardinal); stdcall;</code> <br> <br>  To check the accuracy of the delay, we include in our console program, in addition to the <i>tsc</i> code and the <i>calibrate_runtime</i> code, the following code: <br><br> <code>function cycleperms(pau_dur:cardinal):Int64; <br> var tstsc,tetsc:Int64; <br> begin <br> tstsc:=tsc; <br> sleep(pau_dur); <br> tetsc:=tsc-tstsc; <br> cycleperms:=(tetsc-calibrate_runtime) div pau_dur; <br> end;</code> <br> <br>  We will call this code from the program, setting different pau_dur values ‚Äã‚Äã(pauses) several times. If you noticed, the number of ticks during the pause is then divided by the pause value.  So we will know the accuracy of the delay depending on her time.  For the convenience of conducting the test and displaying / saving the result of the test, the following code is used ( <a href="http://w.ho.by/tmp/pub_etime/zadayem_interv_cherez_sleep.txt">see Example 3</a> ): <br><br> <code>var test_result,temp_result:string; n:cardinal; i:byte; aver,t_res:Int64; res:TextFile; <br> begin <br> WriteLn('The program will generate a file containing the table of results of measurements of quantity of cycles of the processor in a millisecond. Time of measurement is chosen'+' miscellaneous, intervals: 1, 10, 100, 1000, 10000 ms. You will see distinctions of measurements. If an interval of measurement longer - results will be more exact.'); <br> WriteLn; <br> Writeln('Expected time of check - 1 minute. Press any key for start of the test...'); <br> ReadLn; <br> temp_result:='Delay :'+#9+'Test 1:'+#9+'Test 2:'+#9+'Test 3:'+#9+'Test 4:'+#9+'Test 5:'+#9+'Average:'; <br> n:=1; <br> test_result:=temp_result; <br> WriteLn(test_result); <br> while n&lt;=10000 do <br> begin <br> temp_result:=IntToStr(n)+'ms'+#9; <br> aver:=0; <br> for i:=1 to 5 do <br> begin <br> t_res:=cycleperms(n); <br> aver:=aver+t_res; <br> temp_result:=temp_result+IntToStr(t_res)+#9; <br> end; <br> WriteLn(temp_result+IntToStr(aver div 5)); <br> test_result:=test_result+#13+#10+temp_result+IntToStr(aver div 5); <br> n:=n*10; <br> end; <br> WriteLn; <br> AssignFile(res,'TCC_DEF.xls'); <br> ReWrite(res); <br> Write(res,test_result); <br> CloseFile(res); <br> WriteLn('The test is completed. The data are saved in a file TCC_DEF.xls.'); <br> Writeln('Press any key for an exit...'); <br> ReadLn; <br> end.</code> <br> <br>  In it, we execute <i>cycleperms</i> five times for each time interval (from 1 to 10,000 milliseconds), and also consider the average value.  It turns out the table.  So, the processor clock numbers obtained during this study: <br><img src="http://w.ho.by/tmp/pub_etime/TCC_DEF.png" alt="TCC_DEF"><br><br>  The picture we see is not the best.  Since the processor frequency is approximately 1778.8 MHz ( <a href="http://w.ho.by/tmp/pub_etime/uznaem_chastotu_processora.txt">see Example 4</a> ), the 1-millisecond clock values ‚Äã‚Äãshould tend to an approximate number of 1778800. The accuracy of the <i>sleep</i> function does not give us that in 1, 10, 100, or 1000 milliseconds.  Only for a ten-second period of time values ‚Äã‚Äãare close.  Perhaps, if test 4 were not 1781146, then the average value would be acceptable. <br>  What can be done?  Leave the function and consider something else?  Do not hurry yet.  I learned that you can manually set the reference error of the reference time interval using the <i>timeBeginPeriod</i> function [2]: <br><br> <code>MMRESULT timeBeginPeriod( <br> UINT uPeriod <br> );</code> <br> <br>  To maintain this high-resolution resolution, additional system resources are used, so you need to call <i>timeEndPeriod</i> to release them upon completion of all operations.  Function code cycleperms for the study of such <i>sleep</i> ( <a href="http://w.ho.by/tmp/pub_etime/zadayem_interv_cherez_sleep_tochnee.txt">see example 5</a> ): <br><br> <code>function cycleperms(pau_dur:cardinal):Int64; <br> var tstsc,tetsc:Int64; <br> begin <br> timeBeginPeriod(1); <br> sleep(10); <br> tstsc:=tsc; <br> sleep(pau_dur); <br> tetsc:=tsc-tstsc; <br> timeEndPeriod(1); <br> cycleperms:=(tetsc-calibrate_runtime) div pau_dur; <br> end;</code> <br> <br>  There is also an unexplainable feature, <i>timeBeginPeriod (1)</i> , which sets the resolution to 1 millisecond and does not begin to take effect immediately, but only after calling <i>sleep</i> , therefore <i>sleep (10) is</i> inserted into the code after <i>timeBeginPeriod</i> .  The results of this study: <br><img src="http://w.ho.by/tmp/pub_etime/TCC.png" alt="Tcc"><br><br>  The observed data is much better.  The average value for 10 seconds is pretty accurate.  The average for 1 millisecond differs from it only by 1.7%.  Accordingly, the difference for 10 ms is 0.056%, for 100 ms - 0.33% (strangely), for 1000 ms - 0.01%.  Smaller than 1 ms interval, cannot be used in <i>sleep</i> .  But it can be firmly said that <i>sleep is</i> suitable for pauses of 1 ms under the condition that <i>timeBeginPeriod (1) is</i> executed, and the accuracy of <i>sleep</i> only increases with the growth of the specified time interval ( <a href="http://w.ho.by/tmp/pub_etime/zad_interv_cher_sleep_tochnee_i_bolshe.txt">see Example 6</a> ). <br><br>  The <i>sleep</i> function is based on the Native API of the <i>NtDelayExecution</i> function, which has the following form [ <a href="http://forums.realcoding.net/lofiversion/index.php/t16146.html">5</a> ]: <br><br> <code>NtDelayExecution( <br> IN BOOLEAN              Alertable, <br> IN PLARGE_INTEGER       DelayInterval );</code> <br> <br>  Let's try to test its delays, like <i>sleep</i> , but it will take into account even microseconds: <br><br> <code>function cyclepermks(pau_dur:Int64):Int64; <br> var tstsc,tetsc,p:Int64; <br> begin <br> p:=-10*pau_dur; <br> tstsc:=tsc; <br> NtDelayExecution(false,@p); <br> tetsc:=tsc-tstsc; <br> cyclepermks:=(tetsc-calibrate_runtime) *1000 div pau_dur; <br> end;</code> <br> <br>  This function is not registered in windows.pas or another file, therefore we will call it by adding a line: <br><br> <code>procedure NtDelayExecution(Alertable:boolean;Interval:PInt64); stdcall; external 'ntdll.dll';</code> <br> <br>  The code in which we call a function and build a table of results should be corrected like this ( <a href="http://w.ho.by/tmp/pub_etime/interval_cherez_NtDelayExecution.txt">see Example 7</a> ): <br><br> <code>var test_result,temp_result:string; n:Int64; i:byte; aver,t_res:Int64; res:TextFile; <br> begin <br> WriteLn('The program will generate a file containing the table of results of measurements of quantity of cycles of the processor in a mikrosecond. Time of measurement is chosen'+' miscellaneous, intervals: 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000 mks. You will see distinctions of measurements. If an interval of measurement longer - results will be more exact.'); <br> WriteLn; <br> Writeln('Expected time of check - 1 minute. Press any key for start of the test...'); <br> temp_result:='Delay :'+#9+'Test 1:'+#9+'Test 2:'+#9+'Test 3:'+#9+'Test 4:'+#9+'Test 5:'+#9+'Average:'; <br> n:=1; <br> test_result:=temp_result; <br> WriteLn(test_result); <br> while n&lt;=10000000 do <br> begin <br> temp_result:='10^'+IntToStr(length(IntToStr(n))-1)+'mks'+#9; <br> aver:=0; <br> for i:=1 to 5 do <br> begin <br> t_res:=cyclepermks(n); <br> aver:=aver+t_res; <br> temp_result:=temp_result+IntToStr(t_res)+#9; <br> end; <br> WriteLn(temp_result+IntToStr(aver div 5)); <br> test_result:=test_result+#13+#10+temp_result+IntToStr(aver div 5); <br> n:=n*10; <br> end; <br> WriteLn; <br> AssignFile(res,'TCC_NTAPI.xls'); <br> ReWrite(res); <br> Write(res,test_result); <br> CloseFile(res); <br> WriteLn('The test is completed. The data are saved in a file TCC_NTAPI.xls.'); <br> Writeln('Press any key for an exit...'); <br> ReadLn; <br> end.</code> <br> <br>  After conducting a study of the delays created by <i>NtDelayExecution</i> , interesting results were obtained: <br><img src="http://w.ho.by/tmp/pub_etime/TCC_NTAPI.png" alt="TCC_NTAPI"><br><br>  It can be seen that it is useless to apply such accuracy on intervals of less than 1 millisecond.  Other delay intervals are somewhat better than <i>sleep</i> without a modified resolution, but worse than with high resolution sleep (in principle, this is understandable, because here we did not create threads with elevated priority, and did not do anything at all to improve accuracy, just like this makes <i>timeBeginPeriod</i> ).  And if you add <i>timeBeginPeriod</i> ?  Let's see what happens: <br><img src="http://w.ho.by/tmp/pub_etime/TCC_NTAPI2.png" alt="NTAPI2"><br><br>  At microsecond intervals, the situation is the same.  But at intervals starting from 1 millisecond the difference with respect to the 10-second value is 0.84%, which is better than the similar use of sleep (1.7%) - <i>NtDelayExecution</i> gives a more accurate delay. <br>  When searching for means of programming delays in the execution of the code, another option was found [ <a href="http://msdn.microsoft.com/en-us/library/ms682492(VS.85).aspx">4</a> ], which seems to provide the ability to specify the interval in microseconds.  This is a <i>WaitableTimer</i> .  You can work with it through the <i>CreateWaitableTimer, SetWaitableTimer, WaitForSingleObjectEx</i> functions.  Type of procedure <i>cyclepermks</i> , where we added <i>WaitableTimer</i> : <br><br> <code>function cyclepermks(pau_dur:Int64):Int64; <br> var tstsc,tetsc,p:Int64; tmr:cardinal; <br> begin <br> tmr:=CreateWaitableTimer(nil, false, nil); <br> p:=-10*pau_dur; <br> tstsc:=tsc; <br> SetWaitableTimer(tmr, p, 0, nil, nil, false); <br> WaitForSingleObjectEx(tmr, infinite, true); <br> CloseHandle(tmr); <br> tetsc:=tsc-tstsc; <br> cyclepermks:=(tetsc-calibrate_runtime2) *1000 div pau_dur; <br> end;</code> <br> <br>  The peculiarity of the use of the <i>WaitableTimer also</i> requires us to modify the calculation of the correction obtained in the <i>calibrate_runtime</i> : <br><br> <code>function calibrate_runtime2:Int64; <br> var i:byte; tstsc,tetsc,crtm, p:Int64; tmr:cardinal; <br> begin <br> tstsc:=tsc; <br> crtm:=tsc-tstsc; <br> for i:=0 to 9 do <br> begin <br> tmr:=CreateWaitableTimer(nil, false, nil); <br> p:=0; <br> tstsc:=tsc; <br> SetWaitableTimer(tmr, p, 0, nil, nil, false); <br> CloseHandle(tmr); <br> crtm:=tsc-tstsc; <br> if tetsc&lt;crtm then crtm:=tetsc; <br> end; <br> calibrate_runtime2:=crtm; <br> end;</code> <br> <br>  After all, <i>SetWaitableTimer</i> and <i>CloseHandle are</i> also executed for the period of the number of processor clock counts we take into account.  Immediately add a call to <i>timeBeginPeriod to the cyclepermks code</i> , hoping for the help of this procedure in increasing accuracy ( <a href="http://w.ho.by/tmp/pub_etime/interval_cherez_WaitableTimer.txt">see Example 8</a> ).  Result table: <br><img src="http://w.ho.by/tmp/pub_etime/TCC_WFSO.png" alt="TCC_WFSO"><br><br>  Alas, here too we did not get the opportunity to set delays for gaps less than millisecond.  The difference of 1 millisecond and 10 seconds is 5%.  In comparison with the previous methods, it is worse. <br>  Before drawing conclusions, I will say a little about the actual measurement of time itself.  In the above studies, the basis of comparisons was the number of processor cycles and each computer has a different one.  If you need to bring it to units of time based on seconds, you need to do the following: using the 10-second delay of <i>NtDelayExecution,</i> get the number of processor cycles in these 10 seconds or find out the duration of one cycle ( <a href="http://w.ho.by/tmp/pub_etime/uznaem_dlit_odnogo_proc_takta.txt">see example 9</a> ).  Knowing the number of processor cycles per unit of time, you can easily convert smaller values ‚Äã‚Äãof the number of processor cycles into time values.  In addition, it is recommended to set the application to real-time priority. <br><br>  <b>Conclusion</b>  As a result of this work, it was found that it is possible to measure time on a computer very accurately (even up to a length of time, calculated at 50 processor cycles).  This problem was solved successfully.  As for the ability to independently set the exact delays in the executable code, the situation is as follows: the best method found allows you to do this with a resolution of no more than 1 millisecond, with an error of resolution in the 1 ms interval of about 0.84%.  This is a <i>NtDelayExecution</i> function with the permission set by the <i>timeBeginInterval</i> procedure.  The disadvantage of the function, compared to the less accurate sleep, is a cumbersome call and being part of an insufficiently documented Native API.  The use of the Native API is not advised because of the possible incompatibility of separate APIs in different operating systems of the Windows family.  In general, the obvious advantage of the <i>NtDelayExecution</i> function still forces you to make a choice in its favor. <br><br>  <b>Examples:</b> <br>  1. <a href="">Determine the resolution of the system timer</a> <br>  2. <a href="">RDTSC output</a> <br>  3. <a href="">Set the interval through sleep</a> <br>  4. <a href="">Find out the frequency of the processor</a> <br>  5. <a href="">Set the interval through sleep more accurately</a> <br>  6. <a href="">We investigate the accuracy of setting the interval through sleep at different values.</a> <br>  7. <a href="">Interval with NtDelayExecution</a> <br>  8. <a href="">Interval by WaitableTimer</a> <br>  9. <a href="">Recognize the duration of one processor cycle</a> <br>  <i>The examples include source code * .dpr files (in Delphi language), a compiled console * .exe application and (some) * .xls table of results already received by the author (in a format supported by MS Excel).</i>  <i><a href="">All examples are one file</a> .</i> <br><br>  <b>Literature:</b> <br>  1. Russinovich M., Solomon D. The internal structure of Microsoft Windows.  - SPb .: Peter, 2005. - 992 p. <br>  2. Shchupak Yu.A.  Win32 API.  Effective application development.  - SPb .: Peter, 2007. - 572 p. <br>  3. RDTSC - Wikipedia [ <a href="http://ru.wikipedia.org/wiki/Rdtsc">http://en.wikipedia.org/wiki/Rdtsc</a> ] <br>  4. CreateWaitableTimer - MSDN [ <a href="http://msdn.microsoft.com/en-us/library/ms682492(VS.85).aspx">http://msdn.microsoft.com/en-us/library/ms682492(VS.85).aspx</a> ] <br>  5. NtDelayExecution - RealCoding [ <a href="http://forums.realcoding.net/lofiversion/index.php/t16146.html">http://forums.realcoding.net/lofiversion/index.php/t16146.html</a> ] <br><br>  The article was written on November 13, 2009, by <a href="https://habrahabr.ru/users/begin_end/" class="user_link">begin_end</a> .  The author discussed some points considered in the article with <a href="https://forum.antichat.ru/member.php%3Fu%3D33866">slesh</a> ', to whom gratitude for such assistance is expressed. <br><habracut></habracut></div><p>Source: <a href="https://habr.com/ru/post/75234/">https://habr.com/ru/post/75234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../75226/index.html">We talk about PyQt4 - seating first</a></li>
<li><a href="../75229/index.html">64 vs 32 - what is the gain?</a></li>
<li><a href="../75230/index.html">Pirate Bay suggests using magnet links.</a></li>
<li><a href="../75231/index.html">How to search correctly?</a></li>
<li><a href="../75232/index.html">Fontcapture. Font Collection</a></li>
<li><a href="../75235/index.html">We protect ourselves in the Torrent network, block unwanted peers and organizations</a></li>
<li><a href="../75239/index.html">Are there any authorities in the programming world for you? If you clicked Yes, who are they?</a></li>
<li><a href="../75240/index.html">IPod dock from retro gadget</a></li>
<li><a href="../75244/index.html">American media profitability</a></li>
<li><a href="../75246/index.html">cogear - site management system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>