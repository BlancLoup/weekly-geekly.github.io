<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Converting a uniformly distributed random variable to a normally distributed one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This question has long been studied in detail, and the polar coordinate method proposed by George Box, Mervin Muller and George Marsaly in 1958 was mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Converting a uniformly distributed random variable to a normally distributed one</h1><div class="post__text post__text-html js-mediator-article">  This question has long been studied in detail, and the polar coordinate method proposed by George Box, Mervin Muller and George Marsaly in 1958 was most widely used.  This method allows to obtain a pair of independent normally distributed random variables with a mean of 0 and variance 1 as follows: <br><img src="https://habrastorage.org/getpro/habr/post_images/09b/69b/03c/09b69b03cb334b96145ef7e9d4db1372.png" alt="marsaglia marsaglia algorithm"><br>  where Z <sub>0</sub> and Z <sub>1</sub> are the desired values, s = u <sup>2</sup> + v <sup>2</sup> , and u and v are random variables uniformly distributed on the segment (-1, 1), chosen in such a way that the condition 0 &lt;s &lt;1 is met. <br>  Many use these formulas without even thinking, and many do not even know about their existence, since they use ready-made implementations.  But there are people who have questions: ‚ÄúWhere did this formula come from?  And why do you get a couple of values ‚Äã‚Äãright away? ‚Äù  Next, I will try to give a clear answer to these questions. <br><br><a name="habracut"></a><br>  To begin, let me remind you what probability density, the distribution function of a random variable, and the inverse function are.  Suppose there is some random variable whose distribution is given by the density function f (x), which has the following form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/70a/dcf/32770adcf49943f3ee71266ce184e003.png" alt="random distribution density">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This means that the probability that the value of this random variable will be in the interval (A, B) is equal to the area of ‚Äã‚Äãthe shaded area.  And as a result, the area of ‚Äã‚Äãthe entire shaded area should be equal to one, since in any case the value of a random variable falls within the domain of definition of the function f. <br>  The distribution function of a random variable is an integral of the density function.  And in this case, its approximate form would be: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c9/401/0b3/9c94010b31d54570e30b725059e0ddad.png" alt="random distribution function"><br><br>  Here the meaning is that the value of a random variable will be less than A with probability B. And as a result, the function never decreases, and its values ‚Äã‚Äãlie in the interval [0, 1]. <br><br>  The inverse function is a function that returns the argument of the source function, if the value of the source function is passed to it.  For example, for the function x <sup>2, the</sup> inverse will be the root extraction function, for sin (x) this is arcsin (x), etc. <br><br>  Since most of the generators of pseudo-random numbers at the output give only a uniform distribution, it is often necessary to convert it to some other one.  In this case, in a normal Gaussian: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/317/64e/b43/31764eb4365ae9ea42cbdd270b6e6513.png" alt="converting uniform distribution to normal gaussian"><br><br>  The basis of all methods of converting a uniform distribution to any other is the method of inverse transformation.  It works as follows.  A function is found which is the inverse of the required distribution function, and a random variable uniformly distributed on the segment (0, 1) is passed to it as an argument.  At the output, we obtain a value with the required distribution.  For clarity, bring the following picture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/309/cad/6fb/309cad6fb481d7e0aaec53eecfd02fb0.png" alt="inverse transform method"><br><br>  Thus, a uniform segment is smeared in accordance with the new distribution, projecting onto another axis through the inverse function.  But the problem is that the integral of the density of the Gaussian distribution is not easy to calculate, so the above scientists had to cheat. <br><br>  There is a chi-square distribution (Pearson distribution), which is the distribution of the sum of squares of k independent normal random variables.  And in the case when k = 2, this distribution is exponential. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/701/440/3d2/7014403d234546a056e52c0a0b744920.png" alt="exponential distribution of random variable"><br><br>  This means that if a point in the rectangular coordinate system has random coordinates X and Y distributed normally, then after transferring these coordinates to the polar system (r, Œ∏) the square of the radius (distance from the origin of coordinates to the point) will be distributed exponentially since the square of the radius is the sum of the squares of the coordinates (according to the law of Pythagoras).  The density of distribution of such points on the plane will look as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16d/7d4/f13/16d7d4f132ef62308530adaa850b3fcc.png" alt="normal Gaussian distribution on the plane"><img src="https://habrastorage.org/getpro/habr/post_images/df7/73b/2e8/df773b2e885b15bbbab2cf67e70ebf5e.png" alt="box-muller method"><br><br>  Since it is equivalent in all directions, the angle Œ∏ will have a uniform distribution in the range from 0 to 2œÄ.  The reverse is also true: if you specify a point in the polar coordinate system using two independent random variables (an angle distributed uniformly and a radius distributed exponentially), then the rectangular coordinates of this point will be independent normal random variables.  And the exponential distribution from the uniform is already much easier to obtain using the same inverse transform method.  This is the essence of the polar Box-Muller method. <br>  Now we derive the formulas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91d/39d/f7f/91d39df7fe1d7e3ecaf092fd21218c83.png" alt="polar box-muller method">  (one) <br><br>  To obtain r and Œ∏, we need to generate two randomly distributed random variables on the segment (0, 1) (we will call them u and v), the distribution of which one (say v) should be converted to exponential to obtain the radius.  The exponential distribution function is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c5/01a/c9c/4c501ac9c753178a12c68fc3c2db69e5.png" alt="exponential distribution function"><br><br>  Back to her function: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c1/719/116/3c1719116b0ef3f22c4efd9c935ecd71.png" alt="inverse exponential distribution function"><br><br>  Since the uniform distribution is symmetrical, then the transformation will work in the same way as <br><br><img src="https://habrastorage.org/getpro/habr/post_images/171/bce/234/171bce2346fd463510d88b8bba7aa5b5.png" alt="normal to exponential"><br><br>  From the chi-square distribution formula, it follows that Œª = 0.5.  Substitute Œª, v into this function and get the square of the radius, and then the radius itself: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/239/161/36d/23916136d8a979719d7b41ef644b1f72.png" alt="image"><br><br>  The angle we get, stretching a single segment to 2œÄ: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5f/ea8/250/a5fea82501b2d0ff6ec4809c960298f9.png" alt="image"><br><br>  Now we substitute r and Œ∏ into formulas (1) and we get: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/257/528/8ba/2575288ba7ab19575428aa9e0680e797.png" alt="box-muller mueller boxing method">  (2) <br><br>  These formulas are ready to use.  X and Y will be independent and normally distributed with variance 1 and expected value 0. To get a distribution with other characteristics, it is enough to multiply the result of the function by the standard deviation and add the expected value. <br>  But it is possible to get rid of trigonometric functions by setting the angle not directly, but indirectly through the rectangular coordinates of a random point in a circle.  Then through these coordinates it will be possible to calculate the length of the radius vector, and then find the cosine and sine, dividing x and y into it, respectively.  How and why does it work? <br>  Choose a random point from uniformly distributed in a circle of unit radius and denote the square of the length of the radius vector of this point by the letter s: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a7/dbd/375/6a7dbd37579daf0577baa68eecdabe30.png" alt="even distribution in the circle"><br><br>  The choice is made by specifying random rectangular coordinates x and y, uniformly distributed in the interval (-1, 1), and discarding points that do not belong to a circle, as well as a central point at which the angle of the radius vector is not defined.  That is, the condition 0 &lt;s &lt;1 should be satisfied. Then, as in the case of the Gaussian distribution on the plane, the angle Œ∏ will be uniformly distributed.  This is obvious - the number of points in each direction is the same, so each corner is equally likely.  But there is a less obvious fact - s will also have a uniform distribution.  The resulting s and Œ∏ will be independent of each other.  Therefore, we can use the value of s to obtain an exponential distribution without generating a third random variable.  We now substitute s into formulas (2) instead of v, and instead of trigonometric functions, their calculation by dividing the coordinate by the length of the radius vector, which in this case is a root of s: <br><br><img src="http://43318.selcdn.com/static/public/gauss/f8.png" alt="marsaglia marsalla method"><br><br>  We get the formulas, as in the beginning of the article.  The disadvantage of this method is to drop points that are not included in the circle.  That is, using only 78.5% of the generated random variables.  On older computers, the lack of trigonometric functions still gave a big advantage.  Now, when one team of a processor calculates both sine and cosine in an instant, I think these methods can still compete. <br><br>  Personally, I still have two questions: <br><ul><li>  Why is the value of s evenly distributed? </li><li>  Why is the sum of the squares of two normal random variables distributed exponentially? </li></ul><br>  Since s is the square of the radius (for simplicity, I call the length of the radius vector specifying the position of a random point the radius), we first find out how the radii are distributed.  Since the circle is filled uniformly, it is obvious that the number of points with a radius r is proportional to the length of a circle of radius r.  And the circumference is proportional to the radius.  So the density distribution of the radii increases uniformly from the center of the circle to its edges.  And the density function has the form f (x) = 2x on the interval (0, 1).  Coefficient 2 so that the area of ‚Äã‚Äãthe figure under the graph is equal to one.  When such a density is squared, it becomes uniform.  Since theoretically, in this case, it is necessary to divide the density function by the derivative of the transformation function (that is, x <sup>2</sup> ).  And clearly it happens like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a0/9e7/c96/3a09e7c96dbdc0fdda60ace0368ce2ce.png" alt="squaring density"><br><br>  If we make a similar transformation for a normal random variable, then the density function of its square will be similar to a hyperbola.  And the addition of two squares of normal random variables is a much more complicated process associated with double integration.  And the fact that the result will be an exponential distribution, I personally need to check here with a practical method or accept it as an axiom.  And to whom it is interesting, I suggest that you familiarize yourself with the topic, drawing on the knowledge from these books: <br><ul><li>  Wentzel E.S.  Probability theory </li><li>  Knut, D.E.  The Art of Programming, Volume 2 </li></ul><br><br>  In conclusion, I will give an example of the implementation of a generator of normally distributed random numbers in the JavaScript language: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Gauss</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ready = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mean, dev</span></span></span><span class="hljs-function">) </span></span>{ mean = mean == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? <span class="hljs-number"><span class="hljs-number">0.0</span></span> : mean; dev = dev == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : dev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ready) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ready = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second * dev + mean; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u, v, s; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { u = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; v = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; s = u * u + v * v; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span> || s == <span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(<span class="hljs-number"><span class="hljs-number">-2.0</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.log(s) / s); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = r * u; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * v * dev + mean; } }; } g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gauss(); <span class="hljs-comment"><span class="hljs-comment">//   a = g.next(); //         b = g.next(); //   c = g.next(); //         </span></span></code> </pre> <br>  The parameters mean (mathematical expectation) and dev (standard deviation) are optional.  I draw your attention to the fact that the logarithm is natural. </div><p>Source: <a href="https://habr.com/ru/post/208684/">https://habr.com/ru/post/208684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208666/index.html">Monte Carlo method in particle physics</a></li>
<li><a href="../208672/index.html">VKontakte service is not available (at all)</a></li>
<li><a href="../208676/index.html">IPOP - IP over P2P</a></li>
<li><a href="../208678/index.html">Convenient URL generation (CNC). Laravel 4 + third-party packages</a></li>
<li><a href="../208680/index.html">Writing a web service on Go (part one)</a></li>
<li><a href="../208688/index.html">Large retail network Overstock began to accept Bitcoin</a></li>
<li><a href="../208690/index.html">CBOR - New Binary Data Format</a></li>
<li><a href="../208692/index.html">Making difficult conditions</a></li>
<li><a href="../208694/index.html">How to send a letter when you do not know gmail</a></li>
<li><a href="../208700/index.html">How sophomores their desktop environment wrote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>