<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The best time to learn microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Admit, how often did you think about learning the basics of microcontroller programming? Surely you have a few ideas of potential projects in your hea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The best time to learn microcontrollers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/da7/840/e0eda784041bb70778c67e0e99bfcf50.jpg" alt="image"><br>  Admit, how often did you think about learning the basics of microcontroller programming?  Surely you have a few ideas of potential projects in your head, but you never came to realize them.  So: better time to start than it is now just not to find. <br><br>  Why did I decide that this question is interesting for the Habr audience?  It is enough to analyze the number of additions to the favorites of some posts and the conclusions suggest themselves. <br><br>  On the other hand, in my current environment there are a lot of programmers, but almost no imbeders.  When I talk to them on the topic of microcontrollers, I get the impression that many have left their opinion about 10 years ago. <br><a name="habracut"></a><br>  Despite the fact that writing on asm for microcontrollers is easier than for x86 architecture, many people are afraid of it and this serves as an obstacle for them to embedded systems.  Friends, in order to start the microcontroller now, it is not necessary, even, to read the datasheets thoroughly, not to mention knowing its instructions.  Of course, if this is your profession, then the level of immersion is much higher, but tell me how often you, regardless of what professional you are in, do not try to violate the principle of encapsulation until the last and no no yes when creating products. and look at the source of the libraries used?  Now you understand what I mean. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I vaguely remember those times when I did not program microcontrollers.  I started writing on asm, not only because everyone did it, but also because there were practically no normal tools.  I explain the popularity of 8-bit controllers from AVR by the fact that they created very easy-to-use libraries that allow you to create a new project, write a dozen lines of code and get quite a working program (addresses of peripheral devices and interrupt vectors are kindly filled with library creators).  I did not conduct research, it is from my personal memories - I am sure that more intelligent libraries for other controllers existed even earlier, but then we did not know about it. <br><br>  The first really massive 32-bit microcontroller was created by the French office STM.  It was at that moment that many fans got acquainted with the architecture of Cortex-M3 and began to use it widely.  I remember, I simultaneously got 2 controllers in my hands - <a href="http://www.st.com/web/en/catalog/mmc/FM141/FM141/SC1169/SS1031/LN1565">STM32F103</a> and LPC1768.  I had to make a device prototype on one of them as quickly as possible.  Naturally, my choice fell on the first: the French released a library for the periphery called the <a href="http://ru.wikipedia.org/wiki/STM32F10x_Standard_Peripherals_Library">Standard Peripherals Library</a> and all I had to do was launch <a href="http://ru.wikipedia.org/wiki/FreeRTOS">FreeRTOS</a> , connect the necessary peripherals and build the project on the next level of abstraction, without distracting more work with registers.  I also used the skeleton in the future, often bending and pushing the 32-bit Cortex to where the smallest ATtiny would have been, but most often the price allowed (and where it didn‚Äôt allow, or low power consumption was needed, you could use cheap MSP430 and STM8, but it rarely happened). <br><br>  Of course, I‚Äôm misleading if I say that I didn‚Äôt have to fully learn the architecture of the Cortex-M3 and smoke the F103 datasheet - of course, I also had my passion for the <a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a> and StdPeriph_Lib library to prevent rather than help, but the speed of entering new I was struck by a family and even then I realized that the world of controllers was changing and becoming both simpler and more complicated. <br><br>  And so we smoothly got to what I wanted to tell you.  The fact is that the popularity of any Arduino assemblies for a long time did not give rest to the guys from Texas Instruments.  They released <a href="http://www.ti.com/ww/en/launchpad/launchpads.html">MSP430-based launchpads</a> and sold them at lower cost and free shipping, they started a community in which they could upload their projects, they created <a href="http://www.energia.nu/">Energia</a> - fork Arduino, they released Stellaris launchpads, and then renamed them to Tiva C (although here It is about a more global rebranding and adding some new features, the essence has not changed).  I want to talk about the latter. <br><br>  You can buy the <a href="http://www.ti.com/tool/ek-tm4c123gxl">EK-TM4C123GXL loungepad</a> for $ 12.99 with FedEx delivery (that is, you will get it soon enough).  The board is not replete with various electronics, such as Discovery F4 (which has an accelerometer, a sound sensor, a DAC, a bunch of LEDs on board) - everything you find on Tiva C Launchpad is an RGB diode and 2 buttons, but its strength is not in additional devices on the board. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cf/606/c50/9cf606c50ada215dbe7b809a6a6a26d6.png" alt="image"><br><br>  The power of EK-TM4C123GXL in libraries available for download from the TI website called TivaWare.  The fact is that the libraries for their controllers are now being written by everyone, but many of them, unfortunately, are not very different in quality and are more traditional examples than full-fledged libraries that are not ashamed to use in their projects (for the above mentioned LPC1768, NXP they wrote their library almost at the same time as STM, but at that time it was not particularly different in quality).  The library for Tiva C surprises with its standardization, documentation and diversity. <br><br>  A little later, I will offer you to download <a href="http://www.ti.com/tool/sw-tm4c">TivaWare</a> and, if you are not too lazy, after installation you will be able to watch the following directories: <br><ul><li>  Driverlib - drivers for peripheral devices such as adc, gpio and so on are located here (including the header file with macros for calling functions from rom - more on that later) </li><li>  Examples - well here, it is clear, examples.  They are divided into boards, peripherals and project.  In the first, of course, projects for specific debug boards, in the second examples of using peripheral devices and in the third example of a clean project for various development environments (IAR, Keil, CCS) - files are available under the BSD license. </li><li>  Inc - various header files with macros, including the tm4c123gh6pm file, which will be useful to us for creating the simplest project </li><li>  Docs - this is a distinctive feature of TI - simple and clear documentation.  Inside there are several User Guide related to the components described here - DriverLib, Examples, Bootloader, IQmath and so on, as well as user directly to the pad used by us. </li><li>  Sensorlib is what really surprised me: there are drivers for various third-party sensors, such as sht21, lsm303d, MPU6050, and so on.  I like to use the last one (this is such a MEMS assembly from accelerometers and gyroscopes on the same crystal), and I used to connect the library torn from the Invensense examples, so I wrote the source code from TI to me very carefully (besides, I immediately found raw materials with quanterions). </li><li>  IQmath is a library of algorithms optimized for working with floating point numbers on Stellaris (Tiva C) devices. </li><li>  Utils - frequently used utilities for working with the command line, serial port, scheduler, and more. </li><li>  The remaining directories contain a bootloader, raw materials from third-party manufacturers (FreeRTOS, for example), a library for working with USB, drivers for Windows, and so on. </li></ul><br>  In order to run any example on your launch pad, just open the project from the examples / boards / ek-tm4c123gxl folder in your favorite IDE - everything is ready there (I use IAR, so I opened ek-tm4c123gxl.eww and it downloaded to me already configured workspace).  But, you know, almost every microcontroller has such customized examples now, and the real difficulties begin when we try to create something of our own. <br><br>  Ok, let's give up not only the examples but also the customized skeleton of the project - we will start everything from scratch (of course using the file from the libraries).  Immediately a disclaimer: I started working with the pad only today, so I don‚Äôt know almost anything about him or the source code I‚Äôm going to work with.  This is the main leitmotif of the whole article - a person sees Tiva C for the first time and immediately tries to work with it. <br><br>  I wanted to write some complicated and interesting application right away, but then I realized that it would take some time, and I had to urgently publish the article, and so I decided to make a simple example, and then, if you wish, we will do something more interesting. <br><br>  So, the first thing we need is to download and install the library (if you haven't done it yet).  In addition, you need to install an IDE and a flasher. <br><br><div class="spoiler">  <b class="spoiler_title">Where to download?</b> <div class="spoiler_text">  You can download <a href="http://software-dl.ti.com/tiva-c/SW-TM4C/latest/index_FDS.html">this link</a> . If the traffic allows - download the DK-TM4C123G Kit Full Installer - it contains the TivaWare library, documentation and IDE installers (about 3.5Gb). <br>  IDE and Flash Programmer are in the Tools folder. <br>  If not, you can download TivaWare for Tiva C Series, LM Flash Programmer and IDE separately. <br></div></div><br><br>  As an IDE, I will use IAR (hence the examples will be with it), but you can use any of the supported ones. <br><br>  Who does not know, IAR has 2 options for free use - with a time limit and a code size limit.  And, of course, there are other options if these 2 do not suit you (you yourself know which ones).  I will not describe the procedure for installing and registering IAR - everything is simple there, but if you have any difficulties, feel free to ask questions in the comments. <br><br>  So, first of all create a new project.  In the project properties, we will change some settings. <br><br><div class="spoiler">  <b class="spoiler_title">Project Settings</b> <div class="spoiler_text">  Settings, in fact, not so much.  Open the project options and select the correct stone.  On the tab General Options -&gt; Target. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/627/603/0b6/6276030b6d03a6ce4458ea536882ca0b.jpg" alt="image"><br><br>  In the C / C ++ Compiler, on the Preprocessor tab, specify the path to the TivaWare folder.  On the same tab, we will add some constants later. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f3/10e/63a/3f310e63a5f315170df53562dcf2d872.jpg" alt="image"><br><br>  In Debugger, choose TI Stellaris. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ee/a6b/9a0/6eea6b9a0e50a0a6be2882bc19e34370.jpg" alt="image"><br><br>  More detailed settings (if needed) can be seen in the examples (for example, another linker configuration file is used there, not the one suggested by IAR). <br></div></div><br><br>  Now we need to customize the project structure.  I propose to adhere to the structure proposed by TI (as in the examples), but with some differences. <br><br>  In the folder (actually ‚Äúin the group‚Äù, but the folders are somehow familiar) Src we have our source codes.  In the examples, the source files of the library files are also added there, but I believe that this will only confuse the project. <br><br>  The Library folder stores files from the DriverLib.  TI adds there an already compiled file (in the case of IAR, this is driverlib / ewarm / Exe / driverlib.a), you can do the same, but I would suggest adding source instead, and only if necessary - it‚Äôs easier to remember where is found, and the source code is useful.  If you plan to add files from other libraries to the same folder (Utils, for example), then it is better to create another level of hierarchy. <br><br>  The examples are missing, and I didn‚Äôt do it either, but if you write your header files, create an Inc folder. <br><br>  The main thing to remember is that these folders are only for the convenience of the user, they have nothing to do with the placement of files on the disk and have no effect on the compilation. <br><br>  So, in the Src folder, create the file main.c <br><br>  In the Library folder, add startup_ewarm.c - it is needed to properly initialize the interrupt vector.  You can take it from the project_0 (this is in the examples) of the project, for example. <br><br>  Let's start our program with the function main.  Since the RGB LED is connected to port F of our launcher, we blink them. <br><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> main(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> uint32_t ui32Counter; //  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(ui32Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; ui32Counter &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ui32Counter++) { } //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(ui32Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; ui32Counter &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ui32Counter++) { } } }</code> </pre> <br><br>  I think everything is clear: to use types like uint32_t is a good habit, it helps to solve ambiguity with the sizes of variables on different controllers (besides, it conforms to MISRA-C standards);  volatile - tells the compiler that this variable should not be optimized (because we will use it for, in general, a useless operation).  Next is the back-end cycle (as students teach, the program on microcontrollers should never end) and 2 counters for delays. <br>  To compile this code, add to the beginning of the file. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt;</span></span></span></span></code> </pre> <br><br>  Now we will proceed directly to the flashing of the LEDs. <br><br>  <a href="http://www.ti.com/tool/ek-tm4c123gxl">We</a> download the Tiva C Series TM4C123G LaunchPad Evaluation Kit User's Manual file from the <a href="http://www.ti.com/tool/ek-tm4c123gxl">launchpad page</a> and read in the User Switches and RGB User LED section that the diode is connected to the PF1 (red), PF2 (blue) and PF3 (green) pins. <br>  Now open SW-TM4C-DRL-UG (in the TivaWare docs folder) and view the GPIO section.  From the introduction, we understand that the pins must first be configured (configurations, of course, many) to the output.  Here we read that some of the most useful functions are GPIOPinRead () and GPIOPinWrite ().  What they do is clear, it remains to look in their description to clarify the list of parameters.  Immediately we find that the function GPIOPinTypeGPIOOututput () is used to register pins for output.  So, we change comments, in our code on: <br><br><pre> <code class="hljs lisp">GPIOPinTypeGPIOOutput(<span class="hljs-name"><span class="hljs-name">GPIO_PORTF_BASE</span></span>, GPIO_PIN_1|GPIO_PIN_2)<span class="hljs-comment"><span class="hljs-comment">; //  // GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0xFF); GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, 0); // GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0); GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, 0xFF);</span></span></code> </pre><br><br>  To turn on and off the diodes. <br><br>  Naturally, do not forget to add the driverlib / gpio.c file to the Library folder, as well as <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"driverlib/gpio.h"</span></span></span></span></code> </pre><br>  in headlines. <br><br>  In addition, already in the compilation process we notice that it is necessary to add 2 more header files: <br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span></span><span class="hljs-meta"> //    bool,    gpio #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inc/hw_memmap.h"</span></span></span><span class="hljs-meta"> //   .</span></span></code> </pre><br><br>  Now our program looks like this: <br><pre> <code class="hljs kotlin">#include &lt;stdint.h&gt; #include &lt;stdbool.h&gt; #include <span class="hljs-string"><span class="hljs-string">"driverlib/gpio.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"inc/hw_memmap.h"</span></span> void main(void) { <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> uint32_t ui32Counter; GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(ui32Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; ui32Counter &lt; <span class="hljs-number"><span class="hljs-number">2000000</span></span>; ui32Counter++) { } GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, <span class="hljs-number"><span class="hljs-number">0</span></span>); GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(ui32Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; ui32Counter &lt; <span class="hljs-number"><span class="hljs-number">2000000</span></span>; ui32Counter++) { } } }</code> </pre><br><br>  And, if you compile it and run it, you will be able to observe the alternating color change of the diode. <br><br>  But blinking the LED is too easy for us.  Let's go a little further and add support for an I / O port. <br>  Actions are the same.  We find which ports are connected to the UART, read about the configuration of the module in UserGuide, configure it, use the functions for writing to and reading from uart. <br><br>  My uart initialization function was similar to the function from the example, but with one interesting difference.  Here is the initialization from the example: <br><br><pre> <code class="hljs ruby">void ConfigureUART(void) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ Enable the GPIO Peripheral used by the UART. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Enable UART0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Configure GPIO Pins for UART mode. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ROM_GPIOPinConfigure(GPIO_PA0_U0RX); ROM_GPIOPinConfigure(GPIO_PA1_U0TX); ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Use the internal 16MHz oscillator as the UART clock source. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initialize the UART for console I/</span></span>O. /<span class="hljs-regexp"><span class="hljs-regexp">/ UARTStdioConfig(0, 115200, 16000000); }</span></span></code> </pre><br><br>  As you can see, strange functions with the ROM_ prefix are used here - these are special functions that are already stored in the ROM of the launcher microcontroller.  You can read about them in the same UserGuide for DRL.  They are created in order to reduce the size of the code in Flash memory.  Whether you need it or not - you decide, I liked the idea (since I still use the Peripheral Driver Library).  By the way, if you do not know whether the code will be used on the device with pieces of the library in ROM or not - you can use Mapped ROM Calls.  Then the code from ROM will be used if it is there and compiled if it is not. <br><br>  To work with ROM, you need to set up several constants: in the project options, in the C / C ++ Compiler, on the Preprocessor tab, add the TARGET_IS_BLIZZARD_RB1 constant to the Defined Symbols field.  There immediately add PART_TM4C123GH6PM and ewarm - they are needed for successful compilation of library files. <br><br><div class="spoiler">  <b class="spoiler_title">Screen</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage3/362/f50/549/362f5054934cc2daf17ff597429595a6.jpg" alt="image"><br></div></div><br><br>  In addition, you need to add the missing files to the project tree: <br><br><img src="http://habrastorage.org/storage3/2a5/824/f36/2a5824f36aa53201463b188253272a30.jpg" alt="image"><br><br>  So, all we have left is to bring something to the port (you can use any terminal emulator for reading. For example, for Windows I used Real Term).  Then, I suggest counting the letter from the port, check whether it belongs to one of the colors (r, g, b) and change the state of the corresponding pin. <br><br>  You already have the function to initialize the UART.  We change the initialization of the ports to add the third pin (earlier we configured only 2 on the output).  You can output a string to the terminal using the UARTprintf () function;  from the utils / uartstdio.c library (of course, you need to add this to the project and connect the header file). <br><br>  Read the symbol with the function UARTCharGet ().  It enters the cycle until the symbol comes to Uart.  After this, we perform actions on the pins and return to the beginning of the cycle. <br><br><pre> <code class="hljs kotlin">#include &lt;stdint.h&gt; #include &lt;stdbool.h&gt; #include <span class="hljs-string"><span class="hljs-string">"inc/hw_memmap.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"inc/hw_types.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"driverlib/gpio.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"driverlib/rom.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"driverlib/sysctl.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"driverlib/uart.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"driverlib/pin_map.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"utils/uartstdio.h"</span></span> void ConfigureUART(void) { ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); ROM_GPIOPinConfigure(GPIO_PA0_U0RX); ROM_GPIOPinConfigure(GPIO_PA1_U0TX); ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1); UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); UARTStdioConfig(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">115200</span></span>, <span class="hljs-number"><span class="hljs-number">16000000</span></span>); } void main(void) { <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> uint32_t ui32Loop; uint32_t ui32Color; uint8_t ui8Red = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; uint8_t ui8Green = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; uint8_t ui8Blue = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3); ConfigureUART(); UARTprintf(<span class="hljs-string"><span class="hljs-string">"Hello HabraHabr!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { UARTprintf(<span class="hljs-string"><span class="hljs-string">"Please, enter color(r,g,b) \n"</span></span>); ui32Color = UARTCharGet(UART0_BASE); switch (ui32Color) { case <span class="hljs-string"><span class="hljs-string">'r'</span></span>: GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, ui8Red); ui8Red = ~ui8Red; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-string"><span class="hljs-string">'b'</span></span>: GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, ui8Blue); ui8Blue = ~ui8Blue; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-string"><span class="hljs-string">'g'</span></span>: GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, ui8Green); ui8Green = ~ui8Green; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: UARTprintf(<span class="hljs-string"><span class="hljs-string">"Incorrect color! \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><br>  I found an interesting lib in TivaWare - utils / cmdline.  It allows you to create and process commands entered from the command line.  I wanted to make an interesting project using it and several other interesting libraries, but time is running out, so I can write about it later if there is interest (as well as interrupts that are not even mentioned here about FreeRTOS). <br>  Well, now about why I wrote several times about what time is running out and why of all the favorable times for starting controllers now the most favorable: January 22, the <a href="https://www.edx.org/course/utaustinx/utaustinx-ut-6-01x-embedded-systems-1172">Embedded Systems - Shape The World</a> courses start at edX. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/KUtsCLgNomo&amp;xid=17259,15700021,15700186,15700191,15700253,15700256&amp;usg=ALkJrhhMEylQ3REBUZoY3zDxGVRHSBKZrw" frameborder="0" allowfullscreen=""></iframe><br><br>  Registration is free, but if you want to get a standard, you must pay a fee (minimum $ 50).  Personally, I paid $ 50 - not because of the certificate, but simply because of the love for such courses and in their support. <br><br>  To participate, you need to buy a Tiva C lounge pad and a different distribution.  You can buy the latter at any radio market, but you have to hurry with the pad: TI is usually sent via FedEx, but this can take up to 10 days, while a week is left before the course starts. <br><br>  But you should not worry: I do not think that in the first lesson you will immediately need to work with iron, perhaps you can simulate your program. <br><br>  So, a few conclusions.  Using such libraries is a double-edged sword.  On the one hand, it simplifies development, lowers the entry threshold, on the other hand creates an abstraction level that complicates understanding of the basics (there is not a single reference to datasheet throughout the article, and this is wrong: you should always look at datasheets and this is a must for amateur artist in a professional).  But such libraries, unlike Arduino (by the way, Energia supports the described padpad), have one advantage: they do not give you a false understanding of reality.  If you use the library, you understand that a very real device is hidden behind the abstraction and it is not difficult to trace the parallels between functions and real registers. <br><br>  I hope that this material will encourage you to purchase and study (albeit so superficially) this wonderful device.  If you have ideas for projects that you could implement on TM4C123G, but there were difficulties in implementation - feel free to write about it in the comments: we will understand together. </div><p>Source: <a href="https://habr.com/ru/post/209218/">https://habr.com/ru/post/209218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209208/index.html">Physical design of storage structures in Teradata DBMS</a></li>
<li><a href="../209210/index.html"><Extended until February 27!> We are announcing a competition to develop a layout for a 3d kidney print.</a></li>
<li><a href="../209212/index.html">Migrating virtual machines on the fly without vMotion with Veeam Backup & Replication</a></li>
<li><a href="../209214/index.html">Today is the last day when you can use free coupons on COLT</a></li>
<li><a href="../209216/index.html">Additional physical modeling techniques in Teradata</a></li>
<li><a href="../209220/index.html">What unites NASA, Oculus Rift and Kinect 2?</a></li>
<li><a href="../209224/index.html">Happy Birthday, Wikipedia!</a></li>
<li><a href="../209226/index.html">How to move from java to scala in your project</a></li>
<li><a href="../209228/index.html">Creating a client MVC application using RequireJS</a></li>
<li><a href="../209230/index.html">HuGu - the collective player of Vkontakte music on node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>