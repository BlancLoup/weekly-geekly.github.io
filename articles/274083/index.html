<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the C compiler in 40 days</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I suggest you translate the diary of Rui Ueyama, a programmer from Google, which he led while working on the implementation of the C compiler about th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the C compiler in 40 days</h1><div class="post__text post__text-html js-mediator-article">  <i>I suggest you translate the diary of <a href="http://www.sigbus.info/">Rui</a> Ueyama, a programmer from Google, which he led while working on the implementation of the C compiler about three and a half years ago (but only published last December).</i> <i><br></i>  <i>This diary is not of any practical use and is not a tutorial, but I was very interested to read it, I hope you enjoy this story too :)</i> <br><br>  I wrote a C compiler in 40 days, which I called 8cc.  This is a diary written by me at the time.  The code and its history can be viewed on <a href="https://github.com/rui314/8cc">GitHub</a> . <br><a name="habracut"></a><br><h3>  Day 8 </h3><br>  I am writing a compiler.  He started working after writing about 1000 lines of code.  Here are some examples that already work: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; a + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// =&gt; 3 int a = 61; int *b = &amp;a; *b; // =&gt; 61</span></span></code> </pre> <br>  Arrays are correctly converted to pointers, so the code below also works.  Calling functions are also supported. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *c = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%c"</span></span>, *c); <span class="hljs-comment"><span class="hljs-comment">// =&gt; b</span></span></code> </pre><br>  It was not difficult to implement, because  I do it the second time.  I learned how to handle arrays and pointers better. <br><br><h3>  Day 15 </h3><br>  I have come a long way in implementing the compiler and it works surprisingly well.  Nontrivial programs, for example <a href="https://gist.github.com/rui314/2018964">this one</a> - the solving <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D0%25B2%25D0%25BE%25D1%2581%25D1%258C%25D0%25BC%25D0%25B8_%25D1%2584%25D0%25B5%25D1%2580%25D0%25B7%25D1%258F%25D1%2585">problem of eight queens</a> , are compiled and run. <br><br>  Of course he lacks many functions.  These sample programs are chosen not to use them. <br>  The implementation is fairly simple;  there is not even register allocation. <br>  It compiles the source programs into the code of the stack engine, which uses the system stack as the stack.  Each operation requires access to the memory.  But while it suits me. <br><br>  At the beginning, the compiler would fit approximately 20 lines and the only thing that it was able to do is read the integer value from the standard input and start the program which ends immediately returning this integer. <br><br>  Now it contains about 2000 lines.  If you look at git, it seems that it developed in this way: <br><ul><li>  Added "+" and "-" </li><li>  the phases of parsing and code generation are separated </li><li>  Added "*" and "/" </li><li>  added variables (implicitly implying int type) </li><li>  function call added </li><li>  lines added </li><li>  tag generator (tokenizer) and syntax analysis are separated </li><li>  support for declaring basic types </li><li>  pointers and arrays added </li><li>  support for array initialization expressions </li><li>  added "if" </li><li>  feature declaration supported </li><li>  added ‚Äúfor‚Äù and ‚Äúreturn‚Äù </li><li>  pointer assignment is supported </li><li>  "==" added </li><li>  array indexing and pointer arithmetic added </li><li>  Added "++", "-" and "!" </li></ul><br><h3>  Day 17 </h3><br>  I have successfully implemented the structure.  A structure is an object that can occupy more than one machine word.  They are harder to implement than primitive types, but it was easier than I expected. <br><br>  It seems to work as it should;  I can define a structure containing a structure.  I can define a pointer to a structure and dereference it.  Structures containing arrays and arrays of structures also work.  Although I already knew that the code should theoretically work, I was still glad when it really worked, even in such a difficult case. <br><br>  However, I do not feel that I fully understand why this code works correctly.  It feels a bit magical due to its recursive nature. <br><br>  I cannot transfer structures to functions.  In the x86 calling convention, the structure is copied onto the stack and a pointer to it is passed to the function.  But in x86-64, you have to split the structure into several pieces of data and pass them through registers.  It is difficult, so I will postpone it.  Passing structures by value is needed less often than passing pointers to them. <br><br><h3>  Day 18 </h3><br>  Implementing the association was easier, because  it is just a variant of the structure in which all fields have the same offset.  Also implemented the operator "-&gt;".  Easy peasy. <br><br>  Arranging floating-point support was hard.  It seems that implicit type conversion between int and float works, but floating-point numbers cannot be passed to functions.  In my compiler, all function parameters are first placed on the stack, and then written to registers in the order defined in the x86-64 calling convention.  But in this process apparently there is a bug.  It returns a memory access error (SIGSEGV).  It is difficult to debug it, considering the assembler output, because my compiler does not optimize the assembler for reading.  I thought I could finish this in a day, but I was wrong. <br><br><h3>  Day 19 </h3><br>  I wasted my time because I forgot that in accordance with the x86-64 calling convention, the stack frame must be 16 bytes aligned.  I found that printf () drops from SEGV if I pass it some floating point numbers.  I tried to find the conditions under which it can be reproduced.  It turned out that the position of the stack frame matters, which made me think about the requirements of ABI x86-64. <br><br>  I didn‚Äôt take care of it at all, so the stack frame was only 8 byte aligned, but print () didn‚Äôt complain until it took only integers.  This problem can be easily corrected by adjusting the stack frame before calling the CALL instruction.  But such problems can not be avoided if you carefully do not read the specification before writing code. <br><br><h3>  Day 20 </h3><br>  I changed the indentation in the compiler code from 2 to 4. I am more used to using 2-space indents, because these are used in my work at Google.  But for some reason it seems to me that 4 space spaces are more suitable for a ‚Äúbeautiful open source program.‚Äù <br><br>  There is another, more significant, change.  I rewrote the tests from the shell scripts in C. Before this change, each test function compiled by my compiler was linked to main () which was compiled by GCC and then launched by the shell script.  It was slow, because  spawned many processes for each test.  I had no choice when I started the project, because  my compiler didn't have many functions.  For example, he could not compare the result with the expected value due to the lack of comparison operators.  Now it is powerful enough to compile test code.  So I rewrote them to make them faster. <br><br>  I also implemented large types such as long and double.  Code writing was fun because I very quickly succeeded in implementing these functions. <br><br><h3>  Day 21 </h3><br>  I almost finished the implementation of C preprocessor in one day.  Actually, this is the port from my previous attempt to write a compiler. <br><br>  Implementing the C preprocessor is not an easy task. <br><br>  This is part of the C standard, as defined in the specification.  But the specification says too little for it to be useful for self-implementation.  The specification includes several macros with their expanded form, but it says very little about the algorithm itself.  I think she doesn't even explain the details of his expected behavior.  In general, it is underspecified. <br><br>  As far as I know, the PDF in <a href="http://www.spinellis.gr/blog/20060626/">this blog is the</a> only and best resource on how to implement the C preprocessor. The algorithm described in the document (Dave Prosser's algorithm) attempts to deploy as many tokens as possible, avoiding the infinite unfolding of the macro.  Each token has its own history of unfolding, so that tokens do not unfold with the same macro more than once. <br><br>  Preprocessor C itself is an independent language.  It has many features, and only experienced C programmers understand it well. <br><br><h3>  Day 22 </h3><br>  Tried to get the compiler to read the system headers, so now he understands #include.  While I tried, I was getting a lot of errors.  This revealed that my preprocessor still lacks many functions, for example, operators that can only be used in #if.  There are many bugs besides this.  I corrected them as soon as I found them. <br><br>  System header files are large and confusing.  They require many functions from the compiler, such as enum and typedef.  I implemented them one by one, but sometimes I cut corners.  I am trying to read stdio.h.  I have no idea how long this can take. <br><br>  The compiler now consists of 4000 lines.  The small <a href="https://sites.google.com/site/lccretargetablecompiler/">LCC</a> compiler contains 12,000 lines.  Using it as a guide, I think my compiler will soon be able to work like a real C compiler. <br><br>  I'm surprised I wrote 500 lines of code today.  I can work in a stream for 12 hours, but this may be inefficient, because  I get tired without noticing it.  In any case, I must admit that I am a person with a lot of free time. <br><br><h3>  Day 24 </h3><br>  I don't remember what I fixed, but now stdio.h can connect.  This is very cool, because the types of functions defined in the header file are now correctly processed. <br><br>  The scheme I use to implement my compiler involves creating a compiler for a small subset of the language and then developing it into a real C language. Until recently, I didn‚Äôt really try to implement functions that I don‚Äôt fully understand.  I could write as much code as I want and leave the rest.  It was fun. <br><br>  Outside things, such as the header system, have caused many problems.  Now I have to implement all the functions expected from the ‚Äúreal‚Äù C compiler. I did a lot of dirty hacks to read stdio.h.  For example, I implemented a hack to ignore all occurrences of the token "const".  It upsets me. <br><br>  You may ask why not do it in the right way from the very beginning.  I would say that it is not fun.  Too.  For example, the syntax of declaring types in C is too complicated without any sane reason and it is not at all interesting to implement it. <br><br>  Despite this there are some things that I can not avoid.  Probably, I should change my view in order to realize all the functions, from beginning to end.  I may find this interesting as I approach the goal.  Sometimes, I have to write more code than I want in order to achieve a goal. <br><br><h3>  Day 25 </h3><br>  I was stuck for two days with the implementation of the syntax of definitions and declarations without any success.  Why can't I finish this?  I made pointers and structures in one day of work.  I feel that I underestimated it.  Maybe I need a plan? <br><br><h3>  Day 26 </h3><br>  In a difficult situation like this, I probably should remember the fact that the compiler was <a href="https://github.com/rui314/8cc/commit/3764b2071b9601067b81976d80175a0851d0f209">just in one file</a> to see how I‚Äôve made progress in a month.  It simply read the whole through scanf () and printed it through printf ().  Indeed, I very seriously advanced in one month.  Yes, I think I can do it. <br><br><h3>  Day 28 </h3><br>  Finished writing a parser for ads and definitions.  I think the reason why I failed was that I tried to write too many details from the very beginning, so I wrote pseudo-code to make sure I understood everything correctly and then converted it into real code. <br><br>  I have been writing in C for almost 15 years, but only today I felt that I finally understand the type syntax in C. Not surprisingly, I could not write working code.  This is because I just did not understand him correctly. <br><br>  The code I just wrote is too complex and fragile, that even I hardly understand it.  I do not believe that Dennis Ritchie, the creator of C, understood the consequences of what he did.  I suspect that he invented the syntax, wrote the code, which turned out to be more complicated than he expected, and, as a result, was standardized by the ANSI committee.  It‚Äôs hard to implement a standardized language, because you have to do it right.  Rather, it is easier to write your own toy language. <br><br><h3>  Day 29 </h3><br>  Implemented many more operators and cleaned the code. <br><br>  Today, for the first time, my compiler managed to compile one of its files.  When I linked it to other files compiled with GCC, it turned out to be working.  And the resulting compiler also seems to work.  Looks like the goal is getting closer. <br><br><h3>  Day 30 </h3><br>  I implemented switch-case, continue, break and goto today.  When I wrote test cases for goto, the test code quickly turned into a spaghetti code that I could not read.  It made me laugh.  I made sure why <a href="https://ru.wikipedia.org/wiki/Considered_harmful">goto is considered harmful</a> . <br><br><h3>  Day 31 </h3><br>  Implemented functions for varargs, namely va_start, va_arg and va_end.  They are not used often, but I needed them to compile functions, such as printf. <br><br>  The vararg specification for C is not well thought out.  If you pass all function arguments through the stack, va_start can be implemented fairly easily, but on modern processors and in modern calling conventions, arguments are passed through registers to reduce the overhead of calling functions.  Therefore, the specification does not correspond to reality. <br><br>  Roughly speaking, the ABI for x86-64, standardized by AMD, requires that functions with a variable number of arguments copy all registers to the stack in order to prepare for the subsequent call to va_start.  I understand that they had no other choice, but it still looks clumsy. <br><br>  I wondered how other compilers handle functions with a variable number of arguments.  I looked at the TCC headers and it looks like they are not compatible with ABI x86-64.  If the data structure for varargs is different, then the functions passing va_list (such as vprintf) become incompatible.  Or I'm wrong?  [And I‚Äôm really wrong ‚Äî they are compatible.] I also looked at Clang, but it looks confusing.  I did not read it.  If I read too much code from other compilers, it can spoil the fun of my own implementation. <br><br><h3>  Day 32 </h3><br>  After fixing minor problems and adding control sequences for string literals (there were still no '\ 0' and similar things), we managed to compile another file.  I feel confident progress. <br><br>  I tried to implement support functions with more than six parameters, but could not finish it in one day.  In x86-64, the first 6 integer parameters are passed through registers, and the rest through the stack.  Now only transfer via registers is supported.  Passing through the stack is not difficult to implement, but it takes too much time to debug.  I think in my compiler there are no functions with more than six parameters, so I‚Äôll postpone their implementation for now. <br><br><h3>  Day 33 </h3><br>  Three more files compiled today.  Total 6 out of 11. But if we count the lines of code, then this is about 10% of the total.  The remaining files are much larger because they contain the compiler core code. <br><br>  Even worse, in the kernel files I use relatively new C features, such as compound literals and assigned initializers.  They greatly complicate self-compilation.  I should not have used them, but rewriting the code on plain old C will not be productive, so I want to support them in my compiler.  Although it will take time. <br><br><h3>  Day 34 </h3><br>  A few notes on debugging tools.  Since the compiler is a complex piece of code that consists of many steps, a way is needed to somehow investigate it for debugging.  My compiler is no exception;  I implemented several features that I thought were useful. <br><br>  First, the lexical analyzer remembers its reading position and when it is interrupted for unforeseen reasons, it returns this position.  This makes it easy to find a bug when the compiler does not accept valid input data. <br><br>  There is a command line option for printing an internal abstract syntax tree.  If there is an error in the parser, I want to look at the syntax tree. <br><br>  The code generator allows recursion to be used extensively because it generates fragments of assembly code when it crawls an abstract syntax tree.  So I was able to print a mini stack trace for each line of assembly output.  If I notice something wrong, I can trace the code generator by looking at its output. <br><br>  Most internal data structures have functions for converting to strings.  This is useful when using printf for debugging. <br><br>  I always write unit tests when I write a new feature.  Even implementing it, I try to keep the code compiled to run the tests.  Tests are written to be performed in a short period of time, so that you can run them as often as you like. <br><br><h3>  Day 36 </h3><br>  Implemented composite literals and rewrote the initializer of structures and arrays.  I did not like the previous implementation.  Now the initializer is better.  I had to write beautiful code from the very beginning, but since I realized this, only by writing working code, rewriting was inevitable. <br><br>  I think the only feature that is not enough for self-compilation is the assignment of structures.  I hope everything will work as intended without much debugging when it is implemented. <br><br><h3>  Day 37 </h3><br>  The file containing the tokenizer is compiled, but the resulting second-generation compiler does not generate the correct assembler code for some reason.  Although the code generated by the first-generation compiler passes all the tests.  Such an insidious bug. <br><br>  I think that I have no choice but to use printf for debugging, because the second generation is compiled through my compiler, which does not support debugging information.  I added printf in suspicious places.  Printf debug messages were displayed when compiling the second generation, which surprised me a little.  I wanted debug messages to be output only when I <i>use the</i> second generation, so I didn‚Äôt expect the output to work when the second generation <i>is being created</i> . <br><br>  It reminds me of the film "The Beginning".  <i>We have to go deeper to reproduce this bug.</i>  This is the fun part of debugging a self-compiled compiler. <br><br><h3>  Day 38 </h3><br>  I fixed the problem that occurred in the second generation, if the lexical analyzer was self-compiled.  It caused a bug where -1&gt; 0 sometimes returned true (I forgot about the significant extension).  There is another bug in struct layout.  Only three files left. <br><br><h3>  Day 39 </h3><br>  The code generator can now also compile itself.  There are two files left.  The work is almost finished, although I probably should not be overly optimistic.  There may still be unexpected pitfalls. <br><br>  I fixed a lot of problems caused by the poor quality of the code that I wrote at the early stage of this project.  That tired me out. <br><br>  I believed that I had every opportunity for self-compilation, but this is not true.  There is not even a prefix increment / decrement operator.  For some features of C99, I rewrote part of the compiler to make it more convenient to compile.           ,      C,  . <br><br><h3>  40 </h3><br>  Hooray!       ! <br><br>    40 .     ,     C.    ?  ,    ‚Äî         C,        C   .       . <br><br>    ,       ,     ,             . <br><br>      . , ,   ,        . <br><br>    <a href="https://github.com/rui314/8cc/tree/5fdb78be05917a511a1df44c5eb25419d8f6e9d3%3Ffiles%3D1"></a> .   ,    ,            C,       5000 . <br><br><h3>  41 </h3><br>    ,      .   ,   ,       , ,  ,   .     . <br><br>       ,  ,          .    ,  GCC   . <br><br><h3>  42 </h3><br>   ,            ,           . <br><br> ,    "\n" (     ¬´n¬ª)    "\n" (     ).     ,      ,         ASCII   "\n".         ,    ,  .          GCC. <br>      ,   . <br><br>              . ,       Unix           ,          Unix.                 ,     (     )     .     ,             ,  ,      .   ,   ? <br><br><h3>  43 </h3><br>              (operator-precedence parser).  ,    ,          ,        C       (,       ).    ,  ,        .          . <br><br>    ‚Äî         .      . <br><br> ,      ,        ,  ,     .          ,  ,   ,    .         ,      .        ,          . <br><br><h3>  44 </h3><br>      :   ‚Üí   ‚Üí      ‚Üí    ‚Üí x86-64 .  ,       .     ,         ,    . , , ,        . <br><br>    Dragon Book   ,  ,     .   ,          . <br><br>        GCC    .    ,   .      ,       . <br><br><h3>  45 </h3><br>   ,  gcov     .     ,     .    ,      .     . <br><br><h3>  46 </h3><br>  ,       ,    .          ,        ,        . <br><br>        .      .    ,    .        .  ,     ,         . <br><br>      ,         Dragon Book.      ,      - . <br><br><h3>  52 </h3><br>        :            16- ,           .     ,    . <br><br>    :    .    ,          16- .        .    . <br><br>        ,    GCC   ,      .  ,     .   ,      ‚Äî      .    ,            . <br><br>    ,    :      .  C ,    , ,   ,     .       (      ),     .         .         ,         . <br><br>  ,        .    -     . <br><br><h3>  53 </h3><br>     .       GCC,   ‚Äî  ,           .        ABI.    ,               ,       . <br><br>       ,  .          ,   ,    .     ,          .      .   ,   GCC     . <br><br>     :       ,        true,   GCC    8 .  , ,     512 (= 2 <sup>9</sup>  0x100),       true,   GCC  -. GCC              8 ,    false. <br><br> -  , ,       ,    GCC (      )      .  ,    .  -               .      ,    ,  , ,  . <br><br>  x86-64 ABI     ,    8       .   ,         ,      ,    .       .     ‚Äî    ,      ,      . <br><br><h3>  55 </h3><br>   . <br><br>            ,              .     GCC    (,  ,   ): <br><br><ul><li>       . ,  ¬´int x:5¬ª, x   4-  (,  int ‚Äî  32 ). </li><li>        . ,  ¬´int x:10¬ª, x    4- .      ,    ,           . </li></ul><br>         ,   CPU          .      ,   ,    &amp;     .      ,     ,   ,    &amp;,  ¬´¬ª,    ,       . <br><br><h3>  56 </h3><br>   goto (computed goto).  goto      ,   goto         .     C      GCC.   -       switch-case, ,  ,    .    ,     switch-case      goto. <br><br>  goto      . ,      .    ,       . <br><br><h3>  57 </h3><br>  C11 _Generic,         .   ,  ,  GCC 4.6.1   _Generic.            ,  GCC     . <br><br>     typeof(),     GCC.        ,   ,         . <br><br><h3>  58 </h3><br>    C99.  ‚Äî      ,      . , "&lt;:"     "[".         ,    ,   . <br><br>  89  ,   .  ‚Äî   ,      ,      . , printf(¬´huh??!¬ª)   ¬´huh??!¬ª,  ¬´huh|¬ª   "??!"    "|".     .    ,  . <br><br><h3>  62 </h3><br>    <a href="http://www.bellard.org/tcc/">TCC</a> .       -    . <br><br> TCC ‚Äî    C,     20  30  .       x86-64,  , ,   10-20.  ,        . <a href="http://www.bellard.org/"> </a> ,  , ‚Äî . <br><br>        TCC,       .    ,          ,     ,   .       .   ,    ,       -,     ,     . <br><br><h3>  73 </h3><br>      TCC.   ,     ,           TCC.      ,           . </div><p>Source: <a href="https://habr.com/ru/post/274083/">https://habr.com/ru/post/274083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274069/index.html">Perl 6 Developers: Language Ready To Use</a></li>
<li><a href="../274071/index.html">Effective UI tests on Selenide</a></li>
<li><a href="../274075/index.html">Christmas sale: rent a VPS or a server in the Netherlands or the USA and receive from 1 to 3 months as a gift</a></li>
<li><a href="../274077/index.html">Maaaalenka PDF assembly of hardcore articles about GameDev</a></li>
<li><a href="../274081/index.html">John Horton Conway: Life is like a game</a></li>
<li><a href="../274091/index.html">‚ÄúRoslyn is still a very raw technology‚Äù - an interview with Sergey Shkredov, the head of .NET-direction in JetBrains</a></li>
<li><a href="../274093/index.html">Third New Year Call Center: Ultra-fast ReactJS and Typescript Development</a></li>
<li><a href="../274097/index.html">Receptions work in Blender. Part 2</a></li>
<li><a href="../274099/index.html">Who needs Go and why?</a></li>
<li><a href="../274101/index.html">The digest of interesting materials from the world of Drupal # 16</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>