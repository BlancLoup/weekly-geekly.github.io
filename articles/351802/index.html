<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS works: web page rendering engines and tips for optimizing their performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, in the eleventh installment of the JavaScript series, we‚Äôll talk about browser subsystems responsible for rendering web pages. They play a key ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS works: web page rendering engines and tips for optimizing their performance</h1><div class="post__text post__text-html js-mediator-article">  Today, in the eleventh installment of the JavaScript series, we‚Äôll talk about browser subsystems responsible for rendering web pages.  They play a key role in transforming the descriptions of documents made with HTML and CSS into what we see on the screen. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/351802/"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/096/d70/b5a096d70947fb9f7bce4a256a149455.jpg" alt="image"></a> <br><br>  The author of the material said that the company <a href="https://www.sessionstack.com/signup/">SessionStack</a> has to pay great attention to rendering.  In this article, he will share tips on optimizing web pages, taking into account the peculiarities of their visualization. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br><h2>  <font color="#3AC1EF">Overview</font> </h2><br>  When creating web applications, we do not write isolated JS code that deals exclusively with some kind of own ‚Äúinternal‚Äù affairs.  This code is executed in the environment provided by the browser and interacts with it.  Understanding the device of this environment, how it works, what parts it consists of, allows the developer to create better programs, gives him the opportunity to anticipate possible problems with the application that came out. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The figure below shows the main components of the browser.  Let's talk about the role they play in the processing of web pages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0d/cf9/bbf/a0dcf9bbfb167e561c78dde6a8e88611.png"></div><br>  <i><font color="#999999">The main components of the browser</font></i> <br><br><ul><li>  User Interface (User Interface).  This browser component includes the address bar, the ‚ÄúForward‚Äù and ‚ÄúBack‚Äù buttons, the commands for working with bookmarks, and so on.  In general, this is all that the browser displays - with the exception of the area of ‚Äã‚Äãits window, where the displayed web page is located. <br></li><li>  Browser Engine (Browser Engine).  It supports the interaction between the user interface and the rendering engine. <br></li><li>  Rendering Engine (Rendering Engine).  This subsystem is responsible for displaying the web page.  The rendering engine processes HTML and CSS and displays what it did on the screen. <br></li><li>  Network subsystem (Networking).  This subsystem is responsible for the network interaction of the browser with the outside world, in particular, for example, XHR requests are performed by its means.  It supports a platform-independent interface that hides specific implementations of various network mechanisms specific to different platforms.  <a href="https://blog.sessionstack.com/how-modern-web-browsers-accelerate-performance-the-networking-layer-f6efaf7bfcf4">Here</a> you can read details about this subsystem. <br></li><li>  User Interface Support Subsystem (UI Backend).  This subsystem is responsible for displaying basic interface components, such as windows and controls, such as checkboxes.  Here, the browser is provided with a universal interface that does not depend on the platform on which it runs, and this subsystem is based on the possibility of generating user interface elements provided by a specific operating system. <br></li><li>  JavaScript engine (JavaScript Engine).  We analyzed the JS engine in one of the previous <a href="https://habrahabr.ru/company/ruvds/blog/337460/">materials in</a> this series.  This is where JS code is executed. <br></li><li>  Data Persistence Subsystem.  If an application needs local data storage capabilities, it can use various mechanisms provided by this subsystem.  Among them, for example, such APIs as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">localStorage</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> , <a href="https://en.wikipedia.org/wiki/Web_SQL_Database">WebSQL</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystem">FileSystem</a> . <br></li></ul><br>  In this article we will focus on the rendering engine.  It is this browser subsystem that parses and renders HTML and CSS.  And these are the technologies with which the code of web applications written in JavaScript constantly interacts. <br><br><h2>  <font color="#3AC1EF">On various rendering engines</font> </h2><br>  The main task of the rendering engine is to display the requested page in a browser window.  The engine can display HTML documents, XML documents, images.  When using additional plugins, the engine can visualize other types of materials, for example, PDF documents. <br><br>  We know that there are different JS engines that use different browsers.  The same is true for rendering engines.  Here are some popular engines: <br><br><ul><li>  Gecko - used in Firefox browser. <br></li><li>  WebKit - used in the Safari browser. <br></li><li>  Blink - integrated into Chrome and Opera browsers (from the 15th version). <br></li></ul><br><h2>  <font color="#3AC1EF">Webpage Rendering Process</font> </h2><br>  The rendering engine receives the contents of the requested document from the browser‚Äôs network layer.  The rendering process looks like the one below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f24/472/043/f244720436405799957af75a44adc510.png"></div><br>  <i><font color="#999999">Webpage Rendering Process</font></i> <br><br>  Here are the main steps of this process: <br><br><ul><li>  HTML processing to create a DOM tree. <br></li><li>  Creating a render tree. <br></li><li>  Calculation of the parameters of the location of the elements of the rendering tree on the screen, the formation of the page layout. <br></li><li>  Rendering (rendering) the rendering tree. <br></li></ul><br>  Consider these and other steps performed when rendering web pages in more detail. <br><br><h2>  <font color="#3AC1EF">Creating a DOM tree</font> </h2><br>  The first step in the rendering engine is to parse the HTML document and convert what it did to DOM nodes located in the DOM tree.  In this case, the web page, which is presented in the form of HTML code, is converted into a structure similar to that shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66f/4b3/fad/66f4b3fadfe72ed0f956485ed7da5b72.png"></div><br>  <i><font color="#999999">DOM tree</font></i> <br><br>  Each element of this tree containing nested elements is a parent for them.  This is true for all levels of nesting. <br><br><h2>  <font color="#3AC1EF">Creating a CSSOM Tree</font> </h2><br>  CSSOM (CSS Object Model) is a CSS object model.  When the browser is creating the DOM tree of a page, it finds in the <code>head</code> section a <code>link</code> tag that refers to an external CSS file, say, <code>theme.css</code> .  Expecting that he may need this resource to render the page, the browser fulfills the request to download this file.  This file contains plain text, which is a description of the styles applied to the page elements. <br><br>  As in the case of HTML, the engine needs to convert CSS into something the browser can work with - in CSSOM.  The result is a CSSOM tree, shown in the following figure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/b91/ff1/99ab91ff1e81ccace7b5d62a7dccc219.png"></div><br>  <i><font color="#999999">CSSOM tree</font></i> <br><br>  Do you know why CSSOM has a tree structure?  When the final set of styles for the page element is generated, the browser starts with the most general rules applicable to this element represented by the DOM node (for example, if the node is a child of the <code>body</code> element, all styles specified for the <code>body</code> are applied to it) and then recursively specifies computed styles by applying more specific rules. <br><br>  Let us examine the example presented in the previous figure.  Any text contained within the <code>span</code> tag that is placed on the <code>body</code> element is displayed in red and has a font size of <code>16px</code> .  These styles are inherited from the <code>body</code> element.  If the <code>span</code> element is a descendant of the <code>p</code> element, then its contents are not displayed in accordance with the more specific style applied to it. <br><br>  Also note that the above tree is not a full CSSOM tree.  This shows only the styles that we, in our CSS file, decided to override.  Each browser has a standard style set, applied by default, also known as ‚Äúuser agent styles‚Äù (user agent styles).  It is the results of applying these styles that can be seen on a page that has no CSS rules associated with it.  Our styles simply override some of the standard browser styles. <br><br><h2>  <font color="#3AC1EF">Creating a render tree</font> </h2><br>  The instructions on the appearance of elements presented in HTML, combined with information about their styling from the CSSOM tree, are used to form the rendering tree. <br><br>  What it is?  This is a tree of visual elements created in the order in which they will be displayed on the screen.  This is a visual representation of the HTML code of the page, reflecting the influence of the CSS rules corresponding to this page.  The purpose of this tree is to ensure that the elements are displayed in the correct order. <br><br>  The node of the rendering tree is known in the WebKit engine as "renderer" or "render object" (we will call them "rendering objects"). <br><br>  Here is what the rendering tree will look like for the DOM and CSSOM trees shown above. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/00c/07f/95c00c07f371356b64169c68e8c42920.png"></div><br>  <i><font color="#999999">Rendering tree</font></i> <br><br>  Here is a general description of the browser actions that it performs when creating the render tree. <br><br><ul><li>  Starting at the root of the DOM tree, the browser traverses every visible node.  Some sites are invisible (for example, tags that contain links to scripts, meta tags, and so on), their browser skips because they do not affect the appearance of the page.  Some nodes are hidden by means of CSS, the browser also does not include them in the rendering tree.  For example, the <code>span</code> node from our example is not displayed in the render tree, since we have an explicitly specified rule that sets the <code>display: none</code> property for it. <br></li><li>  For each visible node, the browser finds the appropriate CSSOM rules and applies them. <br></li><li>  As a result, a structure is formed containing the visible nodes and the styles calculated for them. <br></li></ul><br>  In order to better understand what is being said here, you can take a look at the source code of the <a href="">RenderObject</a> class from WebKit.  Each rendering object is a rectangular area, usually corresponding to the CSS block of the node.  Information about this block includes its geometrical characteristics, such as width, height and position. <br><br><h2>  <font color="#3AC1EF">Forming page layout</font> </h2><br>  After the rendering object is created and added to the tree, it has not yet been assigned a position and size.  Calculating these values ‚Äã‚Äãis called page layout generation. <br><br>  HTML uses a streaming layout model.  This means that most often the system can calculate the geometric parameters of the elements in one pass.  It uses a coordinate system based on the root rendering object, it uses the coordinates <code>left</code> and <code>top</code> . <br><br>  Layout generation is a recursive process.  It starts at the root object that corresponds to the <code>&lt;html&gt;</code> element of the document.  The process is performed recursively throughout the hierarchical structure of the rendering object, the dimensions and position are calculated for each element that needs it. <br><br>  The position of the root rendering object is <code>0,0</code> .  Its dimensions correspond to the size of the visible part of the browser window (this is called the viewport). <br><br>  The process of forming a layout means assigning to each node the exact position in which it should appear on the page. <br><br><h2>  <font color="#3AC1EF">Render tree rendering</font> </h2><br>  At this stage, the rendering tree is traversed and the <code>paint()</code> methods of rendering objects are called, which perform the output of a graphical representation of the objects on the screen. <br><br>  Visualization, or rendering, can be global or incremental (the page layout is also formed). <br><br><ul><li>  Global rendering means re-rendering the entire rendering tree. <br></li><li>  Incremental rendering is performed in a situation where only some of the rendering objects are changed, moreover, so that it does not affect the entire tree.  The rendering subsystem invalidates the rectangular areas on the screen.  This leads to the fact that the operating system sees them as areas, the contents of which need to be updated and generate a <code>paint</code> event for them.  The operating system performs the redrawing of areas intellectually, combining several areas into one. <br></li></ul><br>  In general, it is important to understand that visualization is a phased process.  To improve the perception of the page by users, the rendering engine tends to display the page as soon as possible.  It will not wait until all HTML has been parsed, in order to proceed to the formation of the rendering tree and the calculation of the page layout parameters.  As a result, some parts of the page will be processed and displayed, while the rendering engine will continue to work with the remaining content of the page, which comes from the network. <br><br><h2>  <font color="#3AC1EF">The order of processing JS-scripts and CSS-files</font> </h2><br>  The analysis and execution of the script is carried out immediately after the page code processing system reaches the <code>&lt;script&gt;</code> .  Document processing is suspended until the script is executed.  This means that this process is performed synchronously. <br><br>  If the script is received from an external source, it must first be downloaded via the network (also synchronously).  Page processing pauses until the script download is complete. <br><br>  HTML5 allows you to indicate the possibility of asynchronous loading and processing of the script using a separate stream. <br><br><h2>  <font color="#3AC1EF">Rendering performance optimization</font> </h2><br>  If you want to optimize your application, taking into account the features of page rendering, there are five main areas that you can control and which need to be addressed. <br><br><ul><li>  Javascript  In previous articles in this series, we talked about how to write an optimized JS code that does not block the user interface, efficiently uses memory, and implements other useful techniques.  When it comes to rendering, we need to consider how the JS code will interact with the DOM elements on the page.  JavaScript can make many changes to the user interface, especially when it comes to one-page applications. <br></li><li>  Calculation styles.  This is the process of determining which CSS rule is applied to a particular element, taking into account the corresponding selectors.  After determining the rules, they are applied and the final style is calculated for each element. <br></li><li>  Formation of the page layout.  After the browser finds out which styles are applied to the element, it can begin to calculate how much space on the screen this element takes and to find its position.  The layout model of a web page indicates that some elements can affect other elements.  For example, the width of a <code>&lt;body&gt;</code> element can affect the width of the child elements, and so on.  All this means that the process of forming a layout is a task that requires intensive calculations.  In addition, the output elements are performed on multiple layers. <br></li><li>  Rendering.  This is where the conversion of everything that was previously calculated to the pixels displayed on the screen is performed.  This process involves the output of text, colors, images, borders, shadows, and so on.  We are talking about every visible part of each element. <br></li><li>  Layout  Since parts of the page may well be displayed on different layers, they need to be combined in a single window in the correct order, which will lead to the correct output of the page.  This is very important, especially for overlapping elements. <br></li></ul><br><h2>  <font color="#3AC1EF">JS code optimization</font> </h2><br>  JavaScript code often leads to changes in what can be observed in the browser.  This is especially true for single-page applications.  Here are some tips on optimizing JS to improve the page rendering process. <br><br><ul><li>  Avoid using the <code>setTimeout()</code> and <code>setInterval()</code> functions to update the appearance of page elements.  These functions call a callback at some point in the frame formation, perhaps at the very end.  We need to call the command leading to visual changes at the beginning of the frame, and not to miss it. <br></li><li>  Transfer lengthy calculations to <a href="https://habrahabr.ru/company/ruvds/blog/348424/">web workers</a> . <br></li><li>  Use micro-tasks split into several frames to make changes to the DOM.  This should be used when the task needs access to the DOM, and access to the DOM from a web worker, for example, cannot be obtained.  This means that a large task needs to be broken down into smaller ones and executed within the <code>requestAnimationFrame</code> , <code>setTimeout</code> , or <code>setInterval</code> , depending on the specifics of the task. <br></li></ul><br><h2>  <font color="#3AC1EF">CSS optimization</font> </h2><br>  Modifying the DOM by adding and removing elements, changing attributes, and other similar actions will cause the browser to recalculate the styles of the elements, and, in many cases, the layout of the entire page, or at least some part of it.  To optimize the page rendering process, consider the following. <br><br><ul><li>  Reduce the complexity of the selectors.  The use of complex selectors can lead to the fact that working with them will take more than 50% of the time required to calculate the styles of the element, the rest of the time will be spent on constructing the style itself. <br></li><li>  Reduce the number of elements for which you want to perform style calculations.  That is, it is better if the style change is directed to several elements, and not to the whole page. <br></li></ul><br><h2>  <font color="#3AC1EF">Layout optimization</font> </h2><br>  Recalculation of the page layout may require serious system resources.  To optimize this process, consider the following. <br><br><ul><li>  Reduce the number of situations leading to recalculation of the layout.  When you change styles, the browser determines whether a recalculation of the layout is required to reflect these changes.  Changes in properties, such as width, height, or element position (in general, we are talking about the geometric characteristics of the elements), require changes in the layout.  Therefore, unless absolutely necessary, do not change these properties. <br></li><li>  Whenever possible, use the flexbox model instead of older model layouts.  This model is faster than others, which can give a significant performance boost. <br></li><li>  Avoid the model of work with the document, providing for periodic changes in the parameters of elements and their subsequent reading.  In JavaScript, the parameters of DOM elements (like <code>offsetHeight</code> or <code>offsetWidth</code> ) from the previous frame are available.  Reading these parameters does not cause problems.  However, if you change the style of an element before reading such parameters (for example, dynamically adding some CSS class to it), the browser will need to spend a lot of resources in order to apply style changes, create a layout and return the necessary data to the program.  This can slow down the program, like this should be avoided whenever possible. <br></li></ul><br><h2>  <font color="#3AC1EF">Rendering optimization</font> </h2><br>  Often this task takes the most time, so it is important to avoid situations that lead to redrawing the page.  Here is what can be done here. <br><br><ul><li>  Changing any property, with the exception of transformations and changes in transparency, leads to a redraw.  Use these features sparingly. <br></li><li>  If your actions caused a recalculation of the layout, this leads to a call to redraw the page, since changes in the geometric parameters of the element also lead to its visual changes. <br></li><li>  Reduce the area of ‚Äã‚Äãpages that need to be redrawn, competently controlling the location of the layers and animation. <br></li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article we talked about the rendering subsystems of modern browsers.  The right approach to page visualization leads to improved performance of web applications and improved user experience. <br><br>  Previous parts of a series of articles: <br><br>  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">How JS Works: About V8 Inside and Code Optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">How JS works: memory management, four types of memory leaks and how to deal with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">How JS works: event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">How JS: WebSocket and HTTP / 2 + SSE work.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">How JS Works: Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">How JS Works: Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">How JS Works: Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">How JS Works: Web Push Notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">How JS Works: Tracking DOM Changes with MutationObserver</a> <br><br>  <b>Dear readers!</b>  What techniques do you use to optimize the rendering of the pages of your web projects? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/351802/">https://habr.com/ru/post/351802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351792/index.html">Profile of non-ideal customer. What clients to refuse and why it is vital</a></li>
<li><a href="../351794/index.html">Seminar Dino Esposito March 29 in Moscow</a></li>
<li><a href="../351796/index.html">Conference DEFCON 19. "The Art of trolling." Matt "OpenFly" Joyce</a></li>
<li><a href="../351798/index.html">Alert in Telegram and Slack in real time. Or How to Make an Alert in Splunk - Part 2</a></li>
<li><a href="../351800/index.html">Elegant patterns of modern javascript: Ice Factory</a></li>
<li><a href="../351804/index.html">How and why to move from service-oriented architecture to microservices</a></li>
<li><a href="../351806/index.html">"Calendar tester" for March. Test security</a></li>
<li><a href="../351808/index.html">Using kubernetes to develop blockchain projects on Hyperledger Fabric</a></li>
<li><a href="../351810/index.html">Live broadcast from Vue.js Moscow Meetup # 1</a></li>
<li><a href="../351812/index.html">Analysis of performance tasks with JBreak (part 4)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>