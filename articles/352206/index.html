<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Release of PVS-Studio for macOS: 64 weaknesses in Apple XNU Kernel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The new version of PVS-Studio 6.23 runs under macOS and allows you to check projects written in C and C ++. Our team decided to coincide with the XNU ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Release of PVS-Studio for macOS: 64 weaknesses in Apple XNU Kernel</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/abf/971/003/abf9710036e0355ffdc45a8bf4d8879b.png" alt="Bug in apple" align="left">  The new version of PVS-Studio 6.23 runs under macOS and allows you to check projects written in C and C ++.  Our team decided to coincide with the XNU Kernel test for this event. <br><br><h2>  PVS-Studio for macOS </h2><br>  With the release of the analyzer version for macOS, PVS-Studio can be safely called the cross-platform static code analyzer for C and C ++. <br><a name="habracut"></a><br>  Initially, there was a version only for Windows.  About two years ago, our team supported Linux: " <a href="https://www.viva64.com/ru/b/0451/">How PVS-Studio was created under Linux</a> ".  Also, attentive readers of our blog should remember the FreeBSD Kernel review articles ( <a href="https://www.viva64.com/ru/b/0377/">article 1, article</a> <a href="https://www.viva64.com/ru/b/0496/">2</a> ).  Then the analyzer was built to run in PC-BSD and TrueOS.  And finally, we got to macOS! <br><br>  <b>Is it easy to develop cross-platform product?</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This question has an economic and technical component. <br><br>  From an economic point of view, making the analyzer cross-platform was the right decision.  Software development has long been moving in this direction, and a tool for developers of such projects must be appropriate.  However, if something is useful - it does not mean that it is immediately worth starting to do.  At first, we always make sure that we have enough strength to implement something in a new direction, and then support it. <br><br>  On the technical side, it is difficult only at the very beginning, if the project is not immediately thought of as cross-platform.  We spent several months adapting the analyzer to the Linux system.  Compilation of the project under the new platform did not take much time: we do not have a graphical interface and the code is almost not tied to the use of system APIs.  Most of the time was taken by adapting the analyzer to new compilers and improving the quality of analysis.  In other words, a lot of effort requires the <a href="https://www.viva64.com/ru/b/0488/">prevention of false positives</a> . <br><br>  <b>And what about the development under macOS?</b> <br><br>  At this point, we already had a CMake project file for CMake, easily adaptable for different operating systems.  Testing systems of different types were also cross-platform.  All this helped to run very quickly on macOS. <br><br>  A special feature of analyzer development for macOS is the Apple LLVM Compiler.  Although the analyzer was assembled with the help of GCC and worked fine, it could still affect the compatibility of the analyzer with users' computers in the future.  In order not to create problems for potential users, we decided to support the build of the distribution with the help of this compiler, which comes with Xcode. <br><br>  C ++ development helps a lot in creating and developing cross-platform projects, but different compilers add such features very unevenly, therefore conditional compilation is still actively used in several places. <br><br>  In general, everything went smoothly and easily.  As before, most of the time was spent on the revision of exceptions, site modification, testing, and other related issues.  As the first project tested with PVS-Studio for macOS, we present you the <a href="https://github.com/apple/darwin-xnu">XNU Kernel</a> . <br><br>  <b>Distributive</b> <br><br>  You can familiarize yourself with the ways of downloading and installing PVS-Studio for macOS <a href="https://www.viva64.com/ru/pvs-studio-download-macos/">here</a> . <br><br><h2>  XNU Kernel </h2><br>  Where to start demonstrating the features of PVS-Studio for macOS, if not from checking the kernel of this system!  Therefore, the first project tested with the new version of the analyzer was the XNU Kernel. <br><br>  XNU is the core of computer operating systems developed by Apple and used in the OS OS family (macOS, iOS, tvOS, watchOS).  <a href="https://ru.wikipedia.org/wiki/XNU">More details</a> . <br><br>  It is believed that the kernel is written in C and C ++, but in fact it is C. I counted 1302 * .c files and only 97 * .cpp files.  The size of the code base is 1929 KLOC.  It turns out that this is a relatively small project.  For comparison, the code base of the Chromium project is 15 times larger and contains 30 MLOC. <br><br>  The source code can be conveniently downloaded from a mirror on GitHub: <a href="https://github.com/apple/darwin-xnu">xnu</a> . <br><br><h2>  Test results </h2><br>  Although the XNU Kernel project is relatively small, studying analyzer warnings alone is a big task and takes a lot of time.  Complicating the study of warnings and false positives, since I did not pre-configure the analyzer.  I just quickly ran through the warnings, writing out code snippets of interest, in my opinion.  This is more than enough to write an article, and, moreover, solid in size.  PVS-Studio analyzer easily finds a large number of interesting errors. <br><br>  <b>A note for XNU Kernel developers</b> .  I did not have the task to find as many errors as possible.  Therefore, you should not be guided by this article to correct them.  Firstly, this is inconvenient, since it is not possible to navigate through warnings.  I am sure that it is much better to use one of the formats that PVS-Studio can generate, for example, an HTML report with the ability to navigate (it is similar to what Clang can generate).  Secondly, I missed many mistakes simply because I studied the report superficially.  I recommend that developers independently carry out a more thorough analysis of the project with the help of PVS-Studio. <br><br>  As I said, the false positives prevented me, but in fact they are not a problem.  If you configure the analyzer, it is quite possible to reduce the number of false positives to <a href="https://www.viva64.com/ru/b/0523/">10-15%</a> .  Since setting it up also takes time and restarting the analysis process, I missed this step - it‚Äôs easy for me to compile errors for the article.  If you plan to perform the analysis carefully, then, of course, should be given time to set up. <br><br>  Basically, false positives occur due to macros and insufficiently qualitatively tagged functions.  For example, in XNU Kernel, most of them are related to the use of the <i>panic</i> function. <br><br>  Here is how this function is declared: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ...)</span></span></span><span class="hljs-function"> __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((__format__ (__printf__, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)))</span></span></span></span>;</code> </pre> <br>  The function is annotated so that its input arguments are interpreted by analogy with the arguments of the <i>printf</i> function.  This allows compilers and analyzers to find errors of incorrect formatting of strings.  However, the function is not marked as non-returnable.  As a result, the following code causes false positives: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) panic(<span class="hljs-string"><span class="hljs-string">"zzzzzz"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(ptr, src, n);</code> </pre> <br>  Here, the analyzer issues a warning that a null pointer can be dereferenced.  From his point of view, after calling the <i>panic</i> function, the <i>memcpy</i> function will be called. <br><br>  To avoid such false positives, you should change the function annotation by adding <i>__attribute __ ((noreturn))</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> __attribute__((noreturn)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ...)</span></span></span><span class="hljs-function"> __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((__format__ (__printf__, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)))</span></span></span></span>;</code> </pre> <br>  Let's now see what interesting things I managed to see in the XNU Kernel code.  In total, I wrote out 64 errors and decided to dwell on this beautiful number.  I grouped the defects according to the <a href="https://cwe.mitre.org/">Common Weakness Enumeration</a> , since many people are familiar with this classification, and it will be easier for them to understand what mistakes they are talking about in this or that chapter. <br><br><h3>  CWE-570 / CWE-571: Expression is Always False / True </h3><br>  Very diverse errors can lead to <a href="https://cwe.mitre.org/data/definitions/570.html">CWE-570</a> / <a href="https://cwe.mitre.org/data/definitions/571.html">CWE-571</a> , i.e.  to situations where a condition or part of a condition is always false / true.  In the case of the XNU Kernel project, all these errors, in my opinion, are related to typos.  PVS-Studio generally reveals typos very well. <br><br>  <b>Fragment N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">key_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( struct mbuf *m, struct socket *so)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m-&gt;m_flags &amp; M_PKTHDR) == <span class="hljs-number"><span class="hljs-number">0</span></span> || m-&gt;m_pkthdr.len != m-&gt;m_pkthdr.len) { ipseclog((LOG_DEBUG, <span class="hljs-string"><span class="hljs-string">"key_parse: invalid message length.\n"</span></span>)); PFKEY_STAT_INCREMENT(pfkeystat.out_invlen); error = EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> senderror; } .... }</code> </pre> <br>  PVS-Studio warning: V501 CWE-570 There are identical sub-expressions 'm-&gt; M_dat.MH.MH_pkthdr.len' to the left.  key.c 9442 <br><br>  Because of a typo, a member of the class is compared to itself: <br><br><pre> <code class="cpp hljs">m-&gt;m_pkthdr.len != m-&gt;m_pkthdr.len</code> </pre> <br>  A part of the condition is always false and, as a result, the length of a message is checked incorrectly.  It turns out that the program will continue to process incorrect data.  Perhaps this is not terrible, but many vulnerabilities are precisely related to the fact that some input data was unverified or not adequately checked.  So this place in the code clearly deserves the attention of developers. <br><br>  <b>Fragment N2, N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VM_PURGABLE_STATE_MASK 3 kern_return_t memory_entry_purgeable_control_internal(...., int *state) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((control == VM_PURGABLE_SET_STATE || control == VM_PURGABLE_SET_STATE_FROM_KERNEL) &amp;&amp; (((*state &amp; ~(VM_PURGABLE_ALL_MASKS)) != 0) || ((*state &amp; VM_PURGABLE_STATE_MASK) &gt; VM_PURGABLE_STATE_MASK))) return(KERN_INVALID_ARGUMENT); .... }</span></span></code> </pre> <br>  PVS-Studio warning: V560 CWE-570 A part of conditional expression is always false: ((* state &amp; 3)&gt; 3).  vm_user.c 3415 <br><br>  Let's take a closer look at this part of the expression: <br><br><pre> <code class="cpp hljs">(*state &amp; VM_PURGABLE_STATE_MASK) &gt; VM_PURGABLE_STATE_MASK</code> </pre> <br>  If we substitute the value of the macro, we get: <br><br><pre> <code class="cpp hljs">(*state &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  The bitwise AND operation can only result in values ‚Äã‚Äãof 0, 1, or 2. It makes no sense to check whether 0, 1, or 2 is greater than 3. It is very likely that the expression contains some typo. <br><br>  As in the previous case, a certain status is incorrectly verified, which may cause the processing of incorrect (unreliable) data. <br><br>  Exactly the same error is found in the file vm_map.c.  Apparently, part of the code was written using Copy-Paste.  Warning: V560 CWE-570 A part of conditional expression is always false: ((* state &amp; 3)&gt; 3).  vm_map.c 15809 <br><br>  <b>Fragment N4</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pat_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean_t</span></span> istate; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> pat; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cpuid_features() &amp; CPUID_FEATURE_PAT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; istate = ml_set_interrupts_enabled(FALSE); pat = rdmsr64(MSR_IA32_CR_PAT); DBG(<span class="hljs-string"><span class="hljs-string">"CPU%d PAT: was 0x%016llx\n"</span></span>, get_cpu_number(), pat); <span class="hljs-comment"><span class="hljs-comment">/* Change PA6 attribute field to WC if required */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pat &amp; ~(<span class="hljs-number"><span class="hljs-number">0x0F</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">48</span></span>)) != (<span class="hljs-number"><span class="hljs-number">0x01</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">48</span></span>)) { mtrr_update_action(CACHE_CONTROL_PAT); } ml_set_interrupts_enabled(istate); }</code> </pre> <br>  PVS-Studio warning: V547 CWE-571 Expression is always true.  mtrr.c 692 <br><br>  Let's look at the meaningless check into which a typo most likely crept in: <br><br><pre> <code class="cpp hljs">(pat &amp; ~(<span class="hljs-number"><span class="hljs-number">0x0F</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">48</span></span>)) != (<span class="hljs-number"><span class="hljs-number">0x01</span></span>ULL &lt;&lt; <span class="hljs-number"><span class="hljs-number">48</span></span>)</code> </pre> <br>  We calculate some expressions: <ul><li>  ~ (0x0FULL &lt;&lt; 48) = 0xFFF0FFFFFFFFFFFF </li><li>  (0x01ULL &lt;&lt; 48) = 0x0001000000000000 </li></ul><br>  An expression <i>(pat &amp; [0xFFF0FFFFFFFFFFFF])</i> cannot result in a value of <i>0x0001000000000000</i> .  The condition is always true.  As a result, the <i>mtrr_update_action</i> function is always called. <br><br>  <b>Fragment N5</b> <br><br>  Now, in my opinion, there will be a very beautiful typo: instead of <i>== they</i> wrote <i>=</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { CMODE_WK = <span class="hljs-number"><span class="hljs-number">0</span></span>, CMODE_LZ4 = <span class="hljs-number"><span class="hljs-number">1</span></span>, CMODE_HYB = <span class="hljs-number"><span class="hljs-number">2</span></span>, VM_COMPRESSOR_DEFAULT_CODEC = <span class="hljs-number"><span class="hljs-number">3</span></span>, CMODE_INVALID = <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">vm_compressor_mode_t</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_compressor_algorithm_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... assertf(((new_codec == VM_COMPRESSOR_DEFAULT_CODEC) || (new_codec == CMODE_WK) || (new_codec == CMODE_LZ4) || (new_codec = CMODE_HYB)), <span class="hljs-string"><span class="hljs-string">"Invalid VM compression codec: %u"</span></span>, new_codec); .... }</code> </pre> <br>  PVS-Studio warning: V768 CWE-571 The expression 'new_codec = CMODE_HYB' is of enum type.  It is the odd that it is used for an expression of a Boolean-type.  vm_compressor_algorithms.c 419 <br><br>  In the process of checking the condition, the variable <i>new_codec is</i> assigned the value 2. As a result, the condition is always true and the assert macro actually does not check anything. <br><br>  The error could be harmless.  Well, you will think, the assert-macro did not check something - it doesn't matter.  However, besides this, the debug version also works incorrectly.  After all, the value of the variable <i>new_codec is spoiled</i> and the wrong codec is used. <br><br>  <b>Fragment N6, N7</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pbuf_copy_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pbuf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pbuf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src)</span></span></span><span class="hljs-function"> </span></span>{ VERIFY(off &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); VERIFY(len &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); VERIFY((u_int)(off + len) &lt;= pbuf-&gt;pb_packet_len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pbuf-&gt;pb_type == PBUF_TYPE_MBUF) m_copyback(pbuf-&gt;pb_mbuf, off, len, src); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pbuf-&gt;pb_type == PBUF_TYPE_MBUF) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)pbuf-&gt;pb_data)[off], src, len); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> panic(<span class="hljs-string"><span class="hljs-string">"%s: bad pb_type: %d"</span></span>, __func__, pbuf-&gt;pb_type); }</code> </pre> <br>  PVS-Studio warning: V517 CWE-570 The use of 'if (A) {...} else if (A) {...}' pattern was detected.  There is a possibility of logical error presence.  Check lines: 340, 343. pf_pbuf.c 340 <br><br>  For clarity, I will highlight the essence: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A) foo(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A) Unreachable_code; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> panic();</code> </pre> <br>  If condition <i>A is</i> true, then the body of the first <i>if statement</i> is executed.  If this is not the case, then the repeated check does not make sense and the <i>panic</i> function is immediately called.  Part of the code is generally unreachable. <br><br>  Here is some kind of logic error, or a typo in one of the conditions. <br><br>  Below in the same file is the function <i>pbuf_copy_data</i> , which, apparently, was written using Copy-Paste and contains the same error.  Warning: V517 CWE-570 The use of if (A) {...} else if (A) {...} 'pattern was detected.  There is a possibility of logical error presence.  Check lines: 358, 361. pf_pbuf.c 358 <br><br><h3>  CWE-670: Always-Incorrect Control Flow Implementation </h3><br>  Defect <a href="https://cwe.mitre.org/data/definitions/670.html">CWE-670</a> says that in the code, most likely, something does not work the way the programmer intended. <br><br>  <b>Fragment N8, N9, N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in_ifaddr_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ifaddr *ifa)</span></span></span><span class="hljs-function"> </span></span>{ IFA_LOCK_ASSERT_HELD(ifa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifa-&gt;ifa_refcnt != <span class="hljs-number"><span class="hljs-number">0</span></span>) { panic(<span class="hljs-string"><span class="hljs-string">"%s: ifa %p bad ref cnt"</span></span>, __func__, ifa); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(ifa-&gt;ifa_debug &amp; IFD_ALLOC)) { panic(<span class="hljs-string"><span class="hljs-string">"%s: ifa %p cannot be freed"</span></span>, __func__, ifa); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifa-&gt;ifa_debug &amp; IFD_DEBUG) { .... }</code> </pre> <br>  PVS-Studio Warning: V646 CWE-670 Consider inspecting the application's logic.  It's possible that 'else' keyword is missing.  in.c 2010 <br><br>  Perhaps there is no error in this code.  However, this place looks very suspicious: <br><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(ifa-&gt;ifa_debug &amp; IFD_ALLOC)) {</code> </pre> <br>  The anomaly is that it is not accepted to write like this.  It would be more logical to start writing <i>if</i> with a new line.  Code authors should check this place.  Perhaps, the <i>else</i> keyword is missing here and the code should be like this: <br><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(ifa-&gt;ifa_debug &amp; IFD_ALLOC)) {</code> </pre> <br>  Or you just need to add a line break so that this code is not confused either by the analyzer or by the colleagues accompanying this code. <br><br>  Similar suspicious places can be found here: <br><br><ul><li>  V646 CWE-670 Consider inspecting the application's logic.  It's possible that 'else' keyword is missing.  kern_malloc.c 836 </li><li>  V646 CWE-670 Consider inspecting the application's logic.  It's possible that 'else' keyword is missing.  ipc_kmsg.c 4229 </li></ul><br>  <b>Fragment N11, N12, N13, N14</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dup2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">proc_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p, struct dup2_args *uap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *retval)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((fdp-&gt;fd_ofileflags[<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>] &amp; UF_RESERVED) == UF_RESERVED) { fp_drop(p, old, fp, <span class="hljs-number"><span class="hljs-number">1</span></span>); procfdtbl_waitfd(p, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DIAGNOSTIC proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> goto startover; } .... startover: .... }</span></span></code> </pre> <br>  PVS-Studio warning: V612 CWE-670 An unconditional 'goto' within a loop.  kern_descrip.c 628 <br><br>  This is a very strange code.  Notice that the body of the <i>while</i> statement ends with the <i>goto statement</i> .  In this case, the operator <i>continue is</i> not used anywhere in the loop body.  This means that the loop body will be executed no more than once. <br><br>  Why was it necessary to create a loop, if it still does not perform more than one iteration?  It would be better to use the <i>if statement</i> , then it would not cause questions.  I think this is a mistake, and something is written incorrectly in the cycle.  For example, it is possible that before the <i>goto</i> operator some condition is missing. <br><br>  Similar "one-time" cycles occur 3 more times: <ul><li>  V612 CWE-670 An unconditional 'goto' within a loop.  tty.c 1084 </li><li>  V612 CWE-670 An unconditional 'goto' within a loop.  vm_purgeable.c 842 </li><li>  V612 CWE-670 An unconditional 'return' within a loop.  kern_credential.c 930 </li></ul><br><h2>  Dereferencing null pointers: CWE-476, CWE-628, CWE-690 </h2><br>  There are various reasons why a null pointer dereference may occur and the PVS-Studio analyzer, depending on the situation, can assign them different CWE-IDs: <ul><li>  <a href="https://cwe.mitre.org/data/definitions/476.html">CWE-476</a> : NULL Pointer Dereference </li><li>  <a href="https://cwe.mitre.org/data/definitions/628.html">CWE-628</a> : Function Call with Incorrectly Specified Arguments </li><li>  <a href="https://cwe.mitre.org/data/definitions/690.html">CWE-690</a> : Unchecked Return Value to NULL Pointer Dereference </li></ul><br>  When writing an article, I considered it reasonable to collect all the errors of this type in one section. <br><br>  <b>Fragment N15</b> <br><br>  I'll start with complex and large functions.  First, consider the <i>netagent_send_error_response</i> function, in which the pointer passed in the <i>session</i> argument is dereferenced. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">netagent_send_error_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( struct netagent_session *session, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">u_int8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">u_int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">u_int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">u_int8_t</span></span> *response = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> response_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct netagent_message_header); MALLOC(response, <span class="hljs-keyword"><span class="hljs-keyword">u_int8_t</span></span> *, response_size, M_NETAGENT, M_WAITOK); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ENOMEM); } (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)netagent_buffer_write_message_header(.....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((error = netagent_send_ctl_data(session-&gt;control_unit, (<span class="hljs-keyword"><span class="hljs-keyword">u_int8_t</span></span> *)response, response_size))) { NETAGENTLOG0(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"Failed to send response"</span></span>); } FREE(response, M_NETAGENT); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (error); }</code> </pre> <br>  Note that the <i>session</i> pointer is dereferenced in the <i>session-&gt; control_unit expression</i> without any prior checking.  Whether the null pointer is dereferenced or not depends on which actual arguments are passed to this function. <br><br>  Now let's see how the <i>netagent_send_error_response</i> function described above is <i>used</i> in the <i>netagent_handle_unregister_message</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">netagent_handle_unregister_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( struct netagent_session *session, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta">#</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> unused(payload_length, packet, offset) u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL; </span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> (session == NULL) { NETAGENTLOG0(LOG_ERR, </span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-string">"Failed to find session"</span></span></span></span><span class="hljs-function"><span class="hljs-meta">); response_error = NETAGENT_MESSAGE_ERROR_INTERNAL; goto fail; } netagent_unregister_session_wrapper(session); netagent_send_success_response(session, .....); return; fail: netagent_send_error_response( session, NETAGENT_MESSAGE_TYPE_UNREGISTER, message_id, response_error); }</span></span></span></span></code> </pre> <br>  PVS-Studio warning: V522 CWE-628 Dereferencing of the null pointer 'session' might take place.  The null pointer is passed into the netagent_send_error_response 'function.  Inspect the first argument.  Check lines: 427, 972. network_agent.c 427 <br><br>  Here the Data Flow analysis implemented in PVS-Studio manifests itself.  The analyzer notes that if the <i>session</i> pointer was <i>NULL</i> , then some information is written to the log, after which a transition to the <i>fail flag</i> occurs. <br><br>  Next <i>comes the netagent_send_error_response</i> function <i>call</i> : <br><br><pre> <code class="cpp hljs">fail: netagent_send_error_response( session, NETAGENT_MESSAGE_TYPE_UNREGISTER, message_id, response_error);</code> </pre> <br>  Notice that the ill-fated <i>session</i> pointer, which is NULL, is passed to the function as the actual argument. <br><br>  As we know, in the <i>netagent_send_error_response</i> function <i>there</i> is no protection for this case, and a null pointer is dereferenced. <br><br>  <b>Fragment N16</b> <br><br>  The following situation is similar to the previous one.  The function code will be shorter, but you will have to deal with it just as slowly and in detail. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pf_lazy_makewritable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pf_pdesc *pd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pbuf_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pbuf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pd-&gt;lmw &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); VERIFY(pbuf == pd-&gt;mp); p = pbuf-&gt;pb_data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; pd-&gt;lmw) { .... }</code> </pre> <br>  Notice that the <i>pbuf</i> pointer <i>is</i> dereference without first checking for <i>NULL</i> equality.  There is a "VERIFY (pbuf == pd-&gt; mp)" check in the code.  However, <i>pd-&gt; mp</i> may be <i>NULL</i> , so the check cannot be considered as protection against <i>NULL</i> . <br><br>  Note.  Please remember that I am completely unfamiliar with the XNU Kernel code and may be mistaken.  Perhaps <i>pd-&gt; mp</i> will never store a <i>NULL</i> value.  Then all my reasoning is wrong and there is no error here.  However, such code is still better to check again. <br><br>  <i>Let's</i> continue and see how the <i>pf_lazy_makewritable</i> function is <i>used</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pf_test_state_icmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf_lazy_makewritable(pd, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, off + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (struct icmp6_hdr)) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (PF_DROP); .... }</code> </pre> <br>  PVS-Studio warning: V522 CWE-628 Dereferencing of the null pointer 'pbuf' might take place.  The null pointer is passed into the 'pf_lazy_makewritable' function.  Inspect the second argument.  Check lines: 349, 7460. pf.c 349 <br><br>  As the second actual argument, a <i>null is</i> passed to the <i>pf_lazy_makewritable</i> function.  It is very strange. <br><br>  Suppose a programmer thinks that the program will be protected from a null pointer by ‚ÄúVERIFY (pbuf == pd-&gt; mp)‚Äù.  Then the question arises: why write such code at all?  Why call a function by passing an obviously incorrect argument? <br><br>  Therefore, it seems to me that in fact the <i>pf_lazy_makewritable</i> function should be able to take a null pointer and somehow handle this case in a special way, but it does not.  This code deserves the most thorough verification by the programmer, and the PVS-Studio analyzer is definitely right to draw our attention to it. <br><br>  <b>Fragment N17</b> <br><br>  You can relax a bit: consider the simple case. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode_t</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cache_lookup_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vnode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dp, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp &amp;&amp; (dp-&gt;v_flag &amp; VISHARDLINK)) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dp-&gt;v_flag &amp; VROOT) || dp == ndp-&gt;ni_rootdir || dp-&gt;v_parent == NULLVP) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  PVS-Studio warning: V522 CWE-690 There might be a null pointer 'dp'.  vfs_cache.c 1449 <br><br>  Take a look at the check: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp &amp;&amp; (dp-&gt;v_flag &amp; VISHARDLINK))</code> </pre> <br>  It tells us that the <i>dp</i> pointer may be null.  However, further the pointer is dereferenced without preliminary check: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dp-&gt;v_flag &amp; VROOT) || ....)</code> </pre> <br>  <b>Fragment N18</b> <br><br>  In the previous example, we encountered a situation where the pointer is checked before dereferencing, and later in the code, the check was forgotten.  But much more often you can find a situation where at first the pointer is dereferenced, and only then it is checked.  No exception and the project code XNU Kernel.  To better understand what we are talking about, let's first consider a synthetic example: <br><br><pre> <code class="cpp hljs">p[n] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Let's now take a look at how such errors look in reality.  Let's start with the name comparison function.  Comparison functions are <a href="https://www.viva64.com/ru/b/0509/">very insidious</a> :). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IORegistryEntry::compareName(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OSSymbol * sym = copyName(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isEqual; isEqual = sym-&gt;isEqualTo( name ); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if( isEqual &amp;&amp; matched) { name-&gt;retain(); *matched = name; } if( sym) // &lt;= sym-&gt;release(); return( isEqual ); }</span></span></code> </pre> <br>  PVS-Studio warnings: V595 CWE-476;  Check lines: 889, 896. IORegistryEntry.cpp 889 <br><br>  The lines of code that interest us are highlighted by comments like "// &lt;=".  As you can see, first the pointer is dereferenced.  Further in the code there is a check for equality of the pointer <i>nullptr</i> .  But it is immediately clear that if the pointer is zero, then a null pointer will dereference and the function, in fact, is not ready for such a situation. <br><br>  <b>Fragment N19</b> <br><br>  The following error occurred due to a typo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memorystatus_get_priority_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">memorystatus_priority_entry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **list_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *list_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_only)</span></span></span><span class="hljs-function"> </span></span>{ .... *list_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">memorystatus_priority_entry_t</span></span>*)kalloc(*list_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ENOMEM; } .... }</code> </pre> <br>  PVS-Studio warning: V595 CWE-476 The 'list_ptr' pointer was used against nullptr.  Check lines: 7175, 7176. kern_memorystatus.c 7175 <br><br>  The analyzer sees that first the variable is dereferenced, and the next line checks for equality <i>nullptr</i> .  This interesting error occurred due to the fact that the programmer forgot to write the character '*'.  In fact, the code should have been like this: <br><br><pre> <code class="cpp hljs">*list_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">memorystatus_priority_entry_t</span></span>*)kalloc(*list_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!*list_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ENOMEM; }</code> </pre> <br>  It can be said that the error was revealed indirectly.  However, it does not matter, because the most important thing is that the analyzer paid attention to the anomalous code and we saw an error. <br><br>  <b>Fragment N20 - N35</b> <br><br>  The XNU Kernel code reveals a lot of errors detected by diagnosing the V595.  However, to consider all of them will be boring.  Therefore, I will analyze only one more case, and then I will give a list of messages indicating errors. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inp_decr_sndbytes_unsent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct socket *so, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inpcb</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inp</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inpcb</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_pcb</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifnet</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifp</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inp</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inp_last_outifp</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (so == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || !(so-&gt;so_snd.sb_flags &amp; SB_SNDBYTE_CNT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifp-&gt;if_sndbyte_unsent &gt;= len) OSAddAtomic64(-len, &amp;ifp-&gt;if_sndbyte_unsent); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ifp-&gt;if_sndbyte_unsent = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br>  PVS-Studio warning: V595 CWE-476  Check lines: 3450, 3453. in_pcb.c 3450 <br><br>  I suggest the reader to independently follow the fate of the pointer <i>so</i> and make sure that the code is written incorrectly. <br><br>  Other errors: <br><br><ul><li>  V595 CWE-476 The 'startDict' pointer was used against nullptr.  Check lines: 3369, 3373. IOService.cpp 3369 </li><li>  V595 CWE-476 The 'job' pointer was used before it was verified against nullptr.  Check lines: 4083, 4085. IOService.cpp 4083 </li><li>  V595 CWE-476 The 'typeinst' pointer was used before it was verified against nullptr.  Check lines: 176, 177. OSMetaClass.cpp 176 </li><li>  V595 CWE-476 The 'name' pointer was used before it was verified against nullptr.  Check lines: 385, 392. devfs_tree.c 385 </li><li>  V595 CWE-476 The 'collection' of the pointer was used before it was verified against nullptr.  Check lines: 71, 75. OSCollectionIterator.cpp 71 </li><li>  V595 CWE-476 The 'ifp' pointer was used before it was verified against nullptr.  Check lines: 2014, 2018. dlil.c 2014 </li><li>  V595 CWE-476 The 'fakeif' pointer was used before it was verified against nullptr.  Check lines: 561, 566. if_fake.c 561 </li><li>  V595 CWE-476 The 'sb' pointer was used before it was verified against nullptr.  Check lines: 138, 140. in_pcblist.c 138 </li><li>  V595 CWE-476 The 'tp' pointer was used before it was verified against nullptr.  Check lines: 2603, 2610. tcp_subr.c 2603 </li><li>  V595 CWE-476 The 'str_id' pointer was used before it was verified against nullptr.  Check lines: 1812, 1817. kdebug.c 1812 </li><li>  V595 CWE-476 The 'sessp' pointer was used before it was verified against nullptr.  Check lines: 191, 194. subr_prf.c 191 </li><li>  V595 CWE-476 The 'sessp' pointer was used before it was verified against nullptr.  Check lines: 1463, 1469. tty.c 1463 </li><li>  V595 CWE-476 The 'so' pointer was used before it was verified against nullptr.  Check lines: 6714, 6719. uipc_socket.c 6714 </li><li>  V595 CWE-476 The 'uap' pointer was verified against nullptr.  Check lines: 314, 320. nfs_upcall.c 314 </li><li>  V595 CWE-476 The 'xfromname' pointer was used before it was verified against nullptr.  Check lines: 3986, 4006. kpi_vfs.c 3986 </li><li>  Note.  In fact, I did not carefully watch all the warnings of this type.  Therefore, in fact, errors can be more. </li></ul><br>  <b>Fragment N36, N37</b> <br><br>  And the last couple of errors on the use of null pointers. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">feth_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ifnet_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ifp)</span></span></span><span class="hljs-function"> </span></span>{ .... if_fake_ref fakeif; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fakeif != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { peer = fakeif-&gt;iff_peer; flags = fakeif-&gt;iff_flags; } <span class="hljs-comment"><span class="hljs-comment">/* check for pending TX */</span></span> m = fakeif-&gt;iff_pending_tx_packet; .... }</code> </pre> <br>  PVS-Studio warning: V1004 CWE-476 The "fakeif" pointer was used unsafely after it was verified against nullptr.  Check lines: 566, 572. if_fake.c 572 <br><br>  I think this comment is not required.  Just see how the <i>fakeif</i> pointer is checked and used. <br><br>  Last similar case: V1004 CWE-476 The 'rt-&gt; rt_ifp' pointer was used unsafely after it was verified against nullptr.  Check lines: 138, 140. netsrc.c 140 <br><br><h3>  CWE-119: Improve Restriction of Memory Buffer </h3><br>  I met a couple of errors related to the buffer overrun.  A very unpleasant kind of mistake for such a responsible project as XNU Kernel. <br><br>  Different options for going beyond the array boundary can be classified by different CWE IDs, but in this case, the analyzer chose <a href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a> . <br><br>  <b>Fragment N38</b> <br><br>  To begin, consider how some macros are declared. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IFNAMSIZ 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IFXNAMSIZ (IFNAMSIZ + 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_ROUTE_RULE_INTERFACES 10</span></span></code> </pre> <br>  It is important for us to remember that: <ul><li>  IFXNAMSIZ = 24 </li><li>  MAX_ROUTE_RULE_INTERFACES = 10 </li></ul><br>  And now let's consider a function where it is possible to go beyond the buffer boundary using the <i>snprintf</i> and <i>memset</i> functions.  Those.  There are 2 errors. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">necp_get_result_description</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> interface_names[IFXNAMSIZ][MAX_ROUTE_RULE_INTERFACES]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; MAX_ROUTE_RULE_INTERFACES; index++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (route_rule-&gt;exception_if_indices[index] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ifnet_t</span></span> interface = ifindex2ifnet[....]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(interface_names[index], IFXNAMSIZ, <span class="hljs-string"><span class="hljs-string">"%s%d"</span></span>, ifnet_name(interface), ifnet_unit(interface)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(interface_names[index], <span class="hljs-number"><span class="hljs-number">0</span></span>, IFXNAMSIZ); } } .... }</code> </pre> <br>  PVS-Studio warnings: <ul><li>  V512 CWE-119 A call of the '__builtin___memcpy_chk' function will lead to a buffer overflow.  - ADDITIONAL IN CURRENT necp_client.c 1459 </li><li>  V557 CWE-787 Array overrun is possible.  The value of 'length - 1' index could reach 23. - ADDITIONAL IN CURRENT necp_client.c 1460 </li></ul><br>  Notice how the two-dimensional array <i>interface_names is</i> declared: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> interface_names[IFXNAMSIZ][MAX_ROUTE_RULE_INTERFACES]; <span class="hljs-comment"><span class="hljs-comment">//  : char interface_names[24][10];</span></span></code> </pre> <br>  But it uses this array as if it were like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> interface_names[MAX_ROUTE_RULE_INTERFACES][IFXNAMSIZ]; <span class="hljs-comment"><span class="hljs-comment">//  : char interface_names[10][24];</span></span></code> </pre> <br>  It turns out some kind of porridge from the data. <br><br>  Someone, without thinking, can say that there is nothing terrible, because both arrays occupy the same number of bytes. <br><br>  No, everything is bad.  The array elements <i>interface_names [10..23] [....] are</i> not used, since the <i>index</i> variable in the loop takes the values ‚Äã‚Äã[0..9].  But the <i>interface_names [0..9] [....]</i> elements are starting to ‚Äúcling‚Äù to each other.  Those.  Some data overwrites others. <br><br>  The result is complete bullshit.    ,     ¬´¬ª,       . <br><br> <b> N39</b> <br><br>      <i>necp_client.c</i>    ,    . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IFNAMSIZ 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IFXNAMSIZ (IFNAMSIZ + 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NECP_MAX_PARSED_PARAMETERS 16 struct necp_client_parsed_parameters { .... char prohibited_interfaces[IFXNAMSIZ] [NECP_MAX_PARSED_PARAMETERS]; .... }; static int necp_client_parse_parameters(...., struct necp_client_parsed_parameters *parsed_parameters) { .... u_int32_t length = ....; .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= IFXNAMSIZ &amp;&amp; length &gt; 0) { memcpy(parsed_parameters-&gt;prohibited_interfaces[ num_prohibited_interfaces], value, length); parsed_parameters-&gt;prohibited_interfaces[ num_prohibited_interfaces][length - 1] = 0; .... }</span></span></span></span></code> </pre> <br>  PVS-Studio: <ul><li> V512 CWE-119 A call of the '__builtin___memcpy_chk' function will lead to a buffer overflow. ‚Äî ADDITIONAL IN CURRENT necp_client.c 1459 </li><li> V557 CWE-787 Array overrun is possible. The value of 'length ‚Äî 1' index could reach 23. ‚Äî ADDITIONAL IN CURRENT necp_client.c 1460 </li></ul><br>    . : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> prohibited_interfaces[IFXNAMSIZ][NECP_MAX_PARSED_PARAMETERS];</code> </pre> <br> ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> prohibited_interfaces[NECP_MAX_PARSED_PARAMETERS][IFXNAMSIZ];</code> </pre> <br><h3> CWE-563: Assignment to Variable without Use </h3><br>    PVS-Studio  <a href="https://cwe.mitre.org/data/definitions/563.html">CWE-563</a>    .         . <br><br> <b> N40</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> gss_krb5_3des_unwrap_mbuf(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cflag = <span class="hljs-number"><span class="hljs-number">1</span></span>; cflag &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; cflag--) { *minor = gss_krb5_3des_token_get( ctx, &amp;itoken, wrap, &amp;hash, &amp;offset, &amp;length, reverse); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*minor == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; wrap.Seal_Alg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xff</span></span>; wrap.Seal_Alg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xff</span></span>; } .... }</code> </pre> <br>  PVS-Studio: V519 CWE-563 The 'wrap.Seal_Alg[0]' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2070, 2071. gss_krb5_mech.c 2071 <br><br>     <i>0xff</i>       .         ,       : <br><br><pre> <code class="cpp hljs">wrap.Seal_Alg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xff</span></span>; wrap.Seal_Alg[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xff</span></span>;</code> </pre> <br>     ,       .   ‚Ä¶ - . <br><br>  PVS-Studio  <a href="https://www.viva64.com/ru/order/"></a> .       ! <br><br> <b> N41, N42, N43, N44</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> struct mbuf * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pf_reassemble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mbuf *m0, struct pf_fragment **frag, struct pf_frent *frent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mff)</span></span></span><span class="hljs-function"> </span></span>{ .... m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_PARTIAL; m-&gt;m_pkthdr.csum_flags = CSUM_DATA_VALID | CSUM_PSEUDO_HDR | CSUM_IP_CHECKED | CSUM_IP_VALID; .... }</code> </pre> <br>  PVS-Studio: V519 CWE-563 The 'm-&gt;M_dat.MH.MH_pkthdr.csum_flags' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 758, 759. pf_norm.c 759 <br><br> : <br><br><pre> <code class="cpp hljs">m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_PARTIAL;</code> </pre> <br>     .     <i>m-&gt;m_pkthdr.csum_flags</i>    .   ,        ,   ,    '|'.    ,    : <br><br><pre> <code class="cpp hljs">m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_PARTIAL; m-&gt;m_pkthdr.csum_flags |= CSUM_DATA_VALID | CSUM_PSEUDO_HDR | CSUM_IP_CHECKED | CSUM_IP_VALID;</code> </pre> <br>   3 ,    : <ul><li> V519 CWE-563 The 'm-&gt;M_dat.MH.MH_pkthdr.csum_flags' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1349, 1350. pf_norm.c 1350 </li><li> V519 CWE-563 The 'm-&gt;M_dat.MH.MH_pkthdr.csum_flags' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2984, 2985. ip_input.c 2985 </li><li> V519 CWE-563 The 'm-&gt;M_dat.MH.MH_pkthdr.csum_flags' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 773, 774. frag6.c 774 </li></ul><br><br><h3> CWE-14: Compiler Removal of Code to Clear Buffers </h3><br>    ,     .       ,     ,     : <ol><li> <a href="https://www.viva64.com/ru/b/0388/">Safe Clearing of Private Data</a> . </li><li> <a href="https://www.viva64.com/ru/w/v597/">V597</a> . The compiler could delete the 'memset' function call, which is used to flush 'Foo' buffer. The RtlSecureZeroMemory() function should be used to erase the private data. </li><li> <a href="https://cwe.mitre.org/data/definitions/14.html">CWE-14</a> : Compiler Removal of Code to Clear Buffers. </li></ol><br>   ,     ,   ,    " <a href="https://www.viva64.com/ru/k/0041/">  ‚Äî ?</a> ". <br><br> ,      ,      ,  ,    ,  .  ,     XNU Kernel   . <br><br> <b> N45</b> <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">private_extern__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YSHA1Final</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> digest[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">20</span></span></span></span><span class="hljs-function"><span class="hljs-params">], YSHA1_CTX* context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">u_int32_t</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> finalcount[<span class="hljs-number"><span class="hljs-number">8</span></span>]; .... <span class="hljs-comment"><span class="hljs-comment">/* Wipe variables */</span></span> i = j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(context-&gt;buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(context-&gt;state, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(context-&gt;count, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(finalcount, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;= #ifdef SHA1HANDSOFF YSHA1Transform(context-&gt;state, context-&gt;buffer); #endif }</span></span></code> </pre> <br>  PVS-Studio: V597 CWE-14 The compiler could delete the 'memset' function call, which is used to flush 'finalcount' buffer. The memset_s() function should be used to erase the private data. sha1mod.c 188 <br><br>     Release-    ,     "// &lt;=".      . <br><br> <b> N46</b> <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">private_extern__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YSHA1Transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">u_int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buffer[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">64</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">u_int32_t</span></span> a, b, c, d, e; .... state[<span class="hljs-number"><span class="hljs-number">0</span></span>] += a; state[<span class="hljs-number"><span class="hljs-number">1</span></span>] += b; state[<span class="hljs-number"><span class="hljs-number">2</span></span>] += c; state[<span class="hljs-number"><span class="hljs-number">3</span></span>] += d; state[<span class="hljs-number"><span class="hljs-number">4</span></span>] += e; <span class="hljs-comment"><span class="hljs-comment">/* Wipe variables */</span></span> a = b = c = d = e = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  PVS-Studio: V1001 CWE-563 The 'a' variable is assigned but is not used until the end of the function. sha1mod.c 120 <br><br>     ,  ,        . <br><br>   ,   PVS-Studio      <a href="https://cwe.mitre.org/data/definitions/563.html">CWE-563</a> .   ,            CWE       CWE-563.         CWE-14,     ,      . <br><br><h3> CWE-783: Operator Precedence Logic Error </h3><br>  <a href="https://cwe.mitre.org/data/definitions/783.html">CWE-783</a>  ,        ,    ,   .     -     . <br><br> <b> N47</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getxattr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((error = copyinstr(uap-&gt;attrname, attrname, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(attrname), &amp;namelen) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } .... out: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (error); }</code> </pre> <br>  PVS-Studio: V593 CWE-783 Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'. vfs_syscalls.c 10574 <br><br>  .          ( <a href="https://www.viva64.com/ru/examples/v593/">proof</a> ).   ,    -       . <br><br>  , : <br><br><pre> <code class="cpp hljs">Status s = foo(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == Error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s;</code> </pre> <br>  : <br><br><pre> <code class="cpp hljs">Status s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s = foo() == Error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s;</code> </pre> <br>     . <ul><li>  ,    : (s = foo()) == Error. </li><li>   ,   : s = (foo() == Error). </li></ul><br>    <i>return</i>    ,  1,   ,   <i>Error</i> . <br><br>        ¬´ ¬ª      . ¬´¬ª     ,    .        - " <a href="https://www.viva64.com/ru/b/0391/">  ,    </a> ". . : <ul><li> 11.      </li><li> 16. ¬´   ¬ª ‚Äî    </li></ul><br>     XNU Kernel.   ,  <i>getxattr</i>   1,     . <br><br> <b> N48 ‚Äî N52</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memorystatus_init_snapshot_vmstats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">memorystatus_jetsam_snapshot_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *snapshot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">kern_return_t</span></span> kr = KERN_SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">mach_msg_type_number_t</span></span> count = HOST_VM_INFO64_COUNT; <span class="hljs-keyword"><span class="hljs-keyword">vm_statistics64_data_t</span></span> vm_stat; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((kr = host_statistics64(.....) != KERN_SUCCESS)) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"memorystatus_init_jetsam_snapshot_stats: "</span></span> <span class="hljs-string"><span class="hljs-string">"host_statistics64 failed with %d\n"</span></span>, kr); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;snapshot-&gt;stats, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(snapshot-&gt;stats)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { + .... }</code> </pre> <br>  PVS-Studio: V593 CWE-783 Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'. kern_memorystatus.c 4554 <br><br>  <i>kr</i>      : 0  1. -   <i>printf</i>    1,    ,    <i>host_statistics64</i> . <br><br>   . ,      ,   .        . <br><br>     ,     : <br><br><ul><li> V593 CWE-783 Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'. vfs_syscalls.c 10654 </li><li> V593 CWE-783 Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'. vfs_syscalls.c 10700 </li><li> V593 CWE-783 Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'. vfs_syscalls.c 10759 </li><li> V593 CWE-783 Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'. kern_exec.c 2297 </li></ul><br><h3> CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior </h3><br>           C  C++  .    PVS-Studio    ,     : V567, V610, V611, V681, V704, V708, V726, V736. <br><br>    XNU      <a href="https://cwe.mitre.org/data/definitions/758.html">CWE-758</a> ,    ,    . <br><br> <b> N53, N54</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pfr_prepare_network</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">union</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sockaddr_union *sa, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> af, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> net)</span></span></span><span class="hljs-function"> </span></span>{ .... sa-&gt;<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>.sin_addr.s_addr = net ? htonl(<span class="hljs-number"><span class="hljs-number">-1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">32</span></span>-net)) : <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  PVS-Studio: V610 CWE-758 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '-1' is negative. pf_table.c 976 <br><br>        .         ,    .          .  This can be done like this: <br><br><pre> <code class="cpp hljs">htonl((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)(<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; (<span class="hljs-number"><span class="hljs-number">32</span></span>-net))</code> </pre> <br>     PVS-Studio  : V610 CWE-758 Undefined behavior. Check the shift operator '&lt;&lt;'. The left operand '-1' is negative. pf_table.c 983 <br><br><h3> CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak') </h3><br>    XNU Kernel  ,          ( <a href="https://cwe.mitre.org/data/definitions/401.html">CWE-401</a> ).   3  ,         <i>delete</i> .     ,    . <br><br> <b> N55, N56, N57</b> <br><br><pre> <code class="cpp hljs">IOService * IODTPlatformExpert::createNub(IORegistryEntry * from) { IOService * nub; nub = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOPlatformDevice; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nub) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !nub-&gt;init( from, gIODTPlane )) { nub-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(); nub = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (nub); }</code> </pre> <br> V773 CWE-401 The 'nub' pointer was assigned values twice without releasing the memory. A memory leak is possible. IOPlatformExpert.cpp 1287 <br><br>   <i>init</i>    ,     .   ,     <i>delete,</i>      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !nub-&gt;init( from, gIODTPlane )) { nub-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> nub; nub = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>   ,  . ,  <i>free</i>   ,   ¬´delete *this;¬ª.     ,    ,     ,   . <br><br>   : <ul><li> V773 CWE-401 The 'inst' pointer was assigned values twice without releasing the memory. A memory leak is possible. IOUserClient.cpp 246 </li><li> V773 CWE-401 The 'myself' pointer was assigned values twice without releasing the memory. A memory leak is possible. IOPMrootDomain.cpp 9151 </li></ul><br><br><h3> CWE-129: Improper Validation of Array Index </h3><br>  <a href="https://cwe.mitre.org/data/definitions/129.html">CWE-129</a>   ,      ,      .  ,      . <br><br> <b> N58 ‚Äî N61</b> <br><br><pre> <code class="cpp hljs">IOReturn IOStateReporter::updateChannelValues(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channel_index) { .... state_index = _currentStates[channel_index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (channel_index &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || channel_index &gt; (_nElements - state_index) / _channelDimension) { result = kIOReturnOverrun; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> finish; } .... }</code> </pre> <br>  PVS-Studio: V781 CWE-129 The value of the 'channel_index' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 852, 855. IOStateReporter.cpp 852 <br><br>      .      ,     ,     . <br><br>  ,      : <br><br><pre> <code class="cpp hljs">IOReturn IOStateReporter::updateChannelValues(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channel_index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (channel_index &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { result = kIOReturnOverrun; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> finish; } state_index = _currentStates[channel_index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (channel_index &gt; (_nElements - state_index) / _channelDimension) { result = kIOReturnOverrun; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> finish; } .... }</code> </pre> <br> ,    ,   <i>channel_index</i>    .     ,       XNU Kernel. <br><br>  : <br><br><ul><li> V781 CWE-129 The value of the 'channel_index' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 651, 654. IOStateReporter.cpp 651 </li><li> V781 CWE-129 The value of the 'pri' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 267, 269. pktsched_fq_codel.c 267 </li><li> V781 CWE-129 The value of the 'pcid' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 224, 225. pmap_pcid.c 224 </li></ul><br><h3> CWE-480: Use of Incorrect Operator </h3><br>  CWE-480    -   . ,  ,   ,      .      ,     .   ,        ,        . <br><br> <b> N62</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NFS_UC_QUEUE_SLEEPING 0x0001 static void nfsrv_uc_proxy(socket_t so, void *arg, int waitflag) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (myqueue-&gt;ucq_flags | NFS_UC_QUEUE_SLEEPING) wakeup(myqueue); .... }</span></span></code> </pre> <br>  PVS-Studio: V617 CWE-480 Consider inspecting the condition. The '0x0001' argument of the '|' bitwise operation contains a non-zero value. nfs_upcall.c 331 <br><br> -  ¬´¬ª ,  . ,  ¬´¬ª ,   .  ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myqueue-&gt;ucq_flags &amp; NFS_UC_QUEUE_SLEEPING) wakeup(myqueue);</code> </pre> <br><br><h3> CWE-665: Improper Initialization </h3><br>  PVS-Studio       CWE.    ,     <a href="https://cwe.mitre.org/data/definitions/665.html">CWE-665</a> . <br><br> <b> N63</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bzero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_template</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_qos_override</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_qos_override</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override_next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> override_contended_resource_count; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> override_qos; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> override_resource_type; <span class="hljs-keyword"><span class="hljs-keyword">user_addr_t</span></span> override_resource; } *overrides; .... }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_bootstrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... bzero(&amp;thread_template.overrides, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(thread_template.overrides)); .... }</code> </pre> <br>  PVS-Studio: V568 It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'thread_template.overrides' class object. thread.c 377 <br><br>   ,  ,    ,   <i>bzero</i> . ,   <i>nullptr</i>  . <br><br>   <i>bzero</i> ‚Äî        .    : <br><br><pre> <code class="cpp hljs">thread_template.overrides = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>    ,    ,    .        : <br><br><pre> <code class="cpp hljs">bzero(thread_template.overrides, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*thread_template.overrides));</code> </pre> <br><h3> CWE-691: Insufficient Control Flow Management </h3><br> <a href="https://cwe.mitre.org/data/definitions/691.html">CWE-691</a>        .     ‚Äî     ,   .          XNU Kernel. <br><br> <b> N64</b> <br><br> ,       ! ,    ,    ,  ,  ,  ,           .   ,  XNU Kernel   ,  ,  ,      .        64,       <a href="https://www.viva64.com/">viva64</a> . <br><br>  Note. ,  ,   ¬´viva64¬ª,     " <a href="https://www.viva64.com/ru/b/0465/"> 10     PVS-Studio</a> ". <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_page_release_startup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vm_page_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mem)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pmap_startup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vm_offset_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *startp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vm_offset_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *endp)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// -debug code remove if (2 == vm_himemory_mode) { for (i = 1; i &lt;= pages_initialized; i++) { .... } } else // debug code remove- /* * Release pages in reverse order so that physical pages * initially get allocated in ascending addresses. This keeps * the devices (which must address physical memory) happy if * they require several consecutive pages. */ for (i = pages_initialized; i &gt; 0; i--) { if(fill) fillPage(....); vm_page_release_startup(&amp;vm_pages[i - 1]); } .... }</span></span></code> </pre> <br>  PVS-Studio: V705 CWE-691 It is possible that 'else' block was forgotten or commented out, thus altering the program's operation logics. vm_resident.c 1248 <br><br> ,    .       <i>else</i> .    ,  ,    .         <i>(2 == vm_himemory_mode)</i>  . <br><br><h2>  Conclusion </h2><br>   macOS       <a href="https://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> ,           C  C++.             . <br><br>            ,  PVS-Studio     macOS. <br><br><p> <a href="https://www.viva64.com/en/b/0566/"><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>        ,      : Andrey Karpov. <a href="https://www.viva64.com/en/b/0566/">PVS-Studio is now available on macOS: 64 weaknesses in the XNU Kernel</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="https://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/352206/">https://habr.com/ru/post/352206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352194/index.html">How to grow from a junior tester into a good tester? Continuation</a></li>
<li><a href="../352196/index.html">Comparison of ITSM-systems</a></li>
<li><a href="../352198/index.html">Classes and factory functions in javascript. What to choose?</a></li>
<li><a href="../352200/index.html">How to turn a website into a mobile application using 7 lines of JSON</a></li>
<li><a href="../352202/index.html">The book "Head First. Design patterns. Updated anniversary edition ¬ª</a></li>
<li><a href="../352208/index.html">How to perform many UI tests in parallel using Selenium Grid?</a></li>
<li><a href="../352210/index.html">Automation in the development of the platform "1C: Enterprise"</a></li>
<li><a href="../352212/index.html">Gaijin Engineer in Tokyo</a></li>
<li><a href="../352214/index.html">Unblock Hackathon Registration Open April 6-8</a></li>
<li><a href="../352218/index.html">US authorities will check the activities of the cryptocurrency fund founder techclog TechCrunch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>