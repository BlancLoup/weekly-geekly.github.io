<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Replicated object. Part 1: Introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface . This publication is the author's translation of his own article. Therefore, if you find an error in the translation, it may well be that the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Replicated object. Part 1: Introduction</h1><div class="post__text post__text-html js-mediator-article">  <strong>Preface</strong> .  This publication is the author's translation of his own article.  Therefore, if you find an error in the translation, it may well be that the error is, in fact, in the original article. <br><br><h2>  annotation </h2><br><blockquote><ol><li>  There is suffering. </li><li>  There is a cause of suffering. </li><li>  There is a cessation of suffering. </li><li>  There is a path leading to deliverance from suffering. </li></ol><br>  <em>4 noble truths of buddhism</em> <br></blockquote><br>  This article contains a description of an early prototype that introduces the concept of a <em>replicated object</em> or <em>replob for short</em> .  Such an object is a further rethinking of the struggle with the complexity of the code that arises when programming distributed systems.  Replob eliminates dependency on a third-party service and implements a consistent change to any user objects representing the corresponding data and functionality.  This idea is based on the use of expressiveness of the C ++ language and an object-oriented approach, which allows using complex logic within distributed transactions.  This makes it possible to significantly simplify the development of fault-tolerant applications and services.  Subsequent articles will explain in more detail the developed approach. <br><br><h2>  Introduction </h2><br>  <strong>WARNING</strong> .  Almost all the methods mentioned in the article contain dirty memory hacks and abnormal use of the C ++ language.  So, if you are not tolerant of such perversions, please do not read this article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the moment, the topic related to distributed systems is one of the most interesting, and attracts a large number of people, including developers and scientists.  The popularity is explained simply: we must create reliable fault-tolerant systems that provide a safe environment for performing various operations and for storing data. <br><a name="habracut"></a><br>  At the same time, maintaining the consistency of a distributed system plays an important role.  Ensuring consistency of a high level is given a considerable price.  Today there are a number of solutions that provide the weakest form of consistency: the so-called consistency in the long run (eventual consistency).  On the one hand, such solutions have relatively good performance, but on the other hand, they cannot be used in many areas where it is necessary to have transactional semantics of operations.  The fact is that it is much easier to think about the system using one of the strong levels of consistency like <em>strict consistency</em> or <em>linearizability</em> .  Such levels of consistency make it much easier to develop a reliable application with secure semantics for the execution of a sequence of operations. <br><br><h2>  Overview </h2><br><blockquote>  As life shows, happiness is less dependent on external things than most believe. <br><br>  <em>Warren cowper</em> <br></blockquote><br>  For the development of a distributed system most often use specialized services.  These services should provide a convenient way to deal with the complexity associated with the asynchronous nature of distributed tasks and with various types of failures, including network problems, application crashes, and hardware failures.  In a distributed environment, these problems should not be regarded as something out of the ordinary, but should be treated as things quite ordinary and ordinary.  Thus, the task of creating a reliable and consistent service for solving problems arising in distributed systems appears on the scene. <br><br>  Modern systems use fault-tolerant services such as <a href="http://zookeeper.apache.org/">Zookeeper</a> (mostly) or <a href="https://coreos.com/etcd/">etcd</a> (under active development).  They use distributed consensus algorithms: <a href="https://web.stanford.edu/class/cs347/reading/zab.pdf">Zab</a> (Zookeeper) or <a href="https://ramcloud.stanford.edu/raft.pdf">Raft</a> (etcd) to ensure that operations are linear.  The idea here is as follows.  In the first step, a leader is elected, then the appointed leader (master) records the messages in a certain sequence, which ensures the necessary level of consistency.  Although the <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab%2Bvs.%2BPaxos">Zookeeper documentation</a> claims that Zookeeper implements an approach using a primary backup, rather than a <a href="https://en.wikipedia.org/wiki/State_machine_replication">state machine replication</a> , it is clear that the only difference between these approaches is that the primary backup is based on the order specified by the replicas, and replication finite state machine is based on the sequence given by the client.  I think that it is important here that both approaches agree on the <em>sequence of deterministic operations</em> using the developed <em>consensus</em> algorithms <em>based on the wizard</em> . <br><br><h2>  Discussion of existing approaches </h2><br><blockquote>  It should always be remembered that we cannot control events, but must adapt to them. <br><br>  <em>Epictet</em> <br></blockquote><br>  The lack of a <em>wizard based distributed consensus</em> algorithm is obvious: it takes a certain period of time to process the state associated with the fall of the master.  The timeout for detecting the fall of the master can not be very small, because it can have a negative impact on performance due to the high probability of choosing a new master.  At the same time, the timeout cannot be very large due to a significant increase in the delay in processing the master's fall.  Thus, we, in fact, have some compromise between the delay in processing messages and the probability of re-election of the master, which, in general, depends on the network conditions and the performance of cluster machines.  At the same time, the performance of the consensus algorithm strictly depends on the survivability of the wizard, and sometimes it takes considerable time to recover and maintain data consistency.  Such logic requires at least several exchanges of network messages, the recording of incomplete operations, and this process does not guarantee convergence for any period of time even in the absence of crashes, because each participant can declare himself as a new master.  Thus, for some operations, the system may not be available for a relatively long period of time: <br><ol><li>  <a href="http://research.google.com/archive/chubby-osdi06.pdf">Chubby</a> : Most problems lasted about 15 seconds or less, 52 of which were around 30 seconds. </li><li>  <a href="http://docs.mongodb.org/manual/faq/replica-sets/">MongoDB</a> : the time varied, but the replicas were chosen by the master for a minute ... During the selection of the master, the cluster was not available for recording. </li><li>  <a href="https://aphyr.com/posts/291-call-me-maybe-zookeeper">Zookeeper</a> : The new leader was elected after 15 seconds or so, and the recording continued again.  However, only clients who had access to one of the nodes [n3 n4 n5] could write, and clients connected to the nodes [n1 n2] completed their processing with a timeout while trying to connect with the leader. </li></ol><br><h3>  Transactional semantics and nontrivial scenarios </h3><br><blockquote>  Logic is the art of making mistakes with self-righteousness. <br><br>  <em>J. U. Krach</em> <br></blockquote><br>  Using transactional semantics for nontrivial logic is one of the most difficult problems.  Let's assume that we have a secure repository like the Zookeeper, and we would like to perform the following sequence of operations: <br><ol><li>  Download some of the data from the repository to the process memory for work. </li><li>  The use of nontrivial logic for data processing and obtaining the result. </li><li>  Saving the result in the repository. </li></ol><br>  This scenario can be solved by applying several approaches. <br><br><h4>  Pessimistic blocking </h4><br>  Pessimistic locking is based on explicitly locking a used resource, similar to the mutex approach for multi-threaded applications.  The task above can be solved by applying the following sequence of operations: <br><ol><li>  Getting an exclusive lock for the operation. </li><li>  Perform the operations described above (load, apply and save). </li><li>  Unlocking. </li></ol><br>  The disadvantage of this scheme follows directly from the requirement of exclusivity of access: <br><ol><li>  Exclusive locking significantly increases the waiting time when locking / unlocking is performed.  That, in turn, worsens the total time of operations. </li><li>  In the case of a process crash in the middle of performing operations, we can potentially get inconsistent data (fortunately, Zookeeper has the functionality to atomic apply several operations at the unlock stage).  This requires additional time to detect the fall of the process and the subsequent unlocking of the resource, which increases the total time of such an operation. </li></ol><br>  I would like to emphasize that systems like Zookeeper do not have explicit locking and unlocking features.  For pessimistic blocking, you need to use a special <a href="http://zookeeper.apache.org/doc/r3.1.2/recipes.html">recipe</a> , but it introduces an additional delay for this kind of transaction (see also: <a href="http://infoscience.epfl.ch/record/181690/files/OpenAPI.pdf">Addressing the ZooKeeper Synchronization Inefficiency</a> ). <br><br>  In this regard, a different way of solving the problem appears on the scene. <br><br><h4>  Optimistic blocking </h4><br>  The optimistic scheme attempts to circumvent the performance problems of the previous approach.  The idea is to check the actual state of the data before recording the operations: <br><ol><li>  Load the status of current data from the repository. </li><li>  Local application of nontrivial logic and the creation of a set of operations for writing. </li><li>  Atomic checking that no other transaction has changed the data, and fixing a set of operations for writing. </li><li>  If the check failed =&gt; repeat operations, starting with the first step. </li></ol><br>  All actions in the third step should be executed atomically, including checking and fixing changes.  Such a scheme can be implemented using an incremental version counter: for any successful update operation, we increment the counter by one.  The idea is to use the <a href="https://en.wikipedia.org/wiki/Compare-and-swap">‚Äúcompare with exchange‚Äù operation</a> , which atomically checks that the data version has not changed, which means that the data itself has remained unchanged. <br><br>  However, this scheme has drawbacks: <br><ol><li>  <strong>The complexity of implementation</strong> : the service must implement the operation "comparison with the exchange" and fixing the packet recording, and you must be able to perform these two operations in an atomic manner. </li><li>  <strong>High cost with high competitiveness</strong> : with a considerable number of simultaneous updates, the algorithm requires repeating steps from the very beginning, thereby wasting resources due to conflicts that arise due to frequent changes in data. </li></ol><br>  In addition, for pessimistic and optimistic locking, we must serialize our internal data in the hierarchical key space of the corresponding system (for example, Zookeeper <a href="http://zookeeper.apache.org/doc/r3.1.2/zookeeperOver.html">"znodes"</a> or etcd <a href="">"nodes"</a> ).  All the facts mentioned complicate the application being developed, and the approach becomes subject to various kinds of errors.  Therefore, I would like to go in a completely different direction. <br><br><h2>  Concept of replicated object </h2><br><blockquote>  The complex must be approached simply, otherwise we will never understand it. <br><br>  <em>Jiju krishnamurti</em> </blockquote><br>  Let's take a step back and recall <em>object-oriented programming</em> (OOP).  Here we have the concept of <em>objects</em> .  Each such object owns certain data representing the <em>state of the</em> object.  In this case, an object contains a set of <em>methods</em> that transform an object from one state to another. <br><br>  Thus, the idea is to replicate actions ( <em>object methods</em> ) between the nodes of a cluster instead of replicating the data itself ( <em>object state</em> ).  These actions deterministically change the state of the object and create the illusion that the object itself is replicated.  At the same time, linearizability ensures that all replicas accept the same sequence of actions, thus obtaining a consistent state of the distributed object under consideration.  This is very similar to the <a href="https://en.wikipedia.org/wiki/State_machine_replication">state machine replication</a> model.  The only difference is that I use a normal <em>object</em> to represent the <em>state</em> and <em>methods</em> to represent <em>events</em> that transform the object.  This mapping greatly reduces the complexity of development and allows you to use the power of the C ++ language, since it initially supports the use of OOP without bloatting code. <br><br><h2>  Properties of the replicated object </h2><br>  My replicated object (or just <em>replob</em> ) has the following properties: <br><ol><li>  Built. </li><li>  Without a master. </li><li>  Storage in memory. </li><li>  Linearized consistency. </li><li>  FIFO warranty for the process. </li><li>  Fast local readings. </li><li>  Competitive flexible distributed transactions. </li><li>  Support for the option of independent parallel transactions. </li><li>  Support for any native data structures. </li><li>  You can customize CAP. </li><li>  Smooth degradation of a set of replicas. </li><li>  Security and survivability with various network problems: <br><ol><li>  Network connectivity violation. </li><li>  Partial violation of the network connectivity type "bridge". </li><li>  Temporary network instability. </li><li>  Partial direction of network packets. </li></ol><br></li></ol><br>  Below I will briefly review each item. <br><blockquote>  In case of verbosity, sin cannot be avoided, but its mouth restraint is reasonable. <br><br>  <em>Ecclesiastes</em> <br></blockquote><br>  <strong>Built</strong> .  This is not a standalone service.  The functionality works within the user process, which reduces the latency of operations by reducing the number of network messages between replicas.  This approach completely eliminates external dependency on services like Zookeeper or etcd and uses native interfaces, which seriously simplifies interaction with replication logic, making it completely transparent to the user. <br><br>  <strong>Without a master</strong> .  The algorithm does not have a dedicated master (leader).  Thus, each node is indistinguishable from each other.  This significantly reduces delays in recovery from crashes, and also creates more predictable behavior in most cases. <br><br>  <strong>Storage in memory</strong> .  The current implementation does not have a persistent layer, and each element is distributed among the replicas inside the process memory.  The algorithm, however, allows you to add a persistence property for objects. <br><br>  <strong>Linearized consistency</strong> .  The algorithm of replicated objects provides a guarantee of linearizability of operations. <br><br>  <strong>FIFO warranty for the process</strong> .  For the specified process, all operations will be completed in order of their planning by this process (FIFO-order). <br><br>  <strong>Fast local readings</strong> .  Special mode allows you to read data locally by reducing the consistency level to consistent consistency.  This significantly reduces latency and overall system load. <br><br>  <strong>Competitive flexible distributed transactions</strong> .  Inside a transaction, you can use a deterministic sequence of operations of any degree of complexity.  Such transactions are handled in a competitive manner. <br><br>  <strong>Support for the option of independent parallel transactions</strong> .  A user may have multiple instances of a consensus implementation for parallelizing independent transactions. <br><br>  <strong>Support for any native data structures</strong> .  A developer can use any standard containers, such as <code>std::vector</code> , <code>std::map</code> , etc., as well as <code>boost::optional</code> , <code>boost::variant</code> or other data structures that support the copy semantics. <br><br>  <strong>You can customize CAP</strong> .  The user can choose between linearizability and availability in cases of network connectivity violations. <br><br>  <strong>Smooth degradation of a set of replicas</strong> .  The system maintains consistency even under conditions where the number of replicas decreases significantly.  For example, the number of replicas can be reduced from five to two, and in some situations even reduced to one replica. <br><br>  <strong>Security and survivability with various network problems</strong> .  There are a number of different network problems (see <a href="https://aphyr.com/posts/288-the-network-is-reliable">Aphyr: The network is reliable</a> ).  In this case, the algorithm preserves consistency and performance in these cases. <br><br>  All of these points will be discussed in detail in subsequent articles. <br><br><h2>  Examples </h2><br><blockquote>  You can be invincible if you do not enter into any battle in which victory does not depend on you. <br><br>  <em>Epictet</em> <br></blockquote><br>  To demonstrate all the flexibility and power of the approach, I will consider a fairly simple example. <br><br><h3>  Example: key-value store </h3><br>  Let's implement replicated storage with the following interface (I omit the <code>std::</code> and <code>boost::</code> namespaces for short): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KV</span></span></span><span class="hljs-class"> {</span></span> optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> optional&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; value)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; kv_; };</code> </pre><br>  For simplicity, I chose a symmetrical interface.  <code>set</code> method removes the corresponding key if an empty value was passed.  When using a regular object, the corresponding implementations may be as follows: <br><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; KV::get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kv_.count(key) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kv_.at(key); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> KV::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) kv_[key] = *value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> kv_.erase(key); }</code> </pre><br>  Now I would like to convert our regular object into a <em>replicable object</em> .  For this, I just add: <br><br><pre> <code class="cpp hljs">DECL_REPLOB(KV, get, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>)</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Hint</b> <div class="spoiler_text">  Hint: The implementation of the <code>DECL_REPLOB</code> is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECL_REPLOB DECL_ADAPTER</span></span></code> </pre><br></div></div><br>  And then I can use the following line of code to replicate my replica set data: <br><br><pre> <code class="cpp hljs">replob&lt;KV&gt;().<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"world!"</span></span>});</code> </pre><br>  After completing the <code>KV::set</code> call, all instances of the <code>KV</code> type from the replica set will contain the specified pair.  Note that an instance can be referenced through the <code>KV</code> type, which means that each replica contains its own single instance of this object. <br><br>  To read data with a linearized consistency level, you should write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> world = replob&lt;KV&gt;().get(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>});</code> </pre><br>  But to improve the performance for this read operation, I just write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> localWorld = replobLocal&lt;KV&gt;().get(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>});</code> </pre><br>  Like this! <br><br><h4>  Transactions </h4><br>  Let's assume that I want to change the value to the specified key.  The naive way is to write such code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> world = replobLocal&lt;KV&gt;().get(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}).value_or(<span class="hljs-string"><span class="hljs-string">"world!"</span></span>); replob&lt;KV&gt;().<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}, <span class="hljs-string"><span class="hljs-string">"hello "</span></span> + world);</code> </pre><br>  The problem here is only that successive two atomic operations do not give a total atomic operation (the so-called <em>state of the race of the second kind</em> ).  Thus, we need to put all our actions inside a transaction: <br><br><pre> <code class="cpp hljs">MReplobTransactInstance(KV) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> world = $.get(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}).value_or(<span class="hljs-string"><span class="hljs-string">"world!"</span></span>); $.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}, <span class="hljs-string"><span class="hljs-string">"hello "</span></span> + world); };</code> </pre><br>  Then all the specified actions will be applied on all replicas atomically. <br><br><h4>  Results Transactions </h4><br>  Consider the following task: it is necessary to calculate the size of the value for the specified key.  There is nothing easier: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// use local instance because we do not need to update the object auto valueLength = MReplobTransactLocalInstance(KV) { return $.get(string{"hello"}).value_or("").size(); };</span></span></code> </pre><br>  The same approach can be used to modify the object: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valueLength = MReplobTransactInstance(KV) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> world = $.get(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}); $.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"another"</span></span>}, world); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> world.value_or(<span class="hljs-string"><span class="hljs-string">""</span></span>).size(); };</code> </pre><br>  All specified operations are applied on replicas atomically. <br><br><h4>  Multiple replob transactions </h4><br>  Let's assume that we have two independent instances of key-value storages: <code>KV1</code> and <code>KV2</code> .  We can combine operations for different instances into one transaction using the modifier <code>MReplobTransact</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the first transaction is distributed // performs value copying from KV2 to KV1 for the same key MReplobTransact { $.instance&lt;KV1&gt;().set( string{"hello"}, $.instance&lt;KV2&gt;().get(string{"hello"})); }; // the second transaction is applied locally // returns total value size calculation for the same key auto totalSize = MReplobTransactLocal { auto valueSize = [](auto&amp;&amp; val) { return val.value_or("").size(); }; return valueSize($.instance&lt;KV1&gt;().get(string{"hello"})) + valueSize($.instance&lt;KV2&gt;().get(string{"hello"})); };</span></span></code> </pre><br>  Should I mention that all these actions are performed atomically, with the first transaction being distributed and running on all replicas? <br><br><h4>  Advanced example </h4><br>  Let's look at the iteration through the collection using a user-defined function: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KV</span></span></span><span class="hljs-class"> {</span></span> optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> optional&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; value)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// generic method to iterate through the collection template&lt;typename F&gt; void forEach(F f) const { for (auto&amp;&amp; v: kv_) f(v); } private: unordered_map&lt;string, string&gt; kv_; };</span></span></code> </pre><br>  Now the task is to return the total row size for all values: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valuesSize = MReplobTransactLocalInstance(KV) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sz = <span class="hljs-number"><span class="hljs-number">0</span></span>; $.forEach([&amp;sz](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; v) { sz += v.second.size(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sz; };</code> </pre><br>  As you can see, everything is implemented quite straightforwardly. <br><br><h2>  Further directions </h2><br><blockquote>  If you know in advance what you want to come to, then steps in this direction are not an experiment at all. <br><br>  <em>Jiju krishnamurti</em> <br></blockquote><br>  Earlier, I looked at some simple, but rather interesting, in my opinion, examples of how to use the replicated object approach.  Subsequent articles will introduce, step by step, the used ideas and concepts: <br><ol><li>  Divine adapter. </li><li>  Non-blocking synchronization without interlocking or a <em>subject-specific model</em> . </li><li>  Homogeneous actor model or <em>functor model</em> . </li><li>  Super-generic serialization. </li><li>  Behavior modifiers </li><li>  IO and coroutines. </li><li>  Consistency and applicability issues of the CAP theorem. </li><li>  Phantom, replob and <em>consensus algorithm without a master</em> . </li><li>  Examples of implementation: <br><ol><li>  Atomic failure detector. </li><li>  Distributed scheduler. </li></ol></li></ol><br><h2>  findings </h2><br><blockquote>  Maturity is the transition from reliance on others to self-reliance. <br><br>  <em>Frederick Pearls</em> <br></blockquote><br>  We have considered the introduction of a built-in failover distributed replicable object that has many unusual properties.  These properties can significantly reduce the complexity of creating a reliable distributed application, and opens up new horizons for the application of such an object in a wide range of emerging tasks. <br><br>  The algorithm for reaching a consensus without a master allows you to handle various failure situations in a predictable way without significant loss of time.  The built-in approach eliminates network delays when reading data.  At the same time, the strong consistency model provides a convenient way of interacting with a replicable object, and also allows using it as flexibly as possible within distributed transactions. <br><br>  <em>I want to express my special thanks to <a href="https://plus.google.com/113021723671522138605">Sergey Polovko</a> , <a href="https://plus.google.com/117023091752061088817">Yauheni Akhotnikau</a> and Petr Prokhorenkov for helpful comments and advice.</em> <br><br><h2>  Questions for self-test </h2><br><blockquote>  The only difficulty is to ask the right question. <br><br>  <em>Frederick Pearls</em> <br></blockquote><br><ol><li>  How is <code>DECL_REPLOB</code> implemented? </li><li>  What is the difference between local and non-local operations? </li><li>  Is it possible to implement a consensus algorithm without a master? </li><li>  List all the behavior modifiers mentioned in the article. </li></ol><br><h2>  Bibliography </h2><br>  [1] Documentation: <a href="http://zookeeper.apache.org/">Zookeeper</a> . <br>  [2] Documentation: <a href="https://coreos.com/etcd/">etcd</a> . <br>  [3] Article: <a href="https://web.stanford.edu/class/cs347/reading/zab.pdf">Zab: High-performance Broadcast For</a> <a href="https://web.stanford.edu/class/cs347/reading/zab.pdf"><br></a>  <a href="https://web.stanford.edu/class/cs347/reading/zab.pdf">Primary-Backup Systems</a> <br>  [4] Article: <a href="https://ramcloud.stanford.edu/raft.pdf">In Search of an Understandable Consensus Algorithm</a> <a href="https://ramcloud.stanford.edu/raft.pdf"><br></a>  <a href="https://ramcloud.stanford.edu/raft.pdf">(Extended version)</a> <br>  [5] Zookeeper Documentation: <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab%2Bvs.%2BPaxos">Zab vs.</a>  <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab%2Bvs.%2BPaxos">Paxos</a> <br>  [6] Article: <a href="http://research.google.com/archive/chubby-osdi06.pdf">The Chubby Lock For Loosely-Coupled Distributed Systems</a> . <br>  [7] MongoDB Documentation: <a href="http://docs.mongodb.org/manual/faq/replica-sets/">How long does replica set failover take?</a> <br>  [8] Aphyr blog: <a href="https://aphyr.com/posts/291-call-me-maybe-zookeeper">Zookeeper</a> . <br>  [9] Documentation: <a href="http://zookeeper.apache.org/doc/r3.1.2/recipes.html">ZooKeeper Recipes and Solutions: Locks</a> . <br>  [10] Article: <a href="http://infoscience.epfl.ch/record/181690/files/OpenAPI.pdf">Addressing the ZooKeeper Synchronization Inefficiency</a> . <br>  [11] Documentation: <a href="http://zookeeper.apache.org/doc/r3.1.2/zookeeperOver.html">Zookeeper znodes</a> . <br>  [12] Documentation: <a href="">etcd nodes</a> . <br>  [13] Wikipedia: <a href="https://en.wikipedia.org/wiki/State_machine_replication">State Machine Replication</a> . <br>  [14] Aphyr blog: <a href="https://aphyr.com/posts/288-the-network-is-reliable">The Network Is Reliable</a> . <br>  [15] Article: <a href="https://www.usenix.org/legacy/events/usenix10/tech/full_papers/Hunt.pdf">ZooKeeper: Wait-Free Coordination For Internet-Scale Systems</a> . </div><p>Source: <a href="https://habr.com/ru/post/267509/">https://habr.com/ru/post/267509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267499/index.html">Messy about developing letters</a></li>
<li><a href="../267501/index.html">Localizing Google Chrome Extensions - Necessary and Easy</a></li>
<li><a href="../267503/index.html">Python Meetup 08.28.15: full-text search and Europython 2015</a></li>
<li><a href="../267505/index.html">Basics of NHibernate (easy tutorial)</a></li>
<li><a href="../267507/index.html">Another way to disable telemetry collection in Windows 10 OS</a></li>
<li><a href="../267511/index.html">Yandeks.Blogi - we will think for you</a></li>
<li><a href="../267513/index.html">Matreshka.js 2: events</a></li>
<li><a href="../267515/index.html">C # attributes and types</a></li>
<li><a href="../267517/index.html">JetBrains have published updates to the new licensing and pricing policy.</a></li>
<li><a href="../267519/index.html">Adaptive video as a background site caps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>