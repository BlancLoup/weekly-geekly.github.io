<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UINavigationController and what it eats with: basic principles, subclassing, protection against double transitions and much more</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I do not pretend to be the ultimate truth, but I still understand the development of something. Therefore, I decided to share with you some of the res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UINavigationController and what it eats with: basic principles, subclassing, protection against double transitions and much more</h1><div class="post__text post__text-html js-mediator-article">  I do not pretend to be the ultimate truth, but I still understand the development of something.  Therefore, I decided to share with you some of the results of the work done, to share a certain compilation of knowledge about navigation controllers, so to speak.  Maybe this will help any of the haunted shells that can be further referred to as my readers, to create a more sophisticated software product. <br><br>  The subject of the study will be the navigation controller, namely the UINavigationController class from the standard UIKit framework for working with the interface that Apple kindly provides us. <br><br><h4>  Briefly about ... </h4><br>  ‚ÄúController‚Äù in this case is a certain class that encapsulates logic, according to the concept (also called a pattern) of <a href="https://ru.wikipedia.org/wiki/Model-View-Controller">MVC</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/ec6/282/c34/ec6282c340604845bb93e94407745c4e.png"><br><br><img src="https://habrastorage.org/files/41a/537/33f/41a53733f3174ee7aa6161bd58e2fed6.jpg"><br><br>  The navigation controller ( <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationController_Class/">UINavigationController</a> ) is a high-level class of abstraction, contains a hierarchy of other view controllers, between representations (UIView views) which are able to navigate (which is, in fact, its main task is!), Transferring at the right moment control to the corresponding the controller.  In addition - the composition contains a navigation bar (UINavigationBar), which displays on the screen, and accordingly changes the contents of this panel: depending on the active controller. <br><a name="habracut"></a><br>  At any time from the active controller, you can get both the current navigation Item and the navigation Bar: <code>self.navigationItem</code> <br> <code>self.navigationController.navigationBar</code> <br> <br>  The hierarchical structure is always tree-like: <br><img src="https://habrastorage.org/files/132/10c/bc2/13210cbc202845ee9a03c941fa35d811.png"><br><br><img src="https://habrastorage.org/files/1ed/a72/27f/1eda7227fc5d4714bdcc1a670ff06a78.png"><br><br><img src="https://habrastorage.org/files/979/e81/886/979e81886e584998900e42d45bc22e32.png"><br><br><h4>  Prehistory </h4><br>  My acquaintance with this control was initially superficial, but after one incident I had to go deeper.  The fact is that in one of my applications, in different places, due to the large amount of asynchrony, not weak connectivity - a lot of lewdness occurred during transitions from one screen to another, and double transitions constantly occurred, with quick touches (tachas).  Before that, I was able to successfully cope with various workarounds, but where could we go without striving for the perfect ... <br><br>  At one point, I needed to stop the double transition (after 2 levels of hierarchy, after the button is pressed back, and the button is quickly activated).  Actually it was required to put a lock at the time of the transition.  After some research, it turned out that there are 2 ways to do this: <br><br>  1) Create a button programmatically, hang up on a navigation bar, attach a corresponding selector (handler method) to it, in which you explicitly block and call one of the methods, like <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationController_Class/">popViewControllerAnimated:;</a> <br>  2) Use the protocol that implements the delegate for the UINavigationBarDelegate navigation bar. <br><br>  Unfortunately, the first approach had a clear drawback: by creating the button programmatically and hanging it on the navigation bar, I could not easily achieve the standard arrow and back button (I simply did not have this icon, it is taken from standard assets (sets )). <br><br>  After some sampling, it turned out that UINavigationBarDelegate allows only UINavigationController as delegate, and I decided to try to subclass for this beast. <br><br><h4>  About Delegation, Navigation, and Security Programming, UINavigationControllerDelegate / UInavigationBarDelegate </h4><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25B3%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">Delegation</a> is one of the fundamental design patterns, the essence of which is that we delegate (reassign) the response for any actions to the delegate class.  Specifically for objective-c: <br><br>  Class delegating behavior -&gt; delegate class <br>  - we assign the appropriate protocol to the delegate class, for example, we define all methods with the @required specifier <br>  and some methods marked with the @optional keyword <br>  - assign to the class that delegates the behavior, this delegate through the delegate property (the delegating class must have a property, something like @property (assign, nonatomic) id delegate;) <br>  - after that, if we write the first class, then in the right places we pull methods, not forgetting to do checks by type <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate &amp;&amp; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@protocol</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProtocol</span></span></span><span class="hljs-class">)] &amp;&amp; [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delegate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">respondsToSelector</span></span></span><span class="hljs-class">: @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">selector</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aMethod</span></span></span><span class="hljs-class">)])</span></span>{ [delegate aMethod]; }</code> </pre><br>  In general, how is it that one object hires another object so that this object explains to him what to do and how to act in certain situations.  So that‚Ä¶ <br><br><img src="https://habrastorage.org/files/f31/d44/5be/f31d445bebf74652bfaec3493f75ad0d.jpg"><br><br>  Creating a new subclass on objective-c like to call "subclassing", so I will not deviate much from these canons. <br><br>  What is the advantage of creating a subclass?  At first, I thought of handling only one situation in navigation, but later I came to the conclusion that it is much better to handle all similar situations centrally, to implement certain pieces of code directly in the navigation, in order to get rid of some root problems and for all other situations.  Another advantage is that you can centrally (in one place of the code) write configuration code that will be common to each controller (for example, in my case, disable multi-touch) <br><br>  Almost all navigation methods in this case begin with push / pop prefixes, something like pushing / pushing (not like push / pull antonyms in Git-e), but this was not the convention of naming target methods that I adopted.  A few words about UINavigationBar.  It contains a similar hierarchy, but NavigationItem.  These Items are UINavigationBar-a elements (there is no direct access to the subwoofers of this bar. And in the documentation it is clearly not recommended to get / change them in any way <code>frame/bounds/alpha <br></code> <code>frame/bounds/alpha <br></code>  UINavigationBar-a (it is still inherited from UIView)).  That is, the navigation bar should still be configured directly by the created and initialized navigationItem, and everything else must be from the crafty one.  Why all this?  And to the fact that UINavigationBarDelegate provides access to 4 methods: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)navigationBar:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationBar</span></span> *)navigationBar shouldPushItem:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationItem</span></span> *)item; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)navigationBar:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationBar</span></span> *)navigationBar didPushItem:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationItem</span></span> *)item; - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)navigationBar:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationBar</span></span> *)navigationBar shouldPopItem:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationItem</span></span> *)item; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)navigationBar:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationBar</span></span> *)navigationBar didPopItem:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationItem</span></span> *)item;</code> </pre><br>  Only from the name it should already be very clear that these are will / did methods.  The first is called before the corresponding action, the second - after.  Only in this case, the first method of the type of should, also provides an answer to the question: ‚ÄúDo this action?‚Äù Thus, the method should be launched before the animation of the replacement item-a navigationBar-a, and the method did ‚Äî after.  Proceeding from the task, my first idea was to block user interaction in the should method, and return it in the did method.  The push methods mean a movement down the hierarchy (toward a more particular one), and the pop methods towards the root. <br><br>  One of the key concepts of <a href="http://habrahabr.ru/post/191548/">defensive programming</a> in <a href="http://habrahabr.ru/post/201826/">asynchrony</a> is ‚Äúwe process accordingly, or we block intermediate states‚Äù.  Intermediate states (intermediate states) are always one of the main sources of bugs in programs.  Since the animation is inherently an asynchronous action (that is, the exact point in time is unknown when a piece of code is called that marks the end of the action, so it cannot be synchronized with other pieces of code. Asynchronous code is always executed in a separate thread), it should be escaped! <br><br>  In terms of defensive programming, the theoretical part is quite well described in the well-known <a href="http://www.ozon.ru/context/detail/id/3159814/">‚ÄúPerfect Code‚Äù</a> <br><br><img src="https://habrastorage.org/files/e37/c8f/217/e37c8f2179fe47dfb50a79e4bb342eb4.png"><br><br>  In addition, the transition animation (segue) from one root view to another also takes a certain amount of time, as it turned out, it is different from the animation time of the navigation bar.  The duration of the animation UINavigationBar-a is static and determined by the constant <br> <code>extern const CGFloat UINavigationControllerHideShowBarDuration;</code> <br> <br>  And the duration of the transition animation can be different.  The main reason for this is the viewDidLoad / viewWillAppear: / methods of building layout (layout-a) according to the construction rules (constraints / constraint).  Accordingly, the transition animation also needs to be screened. <br><br>  UINavigationController-a has a delegate protocol UINavigationControllerDelegate.  It defines 6 methods, 4 associated with transitions that allow processing the current animation directly (but Available ios 7.0 +, respectively, says that they are not yet relevant), but the other 2 are just a storehouse). <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)navigationController:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationController</span></span> *)navigationController willShowViewController:(<span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span> *)viewController animated:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)navigationController:(<span class="hljs-built_in"><span class="hljs-built_in">UINavigationController</span></span> *)navigationController didShowViewController:(<span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span> *)viewController animated:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated;</code> </pre><br>  Accordingly, the handlers for the start and end of the animation of the appearance of the view controller. <br><br><h4>  About transitions (Segues) </h4><br>  I would like a few words about the transitions (segue), recently they have become a convenient and fashionable technology, as they allow to work wonders on the sideboard.  Previously, to execute the transition, it was necessary to instantiate the controller instance, transfer the necessary data to the object, and run the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html">pushViewController: animated:</a> method, now it‚Äôs enough to create a ‚Äúsego‚Äù on the storyboard, on the action, if you need to hang up the identifier, configure.  In our case, the segue navigation controller is always run as a push (not as modal or something else). <br><br>  After that, you can work with any transition in the code; there are 3 UIViewController methods: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)prepareForSegue:(<span class="hljs-built_in"><span class="hljs-built_in">UIStoryboardSegue</span></span> *)segue sender:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender; - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)shouldPerformSegueWithIdentifier:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)identifier sender:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)performSegueWithIdentifier:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)identifier sender:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender;</code> </pre><br>  The first method allows you to perform any actions with the destination controller before its appearance, to process various transitions (transition <code>identifier</code> and <code>destinationViewController</code> ). <br><br>  The second method allows, among other things, to allow or interrupt the execution of the transition. <br><br>  The third method allows you to programmatically call the transition in the code, in fact, it contains the transition code with <code>pushViewController:animated:</code> <br><br>  The most important thing here is that push transitions using segue call the same methods from the navigationController (if any): <br><br><img src="https://habrastorage.org/files/84c/11a/050/84c11a050d8f470bbf2780ca7f4f8000.png"><br><br>  What else might be interesting here?  There are so-called reverse transitions (unwind segue), which perform transitions back through the controllers (they also contain pop methods).  And each of the UIStoryboardSegue has a perform method in which you can override the transition animation using the UIStoryboardSegue subclassing. <br><br>  Using transitions (segue) is the most up-to-date practice of moving from one view controller to another. <br><br><h4>  About the target-action model, the user interaction (User Interaction) </h4><br><br><img src="https://habrastorage.org/files/5a8/e29/364/5a8e2936465e4341b2462423c0a82bda.png"><br><br><img src="https://habrastorage.org/files/3f4/edf/8bd/3f4edf8bd77f4b799b669b7ea136d243.png"><br><br>  And in order to correctly perform the task - a few words about the user interaction with the interface.  When the user touches the screen, a touch event is generated and thrown in, unfortunately the UIEvent does not have an open constructor, so we are not able to easily create our touch events on the device screen, thus emulating this situation.  Controls throughout the application react to the corresponding events (events) intended for them, with the result that the interface becomes interactive and responsive to user actions. <br><br>  Some actions to events are already predetermined (for example, when we touch the button - the button goes into the highlighted state, and changes its appearance).  We can intercept events, and process them as we like, assigning handlers through selectors.  The selector stores a hash value that allows you to quickly select a method associated with it from the hash table of class selectors.  All events are assigned and sent (if I'm not mistaken) in the depths of the UIApplication class, which has 2 important methods. <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)sendEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event; - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)sendAction:(SEL)action to:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)target from:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender forEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event;</code> </pre><br>  In general, this is the implementation of the <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html">target-action</a> pattern: <br><br><img src="https://habrastorage.org/files/1cb/a0a/bf1/1cba0abf1ac24af599beb5ecd959c2e0.png"><br><br>  There are 2 ways to block user interaction: the first is to block the receipt of events by a specific control (control);  the second is to block sending events directly from the application instance object. <br><br>  1st way (each View has a userInteractionEnabled property): <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController.navigationBar.userInteractionEnabled = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.someButton.userInteractionEnabled = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>;</code> </pre><br>  2nd way (the application object is singleton): <br><pre> <code class="objectivec hljs">[[<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> sharedApplication] beginIgnoringInteractionEvents]; [[<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> sharedApplication] endIgnoringInteractionEvents];</code> </pre><br>  Since there is a need to block any interaction (it is not known when clicking specifically on which button the dangerous code will be executed (with the following transition)), the second method suits us. <br><br><h4>  Appearance navigation-bar-a </h4><br>  As you may know, the best practice is to define the appearance using the UIAppearance, but thanks to such a subclass, it is possible to abandon it if you use this subclass everywhere.  By the same to encapsulate this logic (to hide) inside the navigation controller is a very smart decision.  The <code>awakeFromNib</code> method is suitable for <code>awakeFromNib</code> .  I personally did not try to do this, but I spied on others.  This was a small tip. <br><br><h4>  Multitouch </h4><br>  If someone is interested in multitouch (so that it is not possible to press 2 buttons in a row): <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) makeExclusiveTouchToSubviews:(<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span>*)view { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> * currentSubtView <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [view subviews]) { currentSubView.multipleTouchEnabled = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; currentSubView.exclusiveTouch = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> makeExclusiveTouchToSubviews:currentSubView]; } }</code> </pre><br>  Ps.  if you want to use this miracle, use at your own peril and risk, I haven't tried everything out of what was available, so for some situations you may have to write it yourself.  The Utility / GAIClient classes are not supplied (from the first one, the method for disabling multitouch is taken, with the help of the second - non-crash report is sent to GoogleAnalytics). <br><br><h4>  Implemented functionality </h4><br>  It was implemented: <br><ul><li>  A way to block transitions quickly manually (if necessary); </li><li>  3 levels of protection against transitions: <br>  a) at the level of the should navigationBarDelegate methods; </li></ul><br>  c) respectively, by blocking user interaction, if at least one corresponding animation has begun, and unlocking, if all have been completed; <br>  wired protection from the processing of actions at once 2 buttons (by disabling the multitouch); <br>  the release mechanism, in case something went wrong; <br>  creating a report if something went wrong. <br><br><br><h4>  Nuances and problems encountered </h4><br>  The 1st problem was related to the fact that using the explicit and implicit transitions (in the second case via the navigation bar ‚ÄúBack‚Äù) in the second case, the <code>popToViewController:animated:</code> method did not start, it was necessary to explicitly check whether the transition from one controller to another; <br><br>  The 2nd problem is navigation-bar behavior on iOS 7.0.  On this firmware for the standard controller navigation, a delegate is automatically assigned (and if we try to do it again manually, it will generate an exception). <br><br>  The third problem is that on the 7th firmware there is a right-hand svayp interactivePopGestureRecognizer, which allows you to go backwards (it only called the navigation controller delegate will, which is why the user interaction was tightly blocked). <br><br>  4th problem - in extremely rare situations, there could be a danger that the opposite method was not always launched (the system should have been self-restoring if anything happened).  A semblance of a timer was implemented, with a deblocking handler. <br><br><h4>  Download / View </h4><br>  <a href="">Git Repo on github-e</a> </div><p>Source: <a href="https://habr.com/ru/post/263069/">https://habr.com/ru/post/263069/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263059/index.html">Live Webcast Launch Visual Studio 2015</a></li>
<li><a href="../263061/index.html">7 rules for creating beautiful interfaces. Part 2</a></li>
<li><a href="../263063/index.html">What else can a browser know about you?</a></li>
<li><a href="../263065/index.html">Release of InterSystems Cach√© 2015.2 DBMS</a></li>
<li><a href="../263067/index.html">About Burali-Forti, Poincar√© and the very definition of a unit</a></li>
<li><a href="../263073/index.html">Steal for 9 characters</a></li>
<li><a href="../263075/index.html">Protecting PHP Script Domain Name Paths</a></li>
<li><a href="../263077/index.html">Under the hood of ATM software</a></li>
<li><a href="../263079/index.html">6 things I would like to know before developing my first Android application</a></li>
<li><a href="../263081/index.html">We clean the home Internet from very annoying ads (Ad's blocker for OpenWRT)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>