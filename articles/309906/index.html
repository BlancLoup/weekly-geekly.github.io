<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Application of nonlinear dynamics and Chaos theory to the task of developing a new audio data compression algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this publication, I would like to present a number of ideas and experience of practical implementation of an element of Chaos theory - a fractal tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Application of nonlinear dynamics and Chaos theory to the task of developing a new audio data compression algorithm</h1><div class="post__text post__text-html js-mediator-article">  In this publication, I would like to present a number of ideas and experience of practical implementation of an element of Chaos theory - a fractal transformation in a project to develop a new audio data compression algorithm. <br><br>  What you won't find here: <br><br><ul><li>  Complex equations.  The purpose of this publication is to present the ideas and the vision of the problem.  And like any other vision, it is largely abstract; </li><li>  Any generators of fractal images.  Such images look interesting, but I am interested in real tasks. </li></ul><br>  What you find here: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  A brief overview of the application of fractal transformations to the problem of data lossy compression; </li><li>  Unusual interpretation of fractal transformations; </li><li>  References to real compressor code and audio data decompressor through fractal transformations (decompressor is presented in the form of a plug-in for the Winamp audio player); </li><li>  Description of the new format for storing compressed audio data with five unique properties that distinguish the new format from many well-known industrial audio formats. </li></ol><a name="habracut"></a><br>  I think that for most readers of this publication this task will seem strange.  Usually, the concept of fractal is associated with beautiful pictures - the results of fractal transformations, also called fractal (or ‚Äústrange‚Äù) attractors.  However, a careful study of fractal transformations allows us to understand that fractals are not only beautiful images.  Fractal transformations define the projections of elements in a closed set.  Such sets can be colored points in 2.5 D space, a set of points on a 2 D plane, or a set of discrete samples of an audio stream in 1.5 D space. <br><br>  I became interested in fractal transformations from the moment of writing my thesis for the degree of candidate of technical sciences.  The topic of the thesis was - ‚ÄúAlgorithms for reducing the computational complexity of fractal analysis in visual data processing systems‚Äù.  The thesis was successfully defended and accepted for publication by LAP LAMBERT Academic Publishing.  Sometimes I meet links to it on sites <a href="https://www.amazon.ca/Algoritmy-fraktalnogo-szhatiya-izobrazheniy-problematiki/dp/365924581X">Amazon</a> and <a href="http://www.ozon.ru/context/detail/id/31807391/">Ozon</a> . <br><br>  I spent a lot of time studying both theoretical foundations and practical results of research of fractal transformations and found only two attempts to develop fractal transformations to the level of industrial standards: <br><br><ol><li>  Video codec - 'ClearVideo' by company Iterated System Incorporated. </li><li>  Image / video codec - 'FIASCO' by Ullrich Hafner. </li></ol><br>  However, these attempts did not lead to significant success.  The reason for the failures was a significant computational complexity. <br><br><h3>  Mathematical foundations </h3><br>  The construction of images based on fractal transformations does not represent mathematical complexity.  The well-known fractal (fractal set) of Mandelbrot is constructed on the basis of the following transformation: <br><br>  Z (n + 1) = Zn ^ 2 + C where n = 1, 2, 3, ... <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/Mandelbrot_set.png"></div><br>  Thus, a very complex visualization can be achieved with a very simple expression.  This leads to the next question - is it possible to construct a real image through a fractal transformation?  This question was resolved in the affirmative.  More precisely, one can find such a fractal transformation, which is capable of constructing an image with distortions less than or equal to any predetermined value.  This means that the generated image may differ from the original by an amount indistinguishable by the viewer due to the redundancy of the visual information of the image.  Thus, fractal image encoding is a lossy image processing technology. <br><br>  In the book, <a href="https://www.amazon.ca/Algoritmy-fraktalnogo-szhatiya-izobrazheniy-problematiki/dp/365924581X">Amazon</a> or <a href="http://www.ozon.ru/context/detail/id/31807391/">Ozon,</a> you can find exact proofs of the applicability of the fractal transformation to image processing problems ‚Äî Michael Brunsley's Collage Theorem. <br><br><h3>  Pifs </h3><br>  You may ask - how to perform fractal coding (or more precisely - fractal analysis)?  The visualization of the Mandelbrot fractal set is quite impressive, but it was developed after many years of research.  Attempting to find a suitable fractal transformation by simple enumeration is hopeless.  The solution to this problem was proposed by Michael Brunsley and his graduate students (Michael Brunsley later founded Iterated Systems Incorporated).  They proposed a block scheme of fractal transformation.  From the point of view of performing fractal transformations, there are no differences in the applicability of fractal transformations to a set of points or to a set of blocks of points - partitioned iterated function systems (PIFS).  Such a scheme is based on extracting a copy of points from one part of a set of points, applying transformations to a copy, and inserting the result into another part of the set ‚Äî this distinguishes this approach from fractal transformations for individual points.  PIFS scheme can be represented as follows: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/PIFS_Schema.png"></div><br><img src="http://www.codeproject.com/KB/recipes/825358/D-R.png"><br>  where F is the original set of points, D and R are sets of regions of points from F, <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  - the transformation of one region from the set D and the region of the set R. Sets <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  and determine the desired fractal transformation.  It is important to note that if the fractal transformation for the Mandelbrot fractal set is based on one equation of fractal transformation and the idea of ‚Äã‚Äãglobal self-similarity (that is, the similarity of the entire set of any part of it), then the PIFS scheme is based on the group of fractal transformations and the idea of ‚Äã‚Äãlocal similarity of individual regions of the set. <br><br>  You may ask - how does this relate to real images?  On real images it is unlikely to find a global self-similarity, but it is possible to establish a similarity between different areas of the real image, subject to tolerance.  If the resulting amount of memory for storing the system of equations of fractal transformations is less than the amount of memory for storing the original image, then a lossy image compression is obtained.  This image processing approach is different from the classical idea of ‚Äã‚Äãlinear interpolation of signals. <br><br>  To understand this difference, one needs to pay attention to three main properties of fractal transformations: <br><br><ol><li>  fractal transformation is recursive - it is based on the idea of ‚Äã‚Äãunrestricted application of this transformation to the set; </li><li>  fractal transformation is compressive - this means the result is always less than the original; </li><li>  The space of fractal transformation is compact - all transformations over a set are reflected on the set itself (self-similarity). </li></ol><br>  By analogy with the fractal transformation of the Mandelbrot set, the PIFS transformation for real images can be represented as follows: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image002.png"></div><br>  Where <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  - transformation in the space of image points, <img src="http://www.codeproject.com/KB/recipes/825358/clip_image006.png">  - compression vector transformation with a long <img src="http://www.codeproject.com/KB/recipes/825358/clip_image008.png">  in vector with long <img src="http://www.codeproject.com/KB/recipes/825358/clip_image010.png">  but what do variables mean <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  ?  Variables <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image006.png">  describe the transformation on the plane, but each point of the real image has a special meaning - the intensity of its own brightness, which should be considered as part of the fractal transformation space: <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  - compressive luminance conversion and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  - the brightness intensity shift (by analogy with the straight line equation - f (y) = y * s + o). <br><br>  What to do with this equation?  It is very simple - to execute this expression for all transformation groups ( <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image006.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  ) what should fill the set R, filling the whole image F. And once again, and again (recursive execution), to infinity.  In reality, everything is much simpler - after each recursive iteration of the synthesis of a fractal set, the distance between the points decreases (the compressive property of the fractal transformation), but if for the analytical space there are no restrictions in divisibility, then for the discrete space of digital images the new points will fall into the cut-off space between neighboring samples.  It will happen after <img src="http://www.codeproject.com/KB/recipes/825358/clip_image010.png">  recursive PIFS iterations. <br><br>  The expected question is how to find the coefficients mentioned. <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  for a system of fractal transformations?  The task of such a search can be automated based on the following equation: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image029.png"></div><br>  the search task is to find a pair <img src="http://www.codeproject.com/KB/recipes/825358/clip_image031.png">  which minimizes the length of the vector of deviation <img src="http://www.codeproject.com/KB/recipes/825358/clip_image033.png">  .  If you set the extreme tolerance value to 0, you can derive the following approximations for <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  : <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image037.png"></div><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image039.png"></div><br>  These expressions allow you to calculate the optimal values. <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  but unknown variables remain <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  and couples <img src="http://www.codeproject.com/KB/recipes/825358/clip_image031.png">  .  Unfortunately, currently there are no analytical solutions for these variables - all that remains is to set the sets <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  and steam <img src="http://www.codeproject.com/KB/recipes/825358/clip_image031.png">  and sort through their combinations to minimize <img src="http://www.codeproject.com/KB/recipes/825358/clip_image033.png">  equations: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image029.png"></div><br>  For effective minimization, it is required to set large ranges of values ‚Äã‚Äãof the set <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  and steam <img src="http://www.codeproject.com/KB/recipes/825358/clip_image031.png">  , which leads to a ‚Äúcombinatorial explosion‚Äù - the need to enumerate hundreds of thousands of various combinations, which requires hours of operation of a computer processor.  It is this problem that does not allow the transfer of fractal image analysis from the area of ‚Äã‚Äãexotic research to the sphere of industrial standards. <br><br><h3>  Audio </h3><br>  I foresee a question - all the above described is interesting, but where does the sound and compression of sound data come from?  I think many have already realized that for fractal analysis the nature of the sets does not matter - the set of pixels on the plane or the set of samples from the audio stream.  If you accumulate samples of the input audio stream in the buffer and then process them as separate sets, you can form systems of fractal transformations from which you can synthesize fractal sets that are close to the original samples of the audio stream.  This was implemented in my project, which includes the <a href="https://github.com/Xirexel/ROAD">ROAD</a> encoder and <a href="https://github.com/Xirexel/WinampPlugin_in_road">decoder</a> (in the form of a plug-in for Winamp) - test audio files: <a href="https://drive.google.com/file/d/0B9pVRwN4TMxNbkFHMHEzV1E4UTg/view%3Fusp%3Dsharing">Origa - Inner Universe 4Samples.road.wav</a> and <a href="https://drive.google.com/file/d/0B9pVRwN4TMxNWjZRQ3NwbGZxLWc/view%3Fusp%3Dsharing">Alpha - Revolution in Paradise 4Samples.road.wav</a> .  A new algorithm for compressing audio data allowed developing a format with five unique properties: <br><br><ol><li>  <b>Pre-listening.</b>  This term sounds strange, but I decided to use it by analogy with the term ‚ÄúPreview‚Äù from the description of the JPEG2000 image compression format.  But what does this mean for an audio file?  If you look at the expression for calculating the coefficient <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  , it can be seen that it is calculated on the basis of averaging the values ‚Äã‚Äãof neighboring samples.  As a result, through the substitution, you can get the following expression: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image051.png"></div><br>  This expression shows an important fact - part of the coefficients of fractal transformations can be viewed as the average value of the image pixels or samples of the audio stream.  This value is the ‚Äúgrowth point‚Äù of the fractal set.  Fractal transformations need similar points.  However, when using PIFS for analyzing audio data, you can limit the size of the 4-point ‚Äì sample regions - this allows you to get an average audio stream in the low-frequency region (for example, for the original audio stream frequency of 48000 Hz, the average stream has a frequency of 12000 Hz).  As a result, the compressed stream can be listened to with degraded quality without decoding.  I believe that this property can be defined as ‚ÄúPre-listening‚Äù. <br><br></li><li>  <b>Partial compatibility.</b>  From the possibility of organizing a separate low-frequency stream of audio data from the coefficients of fractal transformations, the question arises - how to implement this?  It is possible to reserve a separate section of the data stream, but the fact that this stream is an uncompressed data stream leads to the idea that this stream can be additionally compressed by another algorithm and packaged in a known industrial format.  In this case, the file can be played in an audio player that is compatible with an industrial format with degraded quality.  This idea can be implemented in the form of a stack of compressors.  In my project, the WAVE format from Microsoft was selected.  This format does not include compression, but allows in practice to implement a format stack and partial compatibility: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/fig04.png"></div><br></li><li>  <b>Overclocking</b>  The idea of ‚Äã‚Äãthis property is to increase the frequency of the decoded audio stream.  You can understand the idea of ‚Äã‚Äãimplementing this property if you consider why this property cannot be implemented in many industrial formats.  For example, consider the mp3 format ‚Äî when you try to double the frequency of a decoded audio stream, you need to increase the basis of the inverse discrete cosine transform from 128 to 256, but the compressed data only includes data for 128. This leads to the problem of incomplete orthogonal transform basis.  A similar problem arises with linear prediction based formats.  However, for fractal analysis, the situation is different.  The coefficients considered earlier <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  not related to the size of the basis of transformation: <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  - intensity scalars, <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  - transformation in space - displacement, reflection, etc ... A close analogy is raster and vector image formats: if raster formats assume the presence of one approximating basis and its reaction to a discrete image is investigated, then in vector formats an image is synthesized from the system of equations.  By analogy, most industrial audio compression formats investigate the response of the approximating basis to the input audio data and, when decoded, reconstruct the audio data from the response from the principle of reversibility of the approximating basis with finite impulse response.  At the same time, as a fractal approximating basis is recursive with infinite impulse response, it synthesizes the resulting fractal set.  This important difference is the coefficients. <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  , <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  determine the PIFS equations.  As a result, it is possible to choose the size of the basis and synthesize more samples of the audio stream per unit time than it was in the original audio stream.  A similar result can be observed when scaling vector image formats.  This property is implemented in a plugin for Winamp. <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/fig05.png"></div><br></li><li>  <b>Expansion of dynamic range.</b>  This is a logical continuation of the property of increasing the frequency of a decoded audio stream - as the bit depth increases from 16 bits to 32 bits, new samples of the audio stream will be synthesized in an extended range. <br><br></li><li>  <b>Non-deterministic decoding.</b>  The PIFS system involves many fractal transformations establishing local similarities.  Based on the previously considered expressions, it can be concluded that each of the set of fractal transformations can be performed independently, but the question arises - in what order should they be executed?  It is logical to perform in the order in which the fractal analysis was performed, but this conclusion is wrong - each fractal transformation is equivalent to any other of the set.  This idea is expressed in the implementation of the choice of the next fractal transformation by a random number generator.  For most industrial formats, the reversibility of compression algorithms is the main requirement, but fractal transformations are free from this condition. <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/non-detwrm.png"></div></li></ol><br><h3>  Interpretation </h3><br>  Many mathematical concepts have physical interpretations.  For example - <img src="http://www.codeproject.com/KB/recipes/825358/clip_image056.png">  and circle circumference or natural logarithm and spiral shell of the mollusk.  Often indicate the relationship of fractal sets with the growth of crystals or trees.  However, I would like to present my own interpretation of fractal transformations. <br><br>  I propose to consider the basic expression of the PIFS fractal transform: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/clip_image002.png"></div><br>  This expression can be represented as the following scheme: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/Rang_low.png"></div><br>  Taking into account the fact that the specified expression describes operations with vectors, consider the scheme of operations on each element of the vector: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/Each_Sample.png"></div><br>  I believe that many readers will see the similarity of this scheme with the scheme of an artificial neuron: <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/neuron_model.png"></div><br>  conversions <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  and <img src="http://www.codeproject.com/KB/recipes/825358/clip_image006.png">  can be considered as a function of addition at the input, <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  - sensitivity of an artificial neuron at the entrance, <img src="http://www.codeproject.com/KB/recipes/825358/clip_image014.png">  - the level of displacement - the excitation of an artificial neuron.  An attentive reader may indicate that the sensitivity of an artificial neuron is determined for each input, while <img src="http://www.codeproject.com/KB/recipes/825358/clip_image012.png">  defined as a scalar for all inputs.  Also, the reader will indicate the need for the output of the function to determine the state of an artificial neuron in terms of Binary (Boolean) logic: active or inactive.  But are such requirements important?  Is it acceptable that the sensitivity of an artificial neuron would be the same for all inputs?  Yes, there are algorithms for learning artificial neural networks with a similar rule.  Is a non-binary value valid at the output of an artificial neuron?  At the beginning of the development of the theory of artificial neural networks, when the circuits were built on transistors, capacitors and resistors, they were required to solve simple problems from the field of recognition - for example, recognizing postal codes on postal envelopes and postcards using a perceptron.  But with the development of fuzzy logic and the discovery of the advantages of ‚Äúfuzzy decisions‚Äù (soft decisions) over ‚Äúclear decisions‚Äù (hard decisions), the need for such a function can be questioned. <br><br>  What happens if you look at fractal transformations from the point of view of the theory of artificial neural networks?  Every element of the vector <img src="http://www.codeproject.com/KB/recipes/825358/clip_image022.png">  can be considered as one artificial neuron.  In this case, the vector <img src="http://www.codeproject.com/KB/recipes/825358/clip_image022.png">  can be considered as a layer of artificial neurons with common properties.  However, such ‚Äúlayers‚Äù can be several thousand for a small image.  Plane transformation <img src="http://www.codeproject.com/KB/recipes/825358/clip_image004.png">  can be interpreted as a trace of connections between artificial neurons.  An artificial neural network with linking-topology tracing between layers of artificial neurons for each individual task sounds very unusual, doesn't it?  What features can such artificial neural networks have? <br><br><ol><li>  Recursiveness - the result of the work of an artificial neural network becomes the input data for it itself before establishing an equilibrium state - called for fractal transformations an ‚Äúattractor‚Äù. <br><br></li><li>  The spiral topology is a condition of local self-similarity. <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/spiral.png"></div><br><br></li><li>  Random selection of the sequence of conversions - layers. <br><br></li><li>  Pre-listening - the ability to set the initial level of an artificial neural network from a real source: image or sound of low quality. <br><br></li><li>  Acceleration is a simple scaling of an existing artificial neural network by adding or removing artificial neurons from each layer without the need to recalculate the configuration of an artificial neural network.  This allows you to create a more detailed state of the network with the generation of new parts. <br></li></ol><br>  How can we call such an artificial neural network - a recursive, scalable, asynchronous, non-deterministic artificial neural network with a topology trace and a ‚Äúsoft‚Äù solution.  An interesting fact is that there already exists an artificial neural network with similar properties - <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C_%25D0%25A5%25D0%25BE%25D0%25BF%25D1%2584%25D0%25B8%25D0%25BB%25D0%25B4%25D0%25B0">the Hopfield artificial neural network</a> .  This artificial Hopfield neural network is also recursive, also converges to a steady state and can be asynchronous.  However, it includes one layer, does not include topology tracing, and does not form a ‚Äúsoft‚Äù solution.  It is interesting that fractal transformations, like the Hopfield artificial neural network, have common filtering properties ‚Äî recovery of damaged images (of course, fractal transformations can work with real images): <br><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/Lena-1test.png"></div><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/Lena-2test.png"></div><br><div style="text-align:center;"><img src="http://www.codeproject.com/KB/recipes/825358/rosetest.png"></div><br>  You can see that after removing several elements, fractal transformations can build an image close to the original after one iteration.  However, the image ‚ÄúRose‚Äù, which is very different from the original one, creates a very chaotic distribution of pixel intensity.  This is consistent with the property of filtering - restoration of damaged images. <br><br><h3>  Conclusion </h3><br>  At this point you can finish this article.  I hope the ideas expressed will turn your attention to the exotic area of ‚Äã‚Äãfractal transformations. </div><p>Source: <a href="https://habr.com/ru/post/309906/">https://habr.com/ru/post/309906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309892/index.html">Configuring automatic password retrieval for VPN on Mikrotik</a></li>
<li><a href="../309898/index.html">PCI Express 4.0, cables and everything</a></li>
<li><a href="../309900/index.html">While the thunder did not strike, or Continuity and GOST R 53647.4-2011 / ISO / PAS 22399: 2007</a></li>
<li><a href="../309902/index.html">11 texts to help sort out big data</a></li>
<li><a href="../309904/index.html">Backing up domain controllers with Veeam</a></li>
<li><a href="../309908/index.html">IBM specialists want to stop the epidemic of Escherichia coli.</a></li>
<li><a href="../309910/index.html">Scala or not Scala? That is the question</a></li>
<li><a href="../309912/index.html">Poll. The current state of automated testing 2016</a></li>
<li><a href="../309914/index.html">The history of programming languages: how Fortran allowed users to communicate with the computer on "you"</a></li>
<li><a href="../309918/index.html">How to stop being afraid and fall in love with mbed [Part 2]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>