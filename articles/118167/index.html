<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell without monads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Any programmer who studies haskell, sooner or later meets with such an incomprehensible concept as a monad . For many, familiarity with the language e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell without monads</h1><div class="post__text post__text-html js-mediator-article">  Any programmer who studies haskell, sooner or later meets with such an incomprehensible concept as a <i>monad</i> .  For many, familiarity with the language ends monad.  There are many monad guides, and new ones are constantly appearing (1).  The few who understand monads carefully hide their knowledge, explaining monads in terms of endofunctors and natural transformations (2).  No experienced programmer can find a place for monads in his established picture of the world. <br><br>  As a result, java-programmers only laugh at Haskel, not looking up from their million-line enterprise project.  C ++ developers patch their super-fast applications and come up with even smarter pointers.  Web developers scroll through examples and huge specifications for css, xml and javascript.  And those who study haskell in their free time face a formidable obstacle, the name of which is monad. <br><br>  So, we will learn how to program in haskel <i>without monads</i> . <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To do this, we need some free time, a good night‚Äôs sleep, a mug of a favorite drink and the ghc compiler.  In windows and macos, it can be found in the haskell platform (3) package; linux users can install ghc from the repository.  Code samples starting with Prelude&gt; can be checked in ghci, an interactive interpreter. <br><br>  On Habr√© there was already a similar article (4), however, it does not explain all the ins and outs of I / O, but simply offers ready-made templates for use. <br><br><h4>  Transition to the next action - operator </h4><br>  Let's start from afar.  All calculations in Haskel were divided into ‚Äúwith side effects‚Äù and ‚Äúwithout side effects‚Äù.  The first is, for example, writing / reading from I / O devices, calculations with the possibility of an error somewhere in the middle, etc.  The ‚Äúno side effects‚Äù include such operations as adding numbers, sticking together strings, any mathematical calculations ‚Äî any ‚Äúpure‚Äù functions. <br><br>  Pure functions are combined in the same way as functions in all other programming languages ‚Äã‚Äãare combined: <br><pre><code class="hljs pgsql">Prelude&gt; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> (head (<span class="hljs-keyword"><span class="hljs-keyword">show</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">-2</span></span>))) <span class="hljs-string"><span class="hljs-string">'0'</span></span></code> </pre> <br><br>  For the compilation of programs with side effects, a special operator was created <br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>=</code> </pre><br>  let's call it "connect" (eng. bind).  All I / O actions are glued to them: <br><pre> <code class="hljs ruby">Prelude&gt; getLine <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span>putStrLn asdf asdf</code> </pre><br>  This operator accepts 2 functions with side effects at the input, and the output of the left function supplies the input with the right one. <br><br>  Let's look at the types of functions with the interpreter command: t: <br><pre> <code class="hljs rust">Prelude&gt; :t getLine getLine :: IO <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> Prelude&gt; :t putStrLn putStrLn :: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; IO ()</code> </pre><br><br>  So, getLine takes nothing as input, and returns the type IO String. <br><br>  The fact that the name type 2 words, says that this type of compound.  And the word that comes first is called the type builder, and everything else is the parameters of this builder (I know what sounds like an incongruous sound, but that‚Äôs necessary). <br><br>  In this case, the word IO just indicates a side effect, and it is discarded by the operator ‚Äù=.  As an example of other ‚Äúindicators‚Äù of side effects, we can cite the popular type State, which means that the function has some kind of state. <br><br>  Let's go to putStrLn.  The function accepts a string as input, and returns IO ().  With IO, everything is clear, a side effect, and () is a Haskel-like analog of a void.  Those.  the function does something there with I / O and returns an empty value.  By the way, all programs on HASKEL must end with this same IO (). <br><br>  So, the "connect" operator takes its result from the first argument, cuts off the side effect indicator and transfers what came to the second its argument.  It seems complicated, but on this one operator, half of the Haskel is kept, all the I / O is programmed with it.  It is so significant that it was even added to the language logo. <br><br>  What if the return and accept values ‚Äã‚Äãof the functions to be glued do not match?  Lambda functions come to the rescue.  For example, we just take a parameter as input, but do nothing with it: <br><pre> <code class="hljs 1c">Prelude&gt; (putStrLn <span class="hljs-string"><span class="hljs-string">" 1"</span></span>) &gt;&gt;= (\a -&gt; putStrLn <span class="hljs-string"><span class="hljs-string">" 2"</span></span>) &gt;&gt;= (\b -&gt; putStrLn <span class="hljs-string"><span class="hljs-string">" 3"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Looking ahead, I will say that the operator "= has a very low priority and, if you wish, you can do without brackets in this example.  In addition, if the argument is not used inside the lambda function, as in our example, you can replace it with _. <br><br>  Let's rewrite the first example to be completely equivalent, but using the lambda function: <br><pre> <code class="hljs ruby">Prelude&gt; getLine <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span>\a -&gt; putStrLn a asdf asdf</code> </pre><br>  When displaying the string on the screen, we now clearly indicated with the help of the lambda function that we accept one variable, and explicitly wrote how we use it. <br><br><h4>  Did you say "variable"? </h4><br>  Yes, now let's talk about variables.  As you know, in Haskel there are no variables.  However, if you look at any listing, you will see a lot of assignments. <br><br>  In the code above, a and b are very similar to variables.  They can also be referenced as in other languages.  However, these a and b differ significantly from variables in imperative languages. <br><br>  In all imperative programming languages, a variable is a named memory region.  In Haskell, things like a and b are named expressions and values. <br><br>  We give an example and show these differences.  Consider the following code on C: <br><pre> <code class="hljs lisp">a = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-comment"><span class="hljs-comment">; a = a + 1; printf("%d",a)</span></span></code> </pre><br>  Everything is crystal clear and the result is predictable. <br><br>  Now do the same on haskel: <br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = a + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a ^<span class="hljs-type"><span class="hljs-type">CInterrupted</span></span>.</code> </pre><br>  Code execution will never end.  In the first line, we define a as 1. In the second line, we define a as a + 1. By the time the second line is read, the interpreter forgets the previous value of a, and determines a again, in this case, through itself.  Well, this recursive definition will never be calculated. <br><br>  As for the named memory areas, they are in Haskel, but this is a completely different story. <br><br>  With this design, you can pass parameters through several calls of the "connect" operator: <br><pre> <code class="hljs erlang-repl">Prelude&gt; getLine &gt;&gt;= \a -&gt; putStrLn <span class="hljs-string"><span class="hljs-string">" :"</span></span> &gt;&gt;= \_ -&gt; putStrLn a asdf  : asdf</code> </pre><br><br><h4>  Real code </h4><br>  Now, using our secret knowledge, we will write something real.  Specifically, a program that receives data from the user, performs some actions on them and displays the result on the screen.  We will write the program as it should be in a separate file and compile it into machine code. <br><br>  Let's call the file test.hs: <br><pre> <code class="hljs erlang-repl">main = putStrLn <span class="hljs-string"><span class="hljs-string">"  :"</span></span> &gt;&gt;= \_ -&gt;       getLine &gt;&gt;= \a -&gt;       putStrLn <span class="hljs-string"><span class="hljs-string">"   :"</span></span> &gt;&gt;= \_ -&gt;       putStrLn (show ((read a)^<span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre><br>  compile: <br><pre> <code class="hljs pgsql">ghc <span class="hljs-comment"><span class="hljs-comment">--make test.hs</span></span></code> </pre><br>  run: <br><pre> <code class="hljs 1c">$ ./test   <span class="hljs-built_in"><span class="hljs-built_in"></span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>    <span class="hljs-built_in"><span class="hljs-built_in"></span></span>: <span class="hljs-number"><span class="hljs-number">144</span></span></code> </pre><br>  The read function attempts to parse a string into a value of the desired type.  Which type she herself guesses is a separate story.  The show function converts a value of any type to a string. <br><br>  The read function is not safe if we give it letters and ask to parse the number, an error will occur.  We will not dwell on this, just mention that there is a safe module for this case. <br><br><h4>  Admixture of purity </h4><br>  Separately, the question arises of how to call pure functions from a side-impact code. <br><br>  In the example above, the net function is simply written as an argument to the IO function.  Often this is enough, but not always. <br><br>  There are other ways to call clean code. <br><br>  The first of these is the forcible transformation of a clean code into a side-effect code.  Indeed, pure code can be considered a special case of a side-effect, therefore such a transformation does not pose any danger.  And it is carried out using the function return: <br><pre> <code class="hljs rust">main = putStrLn <span class="hljs-string"><span class="hljs-string">"  :"</span></span> &gt;&gt;= \_ -&gt;       getLine &gt;&gt;= \a -&gt;       putStrLn <span class="hljs-string"><span class="hljs-string">"   :"</span></span> &gt;&gt;= \_ -&gt;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (show ((read a)^<span class="hljs-number"><span class="hljs-number">2</span></span>)) &gt;&gt;= \b -&gt;       putStrLn b</code> </pre><br>  We compile, check, the program works as before. <br><br>  Another way is to use the haskalla let ... in ... In many manuals, enough attention is paid to it, so we will not dwell on it, I will give only a ready-made example: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">main</span></span> = putStrLn <span class="hljs-string"><span class="hljs-string">"  :"</span></span> &gt;&gt;= \_ -&gt;       getLine &gt;&gt;= \a -&gt;       putStrLn <span class="hljs-string"><span class="hljs-string">"   :"</span></span> &gt;&gt;= \_ -&gt;       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = (show ((read a)^<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>       putStrLn b</code> </pre><br><br><h4>  Need more sugar </h4><br>  The developers of the language have noticed that often there are constructions <br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>= \<span class="hljs-number"><span class="hljs-number">_</span></span> -&gt;</code> </pre><br>  therefore, to designate them, we introduced the operator <br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span></code> </pre><br>  Rewrite our code: <br><pre> <code class="hljs pgsql">main = putStrLn "  :" &gt;&gt;       getLine &gt;&gt;= \a -&gt;       putStrLn "   :" &gt;&gt;       let b = (<span class="hljs-keyword"><span class="hljs-keyword">show</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">read</span></span> a)^<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>       putStrLn b</code> </pre><br>  So it became a little more beautiful. <br><br>  But there is a cooler feature - <i>‚Äúdo‚Äù</i> syntactic sugar: <br><pre> <code class="hljs lisp">main = do    putStrLn <span class="hljs-string"><span class="hljs-string">"  :"</span></span>    a &lt;- getLine    putStrLn <span class="hljs-string"><span class="hljs-string">"   :"</span></span>    let b = (<span class="hljs-name"><span class="hljs-name">show</span></span> ((<span class="hljs-name"><span class="hljs-name">read</span></span> a)^<span class="hljs-number"><span class="hljs-number">2</span></span>))    putStrLn b</code> </pre><br>  Exactly what is needed!  So you can already live. <br><br>  Inside the do block, bounded by left justification, the following replacements occur: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">a</span></span> &lt;- abc   abc &gt;&gt;= \a -&gt; abc   abc &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = b   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span></code> </pre><br>  The ‚Äúdo‚Äù notation makes the syntax very similar to the syntax of all modern programming languages.  Nevertheless, under the hood, she has a rather well thought-out mechanism for separating a clean and side-effect code. <br><br>  An interesting difference is the use of the return statement.  It can be inserted in the middle of the block, and it will not interrupt the execution of the function, which can cause confusion.  But in reality, it is often used at the end of a block to return a pure value from the IO function: <br><pre> <code class="hljs rust">get2LinesAndConcat:: IO <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> get2LinesAndConcat = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>    a &lt;- getLine    b &lt;- getLine    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b)</code> </pre><br><br><h4>  Sphere in vacuum </h4><br>  And now we will carry out our pure code in separate function.  And at the same time we will place, finally, the missing type signatures. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>    putStrLn <span class="hljs-string"><span class="hljs-string">"  :"</span></span>    a &lt;- getLine    putStrLn <span class="hljs-string"><span class="hljs-string">"   :"</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = processValue (read a)    putStrLn (show b) processValue :: <span class="hljs-type"><span class="hljs-type">Integer</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Integer</span></span> processValue a = a ^ <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  The important point is that the side-effect I / O code can only be run from the I / O code.  However, clean code can run from anywhere. <br><br>  Thus, the pure functional world is strictly and reliably separated from all that is associated with side effects.  Inside the processValue we can count anything, implement any logic.  But even if a million lines of code is called from there, we can be sure that for any input value, the output will always be the same.  And the parameter passed there is surely not spoiled by anyone, you can safely use it further. <br><br>  In stylistic guides, it is recommended to minimize the use of side-effect code and make the maximum of functionality into pure functions (5).  However, if the program is designed to perform I / O actions, you should not avoid using it wherever necessary.  As a rule, in such cases, auxiliary functions are required, which can be clean.  Experienced programmers in Haskel recognize the excellent support even of IO code in comparison with imperative languages ‚Äã‚Äã(the statement is attributed to Simon Peyton Johnes, but a direct link was not found). <br><br>  One feature of performance is associated with clean functions.  Let's take a classic example, transfer to a function a complex structure ‚Äúemployee‚Äù with many fields.  So, by analogy with C, the efficiency of the code will be comparable to passing this parameter by pointer, and reliability is comparable to passing a parameter through the stack, because in C, only passing through the stack guarantees the immunity of the original structure. <br><br><h4>  What are you carrying? </h4><br>  ‚ÄúThis code is terrible, it is unnecessarily complex, has too little in common with the warm lamp semantics of all other languages, for any purpose c / c ++ / c # / java / python etc. is enough.‚Äù <br><br>  Well, there is some truth in this.  Here you need to decide what you think is terrible: the separation of side effects from clean code or a specific implementation of this mechanism. <br><br>  If you know how to make such a mechanism more simple and understandable, please tell the world community about it!  Haskelny community is very open and friendly.  In the draft of the new standard, which is adopted regularly, any proposals are considered, and if they really are worth, they will be accepted. <br><br>  If you think that ‚Äúin python everything is good that you are attached with your side effects!‚Äù, No one bothers you to use the tool that you like.  From myself I can add that Haskel really simplifies development and makes the code more understandable.  The only way to make sure of this or the opposite is to try writing in Haskel! <br><br><h4>  Where to go next </h4><br>  For further study, <s>or instead of this article,</s> we can recommend the article ‚Äúa soft introduction to haskell‚Äù (6), and especially its translation (7). <br><br>  In addition, of course, any other articles (8) will do.  There are a lot of manuals, but they all explain the same things from different points of view.  Unfortunately, very little information has been translated into Russian.  Despite the abundance of manuals, the language is simple, its description together with the description of standard libraries takes only 270 pages (9). <br><br>  A lot of information is also contained in the documentation for standard libraries (10). <br><br>  I would be glad if the article will help someone or just seem interesting, comments and criticism are welcome. <br><br>  ps What I called the ‚Äútype builder‚Äù in the Haskel world is called the ‚Äú <i>type constructor</i> ‚Äù.  This is done to make it easier to forget the meaning of the word "constructor", taken from the PLO, these are completely different things.  The situation is aggravated by the fact that, in addition to type constructors, there are also <i>data constructors</i> that also have nothing in common with OOP. <br><br><h4>  Links </h4><br><ol><li>  <a href="http://www.haskell.org/haskellwiki/Monad_tutorials_timeline">www.haskell.org/haskellwiki/Monad_tutorials_timeline</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Monad_(category_theory)">http://en.wikipedia.org/wiki/Monad_(category_theory)</a> </li><li>  <a href="http://hackage.haskell.org/platform/">hackage.haskell.org/platform</a> </li><li>  <a href="http://habrahabr.ru/blogs/Haskell/80396/">habrahabr.ru/blogs/Haskell/80396</a> </li><li>  <a href="http://www.haskell.org/haskellwiki/Avoiding_IO">www.haskell.org/haskellwiki/Avoiding_IO</a> </li><li>  <a href="http://www.haskell.org/tutorial/">www.haskell.org/tutorial</a> </li><li>  <a href="">www.rsdn.ru/article/haskell/haskell_part1.xml</a> </li><li>  <a href="http://www.haskell.org/haskellwiki/Tutorials">www.haskell.org/haskellwiki/Tutorials</a> </li><li>  <a href="http://www.haskell.org/definition/haskell98-report.pdf">www.haskell.org/definition/haskell98-report.pdf</a> </li><li>  <a href="http://www.haskell.org/ghc/docs/7.0.3/html/libraries/">www.haskell.org/ghc/docs/7.0.3/html/libraries</a> </li></ol><br><br>  upd: (SPOILER!) <br><br>  As I was correctly suggested in the comments, the choice of the name for the manual on monads is not entirely successful.  Since the topic of monads is not disclosed, there is a sense of understatement. <br><br>  So, the word "monad" is called a set of operators <br><pre> <code class="hljs kotlin">&gt;&gt;= &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fail</code> </pre><br>  and any data type on which they are defined.  For example, IO. <br><br>  There was a not very good aura around this word, but in reality there is no secret meaning in it.  This is simply the name of a programming pattern that can be explained <i>without monads</i> . <br><br>  upd2: <br>  User <a href="http://afiskon.habrahabr.ru/">afiskon</a> provided a link to an interesting presentation. <br>  <a href="http://mmcs.sfedu.ru/~ulysses/IT/Haskell/papers/why-haskell-censored.pdf">about haskel</a> . </div><p>Source: <a href="https://habr.com/ru/post/118167/">https://habr.com/ru/post/118167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118162/index.html">Steganography through file fragmentation</a></li>
<li><a href="../118163/index.html">Avidemux - fast and easy video editor</a></li>
<li><a href="../118164/index.html">Qik: video calls on Android and iPhone</a></li>
<li><a href="../118165/index.html">Log4cplus logging library</a></li>
<li><a href="../118166/index.html">Opera Opening Day: announcing the winners</a></li>
<li><a href="../118168/index.html">What statistics service are you currently using?</a></li>
<li><a href="../118169/index.html">Themed Cards</a></li>
<li><a href="../118171/index.html">Hyperlinks in the format ‚Äúed2k: // ...‚Äù and their use. Part 1: Description of the format of file ed2k hyperlinks</a></li>
<li><a href="../118172/index.html">Eric Schmidt interested in Russia</a></li>
<li><a href="../118173/index.html">Social telephone directory "Who is calling?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>