<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a console emulator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably, many programmers, if they never dreamed, then at least thought about writing their own emulator of any processor. Perhaps some have even exp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a console emulator</h1><div class="post__text post__text-html js-mediator-article">  Probably, many programmers, if they never dreamed, then at least thought about writing their own emulator of any processor.  Perhaps some have even experimented with something like the Z80.  But not many have reached the final implementation of the emulator. <br><br><img src="https://habrastorage.org/storage1/c813224b/e68b3fe3/bc7fb8ec/a3400f75.png"><br><br>  In this post I would like to talk about creating a simple emulator of the gaming platform CHIP-8 from the distant 70s.  Firstly, we touch the history, and secondly, this platform, due to its simplicity, will allow creating a fully functional emulator even for novice programmers. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  the end </h4><br>  As if this was not strange, but I'll start from the end.  Here is a program <br><br><blockquote>  <font color="#000000">OPTION</font> BINARY <font color="#666666">;</font>  <font color="#666666">We want a binary file, not an HP48 one.</font> <br>  <font color="#000000">ALIGN</font> OFF <font color="#666666">;</font>  <font color="#666666">And we don‚Äôt want auto alignement, as some</font> <br>  <font color="#666666">;</font>  <font color="#666666">data can be made of bytes instead of words.</font> <br><br>  LD V0 <font color="#339933">,</font> <font color="#0000ff">0</font> <br>  LD V1 <font color="#339933">,</font> <font color="#0000ff">0</font> <br><br>  <font color="#00007f">LOOP</font> <font color="#339933">:</font> <br>  LD I <font color="#339933">,</font> LEFT <font color="#666666">;</font>  <font color="#666666">We draw a line</font> <br>  <font color="#666666">;</font>  <font color="#666666">is 0 or 1. If we suppose that it will be 1, we keep</font> <br>  <font color="#666666">;</font>  <font color="#666666">drawing the left line.</font>  <font color="#666666">If it is 0, we change register</font> <br>  <font color="#666666">;</font>  <font color="#666666">I to draw a right line.</font> <br><br>  RND V2,1 <font color="#666666">;</font>  <font color="#666666">Load in V2 a 0 ... 1 random number</font> <br><br>  SE V2 <font color="#339933">,</font> <font color="#0000ff">1</font> <font color="#666666">;</font>  <font color="#666666">It is 1?</font>  <font color="#666666">If yes, I still refers to the left line</font> <br>  <font color="#666666">;</font>  <font color="#666666">bitmap</font> <br><br>  LD I <font color="#339933">,</font> RIGHT <font color="#666666">;</font>  <font color="#666666">If not, we need it</font> <br>  <font color="#666666">;</font>  <font color="#666666">bitmap</font> <br><br>  DRW V0 <font color="#339933">,</font> V1 <font color="#339933">,</font> <font color="#0000ff">4</font> <font color="#666666">;</font>  <font color="#666666">And we draw the bitmap at V0, V1.</font> <br><br>  <font color="#00007f">ADD</font> V0,4 <font color="#666666">;</font>  <font color="#666666">The next bitmap is 4 pixels right.</font>  <font color="#666666">So we update</font> <br>  <font color="#666666">;</font>  <font color="#666666">V0 to do so.</font> <br><br>  SE V0 <font color="#339933">,</font> <font color="#0000ff">64</font> <font color="#666666">;</font>  <font color="#666666">If V0 == 64, we</font> <br>  <font color="#666666">;</font>  <font color="#666666">skip the jump to LOOP, as we have to update V1 too.</font> <br><br>  <font color="#00007f">JP</font> <font color="#00007f">LOOP</font> <font color="#666666">;</font>  <font color="#666666">We did not draw a complete line?</font>  <font color="#666666">So we continue!</font> <br><br>  LD V0 <font color="#339933">,</font> <font color="#0000ff">0</font> <font color="#666666">;</font>  <font color="#666666">The first bitmap of each line is located 0, V1.</font> <br><br>  <font color="#00007f">ADD</font> V1,4 <font color="#666666">;</font>  <font color="#666666">We update V1.</font>  <font color="#666666">The next line is located 4 pixels doan.</font> <br><br>  SE V1 <font color="#339933">,</font> <font color="#0000ff">32</font> <font color="#666666">;</font>  <font color="#666666">Have we drawn all the lines?</font>  <font color="#666666">If yes, V1 == 32.</font> <br>  <font color="#00007f">JP</font> <font color="#00007f">LOOP</font> <font color="#666666">;</font>  <font color="#666666">No?</font>  <font color="#666666">So we continue!</font> <br><br>  FIN <font color="#339933">:</font> <font color="#00007f">JP</font> FIN <font color="#666666">;</font>  <font color="#666666">Infinite loop ...</font> <br><br>  RIGHT:;  <font color="#666666">4 * 4 bitmap of the left line</font> <br><br>  <font color="#000000">DB</font> $ 1 <font color="#339933">.......</font> <br>  <font color="#000000">DB</font> $ <font color="#339933">.</font>  1 <font color="#339933">......</font> <br>  <font color="#000000">DB</font> $ <font color="#339933">..</font> 1 <font color="#339933">.....</font> <br>  <font color="#000000">DB</font> $ <font color="#339933">...</font> 1 <font color="#339933">....</font> <br><br>  LEFT:;  <font color="#666666">4 * 4 bitmap of the right line</font> <br>  <font color="#666666">;</font>  <font color="#666666">And YES, it is like that ...</font> <br>  <font color="#000000">DB</font> $ <font color="#339933">..</font> 1 <font color="#339933">.....</font> <br>  <font color="#000000">DB</font> $ <font color="#339933">.</font>  1 <font color="#339933">......</font> <br>  <font color="#000000">DB</font> $ 1 <font color="#339933">.......</font> <br>  <font color="#000000">DB</font> $ <font color="#339933">...</font> 1 <font color="#339933">....</font> <br></blockquote><br>  occupying 38 bytes and in compiled form it looks like this <br><br><img src="https://habrastorage.org/storage1/c464ab84/fa64fae6/6e371097/225b7e3f.png"><br>  should eventually be executed in our emulator and display something like this on the screen: <br><br><img src="https://habrastorage.org/storage1/f3f557ed/ca6a7f8c/0eb5b5d6/d9b297c9.png"><br><br>  With the end done, go to a little tedious, but necessary theory. <br><br><h4>  Architecture </h4><br>  So, what is the CHIP-8 gaming platform?  Those who speak English can read a detailed article on <a href="http://en.wikipedia.org/wiki/CHIP-8">Wikipedia</a> , but I will try to retell the main points in my own words. <br><br>  CHIP-8 is an interpreted programming language created in the mid-70s for the <a href="http://ru.wikipedia.org/wiki/COSMAC_VIP">COSMAC VIP</a> and Telmac 1800 gaming consoles. Programs written and compiled for CHIP-8 are executed on the prefixes themselves in virtual machines.  Well, by modern analogy, this is something like Java bytecode.  I generally advise you to forget at the time of creating the emulator that this is an interpreted language, and assume that we are emulating an iron platform - a kind of processor with its own instruction set.  Further, when I say ‚Äúprefix‚Äù, I will mean CHIP-8. <br><br><img src="https://habrastorage.org/storage1/8cd9a005/638dffb8/0f2dc392/2c788553.jpg"><br><br>  Our console has a memory, a processor, a video output device, sound, and of course an input device.  Consider all the components in more detail: <br><br>  <b>Memory</b> <br><br>  The prefix has 4Kb of main memory (RAM).  The memory starts at offset 200h and ends at offset FFFh, respectively.  Why does program memory start at offset 200h?  It's very simple - the first 512 bytes of memory in the original consoles are taken by the interpreter of the CHIP-8 language in the machine codes of the processor on which the prefix is ‚Äã‚Äãbuilt. <br><br>  <b>Registers</b> <br><br>  In CHIP-8, there are sixteen 8-bit data registers with the names V0 ... VF.  Register VF is responsible for the carry flag (carry flag) for the operations of addition / subtraction.  Also in the console there is a 16-bit address register I. <br><br>  <b>Stack</b> <br><br>  The stack is used to store the return address when the routine ends.  The original version of the console has a stack size of 48 bytes, which corresponds to twelve nesting levels of subroutines.  Since we are not limited in resources, we will use 16 levels of investment.  This is what most CHIP-8 emulators do. <br><br>  <b>Timers</b> <br><br>  In the console there are two 8-bit timers, they both decrease with a frequency of 60 Hz, until it reaches zero. <br>  Delay timer: This timer is used for various delays in games, its value can be read / changed using commands. <br>  Sound timer: When the timer value is non-zero, a squeaking sound is output. <br><br>  <b>Input device</b> <br><br>  Input is carried out using 16 keys.  In the original console, the keys have codes from 0h to Fh. If we emulate on a computer, it is best to use the right NumPad part of the keyboard, the one where the numbers 0-9 and NumLock are located.  The keys '8', '4', '6', and '2' are commonly used to move, although not always the case.  It depends on the game. <br><br>  <b>Graphics and sound</b> <br><br>  In our console, the screen resolution is 64x32 pixels, one color (monochrome).  The output is implemented using sprites, which are always 8 pixels wide and can be from 1 to 15 pixels long.  If while drawing the sprite is superimposed on another sprite, then at the overlap point the color is inverted, and the VF (carry flag) register takes the value 1. Otherwise it takes the value 0. <br><br>  As noted above, a nasty squeaky sound is played, if the Sound timer value is non-zero.  I think we will not implement the sound at all, I do not like these beeps. <br><br>  <b>Teams</b> <br><br>  Our processor (CHIP-8 in fact) has exactly 35 instructions, each command is always two bytes long.  Here the table of commands will not be reprinted, it is in <a href="http://en.wikipedia.org/wiki/CHIP-8">Wikipedia</a> .  You can take a few examples from there, for example: <br>  00E0 Clears the screen.  - when we meet in code 00E0, just clear the screen. <br>  6XNN Sets VX to NN.  - set the VX register to NN.  For example, if you meet the command 635A, then you need to write the value 5Ah to the V3 register. <br><br><h4>  Practice </h4><br>  From the above, it can be seen that this platform is the best way to start learning how emulators work.  Here we have no clever masked and non-masked interrupts, no heaps of peripherals with I / O ports, no complicated timers, and so on.  Know, read to yourself commands by two bytes from the file, compare them with opcodes and execute what is required.  And the teams then just nothing - 35 pieces.  There are pitfalls, and where without them?  Well, let's get started.  And we begin perhaps with memory. <br><br>  It is clear that the first thing when we start the emulator, we need to initialize our virtual machine.  That is, clear the memory, stack, registers and video memory.  As I wrote above, the offset by which we will load our emulated program is 200h.  Prior to this, that is, from offset 000h to 1FFh, there must be an original interpreter.  It has, among other things, a small font that starts at offset 000h and goes up to 050h and occupies 80 bytes.  It can be seen in the source code of my emulator.  Yes, I apologize for my <s>French</s> Delphi, but I am programming on it, do not blame me.  For simplicity, I created this structure: <br><br><blockquote>  Display <font color="#339933">:</font> <font color="#000066">Array</font> <font color="#009900">[</font> 0..64 <font color="#339933">*</font> <font color="#cc66cc">32-1</font> <font color="#009900">]</font> <font color="#000000">of</font> <font color="#000066">Byte</font> ;  <font color="#666666">// video memory</font> <br>  Memory <font color="#339933">:</font> <font color="#000066">Array</font> <font color="#009900">[</font> 0..4095 <font color="#009900">]</font> <font color="#000000">of</font> <font color="#000066">Byte</font> ;  <font color="#666666">// RAM memory</font> <br>  Stack <font color="#339933">:</font> <font color="#000066">Array</font> <font color="#009900">[</font> 0..15 <font color="#009900">]</font> <font color="#000000">of</font> <font color="#000066">Word</font> ;  <font color="#666666">// stack</font> <br>  Registers <font color="#339933">:</font> <font color="#000066">Array</font> <font color="#009900">[</font> 0..15 <font color="#009900">]</font> <font color="#000000">of</font> <font color="#000066">Byte</font> ;  <font color="#666666">// registers</font> <br>  rI <font color="#339933">:</font> <font color="#000066">Word</font> <font color="#339933">=</font> $ <font color="#cc66cc">200</font> ;  <font color="#666666">// I register</font> <br>  SP <font color="#339933">:</font> <font color="#000066">Byte</font> <font color="#339933">=</font> <font color="#cc66cc">0</font> ;  <font color="#666666">// stack counter</font> <br>  PC <font color="#339933">:</font> <font color="#000066">Word</font> <font color="#339933">=</font> $ <font color="#cc66cc">200</font> ;  <font color="#666666">// mem offset counter</font> <br>  delay_timer <font color="#339933">:</font> <font color="#000066">Byte</font> <font color="#339933">=</font> <font color="#cc66cc">255</font> ;  <font color="#666666">// delay timer;</font> <br>  sound_timer <font color="#339933">:</font> <font color="#000066">Byte</font> <font color="#339933">=</font> <font color="#cc66cc">255</font> ;  <font color="#666666">// sound timer;</font> <br></blockquote><br><br>  So, at the beginning we fill all arrays with zeros, then copy the font (Font: array [1..80] of byte) into the Memory array starting from zero and initialize all values: <br><br><blockquote>  FillChar <font color="#009900">(</font> Memory <font color="#339933">,</font> <font color="#cc66cc">4096</font> <font color="#339933">,</font> <font color="#cc66cc">0</font> <font color="#009900">)</font> ;  <font color="#666666">// clear the main memory</font> <br>  Move <font color="#009900">(</font> Font <font color="#339933">,</font> Memory <font color="#339933">,</font> <font color="#cc66cc">80</font> <font color="#009900">)</font> ;  <font color="#666666">// copy the font into it at offset 000h</font> <br>  FillChar <font color="#009900">(</font> Stack <font color="#339933">,</font> <font color="#cc66cc">16</font> <font color="#339933">,</font> <font color="#cc66cc">0</font> <font color="#009900">)</font> ;  <font color="#666666">// clear the stack</font> <br>  FillChar <font color="#009900">(</font> Registers <font color="#339933">,</font> <font color="#cc66cc">16</font> <font color="#339933">,</font> <font color="#cc66cc">0</font> <font color="#009900">)</font> ;  <font color="#666666">// reset registers to zero</font> <br><br>  rI <font color="#339933">: =</font> $ <font color="#cc66cc">200</font> ;  <font color="#666666">// address register I at the beginning of the program</font> <br>  PC <font color="#339933">: =</font> $ <font color="#cc66cc">200</font> ;  <font color="#666666">// array offset</font> <br><br>  SP <font color="#339933">: =</font> <font color="#cc66cc">0</font> ;  <font color="#666666">// stack counter</font> <br>  delay_timer <font color="#339933">: =</font> <font color="#cc66cc">0</font> ;  <font color="#666666">// timers to zeros</font> <br>  sound_timer <font color="#339933">: =</font> <font color="#cc66cc">0</font> ; <br></blockquote><br><br>  Now everything is ready, you can read the emulated program into memory at offset 200h and take on the interpretation of codes.  Here we will have to remember a little bit who the bits are and how to extract them from bytes and words (word).  For simplicity, I created the procedure ExecuteOpcode (opcode: word), to which an opcode of two bytes is transmitted, interpreted and executed.  To understand the meaning, you can check with the table of commands from <a href="http://en.wikipedia.org/wiki/CHIP-8">Wikipedia</a> . <br><br><blockquote>  <font color="#000000">Procedure</font> ExecuteOpcode <font color="#009900">(</font> opcode <font color="#339933">:</font> <font color="#000066">word</font> <font color="#009900">)</font> ; <br>  <font color="#000000">Begin</font> <br>  <font color="#000000">case</font> <font color="#009900">(</font> op_code <font color="#000066">and</font> $ F000 <font color="#009900">)</font> <font color="#000000">shr</font> <font color="#cc66cc">12</font> <font color="#000000">of</font> <font color="#666666">// select the first 4 bits from the opcode</font> <br>  $ 00 <font color="#339933">:</font> <font color="#000000">Begin</font> <font color="#666666">// opcode started from scratch</font> <br>  <font color="#000000">Case</font> op_code <font color="#000066">and</font> $ 00FF <font color="#000000">of</font> <br>  <font color="#666666">// This is our opcode 00E0 - cleaning the screen</font> <br>  $ E0 <font color="#339933">:</font> <font color="#000000">Begin</font> <br>  <font color="#666666">// We do things, that is, we stupidly clear the screen</font> <br>  exit; <br>  <font color="#000000">End</font> ; <br>  <font color="#666666">// And this is - 00EE - exit from the procedure</font> <br>  $ EE <font color="#339933">:</font> <font color="#000000">Begin</font> <br>  <font color="#666666">// Restore the address from the stack, jump to it</font> <br>  exit; <br>  <font color="#000000">End</font> ; <br>  <font color="#000000">End</font> ; <br>  <font color="#666666">// And here we get, if the opcode started from scratch, but neither E0 nor EE ended</font> <br>  <font color="#666666">// Therefore, either we crash or display the message Invalid Opcode</font> <br>  exit; <br>  <font color="#000000">End</font> ;  <font color="#666666">// end check for zero opcode</font> <br>  $ 01 <font color="#339933">:</font> <font color="#000000">Begin</font> <font color="#666666">// the first four bits of the opcode is 1 (the opcode began with one)</font> <br>  <font color="#666666">// This is JMP, jump.</font>  <font color="#666666">Jump to the desired address</font> <br>  PC <font color="#339933">: =</font> op_code <font color="#000066">and</font> $ 0FFF; <br>  exit; <br>  <font color="#000000">End</font> ; <br>  $ 02 <font color="#339933">:</font> <font color="#000000">Begin</font> <font color="#666666">// the first four bits of the opcode are 2 (the opcode began with a two)</font> <br>  <font color="#666666">// Call the subroutine.</font> <br>  <font color="#666666">// increment the stack pointer</font> <br>  <font color="#666666">// put the current address on the stack</font> <br>  <font color="#666666">// and pry on the subroutine</font> <br>  <font color="#000000">End</font> ; <br>  <font color="#666666">//</font> <br>  <font color="#666666">// This continues to the opcode, which begins with 7.</font> <br>  <font color="#666666">//</font> <br><br>  $ 08 <font color="#339933">:</font> <font color="#000000">Begin</font> <font color="#666666">// opcode started from 8. Here you need to look at the last 4 bits</font> <br>  <font color="#000000">case</font> op_code <font color="#000066">and</font> $ 000F <font color="#000000">of</font> <font color="#666666">// last 4 bits of opcode</font> <br>  <font color="#666666">// mov vx, vy</font> <br>  $ 00 <font color="#339933">:</font> <font color="#000000">Begin</font> <br>  <font color="#666666">// Enter the VY value in the VX register</font> <br>  exit; <br>  <font color="#000000">End</font> ; <br>  <font color="#666666">// or vx, vy</font> <br>  $ 01 <font color="#339933">:</font> <font color="#000000">Begin</font> <br>  <font color="#666666">// VX = VX or VY</font> <br>  exit; <br>  <font color="#000000">End</font> ; <br>  <font color="#666666">//</font> <br>  <font color="#666666">// this goes on to 0E</font> <br>  <font color="#666666">//</font> <br><br>  <font color="#000000">End</font> ;  <font color="#666666">// end of checking the last 4 bits of the opcode</font> <br>  <font color="#666666">// get here if Invalid Opcode</font> <br>  exit; <br>  <font color="#000000">End</font> ;  <font color="#666666">// end of test if opcode started at 8</font> <br></blockquote><br>  And so on, I think the idea should be more or less clear.  At the time of writing the interpreter, you can use stubs for some commands.  Now, when we implement the main processor commands, it remains to draw a conclusion to the screen and implement the input device.  The DXYN command is responsible for displaying on the screen.  In the VX register is the X coordinate, in the VY register is the Y coordinate from which we need to start drawing the sprite.  The address register I at this time points to the bitmap of the sprite.  I will not make the implementation of drawing graphics, I think there should be no difficulties, especially since you can always look at the source at the end of this post.  The same with the keyboard. <br><br><h4>  Conclusion </h4><br><br>  Of course, I could not mention all the implementation details in this article.  The goal is to just push a thought and show an analysis of opcodes.  If anyone is interested, you can see <a href="http://rghost.ru/2262193">my implementation of the emulator</a> on Delphi, or find other implementations of emulators on the Internet.  How fashionable to say, thousands of them.  Starting from Visual Basic and ending with iron solutions. <br>  I apologize in advance for my code, I did not put it in order - I poured it as it is.  The main interesting file there is hchip.pas, it implements all the emulation. <br><br>  There is also a good English-speaking forum EmuTalk, which specifically highlights the <a href="http://www.emutalk.net/showthread.php%3Ft%3D19894">branch</a> dedicated to Chip-8 emulation. <br><br>  <a href="http://www.pong-story.com/chip8/">A page</a> on which you can download probably one of the best chip8 emulators and games for it. <br><br>  Anyway, on request in google "chip-8" you can find everything you need. <br><br>  What else can you do?  You can slightly modify our emulator to support Super chip-8 instructions and sprites.  Yes, a lot more that you can. <br><br>  Have a nice day everyone. </div><p>Source: <a href="https://habr.com/ru/post/100907/">https://habr.com/ru/post/100907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../100898/index.html">MeeGo "on wheels"</a></li>
<li><a href="../100901/index.html">Cafe for IT-Schnick</a></li>
<li><a href="../100902/index.html">BlackBerry has introduced a new slider Torch 9800 and OS BlackBerry 6</a></li>
<li><a href="../100904/index.html">WCG'10 - Russian final</a></li>
<li><a href="../100906/index.html">Vulnerability in Apple iOS 4 allows attackers to remotely execute any code</a></li>
<li><a href="../100909/index.html">GMABooster? Accelerate?</a></li>
<li><a href="../100910/index.html">Application for Habrahabr, v1.0</a></li>
<li><a href="../100912/index.html">Opera games with right click menu</a></li>
<li><a href="../100914/index.html">On gosuslugi.ru now you can see information about your traffic violations</a></li>
<li><a href="../100915/index.html">"Server" for nomadic life</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>