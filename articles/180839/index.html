<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>And let me tell you about the gradients!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="final result screen 

 In this article, I talk about how I invented my own personal bicycle, which draws a gradient almost like in Photoshop. Immediat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>And let me tell you about the gradients!</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/56b/352/9a7/56b3529a77f2bb386c1a674289220d62.png"><br>  <i>final result screen</i> <br><br>  In this article, I talk about how I invented my own personal bicycle, which draws a gradient almost like in Photoshop.  Immediately I warn you, the algorithm is terribly slow and unoptimized.  Optimization and consideration of some popular gradient algorithm I'm going to do in the second part of the article. <br><br><h4>  What for? </h4><br>  Somehow I wanted to implement software rendering of gradients that are most similar to Photoshop.  I had no specific goal, so an interesting task for the evening.  Java was selected as the language.  The important idea was that I wanted to write this algorithm on my own, without peeping into other algorithms. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  What should have happened </h5><br>  The drawGradient () method should work as follows: we set the coordinates and colors of the two points, after which a gradient is drawn over the entire image.  Like that: <br><img src="https://habrastorage.org/storage2/7e9/8be/987/7e98be9872a7c25daecc7e5c44431599.png"><br><br>  In this figure, point A has coordinates (55; 20) and color 0xff2e2e2e, and point B has coordinates (175; 180) and color 0xffb5b5b5.  do not forget that the origin is in the upper left corner, and the Y axis is directed downwards. <br><br><h5>  We start to understand </h5><br>  As a reference, I took the gradient from Photoshop from the last screenshot.  As you can see, the gradient consists of three parts: <br><img src="https://habrastorage.org/storage2/6e7/b06/b98/6e7b06b985b75454c645de2bde816948.png"><br>  The red part should be filled with the color of point A, the green part should be point B, and the color of each pixel of the remaining area should be calculated depending on the distance from it to the straight lines c and d. <br><br>  I think it is obvious that we need an algorithm that will determine the distance from any pixel to the straight lines c and d.  You also need a way to determine which pixel is in the ‚Äúred‚Äù area, which is in the ‚Äúgreen‚Äù area, and which is in the remaining area. <br><br>  Recall a school course in geometry and draw the following illustration for a random pixel E: <br><img src="https://habrastorage.org/storage2/1db/b8e/315/1dbb8e315508dd2a24c52c43d4a7a8b1.png"><br><br>  In this figure, AF is the distance from pixel E to line a.  And, accordingly, FB is the distance to the straight line b.  It is these distances that will determine the color of the pixel.  And then the problem is solved with determining which area the pixel belongs to.  It's all very simple.  If AF + FB&gt; AB, then the pixel is either in the red or in the green zone.  To determine which one, let's compare AF and FB.  If AF&gt; FB, then the pixel is in the green zone, otherwise in the red.  Here is a math. <br><br>  So, our task is to find AF and BF.  Let's concentrate on AF, according to the Pythagorean theorem, it turns out that: <br><img src="https://habrastorage.org/storage2/41c/a30/182/41ca3018282e28623435fe7db793e7bd.gif"><br><br>  So, we can learn the square of length AE from the same Pythagorean theorem, since we know the coordinates of points A and E. It turns out like this: <br><img src="https://habrastorage.org/storage2/8ac/888/fb9/8ac888fb950676e4d0254b0d7bb13398.gif"><br><br>  It remains to find only EF.  This is a little more difficult, but nothing terrible.  Since our segment EF is the height of the triangle, dropped on the side AB, the formula for finding the height will help us.  It looks like this: <br><img src="https://habrastorage.org/storage2/180/605/c25/180605c25ba96bacbdb42685aca57a4d.gif"><br><br>  And p is one of the most misleading things.  This is not a perimeter, but a semi-perimeter.  I remember a couple of times made in the school file on this occasion.  It is considered as: <br><img src="https://habrastorage.org/storage2/842/c14/4c9/842c144c993be24280d5645edf8c56ba.gif"><br><br>  AB and EB are calculated in the same way as AE - based on the coordinates. <br><br>  So, the AF counting algorithm is in full view: <br>  1. Calculate AE, EB and AB <br>  2. Calculate p <br>  3. Calculate EF <br>  4. We calculate AF <br><br>  The algorithm for BF is similar, I will not paint it. <br><br><h5>  It's time to go! </h5><br>  I decided to create a class that represents a wrapper for a BufferedImage, let's call it EditableImage.  And in this class, in my estimation, the following methods should have been: <br><pre><code class="java hljs">EditableImage(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height); <span class="hljs-comment"><span class="hljs-comment">// void clear(int color); //       void drawGradient(int x1, int y1, int color1, int x2, int y2, int color2); //    BufferedImage getImage(); //    </span></span></code> </pre> <br>  Hereinafter, all the colors in my code are given as int, which has the following form: <br><pre> <code class="hljs">0xAARRGGBB AA -   (   32    ) RR -    GG -    BB -   </code> </pre><br>  The idea with the class is convenient because if I later want to implement some more chips besides the gradient, it will be easy to do. <br><br>  Let's start with auxiliary pieces that are irrelevant to the gradient <br><div class="spoiler">  <b class="spoiler_title">Gradient.java - program entry point</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.idgdima.gradient; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gradient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IMG_WIDTH = <span class="hljs-number"><span class="hljs-number">640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IMG_HEIGHT = <span class="hljs-number"><span class="hljs-number">480</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GradientPanel panel; <span class="hljs-comment"><span class="hljs-comment">//,      public static void main(String[] args) { // ,          //   JFrame frame = new JFrame("Test"); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); frame.setResizable(false); //     ,    , //     ,     //     panel = new GradientPanel(IMG_WIDTH, IMG_HEIGHT); frame.add(panel); frame.pack(); frame.setLocationRelativeTo(null); frame.setVisible(true); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GradientPanel.java - the panel on which the gradient will be displayed</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.idgdima.gradient; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.BufferedImage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JPanel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BufferedImage image; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GradientPanel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       super(); setPreferredSize(new Dimension(width, height)); // ,    ,  //        BufferedImage   //    EditableImage gradientImage = new EditableImage(width, height); gradientImage.clear(0xff000000); gradientImage.drawGradient(55, 20, 0xff2e2e2e, 175, 180, 0xffb5b5b5); image = gradientImage.getImage(); } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); //     .     // : g.drawImage(image, 0, 0, null); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">EditableImage.java - The most interesting class, the method for the gradient is empty for now.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.idgdima.gradient; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.BufferedImage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EditableImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] rgb; <span class="hljs-comment"><span class="hljs-comment">//        BufferedImage image; //       getImage public EditableImage(int width, int height) { this.width = width; this.height = height; rgb = new int[width * height]; //    //       getImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR); } /** *        * @param color   */ public void clear(int color) { for (int i = 0; i &lt; rgb.length; i++) { rgb[i] = color; } } /** *     * @return */ public BufferedImage getImage() { //    rgb  image image.setRGB(0, 0, width, height, rgb, 0, width); return image; } public void drawGradient(int x1, int y1, int color1, int x2, int y2, int color2) { //  } }</span></span></code> </pre><br></div></div><br><br>  This program can be compiled already at this stage, but it will show us just a black image.  It's time to write a method for the gradient! <br><br>  I did it like this: <br><div class="spoiler">  <b class="spoiler_title">drawGradient</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawGradient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = x1 - x2; <span class="hljs-comment"><span class="hljs-comment">//  float dy = y1 - y2; float AB = (float) Math.sqrt(dx * dx + dy * dy); //    //    for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { dx = x1 - x; dy = y1 - y; float AE2 = dx * dx + dy * dy; float AE = (float) Math.sqrt(AE2); dx = x2 - x; dy = y2 - y; float EB2 = dx * dx + dy * dy; float EB = (float) Math.sqrt(EB2); float p = (AB + AE + EB) / 2f; float EF = 2 / AB * (float)Math.sqrt(Math.abs(p * (p - AB) * (p - AE) * (p - EB))) float EF2 = EF * EF; float AF = (float) Math.sqrt(Math.abs(AE2 - EF2)); float BF = (float) Math.sqrt(Math.abs(EB2 - EF2)); if (AF + BF - 0.1f &gt; AB) { //        rgb[y * width + x] = AF &lt; BF ? color1 : color2; } else { //   float progress = AF / AB; //  interpolate    rgb[y * width + x] = interpolate(color1, color2, progress); } } } } /** * @param num -  * @return 0,  num &lt; 0; 255,  num &gt; 255;    num */ private static int clip(int num) { return num &lt;= 0 ? 0 : (num &gt;= 255 ? 255 : num); }</span></span></code> </pre><br></div></div><br><br>  Please note that I use the module function - Math.abs () wherever there is even the slightest probability that a negative number can get into the function of finding the square root - Math.sqrt ().  Otherwise, we will have artifacts. <br><br>  And in this line, if you remove <code>- 0.1f</code> , it turns out just a terrible mess.  Due to the error of calculations, we have to take a small number: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AF + BF - <span class="hljs-number"><span class="hljs-number">0.1f</span></span> &gt; AB) {</code> </pre><br><br>  It remains only to deal with the interpolate method and the trick is done.  It should take the initial color, the final color and the number of progress, which can be from 0 to 1 and which determines the proportion of each color.  For example, if progress = 0, the initial color is returned, if progress = 1 the final color, and if progress = 0.5, the average color between the initial and final color.  The task is clear, the method is written: <br><div class="spoiler">  <b class="spoiler_title">interpolate</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interpolate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> progress)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     int a1 = (color1 &amp; 0xff000000) &gt;&gt;&gt; 24; int r1 = (color1 &amp; 0x00ff0000) &gt;&gt;&gt; 16; int g1 = (color1 &amp; 0x0000ff00) &gt;&gt;&gt; 8; int b1 = color1 &amp; 0x000000ff; int a2 = (color2 &amp; 0xff000000) &gt;&gt;&gt; 24; int r2 = (color2 &amp; 0x00ff0000) &gt;&gt;&gt; 16; int g2 = (color2 &amp; 0x0000ff00) &gt;&gt;&gt; 8; int b2 = color2 &amp; 0x000000ff; //   float progress2 = (1 - progress); int newA = clip((int) (a1 * progress2 + a2 * progress)); int newR = clip((int) (r1 * progress2 + r2 * progress)); int newG = clip((int) (g1 * progress2 + g2 * progress)); int newB = clip((int) (b1 * progress2 + b2 * progress)); //     return (newA &lt;&lt; 24) + (newR &lt;&lt; 16) + (newG &lt;&lt; 8) + newB; }</span></span></code> </pre><br></div></div><br><br><h5>  Let's look at the result! </h5><br><img src="https://habrastorage.org/storage2/65b/921/a87/65b921a87ff40c9b605c17d8f46bee6f.png"><br><br>  Already not bad, but ours uses linear interpolation, and in Photoshop there is definitely some other move. <br><br><h5>  About interpolation </h5><br>  Look carefully at the picture.  The left gradient is drawn by our algorithm, the right one by photoshop.  Each line has a red dot.  And the darker the line, the dot to the left: <br><img src="https://habrastorage.org/storage2/27e/617/f0d/27e617f0d54715a1d9b2f3222b568f6b.png"><br>  As you can see, our line is straight, like a rail.  It is necessary to fix it.  Here I did not come up with anything sensible and decided to peep on the Internet.  Found an article on Habr√©, which describes some types of interpolation, and even the code is: <a href="http://habrahabr.ru/post/142592/">habrahabr.ru/post/142592</a> <br><br>  Well, we realize cosine interpolation!  First, add two constants to the EditableImage class: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INTERPOLATION_LINEAR = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INTERPOLATION_COS = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Second, we will rewrite the interpolate method a bit, so that one of these constants is supplied to it at the input: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interpolate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> progress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interpolation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     int a1 = (color1 &amp; 0xff000000) &gt;&gt;&gt; 24; int r1 = (color1 &amp; 0x00ff0000) &gt;&gt;&gt; 16; int g1 = (color1 &amp; 0x0000ff00) &gt;&gt;&gt; 8; int b1 = color1 &amp; 0x000000ff; int a2 = (color2 &amp; 0xff000000) &gt;&gt;&gt; 24; int r2 = (color2 &amp; 0x00ff0000) &gt;&gt;&gt; 16; int g2 = (color2 &amp; 0x0000ff00) &gt;&gt;&gt; 8; int b2 = color2 &amp; 0x000000ff; //   float f; if (interpolation == INTERPOLATION_LINEAR) { f = progress; } else if (interpolation == INTERPOLATION_COS) { float ft = progress * 3.1415927f; f = (1 - (float) Math.cos(ft)) * 0.5f; } else { throw new IllegalArgumentException(); } int newA = clip((int) (a1 * (1 - f) + a2 * f)); int newR = clip((int) (r1 * (1 - f) + r2 * f)); int newG = clip((int) (g1 * (1 - f) + g2 * f)); int newB = clip((int) (b1 * (1 - f) + b2 * f)); //     return (newA &lt;&lt; 24) + (newR &lt;&lt; 16) + (newG &lt;&lt; 8) + newB; }</span></span></code> </pre><br></div></div><br>  Then add <code>int interpolation</code> to the list of parameters of the drawGradient method and add this variable to the line calling the interpolate method: <br><pre> <code class="java hljs">rgb[y * width + x] = interpolate(color1, color2, progress , interpolation);</code> </pre><br>  Finally, in the GradientPanel class, we rewrite the call to the drawGradient method, adding INTERPOLATION_COS to it <br><br>  This is what happened with this interpolation method: <br><img src="https://habrastorage.org/storage2/cb5/dbf/64b/cb5dbf64b7abc6efa85e692e23c70580.png"><br>  Hmm, it looks good, but in Photoshop the line is clearly not that curve.  What to do?  That is too straight, then too curve ... And what if we make the average of these two extremes? <br><br>  Great idea, add constant <code>INTERPOLATION_COS_LINEAR = 2</code> <br><br>  And in the code of the interpolate method we add one more else if: <br><pre> <code class="java hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interpolation == INTERPOLATION_COS_LINEAR) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ft = progress * <span class="hljs-number"><span class="hljs-number">3.1415927f</span></span>; f = (progress + (<span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) Math.cos(ft)) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) / <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre><br>  And lo and behold, it turned out almost a complete copy of the gradient from Photoshop! <br>  See for yourself: <br><img src="https://habrastorage.org/storage2/09c/7b4/54e/09c7b454e9ce6b1ce2751cb050a99cd1.png"><br>  Our left. <br><br>  But you two pictures from the top screenshot, combined into one.  It is seen that the interpolation is almost the same, the differences can be blamed on errors when rounding: <br><img src="https://habrastorage.org/storage2/23c/7a3/758/23c7a3758178f89735f7956041608885.png"><br><br>  Hurray, we made a gradient like in photoshop, albeit much slower. <br>  <a href="http://yadi.sk/d/F8qe0UNS58zT3">Sources and jar</a> <br><br>  On this I finish the first part.  In the second part I will try to optimize the algorithm as cool as I can.  And I implement some ready-known fast gradient drawing algorithm, and then compare it in speed with my own. <br><br>  By the way, if you have in mind fast gradient drawing algorithms, leave them in the comments. </div><p>Source: <a href="https://habr.com/ru/post/180839/">https://habr.com/ru/post/180839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../180825/index.html">Highscreen Black Box Outdoor: a recorder for cars and bicycles</a></li>
<li><a href="../180827/index.html">PHP Decorators</a></li>
<li><a href="../180829/index.html">About hatred of fish ... and love of meaningful text. Part 1</a></li>
<li><a href="../180833/index.html">Why buy Pebble Watch</a></li>
<li><a href="../180837/index.html">Code organization in large AngularJS and JavaScript applications</a></li>
<li><a href="../180841/index.html">Clonezilla live CD multicast OS cloning on 10 servers by reference</a></li>
<li><a href="../180845/index.html">Video instruction for self-destruct flash drives</a></li>
<li><a href="../180847/index.html">Django: JSON edit form widget</a></li>
<li><a href="../180849/index.html">The tool to control the behavior of robots on your site</a></li>
<li><a href="../180851/index.html">Advantages of placing in the Netherlands, EvoSwitch Data Center</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>