<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CSS GuideLines, part 3. Naming classes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CSS naming conventions allow you to write strong, clean, and beautiful code. If you follow the naming rules, you will always know: 



- What is the c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CSS GuideLines, part 3. Naming classes</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/39d/5b1/09c/39d5b109c211459f8b1c7395944d13c4.png" width="900"></div><br><br>  CSS naming conventions allow you to write strong, clean, and beautiful code.  If you follow the naming rules, you will always know: <br><br><ul><li>  What is the class used for? </li><li>  Where the class can be used; </li><li>  What other classes is this class associated with. </li></ul><a name="habracut"></a><br>  The naming rules I follow are very simple: I use a hyphen as a separator, and in difficult places I use BEM-like naming. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It should be noted that the naming rules themselves will not give much benefit when writing CSS;  but they are very useful when viewing the markup. <br><br><h4>  <b>Hyphen separation</b> </h4><br>  All words in class names must be separated by a hyphen: <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.page-head</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.sub-content</span></span> {}</code> </pre> <br>  CamelCase and underscore are not used for classes, the following example is incorrect: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.pageHead</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.sub_content</span></span> {}</code> </pre><br><br><h4>  <b>BEM-like naming</b> </h4><br>  For larger interconnected parts of the interface, I use BEM-like class naming. <br><br>  BEM, that is, <i>Block, Element, Modifier</i> , is a methodology created by Yandex developers.  Despite the fact that BEM is a rather large methodology, at the moment we are only interested in its method of naming elements.  Moreover, my naming convention is slightly different from the original BEM: the principles are the same, but the syntax is different. <br><br>  BEM divides the layout components into three groups: <br><ul><li>  Block: main root element. </li><li>  Element: part of a block. </li><li>  Modifier: option or modification of the block. </li></ul><br>  Draw an analogy: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.person</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.person__head</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.person--tall</span></span> {}</code> </pre><br>  At the beginning of the class, the block name is always put, to denote an element, we separate the block name from the element name by two underscores (__), and to denote a modifier we use two hyphens (-). <br><br>  In the example above, we can see that <code>.person {}</code> is a block;  he has no ancestors.  <code>.person__head {}</code> is an element, part of a block;  finally, <code>.person--tall</code> is a modifier, a kind of <code>.person {}</code> block. <br><br><h5>  <b>Use blocks</b> </h5><br>  A block must be a logical, independent unit.  Continuing our example with the class <code>.person {}</code> : we cannot create the class <code>.room__person</code> , because <code>.room {}</code> is an independent unit.  In this case, it is worth separating the blocks: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.room</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.room__door</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.room--kitchen</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.person</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.person__head</span></span> {}</code> </pre><br>  If we need to designate a person inside the room, it would be more appropriate to use such a selector - <code>.room .person</code> , which allows you to <code>.room .person</code> porridge out of a heap of different incomprehensible elements and blocks. <br><br>  A more realistic example of the correct use of blocks might look like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.page</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.sub-content</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.footer</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.footer__copyright</span></span> {}</code> </pre><br>  Each piece of code represents its own block.  Incorrect usage example: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.page</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.page__content</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.page__sub-content</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.page__footer</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.page__copyright</span></span> {}</code> </pre><br>  It is important to be able to distinguish where BEM is worth applying, and where not.  As a rule, I use blocks to describe the autonomous parts of the user interface. <br><br><h5>  <b>Many layers</b> </h5><br>  If we added another element to our <code>.person {}</code> block, say, <code>.person__eye</code> , we would not need to step back when naming an element, adding the names of the previous elements, right down to the root element.  That is, it will be correct to write <code>.person__eye</code> , and not <code>.person__head__eye</code> . <br><br><h5>  <b>Adding element modifications</b> </h5><br>  You may need to add variations of elements, this can be done in several ways, depending on how and why these elements should be changed.  Again, if a person has blue eyes, then in CSS this can be described as: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.person__eye--blue</span></span> {}</code> </pre><br>  However, in real projects everything is a bit more complicated.  I apologize for such an analogy, but let us imagine a person with a beautiful face.  By itself, it is not particularly beautiful, so the best solution would be to add a modifier to the element <code>.person__face {}</code> : <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.person__face--handsome</span></span> {}</code> </pre><br>  But what if we want to describe the face of a beautiful person?  That is, the person is beautiful in itself, unlike the previous example, and we need to describe his face?  This is done as follows: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.person--handsome</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.person__face</span></span> {}</code> </pre><br>  This is one of the few cases when we can change an element depending on the modification of the block.  If you use Sass, you would get this code: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.person</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.person__face</span></span> { .person--handsome &amp; {} } <span class="hljs-selector-class"><span class="hljs-selector-class">.person--handsome</span></span> {}</code> </pre><br>  Notice that we are not adding a new <code>.person__face</code> element inside the <code>.person--handsome</code> element <code>.person--handsome</code> ;  instead, we use the Sass parent selector inside the existing <code>.person__face</code> selector.  This means that all the rules associated with <code>.person__face</code> will be in one place, and we will not have to scatter them all over the file.  This is a good practice when working with nested code: keep all the necessary styles inside one context (in our case, inside <code>.person__face</code> ). <br><br><h4>  <b>Naming in markup</b> </h4><br>  As previously noted, the class naming convention is most useful when working with markup.  Take a look at the next piece of markup, not our agreement: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"box profile pro-user"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"avatar image"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bio"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  How are the <code>.box</code> and <code>.profile</code> classes related to each other?  How are the <code>.profile</code> and <code>.avatar</code> related to each other?  Are they related at all?  Does the <code>.bio</code> class <code>.bio</code> on the <code>.pro-user</code> class?  Can I use the <code>.avatar</code> class outside of this markup? <br><br>  When viewing such markup it is very difficult to answer all these questions.  Using a naming convention changes things: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"box profile profile--is-pro-user"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"avatar profile__image"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"profile__bio"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Now we immediately see which classes are related to each other and how, and which ones are not;  we know which classes we cannot use outside of this markup;  Finally, we know which classes can be used elsewhere. <br><br><h4>  <b>Javascript hooks</b> </h4><br><br>  It is generally unwise to tie JS and CSS code to the same class in the markup, because if you delete or change one class to, for example, change script behavior, you will certainly affect CSS, and vice versa.  Much cleaner, more transparent and generally better to tie JS to individual classes. <br><br>  I came across cases when deleting some classes for the purpose of processing styles, broke all the scripts on the page, and all because the developer did not think and linked the styles with scripts to the same class. <br><br>  As a rule, developers use a separate class for js, starting with the prefix "js-", for example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"btn js-btn"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Follow"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  This markup allows you to use <code>.btn</code> styles anywhere else without affecting the behavior of <code>.js-btn</code> . <br><br><h5>  <b>data- * attributes</b> </h5><br>  Also, quite often developers use data- * attributes as js-hooks, but this is wrong.  data- * attributes, according to the specification, are designed to store data that is not available on the page.  data- * attributes are created for storing data, not for binding to js. <br><br><h4>  <b>Continuing the theme ...</b> </h4><br>  As already mentioned, all the rules presented above are very simple.  I urge you not to dwell on what you have learned and read other materials on this topic - this will allow you to get more opportunities for naming classes. <br><br><h4>  <b>Materials for additional study</b> </h4><br><ul><li>  <a href="http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/">Dizzying immersion in BEM</a> (there is a <a href="http://frontender.info/MindBEMding/">translation</a> ) </li></ul><br><br>  Previous part: <a href="http://habrahabr.ru/post/235893/">CSS GuideLines, part 2. Commenting code</a> </div><p>Source: <a href="https://habr.com/ru/post/236047/">https://habr.com/ru/post/236047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236035/index.html">Game "life", Chaos, "black swan", ethnogenesis and how it all is connected</a></li>
<li><a href="../236037/index.html">Entity Framework Code First in practice</a></li>
<li><a href="../236039/index.html">Exhibition 3D PrintShow in London. Industry - a gold mine or a ghost hunt?</a></li>
<li><a href="../236041/index.html">RailsClub'Moscow 2014. Interview with Aaron Patterson</a></li>
<li><a href="../236043/index.html">Start Sandbox Championship Russian AI Cup 2014</a></li>
<li><a href="../236049/index.html">Let's look under the hood: Microsoft Outlook 2013 Attachments Reminder</a></li>
<li><a href="../236053/index.html">Fastest Intel Core</a></li>
<li><a href="../236057/index.html">Traffic Optimization for Apache and Nginx Web Servers</a></li>
<li><a href="../236059/index.html">Results and Digital Trip Team</a></li>
<li><a href="../236061/index.html">CLion - the long-awaited IDE from JetBrains for C / C ++ developers - opens a public EAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>