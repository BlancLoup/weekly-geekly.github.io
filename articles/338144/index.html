<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rapid development of monitoring scripts with Bash, Outthentic and Sparrow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good time of day! 


 In this post, I will talk about how to quickly and easily write various scripts to check the state of the infrastructure using t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rapid development of monitoring scripts with Bash, Outthentic and Sparrow</h1><div class="post__text post__text-html js-mediator-article"><p>  Good time of day! </p><br><p>  In this post, I will talk about how to quickly and easily write various scripts to check the state of the infrastructure using the tools <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a> , <a href="https://github.com/melezhik/outthentic">Outthentic</a> and <a href="https://github.com/melezhik/sparrow">Sparrow</a> ... </p><a name="habracut"></a><br><p>  Task - we have a server on which we install applications and do configuration settings.  I want to write a script that will quickly give us the answer that everything is fine with the server, and the application is configured and working correctly.  A sort of <a href="https://en.wikipedia.org/wiki/Smoke_testing_(software)">smoke</a> test that will be useful to us when we search for problems or simply check that the next deployment has not broken anything.  Anticipating possible questions, I know that <em>there</em> are <em>already</em> tools that do something similar ( <a href="https://github.com/chef/inspec">inspec</a> ), however, I want to talk about an alternative hike.  (It will be interesting to compare). </p><br><h1 id="vybor-instrumentariya">  Tool selection </h1><br><p>  So why <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a> ?  Because it is quite simple to use and allows you to quickly and efficiently write all sorts of scripts, imho I would not use Bash for more complex tasks, but for this kind of problems it is quite suitable. </p><br><p>  Then, what is Outthentic and how is it useful to us here?  <a href="https://metacpan.org/pod/Outthentic">Outthentic</a> is a scripting framework that allows you to quickly write, configure, and run your script (in this case, written in Bash, but also in other languages), just as importantly, Outthentic has a built-in <a href="https://metacpan.org/pod/Outthentic::DSL">DSL</a> that is suitable for writing scripts in style automated tests that can be convenient when writing monitoring scripts. </p><br><p>  And finally - why (or something like that) <a href="https://metacpan.org/pod/Sparrow">Sparrow</a> and how will it help us?  Sparrow is a platform and runtime environment for user scripts that allows you to distribute and customize ready-made scripts in the form of so-called  Sparrow plugins.  The main exhaust is that when our squeak is written and tested, you can pack it in the form of a plug-in, upload it to the Sparrow repository and transfer it further to the operations department and / or any other colleagues who want to use your script. </p><br><h1 id="prakticheskiy-primer">  Practical example </h1><br><p> The example is partly based on real practice, and partly <em>deliberately</em> simplified so as not to overload the article with unnecessary details.  I have to do more or less of this kind of checking all the time, so I decided to write an automation script for them, so we‚Äôll check what the target target server is on the <code>target-server</code> : </p><br><ul><li><p>  tomcat is running, that is, it is visible in the process list </p><br></li><li><p>  http requests for some application resources (deployed on the server) <br>  return successful http code ( <code>200</code> ) - <code>GET 127.0.0.1:8080/healthcheck</code> </p><br></li><li>  a database server is available from the target server ( <code>192.168.0.2</code> ), at the access level on the tcp port (very often, due to incorrectly configured security policies, this may not be the case, which leads to an application being inoperative) </li></ul><br><p>  Yes, and it is important to note that all checks are performed directly on the target server: </p><br><pre> <code class="hljs pgsql">$ ssh target-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> $ bash /<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">check</span></span>/script.bash</code> </pre> <br><h1 id="bash-skript">  Bash script </h1><br><p>  In this case, the script will be trivial: </p><br><pre> <code class="bash hljs">$ cat script.bash <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash ps uax | grep tomcat | grep -v grep echo; echo timeout 5 curl -sL 127.0.0.1:8080/healthcheck -w "GET /healhcheck --- %{http_code}\n" -o /dev/null echo; echo timeout 5 bash -c "echo OK | telnet 192.168.0.2 3306"</span></span></code> </pre><br><p>  By running the script on the target server, we‚Äôll get something like this in the output: (at this stage no checks are performed, just make sure the script is working): </p><br><pre> <code class="hljs ruby">$ bash script.bash GET /healhcheck --- <span class="hljs-number"><span class="hljs-number">200</span></span> tomcat <span class="hljs-number"><span class="hljs-number">8264</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">32.1</span></span> <span class="hljs-number"><span class="hljs-number">2222884</span></span> <span class="hljs-number"><span class="hljs-number">326452</span></span> ? Sl Sep14 <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">04</span></span> /usr/lib/jvm/java-<span class="hljs-number"><span class="hljs-number">1.8</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>/bin/java -Djava.util.logging.config.file=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tomcat8/conf</span></span><span class="hljs-regexp"><span class="hljs-regexp">/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xmx128M -Djava.awt.headless=true -Djava.endorsed.dirs=/usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/share/tomcat</span></span>8/endorsed -classpath /usr/share/tomcat8/bin/bootstrap.<span class="hljs-symbol"><span class="hljs-symbol">jar:</span></span>/usr/share/tomcat8/bin/tomcat-juli.jar -Dcatalina.base=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tomcat8 -Dcatalina.home=/usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/share/tomcat</span></span>8 -Djava.io.tmpdir=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tomcat8/temp</span></span> org.apache.catalina.startup.Bootstrap start Trying <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ... Connected to <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. Connection closed by foreign host.</code> </pre><br><h1 id="proverka-vyvoda-skripta">  Script output check </h1><br><p>  The whole point of our monitoring is the possibility of consecutively launching several commands and then analyzing their output using a set of simple rules, here Outthentic comes into play. </p><br><p>  First, install the package as a CPAN module: </p><br><pre> <code class="hljs ruby">$ cpanm Outthentic</code> </pre> <br><p>  Next, slightly modify our script so that it can be run through Outthentic: </p><br><ul><li>  Rename the script to <code>strory.bash</code> - this is the agreement to have scripts in the Outthentic framework: </li></ul><br><pre> <code class="hljs ruby">$ mv script.bash story.bash</code> </pre> <br><ul><li>  run the script through the console client <code>strun</code> , which comes with the Outthentic framework and actually runs the scripts: </li></ul><br><pre> <code class="hljs ruby">$ strun</code> </pre> <br><p>  We'll get the output, just like when we ran the script directly.  So far, the benefits of Outthentic are not obvious.  We reach the use of DSL.  Create some simple <em>check rules</em> for validating the output of the script and put the rules in the file <code>story.check</code> : </p><br><pre> <code class="hljs pgsql">$ cat story.<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /healhcheck <span class="hljs-comment"><span class="hljs-comment">--- 200 tomcat8 Connected to 192.168.0.2</span></span></code> </pre><br><p>  Run the <code>strun</code> again: </p><br><pre> <code class="hljs ruby">$ strun <span class="hljs-number"><span class="hljs-number">2017</span></span>-09-<span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">39</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">55</span></span> : [path] / GET /healhcheck --- <span class="hljs-number"><span class="hljs-number">200</span></span> tomcat <span class="hljs-number"><span class="hljs-number">8264</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">32.1</span></span> <span class="hljs-number"><span class="hljs-number">2222884</span></span> <span class="hljs-number"><span class="hljs-number">326452</span></span> ? Sl Sep14 <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">04</span></span> /usr/lib/jvm/java-<span class="hljs-number"><span class="hljs-number">1.8</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>/bin/java -Djava.util.logging.config.file=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tomcat8/conf</span></span><span class="hljs-regexp"><span class="hljs-regexp">/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xmx128M -Djava.awt.headless=true -Djava.endorsed.dirs=/usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/share/tomcat</span></span>8/endorsed -classpath /usr/share/tomcat8/bin/bootstrap.<span class="hljs-symbol"><span class="hljs-symbol">jar:</span></span>/usr/share/tomcat8/bin/tomcat-juli.jar -Dcatalina.base=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tomcat8 -Dcatalina.home=/usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/share/tomcat</span></span>8 -Djava.io.tmpdir=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tomcat8/temp</span></span> org.apache.catalina.startup.Bootstrap start Trying <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ... Connected to <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. Connection closed by foreign host. ok scenario succeeded ok text has <span class="hljs-string"><span class="hljs-string">'GET /healhcheck --- 200'</span></span> ok text has <span class="hljs-string"><span class="hljs-string">'tomcat8'</span></span> ok text has <span class="hljs-string"><span class="hljs-string">'Connected to 192.168.0.2'</span></span> STATUS SUCCEED</code> </pre> <br><p>  We see that the verification rules worked and that the output from the script successfully passed all the checks, and that‚Äôs all we need from our monitoring.  <a href="https://github.com/melezhik/outthentic">The</a> <code>strun</code> report <code>strun</code> customizable and has several options, for example, we can choose a more concise output that will give all the details <em>only</em> in case of an error: </p><br><pre> <code class="hljs pgsql">$ strun <span class="hljs-comment"><span class="hljs-comment">--format production</span></span></code> </pre> <br><p>  Here is what the report will look like if, for some reason, we do not have a tomcat server running: </p><br><pre> <code class="hljs mel">$ strun --<span class="hljs-keyword"><span class="hljs-keyword">format</span></span> production <span class="hljs-number"><span class="hljs-number">2017</span></span><span class="hljs-number"><span class="hljs-number">-09</span></span><span class="hljs-number"><span class="hljs-number">-18</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">44</span></span>:<span class="hljs-number"><span class="hljs-number">43</span></span> : [path] / not ok <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> has <span class="hljs-string"><span class="hljs-string">'tomcat8'</span></span> GET /healhcheck --- <span class="hljs-number"><span class="hljs-number">200</span></span> Trying <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> ... Connected to <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>. Escape <span class="hljs-keyword"><span class="hljs-keyword">character</span></span> is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. Connection closed by foreign host. STATUS FAILED (<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><h1 id="parametrizaciya-skripta-monitoringa">  Parameterization of the monitoring script </h1><br><p>  Outthentic is also convenient because it allows you to simply add and customize <em>input parameters</em> for your scripts.  Suppose, theoretically, we want to specify the host and port for the database server. </p><br><p>  Add default values ‚Äã‚Äãof input parameters via suite.yaml - file for storing default settings in Outthentic terminology: </p><br><pre> <code class="hljs matlab">$ <span class="hljs-built_in"><span class="hljs-built_in">cat</span></span> suite.yaml --- db_server: ip_address: <span class="hljs-string"><span class="hljs-string">"192.168.0.2"</span></span> port: <span class="hljs-number"><span class="hljs-number">3306</span></span></code> </pre><br><p>  In this case, the hierarchy of the configuration file can be arbitrary, I just want to show how easy it is to transfer input parameters described by a hierarchical data structure using Outthentic and <em>even</em> use them inside Bash scripts (without additional parsing): </p><br><p>  Slightly change the monitoring creak that he would take his input parameters <em>from outside</em> : </p><br><pre> <code class="bash hljs">$ cat script.bash <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash db_server_address=$(config db_server.ip_address) db_server_port=$(config db_server.port) # ...      # ... timeout 5 bash -c "echo OK | telnet $db_server_address $db_server_port $db_server_port"</span></span></code> </pre> <br><p>  Now we can run our script with default parameters: </p><br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">      ip address 192.168.0.2   3306 $ strun</span></span></code> </pre> <br><p>  Or override the parameters via the command line: </p><br><pre> <code class="hljs pgsql">$ strun <span class="hljs-comment"><span class="hljs-comment">--param db_server.ip_address=192.168.0.3 --param db_server.port=3307</span></span></code> </pre> <br><p>  Go ahead, all we have to do is transfer the script to operation for all interested parties, for this we need Sparrow. </p><br><h1 id="distribuciya-skripta-v-vide-sparrow-plagina">  Sparrow plugin script distribution </h1><br><p>  Sparrow provides two basic scripting distribution options - through the <a href="https://sparrowhub.org/">SparrowHub</a> public repository and through <a href="https://github.com/melezhik/sparrow">private</a> repositories built on the use of remote <a href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">Git</a> repositories. </p><br><p>  <em>Most likely</em> , when we write purely internal scripts, the second method is more suitable for us.  It is also more simple, since it requires only that the script source code be in some remote Git repository, what will we do this: </p><br><pre> <code class="hljs ruby">$ git init . $ git add . $ git commit -a -m <span class="hljs-string"><span class="hljs-string">"outthentic monitoring script"</span></span></code> </pre> <br><p>  Having added the main project files (story.bash and story.check), it remains for us to set up a file with <a href="https://github.com/melezhik/sparrow">meta data</a> (which actually makes it clear that this is not just a script, but a Sparrow plugin): </p><br><pre> <code class="hljs pgsql">$ cat sparrow.json { "name" : "server-check" "description" : "check server health" }</code> </pre> <br><p>  In fact, a file with meta data may contain a much larger number of parameters, but for the sake of simplicity we will limit ourselves to the minimum set. </p><br><p>  Ok, we actually made our first Sparrow plugin, it remains to send files to git remote: </p><br><pre> <code class="hljs sql">git add sparrow.json git <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span> -a -m <span class="hljs-string"><span class="hljs-string">"add sparrow meta file"</span></span> git remote <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> origin $remote-git-repository git push -u origin <span class="hljs-keyword"><span class="hljs-keyword">master</span></span></code> </pre> <br><h1 id="ispolzovanie-gotovogo-skripta-monitoringa-_kak_-sparrow-plagina">  Using a ready-made monitoring script <em>as a</em> Sparrow plugin </h1><br><p>  This is the most interesting part in the sense that it shows how Sparrow facilitates the process of installing and integrating your scripts with third-party commands. </p><br><p>  To begin with, in order to use the plugin created by us on some target server, we need to install the Sparrow client on this server: </p><br><pre> <code class="hljs ruby">$ cpanm Sparrow</code> </pre> <br><p>  Then everything is simple, because  the plugin is private and will not be downloaded from the common repository, we notify Sparrow about it: </p><br><pre> <code class="hljs bash">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server-check </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote</span></span></span><span class="hljs-string">-git-repository"</span></span> &gt;&gt; ~/sparrow.list</code> </pre> <br><p>  The pair of values ‚Äã‚Äãthat we have to put in the local index file <code>~/sparrow.list</code> is the name of the plugin (it doesn‚Äôt have to be the same as what we used in the previous part and the URL of the remote repository, where the plugin source code lies) </p><br><p>  Now we are updating the sparrow index so that the plugin added by us becomes available: </p><br><pre> <code class="hljs pgsql">$ sparrow <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span></code> </pre> <br><p>  And install the plugin itself: </p><br><pre> <code class="hljs sql">$ sparrow plg <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">check</span></span></code> </pre> <br><p>  Now we can run the plugin as is: </p><br><pre> <code class="hljs sql">$ sparrow plg <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">check</span></span></code> </pre> <br><p>  Or, passing it the parameters: </p><br><pre> <code class="hljs sql">$ sparrow plg <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-comment"><span class="hljs-comment">--param db_server.ip_address=192.168.0.3 --param db_server.port=3307</span></span></code> </pre> <br><p>  And finally, all the same can be run as a Sparrow <a href="https://github.com/melezhik/sparrow">task</a> : </p><br><pre> <code class="hljs sql">$ sparrow project <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">monitoring</span></span> $ sparrow task <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">monitoring</span></span> app1 <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> $ sparrow task ini <span class="hljs-keyword"><span class="hljs-keyword">monitoring</span></span>/app1 <span class="hljs-comment"><span class="hljs-comment">--- db_server: ip_address: "192.168.0.2" port: 3306 --- $ sparrow task run monitoring/app1</span></span></code> </pre><br><p>  The last launch option is convenient because you can create several tasks (with different configurations) to launch the same plug-in.  In essence, a task is a named configuration for running a Sparrow plug-in, and a project is a group of tasks. </p><br><h1 id="ps">  PS </h1><br><p>  That's all.  If anyone is interested, this is what I have not said: </p><br><ul><li><p>  Private Sparrow repositories can be configured not only through the local index files <code>~/sparrow.list</code> (which is inconvenient with a large number of plug-ins), but also through <a href="https://github.com/melezhik/sparrow-nest">Sparrow :: Nest</a> - API for managing private Sparrow repositories. </p><br></li><li><p>  Sparrow plug-ins can be run remotely on servers (via ssh) with automatic pre-installation of the Sparrow client - welcome to the <a href="https://github.com/melezhik/sparrowdo/">Sparrowdo</a> project.  There is another <em>Perl6 API</em> for Sparrow and much more (- <em>:!</em> </p><br></li><li>  Outthentic DSL allows you to create much more complex and interesting test rules than just matching a substring.  Among them are the Perl5 regexp check, the range check and sequence of strings, as well as the dynamic rule generation using general purpose programming languages. </li></ul><br><p>  As always - questions, comments, suggestions, constructive criticism - is welcome. </p><br><p>  Sincerely. </p><br><p>  Alexey </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338144/">https://habr.com/ru/post/338144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338132/index.html">Introduction to kube-spawn - a utility for creating local Kubernetes-clusters</a></li>
<li><a href="../338134/index.html">How to assemble Ceylon in a container if your container ship is blocked</a></li>
<li><a href="../338136/index.html">OO VS FP</a></li>
<li><a href="../338140/index.html">PHP is alive. PHP 7 in practice</a></li>
<li><a href="../338142/index.html">Shopping with full-stack redux</a></li>
<li><a href="../338146/index.html">Russia's first OpenHack from Microsoft (that is, from us)</a></li>
<li><a href="../338148/index.html">MultiSim + M2M OTA platform</a></li>
<li><a href="../338150/index.html">How JS works: memory management, four types of memory leaks and how to deal with them</a></li>
<li><a href="../338154/index.html">How to launch a patent process in an IT company</a></li>
<li><a href="../338156/index.html">Another HighLoadCup solution on Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>