<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java and Project Reactor. Episode 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Surprisingly, the first part of the article even liked someone. 
 Special thanks for your feedback and comments. I have for you  bad  good news...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java and Project Reactor. Episode 2</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/sh/ub/cf/shubcf8bhffucemue9hbvkb7baw.jpeg"></p><br><p>  Hello!  Surprisingly, the <a href="https://habrahabr.ru/company/funcorp/blog/350996/">first part of the article</a> even liked someone. <br>  Special thanks for your feedback and comments.  I have for you <del>  bad </del>  good news: we still have something to talk about!  And more specifically, about some of the details of the work of Reactor. </p><a name="habracut"></a><br><h3 id="ya-otrekayus-ot-magii">  I renounce magic </h3><br><p>  For further deepening in Reactor, it will not be superfluous to describe some principles of its work.  What exactly is hidden from us behind the outer layer of Flux and Mono? </p><br><div class="spoiler">  <b class="spoiler_title">Reminder</b> <div class="spoiler_text"><p>  Flux and Mono implement the Publisher interface. </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>;</code> </pre> </div></div><br><p>  Official documentation suggests comparing Reactor with a <strong>pipeline</strong> .  Publisher gives some data (materials).  The data goes through the chain of operators (conveyor belt), processed, in the end it turns out the finished product, which is transferred to the desired <strong>Consumer / Subscriber</strong> and used there. </p><br><p>  How do Reactor operators work? <del>  The recipe is averaged, because there are lots of variations. </del>  We will try to give a <strong>rough</strong> description. </p><br><p>  Each operator has some <del>  tactics </del>  implementation as an object.  Calling the operator for Flux / Mono returns an object that implements this operator.  For example, a call to <strong>flatMap ()</strong> will return an object of type <strong>FluxFlatMap</strong> (a successor of Flux). </p><br><p>  Those.  the operator is the Publisher, which, in addition to some of its logic, contains a link to the source Publisher to which it is applied.  Operator calls create a chain from Publisher. </p><br><p>  When <strong>subscribing ()</strong> is called, the original Subscriber is created, it is passed back through our chain of <em>publishers</em> , each Publisher can wrap Subscriber into another Subscriber, thus creating another chain, which is passed to the original Publisher for execution. </p><br><p>  It is logical that all this bears some kind of overhead, so it is recommended to refrain from writing normal (synchronous) code via Flux or Mono. </p><br><h3 id="schedulers--planirovschiki">  Schedulers |  Planners </h3><br><p>  Reactor does not care about the execution model of your program, but it kindly provides the tools necessary to control the execution.  Developer <del>  samurai </del>  free to choose <del>  your fate </del>  performance model. </p><br><p>  The execution model and its details are determined by the implementation of the Scheduler interface (ie, the scheduler).  There are static methods for a number of occasions that allow you to specify the execution context: </p><br><ul><li>  <strong>Schedulers.immediate ()</strong> .  Execution will occur in the current thread; </li><li>  <strong>Schedulers.single ()</strong> .  Execution in a dedicated thread.  <strong>Caution!</strong>  It is indeed single, the call will not create a new scheduler / thread, but return the cached value.  To create a dedicated stream / scheduler for each call, use Schedulers.newSingle (); </li><li>  <strong>Schedulers.elastic ()</strong> .  Already mentioned in the last article.  Tasks are written off by workers (hard workers, ‚Äúworkers‚Äù), which he himself creates.  In the case of idle (inactivity) worker nailed.  ExecutorService serves as a worker.  Used for blocking tasks, such as I / O.  The default is unbounded, if you need a limit on the number of workers - use Schedulers.newElastic (); </li><li>  <strong>Schedulers.parallel ()</strong> .  N workers optimized for parallel work.  By default, N = number of available cores, i.e.  Runtime.getRuntime (). AvailableProcessors ().  <strong>Caution!</strong>  <a href="https://bugs.openjdk.java.net/browse/JDK-8140793">Inside the Docker, this method can blatantly lie to you.</a> </li></ul><br><p>  It is worth noting that the boxed Schedulers.single () and Schedulers.parallel () throw an IllegalStateException when trying to run a blocking operator in them: <strong>block (), blockLast (), toIterable (), toStream ()</strong> .  This innovation appeared in release <strong>3.1.6.</strong> </p><br><p>  If you still want to engage in such perversions - use <strong>Shchedulers.newSingle ()</strong> and <strong>Schedulers.newParallel ()</strong> .  But the best practice for blocking operators is to use Schedulers.elastic () or Schedulers.newElastic (). </p><br><p>  Scheduler instances can also be initialized from ExecutorService using <strong>Schedulers.fromExecutorService ()</strong> .  From the Executor is also possible, but not recommended. </p><br><p>  Some operators from Flux and Mono run immediately on a specific Scheduler (but you can transfer your own).  For example, the familiar <strong>Flux.interval ()</strong> by default runs on Schedulers.parallel (). </p><br><pre> <code class="java hljs">Flux.interval(Duration.ofMillis(<span class="hljs-number"><span class="hljs-number">300</span></span>), Schedulers.newSingle(<span class="hljs-string"><span class="hljs-string">"test"</span></span>))</code> </pre> <br><h3 id="kontekst-ispolneniya">  Execution context </h3><br><p>  How to change the execution context?  We need to resort to one of the already familiar to us operators: </p><br><ul><li>  <strong>publishOn ()</strong> ; </li><li>  <strong>subscribeOn ()</strong> . </li></ul><br><p>  They both take a Scheduler as an argument and allow you to change the execution context to the specified Scheduler. <br>  But why are there two of them and what is the difference? </p><br><p>  In the case of <strong>publishOn,</strong> this operator is applied just like any other, in the middle of a call chain.  All subsequent Subscriber will be executed in the context of the specified Scheduler. </p><br><p>  In the case of <strong>subscribeOn</strong> , the global operator is triggered immediately to the whole Subscriber chain.  After the call to subscribe (), the execution context will be the specified Scheduler.  Next, the context can be changed using the publishOn operator.  Subsequent calls to subscribeOn are ignored. </p><br><p>  <a href="https://stackoverflow.com/questions/41939335/using-both-publishon-and-subscribeon-on-a-flux-results-in-nothing-happening">Thanks to stackoverflow for an example.</a>  View Code </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//this is where subscription triggers data production //this is influenced by subscribeOn .doOnNext(v -&gt; System.out.println("before publishOn: " + Thread.currentThread().getName())) .publishOn(Schedulers.elastic()) //the rest is influenced by publishOn .doOnNext(v -&gt; System.out.println("after publishOn: " + Thread.currentThread().getName())) .subscribeOn(Schedulers.parallel()) .subscribe(v -&gt; System.out.println("received " + v + " on " + Thread.currentThread().getName())); Thread.sleep(5000);</span></span></code> </pre> <br><p>  will output the following result: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> publishOn: parallel<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> publishOn: parallel<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> publishOn: elastic<span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> publishOn: parallel<span class="hljs-number"><span class="hljs-number">-1</span></span> received a <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> elastic<span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> publishOn: elastic<span class="hljs-number"><span class="hljs-number">-2</span></span> received b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> elastic<span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> publishOn: elastic<span class="hljs-number"><span class="hljs-number">-2</span></span> received c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> elastic<span class="hljs-number"><span class="hljs-number">-2</span></span></code> </pre> <br><h3 id="obrabotka-oshibok">  Error processing </h3><br><p>  In Reactor, exceptions are interpreted as the <strong>terminal event</strong> (terminal event). <br>  If an exception has occurred somewhere, then something went wrong, our pipeline stops, and the error is thrown before the final Subscriber and its <strong>onError</strong> method. </p><br><p><img src="https://habrastorage.org/webt/kv/42/wc/kv42wclviavfbpnx3mutx_g57ku.png" alt="Favorite picture"></p><br><p>  Why is that?  Reactor is not aware of the seriousness of the exception and has no idea what to do with it.  Such situations should somehow be handled at the application level.  Subscriber has an excellent onError () method for this.  Reactor forces us to redefine it and somehow react to the exception, otherwise we will get <strong>UnsupportedOperationException</strong> on errors. </p><br><div class="spoiler">  <b class="spoiler_title">Refinement</b> <div class="spoiler_text"><p>  To be honest, he throws out a successor to UnsupportedOperationException - <strong>ErrorCallbackNotImplemented</strong> .  To understand that this is really him, there is the auxiliary static method <strong>Errors.errorCallbackNotImplemented (Throwable t)</strong> . </p></div></div><br><h3 id="filosofiya-trycatch">  Try / catch philosophy </h3><br><p>  What is usually done inside a <strong>catch</strong> block in Java?  Well, apart from all your favorite empty <strong>catch</strong> blocks. </p><br><ol><li>  <strong>Static Fallback Value.</strong>  Return some static default value: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromRemoteAndUnstableSource(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEFAULT_VALUE; }</code> </pre> </li><li><p>  <strong>Fallback Method.</strong>  Calling an alternative method in case of an error: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromRemoteAndUnstableSource(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadValueFromCache(); }</code> </pre> <br></li><li><p>  <strong>Dynamic Fallback Value.</strong>  Return some dynamic value depending on the exception: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromRemoteAndUnstableSource(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TimeoutException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadValueFromCache(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEFAULT_VALUE; }</code> </pre> <br></li><li><p>  <strong>Catch and Rethrow</strong> .  Wrap in some kind of domain exception and forward the exception further: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromRemoteAndUnstableSource(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BusinessException(e); }</code> </pre> <br></li><li><p>  <strong>Log or React on the Side</strong> .  Pledge an error and forward an exception further: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromRemoteAndUnstableSource(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable e) { logger.error(e.getMessage(), e); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; }</code> </pre> <br></li><li>  <strong>Using Resources and the Finally Block.</strong>  Freeing resources in a finally block or using try-with-resources. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromRemoteAndUnstableSource(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable e) { <span class="hljs-comment"><span class="hljs-comment">//do nothing } finally { cleanAllStuff(); }</span></span></code> </pre> </li></ol><br><p>  <em>The good news:</em> all this is in Reactor in the form of equivalent operators. </p><br><p>  <em>Less pleasant news:</em> in case of an error, your beautiful data sequence will end anyway (terminal event), despite the error-handling operator. <br>  Such operators are used rather to create a new, fallback sequence for replacing a completed one. </p><br><p>  Let's give an example: </p><br><pre> <code class="java hljs">Flux&lt;String&gt; s = Flux.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) .map(v -&gt; doSomethingDangerous(v)) .map(v -&gt; doSecondTransform(v)); s.subscribe(value -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"RECEIVED "</span></span> + value), error -&gt; System.err.println(<span class="hljs-string"><span class="hljs-string">"CAUGHT "</span></span> + error));</code> </pre> <br><p>  You can compare this with a similar try / catch block: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">11</span></span>; i++) { String v1 = doSomethingDangerous(i); String v2 = doSecondTransform(v1); System.out.println(<span class="hljs-string"><span class="hljs-string">"RECEIVED "</span></span> + v2); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { System.err.println(<span class="hljs-string"><span class="hljs-string">"CAUGHT "</span></span> + t); }</code> </pre> <br><p>  Note: <strong>for</strong> is interrupted! </p><br><p>  Another example of the completion of a sequence in case of an error: </p><br><pre> <code class="java hljs">Flux&lt;String&gt; flux = Flux.interval(Duration.ofMillis(<span class="hljs-number"><span class="hljs-number">250</span></span>)) .map(input -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"tick "</span></span> + input; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"boom"</span></span>); }) .onErrorReturn(<span class="hljs-string"><span class="hljs-string">"Uh oh"</span></span>); flux.subscribe(System.out::println); Thread.sleep(<span class="hljs-number"><span class="hljs-number">2100</span></span>);</code> </pre> <br><p>  On the screen we get: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">tick</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> tick <span class="hljs-number"><span class="hljs-number">1</span></span> tick <span class="hljs-number"><span class="hljs-number">2</span></span> Uh oh</code> </pre> <br><h3 id="realizaciya-trycatch">  Implement try / catch </h3><br><h4 id="static-fallback-value">  Static Fallback Value </h4><br><p>  Using the <strong>onErrorReturn</strong> operator: </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-number"><span class="hljs-number">10</span></span>) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::doSomethingDangerous) .onErrorReturn(<span class="hljs-string"><span class="hljs-string">"RECOVERED"</span></span>);</code> </pre> <br><p>  You can add a predicate so that the statement is not executed for all exceptions: </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-number"><span class="hljs-number">10</span></span>) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::doSomethingDangerous) .onErrorReturn(e -&gt; e.getMessage().equals(<span class="hljs-string"><span class="hljs-string">"boom10"</span></span>), <span class="hljs-string"><span class="hljs-string">"recovered10"</span></span>);</code> </pre> <br><h4 id="fallback-method">  Fallback method </h4><br><p>  Using the <strong>onErrorResume</strong> operator, </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span>) .flatMap(k -&gt; callExternalService(k)) <span class="hljs-comment"><span class="hljs-comment">//   .onErrorResume(e -&gt; getFromCache(k)); //     </span></span></code> </pre> <br><p>  You can add a predicate so that the statement is not executed for all exceptions: </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-string"><span class="hljs-string">"timeout1"</span></span>, <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span>) .flatMap(k -&gt; callExternalService(k)) .onErrorResume(TimeoutException.class, getFromCache(k)) .onErrorResume((Predicate&lt;Throwable&gt;) error -&gt; error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> UnknownKeyException, registerNewEntry(k, <span class="hljs-string"><span class="hljs-string">"DEFAULT"</span></span>));</code> </pre> <br><p>  Similarly: </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-string"><span class="hljs-string">"timeout1"</span></span>, <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span>) .flatMap(k -&gt; callExternalService(k)) .onErrorResume(error -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TimeoutException) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getFromCache(k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> UnknownKeyException) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> registerNewEntry(k, <span class="hljs-string"><span class="hljs-string">"DEFAULT"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Flux.error(error); });</code> </pre> <br><h4 id="dynamic-fallback-value">  Dynamic Fallback Value </h4><br><p>  All the same onErrorResume: </p><br><pre> <code class="java hljs">erroringFlux.onErrorResume(error -&gt; Mono.just( myWrapper.fromError(error); <span class="hljs-comment"><span class="hljs-comment">//,    ,     ));</span></span></code> </pre> <br><h4 id="catch-and-rethrow">  Catch and reethrow </h4><br><p>  You can do it in two ways.  The first is with the <strong>onErrorResume</strong> operator: </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-string"><span class="hljs-string">"timeout1"</span></span>) .flatMap(k -&gt; callExternalService(k)) .onErrorResume(original -&gt; Flux.error( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BusinessException(<span class="hljs-string"><span class="hljs-string">"oops, SLA exceeded"</span></span>, original) );</code> </pre> <br><p>  And more concisely - with the help of <strong>onErrorMap</strong> : </p><br><pre> <code class="java hljs">Flux.just(<span class="hljs-string"><span class="hljs-string">"timeout1"</span></span>) .flatMap(k -&gt; callExternalService(k)) .onErrorMap(original -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BusinessException(<span class="hljs-string"><span class="hljs-string">"oops, SLA exceeded"</span></span>, original));</code> </pre> <br><h4 id="log-or-react-on-the-side">  Log or React on the Side </h4><br><p>  You can add some side effect (metrics, logging) using the doOnError operator </p><br><pre> <code class="java hljs">LongAdder failureStat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LongAdder(); Flux&lt;String&gt; flux = Flux.just(<span class="hljs-string"><span class="hljs-string">"unknown"</span></span>) .flatMap(k -&gt; callExternalService(k)) .doOnError(e -&gt; { failureStat.increment(); log(<span class="hljs-string"><span class="hljs-string">"uh oh, falling back, service failed for key "</span></span> + k); }) .onErrorResume(e -&gt; getFromCache(k));</code> </pre> <br><h4 id="using-resources-and-the-finally-block">  Using Resources </h4><br><p>  So, how to get an analog try-with-resources or finally block?  The operator <strong>Flux.using ()</strong> comes to the <strong>rescue</strong> . </p><br><p>  First you need to familiarize yourself with the interface Disposable.  It forces us to implement the <strong>dispose ()</strong> method.  Calling this method should cancel or complete a task or sequence.  Method calls must be idempotent.  Used resources must be released. </p><br><pre> <code class="java hljs">AtomicBoolean isDisposed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicBoolean(); Disposable disposableInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Disposable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ isDisposed.set(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DISPOSABLE"</span></span>; } }; Flux&lt;String&gt; flux = Flux.using( () -&gt; disposableInstance, <span class="hljs-comment"><span class="hljs-comment">//   disposable -&gt; Flux.just(disposable.toString()), // Disposable::dispose //  );</span></span></code> </pre> <br><h3 id="povtorenie--retrying">  Repetition |  Retrying </h3><br><p>  On retry, a similar behavior is observed, the original sequence is terminated (terminate event), we re-subscribe (re-subscribing) to Flux. </p><br><p>  Let us consider an example.  Code </p><br><pre> <code class="java hljs">Flux.interval(Duration.ofMillis(<span class="hljs-number"><span class="hljs-number">250</span></span>)) .map(input -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"tick "</span></span> + input; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"boom"</span></span>); }) .elapsed() .retry(<span class="hljs-number"><span class="hljs-number">1</span></span>) .subscribe(System.out::println, System.err::println); Thread.sleep(<span class="hljs-number"><span class="hljs-number">2100</span></span>);</code> </pre> <br><p>  will lead </p><br><pre> <code class="hljs css">259,<span class="hljs-selector-tag"><span class="hljs-selector-tag">tick</span></span> 0 249,<span class="hljs-selector-tag"><span class="hljs-selector-tag">tick</span></span> 1 251,<span class="hljs-selector-tag"><span class="hljs-selector-tag">tick</span></span> 2 506,<span class="hljs-selector-tag"><span class="hljs-selector-tag">tick</span></span> 0 248,<span class="hljs-selector-tag"><span class="hljs-selector-tag">tick</span></span> 1 253,<span class="hljs-selector-tag"><span class="hljs-selector-tag">tick</span></span> 2 <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RuntimeException</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">boom</span></span></code> </pre> <br><p>  More complex retry logic is available using the <strong>retryWhen ()</strong> operator. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  I hope this small note has managed to shed light on some of the features of the Reactor. </p><br><p>  Let's sum up: </p><br><ul><li>  execution context can be manipulated using publishOn, subscribeOn and Schedulers statements; </li><li>  There are a lot of operators for exception handling. <del>  for all occasions </del>  ; </li><li>  sending a terminate signal results in the completion of the original ‚Äúsequence‚Äù; </li><li>  Dispose interface is used to release resources. </li></ul><br><p>  Thanks for attention! </p><br><p>  <a href="https://projectreactor.io/docs/core/release/reference/">Based on Reactor documentation</a> </p><br><blockquote>  It‚Äôs not a bad idea. </blockquote><p>  <a href="https://gitter.im/reactor/reactor">I am not here, but there are more worthy men, incl.</a>  <a href="https://gitter.im/reactor/reactor">and contributors / maintainers.</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/359194/">https://habr.com/ru/post/359194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../359184/index.html">AI, practical course. Comparison of deep learning software</a></li>
<li><a href="../359186/index.html">MTS will spend on the implementation of the law of Spring 60 billion rubles</a></li>
<li><a href="../359188/index.html">Intelligent Decision Support Systems - Brief Overview</a></li>
<li><a href="../359190/index.html">As our customer did not want to let go of the provider</a></li>
<li><a href="../359192/index.html">Classic JavaScript algorithms and data structures</a></li>
<li><a href="../359196/index.html">Google Tag Manager usage examples for customTask</a></li>
<li><a href="../359198/index.html">Create a calculator with units</a></li>
<li><a href="../359200/index.html">Google accused of spying on users Safari on iPhone</a></li>
<li><a href="../359204/index.html">Build projects with dapp. Part 2: JavaScript (frontend)</a></li>
<li><a href="../359206/index.html">Caution. How to use process metrics without harming process health</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>