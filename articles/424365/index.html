<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How stack trace works on ARM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! A few days ago I ran into a small problem in our project - in the gdb interrupt handler, it incorrectly deduced the stack trace for Cortex-M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How stack trace works on ARM</h1><div class="post__text post__text-html js-mediator-article">  Good day!  A few days ago I ran into a small problem in <a href="https://github.com/embox/embox">our project</a> - in the gdb interrupt handler, it incorrectly deduced the stack trace for Cortex-M.  Therefore, once again, it is useful to find out, and in what ways can we get the stack trace for ARM?  What compilation flags affect the ability to trace the stack to ARM?  How is this implemented in the Linux kernel?  According to the research I decided to write this article. <br><a name="habracut"></a><br>  Let us examine the two main stack trace methods in the Linux kernel. <br><br><h4>  Stack unwind through frames </h4><br>  Let's start with a simple approach, which can be found in the Linux kernel, but which currently has a deprecated status in GCC. <br><br>  Imagine that a program is running on a stack in RAM, and at some point we are interrupting it and want to display a call stack.  Suppose we have a pointer to the current instruction that is executed by the processor (PC), as well as the current pointer to the top of the stack (SP).  Now, in order to ‚Äújump‚Äù up the stack to the previous function, you need to understand what this function was and where we should jump to this function.  ARM uses the Link Register (LR) for this purpose, <br><blockquote>  The Link Register (LR) is register R14.  It stores the return information for subroutines, function calls, and exceptions.  On reset, the processor sets the value to 0xFFFFFFFF <br></blockquote>  Next, we need to go up the stack and load the new values ‚Äã‚Äãof the LR registers from the stack.  The structure of the stack frame for the compiler is as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs smalltalk">/* <span class="hljs-type"><span class="hljs-type">The</span></span> stack backtrace structure is as follows: fp points to here: | save code pointer | [fp] | return link value | [fp, #<span class="hljs-number"><span class="hljs-number">-4</span></span>] | return sp value | [fp, #<span class="hljs-number"><span class="hljs-number">-8</span></span>] | return fp value | [fp, #<span class="hljs-number"><span class="hljs-number">-12</span></span>] [| saved r10 value |] [| saved r9 value |] [| saved r8 value |] ... [| saved r0 value |] r0-r3 are not normally saved in a <span class="hljs-type"><span class="hljs-type">C</span></span> function. */</code> </pre> <br>  This description is taken from the gcc / gcc / config / arm / arm.h GCC header file. <br><br>  Those.  the compiler (in our case, GCC) can somehow be told that we want to do a stack trace.  And then in the prolog of each function, the compiler will prepare some auxiliary structure.  You can see that this structure contains the ‚Äúnext‚Äù value of the LR register we need, and, most importantly, the address of the next frame <code>| return fp value | [fp, #-12]</code> <code>| return fp value | [fp, #-12]</code> <br><br>  This compiler mode is specified by the -mapcs-frame option.  In the description of the option, there is a mention of ‚Äúleaf-frame-pointer for leaf functions.‚Äù Here, leaf functions are those that do not make any calls to other functions, so they can be made slightly lighter. <br><br>  It may also be asked what to do with assembly functions in this case.  In fact, nothing tricky - you need to insert special macros.  From the <a href="https://github.com/torvalds/linux/blob/6f0d349d922ba44e4348a17a78ea51b7135965b1/tools/objtool/Documentation/stack-validation.txt">tools / objtool / Documentation / stack-validation.txt</a> file in the Linux kernel: <br><blockquote>  Each callable function must be annotated as such with the ELF <br>  function type.  In asm code, this is typically done using the <br>  ENTRY / ENDPROC macros. <br></blockquote>  But the same document discusses that this is also an obvious disadvantage of this approach.  The objtool utility checks if all functions in the kernel are written in the correct format for stack tracing. <br><br>  Below is the function of unwinding the stack from the Linux kernel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CONFIG_FRAME_POINTER) &amp;&amp; !defined(CONFIG_ARM_UNWIND) int notrace unwind_frame(struct stackframe *frame) { unsigned long high, low; unsigned long fp = frame-&gt;fp; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ,    */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore the registers from the stack frame */</span></span></span><span class="hljs-meta"> frame-&gt;fp = *(unsigned long *)(fp - 12); frame-&gt;sp = *(unsigned long *)(fp - 8); frame-&gt;pc = *(unsigned long *)(fp - 4); return 0; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  But here I want to mark the line with <code>defined(CONFIG_ARM_UNWIND)</code> .  She hints that another implementation of unwind_frame is used in the Linux kernel, and we will talk about it a little later. <br><br>  The <i>-mapcs-frame</i> option is only valid for the ARM instruction set.  But it is known that ARM microcontrollers have another set of instructions - Thumb (Thumb-1 and Thumb-2, to be exact), it is used mainly for the Cortex-M series.  To enable frame generation for Thumb mode, use the <i>-mtpcs-frame</i> and <i>-mtpcs-leaf-frame</i> flags <i>.</i>  In fact, this is an analog -mapcs-frame.  Interestingly, these options currently only work for Cortex-M0 / M1.  For some time I could not figure out why it is impossible to compile the desired image for the Cortex-M3 / M4 / ....  After re-reading all the gcc options for ARM and searching the Internet, I realized that this was probably a bug.  Therefore, I got directly into the source code of the <i>arm-none-eabi-gcc</i> compiler.  After examining how the compiler generates frames for ARM, Thumb-1 and Thumb-2, I came to the conclusion that they bypassed Thumb-2, that is, at the moment frames are generated only for Thumb-1 and ARM.  After creating the <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi%3Fid%3D87400">bugs</a> , the GCC developers explained that the standard for ARM has already changed several times and these flags are very outdated, but for some reason they all still exist in the compiler.  Below is the disassembler of the function for which the frame has been generated. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ my_func2(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">00008134</span></span> &lt;my_func&gt;: <span class="hljs-number"><span class="hljs-number">8134</span></span>: b084 sub sp, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">8136</span></span>: b580 push <span class="hljs-comment"><span class="hljs-comment">{r7, lr}</span></span> <span class="hljs-number"><span class="hljs-number">8138</span></span>: aa06 add r2, sp, <span class="hljs-string"><span class="hljs-string">#24</span></span> <span class="hljs-number"><span class="hljs-number">813</span></span>a: <span class="hljs-number"><span class="hljs-number">9203</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#12</span></span>] <span class="hljs-number"><span class="hljs-number">813</span></span>c: <span class="hljs-number"><span class="hljs-number">467</span></span>a mov r2, pc <span class="hljs-number"><span class="hljs-number">813</span></span>e: <span class="hljs-number"><span class="hljs-number">9205</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#20</span></span>] <span class="hljs-number"><span class="hljs-number">8140</span></span>: <span class="hljs-number"><span class="hljs-number">465</span></span>a mov r2, fp <span class="hljs-number"><span class="hljs-number">8142</span></span>: <span class="hljs-number"><span class="hljs-number">9202</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#8</span></span>] <span class="hljs-number"><span class="hljs-number">8144</span></span>: <span class="hljs-number"><span class="hljs-number">4672</span></span> mov r2, lr <span class="hljs-number"><span class="hljs-number">8146</span></span>: <span class="hljs-number"><span class="hljs-number">9204</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#16</span></span>] <span class="hljs-number"><span class="hljs-number">8148</span></span>: aa05 add r2, sp, <span class="hljs-string"><span class="hljs-string">#20</span></span> <span class="hljs-number"><span class="hljs-number">814</span></span>a: <span class="hljs-number"><span class="hljs-number">4693</span></span> mov fp, r2 <span class="hljs-number"><span class="hljs-number">814</span></span>c: b082 sub sp, <span class="hljs-string"><span class="hljs-string">#8</span></span> <span class="hljs-number"><span class="hljs-number">814</span></span>e: af00 add r7, sp, <span class="hljs-string"><span class="hljs-string">#0</span></span></code> </pre><br>  For comparison, the disassembler of the same function for ARM instructions <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">000081f</span></span>8 &lt;my_func&gt;: <span class="hljs-number"><span class="hljs-number">81f</span></span>8: e1a0c00d mov ip, sp <span class="hljs-number"><span class="hljs-number">81f</span></span>c: e92dd800 push {fp, ip, lr, pc} <span class="hljs-number"><span class="hljs-number">8200</span></span>: e24cb004 sub fp, ip, #<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8204</span></span>: e24dd008 sub sp, sp, #<span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  At first glance it may seem that these are completely different things.  But in fact, the frames are absolutely identical, the fact is that in the Thumb mode, the push instruction allows stacking only low registers (r0 - r7) and the lr register on the stack.  For all other registers, this has to be done in two steps via the mov and str instructions, as in the example above. <br><br><h4>  Stack unwind through exceptions </h4><br>  An alternative approach is to unwind the stack, based on the ‚ÄúException Handling ABI for the ARM Architecture‚Äù <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf">standard</a> ( <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf">EHABI</a> ).  In fact, the main example of the use of this standard is the exception handling in languages ‚Äã‚Äãlike C ++.  Information prepared by the compiler for handling exceptions can also be used to trace the stack.  This mode is enabled by the option GCC <i>-fexceptions</i> (or <i>-funwind-frames</i> ). <br><br>  Let's take a closer look at how this is done.  For starters, this document (EHABI) imposes certain requirements on the compiler to generate auxiliary tables .ARM.exidx and .ARM.extab.  This is how this section .ARM.exidx is defined in the Linux kernel source.  From the <a href="">arch / arm / kernel / vmlinux.lds.h file</a> : <br><br><pre> <code class="hljs tex">/* Stack unwinding tables */ #define ARM_UNWIND_SECTIONS <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>. = ALIGN(8); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.ARM.unwind_idx : { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__start_unwind_idx = .; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>*(.ARM.exidx*) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__stop_unwind_idx = .; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span></span></code> </pre><br>  The standard ‚ÄúException Handling ABI for the ARM Architecture‚Äù defines each element of the table .ARM.exidx as the following structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_idx</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> addr_offset; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> insn; };</code> </pre> <br>  The first element is the offset from the beginning of the function, and the second element is the address in the table of instructions that need to be interpreted in a special way in order to unwind the stack further.  In other words, each element of this table is just a sequence of words and half words, which are a sequence of instructions.  The first word indicates the number of instructions that must be executed to unwind the stack to the next frame. <br><br>  The description of these instructions is given in the already mentioned EHABI standard: <br><br><img src="https://habrastorage.org/webt/x9/3d/hx/x93dhxr8vqlkj-c_wcqk-ht1_m0.png"><br><br>  Further, the main implementation of this interpreter in Linux is in the file <a href="">arch / arm / kernel / unwind.c</a> <br><br><div class="spoiler">  <b class="spoiler_title">Implement unwind_frame function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unwind_frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct stackframe *frame)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> low; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_idx</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">idx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_ctrl_block</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctrl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ARM.exidx    ,   PC */</span></span> idx = unwind_find_idx(frame-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!idx) { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Index not found %08lx\n"</span></span>, frame-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } ctrl.vrs[FP] = frame-&gt;fp; ctrl.vrs[SP] = frame-&gt;sp; ctrl.vrs[LR] = frame-&gt;lr; ctrl.vrs[PC] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx-&gt;insn == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* can't unwind */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((idx-&gt;insn &amp; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* prel31 to the unwind table */</span></span> ctrl.insn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)prel31_to_addr(&amp;idx-&gt;insn); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((idx-&gt;insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* only personality routine 0 supported in the index */</span></span> ctrl.insn = &amp;idx-&gt;insn; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Unsupported personality routine %08lx in the index at %p\n"</span></span>, idx-&gt;insn, idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } <span class="hljs-comment"><span class="hljs-comment">/*       ,    - * ,       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* check the personality routine */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) { ctrl.byte = <span class="hljs-number"><span class="hljs-number">2</span></span>; ctrl.entries = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x81000000</span></span>) { ctrl.byte = <span class="hljs-number"><span class="hljs-number">1</span></span>; ctrl.entries = <span class="hljs-number"><span class="hljs-number">1</span></span> + ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0x00ff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Unsupported personality routine %08lx at %p\n"</span></span>, *ctrl.insn, ctrl.insn); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } ctrl.check_each_pop = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ctrl.entries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ctrl.sp_high - ctrl.vrs[SP]) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctrl.vrs)) ctrl.check_each_pop = <span class="hljs-number"><span class="hljs-number">1</span></span>; urc = unwind_exec_insn(&amp;ctrl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctrl.vrs[SP] &lt; low || ctrl.vrs[SP] &gt;= ctrl.sp_high) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> frame-&gt;fp = ctrl.vrs[FP]; frame-&gt;sp = ctrl.vrs[SP]; frame-&gt;lr = ctrl.vrs[LR]; frame-&gt;pc = ctrl.vrs[PC]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> URC_OK; }</code> </pre><br></div></div><br>  This implementation of the unwind_frame function is used when the CONFIG_ARM_UNWIND option is enabled.  Comments with explanations in Russian, I inserted directly into the source text. <br><br>  Below is an example of how the table element .ARM.exidx looks like for the kernel_start function in Embox: <br><br><pre> <code class="hljs perl">$ arm-none-eabi-readelf -u build/base/bin/embox Unwind table <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'.ARM.exidx'</span></span> at offset <span class="hljs-number"><span class="hljs-number">0xaa6d4</span></span> contains <span class="hljs-number"><span class="hljs-number">2806</span></span> entries: &lt;...&gt; <span class="hljs-number"><span class="hljs-number">0x1c3c</span></span> &lt;kernel_start&gt;: @0xafe40 Compact model <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0x9b</span></span> vsp = r11 <span class="hljs-number"><span class="hljs-number">0x40</span></span> vsp = vsp - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0x84</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> {r11, r14} <span class="hljs-number"><span class="hljs-number">0xb0</span></span> finish <span class="hljs-number"><span class="hljs-number">0xb0</span></span> finish &lt;...&gt;</code> </pre><br>  But its disassembler: <br><br><pre> <code class="hljs cs"><span class="hljs-number"><span class="hljs-number">00001</span></span>c3c &lt;kernel_start&gt;: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-number"><span class="hljs-number">1</span></span>c3c: e92d4800 push {fp, lr} <span class="hljs-number"><span class="hljs-number">1</span></span>c40: e28db004 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fp, sp, <span class="hljs-meta"><span class="hljs-meta">#4 &lt;...&gt;</span></span></code> </pre><br>  Let's break down the steps.  We see the assignment <code>vps = r11</code> .  (R11 is the FP) and then <code>vps = vps - 4</code> .  This corresponds to the instruction <code>add fp, sp, #4</code> .  Next comes pop {r11, r14}, which corresponds to the instruction <code>push {fp, lr}</code> .  The last <code>finish</code> instruction reports the end of execution (to be honest, I still do not understand why there are two finish instructions). <br><br>  Now let's see how much memory a ‚Äúbuild-up‚Äù build with the <i>-funwind-frames</i> flag <br>  For the experiment, I compiled Embox for the STM32F4-Discovery platform.  Here are the results of objdump: <br><br><div class="spoiler">  <b class="spoiler_title">With the -funwind-frames flag:</b> <div class="spoiler_text"> <code>Sections: <br> Idx Name Size VMA LMA File off Algn <br> 0 .text 0005a600 08000000 08000000 00004000 2**14 <br> CONTENTS, ALLOC, LOAD, CODE <br> 1 .ARM.exidx 00003fd8 0805a600 0805a600 0005e600 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 2 .ARM.extab 000049d0 0805e5d8 0805e5d8 000625d8 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 3 .rodata 0003e380 08062fc0 08062fc0 00066fc0 2**5 <br></code> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">No flag:</b> <div class="spoiler_text"> <code>Sections: <br> Idx Name Size VMA LMA File off Algn <br> 0 .text 00058b1c 08000000 08000000 00004000 2**14 <br> CONTENTS, ALLOC, LOAD, CODE <br> 1 .ARM.exidx 00000008 08058b1c 08058b1c 0005cb1c 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 2 .rodata 0003e380 08058b40 08058b40 0005cb40 2**5 <br></code> <br></div></div><br>  It is easy to calculate that the .ARM.exidx and .ARM.extab sections take about 1/10 of the .text size.  After that, I collected a larger image - for the ARM Integrator CP based on the ARM9, and there these sections made up 1/12 of the size of the .text section.  But it is clear that this ratio may vary from project to project.  It also turned out that the size of the image that adds the -macps-frame flag is smaller than the option with exceptions (which is expected).  For example, if the size of the .text section is 600 Kb, the total size of .ARM.exidx + .ARM.extab was 50 Kb, and the size of the additional code with the -mapcs-frame flag is only 10 Kb.  But if we look above, what a large prolog has been generated for the Cortex-M1 (remember, via mov / str?), Then it becomes clear that in this case there will be almost no difference, which means for the Thumb-mode use <i>-mtpcs-frame</i> has at least some meaning. <br><br><h4>  Do you need such a stack trace now for ARM?  What are the alternatives? </h4><br>  The third approach is to trace the stack using a debugger.  It seems that many operating systems for working with FreeRTOS, NuttX microcontrollers at the moment <a href="https://www.freertos.org/FreeRTOS_Support_Forum_Archive/May_2012/freertos_dump_stack_trace_5302774.html">assume</a> exactly this tracing <a href="http://nuttx.org/doku.php%3Fid%3Dwiki:howtos:cortexm-hardfault">option</a> or offer to watch the disassembler. <br><br>  As a result, we came to the conclusion that the stack trace for arm at run time is practically never used.  This is probably a consequence of the desire to make the most effective code during operation, and debugging actions (which include stack promotion) go offline.  On the other hand, if the OS already uses C ++ code, then it is quite possible to use the trace implementation via .ARM.exidx. <br><br>  Well, yes, the problem with the incorrect stack output in the interrupt in <a href="https://github.com/embox/embox">Embox</a> , was solved very simply, it turned out to be enough to save the LR register to the stack. </div><p>Source: <a href="https://habr.com/ru/post/424365/">https://habr.com/ru/post/424365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424349/index.html">"Calendar tester" for September. Optimize tests</a></li>
<li><a href="../424353/index.html">Background: the state Internet search engine "Sputnik" and its complex history</a></li>
<li><a href="../424355/index.html">Die casting: how it works</a></li>
<li><a href="../424361/index.html">How gamification improves user experience</a></li>
<li><a href="../424363/index.html">‚ÄúIf you want to create something really cool, you have to dig deeper and know how your code works in the system, on hardware‚Äù</a></li>
<li><a href="../424367/index.html">Fight for resources, part 2: Playing with Cgroups settings</a></li>
<li><a href="../424369/index.html">My favorite file in Chromium codebase</a></li>
<li><a href="../424371/index.html">Deploying vCloud Extender</a></li>
<li><a href="../424373/index.html">Where to work in IT, release 1: Voximplant</a></li>
<li><a href="../424375/index.html">Mayku FormBox Vacuum Former Review: Let Parts Reproduce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>