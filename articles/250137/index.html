<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a view with an animated property change</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the typical tasks in developing applications for iOS is the creation of custom UI elements, including sometimes it may be necessary to animate ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a view with an animated property change</h1><div class="post__text post__text-html js-mediator-article">  One of the typical tasks in developing applications for iOS is the creation of custom UI elements, including sometimes it may be necessary to animate changes in the value of any of the properties.  The article discusses the process of creating a subclass of <i>UIView</i> , which has properties, the values ‚Äã‚Äãof which can be changed with animation.  A simple example: you must draw a circular progress with the ability to animate the change in color and values ‚Äã‚Äãranging from 0 to 1. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/lRTf4A7l_tI%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhgRGqxbEz2oFDyST6lHD8SN96FrXw" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  To create custom animations in the interfaces, the Quartz Core and Core Animation tools are used.  The main work takes place in the layer classes, but in my practice, the user interfaces are usually built from the view hierarchy, so the creation of a separate <i>UIView</i> subclass is <i>considered</i> .  For the same reason, we will use ARC.  Let's start. <br><br><h1>  Frameworks </h1><br>  First of all, you need to connect the Quartz Core framework if it is not in the project. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Layer </h1><br>  Then you need to create a layer class.  <i>Let's</i> call it <i>TSTRoundProgressLayer</i> and inherit from <i>CALayer</i> .  To interact with the outside world, he will need interfaces.  Let's make them in the manner of standard controls like <i>UIProgressView</i> : <br><br><pre><code class="hljs css">@<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> TSTRoundProgressLayer : CALayer @property (strong, nonatomic) __attribute__((NSObject)) CGColorRef progressColor; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">setProgressColor</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(CGColorRef)progressColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">animated</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(BOOL)animated</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">property</span></span> (readwrite, nonatomic) CGFloat progress; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">setProgress</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(CGFloat)progress</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">animated</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(BOOL)animated</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  It is worth paying attention to the storage of color in the property.  Core Animation can animate a color change, but only if it is a <i>CGColorRef</i> .  ARC does not initially understand how to store objects from the CG world, so you need to set additional memory management attributes. <br><br>  Possible values ‚Äã‚Äãof progress makes sense to limit.  To do this, we need to duplicate this property in the class extension (I will explain in more detail later why).  The property available outside the class will only be needed to add logic for changing values, and all work relating directly to animations will occur through its pair of extensions.  Let's call it, for example, <i>animatableProgress</i> : <br><br><pre> <code class="hljs scala"><span class="hljs-meta"><span class="hljs-meta">@interface</span></span> <span class="hljs-type"><span class="hljs-type">TSTRoundProgressLayer</span></span> () <span class="hljs-meta"><span class="hljs-meta">@property</span></span> (assign, nonatomic) <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> animatableProgress; <span class="hljs-meta"><span class="hljs-meta">@end</span></span></code> </pre><br>  To make the animation work, you need to follow a few steps: <br><br><h3>  State drawing code </h3><br><pre> <code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)drawInContext:(<span class="hljs-built_in"><span class="hljs-built_in">CGContextRef</span></span>)context { <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> lineWidth = [<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].scale; <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> rect = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rect.size.height &lt;= lineWidth || rect.size.width &lt;= lineWidth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; rect = <span class="hljs-built_in"><span class="hljs-built_in">CGRectInset</span></span>(rect, lineWidth, lineWidth); <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> radius = MIN(rect.size.height, rect.size.width)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetLineWidth</span></span>(context, lineWidth); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetStrokeColorWithColor</span></span>(context, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressColor); <span class="hljs-built_in"><span class="hljs-built_in">CGContextBeginPath</span></span>(context); <span class="hljs-built_in"><span class="hljs-built_in">CGContextAddArc</span></span>(context, <span class="hljs-built_in"><span class="hljs-built_in">CGRectGetMidX</span></span>(rect), <span class="hljs-built_in"><span class="hljs-built_in">CGRectGetMidY</span></span>(rect), radius, -M_PI_2, -M_PI_2 + M_PI*<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animatableProgress, <span class="hljs-literal"><span class="hljs-literal">NO</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGContextStrokePath</span></span>(context); }</code> </pre><br>  First of all, we restrict incorrect conditions.  Then we narrow the drawing area a little so that the lines are not cut off by the edges of the layer (the cost of drawing lines in Core Graphics).  Next, perform the calculations, setting the context and drawing directly.  I draw attention to the fact that the code uses the value of the internal property <i>animatableProgress</i> .  It is also worth noting that if the <i>progress</i> value is not assigned, it will be zero, and the code will work correctly.  In general, if black color suits as the default progress color, <i>progressColor</i> can also be empty.  However, if you want to set a different default color, you can use the <i>+ defaultValueForKey</i> method: <br><br><pre> <code class="hljs objectivec">+ (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)defaultValueForKey:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)key { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([key isEqualToString:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(progressColor))]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> blueColor].CGColor; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> defaultValueForKey:key]; }</code> </pre><br>  When it comes to field names, I always recommend that you insure the combination: <br><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>())</code> </pre><br>  So when changing the name of the field, the compiler in which case it prompts you to correct it. <br>  The important point is that the drawing code fills only a small circle on the surface of the layer, and not all the allotted space entirely, so for correct drawing it is necessary that the <i>opaque</i> property is set to <i>NO</i> , or that <i>backgroundColor has</i> an alpha different from 1. To insure You can overload the <i>isOpaue</i> getter: <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)isOpaque { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; }</code> </pre><br>  In addition, the drawing code itself in the example is written so that it is necessary to have the view <i>clearsContextBeforeDrawing == YES</i> (this is the default value). <br><br><h3>  Specifying the need to redraw when changing properties </h3><br>  To make the layer know that it needs to be redrawn when the property values ‚Äã‚Äãchange, you need to overload the <i>+ needsDisplayForKey</i> method <i>:</i> <br><br><pre> <code class="hljs objectivec">+ (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)needsDisplayForKey:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)key { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([key isEqualToString:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(progressColor))] || [key isEqualToString:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(animatableProgress))]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> needsDisplayForKey:key]; }</code> </pre><br><h3>  Dynamic properties </h3><br>  And so that when the property values ‚Äã‚Äãchange, the magic of <i>CALayer works</i> , you need to make them dynamic: <br><br><pre> <code class="hljs css">@<span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> progressColor, progress;</code> </pre><br>  How it works?  To manage animations, <i>CALayer</i> has functionality that provides work with values ‚Äã‚Äãon keys that do not have ivars and accessors implementation.  First of all, accessors are not synthesized for dynamic properties.  Thus, when the accessor is called from a dynamic property (for example, <i>-setAnimatableProgress:), the</i> selector is not recognized, and runtime mechanisms are enabled to resolve the situation.  The class <nobr><i>+ (BOOL) resolveInstanceMethod: (SEL) sel</i></nobr> method <nobr><i>works</i></nobr> , in which, if the method matches the existing dynamic property of this class, it is added with the implementation that starts the animation mechanisms. <br><br><h3>  Creating animations </h3><br>  Finally, you need to create the animation object itself, which will be added to the layer.  To do this, use the <i>-actionForKey</i> method <i>:</i> <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">CAAction</span></span>&gt;)actionForKey:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)key { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([key isEqualToString:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(progressColor))] || [key isEqualToString:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(animatableProgress))]) { <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> *animation = [<span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> animationWithKeyPath:key]; animation.duration = <span class="hljs-number"><span class="hljs-number">1</span></span>; animation.timingFunction = [<span class="hljs-built_in"><span class="hljs-built_in">CAMediaTimingFunction</span></span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.fromValue = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presentationLayer valueForKey:key]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animation; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> actionForKey:key]; }</code> </pre><br>  Here, for the desired key, you must return the corresponding animation.  In general, you need to return an object that satisfies the <i>CAAction</i> protocol, which allows the <i>"object to respond to an action launched by CALayer"</i> (free translation).  From classes iOS SDK implements it only <i>CAAnimation</i> .  The protocol description is rather vague, and, judging by the discussions, there is no particular sense to implement the protocol with your own hands.  Moreover, <i>CAAnimation</i> has enough flexibility to allow to solve the vast majority of tasks associated with animations in interfaces of ordinary applications. <br><br>  For the selected example, the simplest and high-level variant, <i>CABasicAnimation,</i> is <i>suitable</i> .  Here we just need to specify the values ‚Äã‚Äãfor which key to animate, how long to do it and where to start.  You can use more flexible types of animations and make them more fine-tuning them, depending on your needs.  So, for example, I added Ising, specifying the corresponding temporary function. <br><br>  It is worth noting that the animation is created before changing the value in the property, and begins to work after it, so the indication of the final value is omitted - at the time of creating the animation it is simply nowhere to take it.  In turn, <i>CABasicAnimation</i> uses the value by <i>keyPath</i> at the time of the start as the initial and final default, so in this case everything works correctly. <br><br>  Animations are added to the layer by calling <i>-addAnimation: forKey:.</i>  Do not confuse <i>key</i> with <i>keyPath</i> from <i>CABasicAnimation</i> , since they are not directly connected.  For example, adding an animation of the ‚Äúfoo‚Äù property can be added to the layer by the ‚Äúbar‚Äù key: <br><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> *animation = [<span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"foo"</span></span>]; [layer addAnimation:animation forKey:<span class="hljs-string"><span class="hljs-string">@"bar"</span></span>];</code> </pre><br>  When an animation itself adds a layer using <i>-actionForKey:,</i> it is added using the same key that changes (and is passed to this method).  In this case, the code for creating an animation object is written so that the <i>-actionForKey:</i> key matches its <i>keyPath</i> .  It is important that one animation can be initiated while another one is being displayed, and when adding a new animation by key, the current animation is deleted by the same key.  This means that you need to think about how to smooth out the joints when one animation replaces another. <br><br>  To display a layer on the screen, the system uses not the object whose property we animate, but its ‚Äúpresentation layer‚Äù ( <i>presentationLayer</i> ) - a copy created by the system.  From it you can get the actual values ‚Äã‚Äãof the properties being animated.  Therefore, it is used to obtain the initial value of the animation: we start a new animation from the value that was displayed on the screen at the time of its creation. <br><br>  This creates the animation object itself for the current property.  It should be noted that the behavior of the layer when changing values ‚Äã‚Äãwill be the same as when changing properties like <i>backgroundColor</i> - by default, the change is animated.  At the view level this can be changed. <br><br><h3>  External interfaces </h3><br>  The basis is, now you need to adjust the work of external interfaces: <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgressColor:(<span class="hljs-built_in"><span class="hljs-built_in">CGColorRef</span></span>)progressColor animated:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressColor = progressColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!animated) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeAnimationForKey:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(progressColor))]; } } - (<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)progress { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animatableProgress; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgress:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)progress { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animatableProgress = MAX(<span class="hljs-number"><span class="hljs-number">0</span></span>, MIN(progress, <span class="hljs-number"><span class="hljs-number">1</span></span>)); } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgress:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)progress animated:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progress = progress; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!animated) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeAnimationForKey:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(animatableProgress))]; } }</code> </pre><br>  As already mentioned, the layer adds animations for those keys that change.  Accordingly, in order to display the changes instantly, it is enough to remove the animation by key after changing the value. <br><br>  Here we see how the accessors of the external property <i>progress are used</i> to limit the range of values.  Why do we need to add the hidden pair to the extension?  If we only have the <i>progress</i> property, and we will overload <i>-setProgress:,</i> <i>CALayer</i> will not add its implementation method that starts the animation in <i>runtime</i> .  I had a naive idea to overload <i>-setValue: forKey:</i> and add a check with a change in value, but changing the values ‚Äã‚Äãbypasses this method, although it is invoked by the <i>presentationLayer</i> during the animation process.  It was thought to limit the values ‚Äã‚Äãby specifying the values ‚Äã‚Äãwhen creating the animation object, but at this point the final value is not yet known.  Thus, it remains only to duplicate the external property and use its hidden pair to work with animations, and external accessors to add logic. <br><br><h1>  View </h1><br>  Work with the layer is finished, now it needs to be wrapped in view.  To do this, add a new class with similar interfaces: <br><br><pre> <code class="hljs css">@<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> TSTRoundProgressBar : UIView @property (readwrite, nonatomic) UIColor *progressColor; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">setProgressColor</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(UIColor</span></span>*)<span class="hljs-selector-tag"><span class="hljs-selector-tag">progressColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">animated</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(BOOL)animated</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">property</span></span> (readwrite, nonatomic) CGFloat progress; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">setProgress</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(CGFloat)progress</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">animated</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:(BOOL)animated</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  We connect Quartz Core and set the class of the view class to the layer. <br><br><pre> <code class="hljs kotlin">+ (Class)layerClass { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [TSTRoundProgressLayer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">]; }</span></span></code> </pre><br>  All interfaces are needed solely to forward calls to the layer: <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> *)progressColor { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> colorWithCGColor:[(TSTRoundProgressLayer*)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer progressColor]]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgressColor:(<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> *)progressColor { [(TSTRoundProgressLayer*)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer setProgressColor:progressColor.CGColor animated:<span class="hljs-literal"><span class="hljs-literal">NO</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgressColor:(<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> *)progressColor animated:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated { [(TSTRoundProgressLayer*)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer setProgressColor:progressColor.CGColor animated:animated]; } - (<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)progress { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [(TSTRoundProgressLayer*)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer progress]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgress:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)progress { [(TSTRoundProgressLayer*)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer setProgress:progress animated:<span class="hljs-literal"><span class="hljs-literal">NO</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setProgress:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)progress animated:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated { [(TSTRoundProgressLayer*)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer setProgress:progress animated:animated]; }</code> </pre><br>  Here we bring the behavior to a view that is more familiar to the view - by default, changes in values ‚Äã‚Äãare not animated. <br><br><h1>  Using </h1><br>  Actually, the classes are ready to use.  Now you can put the view in the hierarchy and observe the behavior when changing values.  For example, you can make a controller class, in the view hierarchy of which our progress will be added.  I don‚Äôt provide details of adding view, you can do it in any convenient way.  I used storyboard.  So, we have: <br><br><pre> <code class="hljs mel">@interface ViewController () @property (weak, nonatomic) IBOutlet TSTRoundProgressBar *<span class="hljs-keyword"><span class="hljs-keyword">progressBar</span></span>; @end</code> </pre><br>  You can observe the behavior, for example, as follows: <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar.progress = <span class="hljs-number"><span class="hljs-number">0.2</span></span>; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">NSEC_PER_SEC</span></span>)), dispatch_get_main_queue(), ^{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar setProgressColor:[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> magentaColor] animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar setProgress:<span class="hljs-number"><span class="hljs-number">0.9</span></span> animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number"><span class="hljs-number">0.8</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">NSEC_PER_SEC</span></span>)), dispatch_get_main_queue(), ^{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar setProgressColor:[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> greenColor] animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar setProgress:<span class="hljs-number"><span class="hljs-number">0.4</span></span> animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number"><span class="hljs-number">1.5</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">NSEC_PER_SEC</span></span>)), dispatch_get_main_queue(), ^{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar.progressColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> redColor]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressBar.progress = <span class="hljs-number"><span class="hljs-number">0.9</span></span>; }); }); }); }</code> </pre><br>  Since the content of the view is created using drawing, it will be convenient to set <i>contentMode == UIViewContentModeRedraw</i> , so that when the <i>frame is</i> changed, the content will be <i>drawn</i> again.  This can be done in the code from the outside view or inside during initialization, or in the interface builder.  Purity code for the sake of choosing the last option <br><br>  A finished project with an example can be found <a href="https://github.com/Gimungagap/AnimatableProperties">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/250137/">https://habr.com/ru/post/250137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250123/index.html">PIC16F1503. Wheelbarrow for pumping - 1. Sound</a></li>
<li><a href="../250125/index.html">Trends 2015: 5 ways to put the API to serve the business</a></li>
<li><a href="../250127/index.html">Differentiation of information systems in the protection of personal data</a></li>
<li><a href="../250129/index.html">Use SVG (Part One)</a></li>
<li><a href="../250135/index.html">Thoughts</a></li>
<li><a href="../250141/index.html">Installing Redmine on Windows 7 as a service, with sqlite3 database</a></li>
<li><a href="../250145/index.html">Stages of birth of new functionality in the software product</a></li>
<li><a href="../250149/index.html">Patterns in AngularJS</a></li>
<li><a href="../250153/index.html">Continuous integration with unity</a></li>
<li><a href="../250155/index.html">Documenting programs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>