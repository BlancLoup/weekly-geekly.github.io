<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UIKit performance optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fact that many articles and videos from WWDC conferences are devoted to the performance of UIKit, this topic is still incomprehensible to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UIKit performance optimization</h1><div class="post__text post__text-html js-mediator-article">  Despite the fact that many articles and videos from <a href="https://developer.apple.com/wwdc/">WWDC</a> conferences are devoted to the performance of UIKit, this topic is still incomprehensible to many iOS developers.  For this reason, we decided to collect the most interesting questions and problems, which primarily depend on the speed and smoothness of the UI application. <br><br>  The first problem to pay attention to is mixing colors. <br><a name="habracut"></a><br><h4>  From the author of the translation </h4><br>  The article specifically used the original images and code.  So that everyone who has an interesting topic could understand ... and conduct experiments in the new <b>Xcode</b> and <b>Instruments</b> . <br><br><h3>  Mixing colors </h3><br>  Blending is a frame rendering operation that determines the final color of a pixel.  Each UIView (to be honest, CALayer) influences the color of the final pixel, for example, in the case of combining a set of properties such as <b>alpha</b> , <b>backgroundColor</b> , and <b>opaque of</b> all overlying views. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with the most commonly used UIView properties, such as UIView.alpha, UIView.opaque, and UIView.backgroundColor. <br><br><h3>  Opacity vs Transparency </h3><br>  <b>UIView.opaque</b> is a hint for the renderer, which allows you to view images as a completely opaque surface, thereby improving the quality of rendering.  Opacity means: ‚ÄúDraw <i>nothing under the surface</i> .‚Äù UIView.opaque allows you to skip the drawing of the lower layers of the image and thus the mixing of colors does not occur. The topmost color for the twist will be used. <br><br><h3>  Alpha </h3><br>  If the alpha value is less than 1, then the opaque value will be ignored, even if it is equal to <b>YES</b> . <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> *view = [[<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> alloc] initWithFrame:<span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(<span class="hljs-number"><span class="hljs-number">35.</span></span>f, <span class="hljs-number"><span class="hljs-number">35.</span></span>f, <span class="hljs-number"><span class="hljs-number">200.</span></span>f, <span class="hljs-number"><span class="hljs-number">200.</span></span>f)]; view.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> purpleColor]; view.alpha = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view addSubview:view]; }</code> </pre> <br>  Although the default opacity value is YES, the result is a mix of colors, since we made our image transparent by setting the Alpha value to less than 1. <br><br><h3>  How to check? </h3><br>  <b>Note:</b> <i>If you want to get accurate information about actual performance, you need to test the application on a real device, and not on a simulator.</i>  <i>The CPU of the device runs slower than the processor of your Mac device, which greatly distinguishes them.</i> <br><br>  You can find the item ‚ÄúColor Blended Layers‚Äù in the debug menu of the iOS simulator.  The debugger can show mixed image layers, where several translucent layers overlap each other.  Multiple image layers that are stacked on top of each other with blending enabled are highlighted in red, while multiple image layers that are displayed without blending are highlighted in green. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88b/caa/c99/88bcaac994220e90c584dd5a1e2b94a7.png" alt="image" width="419"></div><br>  To use the Core Animation tool, you need to connect a real device. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/700/b24/2cf/700b242cf1ec07b132326e6fa0dea160.jpg" alt="image"></div><br>  You can find 'Color Blended Layers' here. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa0/e59/762/fa0e597629d0b83185feeb7832f9f00e.jpg" alt="image"><br><br><h3>  Alpha image channel </h3><br>  The same problem occurs when we try to understand how changing the alpha channel can affect the transparency of the UIImageView (also consider the effect of the alpha property).  Let's use a category for a UIImage to get another image with a custom alpha channel: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *)imageByApplyingAlpha:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>) alpha { <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.size, <span class="hljs-literal"><span class="hljs-literal">NO</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); <span class="hljs-built_in"><span class="hljs-built_in">CGContextRef</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> area = <span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.size.width, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.size.height); <span class="hljs-built_in"><span class="hljs-built_in">CGContextScaleCTM</span></span>(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGContextTranslateCTM</span></span>(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, -area.size.height); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetBlendMode</span></span>(ctx, kCGBlendModeMultiply); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetAlpha</span></span>(ctx, alpha); <span class="hljs-built_in"><span class="hljs-built_in">CGContextDrawImage</span></span>(ctx, area, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.CGImage); <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *newImage = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsEndImageContext</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newImage; }</code> </pre><br>  Consider 4 cases: <br><br><ol><li>  UIImageView has the standard value of the alpha property (1.0) and the image does not have an alpha channel. </li><li>  UIImageView has the standard value of the alpha property (1.0) and the image has an alpha channel of 0.5. </li><li>  UIImageView has a variable value of the alpha property, but the image has no alpha channel. </li><li>  UIImageView has a variable value of the alpha property and the image has an alpha channel of 0.5. </li></ol><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *image = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageNamed:<span class="hljs-string"><span class="hljs-string">@"flower.jpg"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *imageWithAlpha = [image imageByApplyingAlpha:<span class="hljs-number"><span class="hljs-number">0.5</span></span>f]; <span class="hljs-comment"><span class="hljs-comment">//1st case [self.imageViewWithImageHasDefaulAlphaChannel setImage:image]; //The 2nd case [self.imageViewWihImageHaveCustomAlphaChannel setImage:imageWithAlpha]; //The 3d case self.imageViewHasChangedAlphaWithImageHasDefaultAlpha.alpha = 0.5f; [self.imageViewHasChangedAlphaWithImageHasDefaultAlpha setImage:image]; //The 4th case self.imageViewHasChangedAlphaWithImageHasCustomAlpha.alpha = 0.5f; [self.imageViewHasChangedAlphaWithImageHasCustomAlpha setImage:imageWithAlpha]; }</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/fc5/0a7/794fc50a7c18ec3e94cedffcee4af068.jpg" alt="image"></div><br>  Mixed image layers are displayed by the simulator.  Therefore, even when the alpha property for UIImageView has a default value of 1.0, and the image has a converted alpha channel, we will get a mixed layer. <br><br>  Apple's official documentation encourages developers to pay more attention to color mixing: <br><br>  ‚ÄúTo significantly improve the performance of your application, reduce the amount of red when mixing colors.  Using color blending often slows down scrolling. ‚Äù <br><br>  To create a transparent layer, you need to perform additional calculations.  The system must mix the top and bottom layers to determine the color and draw it. <br><br><h3>  Off-screen visualization </h3><br>  The off-screen visualization is the drawing of an image that cannot be performed using GPU hardware acceleration; instead, use a CPU. <br><br>  At a low level, it looks like this: while drawing a layer that needs off-screen rendering, the GPU stops the rendering process and transfers control to the CPU.  In turn, the CPU performs all the necessary operations (for example, it stuffs your fantasies into DrawRect :) and returns control to the GPU with the layer already drawn.  The GPU visualizes it and the drawing process continues. <br><br>  In addition, off-screen visualization requires the allocation of additional memory for the so-called backup storage.  At the same time, it is not needed for drawing layers that use hardware acceleration. <br><br><h3>  Screen visualization </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/42d/039/6e142d039997b4ada1b98a90d8c3890d.png" alt="image"></div><br><h3>  Off-screen visualization </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f86/50b/f3f/f8650bf3f25d0b724a540f136b587aea.png" alt="image"></div><br>  What effects / settings lead to off-screen rendering?  Let's look at them: <br>  custom DrawRect: (any, even if you just fill the background with color) <br><br><ul><li>  rounding radius for CALayer </li><li>  shadow for calayer </li><li>  mask for CALayer </li><li>  any custom drawing using CGContext </li></ul><br>  We can easily detect off-screen visualization using Core Animation in Instruments if we turn on the Color Offscreen-Rendered Yellow option.  Places where off-screen visualization occurs will be indicated by a yellow layer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/066/5bd/574/0665bd5747656d7b038fd197b8677e8c.jpg" alt="image"><br><br>  Consider a few cases and test the quality of work.  We will try to find the optimal solution that will improve the quality of work and, at the same time, realize your vision of good design. <br><br><h3>  Test environment: </h3><br><ul><li>  Device: iPhone 4 with iOS 7.1.1 (11D201) </li><li>  Xcode: 5.1.1 (5B1008) </li><li>  MacBook Pro 15 Retina (ME294) with OS X 10.9.3 (13D65) </li></ul><br><h3>  Rounding corners </h3><br>  Create a simple Tableview with our custom cell and add a UIImageView and UILabel to our cell.  Remember the good old days when the buttons were round?  To achieve this fantastic effect in Tableview we need to set the YES value for CALayer.cornerRadius and CALayer.masksToBounds. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> *)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)tableView cellForRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *identifier = <span class="hljs-built_in"><span class="hljs-built_in">NSStringFromClass</span></span>(CRTTableViewCell.class); CRTTableViewCell *cell = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView dequeueReusableCellWithIdentifier:identifier]; cell.imageView.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">30</span></span>; cell.imageView.layer.masksToBounds = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; cell.imageView.image = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageNamed:<span class="hljs-string"><span class="hljs-string">@"flower.jpg"</span></span>]; cell.textLabel.text = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:<span class="hljs-string"><span class="hljs-string">@"Cell:%ld"</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)indexPath.row]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/f47/b25/b88f47b25e1942e2786b974572ec3620.png" alt="image" width="419"></div><br>  Despite the fact that we have achieved the desired effect, even without Instruments, it is obvious that the performance is very far from the recommended <b>60 FPS</b> .  But we will not look into the crystal ball to find unverified numerical answers.  Instead, we'll just check the performance with <b>Instruments</b> . <br><br>  First of all, turn on the Color Offscreen-Rendered Yellow option.  Each cell of the UIImageView is covered with a yellow layer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e68/92b/52a/e6892b52a827ae53e8a414c7fab81abd.png" alt="image" width="419"></div><br>  It is also worth checking out the work with the Animation and OpenGL ES Driver in Instruments. <br><br>  Speaking of the OpenGL ES Driver tool, what does this give us?  To understand how it works, look at the GPU from the inside.  The GPU consists of two components - Renderer and Tiler.  The renderer's duty is to draw the data, although the order and composition are determined by the Tiler component.  Thus, the job of Tiler is to divide the frame into pixels and determine their visibility.  Only then the visible pixels are transferred to the renderer (i.e. <a href="https://developer.apple.com/library/prerelease/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Performance/Performance.html">the rendering process slows down</a> ). <br><br>  If the Renderer Utilization value is above ~ 50%, then this means that the animation process can be limited by the fill rate.  If Tiler Utilization is above 50%, then it means that the animation may be limited geometrically, that is, on the screen, most likely, there are too many layers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/0fa/c31/fd00fac31a0684b6fe372a456132cde1.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/238/cf8/544/238cf8544bdd7efddf0d4046250dfaaa.png" alt="image"></div><br>  Now it is clear that we must look for a different approach to achieve the desired effect and, at the same time, improve performance.  Use the category for UIImage to round the corners without using the cornerRadius properties: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImage</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YALExtension</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImage</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yal_imageWithRoundedCornersAndSize</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGSize</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeToFit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> rect = (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){<span class="hljs-number"><span class="hljs-number">0.</span></span>f, <span class="hljs-number"><span class="hljs-number">0.</span></span>f, sizeToFit}; <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span></span>(sizeToFit, <span class="hljs-literal"><span class="hljs-literal">NO</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span>.mainScreen.scale); <span class="hljs-built_in"><span class="hljs-built_in">CGContextAddPath</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>(), [<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> bezierPathWithRoundedRect:rect cornerRadius:sizeToFit.width].CGPath); <span class="hljs-built_in"><span class="hljs-built_in">CGContextClip</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>()); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> drawInRect:rect]; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *output = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsEndImageContext</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  And now we will change the dataSource implementation of the cellForRowAtIndexPath method. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> *)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)tableView cellForRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *identifier = <span class="hljs-built_in"><span class="hljs-built_in">NSStringFromClass</span></span>(CRTTableViewCell.class); CRTTableViewCell *cell = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView dequeueReusableCellWithIdentifier:identifier]; cell.myTextLabel.text = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:<span class="hljs-string"><span class="hljs-string">@"Cell:%ld"</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)indexPath.row]; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *image = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageNamed:<span class="hljs-string"><span class="hljs-string">@"flower.jpg"</span></span>]; cell.imageViewForPhoto.image = [image yal_imageWithRoundedCornersAndSize:cell.imageViewForPhoto.bounds.size]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre><br>  The drawing code is called only once, when the object is first displayed on the screen.  The object is cached by CALayer and subsequently displayed without additional drawing.  Regardless of the fact that it is slower than the methods of Core Animation, this approach allows you to convert frame-by-frame drawing one-time. <br><br>  Before we get back to the performance measurement, let's check the offscreen visualization again. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ce/79e/09b/7ce79e09b661e5e447f5e851855b8ac3.png" alt="image" width="419"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea5/84c/c91/ea584cc91c338db63b663191607e71c8.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f46/df6/727/f46df6727f85756de90b54074c03efeb.png" alt="image"></div><br>  <b>57 - 60 FPS!</b>  We managed the best way to double the performance and reduce Tiler Utilization and Renderer Utilization. <br><br><h3>  Avoid overriding the drawRect method </h3><br>  Keep in mind that the -drawRect method leads to off-screen rendering, even when you just need to fill the background with color. <br><br>  Especially if you want to make your own implementation of the method, DrawRect, for such simple operations as setting the background color instead of using the UIView BackgroundColor property. <br><br>  This approach is irrational for two reasons. <br><br>  First: system UIViews can implement their own drawing methods to display their contents, and it is obvious that Apple is trying to optimize these processes.  In addition, we need to remember about backup storage ‚Äî a new backup image, with pixel sizes equal to the image size multiplied by the contentsScale to be cached, until the next image update. <br><br>  Secondly, if we avoid abuse of the method - DrawRect, we do not need to allocate additional memory for backup storage and reset it every time we perform a new rendering cycle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e0/ca0/144/8e0ca014465a2a48f3ca82c54636447c.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/7d3/d12/c577d3d125c5140025ba5b7f3fbe5445.png" alt="image"></div><br><h3>  CALayer.shouldRasterize </h3><br>  Another way to speed performance for offscreen rendering is to use the CALayer.shouldRasterize property.  The layer is rendered once and cached, until the moment when you need to draw the layer again. <br><br>  However, despite the potential performance improvement, if a layer needs to be redrawn too often, the additional caching costs make it useless, because the system will rasterize the layer after each drawing. <br>  In the end, the use of CALayer.shouldRasterize depends on the specific use case and Instruments. <br><br><h3>  Shadows &amp; shadowPath </h3><br>  With the help of shadows it is possible to make the user interface more beautiful.  In iOS, it's very easy to add a shadow effect: <br><br><pre> <code class="objectivec hljs">cell.imageView.layer.shadowRadius = <span class="hljs-number"><span class="hljs-number">30</span></span>; cell.imageView.layer.shadowOpacity = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f;</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe7/8d1/35a/fe78d135a883d8e8e57f7329306bee23.png" alt="image" width="419"></div><br>  With the ‚ÄúOffscreen Rendering‚Äù enabled, we can see that the shadow adds off-screen rendering because of which CoreAnimation calculates shadow rendering in real time, which reduces <b>FPS</b> . <br><br><h4>  What does Apple say? </h4><br>  ‚ÄúAllowing Core Animation to determine the shape of the shadow can affect the performance of your application.  Instead, determine the shape of the shadow using the shadowPath property for CALayer.  When using shadowPath, Core Animation uses the specified form to draw and cache the shadow effect.  For layers whose state does not change or changes rarely, this significantly improves performance by reducing the number of visualizations performed by Core Animation. " <br><br>  Therefore, we must provide shadow caching (CGPath) for CoreAnimation, which is fairly easy to do: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> *shadowPath = [<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> bezierPathWithRect:cell.imageView.bounds]; [cell.imageView.layer setShadowPath:shadowPath.CGPath];</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/d86/b37/849d86b3772384111468ffaa057b8976.png" width="419" alt="image"></div><br>  With one line of code, we avoided off-screen visualization and greatly improved performance. <br><br>  So, as you can see, many problems related to the performance of the UI can be solved quite easily.  One small note - do not forget to measure the performance before and after optimization :) <br><br><h3>  Useful links and resources </h3><br>  <a href="https://developer.apple.com/videos/wwdc/2011/">WWDC 2011 Video: Understanding UIKit rendering</a> <br>  <a href="https://developer.apple.com/videos/wwdc/2012/">WWDC 2012 Video: iOS App performance: Graphics and Animations</a> <br>  Book: <a href="https://itunes.apple.com/us/book/ios-core-animation/id687319118%3Fmt%3D11">iOS Core animation.</a>  <a href="https://itunes.apple.com/us/book/ios-core-animation/id687319118%3Fmt%3D11">Advanced Techniques</a> by Nick Lockwood <br>  iOS image caching.  <a href="http://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/%2520">Libraries benchmark</a> <br>  <a href="https://developer.apple.com/videos/wwdc/2014/">WWDC 2014 Video: Advanced Graphics and Animations for iOS Apps</a> </div><p>Source: <a href="https://habr.com/ru/post/345178/">https://habr.com/ru/post/345178/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345166/index.html">Diagnose and understand the behavior of your application's GPU using GAPID</a></li>
<li><a href="../345168/index.html">How to compromise the workflow system in a few clicks</a></li>
<li><a href="../345172/index.html">Headache from RecyclerView.Adapter - there is a way out</a></li>
<li><a href="../345174/index.html">How I leaked $ 1000 to the promotion of the game and what came out of it</a></li>
<li><a href="../345176/index.html">DataTalks # 8: User Study</a></li>
<li><a href="../345180/index.html">Helping food delivery: logo redesign and corporate identity development</a></li>
<li><a href="../345184/index.html">REST is a new SOAP</a></li>
<li><a href="../345186/index.html">Render clouds on mobile devices</a></li>
<li><a href="../345188/index.html">Today is the day of thick polar fox retail - the error of cash registers Shtrikh-M across the country</a></li>
<li><a href="../345190/index.html">We generate fake news headlines in the style of Tapy.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>