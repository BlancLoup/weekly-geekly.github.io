<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about sorting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous topic, about the assessment of the complexity of the algorithms was very positively evaluated by the habrasoobschestvom. From this I can ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about sorting</h1><div class="post__text post__text-html js-mediator-article">  The previous topic, about the assessment of the complexity of the algorithms was very positively evaluated by the habrasoobschestvom.  From this I can conclude that the topic of the basic algorithms is very interesting.  Today I want to introduce you to the part dedicated to sorting algorithms.  It‚Äôs not serious to write about basic algorithms for Habr, but it‚Äôs still worth telling about Shell sorting, pyramid and fast.  (If anyone is interested in reading about the basic methods, you are welcome <a href="http://gorkoff.ru/%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D1%258B/%25D0%25BE%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B2%25D1%258B-%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B8-%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D0%25BE%25D0%25B2/">here</a> ) <br><a name="habracut"></a><h4>  Efficient sorting methods </h4><br><h5>  Sort inserts with decreasing distance (Shell sort) </h5><br>  In 1959, Shell proposed a way to speed up sorting with simple inserts.  First, each group of elements separated by k <sub>1</sub> elements from each other is sorted separately.  This process is called k <sub>1</sub> sorting.  After the first pass, groups of elements are considered, but already separated from each other by k <sub>2</sub> (k <sub>2</sub> &lt;k <sub>1</sub> ) positions, and these groups are also sorted separately.  This process is called k <sub>2</sub> sorting.  So several iterations are carried out, and at the end the sorting step becomes equal to 1. <br>  A reasonable question arises: will the cost of performing several passes, each of which sorts all the elements, exceed the potential savings?  However, each sorting of one group of elements either deals with a relatively small number of them, or the elements are already partially sorted, so relatively few permutations need to be made. <br>  Obviously, the method leads to a sorted array, and it is easy to see that at each step you need to do less work due to previous iterations (since each k <sub>i</sub> sort combines two groups sorted by the previous k <sub>i-1</sub> sort).  It is also obvious that any sequence of distances is permissible, so long as the last of them is equal to one.  It is not so obvious that the method works better if the decreasing distances are chosen to be different from the power of two. <br>  We give an algorithm for an arbitrary sequence of distances.  In total there will be T distances h <sub>1</sub> , h <sub>2</sub> , ..., h <sub>T</sub> satisfying the conditions: h <sub>T</sub> = 1, h <sub>i + 1</sub> &lt;h <sub>i</sub> . <br><blockquote><ol><li>  <font color="#000000">procedure</font> ShellSort <font color="#000066">;</font> </li><li>  <font color="#000000">const</font> </li><li>  T <font color="#000066">=</font> <font color="#0000ff">5</font> <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  i <font color="#000066">,</font> j <font color="#000066">,</font> k <font color="#000066">,</font> m <font color="#000066">:</font> <font color="#000066">longint</font> <font color="#000066">;</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">longint</font> <font color="#000066">;</font> </li><li>  h <font color="#000066">:</font> <font color="#000000">array</font> <font color="#000066">[</font> 1 <font color="#000066">..</font> 5 <font color="#000066">]</font> <font color="#000000">of</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  h <font color="#000066">[</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">31</font> <font color="#000066">;</font>  h <font color="#000066">[</font> <font color="#0000ff">2</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">15</font> <font color="#000066">;</font>  h <font color="#000066">[</font> <font color="#0000ff">3</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">7</font> <font color="#000066">;</font>  h <font color="#000066">[</font> <font color="#0000ff">2</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">3</font> <font color="#000066">;</font>  h <font color="#000066">[</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> m <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">1</font> <font color="#000000">to</font> T <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  k <font color="#000066">:</font> <font color="#000066">=</font> h <font color="#000066">[</font> m <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> k <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">-</font> k <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> <font color="#000066">(</font> j&gt; <font color="#000066">=</font> k <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> x &lt;a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  a <font color="#000066">[</font> j <font color="#000066">+</font> k <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">-</font> k <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> <font color="#000066">(</font> j&gt; <font color="#000066">=</font> k <font color="#000066">)</font> <font color="#000000">or</font> <font color="#000066">(</font> x&gt; <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">then</font> </li><li>  a <font color="#000066">[</font> j <font color="#000066">+</font> k <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> x </li><li>  <font color="#000000">else</font> </li><li>  <font color="#000000">begin</font> </li><li>  a <font color="#000066">[</font> j <font color="#000066">+</font> k <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> x <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li></ol></blockquote><br>  Analysis of this algorithm is a complex mathematical problem, which still does not have a complete solution.  At the moment it is not known which sequence of distances gives the best result, but it is known that distances should not be multiples of each other.  It is necessary that the next passage does not combine the two sequences that were not intersected before.  In fact, it is desirable that the sequences intersect as often as possible.  This is related to the following theorem: if the sequence after k <sub>i is</sub> sorted k <sub>i + 1 is</sub> sorted, then it remains k <sub>i</sub> sorted. <br>  Knut proposes to use one of the following sequences as successively decreasing (given in reverse): 1,4,13,40,121, ..., where h <sub>i-1</sub> = 3 * h <sub>i</sub> +1 or 1,3,7,15, 31, ..., where h <sub>i-1</sub> = 2 * h <sub>i</sub> +1.  In the latter case, a mathematical study shows that when sorting N elements by the Shell algorithm, the costs are proportional to N <sup>1.2</sup> .  Although it is much better than N <sup>2</sup> , we will not delve into this method, as there are even faster algorithms. <br><br><h5>  Pyramidal sorting (tournament sorting) </h5><br>  Simple selection sorting is based on re-selecting the smallest key among the N elements, then among the remaining N-1 elements, etc.  Obviously, in order to find the smallest key among the n elements, you need N-1 comparisons, among N-1 elements you need N-2 comparisons, etc.  Obviously, the sum of the first N-1 positive integers is (N <sup>2</sup> -N) / 2.  This sorting can be improved only if after each viewing more information is saved than just about one smallest element.  For example, N / 2 comparisons allow you to define a smaller key in each pair, another N / 4 comparison will give a smaller key in each pair of smaller keys already found, etc.  Consider the array 12,18,42,44,55,67,94,6.  By making n-1 comparisons, we can build a selection tree, with the smallest key at the root. <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/4d/5e/4d5ef25dd3fdfe298a99ae1e680aac57.jpg"></a> <br>  The second step is to descend along the path corresponding to the smallest key and replace it with an empty position in a leaf of the tree, or an element from another branch in intermediate nodes. <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/69/9f/699fe6ff3cc63913706d2c4a6193d250.jpg"></a> <br><br>  Now the element in the root of the tree will be the next smallest key.  Now you can remove it.  After N such steps in the tree there will not be a single node with a key, and the sorting process will be completed.  Obviously, at each of the N steps, log (N) comparisons are required, so the whole procedure requires about N * log (N) elementary operations (in addition to the N steps that are needed to build the tree).  This is a significant improvement not only in comparison with simple methods that require N <sup>2</sup> steps, but also with Shell sorting, which requires N <sup>1.2</sup> steps.  Naturally, the complexity of the elementary steps in this algorithm is higher: to save all the information from the previous step, you need to use some tree.  Now we need to find a way to efficiently organize this information. <br>  First of all, it is necessary to get rid of the need to store empty values, which, in the end, will fill the entire tree and lead to a large number of unnecessary comparisons.  Then we need to find a way to make the tree occupy N units in memory, instead of 2 * N-1, as it happens in the figures.  Both goals were achieved in the HeapSort algorithm, so named by its inventor Williams.  This algorithm is a radical improvement in conventional tournament sorting. <br>  A pyramid (heap) is a sequence of keys h <sub>L</sub> , h <sub>L + 1</sub> , ..., h <sub>R</sub> (L‚â•0), such that h <sub>i</sub> &lt;h <sub>2i + 1</sub> and h <sub>i</sub> &lt;h <sub>2i + 2</sub> , for i = L ... R / 2-1.  It turns out that any binary tree can be represented by an array, as shown in the figure (with the top of the pyramid being its smallest element). <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/dc/22/dc22f951b023951181ff28a12899807d.jpg"></a> <br>  The pyramid expansion algorithm is quite simple.  A new pyramid is obtained as follows: first, the added element x is placed on the top of the pyramid, and then sifted down, changing places with the smallest of two descendants, which, accordingly, moves up. <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/7a/a0/7aa0a99e96d81f6b4f9272881d243114.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In our example, we expand the pyramid with the number h <sub>0</sub> = 44.  First, the key 44 changes places with 6, and then with 12. As a result, we obtain the desired tree.  We formulate the sifting algorithm in terms of a pair of indices i, j corresponding to the elements that are exchanged at each sieving step. <br>  The method that we will consider was suggested by Floyd.  The basis of the method is the sift procedure (screening).  If we have an array h <sub>1</sub> ... h <sub>N</sub> , then its elements with numbers from m = N div 2 to N already form a pyramid (because these elements do not have such pairs i, j, so that j = 2 * i + 1 or j = 2 * i + 2).  These elements will form the bottom row of the pyramid.  Note that no ordering is required in the bottom row.  Then begins the process of expanding the pyramid.  And in one step only one element will be included in it, and this element will be put in its place using the sifting procedure, which we will now consider. <br><blockquote><ol><li>  <font color="#000000">procedure</font> sift <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  i <font color="#000066">,</font> j <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">longint</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> L <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">2</font> <font color="#000066">*</font> i <font color="#000066">;</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> <font color="#000066">(</font> j &lt;R <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> a <font color="#000066">[</font> j <font color="#000066">]</font> &lt;a <font color="#000066">[</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">then</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> <font color="#000066">(</font> j &lt; <font color="#000066">=</font> R <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> x &lt;a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">2</font> <font color="#000066">*</font> j <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> <font color="#000066">(</font> j &lt;R <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> a <font color="#000066">[</font> j <font color="#000066">]</font> &lt;a <font color="#000066">[</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">then</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> x <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  The process of obtaining the pyramid can be described as follows: <br><blockquote><ol><li>  L <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">(</font> N <font color="#000000">div</font> <font color="#0000ff">2</font> <font color="#000066">)</font> <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  R <font color="#000066">:</font> <font color="#000066">=</font> N <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> L&gt; <font color="#0000ff">1</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  L <font color="#000066">:</font> <font color="#000066">=</font> L <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  sift <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  The pyramid that we get is characterized by the fact that the largest (and not the smallest) key will be stored at its top.  In addition, the resulting array will not be fully ordered.  In order to achieve complete orderliness, it is necessary to carry out another N siftings and after each of them remove the next element from the top.  The question arises, where to store the elements removed from the top.  There is a rather beautiful solution to this problem: we need to take the last element of the pyramid (we will call it x), write the element from the top of the pyramid to the position freed from under x, and put the element x in the correct position with the next screening.  This process can be described as follows: <br><blockquote><ol><li>  <font color="#000000">while</font> R&gt; <font color="#0000ff">1</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> A <font color="#000066">[</font> R <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  A <font color="#000066">[</font> R <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> x <font color="#000066">;</font> </li><li>  R <font color="#000066">:</font> <font color="#000066">=</font> R <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  sift <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li></ol></blockquote><br>  Thus, the pyramidal sorting algorithm can be represented by the following code: <br><blockquote><ol><li>  <font color="#000000">procedure</font> HeapSort <font color="#000066">;</font> </li><li>  <font color="#000000">procedure</font> sift <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  i <font color="#000066">,</font> j <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li> x <font color="#000066">:</font> <font color="#000066">longint</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> L <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">2</font> <font color="#000066">*</font> i <font color="#000066">;</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> <font color="#000066">(</font> j &lt;R <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> a <font color="#000066">[</font> j <font color="#000066">]</font> &lt;a <font color="#000066">[</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">then</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> <font color="#000066">(</font> j &lt; <font color="#000066">=</font> R <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> x &lt;a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">2</font> <font color="#000066">*</font> j <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> <font color="#000066">(</font> j &lt;R <font color="#000066">)</font> <font color="#000000">and</font> <font color="#000066">(</font> a <font color="#000066">[</font> j <font color="#000066">]</font> &lt;a <font color="#000066">[</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">)</font> <font color="#000000">then</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> x <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  L <font color="#000066">,</font> R <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">longint</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  L <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">(</font> N <font color="#000000">div</font> <font color="#0000ff">2</font> <font color="#000066">)</font> <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  R <font color="#000066">:</font> <font color="#000066">=</font> N <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> L&gt; <font color="#0000ff">1</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  L <font color="#000066">:</font> <font color="#000066">=</font> L <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  sift <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> R&gt; <font color="#0000ff">1</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> <font color="#0000ff">1</font> <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> A <font color="#000066">[</font> R <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  A <font color="#000066">[</font> R <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> x <font color="#000066">;</font> </li><li>  R <font color="#000066">:</font> <font color="#000066">=</font> R <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  sift <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li></ol></blockquote><br><br>  In this algorithm, large elements are first sifted to the left, and only then they take final positions on the right side of the sorted array.  Because of this, it may seem that the effectiveness of pyramidal sorting is not very high.  Indeed, it is better to use other algorithms for sorting a small number of elements, but for large N this sorting is very effective. <br>  In the worst case, the pyramid creation phase requires N / 2 sieving steps, and at each step the elements are sifted through log (N / 2), log (N / 2 + 1), ..., log (N-1) positions.  Then the sorting phase requires n-1 screenings with no more than log (N-1), log (N-2), ..., 1 transfers.  In addition, you will need n-1 shipments in order to put elements from the top of the pyramid into place.  It turns out that even in the worst case pyramidal sorting requires N * log (N) transfers.  This property is the most important distinctive feature of this algorithm. <br>  Best performance can be expected if the items initially stand in reverse order.  Then the pyramid creation phase does not require shipments.  The average number of shipments is N / 2 * log (N), and deviations from this value are quite small. <br><br><h5>  Quick sort </h5><br>  The two previous methods were based on the principles of insertion and selection.  It is time to consider the third, based on the principle of exchange.  Bubble sorting turned out to be the worst among all three simple algorithms, but the improvement of exchange sorting gives the best known array sorting method. <br>  The construction of quick sorting is based on the fact that in order to achieve maximum efficiency, it is desirable to perform exchanges between the most distant positions.  Suppose we have N elements arranged in the reverse order.  You can sort them just for N / 2 exchanges, first exchanging the leftmost and rightmost elements, and then gradually moving inside the array on both sides.  Of course, this method will work only if the elements in the array are ordered in the reverse order.  Nevertheless, it is on this idea that the method under consideration is built. <br>  Let's try to implement such an algorithm: randomly choose any element (let's call it x).  We will scan the array on the left until we find the element a <sub>i</sub> &gt; x, and then on the right, until we find the element.  a <sub>j</sub> &lt;x Then we will exchange the two found elements and continue this process until both views meet somewhere in the middle of the array.  As a result, we obtain an array divided into two parts: the left, with keys smaller (or equal) x, and the right with keys larger (or equal) x.  We formulate the separation process as a procedure: <br><blockquote><ol><li>  <font color="#000000">procedure</font> partition <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  i <font color="#000066">,</font> j <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  w <font color="#000066">,</font> x <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> n <font color="#000066">;</font> </li><li>  <font color="#808080">// select at random x</font> </li><li>  <font color="#000000">REPEAT</font> </li><li>  <font color="#000000">while</font> a <font color="#000066">[</font> i <font color="#000066">]</font> &lt;x <font color="#000000">do</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> x &lt;a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000000">do</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> i &lt; <font color="#000066">=</font> j <font color="#000000">then</font> </li><li>  <font color="#000000">begin</font> </li><li>  w <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> w <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">UNTIL</font> i&gt; j <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li></ol></blockquote><br>  Now, remember that our goal is not just to divide the array, but also to sort it.  In fact, there is only one small step from separation to sorting: after dividing the array, you need to apply the same process to both the resulting parts, then to the parts of the parts, etc., until each part consists of one element. <br><blockquote><ol><li>  <font color="#000000">procedure</font> sort <font color="#000066">(</font> L <font color="#000066">,</font> R <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  i <font color="#000066">,</font> j <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  w <font color="#000066">,</font> x <font color="#000066">:</font> <font color="#000066">longint</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> L <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> R <font color="#000066">;</font> </li><li>  x <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> <font color="#000066">(</font> L <font color="#000066">+</font> R <font color="#000066">)</font> <font color="#000000">div</font> <font color="#0000ff">2</font> <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  <font color="#000000">REPEAT</font> </li><li>  <font color="#000000">while</font> a <font color="#000066">[</font> i <font color="#000066">]</font> &lt;x <font color="#000000">do</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> x &lt;a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000000">do</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> i &lt; <font color="#000066">=</font> j <font color="#000000">then</font> </li><li>  <font color="#000000">begin</font> </li><li>  w <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> i <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">;</font> </li><li>  a <font color="#000066">[</font> j <font color="#000066">]</font> <font color="#000066">:</font> <font color="#000066">=</font> w <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  j <font color="#000066">:</font> <font color="#000066">=</font> j <font color="#000066">-</font> <font color="#0000ff">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">UNTIL</font> i&gt; j <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> L &lt;j <font color="#000000">then</font> </li><li>  sort <font color="#000066">(</font> L <font color="#000066">,</font> j <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> i &lt;R <font color="#000000">then</font> </li><li>  sort <font color="#000066">(</font> i <font color="#000066">,</font> r <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">procedure</font> QuickSort <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  sort <font color="#000066">(</font> <font color="#0000ff">1</font> <font color="#000066">,</font> n <font color="#000066">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li></ol></blockquote><br><br>  To study the efficiency of quick sorting, you must first examine the behavior of the separation process.  After selecting the separating value x, the entire array is scanned, so exactly N comparisons are performed.  If we are lucky and the median is always selected as the border (the middle element of the array), then each iteration splits the array in half, and the number of necessary passes is equal to log (N).  Then the total number of comparisons is N * log (N), and the total number of exchanges is N * log (N) / 6. <br>  Of course, one cannot expect that with a choice of median it will always be so lucky.  Strictly speaking, the probability of this is 1 / N.  But it is shown that the expected efficiency of quick sorting is worse than optimal only by a factor of 2 * ln (2). <br>  Even the quick sort algorithm has flaws.  With small N, its performance can be assessed as satisfactory, but its advantage lies in the ease of connecting a simple method for processing segments.  The worst case problem remains.  Suppose that each time the largest value in the shared segment is selected as the dividing element.  Then each step will divide a fragment of N elements into two sequences of 1 and N-1 elements, respectively.  Obviously, in the worst case, the behavior is estimated to be N <sup>2</sup> .  To avoid the worst case, it was proposed to choose the element x as the median of the three values ‚Äã‚Äãof the segment to be divided.  Such an addition does not degrade the algorithm in the general case, but will greatly improve its worst-case behavior. </div><p>Source: <a href="https://habr.com/ru/post/104697/">https://habr.com/ru/post/104697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../104681/index.html">Cd error</a></li>
<li><a href="../104683/index.html">Qt 4.7.0 Released</a></li>
<li><a href="../104686/index.html">Beautiful Django configs</a></li>
<li><a href="../104690/index.html">Creating a trial search engine on Sphinx + php</a></li>
<li><a href="../104693/index.html">Latvian information portal</a></li>
<li><a href="../104701/index.html">Phone numbers on various Internet resources</a></li>
<li><a href="../104702/index.html">Meebo updated interface</a></li>
<li><a href="../104704/index.html">Using git in flash development</a></li>
<li><a href="../104706/index.html">VMware View Client in Russian</a></li>
<li><a href="../104709/index.html">September 21, 2010 - twenty years of the Russian Fidonet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>