<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural maze generation in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note: This tutorial is written for Unity 2017.1.0 and is intended for advanced users. It is understood that you are already familiar with the programm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural maze generation in Unity</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8f/cc1/574/d8fcc1574baf6339bb9474a587ab9675.png" alt="image"></div><br><blockquote>  <em>Note:</em> This tutorial is written for Unity 2017.1.0 and is intended for advanced users.  It is understood that you are already familiar with the programming of games in Unity. </blockquote><br>  You, as a Unity-developer, probably have enough experience in creating levels manually.  But did you ever want to generate levels on the fly?  Procedural generation of meshes for floors and walls, in contrast to the simple arrangement of previously created models, provides much more flexibility and replayability of the game. <br><br>  In this tutorial you will learn the following: <br><br><ul><li>  Procedurally generate levels using the example of creating a game about running in a maze. </li><li>  Generate data mazes. </li><li>  Use maze data to build a mesh. </li></ul><br><h2>  Getting Started </h2><br>  Most algorithms (such as <a href="http://www.astrolog.org/labyrnth/algrithm.htm" rel="noopener">this</a> and <a href="http://www.jamisbuck.org/mazes/" rel="noopener">this</a> , for example) create ‚Äúideal‚Äù dense labyrinths, that is, those that have only one correct path and no loops.  They look like labyrinths published in the ‚ÄúPuzzle‚Äù newspaper sections. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/bac/e8f/3b9bace8f7a5c37fbcc5fa8d269c29a4.png"></div><br>  However, it is more pleasant to play most games when mazes are not ideal and there are loops in them.  They should be extensive and consisting of open spaces, and not from narrow winding corridors.  This is especially true for the rogue-like genre, in which procedural levels are not so much ‚Äúlabyrinths‚Äù, but rather dungeons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2b/7b6/0d4/c2b7b60d40485befed2f14359b334c7e.jpg"></div><br>  In this tutorial, we will implement one of the simplest maze algorithms described <a href="http://www.robotron2084guidebook.com/home/games/berzerk/mazegenerator/" rel="noopener">here</a> .  I chose it in order to realize the mazes in the game with minimal effort.  This simple approach works well in classic games listed by reference, so we can use it to create mazes in a game called <em>Speedy Treasure Thief</em> . <br><a name="habracut"></a><br>  In this game, each level is a new maze, in which a treasure chest is hidden.  However, you do not have much time to search for him and escape before the guards return!  At each level there is a time limit and you can play until you get caught.  Points scored depend on the amount of treasure you stole. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/ee3/b44/628ee3b4497ff3827eac10ca0947be70.png"></div><br>  First, create a new empty project in Unity. <br><br>  Download <em><a href="">project blank</a></em> , unpack it and import into new project ** proc-mazes-starter.unitypackage **.  In the draft of the project there is the following content: <br><br><ol><li>  Folder <em>Graphics</em> , which contains all the necessary graphics for the game. </li><li>  Scene <em>Scene</em> is the source scene for this tutorial containing the player and the UI. </li><li>  <em>Scripts</em> folder containing two auxiliary scripts.  We will write the rest of the scripts during the tutorial. </li></ol><br>  And this is enough to get started.  Each of these points will be discussed in more detail later. <br><br><h2>  Set the code architecture </h2><br>  Let's start by adding an empty project to the scene.  Select <em>GameObject ‚ñ∏ Create Empty</em> , name it <em>Controller,</em> and place it at (X: 0, Y: 0, Z: 0).  This object will simply be the attachment point of the scripts controlling the game. <br><br>  In the project's <em>Scripts</em> folder, create a C # script called <em>GameController</em> , then create another script and name it <em>MazeConstructor</em> .  The first script will control the game as a whole, and the second will be engaged in the generation of a maze. <br><br>  Replace all lines in <em>GameController with the</em> following code: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MazeConstructor))] <span class="hljs-comment"><span class="hljs-comment">// 1 public class GameController : MonoBehaviour { private MazeConstructor generator; void Start() { generator = GetComponent&lt;MazeConstructor&gt;(); // 2 } }</span></span></code> </pre> <br>  Briefly tell what we have just created: <br><br><ol><li>  The <code>RequireComponent</code> attribute <code>RequireComponent</code> component when this script is added to a GameObject. </li><li>  A private variable stores the reference returned by <code>GetComponent()</code> . </li></ol><br>  Add this script to the scene: drag the <em>GameController</em> script from the <em>Project</em> window to the GameObject <em>Controller</em> in the <em>Hierarchy</em> window. <br><br>  Notice that the MazeConstructor has also been added to the <em>Controller</em> ;  this happens automatically thanks to the <code>RequireComponent</code> attribute. <br><br>  Now replace everything in the <em>MazeConstructor</em> with the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MazeConstructor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 public bool showDebug; [SerializeField] private Material mazeMat1; [SerializeField] private Material mazeMat2; [SerializeField] private Material startMat; [SerializeField] private Material treasureMat; //2 public int[,] data { get; private set; } //3 void Awake() { // default to walls surrounding a single empty cell data = new int[,] { {1, 1, 1}, {1, 0, 1}, {1, 1, 1} }; } public void GenerateNewMaze(int sizeRows, int sizeCols) { // stub to fill in } }</span></span></code> </pre> <br>  This is what happens here: <br><br><ol><li>  All these fields are available to us in the <em>Inspector</em> .  <code>showDebug</code> switches the debug display, and various <em>Material</em> references are materials for the generated models.  By the way, the <code>SerializeField</code> attribute displays the field in the <em>Inspector</em> , even though the variable is <code>private</code> . </li><li>  Next comes the <code>data</code> property.  Access declarations (for example, declaring a property as <code>public</code> , but then assigning it to a <code>private set</code> ) make it read-only outside the class.  Thus, the maze data can not be changed from the outside. </li><li>  The last part of the interesting code is in <code>Awake()</code> .  The function initializes <code>data</code> with a 3 x 3 array of ones surrounding zero.  1 means a wall, and 0 means empty space, that is, the default grid looks like a room surrounded by a wall. </li></ol><br>  This is already a good foundation for the code, but until we see anything yet! <br><br>  To display the maze data and check how it looks, add the following method to the <em>MazeConstructor</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 if (!showDebug) { return; } //2 int[,] maze = data; int rMax = maze.GetUpperBound(0); int cMax = maze.GetUpperBound(1); string msg = ""; //3 for (int i = rMax; i &gt;= 0; i--) { for (int j = 0; j &lt;= cMax; j++) { if (maze[i, j] == 0) { msg += "...."; } else { msg += "=="; } } msg += "\n"; } //4 GUI.Label(new Rect(20, 20, 500, 500), msg); }</span></span></code> </pre> <br>  Consider each of the commented sections: <br><br><ol><li>  This code checks if debugging is enabled. </li><li>  Initialization of several local variables: local copy of the saved maze, maximum row and column, and row. </li><li>  Two nested loops go through the rows and columns of a two-dimensional array.  For each row / column in the array, the code will check the stored value and add "...." or "==" depending on whether the value is zero.  Also, after passing through all the columns in a row, the code adds a new row so that each row of the array starts with a new row line. </li><li>  Finally, <code>GUI.Label()</code> displays the string being created.  This project uses the new GUI system for outputting data to the player, but the old system is easier to create quick debug messages. </li></ol><br>  Don't forget to enable <em>Show Debug</em> for the MazeConstructor component.  Click <em>Play</em> , and the saved maze data (which is the default maze for now) will be displayed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/bea/12a/68bbea12a0c02dc71869f82afef9eb4b.png"></div><br>  Not a bad start!  However, the code does not yet generate the maze itself.  In the next section, I will explain how to solve this problem. <br><br><h2>  Generating Maze Data </h2><br>  Notice that in <code>MazeConstructor.GenerateNewMaze()</code> is empty;  This is a blank that we fill out later.  At the end of the <code>Start()</code> method of the <em>GameController</em> script <em>,</em> add the following line.  She will call this method stub: <br><br><pre> <code class="cs hljs"> generator.GenerateNewMaze(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>);</code> </pre> <br>  The ‚Äúmagic‚Äù numbers 13 and 15 are the parameters of the method that determine the size of the maze.  Although we are not using them yet, these size options define the number of rows and columns of the grid. <br><br>  At this stage, we can proceed to generating data for the maze.  Create a new script <em>MazeDataGenerator</em> ;  this class encapsulates data-generation logic, and will be used in the <em>MazeConstructor</em> .  Open a new script and replace everything with the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MazeDataGenerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> placementThreshold; <span class="hljs-comment"><span class="hljs-comment">// chance of empty space public MazeDataGenerator() { placementThreshold = .1f; // 1 } public int[,] FromDimensions(int sizeRows, int sizeCols) // 2 { int[,] maze = new int[sizeRows, sizeCols]; // stub to fill in return maze; } }</span></span></code> </pre> <br>  Note that this class does not inherit from MonoBehaviour.  It will not be used directly as a component, but only inside the <em>MazeConstructor</em> , therefore it is not required to have MonoBehaviour functionality. <br><br><ol><li>  <code>placementThreshold</code> will be used by the data generation algorithm to determine if the space is empty.  In the class constructor, this variable is assigned a default value, but it is made <code>public</code> so that other code can control the configuration of the generated maze. </li><li>  One of the methods (in this case, <code>FromDimensions()</code> ) is still empty and left with a blank, which we fill in later. </li></ol><br>  Next, we will add several sections of code to the <em>MazeConstructor</em> so that it can invoke the <em>stub</em> method.  First, let's add a private variable to store the data generator: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MazeDataGenerator dataGenerator;</code> </pre> <br>  Then create an instance of it in <code>Awake()</code> , saving the generator to a new variable by adding the next line at the top of the <code>Awake()</code> method. <br><br><pre> <code class="cs hljs"> dataGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MazeDataGenerator();</code> </pre> <br>  Finally, call <code>FromDimensions()</code> in <code>GenerateNewMaze()</code> , passing the size of the grid and saving the resulting data.  Find in <code>GenerateNewMaze()</code> line that says <code>// stub to fill in</code> , and replace it with the following: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sizeRows % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sizeCols % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Odd numbers work better for dungeon size."</span></span>); } data = dataGenerator.FromDimensions(sizeRows, sizeCols);</code> </pre> <br>  Here is added a warning that it is better to use odd numbers for sizes, because the generated maze will be surrounded by walls. <br><br>  Run the game to see empty maze data, but with the correct dimensions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/000/247/9c3/0002479c32b512b41a2c27d26ce050d5.png"></div><br>  Fine!  Everything is ready to save and display the maze data!  The time has come to implement the labyrinth generation algorithm inside <code>FromDimensions()</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e26/f3b/d41/e26f3bd411f8913964b8eea8736d6539.png"></div><br>  The algorithm described above bypasses every second cell in the grid (that is, not every cell!) By positioning the wall and choosing the next blocking space.  The algorithm programmed here will differ slightly from it, it also decides whether to skip space, which can lead to the appearance of open spaces in the maze.  Since the algorithm does not have to store a lot of information or know a lot about the rest of the maze, for example, about the branch points that need to be passed, the code becomes very simple. <br><br>  To implement this maze generation algorithm, add the following code to the <code>FromDimensions()</code> of <em>MazeDataGenerator by</em> replacing the line with <code>// stub to fill in</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rMax = maze.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cMax = maze.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= rMax; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= cMax; j++) { <span class="hljs-comment"><span class="hljs-comment">//1 if (i == 0 || j == 0 || i == rMax || j == cMax) { maze[i, j] = 1; } //2 else if (i % 2 == 0 &amp;&amp; j % 2 == 0) { if (Random.value &gt; placementThreshold) { //3 maze[i, j] = 1; int a = Random.value &lt; .5 ? 0 : (Random.value &lt; .5 ? -1 : 1); int b = a != 0 ? 0 : (Random.value &lt; .5 ? -1 : 1); maze[i+a, j+b] = 1; } } } }</span></span></code> </pre> <br>  As you can see, the code gets the boundaries of a 2D array, and then bypasses it: <br><br><ol><li>  For each grid cell, the code first checks to see if the current cell is out of the grid (that is, if any of the indices are on the border of the array).  If so, he puts the wall, assigning 1. </li><li>  Next, the code checks whether the coordinates are divided by 2 in order to perform actions in every <i>second</i> cell.  There is also an additional check on the <code>placementThreshold</code> value described above in order to randomly skip this cell and continue traversing the array. </li><li>  Finally, the code assigns a value of 1 to the current cell and a randomly selected neighboring cell.  The code uses several ternary operations to add an array of 0, 1, or -1 to the index, thus obtaining the index of the neighboring cell. </li></ol><br>  Display the maze data again to see what the generated maze looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fab/1b5/0bd/fab1b50bd4771cacf4caff0266e13389.png"></div><br>  Restart the game to see that the maze data is new each time.  Fine! <br><br>  The next serious task is to generate a 3D mesh from 2D maze data. <br><br><h2>  Maze Mesh Generation </h2><br>  Now, after generating all the maze data, we can build a mesh based on this data. <br><br>  Create another new <em>MazeMeshGenerator</em> script.  Just as the <em>MazeDataGenerator</em> encapsulates the maze generation logic, the <em>MazeMeshGenerator</em> will contain the mesh generation logic and be used by the <em>MazeConstructor</em> to complete this maze generation step. <br><br>  More precisely, it will <i>later</i> contain the logic for generating the mesh.  First, we simply create a textured quad for display, and then modify this code to generate the entire maze.  To do this, we need to make small changes to the Unity editor, and then go deeper into the code. <br><br>  First we need to bind the materials that will be applied to the generated mesh. <br><br>  Select the <em>Graphics</em> folder in the <em>Project</em> window, then select the <em>Hierarchy</em> Controller in the window to display its <em>Maze Constructor</em> component in the <em>Inspector</em> . <br><br>  Drag materials from the <em>Graphics</em> folder to the <em>Maze Constructor</em> material slots.  Use the <em>floor-mat</em> for Material 1 and the <em>wall-mat</em> for Material 2, and drag <em>start</em> and <em>treasure</em> to the appropriate slots. <br><br>  Since we are already working in the <em>Inspector</em> , we will also add the <em>Generated</em> tag: click on the Tag menu at the top of the <em>Inspector</em> and select <em>Add Tag</em> .  When generating meshes, we will assign them this tag to find them. <br><br>  Having made all the necessary changes in the Unity editor, open a new script and replace everything with this code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MazeMeshGenerator</span></span> { <span class="hljs-comment"><span class="hljs-comment">// generator params public float width; // how wide are hallways public float height; // how tall are hallways public MazeMeshGenerator() { width = 3.75f; height = 3.5f; } public Mesh FromData(int[,] data) { Mesh maze = new Mesh(); //1 List&lt;Vector3&gt; newVertices = new List&lt;Vector3&gt;(); List&lt;Vector2&gt; newUVs = new List&lt;Vector2&gt;(); List&lt;int&gt; newTriangles = new List&lt;int&gt;(); // corners of quad Vector3 vert1 = new Vector3(-.5f, -.5f, 0); Vector3 vert2 = new Vector3(-.5f, .5f, 0); Vector3 vert3 = new Vector3(.5f, .5f, 0); Vector3 vert4 = new Vector3(.5f, -.5f, 0); //2 newVertices.Add(vert1); newVertices.Add(vert2); newVertices.Add(vert3); newVertices.Add(vert4); //3 newUVs.Add(new Vector2(1, 0)); newUVs.Add(new Vector2(1, 1)); newUVs.Add(new Vector2(0, 1)); newUVs.Add(new Vector2(0, 0)); //4 newTriangles.Add(2); newTriangles.Add(1); newTriangles.Add(0); //5 newTriangles.Add(3); newTriangles.Add(2); newTriangles.Add(0); maze.vertices = newVertices.ToArray(); maze.uv = newUVs.ToArray(); maze.triangles = newTriangles.ToArray(); return maze; } }</span></span></code> </pre> <br>  The two fields at the top of the class, <code>width</code> and <code>height</code> , are similar to the <code>placementThreshold</code> of the <em>MazeDataGenerator</em> : these are the values ‚Äã‚Äãthat are set by default in the constructor and used by the mesh generation code. <br><br>  The main part of the interesting code is inside <code>FromData()</code> ;  this is the method that the <em>MazeConstructor</em> calls to generate a mesh.  At the moment, this code simply creates a single quadrilateral to demonstrate its work.  Soon we will expand it to a whole level. <br><br>  This illustration shows what the quad is created from: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88c/82d/af9/88c82daf92435b7f0c727acf9549006b.png"></div><br>  The code is long, but quite repetitive with slight variations: <br><br><ol><li>  A mesh consists of three lists: vertices, UV coordinates, and triangles. </li><li>  The list of vertices stores the position of each vertex ... </li><li>  The UV coordinates listed correspond to the nodes in this list ... </li><li>  And triangles are indices in the list of vertices (i.e., ‚Äúthis triangle consists of vertices 0, 1, and 2‚Äù). </li><li>  Notice that two triangles are created;  The quadrilateral consists of two triangles.  Also note that the <code>List</code> data types are used (to append to the list), but in the end <code>Mesh</code> requires <code>Arrays</code> . </li></ol><br>  <em>The MazeConstructor</em> should create an instance of the <em>MazeMeshGenerator</em> , and then call the mesh generation method.  It should also <i>display the</i> mesh, so we will add the following code snippets: <br><br>  First, add a private field to store the mesh generator. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MazeMeshGenerator meshGenerator;</code> </pre> <br>  Create its instance in <em>Awake ()</em> , saving the mesh generator in the new field by adding the following line at the top of the <em>Awake ()</em> method: <br><br><pre> <code class="cs hljs"> meshGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MazeMeshGenerator();</code> </pre> <br>  Next, add the <em>DisplayMaze ()</em> method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplayMaze</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(); go.transform.position = Vector3.zero; go.name = <span class="hljs-string"><span class="hljs-string">"Procedural Maze"</span></span>; go.tag = <span class="hljs-string"><span class="hljs-string">"Generated"</span></span>; MeshFilter mf = go.AddComponent&lt;MeshFilter&gt;(); mf.mesh = meshGenerator.FromData(data); MeshCollider mc = go.AddComponent&lt;MeshCollider&gt;(); mc.sharedMesh = mf.mesh; MeshRenderer mr = go.AddComponent&lt;MeshRenderer&gt;(); mr.materials = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Material[<span class="hljs-number"><span class="hljs-number">2</span></span>] {mazeMat1, mazeMat2}; }</code> </pre> <br>  Finally, to call <em>DisplayMaze (),</em> add the following line to the end of <em>GenerateNewMaze ()</em> : <br><br><pre> <code class="cs hljs"> DisplayMaze();</code> </pre> <br>  <code>Mesh</code> itself is just data.  It is invisible until it is assigned to an object (if more specifically, an <code>MeshFilter</code> object) in the scene.  Therefore, <code>DisplayMaze()</code> not only calls <code>MazeMeshGenerator.FromData()</code> , but also inserts this call in the middle of creating an instance of a new <code>GameObject</code> , setting the <em>Generated</em> tag, adding the <code>MeshFilter</code> and the generated mesh, adding the <code>MeshCollider</code> for collisions with the mesh, and finally adding the <code>MeshRenderer</code> and materials. <br><br>  We wrote the <code>MazeMeshGenerator</code> class and created a copy of it in the <em>MazeConstructor</em> , so click <em>Play</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/9ad/10e/81d9ad10e17965451f8c6318a6200d87.png"></div><br>  We built the textured quad completely with code!  This is an interesting and important beginning, so pause to analyze your work at this stage and understand how the code works. <br><br>  Next, we will quite refactor <code>FromData()</code> , replacing it completely with this code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] data</span></span></span><span class="hljs-function">)</span></span> { Mesh maze = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-comment"><span class="hljs-comment">//3 List&lt;Vector3&gt; newVertices = new List&lt;Vector3&gt;(); List&lt;Vector2&gt; newUVs = new List&lt;Vector2&gt;(); maze.subMeshCount = 2; List&lt;int&gt; floorTriangles = new List&lt;int&gt;(); List&lt;int&gt; wallTriangles = new List&lt;int&gt;(); int rMax = data.GetUpperBound(0); int cMax = data.GetUpperBound(1); float halfH = height * .5f; //4 for (int i = 0; i &lt;= rMax; i++) { for (int j = 0; j &lt;= cMax; j++) { if (data[i, j] != 1) { // floor AddQuad(Matrix4x4.TRS( new Vector3(j * width, 0, i * width), Quaternion.LookRotation(Vector3.up), new Vector3(width, width, 1) ), ref newVertices, ref newUVs, ref floorTriangles); // ceiling AddQuad(Matrix4x4.TRS( new Vector3(j * width, height, i * width), Quaternion.LookRotation(Vector3.down), new Vector3(width, width, 1) ), ref newVertices, ref newUVs, ref floorTriangles); // walls on sides next to blocked grid cells if (i - 1 &lt; 0 || data[i-1, j] == 1) { AddQuad(Matrix4x4.TRS( new Vector3(j * width, halfH, (i-.5f) * width), Quaternion.LookRotation(Vector3.forward), new Vector3(width, height, 1) ), ref newVertices, ref newUVs, ref wallTriangles); } if (j + 1 &gt; cMax || data[i, j+1] == 1) { AddQuad(Matrix4x4.TRS( new Vector3((j+.5f) * width, halfH, i * width), Quaternion.LookRotation(Vector3.left), new Vector3(width, height, 1) ), ref newVertices, ref newUVs, ref wallTriangles); } if (j - 1 &lt; 0 || data[i, j-1] == 1) { AddQuad(Matrix4x4.TRS( new Vector3((j-.5f) * width, halfH, i * width), Quaternion.LookRotation(Vector3.right), new Vector3(width, height, 1) ), ref newVertices, ref newUVs, ref wallTriangles); } if (i + 1 &gt; rMax || data[i+1, j] == 1) { AddQuad(Matrix4x4.TRS( new Vector3(j * width, halfH, (i+.5f) * width), Quaternion.LookRotation(Vector3.back), new Vector3(width, height, 1) ), ref newVertices, ref newUVs, ref wallTriangles); } } } } maze.vertices = newVertices.ToArray(); maze.uv = newUVs.ToArray(); maze.SetTriangles(floorTriangles.ToArray(), 0); maze.SetTriangles(wallTriangles.ToArray(), 1); //5 maze.RecalculateNormals(); return maze; } //1, 2 private void AddQuad(Matrix4x4 matrix, ref List&lt;Vector3&gt; newVertices, ref List&lt;Vector2&gt; newUVs, ref List&lt;int&gt; newTriangles) { int index = newVertices.Count; // corners before transforming Vector3 vert1 = new Vector3(-.5f, -.5f, 0); Vector3 vert2 = new Vector3(-.5f, .5f, 0); Vector3 vert3 = new Vector3(.5f, .5f, 0); Vector3 vert4 = new Vector3(.5f, -.5f, 0); newVertices.Add(matrix.MultiplyPoint3x4(vert1)); newVertices.Add(matrix.MultiplyPoint3x4(vert2)); newVertices.Add(matrix.MultiplyPoint3x4(vert3)); newVertices.Add(matrix.MultiplyPoint3x4(vert4)); newUVs.Add(new Vector2(1, 0)); newUVs.Add(new Vector2(1, 1)); newUVs.Add(new Vector2(0, 1)); newUVs.Add(new Vector2(0, 0)); newTriangles.Add(index+2); newTriangles.Add(index+1); newTriangles.Add(index); newTriangles.Add(index+3); newTriangles.Add(index+2); newTriangles.Add(index); }</span></span></code> </pre> <br>  Wow, what a <i>long</i> piece of code!  But here again almost the same thing is repeated, only some numbers change.  In particular, the code for generating the quadrangle is moved to a separate <code>AddQuad()</code> method to call it again for the floor, ceiling and walls of each grid cell. <br><br><ol><li>  The last three parameters of <code>AddQuad()</code> are the same list of vertices, UVs and triangles.  The first line of the method gets the index to start with.  When you add new quadrilaterals, the index will increase. </li><li>  However, the first parameter to <code>AddQuad()</code> is the transformation matrix, and this part can be difficult to understand.  In fact, the position / rotation / scale can be stored as a matrix, and then applied to the vertices.  This is what the <code>MultiplyPoint3x4()</code> call does.  Thus, the quad generation code can be used for floors, ceilings, walls, etc.  We only need to change the transformation matrix used! </li><li>  Let's <code>FromData()</code> back to <code>FromData()</code> .  Lists for UV vertices and triangles are created at the top.  This time we have <i>two</i> lists of triangles.  The Unity <code>Mesh</code> object can have many sub-mixes with different materials on each, that is, each list of triangles is a separate mix.  We announce two mixes so that you can assign different materials to the floor and walls. </li><li>  After that, we go through the 2D array and create quadrilaterals for the floor, ceiling and walls in each grid cell.  Each cell needs a floor and ceiling, in addition, checks are performed on neighboring cells for the need for walls.  Notice that <code>AddQuad()</code> is called several times, but each time with a different transformation matrix and different lists of triangles used for floors and walls.  Also note that the <code>width</code> and <code>height</code> are used to determine the position and size of the quadrilaterals. </li><li>  Oh, and a small addition: <code>RecalculateNormals()</code> prepares the mesh for lighting. </li></ol><br>  Click Play to see how the entire mesh is generated: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8f/cc1/574/d8fcc1574baf6339bb9474a587ab9675.png"></div><br>  Congratulations, we are done with the labyrinth generation and the main part of the programming required for <em>Speedy Treasure Thief</em> !  In the next section, we will look at the rest of the game. <br><br><h2>  Finish the game </h2><br>  We need to make in the code and other additions and changes, but first let's use what was in the draft of the project.  As I mentioned in the introduction, there are two scripts in the project, a scene with a player and a UI, as well as all the graphics for the game with a maze.  The <em>FpsMovement</em> script is just a one-script version of the character controller from <a href="https://www.amazon.com/gp/product/1617294969" rel="noopener">my book</a> , and <em>TriggerEventRouter</em> is an auxiliary code, convenient for working with game triggers. <br><br>  The player is already configured in the scene, including the <em>FpsMovement</em> component and <br>  A directional light source is attached to the camera.  In addition, skybox and ambient lighting are disabled in the <em>Lighting Settings</em> window.  Finally, in the scene there is a UI canvas with labels for points and time. <br><br>  And this is all that is in the project blank.  Now we will write the remaining code for the game. <br><br>  Let's start with the <em>MazeConstructor</em> .  To begin, add the following properties to store the dimensions and coordinates: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hallWidth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hallHeight { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startRow { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startCol { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goalRow { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goalCol { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Now you need to add new methods.  The first is <code>DisposeOldMaze()</code> ;  as the name implies, it removes the existing maze.  The code finds all objects with the <em>Generated</em> tag and destroys them. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeOldMaze</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject[] objects = GameObject.FindGameObjectsWithTag(<span class="hljs-string"><span class="hljs-string">"Generated"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameObject go <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> objects) { Destroy(go); } }</code> </pre> <br>  Next we add the <code>FindStartPosition()</code> method.  This code starts at 0.0 and goes through all the maze data until it finds an open space.  These coordinates are then saved as the starting position of the maze. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindStartPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] maze = data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rMax = maze.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cMax = maze.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= rMax; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= cMax; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maze[i, j] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { startRow = i; startCol = j; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br>  Similarly, <code>FindGoalPosition()</code> essentially does the same thing, only starts at maximum values ‚Äã‚Äãand performs a countdown.  Add this method too. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindGoalPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] maze = data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rMax = maze.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cMax = maze.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// loop top to bottom, right to left for (int i = rMax; i &gt;= 0; i--) { for (int j = cMax; j &gt;= 0; j--) { if (maze[i, j] == 0) { goalRow = i; goalCol = j; return; } } } }</span></span></code> </pre> <br>  <code>PlaceStartTrigger()</code> and <code>PlaceGoalTrigger()</code> place objects in the scene at the start and target positions.    ,   ,    <em>TriggerEventRouter</em> (  ).      ,  ,  -    .     . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceStartTrigger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TriggerEventHandler callback</span></span></span><span class="hljs-function">)</span></span> { GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube); go.transform.position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(startCol * hallWidth, <span class="hljs-number"><span class="hljs-number">.5</span></span>f, startRow * hallWidth); go.name = <span class="hljs-string"><span class="hljs-string">"Start Trigger"</span></span>; go.tag = <span class="hljs-string"><span class="hljs-string">"Generated"</span></span>; go.GetComponent&lt;BoxCollider&gt;().isTrigger = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; go.GetComponent&lt;MeshRenderer&gt;().sharedMaterial = startMat; TriggerEventRouter tc = go.AddComponent&lt;TriggerEventRouter&gt;(); tc.callback = callback; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceGoalTrigger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TriggerEventHandler callback</span></span></span><span class="hljs-function">)</span></span> { GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube); go.transform.position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(goalCol * hallWidth, <span class="hljs-number"><span class="hljs-number">.5</span></span>f, goalRow * hallWidth); go.name = <span class="hljs-string"><span class="hljs-string">"Treasure"</span></span>; go.tag = <span class="hljs-string"><span class="hljs-string">"Generated"</span></span>; go.GetComponent&lt;BoxCollider&gt;().isTrigger = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; go.GetComponent&lt;MeshRenderer&gt;().sharedMaterial = treasureMat; TriggerEventRouter tc = go.AddComponent&lt;TriggerEventRouter&gt;(); tc.callback = callback; }</code> </pre> <br> ,    <code>GenerateNewMaze()</code>  : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateNewMaze</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeRows, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sizeCols, TriggerEventHandler startCallback=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, TriggerEventHandler goalCallback=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sizeRows % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sizeCols % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Odd numbers work better for dungeon size."</span></span>); } DisposeOldMaze(); data = dataGenerator.FromDimensions(sizeRows, sizeCols); FindStartPosition(); FindGoalPosition(); <span class="hljs-comment"><span class="hljs-comment">// store values used to generate this mesh hallWidth = meshGenerator.width; hallHeight = meshGenerator.height; DisplayMaze(); PlaceStartTrigger(startCallback); PlaceGoalTrigger(goalCallback); }</span></span></code> </pre> <br>  <code>GenerateNewMaze()</code>   ,     ,   ,       . <br><br>      <em>MazeConstructor</em> ,  !  ,     .     . <br><br>      <em>GameController</em> .     : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MazeConstructor))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameController</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 [SerializeField] private FpsMovement player; [SerializeField] private Text timeLabel; [SerializeField] private Text scoreLabel; private MazeConstructor generator; //2 private DateTime startTime; private int timeLimit; private int reduceLimitBy; private int score; private bool goalReached; //3 void Start() { generator = GetComponent&lt;MazeConstructor&gt;(); StartNewGame(); } //4 private void StartNewGame() { timeLimit = 80; reduceLimitBy = 5; startTime = DateTime.Now; score = 0; scoreLabel.text = score.ToString(); StartNewMaze(); } //5 private void StartNewMaze() { generator.GenerateNewMaze(13, 15, OnStartTrigger, OnGoalTrigger); float x = generator.startCol * generator.hallWidth; float y = 1; float z = generator.startRow * generator.hallWidth; player.transform.position = new Vector3(x, y, z); goalReached = false; player.enabled = true; // restart timer timeLimit -= reduceLimitBy; startTime = DateTime.Now; } //6 void Update() { if (!player.enabled) { return; } int timeUsed = (int)(DateTime.Now - startTime).TotalSeconds; int timeLeft = timeLimit - timeUsed; if (timeLeft &gt; 0) { timeLabel.text = timeLeft.ToString(); } else { timeLabel.text = "TIME UP"; player.enabled = false; Invoke("StartNewGame", 4); } } //7 private void OnGoalTrigger(GameObject trigger, GameObject other) { Debug.Log("Goal!"); goalReached = true; score += 1; scoreLabel.text = score.ToString(); Destroy(trigger); } private void OnStartTrigger(GameObject trigger, GameObject other) { if (goalReached) { Debug.Log("Finish!"); player.enabled = false; Invoke("StartNewMaze", 4); } } }</span></span></code> </pre> <br><ol><li> ,    ‚Äî      . </li><li>          ,   ,     . </li><li> <code>MazeConstructor</code>   ,   ,   <code>Start()</code>   ,     <code>GenerateNewMaze()</code> . </li><li> <code>StartNewGame()</code>      ,      <i></i> .    ,  ,    . </li><li> <code>StartNewMaze()</code>    ,     .    ,       ,      . </li><li> <code>Update()</code> ,   ,    ,    .         . </li><li> <code>OnGoalTrigger()</code>  <code>OnStartTrigger()</code> ‚Äî    ,  <em>TriggerEventRouter</em>  <em>MazeConstructor</em> . <code>OnGoalTrigger()</code> ,    ,     . <code>OnStartTrigger()</code> ,   ,    ,       . </li></ol><br>    .      Unity.    <em>Canvas</em>   <em>Hierarchy</em>     Inspector. Canvas  ,         .  ,    ,       ( <em>Player</em> ,  <em>Time</em>  Canvas   <em>Score</em> )    Inspector.    <em>Show Debug</em> ,     Play: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/8fd/6a6/d348fd6a61e555ec74874e0f99259f54.png"></div><br>  !       ,          . <br><br><h2>   ? </h2><br>     ,     .  ,   <a href=""></a>   Unity. <br><br>        ,    <code>FromDimensions()</code> .      ;    <a href="https://www.raywenderlich.com/66062/procedural-level-generation-games-using-cellular-automaton-part-1">     </a> . <br><br>            ! </div><p>Source: <a href="https://habr.com/ru/post/353104/">https://habr.com/ru/post/353104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353090/index.html">IT asset management: how myths affect projects (Part 2)</a></li>
<li><a href="../353092/index.html">Digital events in Moscow from April 9 to 15</a></li>
<li><a href="../353094/index.html">ECO Flow in Vivado or working in netlist editing mode</a></li>
<li><a href="../353100/index.html">Explicit Proxy with authorization by AD Group + Interception Proxy with authorization by MAC</a></li>
<li><a href="../353102/index.html">Effective use of AWS spot instances</a></li>
<li><a href="../353108/index.html">Is it possible to enter the closed door, or how patches vulnerabilities</a></li>
<li><a href="../353110/index.html">Mitap Cocoaheads in Tutu.ru office</a></li>
<li><a href="../353112/index.html">Security violations of mobile applications as a result of insufficient attention of the developers</a></li>
<li><a href="../353114/index.html">Kubernetes 1.10: a review of major innovations</a></li>
<li><a href="../353116/index.html">Dagaz: Looking for talents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>