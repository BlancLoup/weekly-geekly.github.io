<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tree Tree Comparison *</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 * Actually not quite like that. When developing an information system, part of which is the various processing of design and technologica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tree Tree Comparison *</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  * Actually not quite like that.  When developing an information system, part of which is the various processing of design and technological documentation, I had a problem that can be briefly described as follows.  Today we have one composition of the product, several changes in different parts of this product come in one day and by the evening it is not clear what has changed?  Products can sometimes have more than 10,000 elements in the composition, the elements are not unique, and the reality is that the changes in composition can actively come, although the product is almost ready.  Not understanding the scope of changes makes planning difficult. <br><br>  The composition of the product can be represented as a tree graph.  Not finding a suitable way to compare two graphs, I decided to write my <s>bicycle</s> . <br><a name="habracut"></a><br><h3>  Task </h3><br>  During the day, various changes from the design system come to the accounting system.  On the data from the accounting system is built production planning.  Conditions allow you to accept all changes for the day and recalculate the product specification at night.  But, as I wrote above, it is not clear how the state of yesterday differs from the state of today. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I want to see what was left of the wood product, and what was added.  Just want to see which part or assembly replaced another part or assembly.  For example, if an intermediate node was added to a tree branch, then it would be wrong to assume that all the subordinate elements were removed from the old places and inserted into the new places.  They remained in place, but an intermediate node was inserted.  In addition, the element can "travel" up and down only within one branch of the tree, this is due to the specifics of the manufacturing process. <br><br><img src="https://habrastorage.org/web/c7a/736/ac3/c7a736ac3c5a4fe19f02cf787963aea5.png"><br><br><h3>  Training </h3><br>  The product specification is recalculated by the PL / SQL procedure inside Oracle.  Therefore, I found it logical to do my search for changes to PL / SQL. <br><br>  The table in which the product tree is stored, let's call it <code>MR_ORDER_TREE</code> , has the following form: <br><table><tbody><tr><td> <code>order_id</code> </td> <td>  Order ID on which the tree is attached </td></tr><tr><td> <code>item_id</code> </td> <td>  The element ID in the tree, together with order_id, forms the primary key and is unique within the order. </td></tr><tr><td> <code>item_ref</code> </td> <td>  ID of the element to which the selected element belongs </td></tr><tr><td> <code>kts_item_id</code> </td> <td>  ID from the directory of parts and assemblies </td></tr><tr><td> <code>item_qty</code> </td> <td>  amount </td></tr><tr><td> <code>is_item_buy</code> </td> <td>  Is the product purchased? </td></tr><tr><td> <code>item_position</code> </td> <td>  Item number in assembly </td></tr></tbody></table><br>  Bundles <code>(item_ref, kts_item_id)</code> unique.  In addition to the purchase, the position and quantity there are other attributes of a particular element, but it is not about them. <br><br>  At recalculation of the specification, the data, under the changed orders, completely are removed and are considered again.  Therefore it is necessary to preserve the state of the tree before recalculation.  For this we use a similar table <code>MR_ORDER_TREE_PREV</code> . <br><br>  The result of the comparison will be stored in the <code>MR_ORDER_TREE_COMP</code> table, which will additionally have two columns: <br><table><tbody><tr><td> <code>stat</code> </td> <td>  Column to mark the status of items: <br>  -1 - additional root element (about it below) <br>  0 - item removed <br>  1 - item added <br>  2 - item properties have changed <br>  3 - unknown condition (just in case something went wrong) <br>  4 - the item has not changed </td></tr><tr><td> <code>comm</code> </td> <td>  Comment giving additional data as </td></tr></tbody></table><br>  First, take the previous and current trees and drop them into the <code>MR_ORDER_TREE_COMP</code> table.  In this case, we add to them the common root, <code>item_id</code> at the current tree will increase by (maximum value + 1) <code>item_id</code> tree with the previous state.  All the elements of the old tree will be considered as deletion, and all the elements of the new one as an insert. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(item_id), <span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_prev t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.order_id = p_order_id; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> MR_ORDER_TREE_COMP (ORDER_ID, ITEM_ID, KTS_ITEM_ID, ITEM_QTY, IS_ITEM_BUY, IS_ADD_WORK, ITEM_POSITION, N_GROUP, T_LEVEL, STAT, COMM) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (p_order_id, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">'   '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> MR_ORDER_TREE_COMP (ORDER_ID, ITEM_ID, ITEM_REF, KTS_ITEM_ID, KTS_ITEM_REF, ITEM_QTY, IS_ITEM_BUY, IS_ADD_WORK, ITEM_POSITION, N_GROUP, STAT, COMM) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.order_id, p.item_id, nvl(p.item_ref, <span class="hljs-number"><span class="hljs-number">-1</span></span>), p.kts_item_id, p.kts_item_ref, p.item_qty, p.is_item_buy, p.is_add_work, p.item_position, p.n_group, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_prev p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.order_id = p_order_id; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> MR_ORDER_TREE_COMP (ORDER_ID, ITEM_ID, ITEM_REF, KTS_ITEM_ID, KTS_ITEM_REF, ITEM_QTY, IS_ITEM_BUY, IS_ADD_WORK, ITEM_POSITION, N_GROUP, STAT, COMM) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.order_id, p.item_id + v_id, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> p.item_ref <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> p.item_ref + v_id <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, p.kts_item_id, p.kts_item_ref, p.item_qty, p.is_item_buy, p.is_add_work, p.item_position, p.n_group, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.order_id = p_order_id;</code> </pre> <br><img src="https://habrastorage.org/web/156/9c1/4b1/1569c14b1b0c47b2af12e19a7a69723a.png"><br>  We also put down on the elements of the total tree their nesting level in order not to calculate it every time. <br><br><pre> <code class="sql hljs">for rec in (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> lev <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> order_id = p_order_id) <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">prior</span></span> item_id = item_ref <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> item_id = <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.t_level = rec.lev <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_id = rec.item_id; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>;</code> </pre> <br>  Save the state of the <code>mr_order_tree_comp</code> table for the recalculated order, this will be needed in the future.  I used the collection, but I think that a temporary table can also be applied. <br><br><pre> <code class="sql hljs"> procedure save_tree_stat(p_order in number) is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> TREE_BC_STAT_ROW(c.order_id, c.item_id, c.item_ref, c.kts_item_id, c.kts_item_ref) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> tree_before_calc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> save_tree_stat;</code> </pre> <br><h3>  "The addition of" trees </h3><br>  Now you need to go through the resulting tree through the levels and nodes in search of change.  To begin, we define the maximum level: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(t_level) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_max_lvl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> order_id = p_order_id;</code> </pre> <br>  Now in the cycle go through the levels of this tree.  At each level, also in the loop, we will select the child elements of each node, and look for the element with the ‚Äúopposite sign‚Äù.  Simply put, look for the same <code>kts_item_id</code> with the same <code>item_ref</code> , but state 1 for 0 and 0 for 1. After that, one of them should be deleted and the incoming elements should be reassigned to the remaining node. <br><br>  When an item is processed, place it on some list of processed items.  I used the following procedure: <br><br><pre> <code class="sql hljs"> procedure add_to_rdy (p_item in number, p_order in number) is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> item_ready_list.extend; item_ready_list(item_ready_list.last) := tree_rdy_list_row(p_order, p_item); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> add_to_rdy;</code> </pre> <br>  Element "Handling" returned by function <br><br><pre> <code class="sql hljs">function item_rdy(p_item in number, p_order in number) return number</code> </pre> <br>  which was browsing the same collection. <br><br>  The cycle is as follows: <br><br><pre> <code class="sql hljs">&lt;&lt;lvls&gt;&gt; for i in 1..v_max_lvl loop &lt;&lt;heads&gt;&gt; for rh in (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.t_level = i) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> &lt;&lt;leafs&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rh.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> c.stat) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item_rdy(rl.item_id, rl.order_id) = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rl.stat = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rh.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.kts_item_id = rl.kts_item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">1</span></span>; case when (v_cnt = 1) then <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.item_id <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_item <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rh.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.kts_item_id = rl.kts_item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.item_ref = v_item <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_ref = rl.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.order_id = p_order_id; <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_id = v_item <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.order_id = p_order_id; diff_items(p_order_id, rl.item_id, v_item); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_id = rl.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.order_id = p_order_id; add_to_rdy(rl.item_id, rl.order_id); add_to_rdy(v_item, rl.order_id); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>;</code> </pre> <br>  For <code>(rl.stat = 1)</code> logic is similar. <br><br>  When the same element was found, everything is simple - you just need to compare their properties.  To do this, use the <code>diff_items</code> function.  The situation, when more than one element is found, is more likely an exception and says that there is something wrong with the composition tree. <br><br><h3>  Search for "similar" items </h3><br>  But what to do when there was a replacement of one node by another, was the node inserted in the middle or was the node in the middle removed? <br><br>  To determine the situations described, I did not find anything smarter than just comparing the compositions of two nodes in order to determine the ratio of the number of identical <code>kts_item_id</code> to the total number of elements.  If the value of this relationship is greater than a certain value, then the nodes are interchangeable.  If at the current loop iteration the node has several replacement options, then the variant with the highest ‚Äúsimilarity coefficient‚Äù is taken. <br><br>  Perhaps with such a bold decision I will ever shoot myself in the foot. <br><br>  Add some code to the main <code>CASE</code> . <br><br><pre> <code class="sql hljs">when (v_cnt = 0) then <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rh.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(item_ready_list) a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.order_id = c.order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.item_id = c.item_id);</code> </pre> <br>  Managed to find one item in this node. <br><br><pre> <code class="sql hljs"> if (v_cnt = 1) then <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.item_id, c.kts_item_id <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_item, v_kts <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rh.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(item_ready_list) a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.order_id = c.order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.item_id = c.item_id);</code> </pre> <br>  We rehash the contents of the current node without hesitation.  Provided that both elements are assemblies.  The current item is not deleted.  Why?  If there are no identical elements in the nodes at all, then everything will be returned to their places. <br><br><pre> <code class="sql hljs"> if (is_item_comp(v_item, p_order_id) = is_item_comp(rl.item_id, p_order_id)) then <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.item_ref = v_item <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_ref = rl.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.order_id = p_order_id; add_to_rdy(rl.item_id, rl.order_id); add_to_rdy(v_item, rl.order_id); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>;</code> </pre> <br>  If you manage to find multiple items, then the most similar assembly is taken.  To define ‚Äúsimilarity‚Äù, the <code>like_degree</code> procedure is <code>like_degree</code> , the value of the coefficient for comparison is contained in the variable <code>lperc</code> . <br><br><pre> <code class="sql hljs">if (v_cnt &gt; 1) then <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, kts_item_id, max_lperc <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_item, v_kts, v_perc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.item_id, c.kts_item_id, <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(like_degree(rl.item_id, c.item_id, c.order_id)) max_lperc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rh.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(item_ready_list) a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.order_id = c.order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.item_id = c.item_id) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_item_comp(c.item_id, p_order_id) = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> is_item_comp(rl.item_id, p_order_id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> c.item_id, c.kts_item_id <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> max_lperc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; if (v_perc &gt;= lperc) then <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.item_ref = v_item <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_ref = rl.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.order_id = p_order_id; <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.comm = <span class="hljs-string"><span class="hljs-string">'.   '</span></span> || kts_pack.item_code(v_kts) || <span class="hljs-string"><span class="hljs-string">' ('</span></span> || to_char(v_perc) || <span class="hljs-string"><span class="hljs-string">'%)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_id = rl.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.order_id = p_order_id; add_to_rdy(rl.item_id, rl.order_id); add_to_rdy(v_item, rl.order_id); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>;</code> </pre> <br>  As a result, some of the elements will be re-linked, and the tree will look like this. <br><img src="https://habrastorage.org/web/bc7/a04/951/bc7a049512244614898d431a31ba38e7.png"><br>  If the additional root element that was added at the beginning is not needed, then it can be removed. <br><br>  Now you can take all the remaining elements with status 0 and 1, and starting with them go up to the root.  If the same element with ‚Äúopposite status‚Äù is found, then compare them, remove the element from the tree with 0, and change the status of the element with 1. <br><br><pre> <code class="sql hljs">&lt;&lt;items&gt;&gt; for rs in (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> &lt;&lt;branch&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id) t <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">prior</span></span> t.item_ref = t.item_id <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> t.item_id = rs.item_id) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_ref = rb.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.kts_item_id = rs.kts_item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat != rs.stat; if (v_cnt = 1) then <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.item_id <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_item <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.item_ref = rb.item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.kts_item_id = rs.kts_item_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.stat != rs.stat; if (rs.stat = 0) then <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_id = v_item; diff_items(p_order_id, rs.item_id, v_item); <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.item_ref = v_item <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = rs.item_id; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mr_order_tree_comp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> item_id = rs.item_id; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; if (rs.stat = 1) then <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.stat = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_id = rs.item_id; diff_items(p_order_id, rs.item_id, v_item); <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mr_order_tree_comp c <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> c.item_ref = rs.item_id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.item_ref = v_item; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mr_order_tree_comp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> order_id = p_order_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> item_id = v_item; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; continue items; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> branch; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> items;</code> </pre> <br>  Now let's go through the remaining items with status 0 and restore their previous <code>item_ref</code> .  To do this, use the <code>tree_before_calc</code> collection, in which the initial state of the tree <code>mr_order_tree_comp</code> . <br><br>  After that, the tree gets the desired form. <br><br><img src="https://habrastorage.org/web/6ca/cc4/068/6cacc4068d2d4cd0acad13cc1178db6a.png"><br><br>  I believe that there are more beautiful, fast and correct ways to compare trees.  This is my option and I hope that it will be useful to someone and show you how to do it or how not to do it. </div><p>Source: <a href="https://habr.com/ru/post/334384/">https://habr.com/ru/post/334384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334372/index.html">Piracy and Four Currencies: Pay What You Want and Free-to-Play</a></li>
<li><a href="../334374/index.html">Oleg Nenashev, Kirill Tolkachev and Alexander Tarasov about Groovy DSL and Pipeline in Jenkins on jug.msk.ru</a></li>
<li><a href="../334376/index.html">JetBrains MPS for those interested # 2</a></li>
<li><a href="../334378/index.html">Security Week 30: Addups again for your own, how to cache uncached in Docker containers - a dangerous load</a></li>
<li><a href="../334380/index.html">PyTorch - your new deep learning framework</a></li>
<li><a href="../334386/index.html">Postgres Pro quiz task analysis on PGDay'17</a></li>
<li><a href="../334388/index.html">Authorization form with sending an encrypted password</a></li>
<li><a href="../334390/index.html">Magento Dare to Share - Open Platform for Reports on Magento, PHP and eCommerce</a></li>
<li><a href="../334392/index.html">Putting things in order: Chrome and Firefox will end the credibility of Symantec certification center</a></li>
<li><a href="../334394/index.html">Mutation Testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>