<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>garbage.collect ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The browser needs a little memory to execute JavaScript, you need to store objects, primitives, functions that are created for all user actions somewh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>garbage.collect ()</h1><div class="post__text post__text-html js-mediator-article">  The browser needs a little memory to execute JavaScript, you need to store objects, primitives, functions that are created for all user actions somewhere.  Therefore, the browser first allocates the necessary amount of RAM, and when objects are not used, it cleans it independently. <br><br>  In theory, it sounds good.  In practice, the user opens 20 tabs from YouTube, social networks, reads something, works, the browser eats memory, like Hummer H2 - gasoline.  A garbage collector, like this monster with a mop, runs through memory and adds confusion, everything slows down and falls. <br><br><img src="https://habrastorage.org/webt/uc/vx/ke/ucvxke3xzwiqngna7opkqwllmq4.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To avoid such situations and the performance of our sites and applications did not suffer, the front-end developer should know how garbage affects applications, how the browser collects and optimizes memory management, and how this all differs from harsh reality.  Just about this report by <strong>Andrei Roenko ( <a href="https://habr.com/users/flapenguin/" class="user_link">flapenguin</a> )</strong> at <a href="http://frontendconf.ru/moscow/2018">Frontend Conf 2018</a> . <br><br>  We use the garbage collector (not at home - in front-end development) every day, but we don‚Äôt really think about what it is, what it costs us and what its capabilities and limitations are. <br><br><blockquote>  If garbage collection really worked in JavaScript, most npm modules would delete themselves immediately after installation. <br></blockquote><br>  But so far it is not so, and we will talk about what is - about the assembly of unnecessary objects. <br><br><a name="habracut"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/tDbRVZqwxn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker</strong> : <strong>Andrei Roenko is</strong> developing <a href="https://tech.yandex.ru/maps/">the Yandex.Maps API</a> , has been in the front end for six years, likes to create his own high abstractions and descend to the ground from strangers. <br><br><h2>  Why do we need garbage collection? <br></h2><br>  Consider the example of Yandex.Maps.  Yandex.Maps is a huge and complex service that uses a lot of JS and almost all existing browser APIs, except multimedia, and the average session time is 5-10 minutes.  The abundance of javascript creates many objects.  Dragging a map, adding organizations, search results and many other events that occur every second creates an avalanche of objects.  Add to this the React and objects becomes even more. <br><br>  However, JS objects occupy only 30‚Äì40 MB on the map.  For long sessions, Yandex.Maps and the constant allocation of new objects is not enough. <br><br><blockquote>  The reason for the small amount of objects is that they are successfully collected by the garbage collector and the memory is reused. <br></blockquote><br>  Today we will talk about garbage collection from four sides: <br><br><ul><li>  <strong>Theory</strong>  Let's start with her, to speak the same language and understand each other. </li><li>  <strong>Harsh reality.</strong>  Ultimately, the computer is executed machine code, which does not have all the usual abstractions to us.  Let's try to figure out how garbage collection works at a low level. </li><li>  <strong>Browser reality.</strong>  Let's see how garbage collection is implemented in modern engines and browsers, and what conclusions we can draw from this. </li><li>  <strong>Daily</strong> - let's talk about the practical application of the knowledge gained in everyday life. </li></ul><br>  All statements are supported by examples of how you can and how not to do. <br><br><h2>  Why all this to know? </h2><br>  Garbage collection is an imperceptible thing for us, but knowing how it works you will: <br><br><ul><li>  Have an idea about the tool that you use, which is useful in work. </li><li>  Understand where to optimize already released applications and how to design future ones so that they work better and faster. </li><li>  Know how not to make common mistakes and stop wasting resources on useless and harmful "optimization". </li></ul><br><h2>  Theory <br></h2><br>  Joel Spolsky once said: <br><br><blockquote>  All nontrivial abstractions are holes. <br></blockquote><br>  A garbage collector is one big non-trivial abstraction that is patched from all sides.  To our happiness, it flows very rarely. <br><br>  Let's start with the theory, but without boring definitions.  Let us analyze the work of the collector by the example of simple code: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Foo = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> }; } work(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xy, z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br><ul><li>  There is a <strong>class</strong> in the code. </li><li>  The class has a <strong>constructor</strong> . </li><li>  <strong>The work method</strong> returns the associated function. </li><li>  Inside this function, <strong>this</strong> and a couple of variables from the closure are used. </li></ul><br>  Let's see how this code will behave if we run it this way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">//C   window.worker = foo.work('Brendan Eich'); //     bind,   window.foo = null; //   window.Foo = null; //  ,   -  window.worker(); window.worker = null; //   ,  </span></span></code> </pre><br>  Let us analyze the code and its components in more detail and begin with the class. <br><br><h3>  Class declaration <br></h3><br><img src="https://habrastorage.org/webt/nd/yq/ie/ndyqietonv9ggcg45mvfmwnsyae.png"><br><br>  We can assume that classes in ECMAScript 2015 are just syntactic sugar for functions.  All functions have: <br><br><ul><li>  <strong>Function. [[Prototype]]</strong> is the real function prototype. </li><li>  <strong>Foo.prototype</strong> is a prototype for newly created objects. </li><li>  Foo.prototype has a backlink to the constructor via the constructor field.  This is an object, so it inherits the <strong>Object.prototype</strong> . </li><li>  <strong>The work method is a</strong> separate function to which there is a reference, similar to the constructor, because they are both just functions.  He can also set a prototype and call it via new, but rarely does anyone use this behavior. </li></ul><br>  Prototypes occupy a lot of space on the scheme, so let's remember that they are, but then we remove for simplicity. <br><br><h3>  Creating a class object <br></h3><br><img src="https://habrastorage.org/webt/f_/ea/5u/f_ea5uuq01wygmqkdfbrj4a8oja.png"><br><br><ul><li>  We put our class in the window, because the classes do not get there by default. </li><li>  Create a class object. </li><li>  Creating an object automatically exposes a prototype to a class object in Foo.prototype.  Therefore, when you try to call the work method on the object, it will know what kind of work it is. </li><li>  Our constructor creates an <em>x</em> field in the object from an object with a string. </li></ul><br>  Here's what happened: <br><br><img src="https://habrastorage.org/webt/nb/xx/d1/nbxxd11pg7bmutfnn4bqh3_ooxs.png"><br><br>  The method returns the associated function - this is such a special ‚Äúmagic‚Äù object in JS, which consists of the associated this and function to be called.  The associated function also has a prototype and another prototype, but we are interested in the closure.  By specification, the closure is stored in Environment.  Most likely you are used to the word Scope, but <strong>in the specifications the field is called Environment</strong> . <br><br><img src="https://habrastorage.org/webt/dv/zu/rn/dvzurne2uerkhr0vqxeahna5cum.png"><br><br>  The Environment stores a link to LexicalEnvironment.  This is a complex object, more complicated than the slide, it contains links to everything that can be accessed from a function.  For example, window, foo, name, and z.  There are also links even to what you clearly do not use.  For example, you can apply eval and accidentally use unused objects, but JS should not break. <br><br>  So, we have built all the objects and now we will destroy everything. <br><br><h3>  Remove the link to the object <br></h3><br>  Let's start by removing the object link, this link in the diagram is highlighted in red. <br><br><img src="https://habrastorage.org/webt/zp/g_/mf/zpg_mfnx7pgoc1q46ruedg5oeve.png"><br><br>  We delete and nothing happens, because from the <strong>window</strong> to the object there is a path through the <strong>bound function</strong> function. <br><br><img src="https://habrastorage.org/webt/_w/lv/v6/_wlvv6dpon2qnjgaukobadopmas.png"><br><br>  This pushes us to a typical error. <br><br><h3>  A typical mistake is a forgotten subscription. <br></h3><br><pre> <code class="javascript hljs">externalElement.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shouldDoSomethingOnClick) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(); } })</code> </pre><br>  Occurs when you subscribe: using <strong>this,</strong> explicitly via bind or through switch functions;  use something in closure.  Then you forget to unsubscribe, and the lifetime of your object or of what is in the closure becomes the same as the lifetime of the subscription.  For example, if this is a DOM element that you do not touch with your hands, then, most likely, this is the time until the end of the page‚Äôs life. <br><br>  To solve this problem: <br><br><ul><li>  Unsubscribe. </li><li>  Consider the subscription lifetime and who owns it. </li><li>  If for some reason you can not unsubscribe, then nullify the links (whatever = null), or clear all the fields of the object.  If an object leaks from you, it will be small and do not mind it. </li><li>  Use WeakMap, maybe it will help in some situations. </li></ul><br><h3>  Remove class reference <br></h3><br>  Go ahead and try to remove the class reference highlighted in red. <br><br><img src="https://habrastorage.org/webt/px/sm/yf/pxsmyfvo0utc5d1wh3rfrqcpmlc.png"><br><br>  We delete the link and nothing changes here.  The reason is that the class is available through BoundThis, which has a link to the prototype, and in the prototype there is a link back to the constructor. <br><br><h3>  Typical <s>mistake</s> useless work <br></h3><br>  Why do we need all these demonstrations?  Because there is a downside of the problem when people take advice to nullify links too literally and nullify everything. <br><br><pre> <code class="javascript hljs">destroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._y = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  10 this._foobar = null }</span></span></code> </pre><br>  This is a pretty useless job.  If an object consists only of references to other objects and there are no resources there, then no destroy () is needed.  It is enough to lose the link to the object, and it will die by itself. <br><br>  There is no universal council.  When it is necessary - null, and when it is not necessary - do not null.  Zanulenie not a mistake, but simply useless work. <br><br>  Go ahead.  Call the method bound function and it will remove the link from [object Foo] to [object Object].  This will lead to the fact that in the scheme there will appear objects that are alone in the blue rectangle. <br><br><img src="https://habrastorage.org/webt/zl/ep/xc/zlepxcvklqpricdvth4gxnjp2ny.png"><br><br>  These objects are js trash.  He is perfectly going.  However, there is garbage that does not lend itself to the collector. <br><br><h3>  Garbage that is not going to <br></h3><br>  In many browser APIs you can create and destroy an object.  If the object is not destroyed, then no collector can assemble it. <br><br>  Objects with pair functions create / delete: <br><br><ul><li>  createObjectURL (), revokeObjectURL (); </li><li>  WebGL: create / delete Program / Shader / Buffer / Texture / etc; </li><li>  ImageBitmap.close (); </li><li>  indexDb.close (). </li></ul><br>  For example, if you forget to remove ObjectURL from a 200 MB video, then these 200 MB will be in memory until the end of the page‚Äôs life and even longer, because there is data exchange between the tabs.  Similarly in WebGL, indexDb and other browser-based APIs with similar resources. <br><br>  Fortunately, in our example in the blue rectangle just JavaScript objects, so this is just garbage that can be removed. <br><br>  The next step is to clean the last link from left to right.  This is a link to the method we received, to the associated function. <br><br><img src="https://habrastorage.org/webt/5g/k5/h9/5gk5h96gg6zpw4bi64mq1guopom.png"><br><br>  After its removal, we will not have links between the left and the right side?  In fact, there are still references from the closure. <br><br><img src="https://habrastorage.org/webt/hy/s0/vy/hys0vysevtslyjbht0gjngdaqaq.png"><br><br>  It is important that there are no links from left to right, therefore everything except window is garbage, and it will die. <br><br>  <strong>Important note</strong> : there are circular references in the garbage, that is, objects that link to each other.  The presence of such links does not affect anything, because the garbage collector does not collect individual objects, but all the garbage. <br><br><img src="https://habrastorage.org/webt/hl/qq/4f/hlqq4fn3nlubl4aefqycqyi4v8u.png"><br><br>  We looked at examples and now, at an intuitive level, we understand what rubbish is, but let's give a complete definition of the concept. <br><br><blockquote>  Garbage is everything that is not a living object. <br></blockquote><br>  Everything became very clear.  But what is a living object? <br><br>  <strong>A living object is an object that can be reached by links from the root object.</strong> <br><br>  Two new concepts appear: ‚Äúfollow the links‚Äù and ‚Äúroot object‚Äù.  One root object we already know is window, so let's start with links. <br><br><h3>  What does it mean to follow the links? <br></h3><br>  There are many objects that are related to each other and link to each other.  We will start a wave along them, starting with the root object. <br><br>  We initialize the first step, and then we act according to the following algorithm: let's say that all that is on the crest of the wave are living objects and see what they refer to. <br><br><img src="https://habrastorage.org/webt/qd/vc/gv/qdvcgvf0tjyk-i85yx9_yzivgs8.png"><br><br>  Initialize the first step.  Then we will act according to the following algorithm: let's say that all the yellow on the crest of the wave are living objects and see what they refer to. <br><br>  We will make what they refer to with a new wave crest: <br><br><img src="https://habrastorage.org/webt/k-/5p/bz/k-5pbzevhodbxxsj1ktayvgio34.png"><br><br>  Finished and start again: <br><br><ul><li>  We liven up. </li><li>  We look at what they refer to. </li><li>  Create a new wave crest, animate objects. </li><li>  We look at what they refer to. </li></ul><br><img src="https://habrastorage.org/webt/nd/bb/8d/ndbb8dwnwadhclwfucgkozu42ea.png"><br><br>  Noticing that one arrow points to an already living object, we simply do nothing.  Further according to the algorithm, until the objects for traversing are finished.  Then we say that we have found all the living objects, and all the rest is rubbish. <br><br><img src="https://habrastorage.org/webt/pw/ms/6z/pwms6zisv2hasovzir04jtjna0k.png"><br><br>  This process is called <strong>marking</strong> . <br><br><h3>  What does the root object mean? <br></h3><br><br><ul><li>  Window. </li><li>  Almost all browser APIs. </li><li>  All promise. </li><li>  All that is put in Microtask and Macrotask. </li><li>  Mutation observers, RAF, Idle-callbacks.  Everything that can be reached from what is in the RAF cannot be deleted, because if you delete an object that is used in the RAF, then surely something will go wrong. </li></ul><br>  Build may occur at any time.  Every time braces or function appear, a new object is created.  The memory may not be enough, and the collector will go looking for a free one: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = {}; <span class="hljs-comment"><span class="hljs-comment">// nomem, run gc D: // ‚Ä¶ } while (whatever()) bar(); }</span></span></code> </pre><br>  In this case, the root objects will be all that is on the call stack.  If you, for example, stop at line X and delete what Y refers to, then your application will crash.  JS does not allow us such frivolities, so you cannot delete an object from Y. <br><br>  If the previous part seemed difficult, then it will be even more difficult. <br><br><h2>  Harsh reality <br></h2><br>  Let's talk about the world of machines, in which we deal with iron, with physical carriers. <br><br>  Memory is one big array in which just numbers lie, for example: new Uint32Array (16 * 2 ** 30). <br><br>  Let's create objects in memory and add them from left to right.  Create one, second, third - they are all different sizes.  Along the way we put down the links. <br><img src="https://habrastorage.org/webt/rg/ly/oy/rglyoyk5kjjz0re9ktp1m7r0dtg.png"><br><br>  On the seventh object the place is over, because we have 2 free squares, but we need 5. <br><br>  What can be done here?  The first option is to crash.  It's 2018 in the yard, everyone has the latest MacBooks and 16 GB of RAM.  There are no situations when there is no memory! <br><br>  However, letting things go bad is a bad idea, because on the web this leads to a screen like this: <br><br><img src="https://habrastorage.org/webt/un/lw/gn/unlwgnwcw1-7p5xunjhvo2hfwzg.png"><br><br>  This is not the behavior that we want from the program, but in general it is valid.  There is a category of collectors called <strong>No-op</strong> . <br><br><h3>  No-op collector <br></h3><br>  Pros: <br><br><ul><li>  The collector is very simple. </li><li>  Garbage collection is simply not there. </li><li>  Do not write anything and think about memory. </li></ul><br>  Minuses: <br><br><ul><li>  Everything falls so that it never rises again. </li></ul><br>  For the frontend, the no-op collector is irrelevant, but used on the backend.  For example, having several servers behind balancers, the application is given 32 GB of RAM and then it is killed entirely.  It's easier and productivity is only enhanced by simply restarting when memory becomes low. <br><br>  In the web, it is impossible and you have to clean it. <br><br><h3>  Find and remove trash <br></h3><br>  Let's start cleaning with trash search.  We already know how to do this.  Garbage - objects C and F in the previous scheme, because they can not be reached along the arrows from the root object. <br><br>  We take this garbage, feed it to the garbage lover and is ready. <br><br><img src="https://habrastorage.org/webt/g8/1l/s1/g81ls1ji6sco7buvbftj6xgr714.png"><br><br>  After cleaning, the problem is not solved, as there are holes in the memory.  Please note that there are 7 free squares, but we still cannot select 5 of them.  Fragmentation has occurred and the build is over.  Such an algorithm with holes is called <strong>Mark and Sweep</strong> . <br><br><h3>  Mark and sweep <br></h3><br>  Pros: <br><br><ul><li>  Very simple algorithm.  One of the first that you‚Äôll learn about if you start exploring the Garbage collector. </li><li>  It works in proportion to the amount of garbage, but copes only when there is little garbage. </li><li>  If you have only living objects, then he does not waste time and simply does nothing. </li></ul><br>  Minuses: <br><br><ul><li>  It requires a complex logic of searching for free space, because when there are a lot of holes in the memory, then you have to try on each object to understand whether it is suitable or not. </li><li>  Fragments the memory.  It may happen that with free 200 MB, the memory is broken into small pieces and, as in the example above, there is no single piece of memory for the object. </li></ul><br>  We are looking for other ideas.  If you look at the picture and think, then the first thought is to move everything to the left.  Then to the right will remain one large and free piece, in which our object will easily fit. <br><br>  Such an algorithm exists and it is called <strong>Mark and Compact</strong> . <br><br><h3>  Mark and Compact <br></h3><br>  Pros: <br><br><ul><li>  Defragmenting memory. </li><li>  It works in proportion to the number of living objects, which means it can be used when there is practically no garbage. </li></ul><br>  Minuses: <br><br><ul><li>  Difficult in work and implementation. </li><li>  Moves objects.  We moved the object, copied it, now it is in a different place and the whole operation is rather expensive. </li><li>  It requires 2-3 passes through the entire memory, depending on the implementation - the algorithm is slow. </li></ul><br>  Here we come to another idea. <br><br><h3>  Garbage collection is not free <br></h3><br>  In High performance APIs like WebGL, WebAudio, and WebGPU, which is still in development, objects are created and deleted in separate phases.  These specifications are written so that garbage collection is not in process.  Moreover, there is not even a Promise there, but there is pull () - you just interrogate each frame: ‚ÄúDid something happen or not?‚Äù. <br><br><h3>  Semispace aka Lisp 2 <br></h3><br>  There is another collector, about which I want to talk.  What if you do not free the memory, and copy all the living objects somewhere in another place. <br><br>  Let's try to copy the root object "as is", which is somewhere referenced. <br><br><img src="https://habrastorage.org/webt/oe/ck/uc/oeckucvn6dpbz9hgbg3ykkzmylm.png"><br><br>  And then all the rest. <br><br><img src="https://habrastorage.org/webt/rf/ds/9x/rfds9xc3v1tp6pvlpokawj8pkn0.png"><br><br>  There are no debris and holes in the memory above.  Everything seems to be fine, but two problems arise: <br><br><ul><li>  Duplication of objects - we have two green objects and two blue ones.  Which one to use? </li><li>  Links from new objects lead to old objects, and not to each other. </li></ul><br>  With links, everything is solved with the help of a special algorithmic "magic", and with duplication of objects we cope with the removal of everything from below. <br><img src="https://habrastorage.org/webt/cq/sr/ur/cqsrurkhqp_b01qsxjhzndggryg.png"><br><br>  As a result, we still have free space, and on top only live objects in the normal manner.  This algorithm is called <strong>Semispace</strong> , <strong>Lisp 2,</strong> or simply the ‚Äúcopy collector.‚Äù <br><br>  Pros: <br><br><ul><li>  Defragmenting memory. </li><li>  Plain. </li><li>  Can be combined with the bypass phase. </li><li>  Works in proportion to the number of living objects in time. </li><li>  Works well when a lot of trash.  If you have 2 GB of memory and there are 3 objects in it, then you will bypass only 3 objects, and the remaining 2 GB didn‚Äôt seem to be there. </li></ul><br>  Minuses: <br><br><ul><li>  Double memory consumption.  You use 2 times more memory than necessary. </li><li>  Moves objects - this is also not a very cheap operation. </li></ul><br><blockquote>  Note: garbage collectors can move objects. <br></blockquote><br>  In the web, this is irrelevant, and in Node.js even very.  If you are writing an extension in C ++, then the language does not know about all this, so there are double links that are called handle and look something like this: v8 :: Local &lt;v8 :: String&gt;. <br><br>  Therefore, if you are going to write plugins for Node.js, then the information will be useful to you. <br><br>  Summarize the different algorithms with their pros and cons in the table.  It also has the Eden algorithm, but more about it later. <br><br><img src="https://habrastorage.org/webt/s9/zm/ec/s9zmecoite95yruxuvtafbzaimy.png"><br><br>  I really want an algorithm without cons, but there is no such thing.  Therefore, we take the best of all worlds: we use several algorithms at the same time.  In one piece of memory we collect garbage with one algorithm, and in the other with another algorithm. <br><br>  How to understand the effectiveness of the algorithm in this situation? <br><br>  We can use the knowledge of smart husbands from the 60s, who looked at all the programs and understood: <br><br><blockquote>  Weak hypothesis about generations: most objects die young. <br></blockquote><br>  These they wanted to say that all programs do nothing but produce fruit.  In an attempt to use knowledge, we will come to what is called "assembly by generations." <br><br><h3>  Assembly by generations <br></h3><br>  Create two pieces of memory that are unrelated: on the left of Eden, and on the right of the slow Mark and Sweep.  In Eden we create objects.  Lots of objects. <br><br><img src="https://habrastorage.org/webt/_y/rt/tc/_yrttco6brh1zyz4sqkiuk4wrjo.png"><br><br>  When Eden says it's filled, we run garbage collection in it.  Find live objects and copy them to another collector. <br><br><img src="https://habrastorage.org/webt/38/si/a5/38sia5sg1nhfx6elimcuitdpqok.png"><br><br>  Eden itself is completely clear, and we can further add objects to it. <br><br><img src="https://habrastorage.org/webt/pp/qc/3_/ppqc3_uk1okblort71qjndj7ije.png"><br><br>  Relying on the hypothesis of generations, we decided that objects c, g, i most likely will live for a long time, and we can check them for rubbish less often.  Knowing this hypothesis, you can write programs that cheat collector.  You can do this, but I do not advise you, because this will almost always lead to undesirable effects.  If you create a long-lived garbage, the collector will begin to assume that it is not required to collect. <br><br>  A classic example of cheating is LRU-cache.  The object is in the cache for a long time, the collector looks at it and believes that it will not collect it yet, because the object will live for a very long time.  Then a new object gets into the cache, and the big old one is pushed out of it and it‚Äôs impossible to assemble this large object right away. <br><br>  How to collect now we know.  Talk about when to collect. <br><br><h3>  When to collect? <br></h3><br>  The easiest option is when we <strong>just stop everything</strong> , start the build, and then run the JS work again. <br><br><img src="https://habrastorage.org/webt/e-/1n/od/e-1nodx10w_v6q7x5w7xi9xdfvk.png"><br><br>  In modern computers, there is not a single thread of execution.  On the web, this is familiar to Web Workers.  Why not take and not <strong>parallelize the build process</strong> .  Making several small operations at the same time will be faster than one big one. <br><br><img src="https://habrastorage.org/webt/y6/yw/jh/y6ywjhxlis6qhu7kk5cumaruayu.png"><br><br>  Another idea is to accurately make a cast of the current state, and <strong>build the assembly in parallel with JS execution</strong> . <br><br><img src="https://habrastorage.org/webt/lm/fd/3w/lmfd3w2kiyhtxlwvp1wtlges6ia.png"><br><br><blockquote>  If you are interested, I advise you to read: <br><br><ul><li>  The only and the main book on the assembly "Garbage Collection Handbook". </li><li>  <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Wikipedia</a> as a universal resource. </li><li>  Site <a href="http://www.memorymanagement.org/">memorymanagement.org.</a> </li><li>  Reports and articles by <a href="https://shipilev.net/">Alexander Shepelev</a> .  He talks about Java, but in terms of garbage, Java and V8 work in approximately the same way. </li></ul></blockquote><br><h2>  Browser reality <br></h2><br>  Let's get to how browsers use everything we talked about. <br><br><h3>  IoT engines <br></h3><br>  Let's start not entirely with browsers, but with the Internet of Things engines: JerryScript and Duktape.  They use Mark'n'sweep and Stop the world algorithms. <br><br>  IoT engines run on microcontrollers, which means: the language is slow;  second hang;  fragmentation;  and all this for a teapot with backlight :) <br><br>  If you write Internet of Things in JavaScript, then tell us in the comments?  Is there any reason? <br><br>  IoT-engines leave alone, we are interested in: <br><br><ul><li>  V8. </li><li>  SpiderMonkey.  He really has no logo.  Logo homemade :) </li><li>  JavaScriptCore, which is used in WebKit. </li><li>  ChakraCore, which is used in the Edge. </li></ul><br><img src="https://habrastorage.org/webt/vw/0q/nj/vw0qnjkmktvnd2z0_dhrvkw4y_u.png"><br><br>  All engines are about the same, so we'll talk about the V8, as the most famous. <br><br><h3>  V8 <br></h3><br><ul><li>  Almost all server-side JavaScript, because this is Node.js. </li><li>  Almost 80% of client javascript. </li><li>  The most sociable developers, a lot of information and good sources that are easiest to read. </li></ul><br>  In V8, assembly is used for generations. <br><img src="https://habrastorage.org/webt/u-/-7/r4/u--7r4ggek0kxgpscwhtzn8grfe.png"><br><br>  The only difference is that before we had two collectors, and now three: <br><br><ul><li>  An object is created in Eden. </li><li>  At some point, there is too much garbage in Eden and the object is transferred to Semispace. </li><li>  The object grows up and when the collector realizes that he is too old and boring, he throws it at Mark and Sweep, in which garbage collection is extremely rare. </li></ul><br>  Visually see how it looks like at <strong>memory trace</strong> . <br><br><img src="https://habrastorage.org/webt/c7/s1/av/c7s1avnfboc9c57khyjw5xqjybm.png"><br><br>  Several large waves with small waves are noticeable.  Small ones are minor assemblies, and large ones are major ones. <br><br>  The meaning of our existence, according to the hypothesis of generations, is to generate garbage, so the next mistake is the fear of creating garbage. <br><br><blockquote>  Garbage can be created when it is really garbage.  If you reuse the object, it will live much longer and the collector will decide that it should not be collected, so do not do so. <br></blockquote><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallel mark </font></font><br></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relatively recently, V8 developers have parallelized the search phase of living objects. </font></font><br><img src="https://habrastorage.org/webt/40/dg/j5/40dgj5iiquv7dsag0mndget4s30.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The assembly phase is still Stop the world, but most of the assembly is the search for living objects, which happens completely independently of JS execution, that is, it adds very, very small freezes.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How much is all this fun? </font></font><br></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From 1 to 3%, which is not very much. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But 3% = 1/33 and that's a lot for GameDev. </font><font style="vertical-align: inherit;">In GameDev 3% is 1 frame, which is already a noticeable lag. </font><font style="vertical-align: inherit;">Therefore, GameDev tries not to use the garbage collector.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pool = [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bullet = pool.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> !x.inUse); bullet.isUse = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bullet; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnToPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bullet</span></span></span><span class="hljs-function">) </span></span>{ bullet.inUse = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Frame const bullet = getFromPool(); // ... returnToPool(bullet);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of using a collector, 10,000 bullets are created in advance, for example, and these bullets are picked out and released by hand. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another example is the particle system in games. </font><font style="vertical-align: inherit;">If you have a fire or stars from a magic wand, then you can create thousands and tens of thousands of objects. </font><font style="vertical-align: inherit;">This is a very large load on the collector, which will inevitably lead to a hang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Waste Collector Statistics: Chromium </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From the collector you can pull out some statistics, but, unfortunately, only in Chromium. </font></font><br><br><pre> <code class="javascript hljs">&gt; performance.memory MemoryInfo { <span class="hljs-attr"><span class="hljs-attr">totalJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">usedJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">jsHeapSizeLimit</span></span>: <span class="hljs-number"><span class="hljs-number">2330000000</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Chromium, there is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance.memory</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and you can find out how much is currently reserved for the page, how much memory is used and how much Chromium is ready to allocate. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chromium is ready to allocate 2 GB of memory for JavaScript. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, there is still no documentation and you can only read the source and blogpost.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Garbage Collector Statistics: Node </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Node.js, everything is standardized in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process.memoryUsage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which returns roughly the same thing.</font></font><br><br><pre> <code class="javascript hljs">&gt; process.memoryUsage() { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">22839296</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">10207232</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">5967968</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">12829</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that someday this information will be standardized and it will get into other browsers, but so far there is no hope. </font><font style="vertical-align: inherit;">But there are thoughts to give developers greater control over garbage collection. </font><font style="vertical-align: inherit;">This refers to weak links.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Future </font></font><br></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak links</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are almost like normal ones, only they can be collected in case of a lack of memory. There is a </font></font><a href="https://github.com/tc39/proposal-weakrefs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposal for</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this matter </font><font style="vertical-align: inherit;">, but so far it is in the second stage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have Node.js, then you can use </font></font><a href="https://www.npmjs.com/package/weak"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-weak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and weak links, for example, for caching.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakRef(myJson); <span class="hljs-comment"><span class="hljs-comment">// 2   let json = cached.deref(); if (!json) { json = await fetchAgain(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can save a large object, for example, if you have video processing on JS. </font><font style="vertical-align: inherit;">You can store caches in weak links and tell the builder that if there is not enough memory, then these objects can be deleted, and then checked for deletion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the future, we will have a </font></font><a href="https://github.com/WebAssembly/gc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">collector in WebAssembly</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but so far everything is foggy. </font><font style="vertical-align: inherit;">In my opinion, a large number of problems are not solved in the current solution, and even when the developers finish it, the fog of uncertainty will be even denser, because no one knows how to use it.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is nothing special to </font></font><a href="https://v8.dev/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about browsers: there is </font><a href="https://v8.dev/"><font style="vertical-align: inherit;">v8.dev</font></a><font style="vertical-align: inherit;"> and source codes for JS engines.</font></font><br></blockquote><br><ul><li> <a href="https://github.com/v8/v8/tree/7.0.237/src/heap"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/v8/v8/tree/7.0.237/src/heap</font></font></a> </li><li> <a href="https://github.com/servo/mozjs/blob/master/mozjs/js/src/gc/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/servo/mozjs/blob/master/mozjs/js/src/gc/</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/WebKit/webkit/.../JavaScriptCore/heap/MarkedSpace.cpp</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/Microsoft/ChakraCore/.../HeapAllocator.cpp</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/svaarala/duktape/.../duk_heap_markandsweep.c</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/jerryscript-project/jerryscript/.../ecma-gc.c</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How can all this be used in everyday life? </font></font><br><br><h2>  Daily routine <br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In everyday life there are DevTools and two great tabs: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We will look at the tabs on the example of Chromium, because everyone uses it, and for Firefox and Safari everything is the same.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performance tab </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you remove the Trace by clicking the "Memory" checkbox right below the Performance tab, a nice memory consumption graph will be recorded along with the JS impression. </font></font><br><br><img src="https://habrastorage.org/webt/vm/8b/hn/vm8bhnnurkvza6cquinxa61ema8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And along with JS, all internal events in V8 and all the information about how much the collector worked is recorded. </font><font style="vertical-align: inherit;">You can see on the slide on the example of Yandex.Map that the GC worked for 30 ms out of 1200 ms of JS, that is, 1/40.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memory Tab </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the tab, you can take a snapshot of the entire memory with all objects. </font></font><br><br><img src="https://habrastorage.org/webt/1i/cl/br/1iclbrk21tcz3lmj472ukb5jwqc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like this. </font></font><br><br><img src="https://habrastorage.org/webt/fy/6i/0v/fy6i0v3tu6yq2onfzuz7ma7moks.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objects can be sorted by size, by size of objects plus how much they pull other objects behind them. From interesting things you can see, for example, compiled code that V8 builds into machine code in order to run very, very quickly. He also lives in the collector, and the collector collects it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the Q object (two lines below the compiled code) is React in the minified Maps code. It takes a lot of space, but what to do? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to see how much space your objects take, then give them the names for easy search in the cast or at minification keep what they are minified into. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also remove the cast of allocation, that is, the creation of objects.</font></font><br><br><img src="https://habrastorage.org/webt/-3/z_/si/-3z_si-wvtfdlbz87myro38qz1s.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is about the same as the current state, only a lot of them, they are constantly being created and you have a process schedule. </font><font style="vertical-align: inherit;">The graph shows that there are peaks - about 4 MB is created for one tick. </font><font style="vertical-align: inherit;">You can see what is there. </font></font><br><br><img src="https://habrastorage.org/webt/pr/un/bt/prunbtssbfjjsklugfzwp2mv778.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different utilitarian objects and again React, because at that moment the map was redrawing something: a response came from the server and almost the entire interface was updated. </font><font style="vertical-align: inherit;">Accordingly, a bunch of JSX was created. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If Performance and Memory are suddenly not enough, you can use:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Chromium: about: tracing. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Firefox: about: memory and about: performance, but they are difficult to read. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node flags are trace-gc, ‚Äìexpose-gc, require ('trace_events'). </font><font style="vertical-align: inherit;">Through trace_events, you can programmatically collect statistics.</font></font></li></ul><br><h2>  Results <br></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The garbage collector is smart, it was made by knowledgeable developers to collect the garbage that you produce. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No one bothers you to deceive the assembler or to complicate his work and shoot himself in this way. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not be afraid to create garbage. </font><font style="vertical-align: inherit;">The collector collects garbage, so why take away his work?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keep track of performance, because you can accidentally do something wrong and get the consequences in an unexpected place. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you do not have a SPA, then you can do nothing, because winning 1 frame of a hang may not be worth the work that will be spent. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Most of the errors, dubious places and useless work is due to a misunderstanding of the tool. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contact speaker Andrei Roenko: </font></font><a href="https://flapenguin.me/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flapenguin.me</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://twitter.com/fla_penguin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/flapenguin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><blockquote>   <a href="https://frontendconf.ru/moscow-rit/2019">  -</a>      <a href="https://ritfest.ru/">++</a> .      <a href="http://eepurl.com/bb99tn"><strong></strong></a>  <a href="https://www.youtube.com/c/FrontendChannel"><strong>YouTube-</strong> <br></a> . <br><br>     ,     2018 ,     .     <a href="https://www.youtube.com/playlist%3Flist%3DPLfbxrJr-t5mmbfVGG01Gd8Yh-njCgcOFK"></a>     <a href="http://frontendconf.ru/">Frontend Conf</a> 2018. <br><br>     ,   :) <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/433318/">https://habr.com/ru/post/433318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433302/index.html">First Rust Steps</a></li>
<li><a href="../433304/index.html">Load testing with locust. Part 3</a></li>
<li><a href="../433306/index.html">Visual studio 2019</a></li>
<li><a href="../433308/index.html">Transferring PBX configuration to 3CX PBX Express service</a></li>
<li><a href="../433316/index.html">Design Digest: onboarding, feedback, search for ideas and decision making</a></li>
<li><a href="../433320/index.html">Grid Layout as the basis of modern layouts</a></li>
<li><a href="../433322/index.html">JSON API - we work according to the specification</a></li>
<li><a href="../433324/index.html">Build a Dream Bundle with Webpack</a></li>
<li><a href="../433330/index.html">Solving Japanese Crosswords with SAT Solver</a></li>
<li><a href="../433332/index.html">Python support in Azure Functions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>