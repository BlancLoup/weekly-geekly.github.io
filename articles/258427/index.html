<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Jancy - scripting language for system / network programmers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why even create a new programming language? There are already an incredible number of them - in my firm conviction, significantly more than necessary....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Jancy - scripting language for system / network programmers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b61/b7e/756/b61b7e756a1f85df0edf526a0ccf3e0c.png" alt="jancy" align="right">  Why even create a new programming language?  There are already an incredible number of them - in my firm conviction, significantly more than necessary.  And certainly, the fact that compiler creation is an incredibly exciting process plays a significant role in this situation.  Adjusted for watermelons and pork hryashchiki - this is generally one of the most ‚Äúdelicious‚Äù works that an enthusiastic programmer can dream of. <br><br>  Indescribably zdorovskim is a flower-candy period - the first stage of the study of the theory of compilers for thick smart books, and - right there!  - its application in practice, in its own language.  Even the sad prospect that the creator of the language may well be his only user is not able to outweigh the joy of creativity and stop the spherical-in-vacuum compiler Kulibin.  Of course, if the satisfaction of self-interest is not only important, but also the sole driving force of the whole process, the above described perspective will inevitably be realized.  But even if this is not the only reason for creating a new language, the prospect of becoming a single user of your creation still has a chance to materialize. <br><a name="habracut"></a><br>  My flower-candy period of the novel with compilers and the joy of sculpting my first languages ‚Äã‚Äãended a long time ago.  I can say that I legitimized my relationship with the bonds of sacred marriage: compilers, debuggers and development tools - this is my main job in Tibbo with all the ensuing consequences (yes, including in the form of saturation with the subject, increasing the percentage of routine tasks, etc. e.) Therefore, I had a different motivation for creating my own scripting programming language than satisfying my own interest. <br><br><h1>  So why? </h1><br>  If we briefly formulate the practical side of my personal and our (as a company) motivation, then it will sound like this: we wanted to have an embedded script engine <b>with pointers</b> to structures and <b>safe address arithmetic</b> .  This was not found.  And we made <a href="http://tibbo.com/jancy/">Jancy</a> ("between-Java-and-C"), which has C-compatible structures, and pointers with safe arithmetic, and much, much more: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Unique features</b> <br><ul><li>  Safe pointers and address arithmetic; </li><li>  The unprecedented level of compatibility of source codes with C / C ++ for scripting languages; </li><li>  Reactive programming is one of the first implementations in an imperative language (and not in the form of libraries); </li><li>  Built-in lexer / scanner generator. </li></ul><br>  <b>Design Principles</b> <br><ul><li>  Object-oriented language with C-like syntax; </li><li>  Binary ABI (application-binary-interface) compatibility with C / C ++; </li><li>  Automatic memory management through accurate garbage collection; </li><li>  <a href="http://llvm.org/">LLVM</a> as a backend. </li></ul><br>  <b>Other significant features</b> <br><ul><li>  Exceptions like syntactic sugar over the error code model. </li><li>  Properties (properties) - the most complete implementation; </li><li>  Multicasts (multicasts) and events (events), including the weak ones, from which it is not necessary to unsubscribe; </li><li>  Multiple inheritance; </li><li>  Const correctness; </li><li>  RAII paradigm support (resource-acquisition-is-initialization); </li><li>  Local memory of threads (thread local storage); </li><li>  Partial application for functions and properties; </li><li>  A schedule operator to create pointers to functions that are guaranteed to be called in a given environment (for example, in the right workflow); </li><li>  Enumerations for bit flags (bitflag enums); </li><li>  Perl-like string formatting; </li></ul><br>  A more complete list of features with examples of use can be found here: <a href="http://tibbo.com/jancy/features.html">http://tibbo.com/jancy/features.html</a> <br><br><h1>  Who can it be useful? </h1><br>  First of all, we wrote a language for ourselves - Jancy is used in the <a href="http://tibbo.com/ioninja/">IO Ninja</a> project as an embedded scripting language.  However, if he was useful to us, we humbly hope that he may well help others.  Hope this primarily relies on the <b>three strongest sides of Jancy</b> , in which our language has a real advantage over analogues. <br><br>  <b>1. High C / C ++ Compatibility</b> <br>  This applies to binary ABI compatibility as well as source level compatibility.  There are a lot of advantages here: this is a seamless connection of existing C-libraries, and porting code with C / C ++ using copy-pasting and subsequent cosmetic edits (and sometimes without them at all), and the ease of creating new libraries in C / C ++ for use from Jancy- scripts, and the efficiency of embedding a Jancy engine in a C / C ++ application, etc. <br><br>  <b>2. Convenient tools for IO programming</b> <br>  Here I first of all speak, firstly, about support of pointers and address arithmetic, ideally suited for parsing and generating binary packages, and, secondly, about the lexer generator (with incremental, i.e., applicable to parsing the IO streams coming piece by piece).  This also includes a partial application and a scheduling operator, which together allow, for example, to create a completion routine with captured context arguments;  at the same time, it will be automatically called in the necessary workflow. <br><br>  <b>3. Convenient tools for UI programming</b> <br>  Two words: <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">reactive programming</a> .  I am sure that in the near future, reactivity support - at the language level or in the form of crutches like preprocessors and libraries - will become an integral part of any user interface development system (UI).  Jancy offers out-of-box reactivity, and in my opinion, in a completely intuitive way.  In addition to reactivity, Jancy supports all sorts of variations in properties and events, which also helps build beautiful user interface frameworks. <br><br>  At the same time, despite the remarkable features of item number three, we are not yet positioning Jancy as a language for developing a user interface.  The maximum task at the moment is to become a scripting language for low-level IO programming, i.e.  <b>a system / network programmer / hacker tool</b> . <br><br>  And now - slides!  ¬© <br><br><h1>  ABI Compatibility with C / C ++ </h1><br>  Compatibility is always good, and compatibility with the de facto system programming language standard is just great, isn't it? <br><br>  Jancy scripts are JIT-compiled and can be directly called from a C / C ++ program, as well as directly calling C / C ++ functions.  This means that after correctly describing data types and function prototypes in Jancy scripts and a C ++ application, it becomes possible to transfer data naturally, through function arguments and return values. <br><br>  We declare and use functions from a script on Jancy: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charArg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intArg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> doubleArg )</span></span></span></span>; bar (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = foo (<span class="hljs-string"><span class="hljs-string">'a'</span></span>, x, <span class="hljs-number"><span class="hljs-number">3.1415</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  We write implementation in C / C ++: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charArg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intArg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> doubelArg )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... return true; }</span></span></code> </pre><br>  We connect before JIT-compile the script: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyLib</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> jnc::StdLib { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JNC_BEGIN_LIB () JNC_FUNCTION (<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, foo) JNC_LIB (jnc::StdLib) JNC_END_LIB () }; <span class="hljs-comment"><span class="hljs-comment">// ... MyLib::mapFunctions (&amp;module);</span></span></code> </pre><br>  Done!  No packaging / unpacking of variant-like containers, explicit pushing of arguments on the virtual machine stack, etc.  - everything works directly.  To date, Jancy supports all major calling models (calling conventions): <br><ul><li>  cdecl (microsoft / gcc) </li><li>  stdcall (microsoft / gcc) </li><li>  Microsoft x64 </li><li>  System v </li></ul><br>  In the opposite direction, calling Jancy from C ++ is just as easy: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Bar* bar = (Bar*) <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.getFunctionByName (<span class="hljs-string"><span class="hljs-string">"bar"</span></span>)-&gt;getMachineCode (); bar (<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  How about calling system functions and dynamic libraries (dll / so)?  No problem!  Jancy offers seamless integration with dynamic libraries: <br><pre> <code class="cpp hljs">library User32 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageBoxA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( intptr hwnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thin* text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thin* caption, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... } // ... User32 user32; user32.load ("user32.dll"); user32.lib.MessageBoxA (0, "Message Text", "Message Caption", 0x00000040);</span></span></code> </pre><br>  In this case, the resolution of the names will be made as they are accessed, and the found addresses will be cached (like DELAYLOAD, adjusted for the explicit loading of the module itself).  Error handling when loading and resolving names is performed by the standard for Jancy method of pseudo-exceptions (for details, see the next section). <br><br>  Dynamic name lookups (GetProcAddress / dlsym) are, of course, also possible - although not as elegant as the previous approach. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> cdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Printf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thin* format, ... )</span></span></span></span>; jnc.Library msvcrt; msvcrt.load (<span class="hljs-string"><span class="hljs-string">"msvcrt.dll"</span></span>); Printf thin* <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>; unsafe { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> = (Printf thin*) msvcrt.getFunction (<span class="hljs-string"><span class="hljs-string">"printf"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"function 'printf' is found at 0x%p\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>);</code> </pre></div></div><br>  Another important consequence of the high degree of compatibility between Jancy and C / C ++ is the ability to copy-paste from publicly available sources (such as Linux, React OS or other open source projects) and use the C protocol header definitions: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> IpProtocol: <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> { Icmp = <span class="hljs-number"><span class="hljs-number">1</span></span>, Tcp = <span class="hljs-number"><span class="hljs-number">6</span></span>, Udp = <span class="hljs-number"><span class="hljs-number">17</span></span>, } struct IpHdr { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> m_headerLength : <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> m_version : <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> m_typeOfService; bigendian <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_totalLength; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_identification; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_flags; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> m_timeToLive; IpProtocol m_protocol; bigendian <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_headerChecksum; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m_srcAddress; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m_dstAddress; }</code> </pre><br>  By the way, pay attention to the support of integer types with the reverse order of bytes (bigendians).  This, of course, is far from large-scale innovation, but it greatly simplifies the description and work with the headers of network protocols - here the reverse byte order is ubiquitous. <br><br><h1>  Pseudo-exceptions </h1><br>  Paradoxically, one of the consequences of ABI compatibility with C / C ++ was the rejection of the exception model that is familiar to C ++ programmers.  The fact is that such exceptions are completely inappropriate for the multilanguage call stack (although, of course, the list of objective claims to C ++ - these exceptions are not limited to - hot debates ‚Äúfor‚Äù and ‚Äúagainst‚Äù exceptions pop up on programmer resources with a regularity that can only envy). <br><br>  Anyway, Jancy uses a hybrid model.  It is based on checking return values, but the compiler eliminates the need to do it manually.  As a result, everything looks almost like exceptions in C ++ or Java, but at the same time, the behavior of the program when an error is an order of magnitude more transparent and predictable, and the support for exceptions during interlingual interactions (such as calling C ++ functions from scripts on Jancy and vice versa) becomes so simple as far as possible. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">-100</span></span> || a &gt; <span class="hljs-number"><span class="hljs-number">200</span></span>) <span class="hljs-comment"><span class="hljs-comment">// invalid argument { jnc.setStringError ("detailed-description-of-error"); return false; } // ... return true; }</span></span></code> </pre><br>  Return values ‚Äã‚Äãfor functions marked with the throws modifier will be treated as error codes.  In Jancy, intuitive error conditions are accepted for standard types: false for the boolean type, null for pointers, -1 for unsigned integers, and &lt;0 for signed ones.  The remaining types are cast to boolean (if this is not possible, a compilation error is generated).  It is obvious that the function returning void in this model cannot return errors. <br><br>  In addition, in this model, the developer is free to choose how to handle errors in each case.  Sometimes it is more convenient to do this by checking the return code manually, sometimes using the semantics of exceptions.  In Jancy, when calling the same function!  - You can do this and that, depending on the situation. <br><pre> <code class="cpp hljs">bar () { foo (<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// can use exception semantics... foo (-20); catch: printf ($"error caught: $(jnc.getLastError ().m_description)\n"); // handle error } baz (int x) { bool result = try foo (x); // ...or manual error-code check if (!result) { printf ($"error: $(jnc.getLastError ().m_description)\n"); // handle error } }</span></span></code> </pre><br>  The finally construct in most languages ‚Äã‚Äãis traditionally associated with exceptions.  But in Jancy finally it can be added to any block at the request of the developer.  In the end, you need to clean up after yourself even if no errors occurred, is it? <br><pre> <code class="cpp hljs">foo () { <span class="hljs-comment"><span class="hljs-comment">// nothing to do with exceptions here, just a 'finally' block to clean up finally: printf ("foo () finalization\n"); }</span></span></code> </pre><br>  Of course, a more traditional use of the finally construct is allowed in cases where exceptions are expected. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs">foo (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* address) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open (address); transact (<span class="hljs-number"><span class="hljs-number">1</span></span>); transact (<span class="hljs-number"><span class="hljs-number">2</span></span>); transact (<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>: addErrorToLog (jnc.getLastError ()); finally: close (); } }</code> </pre></div></div><br><br><h1>  Safe pointers and address arithmetic </h1><br>  Address arithmetic in the scripting language is what it was all about. <br><br>  Pointers, for all their inherent insecurity, are explicitly or implicitly part of any language.  By limiting the types of pointers available to the developer, they can significantly protect the language, simplify the handling of unfavorable situations during execution, and even catch incorrect operations at the time of compilation using static analysis.  But if address arithmetic comes into play, it is simply impossible to completely shift the analysis to the compilation stage. <br><br>  To always be able to verify the correctness of operations, the pointers in Jancy are thick by default.  In addition to the address, they also contain a validator - a special meta-data structure from which you can get information about the allowed range of addresses, the type of data, and the integer nesting level (scope level). <br><br>  The security formula for pointers and address arithmetic in Jancy is: <br><ol><li>  checking ranges for indirect references to pointers; </li><li>  checking the level of nesting when assigning pointers; </li><li>  check of reducibility when assigning pointers. </li></ol><br><div class="spoiler">  <b class="spoiler_title">What about performance?</b> <div class="spoiler_text">  This mechanism is not free and really results in certain overhead costs during execution. <br><br>  But first, even in the most naive version, without any optimizations, two integer comparisons to check the range or one to check the level of nesting is not so bad, especially taking into account the JIT compilation and the fact that Jancy is still a scripting language. <br><br>  Secondly, in the future with the help of static analysis it will be possible to get rid of many unnecessary checks at the compilation stage.  And thirdly, unsafe (thin, thin) pointers without validators can already be used for critical sections of code performance ‚Äî checks are not performed during operations with thin pointers. <br></div></div><br>  Checks for the valid address range are performed both in the case of an explicit use of the pointer, and in the case of the indexing operator: <br><pre> <code class="cpp hljs">foo ( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i ) { p += i; *p = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;-- range is checked static int a [] = { 10, 20, 30 }; int x = a [i]; // &lt;-- range is checked }</span></span></code> </pre><br>  In the case of pointers to stack and stream variables, checks of the level of nesting are also needed - to prevent addresses from leaking beyond their lifetime.  This mechanism even works in the case of multi-level pointers, like pointers-on-structures-with-pointers-on-structures-e-t: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* g_p; bar ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>** dst, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* src ) { *dst = src; <span class="hljs-comment"><span class="hljs-comment">// &lt;-- scope level is checked } baz () { int x; bar (g_p, &amp;x); // &lt;-- runtime error: scope level mismatch }</span></span></code> </pre><br>  Finally, reducibility checks are designed to prevent the destruction of the validators themselves.  Indeed, what if we create a pointer to a pointer, bring it to a pointer to char and then byte by byte wipe the validator with garbage?  Jancy will simply not do this: the compiler and runtime only allow casts where it is safe. <br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text">  Jancy divides all types into categories POD (plain-old-data) and non-POD.  The concept of POD in Jancy is slightly different from that in C ++.  Perhaps, in this regard, it was worthwhile to come up with a new term to avoid confusion, but in the end I decided not to make new cuts.  In addition, it seems to me that the POD in Jancy reflects the meaning of the concept of plain-old-data much more accurately. <br><br>  In Jancy, POD is data without meta data.  They can be safely copied and modified byte-by-byte without breaking anything.  Aggregation of POD data, whether it is the inclusion of fields, inheritance (here is the difference from C ++) or union into arrays - also leads to POD.  Everything that contains meta-data, namely classes, safe pointers to data and any aggregates of them, is non-POD. <br><br>  The Jancy compiler allows casting of non-POD types if and only if, as a result of casting, it is not possible to destroy or replace metadata.  For situations in which at the compilation stage it is not known (for example, we cast to a child type, the so-called downcast) - there is a special dynamic cast operator.  The dynamic cast operator is compiled into a call to a built-in function that returns a pointer to the requested type, or null if the cast is not possible. <br><br>  For example, let's prepare test types that we will bring to each other: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_a; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_b; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> A, B { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_c; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">:</span></span> C { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_s; }</code> </pre><br>  Here A, B, C is POD (and the latter type would not be POD in C ++), D is not POD, since  This type contains meta data in the form of the m_s pointer validator.  Now consider the possible cast operations. <br><br>  Upcast casts are always allowed and do not require an explicit cast operator for either POD or non-POD: <br><pre> <code class="cpp hljs">foo (D* d) { C* c = d; A* a = ; }</code> </pre><br>  POD types can be arbitrarily reduced to each other using the cast operator: <br><pre> <code class="cpp hljs">bar (B* b) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) b; C* c = (C*) b; <span class="hljs-comment"><span class="hljs-comment">// &lt;-- unlike C++ no pointer shift }</span></span></code> </pre><br>  Reductions from POD to non-POD types are allowed only in the case of a resultant constant pointer: <br><pre> <code class="cpp hljs">foo (D* d) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) d; &lt;-- error <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* p2 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*) d; <span class="hljs-comment"><span class="hljs-comment">// OK }</span></span></code> </pre><br>  Reduction to child types (downcast) is possible with the help of the dynamic cast operator: <br><pre> <code class="cpp hljs">bar (B* b) { D* d = dynamic (D*) b; A* a = dynamic (A*) b; <span class="hljs-comment"><span class="hljs-comment">// not a downcast, but still OK }</span></span></code> </pre><br>  Dynamic coercion is possible due to the validator contained in the index, and hence the type information.  In addition to dynamic casting, Jancy also offers a dynamic sizing operation that is available from the same validator - although this is not related to the security of pointers, in certain situations it is very convenient: <br><pre> <code class="cpp hljs">foo (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = dynamic <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (*p); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count = dynamic countof (*p); } <span class="hljs-comment"><span class="hljs-comment">//... bar () { int a [100]; foo (a); }</span></span></code> </pre><br></div></div><br>  Dear habrovchenie invited to play with our <a href="http://tibbo.com/jancy/live_demo.html">online-compiler</a> and actually try out how it all works (read: try to slip the compiler an example of a script with pointers that dump it;) <br><br>  Read more about pointers in Jancy here: <a href="http://tibbo.com/jancy/features/pointers.html">http://tibbo.com/jancy/features/pointers.html</a> <br><br><h1>  Automaton functions </h1><br>  Safe pointers and address arithmetic are ideal for parsing and generating binary packages: <br><pre> <code class="cpp hljs">dissectEthernet (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* p) { io.EthernetHdr <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* hdr = (io.EthernetHdr <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*) p; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (hdr.m_type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EthernetType.Ip: dissectIp (hdr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EthernetType.Ip6: dissectIp6 (hdr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EthernetType.Arp: dissectArp (hdr + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  But there is another class of protocols ‚Äî protocols that do not rely on binary headers and instead use some kind of query / response language.  In this case, to parse IO streams, you need to write a parser for this language.  Thus it is necessary to attend to the preliminary buffering of data - often there is no guarantee that the transport delivered the message in its entirety, and not in pieces. <br><br>  Since this task is typical in IO programming, Jancy offers a built-in tool for solving it.  The Jancy automatons are designed to facilitate the first and most routine stage of writing any parser ‚Äî the creation of a lexer / scanner.  It works on the principle of well-known lexer-generators such as <a href="http://en.wikipedia.org/wiki/Lex_(software)">Lex</a> , <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a> , <a href="http://www.complang.org/ragel/">Ragel</a> : <br><pre> <code class="cpp hljs">jnc.<span class="hljs-function"><span class="hljs-function">AutomatonResult automaton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jnc.Recognizer* recognizer)</span></span></span><span class="hljs-function"> </span></span>{ %% <span class="hljs-string"><span class="hljs-string">"getOption"</span></span> createToken (Token.GetOption); %% <span class="hljs-string"><span class="hljs-string">"setOption"</span></span> createToken (Token.SetOption); %% <span class="hljs-string"><span class="hljs-string">"exit"</span></span> createToken (Token.Exit); %% [_\w][_\w\d]* createToken (Token.Identifier, recognizer.m_lexeme); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Inside the automaton function, a list of recognized lexemes in the form of regular expressions is described.  After the description of each token, there is a block of code that must be executed when it is detected in the input stream.  This whole kitchen is compiled into a table DFA, the state of which is stored in an external jnc.Recognizer object (a pointer to this object is passed in the recognizer argument).  In it, the characters of the potential lexeme accumulate, and it also implicitly calls our automaton function, while performing the necessary transitions between states. <br><br>  The aggregate of the automaton function and this control recognizer is our lexer.  At the same time, this lexer will be incremental, that is, able to parse messages coming in parts: <br><pre> <code class="cpp hljs">jnc.<span class="hljs-function"><span class="hljs-function">Recognizer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recognizer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scanRx)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// create recognizer object try { recognizer.write ("ge"); recognizer.write ("tOp"); recognizer.write ("tion"); recognizer.eof (); // notify recognizer about eof (this can trigger actions or errors) catch: // handle recognition error }</span></span></code> </pre><br>  Note that, as in Ragel, it is possible to switch between different automaton functions, which allows, in particular, to create context-sensitive keywords (or, to put it differently, to parse a multi-language input). <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jnc.<span class="hljs-function"><span class="hljs-function">AutomatonResult automaton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanGlobal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jnc.Recognizer* recognizer)</span></span></span><span class="hljs-function"> </span></span>{ %% <span class="hljs-string"><span class="hljs-string">'#'</span></span> recognizer.m_automatonFunc = scanPreprocessor; <span class="hljs-comment"><span class="hljs-comment">// switch to pp-specific keywords // ... } jnc.AutomatonResult automaton scanPreprocessor (jnc.Recognizer* recognizer) { %% "if" createToken (Token.If); %% "ifdef" createToken (Token.Ifdef); // ... %% '\n' recognizer.m_automatonFunc = scanGlobal; // switch back }</span></span></code> </pre></div></div><br>  Automaton functions on the one hand, and safe pointers with address arithmetic on the other, make it easy to parse protocols and IO streams of any type. <br><br><h1>  Conclusion </h1><br>  Despite the fact that user interface programming (UI) is not Jancy‚Äôs main purpose at the moment, we would still like to demonstrate the approach to reactive programming that is used in Jancy - I think we managed to find the optimal compromise in the coexistence of imperative and declarative started in reactive programming.  A story about this will go in the next article. <br><br>  In the meantime, we invite you to try out the features of the Jancy language (as described in this article, as well as many others) on the <a href="http://tibbo.com/jancy/live_demo.html">live</a> page of the <a href="http://tibbo.com/jancy/live_demo.html">compiler's live demo</a> .  You can also download, compile and play with the Jancy JIT compiler library and examples of its use - all of this is available on the <a href="http://tibbo.com/jancy/downloads">downloads</a> page. </div><p>Source: <a href="https://habr.com/ru/post/258427/">https://habr.com/ru/post/258427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258411/index.html">GammaRay - a means of introspection Qt-applications</a></li>
<li><a href="../258413/index.html">Luwrain - a working environment for people with visual impairments</a></li>
<li><a href="../258415/index.html">Recalculation of images for different cartographic projections in webGL</a></li>
<li><a href="../258419/index.html">10 networking tips for people who hate it</a></li>
<li><a href="../258423/index.html">PSR-7 adopted</a></li>
<li><a href="../258429/index.html">.NET-conference. NEXT 2015 Piter: A short tour of the reports - part 1</a></li>
<li><a href="../258431/index.html">More IT professions for kids, even more</a></li>
<li><a href="../258433/index.html">We test Chinese iron and find out how cheap and angry it is</a></li>
<li><a href="../258437/index.html">Dagaz: Kicks to common sense (part 7)</a></li>
<li><a href="../258439/index.html">The new issue of the magazine "Radio Annual" number 35 (2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>