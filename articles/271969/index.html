<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lightweight Parser Designer with Interactive Mode</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodically faced with small puzzles to develop simple text analyzers, I decided to automate this task, and the academic interest did not give rest. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lightweight Parser Designer with Interactive Mode</h1><div class="post__text post__text-html js-mediator-article">  Periodically faced with small puzzles to develop simple text analyzers, I decided to automate this task, and the academic interest did not give rest.  Initially I looked in the direction of <b>Racc</b> (one of the interpretations of <a href="https://ru.wikipedia.org/wiki/Yacc">Yacc</a> ), but it seemed to me not enough for a simple solution for my small tasks and then I decided to develop my own simple analyzer.  Although, of course, if you are developing a compiler or something like that and still on an industrial scale, then you should definitely look in the direction of <b>Racc</b> . <br><br>  But if you want to figure out for yourself what a parser is and how quickly you can write it yourself, without reading a bunch of articles about lexical analyzers like a dragon book, then go ahead under the cat (although the book is very good). <br><a name="habracut"></a><br><h3>  Input flow analysis </h3><br>  If we consider the task of analyzing the input stream in a very abstract way, and I think we should start with this, then it all comes down to the implementation of the finite state machine, i.e.  state machines, where the condition for the transition to a certain state is the presence in the input stream of the necessary data (hereinafter referred to as templates).  In turn, the transition to the state can be performed only when the unique characters and the full match of the characters in the input stream with a specific template, why unambiguous, because  transition from one state to several states at once is possible and while the input symbols of the stream coincide with several state patterns simultaneously, the analyzer is in a state of uncertainty.  Based on the foregoing, the analyzer itself may be in the following states: <br><br><ul><li>  state of certainty. </li><li>  state of not certainty. </li><li>  state change. </li></ul><br>  Of course, erroneous states are possible, but since  we consider the generalized model of the analyzer and do not know on which sets of characters an error should be issued, then this task falls on the shoulders of a specific implementation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In a state of certainty, we know exactly which state handler we need to call, but in a state of uncertainty, we don‚Äôt know what the next state will be, i.e.  which template will be a match or eventually there will be no one-to-one match, then in this case we should buffer the input stream and then transfer the characters from the accumulated buffer to an already defined state, i.e.  in case of uncertainty, we buffer the input stream and already in the state change mode we must transfer the buffer data to a new state or return the current one if the transition has not happened. <br><br>  Now, you can decompose, or more precisely, the detailing of the process of analyzing the input stream to: <br>  classification of the input stream (coincides with one, with many and does not coincide with any template) and processing the result of the classification (transition, buffering, etc.). <br><br><h3>  Implementation </h3><br>  Although, in my main occupation, I am an embedded system developer and my main programming language is ANSI C, I decided to implement this model in Ruby, because  on it you think less about the technical details of the implementation and planned to implement this model as Ruby Gem.  I really love everything universal (within certain limits), short and concise.  In the future, I plan to implement this model in emdedded for the input traffic analyzer, but in a more simplified form and possibly on HDL. <br><br>  So, let's start, I repeat, Ruby doesn‚Äôt know very deeply, so I relied on the accumulated experience and precise algorithmization of the process in my head, therefore I considered that my knowledge of Ruby is quite enough for this, as my music teacher once said: ‚ÄúLearn to improvise and make music on three-five notes, and then you will thrash the steep passages, otherwise your continuous arpeggio is not possible to listen‚Äù.  Sometimes, remembering him, now I think that he was right, although then I wanted cool solyak, okay, let's go back to the topic. <br><br>  I think the development process should go in stages, and the stages should be ‚Äútangible‚Äù, i.e.  you need to understand what needs to be done to implement this stage and in what amounts (complexity), I‚Äôll not go deep about this now, not this topic of our conversation, but to implement the parser, its build-up and testing should go on gradually building up the code with each state.  And here I could not do without interactive mode, if someone uses my gem, I think he should also initially debug the behavior of his model in interactive mode, and only then write parser state handlers. <br><br><h3>  Example </h3><br>  For greater clarity, I will give an example of the implementation of a simple source file parser for the automatic generation of documentation, remotely resembling doxygen.  Initially, I need to install my gem: <br><br><pre><code class="bash hljs">$ gem install iparser</code> </pre> <br>  As you already understood, the gem is called <b>iparser</b> and after its installation we will create a file named 'parser_example.rb', in which we will write the code of our parser based on <b>iparser</b> .  First of all, we connect the library and create a parser machine object that implements the main logic of the analyzer, i.e.  copy of the parser itself: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iparser'</span></span> parser = Iparser::Machine.new</code> </pre><br>  The next step is to describe the state of the parser.  We will have a very simple parser and it will have only three states: <br><br><ul><li>  initial (idle). </li><li>  single-line comments (comment-line). </li><li>  multiline comments (comment-block). </li></ul><br>  Now we can describe each state separately (I will give the script code as a whole below).  The state of 'idle' I will not describe in detail, because  in our case, it is empty, and the state of 'comment-line' will be considered closer.  To create an instance of the state, use the following code: <br><br><pre> <code class="ruby hljs">ps_idle = Iparser::State.new(<span class="hljs-string"><span class="hljs-string">'idle'</span></span>) ps_cline = Iparser::State.new(<span class="hljs-string"><span class="hljs-string">'comment-line'</span></span>)</code> </pre><br>  In the parameters of the state constructor, you specify a string with the name (identifier) ‚Äã‚Äãof the state, preferably understandable to you, since  used for remote debugging of the model.  Each parser state object has an <b>entry</b> field, this is a pattern that matches the transition to this state, i.e.  condition entry state.  Comparison with the template is performed character-by-character, as well as processing the input stream.  Entry to the state will be made in the presence in the input stream of characters '\\\', going in a row.  There is also a <b>leave</b> field to specify a pattern to exit the state (return to the previous one), in our case these are the end of line '\ n \ r' characters, although it is enough to indicate the first one, but for clarity, we will indicate both.  Now we will describe the 'comment-line': <br><br><pre> <code class="ruby hljs">ps_cline.entry &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\//</span></span> ps_cline.entry &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\//</span></span> ps_cline.entry &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\//</span></span> ps_cline.leave &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/[\n\r]/</span></span></code> </pre><br>  Please note that patterns are set using regular expressions, you can and without them, but this later. <br><br>  Next, create a state for processing multi-line comments, we will get into it when we meet the characters '/ **', and leave it if there is a '* /'.  Also write: <br><br><pre> <code class="ruby hljs">ps_cblock = Iparser::State.new(<span class="hljs-string"><span class="hljs-string">'comment-block'</span></span>) ps_cblock.entry &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\//</span></span> ps_cblock.entry &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\*/</span></span> ps_cblock.entry &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\*/</span></span> ps_cblock.leave &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\*/</span></span> ps_cblock.leave &lt;&lt; <span class="hljs-regexp"><span class="hljs-regexp">/\//</span></span> ps_cblock.ignore &lt;&lt; <span class="hljs-string"><span class="hljs-string">'*'</span></span></code> </pre><br>  We also specified characters that should be ignored while in this state.  We have a star symbol, because  I like to write multiline comments like: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * ... */</span></span></code> </pre><br>  Now we should link our three states into a single chain, from 'idle' we can get into 'comment-line' and 'comment-block', and only one of them back into 'idle'.  Linking is performed by specifying state indexes in the <b>branches</b> field of each of the states.  The index will be determined by the order of adding state objects to the parser instance; the addstate parser method is used to add objects to the parser. <br><br><pre> <code class="ruby hljs">ps_idle.branches &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ps_idle.branches &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> parser.addstate ps_idle parser.addstate ps_cline parser.addstate ps_cblock</code> </pre><br>  And finally, we need to check whether we have correctly created a chain of states, for this we will launch an interactive mode (the <b>prestart</b> method <b>will</b> set all initial parameters): <br><br><pre> <code class="ruby hljs">parser.prestart parser.interactive_parser</code> </pre><br>  For greater clarity, I will give the script code as a whole, of course, I rearranged it a bit, but it contains only the code I wrote above: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iparser'</span></span> <span class="hljs-comment"><span class="hljs-comment"># # Create parser-machine object. # parser = Iparser::Machine.new # # Create startup state for this parser-machine. # ps_idle = Iparser::State.new('idle') # # Add branch indexes to 'comment-line' and 'comment-block' state. # ps_idle.branches &lt;&lt; 1 ps_idle.branches &lt;&lt; 2 # # Create single line comment state for this parser-machine. # ps_cline = Iparser::State.new('comment-line') ps_cline.entry &lt;&lt; /\// ps_cline.entry &lt;&lt; /\// ps_cline.entry &lt;&lt; /\// ps_cline.leave &lt;&lt; /[\n\r]/ # # Create multiline comment state for this parser-machine. # ps_cblock = Iparser::State.new('comment-block') ps_cblock.entry &lt;&lt; /\// ps_cblock.entry &lt;&lt; /\*/ ps_cblock.entry &lt;&lt; /\*/ ps_cblock.leave &lt;&lt; /\*/ ps_cblock.leave &lt;&lt; /\// ps_cblock.ignore &lt;&lt; '*' # # Add all states to parser-machine. # parser.addstate ps_idle parser.addstate ps_cline parser.addstate ps_cblock # # Call parser startup method. # parser.prestart # # Call interactive mode for check state-machine. # parser.interactive_parser</span></span></code> </pre><br>  Not so big code, now run the script: <br><br><pre> <code class="bash hljs">$ ruby parser_example.rb</code> </pre><br>  To exit the interactive mode, you must enter an empty line (just press <b>enter</b> immediately). <br><br>  Enter '\\\' and see that on the last character the parser goes into the state of 'comment-line' ( <b>branch to comment-line</b> ), now enter '\ n' or '\ r' and see that the parser goes back to the 'state idle '( <b>back</b> ).  The character '\' is used to enter esc-characters, respectively, to enter the character '\' you need to type it twice '\\', as well as when specifying strings in C and other languages.  In interactive mode, you can mess around as much as you like, until you are sure that the chain of all states is connected correctly. <br><br>  The final stage, considering that we checked and debugged the logic of transitions of our machine, you can add handlers for our states (and only now, because I wrote above about the development process), they will be quite simple.  Each state can have three handlers: <br><br><ul><li>  init: state initializer (state constructor). </li><li>  handler: state handler. </li><li>  fini: state finalizer (state destructor). </li></ul><br>  The state constructor will be called only once upon entering the state and will receive as an argument an array of buffered characters that the parser has accumulated while in the uncertainty mode.  The handler will be called continuously and will receive the input symbol as an argument, until it leaves the state, and the destructor will be called only once when leaving the state. <br><br>  The handler method can also control the operation of the parser, although it may be that I implemented it for nothing, while there is, then it is necessary to describe.  If the handler returns the data type <b>Fixnum</b> whose value is within (&gt; = 0), then it will be interpreted as an index to go into some state, if the index goes beyond the state array, the parser will throw an exception.  If the handler returns <b>nil</b> , the parser will hold this state, i.e.  there is no reaction and if any other value, then it is regarded as an error and the parser returns <b>false</b> , which signals a parsing error, because  in all other cases, it returns <b>true</b> .  Below I will give the modified code completely, because  it seems that I have tried to describe everything in detail. <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iparser'</span></span> <span class="hljs-comment"><span class="hljs-comment"># # Simple check startup arguments. # if( ARGV.size != 1 || !File.exist?(ARGV[0]) ) puts puts "ERROR: unable to open file #{ARGV[0]}" puts exit end # # Create output file. # $fout = File.new( 'index.html', 'w' ) # # Create initializer method for parser-states. # def doc_init ( str ) $fout.print "&lt;p&gt;" end # # Create handler method for parser-states. # def doc_handler ( c ) $fout.print c end # # Create finalizer method for parser-states. # def doc_fini ( str ) $fout.puts "&lt;/p&gt;" end # # Create parser-machine object. # parser = Iparser::Machine.new # # Create startup state for this parser-machine. # ps_idle = Iparser::State.new('idle') # # Add branch indexes to 'comment-line' and 'comment-block' state. # ps_idle.branches &lt;&lt; 1 ps_idle.branches &lt;&lt; 2 # # Create single line comment state for this parser-machine. # ps_cline = Iparser::State.new('comment-line') ps_cline.entry &lt;&lt; /\// ps_cline.entry &lt;&lt; /\// ps_cline.entry &lt;&lt; /\// ps_cline.leave &lt;&lt; /[\n\r]/ # # Create multiline comment state for this parser-machine. # ps_cblock = Iparser::State.new('comment-block') ps_cblock.entry &lt;&lt; /\// ps_cblock.entry &lt;&lt; /\*/ ps_cblock.entry &lt;&lt; /\*/ ps_cblock.leave &lt;&lt; /\*/ ps_cblock.leave &lt;&lt; /\// ps_cblock.ignore &lt;&lt; '*' # # Add handlers for states. # ps_cline.init( method(:doc_init) ) ps_cline.handler( method(:doc_handler) ) ps_cline.fini( method(:doc_fini) ) ps_cblock.init( method(:doc_init) ) ps_cblock.handler( method(:doc_handler) ) ps_cblock.fini( method(:doc_fini) ) # # Add all states to parser-machine. # parser.addstate ps_idle parser.addstate ps_cline parser.addstate ps_cblock # # Call parser startup method. # parser.prestart # # Call interactive mode for check state-machine. # $fout.puts "&lt;html&gt;" $fout.puts "&lt;body&gt;" File.open( ARGV[0], 'r' ).each do |line| line.each_char do |c| parser.parse(c) end end $fout.puts "&lt;/body&gt;" $fout.puts "&lt;/html&gt;" $fout.close</span></span></code> </pre><br>  Yes, note that our handler (doc_handler) does not return <b>nil</b> , since  we do not analyze the result of the parser (method <b>parser.parse</b> ).  For the last check we will create a test file with the name 'test.c' and fill it with the following contents: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; ///Test function - 1. void test1 ( void ) { } /** * Test function - 2. */ void test2 ( void ) { }</span></span></span></span></code> </pre><br>  Run our script for the last time and see the result of our parser. <br><br><pre> <code class="bash hljs">$ ruby parser_example.rb test.c</code> </pre><br>  This is the file 'index.html', that's all, thank you all for your attention! <br><br>  I hope that someone will help and reduce the time to learn the basic principles of analyzers, and maybe someone will want to use my gem for personal purposes without finding a simpler option, if you didn‚Äôt like it, don‚Äôt kick much, although of course, criticize After all, one cannot become a good creator without good criticism, either.  If anyone is interested, here is a link to gem <a href="https://rubygems.org/gems/iparser">iparser</a> . </div><p>Source: <a href="https://habr.com/ru/post/271969/">https://habr.com/ru/post/271969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271957/index.html">Systemd and Containers: Introduction to systemd-nspawn</a></li>
<li><a href="../271959/index.html">NetApp ONTAP: UNMAP in the SAN environment</a></li>
<li><a href="../271961/index.html">Reliability and durability of server hardware</a></li>
<li><a href="../271963/index.html">Security audit on the server. Search by security magazine. Power powershell</a></li>
<li><a href="../271965/index.html">Practical aspects of automatic generation of unique texts for SEO</a></li>
<li><a href="../271971/index.html">Announcement of online courses Technopark, Technosphere and Technotrack on Stepic</a></li>
<li><a href="../271977/index.html">Recognition of the Burmese language: now we can even</a></li>
<li><a href="../271979/index.html">How did we do Linux-penguins for the New Year</a></li>
<li><a href="../271981/index.html">New malicious campaign Dridex led to a large number of infections in Europe</a></li>
<li><a href="../271983/index.html">Linux, delayed driver loading and broken interrupts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>