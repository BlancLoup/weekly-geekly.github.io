<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Diagnosing and fixing memory leaks in TypeScript applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Recently, we have completed a large project with a rather complicated advanced UI. Without going into details, let's say that inside th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Diagnosing and fixing memory leaks in TypeScript applications</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br><img src="https://habrastorage.org/files/820/51d/c82/82051dc821e1402d9a7aa797c3a4a610.jpg" align="left">  Recently, we have completed a large project with a rather complicated advanced UI.  Without going into details, let's say that inside the browser something like desktop was implemented with windows, floors and everything that was supposed to.  Of course, problems with memory leaks did not bypass us.  Frankly, for the time being focused on getting a business result.  When the hands reached the memory leaks, it was found that the browser windows occupy gigabytes of RAM.  We have classified errors and, in general, have developed an approach to eliminate them.  We want to share this approach with you. <br><br>  Much has already been written on the topic of memory leaks in client applications.  Initially, the main problem consisted of browsers IE8 and lower versions (see, for example: <br>  <a href="http://habrahabr.ru/post/141451/">http://habrahabr.ru/post/141451/</a> <br>  <a href="http://habrahabr.ru/post/146784/">http://habrahabr.ru/post/146784/</a> <br>  <a href="https://learn.javascript.ru/memory-leaks">https://learn.javascript.ru/memory-leaks</a> ). <br>  But now, when it can be said that IE8 is in the past, problems remain.  Even the use of such a language as TypeScript does not guarantee their absence.  And given the fact that the front-end in web-based applications is becoming increasingly difficult, the urgency of the problem is only increasing. <br><a name="habracut"></a><br><br><h2>  Causes of errors </h2><br>  The main sources of leaks that we identified for ourselves were: <br><ul><li>  jQuery widgets </li><li>  Custom Knockout-bindings </li><li>  implementation of the publish-subscribe architecture </li><li>  use of Promises </li><li>  D3 </li><li>  Google maps </li></ul><br>  Looking ahead, we say that the last item caused the most problems.  Some of which, unfortunately, cannot be solved at all.  However, the negative effects here can be minimized. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Cleanup Handler Usage Template </h2><br>  We have identified the cleaning operations in a special module: <br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ed = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'disposing'</span></span>);</code> </pre> <br>  This module contains the ed.Disposables interface, which is essentially a tree of deletion event handlers associated with the displayed view.  It is assumed that these handlers will be registered when an object is created, i.e.  in the class constructor. <br>  See example: <br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapControl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( ‚Ä¶ private beDisposed : ed.Disposables //        ‚Ä¶ ) { ... beDisposed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">beDisposed</span></span></span><span class="hljs-function"> =&gt;</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//  } ); }</span></span></code> </pre><br><br>  When a part of the view is not needed, for example, when closing a model window, or leaving the page, a part of the tree should be deleted: <br><pre> <code class="hljs javascript">ulo.enableWindowUnloadTracking(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ed.disposeAll(beDisposed, <span class="hljs-string"><span class="hljs-string">'window unloading'</span></span>); ey.nullify(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ec.alwaysTrue); });</code> </pre><br>  Let's look at eliminating errors with this approach. <br><br><h3>  1. jQuery widgets </h3><br>  Although in modern life there is a certain tendency to abandon the jQuery library, in many cases one cannot do without it.  A huge role is played by the millionth army of widgets, many of which implement very important and useful features. <br>  A typical method of working with a widget is to ‚Äúwrap‚Äù it into a wrapper object, for example: <br><pre> <code class="hljs php">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toCheckbox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $element: JQuery, options: CheckboxOptions )</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JQuery</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $element.jqxCheckBox(options); }</code> </pre><br>  The problem is that after the widget has been constructed, a reference to the jQuery selector ($ element) is saved in the wrapper object.  Such a link can generate a circular dependency between the object and the corresponding DOM element.  Therefore, such a link should be ‚Äúcleaned up‚Äù when a memory cleaning mechanism is triggered.  In our case, a special function nullify is used for this, which is called for the jQuery selector and the ‚Äúnullification‚Äù of the reference to the jQuery selector: <br><pre> <code class="hljs bash"> //  -c jQuery- <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> toCheckbox( beDisposed: ed.Disposables, <span class="hljs-variable"><span class="hljs-variable">$element</span></span>: JQuery, options: CheckboxOptions ) : JQuery { ed.append(beDisposed, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disposeJqxCheckbox</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$element</span></span> != null) { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> instance = <span class="hljs-variable"><span class="hljs-variable">$element</span></span>.jqxCheckBox(<span class="hljs-string"><span class="hljs-string">'getInstance'</span></span>); //   jQuery- <span class="hljs-variable"><span class="hljs-variable">$element</span></span>.jqxCheckBox(<span class="hljs-string"><span class="hljs-string">'destroy'</span></span>); // <span class="hljs-string"><span class="hljs-string">''</span></span>  jQuery- ed.nullify(instance, 1); // <span class="hljs-string"><span class="hljs-string">''</span></span>  <span class="hljs-variable"><span class="hljs-variable">$element</span></span> = null; options = null; beDisposed = null; } }); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$element</span></span>.jqxCheckBox(options); }</code> </pre><br>  Thus, we eliminate all opportunities for the widget, and its DOM representations to remain "not cleansed". <br><br><h3>  2. Custom Knockout-bindings </h3><br>  In general, wherever DOM elements appear, it is necessary to closely monitor leaks.  Since the main purpose of Konckout is to interconnect the model and the view, it is important to carefully manage the DOM elements. <br><br>  In the following example, the object will ‚Äúhang‚Äù in memory, because  binds its event handling to the DOM element: <br><pre> <code class="hljs javascript">init: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element: HTMLElement, ‚Ä¶</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> beDisposed = xko.toBeDisposed(element); $(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).on(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, <span class="hljs-string"><span class="hljs-string">'input,textarea,select'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ $(element).on(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, <span class="hljs-string"><span class="hljs-string">'input, textarea, select'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ ... }); }); }</code> </pre><br>  Therefore, you need to untie them accordingly: <br><pre> <code class="hljs javascript">init: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element: HTMLElement, ‚Ä¶</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> beDisposed = xko.toBeDisposed(element); $(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).on(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, <span class="hljs-string"><span class="hljs-string">'input,textarea,select'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ $(element).on(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, <span class="hljs-string"><span class="hljs-string">'input, textarea, select'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ ... }); }); ed.appendUntied(beDisposed, () =&gt; { $(element).off(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>); $(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).off(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>); }); }</code> </pre><br><br><h3>  3. Implementation of publish / subscribe architecture </h3><br>  The publish / subscribe architecture is a typical technique for reducing connectivity.  In our project, such a technique was implemented in the form of signals (Signals).  Problems here can be caused by the absence of a reply from existing signal handlers after the object has already been deleted.  If the code contains a subscription to an event, then there must be an unsubscribe from it.  The lack of a formal reply is fraught with large leaks, especially if the callback function contains references to objects with a short lifespan.  We illustrate this with an example of using a signal followed by a reply to the click event of the specified html element: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Button</span></span></span><span class="hljs-class"> implements ucb.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Component</span></span></span><span class="hljs-class"> { //  ,             public justClicked = es.toActSignal(); private noMoreOpt : () =&gt; void = null; constructor( //        </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beDisposed</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ed</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Disposables</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stopPropogation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">boolean</span></span></span><span class="hljs-class"> ) { ‚Ä¶ } attach(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HTMLButtonElement</span></span></span><span class="hljs-class">): void { //         click html-,        this.noMoreOpt = ue.listenToUntil( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beDisposed</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">click'</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MouseEvent</span></span></span><span class="hljs-class">) =&gt; { if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stopPropogation</span></span></span><span class="hljs-class">) { ue.stopEventPropagation(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocked</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">component</span></span></span><span class="hljs-class">.'); } //   this.justClicked(); } ); } detach(): void { //         if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noMoreOpt</span></span></span><span class="hljs-class"> != </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">) { this.noMoreOpt(); this.noMoreOpt = null; } } }</span></span></code> </pre><br>  In addition, note that when subscribing to an event, you also need to pass a link to the handler tree: <br><pre> <code class="hljs coffeescript">submit.justClicked.watchUntil(beDisposed, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   });</code> </pre><br><br><h3>  4. Promise and race conditions (race condition in client code) </h3><br>  It is not uncommon for javascript applications to make it necessary to use asynchronous operations, for example, accessing a server.  To solve such problems, as a rule, they use so-called Promises.  These can be either jQuery-promises or promises from the popular Q library. Regardless of which library is used, the ways of working with such objects are similar.  Using promises in itself is not difficult, but, depending on the scenario being implemented, side effects may occur, which can only be noticed with the help of debugging and analysis tools. <br>  Consider the case of so-called races or race conditions, using the following code as an example: <br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> some.willGetLegendImage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.beDisposed).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image)</span></span></span><span class="hljs-function"> =&gt;</span></span> { model.setLegendImage(image); });</code> </pre><br>  The problem here is that the calling code ignored the promise object returned by then (...) and, as a result, has no idea when the transferred function will end.  Execution of the function as if drops out of the main thread, and the objects used remain locked in memory until the callback.  In addition, it is possible that the function will work after deleting the original object, and we will get an exception of the form undefined. <br><br>  To get a more secure code, you need to return promise for later use: <br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     promise,     <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>.  promise   promise,   willGetLegendImage. var promise = some.willGetLegendImage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.beDisposed).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   model  callback-     model.setLegendImage(image); });</code> </pre><br>  Thus, you should always track the status of the original promises and always return the result of the then () call inherited from the original promises.  These objects can also be deleted using the delete event handler mechanism. <br><br><h3>  5. D3 library </h3><br>  To implement the requirements in our project, it became necessary to display graphs and charts that are difficult to implement with only html elements at our disposal.  Inspired by the capabilities of the D3 library, it was decided to use it for use in conjunction with SVG elements.  Despite the fact that the library's API is relatively simple, accompanied by well-developed documentation, and there are a lot of workable examples, in the context of our application, a set of nuances has arisen that I would like to mention. <br><br><h4>  5.1.  D3 Updated Selection </h4><br>  Using D3 to display such things as graphics, charts, and other related elements (for example, the chart axis) turned out to be quite easy.  And due to the presence of its own data binding mechanism, the code for updating the views looked readable and concise.  However, typical techniques for using D3 had to be diluted with functionality for cleaning the removed elements. <br><br>  It is logical to assume that when updating data you can get a subset of svg-elements that can not be compared with the updated data, in other words, they become unnecessary.  Often, when constructing a representation, the elements of which it consists, can be used by other components and such elements definitely need to be somehow cleaned before being removed.  After binding to the data, we get the object D3 UpdatedSelection.  Such an object has an exit () method that allows access to a subset of the elements to be deleted.  The method returns an array of elements, iterating over which in the loop, you can execute the cleanup code.  If there is no such functionality and somewhere there are links to a previously generated element, then later you can find DOM elements (so called detached DOM elements) that are hanging in memory. <br>  For example, we have an idea from markers - points on the map, where each point is defined by its coordinates: <br><pre> <code class="hljs lua">//     var markers = this.layer.selectAll(<span class="hljs-string"><span class="hljs-string">'svg.marker'</span></span>) .data(dataItems, d =&gt; d.itemId); //       markers.enter() .append(<span class="hljs-string"><span class="hljs-string">'svg'</span></span>) .classed(<span class="hljs-string"><span class="hljs-string">'marker'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> { transform.call(this, data, paddingLeft, paddingTop); }); .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: DataItem)</span></span></span></span> { //   renderMarker.call(this, data, that.renderOptions); }) //        SelectManager,        markers.each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> { var element = d3.<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>(this).node(); var markerElement = $(element).<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'circle, polygon'</span></span>).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); //      <span class="hljs-built_in"><span class="hljs-built_in">select</span></span>.attach(markerElement, dragObjectFrom); }) //       DOM-      SelectManager markers.<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var element = d3.<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>(this).node(); var markerElement = $(element).<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'circle, polygon'</span></span>).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); //   <span class="hljs-built_in"><span class="hljs-built_in">select</span></span>.detach(markerElement); }) .<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(); // , ,  </code> </pre><br>  Note also that such dangling elements, it makes sense to delete immediately in the process of redrawing, and not when deleting the subtree of representations. <br><br><h4>  5.2.  D3 Events </h4><br>  D3 provides its own abstraction for working with events.  The need to use events via D3 may arise, for example, when data is bound, or when using d3.behaviors (drag, move, zoom, and the like). <br>  If it is assumed that the view should handle events, then code should be present that executes the existing event handlers from the events.  Removal of the handler is done simply: we specify the string constant as the name of the event and pass the null handler function instead: <br><pre> <code class="hljs pgsql">//     d3 UpdatedSelection selection.datum(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) //     click, dblclick  mousedown: .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'dbclick'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) //   ,   d3 drag behavior: .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'drag'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'dragstart'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'dragend'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'zoom'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre><br>  This code, of course, can and should be placed inside an object deletion handler. <br><br><h3>  6. Google Map </h3><br><h4>  6.1.  Specificity of the life cycle of the Map object </h4><br>  With all the advantages of this component, it is necessary to take into account the peculiarities of the life cycle of the map object: once you create an instance of the Map object, you cannot delete it.  The Google Map API does not provide a destructor function for this object.  This aspect is discussed in more detail here: <a href="https://code.google.com/p/gmaps-api-issues/issues/detail%3Fid%3D3803">https://code.google.com/p/gmaps-api-issues/issues/detail?id=3803</a> . <br>  It is necessary from the very beginning to take into account this nuance in the architecture of the application, in order to avoid unwanted memory leaks. <br><br>  Therefore, in order to minimize memory leaks, the developer is simply obliged to take care of the careful use of such a specific object. <br><br>  Depending on the specifics of the application, it may be recommended to reuse the once created instance of the map, if it is one.  Or to have a pool of map objects, if you need to simultaneously work with several maps. <br><br><h4>  6.2.  Work with map events and map objects </h4><br><ul><li>  When using map events, by analogy with DOM events, the subscription field must be stored in an internal variable reference to the cleanup code function.  Calling such a function must be placed in the cleanup code of the component. </li><li>  When creating map objects (points, lines, rectangles, etc.), you need to clear the associated data, ‚Äúzero‚Äù references to markers, unsubscribe from events, and delete layer data in the component cleanup code: </li></ul><br><pre> <code class="hljs ruby">import ed = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'disposing'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       disposing,     ed ‚Ä¶ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapControl</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dispatch</span></span></span><span class="hljs-class">: { ‚Ä¶ };</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/   (d3) constructor( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        private beDisposed : ed.Disposables, ‚Ä¶ ) { ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ed.append(beDisposed, () =&gt; { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      this.mapEventsListeners.forEach(listener =&gt; google.maps.event.removeListener(listener)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     () google.maps.event.clearInstanceListeners(this.map); this.map.unbindAll(); ea.use(this.markers, (marker: google.maps.Marker) =&gt; { marker.setMap(null); marker = null; }); this.markers = null; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   DOM-,   () var element = this.map.getDiv(); ea.use( ud.toNodeArray(element.getElementsByTagName('img')), (image: HTMLImageElement) =&gt; { image.src = ''; } ); ko.cleanNode(element, 'map-control'); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ''     this.map = null; }); } }</span></span></code> </pre><br>  As can be seen from the above example, we first unsubscribe from the events, and then clear the map objects. <br><br><h2>  Instead of conclusion </h2><br>  In conclusion, we want to say a few words about the toolkit that was used to diagnose leaks. <br><ul><li>  For IE, there is a description of the tools and how to apply them directly on MSDN: <a href="https://msdn.microsoft.com/en-us/library/dn255003(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/dn255003(v=vs.85).aspx</a> </li><li>  For Google Chrome, go here: <a href="http://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/">http://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/</a> </li><li>  It is also a good article from Yandex <a href="http://habrahabr.ru/company/yandex/blog/195198/">http://habrahabr.ru/company/yandex/blog/195198/</a> , which details the process from monitoring the amount of free memory to directly eliminating errors. </li></ul><br><br>  <b>PS</b> We showed what we faced and how we solved these problems.  If you have a similar experience, we will be happy to find out about it, since a general approach to the problem, in our opinion, is still being developed. </div><p>Source: <a href="https://habr.com/ru/post/274185/">https://habr.com/ru/post/274185/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274175/index.html">Fourier transform boundedness or why you should trust your hearing</a></li>
<li><a href="../274177/index.html">12 best overseas developer conferences in 2016</a></li>
<li><a href="../274179/index.html">OpenOCD, GDB and (strongly) remote debugging</a></li>
<li><a href="../274181/index.html">Unit Tests in ABAP. Part Three Every kind of fuss</a></li>
<li><a href="../274183/index.html">How I searched (and found) the difference in two byte-identical files.</a></li>
<li><a href="../274187/index.html">Development Environment: Redmine + Git + ownCloud</a></li>
<li><a href="../274189/index.html">Does your site have problems with Google?</a></li>
<li><a href="../274191/index.html">New Year's check .NET Core Libraries (CoreFX)</a></li>
<li><a href="../274193/index.html">Draw together. Portrait of user IE 8 full face</a></li>
<li><a href="../274195/index.html">Direct disk access from python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>