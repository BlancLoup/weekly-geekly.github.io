<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hormonal holywar Admin and Development PHP or REMOTE_ADDR vs HTTP_X_FORWARDED_FOR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I witnessed one interesting dispute about how really you need to determine the IP address of the end user from PHP scripts. 
 Actually, each ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hormonal holywar Admin and Development PHP or REMOTE_ADDR vs HTTP_X_FORWARDED_FOR</h1><div class="post__text post__text-html js-mediator-article">  Recently I witnessed one interesting dispute about how really you need to determine the IP address of the end user from PHP scripts. <br>  Actually, each word sabzh displays the actual situation.  It was a religious debate, aggravated by spring wonderful weather, in which, I believe, there were no right and wrong, but which led me to a mini-study and, to my luck, put an end to understanding this confessional but in fact a very simple question. <br>  For those who, like me, I was sure that I understood everything, but I was <s>afraid to ask</s> if I was too lazy to understand the little things - under the cat. <br><a name="habracut"></a><br><br><h3>  Prehistory </h3><br>  Being engaged in the development of VOD service for Samsung SmartTV platform, we certainly need to know the user's country, so that inadvertently not showing a happy user a movie where the copyright holder prohibits ... missteps). <br>  <i>[The question, as noted in the comments, Legal, and fraud is possible, but the article is not even about how to try to prevent such fraud, but about how to make friends with php and nginx]</i> <br><br>  On the server we have the following: php-fpm + nginx 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      How to determine the country?  Well, of course through the user's IP and GEO IP database <a href="http://www.maxmind.com/">maxmind</a> <br>  "Pfff ...." - <s>it</s> seemed to <s>all of</s> us - yes, simpler than simple.  And in order not to write my bike, <a href="http://stackoverflow.com/questions/55768/how-do-i-find-a-users-ip-address-with-php">google stackoverflow</a> , <b>even penetrated</b> into each line, screwed it and left it there as the code grew: <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserHostAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($_SERVER[<span class="hljs-string"><span class="hljs-string">'HTTP_X_REAL_IP'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">//check ip from share internet { $ip=$_SERVER['HTTP_X_REAL_IP']; } elseif (!empty($_SERVER['HTTP_CLIENT_IP'])) //check ip from share internet { $ip=$_SERVER['HTTP_CLIENT_IP']; } elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) //to check ip is pass from proxy { $ip=$_SERVER['HTTP_X_FORWARDED_FOR']; } else { $ip=$_SERVER['REMOTE_ADDR']; } return $ip; }</span></span></code> </pre> <br><br>  And everything worked!  Almost a year ... until something unexpected happened.  Naturally unexpected for this code ... <br><br><h3>  How to confuse php or proxy chain (still part of history) </h3><br>  It broke!  And this happened when we had to screw one of the payment systems and all this code collapsed because in HTTP_X_FORWARDED_FOR not one address came, but a comma-separated list of addresses (which is strictly speaking legal, acceptable, and not even regulated in a <a href="http://www.php.net/manual/en/reserved.variables.server.php">php dock</a> ) <br>  And no one would have noticed if HTTP_X_REAL_IP or HTTP_CLIENT_IP (which is also not regulated by the dock) contained the IP you were looking for, but alas, they were empty :( <br><br>  ‚ÄúWell, okay‚Äù - we thought (now I was no longer alone), we would rewrite everything and ask the admins to push the user IP into the variable REMOTE_ADDR: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserHostAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ $ip=$_SERVER[<span class="hljs-string"><span class="hljs-string">'REMOTE_ADDR'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $ip; }</code> </pre><br><br>  And everything worked!  Almost a month ... until something unexpected happened.  Naturally unexpected for this code ... <br><br><h3>  Spring dispute tough men (this is not irony - they are cool) </h3><br>  It broke!  This happened because we had to update nginx.  And we turned to the professionals in this business - to our admins. <br>  And those, in turn, decided to update the config and get rid of our ‚Äúcrutch / not crutch‚Äù (until we understood this) with a forwarding to REMOTE_ADDR. <br><br>  REMOTE_ADDR left unchanged i.  there now shone something like "127.0.0.1" <br>  in HTTP_X_FORWARDED_FOR, the user's IP was skipped (which, in the meantime, was easily overridden by sending the header `x-forwarded-for: 999.999.999.999` from the browser) <br>  And then it started - P = Developed, A = Admin: <br><br>  <b>A:</b> you have broken everything, and since we have a nginx proxy, then the address you need is in HTTP_X_FORWARDED_FOR and in REMOTE_ADDR there will be a real client IP address to php-fpm (ie, 127.0.0.1) <br>  <b>R:</b> but we cannot believe HTTP_X_FORWARDED_FOR, because this is a variable that can be easily redefined via the header to the server, referring to a very interesting <a href="http://www.phpfaq.ru/ip">article</a> <br>  <b>A:</b> No, we will do so that it will contain the real IP of the end user, and in REMOTE_ADDR the real client address to php <br>  <b>R:</b> then we don‚Äôt follow the sequence of proxies, and still for universalization on another server (say, no proxy) these configs may not be true, push everything into REMOTE_ADDR which will work in any case. <br><br>  ... it is brief and without mats ... <br><br>  As a result, of course, everything got started ... and we stopped at transparent proxying, when php thinks that clients connect to it directly without any proxies and all variables (or rather, the one to which we pay attention) are in the state we need. <br>  However, there is not enough feng shui in this matter, and in fact we <b>have a proxy</b> or maybe not one. <br><br><h3>  Who is to blame of them who is right </h3><br>  Judge us, but no one! <br><br>  If we really have a lot of clients directly to php, or transparent proxying, then everything is simple - use REMOTE_ADDR for health and enjoy. <br><br>  But what about the Feng Shui and where should it be if we use normal proxying and want PHP to know about it? <br><br><h3>  The recipe ... but not a panacea: </h3><br><ul><li>  <b>REMOTE_ADDR</b> - contains the IP address of the nginx directly accessing it, in our case 127.0.0.1 </li><li>  <b>HTTP_X_FORWARDED_FOR</b> - contains a chain of proxy addresses and the last is the IP of the <b>direct</b> client who accessed the proxy server.  And here we consider two special cases: <br><br><ul><li>  <i><b>Not cascading proxying.</b></i>  In HTTP_X_FORWARDED_FOR, the last or only IP address (depending on what the user sent / did not send in the x-forwarded-for header) will be the real, desired, same user address. <br><br>  It would seem well what the problem is to parse this variable and get the <b>last</b> element from there.  But in our case, the settings were not completely correct and the <b>entire</b> HTTP_X_FORWARDED_FOR was replaced with the header from the x-forwarded-for browser, but had to paste the real IP of the <b>direct</b> user to it. <br><br>  For example, checked on industrial vps hosting: <br><img src="https://habrastorage.org/storage2/fb4/db4/e23/fb4db4e23839ad4d0c6f80292b333598.jpg"><br>  It is also scary to trust such data, but if everything is done correctly in the settings, then the last IP will be the user's address, regardless of what comes in the headers. <br><br></li><li>  <i><b>Cascading proxying</b></i>  In this case, the HTTP_X_FORWARDED_FOR is really a chain of proxy addresses and the last is the IP of the direct client who accessed the proxy server.  But this is not the real IP of the user, but only the IP of the previous proxy in the list. <br><br>  It would seem well what the problem is to parse this variable and get the <b>first</b> element out.  But as it was shown above in the figure, this is certainly not the correct data and the user can mislead us in two accounts by sending to x-forwarded-for the first element that IP wants </li></ul><br></li><li>  <b>HTTP_X_REAL_IP</b> (or any other variable that <b>Admin</b> and <b>Razrab</b> agree <b>on</b> ) - contains the IP of the user accessing the php or the first <b>non-trusted</b> proxy from the server (which is equal to the client's address for us) <br><br>  For convenience, you can use a special <a href="http_realip_module.html">module for nginx</a> which eliminates the problems of determining cascade and non-cascade proxying, but it defaults to ‚Äúin standard assemblies of centos, debik and nginx fed, for some reason without the - with-http_realip_module parameter‚Äù (c) <b>Admin</b> , as well as for it the <b>chain</b> must be <b>correctly formed in</b> HTTP_X_FORWARDED_FOR and the addresses of <b>trusted</b> proxy servers are configured from which we can take the last element from HTTP_X_FORWARDED_FOR <br><br>  However, again, HTTP_X_REAL_IP is <b>not the real</b> IP of the end user <b>in general</b> , but only the first IP in the list of proxies during cascade proxying. <br>  Although if the proxying is not cascading, then there may be the address of the end user. <br>  And if the proxying is cascaded and the http_realip module is correctly configured, then there should be either the end user's IP or the correct IP of the <b>first untrusted</b> proxy from the php server, which is good for us too </li><li>  <b>HTTP_CLIENT_IP</b> (or any other variable that <b>Admin</b> and <b>Develop will</b> agree <b>on</b> ) contains the first IP from HTTP_X_FORWARDED_FOR for any type of proxying, and in the absence of proxying, the contents of the http client-ip header.  Which can be used for reference only.  <b>And in no case to determine the real IP of the user</b> . <br></li></ul><br><h3>  In custody </h3><br>  There are several proxying options for php + nginx <br><ul><li>  <b>Transparent</b> is characterized by the constant content of variables in _SERVER (including REMOTE_ADDR) as if we were working directly with php </li><li>  <b>Not transparent, not cascading</b> - it‚Äôs characteristic that the <b>Admin</b> and <b>Razrab</b> need to agree on where the real IP address of the user will be stored :) </li><li>  <b>Not transparent cascade</b> - the same is characteristic of <b>non-transparent non-cascade</b> + correctly configured <a href="http_realip_module.html">module for nginx</a> . Also, you should remember about the possibility of cascading proxying and that the user is evil and can send very erroneous data to _SERVER ["HTTP_xxxx"] </li></ul><br><br>  <b>PS</b> <br>  Later we will set up Feng Shui in the settings and get rid of transparent proxying, as well as write the universal function of determining IP for both cases of proxying. <br><br>  <b>Pps</b> <br>  For fun, who cares: if someone in the comments writes this function and the nginx config for us and we use it, then at fair word, he will get 100r on the phone. <br>  But this function and the config should be truly Orthodox and take into account everything :) all the clues are in the article. <br>  The main thing is Zen: take your time - suddenly the first ones will write with errors and you will take them into account, take your time - suddenly the first correct answer will be up to you. <br><br>  Thanks to all.  Have a nice spring!  Negotiate with colleagues and love them!  :) <br><br>  <b>UDP:</b> <br>  Own implementation: <br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> null|string $ip_param_name -   _SERVER,     IP  *       REMOTE_ADDR       , *     IP    , *    HTTP_X_REAL_IP    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> bool $allow_non_trusted - ,   $ip_param_name  *      _SERVER[$ip_param_name] *      _SERVER     $non_trusted_param_names * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $non_trusted_param_names -  ,     IP   _SERVER * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserHostAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $ip_param_name = null, $allow_non_trusted = false, array $non_trusted_param_names = array</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">'HTTP_X_REAL_IP'</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">,</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">'HTTP_CLIENT_IP'</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">,</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">'HTTP_X_FORWARDED_FOR'</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">,</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">'REMOTE_ADDR'</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($ip_param_name) || !is_string($ip_param_name)){ <span class="hljs-comment"><span class="hljs-comment">//       $ip = $_SERVER['REMOTE_ADDR']; }else{ //    if(!empty($_SERVER[$ip_param_name]) &amp;&amp; filter_var($_SERVER[$ip_param_name], FILTER_VALIDATE_IP)){ //      $ip = $_SERVER[$ip_param_name]; }else if($allow_non_trusted){ //           foreach($non_trusted_param_names as $ip_param_name_nt){ if($ip_param_name === $ip_param_name_nt) //      continue; if(!empty($_SERVER[$ip_param_name_nt]) &amp;&amp; filter_var($_SERVER[$ip_param_name_nt], FILTER_VALIDATE_IP)){ //      $ip = $_SERVER[$ip_param_name_nt]; break; } } } } if(empty($ip)) //      ip,     $_SERVER['REMOTE_ADDR'] -   throw new Exception("Can't detect IP"); return $ip; }</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/177113/">https://habr.com/ru/post/177113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177097/index.html">How does LTE cope with inter-cell interference</a></li>
<li><a href="../177099/index.html">Methods for assessing the subjective quality of speech</a></li>
<li><a href="../177105/index.html">Pichmongi and maglutes</a></li>
<li><a href="../177109/index.html">Formal languages ‚Äã‚Äãand grammar</a></li>
<li><a href="../177111/index.html">Marathon puzzles in C ++</a></li>
<li><a href="../177115/index.html">Comparing Angular, Backbone, CanJS and Ember</a></li>
<li><a href="../177117/index.html">Success in Indie: A Beginner's Guide</a></li>
<li><a href="../177121/index.html">Failsafe resource allocator over DHT</a></li>
<li><a href="../177125/index.html">"Beeline" is updated: first - a personal account. We invite you to beta tests</a></li>
<li><a href="../177127/index.html">Post of Russia, ban on receiving international mail in Sheremetyevo, take two, from April 18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>