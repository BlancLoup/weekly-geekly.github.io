<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use korutiny in prode and sleep well at night</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Korutiny - a powerful tool for asynchronous code execution. They work in parallel, communicate with each other and consume few resources. It would see...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use korutiny in prode and sleep well at night</h1><div class="post__text post__text-html js-mediator-article">  Korutiny - a powerful tool for asynchronous code execution.  They work in parallel, communicate with each other and consume few resources.  It would seem that without fear, you can introduce corutinas in production.  But there are fears and they interfere. <br><br>  The report by <strong>Vladimir Ivanov</strong> on <a href="http://appsconf.ru/">AppsConf</a> is just about the fact that the devil is not so bad and that it is possible to use Korutin today: <br><br><ul><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/429908/">why corutinos, not RxJava</a> ; </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/429908/">what fears interfere with developers</a> ; </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/429908/">how to make a cache using korutiny</a> ; </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/429908/">how to handle errors correctly</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About speaker</strong> : Vladimir Ivanov ( <a href="https://habr.com/users/dzigoro/" class="user_link">dzigoro</a> ) is a leading Android developer at <strong>EPAM</strong> with 7 years of experience, enjoys Solution Architecture, React Native and iOS development, and also has a <strong>Google Cloud Architect</strong> certificate. <br><a name="habracut"></a><br><blockquote>  Everything you read is a product of experience and various studies, so take it as it is, without any guarantees. <br></blockquote><h2><a name="coroutine"></a>  Korutin, Kotlin and RxJava </h2><br>  For information: the current status of Korutin - in the release, came out of Beta.  <strong>Kotlin 1.3</strong> was released, the Korutins were declared stable and world peace came. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  Recently, I conducted a survey on Twitter that people have been using Corutin: <br><br><ul><li>  13% of Korutin in Prode.  All is well; </li><li>  25% try them in the pet project; </li><li>  24% - What's Kotlin? </li><li>  The main mass in 38% RxJava everywhere. </li></ul><br>  Statistics are not happy.  I think that <strong>RxJava is too complicated tool</strong> for tasks in which it is usually used by developers.  Korutiny more suitable for managing asynchronous operation. <br><br>  In my previous reports, I told you how to refactor with RxJava on Korutina in Kotlin, so I will not dwell on this in detail, but only recall the main points. <br><br><h3>  Why do we use korutiny? </h3><br>  Because if we use RxJava, then the usual examples of implementation look like this: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  We have an interface, for example, we write a GitHub client and want to perform a couple of operations for it: <br><br><ol><li>  Log in user <br></li><li>  Get a list of GitHub repositories. <br></li></ol><br>  In both cases, the functions will return Single business objects: GitHubUser or a list of GitHubRepository. <br><br>  The implementation code for this interface is as follows: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - We take <strong>compositeDisposable</strong> , so that there is no memory leak. <br>  - Add a call to the first method. <br>  - Use convenient operators to get the user, for example <strong>flatMap</strong> . <br>  - Get a list of its repositories. <br>  - We write <strong>Boilerplate</strong> that it was carried out on the necessary flows. <br>  - When everything is ready - we show the list of repositories for the logged in user. <br><br>  <strong>RxJava code difficulties:</strong> <br><br><ul><li>  <strong>Complexity.</strong>  In my opinion, the code is too complicated for the simple task of two network calls and displaying something on the <strong>UI</strong> . </li><li>  <strong>Unbound stack traces.</strong>  Stack traces are almost unrelated to the code you write. </li><li>  <strong>Overuse of resources</strong> <strong>.</strong>  RxJava generates many objects under the hood and performance may decline. </li></ul><br>  <strong>What will be the same code with Korutins to version 0.26?</strong> <br><br>  In 0.26, the API has changed, and we are talking about production.  No one had time to apply 0.26 per product, but we are working on it. <br><br>  <strong>With Corutin our interface will change quite significantly</strong> .  Functions will stop returning any Singles and other helper objects.  They will immediately return the business objects: GitHubUser and the GitHubRepository list.  The GitHubUser and GitHubRepository functions will have <strong>suspend</strong> modifiers.  This is good, because suspend us almost does not commit to anything: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  If you look at the code that already uses the implementation of this interface, then it will change significantly compared to RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - The main action takes place where we call the <strong>coroutine builder async</strong> , wait for the answer and get <strong>userlnfo</strong> . <br>  - Use data from this object. <br>  - Make another call to <strong>async</strong> and call <strong>await</strong> . <br><br>  Everything looks as if no asynchronous work is happening, and we just write commands to the bar and they are executed.  In the end, we do what needs to be done on the UI. <br><br>  <strong>Why are korutiny better?</strong> <br><br><ul><li>  This code is easier to read.  It is written as if it were consistent. </li><li>  Most likely the performance of this code is better than on RxJava. </li><li>  It's very easy to write tests, but we'll get to them a bit later. </li></ul><br><h2>  2 steps to the side <br></h2><br>  A little distracted, there are a couple of things that still need to talk. <br><br><h3>  Step 1. withContext vs launch / async <br></h3><br>  In addition to the <strong>coroutine builder async,</strong> there is a <strong>coroutine builder withContext</strong> . <br><br>  <strong>Launch</strong> or <strong>async</strong> creates a new <strong>Coroutine context</strong> , which is not always necessary.  If you have a Coroutine context that you want to use throughout the application, then you do not need to recreate it.  You can simply reuse the existing one.  To do this, you need a coroutine builder withContext.  It simply re-uses the existing Coroutine context.  It will be 2-3 times faster, but now it is not a fundamental question.  If the exact numbers are interesting, then <a href="https://stackoverflow.com/questions/50230466/kotlin-withcontext-vs-async-await">here is</a> the <strong>stackoverflow</strong> <a href="https://stackoverflow.com/questions/50230466/kotlin-withcontext-vs-async-await">question</a> with benchmarks and details. <br><br><blockquote>  <strong>General rule:</strong> Use withContext without doubt where it is semantically appropriate.  But if you need parallel loading, for example several pictures or parts of data, then async / await is your choice. <br></blockquote><br><h3>  Step 2. Refactoring <br></h3><br>  What if you refactor a really complex RxJava chain?  I ran into this in production: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  I had a complex chain with a <strong>public subject</strong> , with <strong>zip</strong> and <strong>side</strong> <strong>effects</strong> in each <strong>zipper</strong> , which else sent something to the event bus.  The task at least was to get rid of the event bus.  I spent the day, but could not refactor the code to solve the problem.  <strong>The correct solution was to throw everything out and rewrite the code to coroutine in 4 hours</strong> . <br><br>  The code below is very similar to what I did: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - We do async for one task, for the second and third. <br>  - We are waiting for the result and add all this to the object. <br>  - Done! <br><br>  If you have complex chains and have korutiny, then just refactor.  This is real fast. <br><br><h2><a name="fear"></a>  What prevents developers from using Cortina in the sale? <br></h2><br>  In my opinion, we, as developers, are now prevented from using Korutiny only by the fear of something new: <br><br><ul><li>  We do not know what to do with the <strong>lifecycle</strong> , with the <strong>activity</strong> and the life cycle of the fragments.  How to work with korutinami in these cases? </li><li>  No experience solving daily complex tasks in production using korutin. </li><li>  Not enough tools.  For RxJava, a bunch of libraries and functions are written.  For example <strong>RxFCM</strong> .  There are a lot of operators in RxJava itself, which is good, but what about korutin? </li><li>  We do not really understand how to test Korutiny. </li></ul><br><blockquote>  If we get rid of these four fears, we will be able to sleep at night and use the korutiny in production. <br></blockquote><br>  Let's go for the points. <br><br><h3>  1. Lifecycle management <br></h3><br><ul><li>  Korutiny can flow away as <strong>disposable</strong> or <strong>AsyncTask</strong> .  This problem needs to be solved manually. </li><li>  To avoid the random <strong>Null Pointer Exception, the</strong> cortinas need to be stopped. </li></ul><br><h4>  Stop <br></h4><br>  Are you familiar with the <strong>Thread.stop ()</strong> method?  If you used it, not for long.  In <strong>JDK 1.1, the</strong> method was immediately declared obsolete, since it is impossible to take and stop a certain piece of code and there are no guarantees that it will complete correctly.  Most likely you will only receive <strong>memory corruption</strong> . <br><br>  Therefore, <strong>Thread.stop () does not work</strong> .  You need to be canceled cooperatively, that is, the code on the other side knew that you are canceling it. <br><br>  How we apply stops with RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  In RxJava, we <strong>use CompositeDisposable</strong> . <br><br>  - Add the <strong>compositeDisposable</strong> variable to the activity in the fragment or in the presenter, where we use RxJava. <br>  - In <strong>onDestro</strong> y add <strong>Dispose</strong> and all exceptions go away by themselves. <br><br>  Approximately the same principle with korutinami: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() ‚Ä¶ } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Consider the example of a <strong>simple task</strong> . <br><br>  Normally, <strong>coroutine builders</strong> return a <strong>job</strong> , and in some cases <strong>Deferred</strong> . <br><br>  - We can memorize this job. <br>  - Give the command <strong>"launch"</strong> <strong>coroutine builder</strong> .  The process starts, something happens, the result of the execution is remembered. <br>  - If we don‚Äôt transfer anything else, then ‚Äúlaunch‚Äù launches the function and returns us the reference to the job. <br>  - Job remember, and in onDestroy we say <strong>‚Äúcancel‚Äù</strong> and everything works well. <br><br>  <strong>What is the problem approach?</strong>  For each job, a field is needed.  You need to maintain a list of jobs to cancel them all together.  The approach leads to duplication of code, do not do so. <br><br>  The good news is that we have <strong>alternatives</strong> : <strong>CompositeJob</strong> and <strong>Lifecycle-aware job</strong> . <br><br>  CompositeJob is an analogue of compositeDisposable.  It looks like this <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - On one fragment we get one job. <br>  ‚ÄúAll <strong>job‚Äôs are</strong> added to CompositeJob and give the command: <strong>‚Äú job.cancel () for everyone! ‚Äù</strong> . <br><br>  The approach is easily implemented in 4 lines, not counting the class declaration: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  You will need: <br><br>  - <strong>map</strong> with string key, <br>  - the <strong>add</strong> method to which you will add the job, <br>  - optional <strong>key</strong> parameter. <br><br>  If you want to use the same key for the same job, please.  If not, <strong>hashCode</strong> solves our problem.  We add job in map which we transferred, and we cancel previous with the same key.  If we exceed the task, we are not interested in the previous result.  We cancel it and run it again. <br><br>  Cancel is simple: get job by key and cancel.  The second cancel for the entire map cancels everything.  All code is written in half an hour in four lines and it works.  If you do not want to write - take an example above. <br><br><h4>  Lifecycle-aware job </h4><br>  Did you use <strong>Android Lifecycle</strong> , <strong>Lifecycle owner</strong> or <strong>observer</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  Our <strong>activity</strong> and <strong>fragments</strong> have certain states.  Most interesting: <strong>created,</strong> <strong>started</strong> and <strong>resumed</strong> .  There are different transitions between states.  <strong>LifecycleObserver</strong> allows you to subscribe to these transitions and do something when one of the transitions happens. <br><br>  It looks quite simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre><br>  You hang up the annotation with some parameter on the method, and it is called with the appropriate transition.  It is enough just to use this approach for corutin: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - You can write the base class <strong>AndroidJob</strong> . <br>  - In the class we will pass <strong>Lifecycle</strong> . <br>  - The <strong>LifecycleObserver</strong> interface will implement the job. <br><br>  All we need is: <br><br>  - In the constructor, add to the Lifecycle as an Observer. <br>  - Subscribe to <strong>ON_DESTROY</strong> or anything else that interests us. <br>  - Make a cancel at ON_DESTROY. <br>  - <strong>Start</strong> one <strong>parentJob</strong> in your snippet. <br>  - Call the <strong>Joy jobs</strong> designer or <strong>lifecycle of</strong> your activity fragment.  No difference. <br>  - Pass this <strong>parentJob</strong> as a <strong>parent</strong> . <br><br>  The finished code looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  When you cancel parent, all child corutines are canceled and you no longer need to write anything in the fragment.  Everything happens automatically, no more ON_DESTROY.  The main <strong>thing is</strong> not to forget to pass <strong>parent = parentJob</strong> . <br><br><blockquote>  If you use, you can write a simple lint rule, which will highlight you: ‚ÄúOh, you forgot your parent!‚Äù <br></blockquote><br>  WITH <strong>&nbsp;</strong>  Lifecycle management sorted out.  We have a couple of tools that make it all easy and comfortable. <br><br>  What about complex scenarios and non-trivial production tasks? <br><br><h3>  2. Complex use-cases <br></h3><br>  Complex scripts and nontrivial tasks are: <br><br>  - <strong>Operators</strong> - complex operators in RxJava: flatMap, debounce, etc. <br>  - <strong>Error-handling -</strong> complex error handling.  Not simple <strong>try..catch</strong> , but for example, nested. <br>  - <strong>Caching</strong> <strong>is a</strong> non <strong>-</strong> trivial task.  In production, we ran into a cache and wanted to get a tool to easily solve the problem of caching with corutines. <br><br><h4>  Repeat </h4><br>  When we thought about operators for corutin, the first option was <strong>repeatWhen ()</strong> . <br><br>  If something went wrong and the quorutine could not reach the server inside, then we want to try again several times with some exponential fallback.  Perhaps the reason is a bad connection and we get the desired result by repeating the operation several times. <br><br>  With Corutin, this task is easily implemented: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Operator implementation: <br><br>  - He takes <strong>Deferred</strong> . <br>  - You will need to call <strong>async</strong> to get this object. <br>  - Instead of <strong>Deferred,</strong> you can transfer and suspend a block and, in general, any <strong>suspend function.</strong> <br>  - Cycle <strong>for</strong> - you are waiting for the result of your korutiny.  If something happens and the repeat counter is not exhausted, try again through <strong>Delay</strong> .  If not, then no. <br><br>  The function can be easily customized: put an exponential Delay or pass a lambda function that will calculate the Delay depending on the circumstances. <br><br>  Enjoy, it works! <br><br><h4>  Zips </h4><br>  Also often come across them.  Here again, everything is simple: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Use <strong>zipper</strong> and call await on your Deferred. <br>  - Instead of Deferred, you can use the suspend function and the coroutine builder with withContext.  You will convey the context you need. <br><br>  This again works and I hope that I have removed this fear. <br><br><a name="cache"></a><h3>  Cache </h3><br><br>  Do you have a cache implementation in production with RxJava?  We use rxcache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  In the diagram on the left: <strong>View</strong> and <strong>ViewModel</strong> .  On the right - data sources: network calls and database. <br><br>  If we want something to be cached, then cache will be another data source. <br><br>  Types of cache: <br><br><ul><li>  <strong>Network Source</strong> for network calls. </li><li>  <strong>In-memory cache</strong> . </li><li>  <strong>Persistent cache</strong> with expiration for storage on disk so that the cache survives the restart of the application. </li></ul><br>  We write a simple and primitive <strong>cache</strong> for the third case.  Coroutine builder withContext comes to the rescue again. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - You perform each operation with withContext and see if any data is coming. <br>  - If the data from <strong>persistence</strong> does not come, then you try to get it from <strong>memory.cache</strong> . <br>  - If the memory.cache is also not, then contact the <strong>network source</strong> and get your data.  Do not forget, of course, put in all the caches. <br><br>  This is a rather primitive implementation and there are many questions here, but the method works if you need the cache in one place.  For production tasks this cache is not enough.  Need something more complicated. <br><br><h4>  Rx has rxcache </h4><br>  For those who still use RxJava, you can use RxCache.  We still use it too.  <strong>RxCache</strong> is a special library.  Allows you to cache data and manage its life cycle. <br><br>  For example, you want to say that this data will become obsolete in 15 minutes: ‚ÄúPlease, after this period of time, do not give the data from the cache, but send me fresh data‚Äù. <br><br>  The library is wonderful because it will support the team declaratively.  The declaration is very similar to what you do with <strong>Retrofit</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - You say that you have a <strong>CacheProvider</strong> . <br>  - Start a method and say that <strong>LifeCache's</strong> lifetime <strong>is</strong> 15 minutes.  The key by which it will be available is <strong>Features</strong> . <br>  - Returns <strong>Observable &lt;Reply</strong> , where <strong>Reply</strong> is an auxiliary library object for working with cache. <br><br>  The use is quite simple: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - With Rx Cache access to <strong>RestApi</strong> . <br>  - Appeals to <strong>CacheProvider</strong> . <br>  - Feed him Observable. <br>  - The library itself will figure out what to do: go to the cache or not, if the time runs out, contact <strong>Observable</strong> and perform another operation. <br><br>  Using the library is very convenient and I would like to get a similar one for Corutin. <br><br><h4>  Coroutine Cache in Development </h4><br>  Inside EPAM, we write the <strong>Coroutine Cache</strong> library, which will execute all the functions of RxCache.  We wrote the first version and run it inside the company.  As soon as the first release comes out, I‚Äôll be happy to write about it on my Twitter.  It will look like this: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  We will have a <strong>getFeatures</strong> suspend function.  The function will be passed as a block into a special function of a higher order <strong>withCache</strong> , which will itself understand what needs to be done. <br><br>  Perhaps we will make the same interface to support declarative functions. <br><br><a name="err"></a><h3>  Error processing <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  Simple error handling is often found by developers and is usually quite simple.  If you do not have complicated things, then in catch you catch an <strong>exercise</strong> and see what happened there, write to the log or show an error to the user.  On the UI, you can easily do this. <br><br>  In simple cases, everything is expected to be easy - error handling with corutins is done through <strong>try-catch-finally</strong> . <br><br>  In production, in addition to simple cases, there are: <br><br>  - nested <strong>try-catch</strong> , <br>  - Many different types of <strong>expressions</strong> , <br>  - Errors in the network or in business logic, <br>  - User errors.  He did something wrong again and is to blame for everything. <br><br>  We must be ready for this. <br><br>  There are 2 <strong>possible</strong> solutions: <strong>CoroutineExceptionHandler</strong> and the <strong>Result classes</strong> approach. <br><br><h3>  Coroutine Exception Handler <br></h3><br>  This is a special class for handling complex error cases.  <strong>ExceptionHandler</strong> allows you to take as your argument the <strong>Exception</strong> as an error and handle it. <br><br>  How do we usually handle complex errors? <br><br>  The user clicked something, the button did not work.  He needs to say what went wrong and direct it to a specific action: check the Internet, Wi-Fi, try it later or delete the application and never use it again.  Say about this user can be quite simple: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Let's get the default message: ‚ÄúSomething went wrong!‚Äù And analyze the exception. <br>  - If it is <strong>ConnectionException,</strong> then we take a localized message from the resources: ‚ÄúMan, turn on Wi-Fi and your problems will go away.  I guarantee it. ‚Äù <br>  - If the <strong>server said something wrong</strong> , then you need to inform the client: ‚ÄúGo out and log in again‚Äù, or ‚ÄúDo not do it in Moscow, do it in another country‚Äù, or ‚ÄúSorry, comrade.  All I can do is just say that something went wrong. ‚Äù <br>  - If this is a completely <strong>different error</strong> , for example, <strong>out of memory</strong> , we say: "Something went wrong, I'm sorry." <br>  - All messages are output. <br><br>  What you write to <strong>CoroutineExceptionHandler</strong> will run on the same <strong>Dispatcher</strong> where you run coruntine.  So if you give the ‚Äúlaunch‚Äù command to the UI, then everything happens on the UI.  You do not need a separate <strong>dispatching,</strong> which is very convenient. <br><br>  It‚Äôs easy to use: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  There is a <strong>plus</strong> operator.  In the Coroutine context add a <strong>handler</strong> and everything works, which is very convenient.  We used it for a while. <br><br><h3>  Result classes <br></h3><br>  We later realized that a CoroutineExceptionHandler might be missing.  The result, which is formed by the work of korutina, may consist of several data, of different parts or process several situations. <br><br>  <strong>Result classes</strong> helps to cope with this problem: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - In your business logic, you get the <strong>Result class</strong> . <br>  - Mark as <strong>sealed</strong> . <br>  - Inherit from the class two other data classes: <strong>Success</strong> and <strong>Error</strong> . <br>  - In <strong>Success,</strong> transfer your data that is formed as a result of performing corutina. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- In </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> add exception. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then you can implement the business logic as follows:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You call the Coroutine context - Coroutine builder withContex and you can handle different situations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, a logged in user: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- We </font><font style="vertical-align: inherit;">exit </font><font style="vertical-align: inherit;">and say that this is an error. </font><font style="vertical-align: inherit;">Let the logic above handle it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- You can call RestApi or other business logic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- If everything is fine, then </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result.Success is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returned </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- If an exception occurs, then </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result.Error</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The approach allows you to delegate error handling somewhere further, although the ExceptionHandler does the same. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result classes work, tests are convenient to write. </font><font style="vertical-align: inherit;">We use Result classes, but you can use both ExceptionHandler and try-catch.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Testing </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing that worries us and prevents sleep well. </font><font style="vertical-align: inherit;">If you are writing </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unit tests</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then you are sure that everything is working correctly. </font><font style="vertical-align: inherit;">With Corutin, we also want to write unit tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how to do it. </font><font style="vertical-align: inherit;">Globally, in order to write unit-tests, we need to solve 2 problems:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replacing context</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To be able to substitute the context in which everything happens;</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mocking coroutines</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To be able to mokirovat korutiny</font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replacing context </font></font><br></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So the presenter looks like: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { ‚Ä¶ } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if in the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">login</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">you launch your coruntine, then it explicitly uses the UI context. </font><font style="vertical-align: inherit;">This is not very good for tests, since one of the principles of application testing says that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all dependencies must be explicitly passed to a method or class</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Here the principle is not respected, so the code needs to be improved in order to write a unit-test. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The improvement is quite simple:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- In the login method, configure the transfer of coroutineContext. </font><font style="vertical-align: inherit;">It is clear that in the code of your application you do not want to pass it everywhere explicitly. </font><font style="vertical-align: inherit;">In Kotlin, you can simply write that it should be the default UI. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Call your Coroutine builder with the Coroutine Contex that you pass to the method. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the unit test, you can do the following:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- You can create your </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LoginPresenter</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and call the login method with some context, for example, with Unconfined. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unconfined</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reports that the quorutine will be launched on the stream that starts it. </font><font style="vertical-align: inherit;">This allows one line to write tests and check the result.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mocking coroutines </font></font><br></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next question is mocking a corutin. </font><font style="vertical-align: inherit;">I recommend using </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mockk</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for unit tests. </font><font style="vertical-align: inherit;">This is a lightweight unit-testing framework specifically written in Kotlin, in which it is easy to work with Korutins. </font><font style="vertical-align: inherit;">You can replace the suspend function or the coroutine with the help of the special function </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coEvery</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and instead of calling corutina, return an interesting business object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, a login call instead of a cortina simply returns </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githubUser</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mockito-kotlin</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then everything is a little more difficult - you will have to dance with a tambourine. </font><font style="vertical-align: inherit;">Perhaps there is a more accurate way, but now we use this:</font></font><br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use just </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runBlocking</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">With the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">given block</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we do the same as in the previous example. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can write a complete test on our </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presenter</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Prepare your business data, for example, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubUser</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- The LoginPresenter explicitly passes the dependency to our API, but now it will be locked. </font><font style="vertical-align: inherit;">How do you mokiruete it up to you. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Then call </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presenter.login</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the Unconfined context and check that all the necessary data that we are expecting has been generated in the Presenter.</font></font><br><br>  And that's it!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testing Korutin really easy. </font></font><br><br><h2>  Let's sum up <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  ‚Äî   ,   . </li><li> <strong>   .</strong>   ,       . Unit- ‚Äî       ,  ,     ,    .  ‚Äî welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  useful links <br></h3><br><ul><li>      ,      Android GDE   <a href="https://proandroiddev.com/android-coroutine-recipes-33467a4302e9">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html"> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://twitter.com/vvsevolodovich">Twitter</a>       . <a href="https://medium.com/%40dzigorium"><strong> Medium</strong></a>     ¬´¬ª      Android,   async-   . </li></ul><br><blockquote>  <strong>news</strong> <br><br> 30    Mail.ru   <a href="https://www.meetup.com/ru-RU/AppsConf-Mobile-Meetup/events/256564566/"> </a>      .  ,    <a href="https://conf.ontico.ru/event/join/mac1.html"></a> . <br><br>       <a href="http://appsconf.ru/">AppsConf</a>   ,   <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dac2019"> </a>    <a href="https://conf.ontico.ru/conference/join/ac2019.html"> </a>   . <br><br> <a href="http://eepurl.com/bOajmn">  </a> ,   ,       ,       . <br><br>    <a href="https://www.youtube.com/c/MobileChannelRussia">youtube-</a>       AppsConf 2018 ‚Äî    :) <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/429908/">https://habr.com/ru/post/429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429892/index.html">xonsh - python as shell replacement</a></li>
<li><a href="../429894/index.html">Using the Fish eye camera on a Raspberry Pi 3 with ROS - part 2</a></li>
<li><a href="../429898/index.html">DMS (Dealership Management System) - Implementation of Information EcoSystems for Dealer Networks Management</a></li>
<li><a href="../429902/index.html">Page Rank in the Web 2.0 era - Part 1</a></li>
<li><a href="../429904/index.html">Funny and sad stories about the development of computer games</a></li>
<li><a href="../429910/index.html">AppsConf Rises</a></li>
<li><a href="../429912/index.html">Library development: from API to public release</a></li>
<li><a href="../429914/index.html">OpenSceneGraph: Scene graph and smart pointers</a></li>
<li><a href="../429916/index.html">How to build and build</a></li>
<li><a href="../429918/index.html">Intel Virtual World. Part 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>