<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to blink 4 LEDs on CortexM using C ++ 17, tuple and perverted imagination</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All good health! 

 When teaching students to develop embedded software for microcontrollers at the university, I use C ++ and sometimes I give especi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to blink 4 LEDs on CortexM using C ++ 17, tuple and perverted imagination</h1><div class="post__text post__text-html js-mediator-article">  All good health! <br><br>  When teaching students to develop embedded software for microcontrollers at the university, I use C ++ and sometimes I give especially interested students all sorts of tasks to identify particularly <s>sick and</s> talented students. <br><br>  Once again, such students were given the task of blinking 4 LEDs using the C ++ 17 language and the standard C ++ library, without connecting additional libraries, such as CMSIS and their header files with the description of register structures, and so on ... The one with the code wins the ROM will occupy the smallest size and the least amount of RAM consumed.  The compiler optimization should not be higher than Medium.  The IAR compiler 8.40.1. <br>  The winner <s>goes to the Canaries</s> gets 5 for the exam. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I myself didn‚Äôt solve this task before, so I‚Äôll tell you how the students solved it and what happened with me.  I warn you right away that it is unlikely that such code can be used in real applications, that's why I placed the publication in the section ‚ÄúAbnormal programming‚Äù, although who knows. <br><a name="habracut"></a><br><h3>  Conditions of the problem </h3><br>  There are 4 LEDs on the ports GPIOA.5, GPIOC.5, GPIOC.8, GPIOC.9.  They need to blink.  So that we have something to compare, we took the code written in C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++i){ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br>  The <code>delay()</code> function here is a purely formal, ordinary cycle, it cannot be optimized. <br>  It is assumed that the ports are already configured to exit and clocking is applied to them. <br>  I‚Äôll also say that bitbanging wasn‚Äôt used to make the code portable. <br><br>  This code takes 8 bytes on the stack and 256 bytes in ROM on Medium optimization <br><blockquote>  255 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  8 bytes of readwrite data memory </blockquote><br>  255 bytes due to the fact that part of the memory went under the table of interrupt vectors, IAR function calls to initialize the block with a floating point, all sorts of debugging functions and the __low_level_init function where the ports themselves were configured. <br><br>  So, the full requirements: <br><br><ul><li>  The main () function should contain as little code as possible. </li><li>  You can not use macros </li><li>  Compiler IAR 8.40.1 supporting C ++ 17 </li><li>  You cannot use CMSIS header files, such as "#include" stm32f411xe.h " </li><li>  You can use the __forceinline directive for inline functions. </li><li>  Medium Compiler Optimization </li></ul><br><h3>  Student solution </h3><br>  In general, there were several solutions, I will show only one ... it is not optimal, but I liked it. <br><br>  Since you can‚Äôt use header files, students first made a <code>Gpio</code> class that should store a link to the port registers at their addresses.  To do this, they use the overlay structure, most likely the idea was taken from here: <a href="https://blog.feabhas.com/2017/05/making-things-stuff-part-5/">Structure overlay</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); } ;</span></span></code> </pre> <br>  As you can see, they immediately identified the <code>Gpio</code> class with attributes that should be located at the addresses of the respective registers and the method for switching the state by the leg number: <br>  Then we determined the structure for <code>GpioPin</code> , which contains a pointer to <code>Gpio</code> and the number of the leg: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GpioPin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio* port ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum ; } ;</code> </pre> <br>  Then they made an array of LEDs that sit on the specific legs of the port and ran through it by calling the <code>Toggle()</code> method of each LED: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GpioPin leds[] = {{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpioaBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>} } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsDriver</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggelAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Well, actually the whole code:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; } ; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); struct GpioPin { volatile Gpio* port ; std::uint32_t pinNum ; } ; const GpioPin leds[] = {{reinterpret_cast&lt;volatile Gpio*&gt;(GpioaBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9} } ; struct LedsDriver { __forceinline static inline void ToggelAll() { for (auto&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ; int main() { for(;;) { LedsContainer::ToggleAll() ; delay(); } return 0 ; }</span></span></code> </pre> <br></div></div><br>  Statistics of their code for Medium optimization: <br><blockquote>  275 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  8 bytes of readwrite data memory </blockquote><br>  Good decision, but it takes a lot of memory :) <br><br><h3>  My decision </h3><br>  I certainly decided not to look for simple ways and decided to act seriously :). <br>  The LEDs are on different ports and different legs.  The first thing that needs to be done is to make the <code>Port</code> class, but to get rid of pointers and variables that occupy RAM, you need to use static methods.  The port class might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  -  };</span></span></code> </pre> <br>  As a template parameter, it will have a port address.  In the heading <code>"#include "stm32f411xe.h"</code> , for example, for port A, it is defined as GPIOABASE. But we are forbidden to use headings, so we just need to make our constant. As a result, the class can be used like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ;</code> </pre><br>  To blink you need the Toggle method (const std :: uint8_t bit), which will switch the required bit using the exclusive OR operation.  The method should be static, add it to the class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   __forceinline,        __forceinline inline static void Toggle(const std::uint8_t bitNum) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr+20) ^= (1 &lt;&lt; bitNum) ; //addr + 20  ODR  } };</span></span></code> </pre> <br>  Excellent <code>Port&lt;&gt;</code> is, it can switch the status of the leg.  The LED is sitting on a specific leg, so it is logical to make a class <code>Pin</code> , which will have <code>Port&lt;&gt;</code> and the leg number as template parameters.  Since the <code>Port&lt;&gt;</code> type is template, i.e.  different for a different port, we can only transmit the universal type T. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T::Toggle(pinNum) ; } } ;</code> </pre> <br>  It's bad that we can pass on any nonsense of type <code>T</code> which has the <code>Toggle()</code> method and it will work, although it is assumed that we should only transfer the type <code>Port&lt;&gt;</code> .  To protect against this, let us make sure that <code>Port&lt;&gt;</code> inherited from the base class <code>PortBase</code> , and in the template we will check that our transferred type is really based on <code>PortBase</code> .  We get the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortBase</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class">:</span></span> PortBase { __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">//   struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ;</span></span></code> </pre> <br>  Now the template is instantiated only if our class has a base class <code>PortBase</code> . <br>  In theory, you can already use these classes, let's see what happens without optimization: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led2 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led3 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led4 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { Led1::Toggle(); Led2::Toggle(); Led3::Toggle(); Led4::Toggle(); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br><blockquote>  271 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  24 bytes of readwrite data memory </blockquote><br>  Where did these additional 16 bytes in RAM and 16 bytes in ROM come from?  They come from the fact that we pass the bit parameter to the Toggle function (const std :: uint8_t bit) of the Port class, and the compiler, upon entering the main function, saves 4 additional registers on the stack through which it passes this parameter, then uses these registers in which the value of the pin number for each Pin is stored and when exiting from main, restores these registers from the stack.  And although in fact this is some kind of completely useless work, since the functions are built-in, but the compiler acts in full compliance with the standard. <br>  You can get rid of this by removing the port class in general, passing the port address as a template parameter for the <code>Pin</code> class, and calculating the ODR register address inside the <code>Toggle()</code> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr + OdrAddrShift ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } } ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;GpioaBaseAddr, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ;</code> </pre> <br>  But it does not look very good and user-friendly.  So let's hope that the compiler removes this unnecessary saving of registers with a little optimization. <br><br>  Put the optimization on Medium and see the result: <br><blockquote>  251 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  8 bytes of readwrite data memory </blockquote><br>  Wow wow wow ... we have 4 bytes less <div class="spoiler">  <b class="spoiler_title">sishnogo code</b> <div class="spoiler_text"><blockquote>  255 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  8 bytes of readwrite data memory </blockquote><br></div></div><br>  How can this be?  Let's take a look at the assembler in the debugger for C ++ code (left) and C code (right): <br><br><img src="https://habrastorage.org/webt/vh/ym/d9/vhymd9hbcko9luonsasg-xz7w7e.png" alt="image"><br><br>  It can be seen that, firstly, the compiler made all the functions built-in, now there are no calls at all, and secondly, it optimized the use of registers.  It can be seen that in the case of C code, the compiler uses either the R1 register and R2 for storing the port addresses, and does additional operations every time after switching the bit (save the address in the register, then in R1, then in R2).  In the second case, it uses only the R1 register, and since the last 3 calls to switch are always from port C, there is no need to keep the same port C address in the register.  As a result, 2 teams and 4 bytes are saved. <br><br>  Here it is a miracle of modern compilers :) Well, okay.  In principle, it was possible to stop at this, but let's go further.  I think it will not work out to optimize something else, although it may be wrong if you have ideas, write in the comments.  But with the amount of code in main () you can work. <br><br>  Now I want all the LEDs to be somewhere in the container, and one could call the method, switch everything ... That's something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { LedsContainer::ToggleAll() ; delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br>  We will not stupidly insert the switching of 4 LEDs into the LedsContainer :: ToggleAll function, because it is not interesting :).  We want to put the LEDs in a container and then go over them and call Toggle () method on each one. <br><br>  <i>Students used an array to store pointers to LEDs.</i>  But I have different types, for example: <code>Pin&lt;PortA, 5&gt;</code> , <code>Pin&lt;PortC, 5&gt;</code> , and I cannot store pointers to different types in an array.  You can make a virtual base class for all Pin, but then a table of virtual functions will appear and I won‚Äôt be able to win students. <br><br>  Therefore, we will use a tuple.  It allows you to store objects of different types.  This case will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> records = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple ( Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt;{} ) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tRecordsTuple = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(records) ; }</code> </pre> <br>  Excellent there is a container, it stores all the LEDs.  Now add the <code>ToggleAll()</code> method to it: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        } private: constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br>  It is simply impossible to walk through the elements of a tuple like this, since the receipt of the element of a tuple should occur only at the compilation stage.  To access elements of a tuple there is a template get method.  Well, that is  if we write as <code>std::get&lt;0&gt;(records).Toggle()</code> , then the <code>Toggle()</code> method will be called for the object of the class <code>Pin&lt;PortA, 5&gt;</code> , if <code>std::get&lt;1&gt;(records).Toggle()</code> , then the <code>Toggle()</code> method will be called for an object of the class <code>Pin&lt;Port, 5&gt;</code> and so on ... <br><br>  It was possible to <s>wipe students nose</s> and just write like this: <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(records).Toggle(); }</code> </pre> <br>  But we do not want to strain a programmer who will support this code and allow him to do additional work, wasting the resources of his company, for example, if another LED appears.  It is necessary to add code in two places, to a tuple and to this method - and this is not good, and the company owner will not be very pleased.  Therefore, we bypass the tuple using helper methods: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); //    get&lt;3&gt;(records).Toggle(), get&lt;2&gt;(records).Toggle(), get&lt;1&gt;(records).Toggle(), get&lt;0&gt;(records).Toggle() } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) {//      } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br>  It looks scary, but I warned at the beginning of the article that the <s>shizanuty</s> method <s>is</s> not very ordinary ... <br><br>  At the compilation stage, all this magic does literally the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  LedsContainer::ToggleAll() ; //   4 : Pin&lt;Port, 9&gt;().Toggle() ; Pin&lt;Port, 8&gt;().Toggle() ; Pin&lt;PortC, 5&gt;().Toggle() ; Pin&lt;PortA, 5&gt;().Toggle() ; //     Toggle() inline,   : *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 9) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 8) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 5) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020014 ) ^= (1 &lt;&lt; 5) ;</span></span></code> </pre> <br>  Forward compile and check the size of the code without optimization: <br><br><div class="spoiler">  <b class="spoiler_title">Code that compiles</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; #include &lt;tuple&gt; #include &lt;utility&gt; #include &lt;cstdint&gt; #include &lt;type_traits&gt; //#include "stm32f411xe.h" #define __forceinline _Pragma("inline=forced") constexpr std::uint32_t GpioaBaseAddr = 0x4002'0000 ; constexpr std::uint32_t GpiocBaseAddr = 0x4002'0800 ; constexpr std::uint32_t OdrAddrShift = 20U; struct PortBase { }; template &lt;std::uint32_t addr&gt; struct Port: PortBase { __forceinline inline static void Toggle(const std::uint8_t bit) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr + OdrAddrShift) ^= (1 &lt;&lt; bit) ; } }; template &lt;typename T, std::uint8_t pinNum, class = typename std::enable_if_t&lt;std::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ; using PortA = Port&lt;GpioaBaseAddr&gt; ; using PortC = Port&lt;GpiocBaseAddr&gt; ; //using Led1 = Pin&lt;PortA, 5&gt; ; //using Led2 = Pin&lt;PortC, 5&gt; ; //using Led3 = Pin&lt;PortC, 8&gt; ; //using Led4 = Pin&lt;PortC, 9&gt; ; class LedsContainer { friend int main() ; public: __forceinline static inline void ToggleAll() { //    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) { } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; } ; void delay() { for (int i = 0; i &lt; 1000000; ++i){ } } int main() { for(;;) { LedsContainer::ToggleAll() ; //GPIOA-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 8; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 9; delay(); } return 0 ; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Assembly proof, unpacked as planned:</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0e/aa/un/0eaaunh1qwmg73s1p-3ev4zcpws.png" alt="image"><br></div></div><br>  We see that the memory is brute force, 18 bytes more.  The problems are the same, plus 12 more bytes.  I did not understand where they came from ... maybe someone can explain. <br><blockquote>  283 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  24 bytes of readwrite data memory </blockquote><br>  Now the same thing on Medium optimization and a miracle ... got a code identical to C ++ implementation head-on and more optimally than C code. <br><blockquote>  251 bytes of readonly code memory <br>  1 byte of readonly data memory <br>  8 bytes of readwrite data memory </blockquote><br><div class="spoiler">  <b class="spoiler_title">Assembler</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y4/7w/l9/y47wl95frzmeyb2brdekbnvqvr8.png" alt="image"><br></div></div><br>  As you can see, I won, and <s>went to the Canaries</s> and enjoyed a rest in Chelyabinsk :), but the students are great too, the exam passed successfully! <br><br>  <a href="https://onlinegdb.com/S1apkSaJH">Who cares, the code here</a> <br><br>  Where it is possible to use this, well, I thought of this, for example, we have parameters in the EEPROM memory and a class describing these parameters (Read, write, initialize to the initial value).  The class is a template, of the type <code>Param&lt;float&lt;&gt;&gt;</code> , <code>Param&lt;int&lt;&gt;&gt;</code> and it is necessary, for example, reset all parameters to default values.  Just here it is possible to put all of them in a tuple, since the type is different and call <code>SetToDefault()</code> method for each parameter.  True, if there are 100 such parameters, then the ROM will play off a lot, but the RAM will not suffer. <br><br>  PS I must admit that at maximum optimization this code is the same in size as in C and in my decision.  And all the efforts of the programmer to improve the code are reduced to the same code in assembler. <br><br>  P.S1 Thank you <a href="https://habr.com/ru/users/0xd34df00d/" class="user_link">0xd34df00d</a> for <a href="https://habr.com/ru/users/0xd34df00d/" class="user_link">good</a> advice.  You can simplify unpacking a tuple with <code>std::apply()</code> .  The code of the <code>ToggleAll()</code> function is then simplified to this: <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>... args) { (args.Toggle(), ...); }, records); }</code> </pre> <br>  Unfortunately in IAR, std :: apply in the current version is not yet implemented, but it will also work, see <a href="https://onlinegdb.com/SJLu0aTyS">for implementation with std :: apply</a> </div><p>Source: <a href="https://habr.com/ru/post/457246/">https://habr.com/ru/post/457246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457232/index.html">Bumble Robop Bead - the first test flight inside the ISS</a></li>
<li><a href="../457234/index.html">Cognitive distortions during product creation</a></li>
<li><a href="../457236/index.html">How did an IT company fight for the right to sell music</a></li>
<li><a href="../45724/index.html">Dual-core player</a></li>
<li><a href="../457240/index.html">News of the week: neural network and photoshopped images, growth of Yandex shares, Huawei claims $ 1 billion for patents</a></li>
<li><a href="../457248/index.html">Javascript programming for lathe</a></li>
<li><a href="../45725/index.html">Modern foreign series</a></li>
<li><a href="../457250/index.html">Dark day for Vue.js</a></li>
<li><a href="../457254/index.html">The digest of interesting materials for the mobile developer # 303 (June 17 - 23)</a></li>
<li><a href="../457256/index.html">Internet history: ARPANET - package</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>