<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Git bottom to top</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This translation is not an ordinary story. Version control systems are far from my professional interests. For working projects, I needed them infrequ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Git bottom to top</h1><div class="post__text post__text-html js-mediator-article">  This translation is not an ordinary story.  Version control systems are far from my professional interests.  For working projects, I needed them infrequently, and, differently, so that, every time such a need arose, I recalled how this or that operation was done in them.  And for personal projects, I had enough features of Dropbox, which stores the history of file versions. <br><br><img src="https://habrastorage.org/webt/ui/bv/vs/uibvvsfvqcnj_9js2a-u23mh8do.jpeg"><br>  <sup>Twitter <a href="https://twitter.com/girlie_mac/status/905270297128865792">image @girlie_mac</a></sup> <br><br>  But once I went to the hospital for three unforgettable days - it sometimes happens to women.  From entertainment I had a newborn daughter and a phone with a large screen.  My daughter initially entertained poorly (at home she quickly corrected herself), and on the phone, in addition to books and films, the text ‚ÄúGit from the bottom up‚Äù appeared, which turned out to be more than good ... Since then, almost 3 years have passed, <s>it‚Äôs time for an older daughter to start using Git</s> Git has become the mainstream, if not the standard in modern development, and I was surprised to find that the translation of this miracle into Russian, useful not only for beginners, but also for advanced Git users, is still not there.  Correct this situation. <br><a name="habracut"></a><br>  Welcome to the world of git.  Although when looking outside, the bulk of the Git features seems confusing, when viewed from the bottom up, Git is beautiful and simple.  I hope that this document will help you to deal with this powerful version control system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And we begin with a list of terms that appear in the text and are necessary for its understanding. <br><br><ul><li>  <b>Working tree</b> - Any directory in your file system associated with the <i>repository</i> (as can be seen from the presence of the ‚Äú.git‚Äù subdirectory in it).  Includes all files and subdirectories. </li><li>  <b>Commit</b>  In the role of a noun: "snapshot" of the <i>working tree</i> at some point in time.  In the role of the verb: commit (commit) - add <i>commit</i> to the <i>repository</i> . </li><li>  <b>A repository (Repository)</b> is a set of <i>commits</i> , i.e.  just an archive of past states of the <i>working</i> project <i>tree</i> on your or someone else's machine. </li><li>  <b>A branch</b> is simply a name for a <i>commit</i> , also called a <i>reference</i> .  Determines the origin - ‚Äúpedigree‚Äù of a <i>commit</i> , and thus is a typical representation of the ‚Äúdevelopment branch‚Äù </li><li>  <b>Checkout</b> - operation of switching between <i>branches</i> or restoration of <i>working tree</i> files </li><li>  <b>A tag</b> is also a name for a <i>commit</i> , which differs from a <i>branch</i> in that it always points to the same <i>commit</i> and can also have its own text description. </li><li>  <b>Master</b>  Conventionally, the "main" or "main" <i>branch of the repository</i> , but in essence no different from other <i>branches</i> </li><li>  <b>Index</b> .  Unlike other similar tools, Git does not send changes from the <i>working tree</i> to the <i>repository</i> directly.  Instead, changes are first recorded in the <i>index</i> , or ‚Äústaging area‚Äù.  This can be viewed as a way of "confirming" your changes before committing, which will write to the <i>repository</i> all approved changes. </li><li>  <b>HEAD</b> - header.  Used by the <i>repository</i> to determine what is selected using <i>checkout</i> <br><ul><li>  If the <i>checkout</i> subject is a branch, <i>HEAD</i> will refer to it, indicating that the name of the branch should be updated during the next <i>commit.</i> </li><li>  If the <i>checkout</i> subject is a commit, then <i>HEAD</i> will refer only to it.  In this case, <i>HEAD</i> is called detached. </li></ul></li></ul><br>  Interacting with Git usually looks like this: <br><br>  After creating the repository, the work takes place in the working tree.  As soon as a significant milestone is reached - eliminate the bug;  the end of the working day;  The moment when, finally, everything starts to compile, you add your changes to the index.  As soon as everything that you are about to commit is in the index, you write its contents to the repository.  The diagram below is a typical project life cycle: <br><br><img src="https://habrastorage.org/webt/tc/hz/vd/tchzvdfzhvhht5akhcdf93fnhso.png"><br><br>  Now let's see how each of the entities shown in the picture works in git <br><br><h2>  <font color="#0071c5">Repository: tracking the contents of a directory</font> </h2><br>  As follows from the definitions above, what Git does is elementary: it contains snapshots of the contents of a directory.  Most of its internal design can be understood in terms of this basic task. <br><br>  The design of the Git repository in many ways reproduces the UNIX file system.  The file system starts with the root directory, which usually consists of other directories, many of which have leaf nodes, i.e.  files containing data.  File metadata is stored both in the directory (names) and in i-nodes, which are referenced to the contents of these files (size, type, access permissions, etc.). Each i-node has a unique number that identifies the contents of the corresponding file.  Although there may be many objects in a directory pointing to a specific i-node (i.e. hard links), it is the i-node that ‚Äúowns‚Äù the content stored in your file system. <br><br>  The internal architecture of Git has a strikingly similar structure with one small difference. <br><br>  It all starts with the fact that Git presents the contents of your files in the form of so-called ‚Äúfragments‚Äù (‚Äúblobs‚Äù), which are leaf nodes in a structure that is very similar to a directory and is called a tree.  Just as an i-node is uniquely identified by a number assigned to it by a system, a fragment in Git is marked by calculating the SHA-1 hash of its size and content.  For all possible applications, this is just an arbitrary number, just like an i-node, with the exception of two additional properties: firstly, it controls the immutability of the fragment contents, and secondly, it guarantees that the same content will always be represented by the same the same fragment regardless of where it will be found - in different commits, repositories, or even in different parts of the Internet.  If several trees refer to the same fragment, then it looks like hard links: the fragment will not disappear from your repository as long as there is at least one link to it. <br><br>  The difference between a file in a file system and a fragment in Git is that the fragment itself does not store metadata about its contents.  All this information is stored in the tree to which the fragment belongs.  One tree may consider this content as a ‚Äúfoo‚Äù file created in August 2004, while another tree may know the same content under the file name ‚Äúbar‚Äù created five years later.  In a normal file system, such two files with matching content but differing metadata will always be represented as two independent files. <br><br>  What caused this difference?  Basically, the file system is designed to support changing files, but Git is not.  Because of the immutability of the data in the repository, Git needed a new design.  And, as it turned out, this design made it possible to more compact storage - after all, all objects with identical content will be common regardless of their location. <br><br><h2>  <font color="#0071c5">We get acquainted with a fragment</font> </h2><br>  Now that the overall picture is drawn, let's look at practical examples.  Let's create a test repository and show how Git works in it from the bottom.  (a <i>comment of the translator - all examples of this text are checked for git version 2.13.0.windows.1</i> ) <br><br><pre><code class="bash hljs">$ mkdir sample; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> sample $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span> &gt; greeting</code> </pre> <br>  Here I created a new <i>sample</i> directory containing a file with prosaically predictable content.  So far I have not even created a repository, but I can already start using some Git commands to understand what it is going to do.  First, I want to know how Git will store my greeting. <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-object greeting af5626b4a114abcb82d63db7c8082c3c4756e51b</code> </pre> <br>  When you run this command on your system, you will get the same hash identifier ( <i>note of the translator: further in the text - the hash id</i> ).  Although we create two different repositories (perhaps in different parts of the world), our greeting fragments will have the same hash id. <br><br>  I can even get commits from your repository to mine, and Git will understand that we are tracking the same content, and, accordingly, will only store one copy of it. <br>  The next step is to initialize the new repository and commit to it: <br><br><pre> <code class="bash hljs">$ git init $ git add greeting $ git commit -m <span class="hljs-string"><span class="hljs-string">"Added my greeting"</span></span></code> </pre> <br>  At this stage, our fragment should be in the system and use, as we expected, the hash id defined above.  For convenience, Git requires only initial hash digits that uniquely identify a fragment in the repository.  Usually 6 or 7 digits is enough. <br><br><pre> <code class="bash hljs">$ git cat-file -t af5626b blob $ git cat-file blob af5626b Hello, world!</code> </pre> <br>  Here it is!  I did not even look at which commit or tree it is in, but based solely on the content, I could assume that it is there, and I was not mistaken.  This content will have the same identifier regardless of the repository lifetime or the position of the file in it.  That is, the data is guaranteed to be saved forever. <br><br>  Thus, a fragment is a fundamental unit of data in Git.  In fact, this whole system is just fragment management. <br><br><h2>  <font color="#0071c5">Fragments are stored in trees.</font> </h2><br>  The unique content of your files is stored in fragments, but the fragments themselves are completely faceless.  They have no name, no structure, fragments - they are fragments.  Therefore, to represent the structure and names of your files, Git attaches fragments as nodes - ‚Äúleaves‚Äù to a tree. <br><br>  Now I cannot find out which tree (s) the fragment belongs to, since it can have so many owners.  But I know that it definitely has to be somewhere in the tree that the committer I just created owns. <br><br><pre> <code class="bash hljs">$ git ls-tree HEAD 100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b greeting</code> </pre> <br>  That is, this first commit, which added my greeting file to the repository, contains one tree with a single leaf: a greeting fragment. <br><br>  Although with the help of the <i>ls-tree HEAD command</i> I can look at the tree containing my fragment, but I have not yet seen the underlying tree object to which this commit refers. <br>  Here are some more commands to highlight this difference and explore my tree: <br><br><pre> <code class="bash hljs">$ git rev-parse HEAD 588483b99a46342501d99e3f10630cfc1219ea32 <span class="hljs-comment"><span class="hljs-comment">#     $ git cat-file -t HEAD commit $ git cat-file commit HEAD tree 0563f77d884e4f79ce95117e2d686d7d6e282887 author John Wiegley &lt;johnw@newartisans.com&gt; 1209512110 -0400 committer John Wiegley &lt;johnw@newartisans.com&gt; 1209512110 -0400 Added my greeting</span></span></code> </pre> <br>  The first command decodes the HEAD header to the commit it refers to, the second checks its type, and the third shows the hash id of the tree that the commit owns, as well as other information stored in the commit.  The hash id of a commit is unique to my repository, since it includes my name and the date of the commit, but the hash id of the tree should be the same for my and your examples, since it contains the same fragment under the same name. <br>  Make sure that this is really the same object: <br><br><pre> <code class="bash hljs">$ git ls-tree 0563f77 100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b greeting</code> </pre> <br>  That is, my repository contains a single commit that references a tree containing a fragment with what I want to write. <br><br>  Here is another command that I can use to confirm this: <br><br><pre> <code class="bash hljs">$ find .git/objects -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f | sort .git/objects/05/63f77d884e4f79ce95117e2d686d7d6e282887 .git/objects/58/8483b99a46342501d99e3f10630cfc1219ea32 .git/objects/af/5626b4a114abcb82d63db7c8082c3c4756e51b</code> </pre> <br>  This shows that my entire repository contains 3 objects, the hash id of which we have already seen in previous examples.  Let's just take a curious look at the types of these objects: <br><br><pre> <code class="bash hljs">$ git cat-file -t 588483b99a46342501d99e3f10630cfc1219ea32 commit $ git cat-file -t 0563f77d884e4f79ce95117e2d686d7d6e282887 tree $ git cat-file -t af5626b4a114abcb82d63db7c8082c3c4756e51b blob</code> </pre> <br>  I could also use the <i>show</i> command to view a summary of each of these objects, but I will leave this exercise to readers. <br><br><h2>  <font color="#0071c5">How are trees formed?</font> </h2><br>  Each commit contains a single tree.  But how are trees formed?  We know that fragments are created using the "slicing" of the contents of your file, and that trees own fragments, but we have not yet seen how these trees are formed and how the trees are associated with their parent commits. <br><br>  Let's start again with a new repository, but this time we'll do everything manually. <br><br><pre> <code class="bash hljs">$ rm -fr greeting .git $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span> &gt; greeting $ git init $ git add greeting</code> </pre> <br>  It all starts with adding a file to the index. So far, we can assume that the index is what you use for the initial creation of fragments from files.  When I added the <i>greeting</i> file, there were changes in my repository.  Although it is not a commit yet, there is a way to look at them: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-comment"><span class="hljs-comment">#   - ! fatal: bad default revision 'HEAD' $ git ls-files --stage #  ,     100644 af5626b4a114abcb82d63db7c8082c3c4756e51b 0 greeting</span></span></code> </pre> <br>  What is it?  There are no commits yet, but the object is already there.  It has the same hash id from which I started the whole enterprise, so I know that it represents the contents of the <i>greeting</i> file.  I could use the <i>git cat-file -t</i> command for this hash id, and I would see that this is a fragment ‚Äî the same one I received the first time I created this repository (who would doubt). <br><br>  Neither the tree nor the commits refer to this fragment.  So far, there is a link to it only in the <i>.git / index</i> file, which contains links to the fragments and trees that actually form the current index.  And now let's create a tree in the repository, on which fragments will hang: <br><br><pre> <code class="bash hljs">$ git write-tree <span class="hljs-comment"><span class="hljs-comment">#      0563f77d884e4f79ce95117e2d686d7d6e282887</span></span></code> </pre> <br>  A familiar number, isn't it?  A tree containing the same fragments (and sub-trees) will always have the same hash.  Although I still do not have a commit object, but in this repository there is a tree object containing fragments.  The goal of the low-level <i>write-tree</i> command is to take the contents of the index and place it in a new tree for further creation of a commit. <br><br>  A new commit object can be created manually using this tree directly.  This is exactly what the <i>commit-tree</i> command does: it takes the hash id of the tree and creates a commit object for it.  If I wanted a commit to have a parent object, I would have to specify it explicitly using the -p option. <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Initial commit"</span></span> | git commit-tree 0563f77 5f1bc85745dcccce6121494fdd37658cb4ad441f</code> </pre> <br>  Note that the resulting hash id is different from the one that happens on your system because the commit refers to my name and the time it was created, and these details will always be different from yours. <br><br>  But the work does not end there - I have not yet registered a commit as a new header for the current branch: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 5f1bc85745dcccce6121494fdd37658cb4ad441f &gt; .git/refs/heads/master</code> </pre> <br>  This command tells Git that the ‚Äúmaster‚Äù branch should now reference this commit. <br>  Another safer way to achieve the same goal is to use the <i>update-ref</i> command: <br><pre> <code class="bash hljs">$ git update-ref refs/heads/master 5f1bc857</code> </pre> <br><br>  After creating the <i>master</i> branch, we need to associate our tree with it.  This usually happens when you switch a branch: <br><br><pre> <code class="bash hljs">$ git symbolic-ref HEAD refs/heads/master</code> </pre> <br>  This command creates a <i>HEAD</i> symbolic link to the <i>master</i> branch.  This is very important, as all further commits from the working tree will now automatically update the <i>refs / heads / master</i> value. <br><br>  It's hard to believe that this is so easy, but now I can use the <i>log</i> command to view my newly created commit. <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> commit 5f1bc85745dcccce6121494fdd37658cb4ad441f Author: John Wiegley &lt;johnw@newartisans.com&gt; Date: Mon Apr 14 11:14:58 2008 -0400 Initial commit</code> </pre> <br>  I note that if I didn‚Äôt have <i>refs / heads / master</i> pointing to a new commit, it could be considered unavailable - since no one refers to it, and it is not the parent object of another available commit.  In this case, the commit object will someday be removed from the repository along with its own tree and all the fragments (this happens automatically with the help of the ‚Äúgc‚Äù command, which is rarely used manually by Git users).  When you link a commit to the name in the <i>refs / heads</i> , as we did above, it becomes available, which guarantees that Git will continue to be saved. <br><br><h2>  <font color="#0071c5">The beauty of commits</font> </h2><br>  Some version control systems make branches magical entities, often distinguishing them from the main line of development, while others discuss the concept of branching as if it is very different from commits.  But in Git, branches are not a separate entity - there are only fragments, trees and commits (well, tags, but they are just links to commits, so they can be ignored) Since a commit can have one or more parents and these commits in turn, they can belong to their parents, we can consider a single commit as a branch - after all, he knows his whole "family tree". <br><br>  You can view all top-level commits at any time using the branch command <br><br><pre> <code class="bash hljs">$ git branch -v * master 5f1bc85 Initial commit</code> </pre> <br>  Repeat after me: A branch is just a named link to a commit. <br>  Branches and tags are identical with one exception - tags can have their own descriptions - like commits to which they refer.  Branches are just names, and tags are descriptions, one might say, labels. <br><br>  In truth, we don‚Äôt really need to use these ‚Äúpseudonyms‚Äù.  For example, if desired, I could refer to any object of the repository, using only the hash-id of its commits. <br><br>  Here, for example, the command that reboots NEAD of my working tree to a given commit; <br><br><pre> <code class="bash hljs">$ git reset --hard 5f1bc85</code> </pre> <br>  The <i>--hard switch</i> causes deletion of all current changes to my working tree, regardless of whether they were registered for future repository (we'll talk about this command below). <br><br>  A safer way to go to a specific commit is to use the <i>checkout</i> command: <br><br><pre> <code class="bash hljs">$ git checkout 5f1bc85</code> </pre> <br>  The difference with the previous command is that the files changed in my working tree will be saved.  If I add the -f switch to <i>checkout</i> , the command will act in the same way as <i>reset -hard</i> , except that checkout only changes the working tree, and <i>reset</i> -hard also changes the HEAD of the current branch so that it points to the specified version of the tree. <br><br>  Another advantage of a commit-based system is the ability to rephrase the terms of even the most complex version control systems in a simple language.  For example, if a commit has several parents, then this is a merged commit.  Or, if a commit has several descendants, then it is an ancestor of the branch and so on.  But for Git between these entities there is no difference for him, the world is simply a set of commits, each of which contains a tree that refers to other trees and fragments that store your data.  Anything more complicated than that is just a legend. <br>  Here is an illustration of how it all works: <br><br><img src="https://habrastorage.org/webt/ie/bo/9k/iebo9kd6mj3lq_wafyqc9_piif0.jpeg"><br><br><h2>  <font color="#0071c5">A commit under any other name ...</font> </h2><br>  Understanding commits is the key to comprehending Git.  You will realize that you have achieved enlightenment, when your mind will contain only the topology of commits, and not a jumble of branches, tags, local and remote repositories, and so on.  I hope that this understanding will not require you to cut off your hands (as the second follower of the Zen teachings did), although I would appreciate if by that moment you had such a desire. <br><br>  If commits are key, their names are the door to mastery.  There are many ways to name commits, groups of commits, and even some of the objects contained in commits, which are supported by most Git commands.  Here is a summary of the main ones: <br><br><ul><li>  <b>The name of the code branch (branchname)</b> - As mentioned above, the name of any branch is simply the pseudonym of the most recent commit to this branch.  This is equivalent to the use of the word HEAD when selecting this branch. </li><li>  <b>Tagname (tagname)</b> - As well as the name of the branch - this is the name of the commit.  The only difference is that the tag name never changes, while the name of the branch changes every time a new commit arrives there. </li><li>  <b>HEAD</b> - Alias ‚Äã‚Äãof the name of the currently selected commit.  If you choose a particular commit - instead of the name of a branch, then HEAD refers exclusively to it, and not to the name of the branch.  This is a special case called ‚Äúusing a separated head‚Äù (I'm sure there must be some joke). </li><li>  <b>c82a22c39cbc32 ...</b> - A commit can always be accessed by its full, 40-character hash id. Usually this happens during copying and pasting, since  There are usually other, more convenient ways to do this. </li><li>  <b>c82a22c</b> - You need to use only that part of the hash id that uniquely identifies the commit in the repository.  Usually 6-7 numbers are enough for this. </li><li>  <b>name ^</b> - The symbol ^ is used to refer to the parent of any commit.  In the case when a commit has more than one parent (a merge commit), the first one is taken.  If you need the nth parent, you can refer to it as name ^ n </li><li>  <b>name ^^</b> - Parent of parent of this commit.  You can continue this sequence ... </li><li>  <b>name ~ 10</b> - ....  but not necessary.  ~ N is used to refer to the n-ancestor of this commit (equivalent to n consecutive ^ characters) </li><li>  <b>name: path</b> - To access a specific file within the commit tree, specify the file name after the colon.  This is useful for the show command or for comparing two versions of a file between commits: <br><pre> <code class="bash hljs">$ git diff HEAD^1:Makefile HEAD^2:Makefile</code> </pre> </li><li>  <b>name ^ {tree}</b> - You can refer not to the commit itself, but to the tree containing it. </li><li>  <b>name1..name2</b> - This and the following names refer to the range of commits and are very useful in commands of the type log to view the changes made in a selected period of time. <br>  In this case, the command addresses all previous commits starting with name2 up to (but not inclusive!) Name1.  If one of these names is omitted, then HEAD is used instead. </li><li>  <b>name1 ... name2</b> - The ellipsis in the range is not at all like two points.  For commands of type log, it denotes all commits referenced by either name1 or name2, but not both.  The result is a list of unique commits in both branches. </li><li>  <b>--since = "2 weeks ago"</b> - Address all commits, starting from the given date </li><li>  <b>--until = "1 week ago"</b> - Address all commits, up to the specified date </li><li>  <b>--grep = pattern</b> - Address all commits whose message matches the specified regular expression pattern. </li><li>  <b>--committer = pattern</b> - Addresses all commits entered into the repository by the person whose information matches the specified pattern. </li><li>  <b>--author = pattern</b> - Addresses all commits, information about the author of which fits a given pattern.  A commit author is the creator of the changes that the commit represents.  For local development, this is the same person who commits.  But when patches are sent by mail, the author and the person who actually commits is usually different. </li><li>  <b>--no-merges</b> - Address all commits with a single parent, i.e.  ignores merge commits </li></ul><br>  Most of these options can be combined.  Here is an example showing how to get information about all changes in the current branch (split from master) that I made in the last month and containing the text ‚Äúfoo‚Äù. <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> --grep=<span class="hljs-string"><span class="hljs-string">'foo'</span></span> --author=<span class="hljs-string"><span class="hljs-string">'johnw'</span></span> --since=<span class="hljs-string"><span class="hljs-string">"1 month ago"</span></span> master..</code> </pre> <br><h2>  <font color="#0071c5">Branching and rebase power</font> </h2><br>  One of the most effective commands for working with commits is the command with the unassuming name <i>rebase</i> .  It works like this: each existing branch in Git has one or more "basic commits" - those from which it originated.  Let's take an example of the following typical scenario (in the figure below).  Here, the arrows point back in time as each commit refers to its parent (s), but not descendants.  Therefore, D and Z are the headers of their branches. <br><br><img src="https://habrastorage.org/webt/wk/rz/ki/wkrzkivyqpiwdplybpirfptdm4k.png"><br><br>  You can verify this with the command <br><br><pre> <code class="bash hljs">$ git branch Z * D</code> </pre> <br>  And in detail: <br><br><pre> <code class="bash hljs">$ git show-branch ! [Z] Z * [D] D -- * [D] D * [D^] C * [D~2] B + [Z]Z + [Z^]Y + [Z~2] X + [Z~3] W +* [D~3] A</code> </pre> <br>  It is required to get used to this type of designation, but, in essence, this is just a description of the diagram above.  ( <i>comment of the translator: pay attention to the spaces in the record, they matter - they divide the output into columns</i> ) <br><br>  And that's what it tells us: <br><br>  Our current branch was first split into commit A (also known as commit <br>  D ~ 3, and even Z ~ 4 if you like it that way.  For those who missed the table above, let me remind you that the <i>commit ^</i> syntax is used to denote the commit parent, and <i>commit ~ 3</i> is its third-level ancestor, i.e.  great grandfather. <br><br><ul><li>  If you read from the bottom up, the first column (with the + signs) shows a budged Z branch with four commits ‚Äî W, X, Y, and Z. </li><li>  The second column (with asterisks) shows commits made in the current branch (and the * symbol always denotes it), namely three commits - B, C and D. </li><li>  And finally, the top of the output, separated from the bottom by a dividing line, shows a list of available branches, in which column their commits are and in which symbol they are marked. </li></ul><br>  Now we need to bring the working branch Z in accordance with the main D. Ie  include work done in B, C, and D in Z. In other version control systems, such things are done solely by the use of a <i>branch merge</i> .  In Git, there is also the possibility of merging.  It is implemented by the <i>merge</i> command and is used when Z is a published branch, and we do not want to change its commit history.  Here are the necessary commands for this: <br><br><pre> <code class="bash hljs">$ git checkout Z <span class="hljs-comment"><span class="hljs-comment">#    Z $ git merge D #  B, C  D  Z</span></span></code> </pre> <br>  Now the repository will look like this: <br><img src="https://habrastorage.org/webt/zg/jr/rv/zgjrrvshnrmxq0_iee731iwstzy.png"><br><br>  If we now select branch Z, it will contain everything that was there before, combined with the contents of D <i>(here the translator sighs heavily: the real merge operation would require resolving conflicts between states D and Z)</i> . <br><br>  Although the new Z now contains changes from D, it also includes the new commit Z ', which is a merger of Z and D. It does not add anything new, but it represents the work of combining Z and D. In a sense, this is ‚Äúmeta -commit "because its contents relate exclusively to the measurements of the repository, and not to the new work done in the working tree. <br>  But in Git there is a method of transplanting Z directly into D, actually moving Z in time - using the powerful rebase command.  ,      : <br><br><img src="https://habrastorage.org/webt/w1/hf/yy/w1hfyyknkwbct6w2teh_ncrcq6w.png"><br><br>  ,     Z        D.      <i>rebase</i> ‚Äî     ,    .      ,      ,         ,          . <br><br>  ,        rebase ‚Äî     merge : <br><br><pre> <code class="bash hljs">$ git checkout Z <span class="hljs-comment"><span class="hljs-comment">#    Z $ git rebase D #   Z,     D</span></span></code> </pre> <br> ,    <i>merge</i>  <i>rebase</i> . <br>  rebase   ‚Äî      ,   ,     ,          .       ,  merge. <br><br> ,           . ,  W   A,        A  W,       ,    D  W'.    W   ,   A+W+X    D+W'+X'   . ,      ,   Z ‚Äî .     ,    ,  -      Z,         Z,     Z'. <br><br>       ‚Äî  <i>rebase</i>   ,   ,      ‚Äî <i>merge</i> .  merge   ,           . <br><br><h2> <font color="#0071c5"> rebase</font> </h2><br>   <i>rebase</i> ,       W  Z,    Z   D (    D). ,      .    -i  rebase,    ,          Z. <br><br>     . <br><br><ul><li> <b>pick</b> () ‚Äî   ,      ,      .  ,         (  )  .    rebase    . </li><li> <b>squash</b> ()‚Äî    ¬´¬ª    .       .            ( ,  ,     ),    Z      D.    ,       ,   ,        . </li><li> <b>edit</b> () ‚Äî      ,   rebase ,     ,      ,    rebase --continue   ,      . </li><li> <b>drop</b> () ‚Äî       rebase,     ‚Äî ,      . ,       ,          . </li></ul><br><br>    rebase     ,            .    rebase : <br><br><ul><li>     , </li><li>  , </li><li>   ,     , </li><li>         , </li><li>         . </li></ul><br>  ,        <i>rebase</i> ,          .     ,  - <i>rebase</i> . <br><br>      ,    ,        ,    I    Z: <br><img src="https://habrastorage.org/webt/2d/9b/_m/2d9b_m0q0jsrv4wri_iv7jpwrou.png"><br><br>  ,       ‚Äî D,           Z.  -     ,   C  X     ,       ,     L.    ,    L ‚Äî ,   ,         D,         Z,     .     ,     J,        .  ,     : <br><br><pre> <code class="bash hljs">$ git checkout L $ git rebase -i Z</code> </pre> <br>     <i>(    )</i> ,    : <br><img src="https://habrastorage.org/webt/c-/gp/u3/c-gpu3qrd1r_lwopxc6kjnipl8a.png"><br><br><h2> <font color="#0071c5">:  </font> </h2><br>   ,       Git,   ,       ‚Äî Git .     ,      .     ,         ,       add.   , ,            .         .  ,          reset,    ,  ,   .  ‚Äî        ,       :    ,      CVS  Subversion,      Darcs ‚Äî      . <br><br><img src="https://habrastorage.org/webt/ci/k5/mv/cik5mv_te-ogxlzmpmtgpt4m5am.png"><br><br> ,  ,       ‚Äî    -a  commit.  , , ,      ‚Äî Subversion. <br><br>     <i>svn status</i> ,   ,          <i>svn commit</i> .  ¬´  ¬ª       ,          HEAD.  -   ,       .          ,    ,   ,    <i>svn add</i>    . <br><br>         Git  <i>commit -a</i> :    ,  ,    add,   ,  ,      . <br><br>     ,   <i>Subversion</i> ,   :   <i>Subversion</i> ¬´  ¬ª      ,   Git      ,  , ,     HEAD.          ‚Äî    ,      <i>commit</i> . <br><br>      ,     :       foo.c,        .         2  ,    .      <i>Subversion</i> : <br><br><pre> <code class="bash hljs">$ svn diff foo.c &gt; foo.patch $ vi foo.patch &lt; foo.patch,  ,       &gt; $ patch -p1 -R &lt; foo.patch <span class="hljs-comment"><span class="hljs-comment">#     $ svn commit -m "  " $ patch -p1 &lt; foo.patch #    $ svn commit -m "  "</span></span></code> </pre> <br>  ?           . <br><br>        Git,  : <br><br><pre> <code class="bash hljs">$ git add --patch foo.c &lt;     &gt; $ git commit -m <span class="hljs-string"><span class="hljs-string">"  "</span></span> $ git add foo.c <span class="hljs-comment"><span class="hljs-comment">#    $ git commit -m "  "</span></span></code> </pre> <br><h2> <font color="#0071c5">Reset   reset?</font> </h2><br>         Git  <i>reset</i> ‚Äî    ,   .   ,   <i>reset</i>     ,    HEAD.           . <br><br>  ,  <i>reset</i> ‚Äî   ,    .   ‚Äî   .           ,       Git. <br><br><h3> <font color="#0071c5">  reset</font> </h3><br>     --mixed (    ,   mixed ‚Äî   ), <i>reset</i>   ,   HEAD    .      -soft   ,  -soft    HEAD,   . <br><br><pre> <code class="bash hljs">$ git add foo.c <span class="hljs-comment"><span class="hljs-comment">#         $ git reset HEAD #   ,    $ git add foo.c #  ,   </span></span></code> </pre> <br><h3> <font color="#0071c5"> soft reset</font> </h3><br>  reset  -soft    HEAD   .        .      : <br><br><pre> <code class="bash hljs">$ git reset --soft HEAD^ <span class="hljs-comment"><span class="hljs-comment">#  HEAD   , ..     $ git update-ref HEAD HEAD^ #     </span></span></code> </pre> <br>           HEAD,     <i>git status</i> ,    .   ‚Äî      ,    ,       .         . <br><br>   ,         ,      <i>commit -amend</i> ,        ,       . <br><br> , , :           -    HEAD, ,      <i>reset</i> ,       ( <i>merge</i> )  ,      . <br><br>        soft reset   : <br><br><img src="https://habrastorage.org/webt/ap/up/qm/apupqmlkjwofleedjor9dku1gne.png"><br><br>      HEAD          ‚Äî       : <br><br><img src="https://habrastorage.org/webt/wr/m1/c_/wrm1c_6fw5mp1q5hzddiyvnvuxg.png"><br><br><h3> <font color="#0071c5"> hard reset</font> </h3><br>  --hard   <i>reset</i> ‚Äî   ,      hard reset   HEAD,            ,        HEAD. <br><br>     ‚Äî <i>checkout</i> ,    ,   reset --hard,    ,   .            . <br><br> ,    hard reset  -  ,       <i>reset --soft</i> ,   <i>reset -hard</i>     .  ,   : <br><br><pre> <code class="bash hljs">$ git reset --hard HEAD~3 <span class="hljs-comment"><span class="hljs-comment">#    ,   $ git reset --soft HEAD~3 #  HEAD    $ git reset --hard #     </span></span></code> </pre> <br>   , hard reset    .  ,          ‚Äî   <i>git stash</i> (.  ) <br><br><pre> <code class="bash hljs">$ git stash $ git checkout -b new-branch HEAD~3 <span class="hljs-comment"><span class="hljs-comment">#     ! new HEAD HEAD</span></span></code> </pre> <br>         ,      ,       : <br><br><ol><li>       (stash),         . ,        ,            ,       . </li><li> Stash      ,    .               ,      . </li></ol><br>         new-branch   ,       master,     : <br><br><pre> <code class="bash hljs">$ git branch -D master <span class="hljs-comment"><span class="hljs-comment"># ,  master (    reflog) $ git branch -m new-branch master # new-branch  master</span></span></code> </pre> <br>    :               <i>reset --soft</i>  <i>reset --hard</i> (    ),    ,     . Git        ,           ,     ,       master.      ! <br><br>       <i>reset -hard</i> ,      ,      master?     stash      (.  ),      . <br><br> ,   ,           reflog (    ): <br><br><pre> <code class="bash hljs">$ git reset --hard HEAD@{1} <span class="hljs-comment"><span class="hljs-comment">#   reflog  </span></span></code> </pre> <br>     Git   <i>stash</i>  <i>reset -hard</i> .        .    <i>stash</i> ,           : <br><br><pre> <code class="bash hljs">$ git stash <span class="hljs-comment"><span class="hljs-comment">#  ,      $ git reset --hard HEAD~3 #     $ git reset --hard HEAD@{1} # !   ,     $ git stash apply #      .</span></span></code> </pre> <br><br><h2> <font color="#0071c5">   : stash  reflog</font> </h2><br>        ,     Git:     ,       ,      ,      ,   ,    . <br><br> , ,         .  ‚Äî Git reflog, -,         .  ,              (    <i>commit</i> ),  ,        reflog,       : <br><br><pre> <code class="bash hljs">$ git reflog 5f1bc85... HEAD@{0}: commit (initial): Initial commit</code> </pre> <br>  reflog            .  ,     -     ( <i>reset</i> ),       reflog   30 ,     ¬´ ¬ª.        ,     . <br><br>    ,    ‚Äî    .       .  , ,   foo.c,        , Git     ,     ,     .      ,     Git.   ,     ,      SHA1  id,    : <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$git</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-object foo.c &lt; <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> id&gt;</code> </pre> <br>      ? ,             .         stash: ( <i>. .:       stash   ‚Äî ¬´¬ª</i> ) <br><br><pre> <code class="bash hljs">$ git stash</code> </pre> <br>       ,    ,    ,    :   , ,   ,    stash  ‚Äî     .        stash. <br><br>          stash   <i>stash apply</i> ,      reflog   . <br><br> ,   ,      ( WIP ‚Äî   ¬´Work in Progress¬ª ‚Äî ¬´‚Ä¶¬ª: <br><br><pre> <code class="bash hljs">$ git stash list stash@{0}: WIP on master: 5f1bc85... Initial commit $ git reflog show stash <span class="hljs-comment"><span class="hljs-comment">#      id  stash  2add13e... stash@{0}: WIP on master: 5f1bc85... Initial commit $ git stash apply</span></span></code> </pre> <br>      stash     ,        ,         .  ,     ,  ,                : <br><br><pre> <code class="bash hljs">$ git stash list stash@{0}: WIP on master: 73ab4c1... Initial commit ... stash@{32}: WIP on master: 5f1bc85... Initial commit $ git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> stash@{32} <span class="hljs-comment"><span class="hljs-comment">#    ? $ git show stash@{32} #  ,     $ git checkout -b temp stash@{32} #      !</span></span></code> </pre> <br>    : ,                 !        ,     :  stash  ,      (,     -     ),    <i>stash apply</i>    . <br>      stash ‚Äî ,       30 ,   stash clear,     reflog expire <br><br><pre> <code class="bash hljs">$ git stash clear <span class="hljs-comment"><span class="hljs-comment">#   !      $ git reflog expire --expire=30.days refs/stash &lt;   stash &gt;</span></span></code> </pre> <br>   stash            ‚Äî         .       stash   ,     (Unix OS): <br><br><pre> <code class="bash hljs">$ cat &lt;&lt;EOF &gt; /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/git-snapshot <span class="hljs-comment"><span class="hljs-comment">#!/bin/sh git stash &amp;&amp; git stash apply EOF $ chmod +x $_ $ git snapshot</span></span></code> </pre> <br>        ,        ,    ‚Äî  reflog expire <br><br><h2>  <font color="#0071c5">findings</font> </h2><br>            .        .     ,     .           ,        .           ,   ,       . Git     , ,   ‚Äî      . <br><br>  ‚Äî       ,   ,        .  ,   Git,     .      ,         ,  Git. <br><br>            ‚Äî  , ,            . Git      .  ,           . <br><br> <i><b> </b> .     2009 .        git    <a href="https://github.com/intel/ARM_NEON_2_x86_SSE"> </a>  GitHub, , ,  ,           Git.   ?  ,      .</i> </div><p>Source: <a href="https://habr.com/ru/post/344962/">https://habr.com/ru/post/344962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344950/index.html">Does Ketchapp clone games?</a></li>
<li><a href="../344952/index.html">Winter internship for mobile developers at Redmadrobot</a></li>
<li><a href="../344954/index.html">Time is money. As we taught Yandeks.Taksi accurately calculate the cost of the trip</a></li>
<li><a href="../344956/index.html">For those who were afraid, but still ready to try. (Excel)</a></li>
<li><a href="../344960/index.html">Phone number without a passport</a></li>
<li><a href="../344964/index.html">FAQ on integration with ESIA</a></li>
<li><a href="../344966/index.html">HyperRAM: Using a HyperBus Memory Interface Chip</a></li>
<li><a href="../344968/index.html">Translation - Maximum Usage APK Analyzer</a></li>
<li><a href="../344970/index.html">ChatScript Intelligent Chatbots: Development Practice and JavaScript Integration</a></li>
<li><a href="../344972/index.html">Found the largest database of stolen passwords: what you should know</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>