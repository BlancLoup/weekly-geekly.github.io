<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Canvas to GIF in Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I'll tell you about the features that I encountered while saving the image from the canvas in the GIF. 
 There will be considered ready-made solutions...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Canvas to GIF in Javascript</h1><div class="post__text post__text-html js-mediator-article"><img src="http://habrastorage.org/storage2/8bd/2c3/1f2/8bd2c31f23fbe5125e76734e0abd2b9c.png"><br>  I'll tell you about the features that I encountered while saving the image from the canvas in the GIF. <br>  There will be considered ready-made solutions and my own javascript image quantization code (that is, reducing the palette to 256 colors).  Also, the performance issues of some javascript constructions will be affected. <br><a name="habracut"></a><br><h4>  Briefly about why you need such a converter </h4><br>  Honestly, it‚Äôs not at all necessary to convert images using Javascript.  Server languages, such as PHP, C #, JAVA, do a good job with this task.  But if there is a Javascript image editor, which works with canvas, which already knows how to produce pictures in jpg and png formats, then at least it is ugly to separate the logic into the client and server parts.  It is for the inner beauty of the application that I took up this issue.  I want the entire application to be on javasript. <br><br><h4>  We are building bricks </h4><br>  Convert canvas to JPEG or PNG is not difficult.  One function is enough for this: <br><br><pre><code class="javascript hljs">canvas.toDataURL(mime)</code> </pre> <br>  The result of this faction will be the base64 DatURL string, which you can, for example, easily substitute for the img tag src attribute. <br>  The mime parameter can be either ‚Äúimage / png‚Äù or ‚Äúimage / jpeg‚Äù. <br>  If you transfer ‚Äúimage / gif‚Äù or ‚Äúimage / bmp‚Äù as mime, the result will still be in PNG format. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since there are a lot of programmers on our planet, I decided to find out if someone had encountered such a problem and if someone had reached out to solve it. <br>  I was lucky, I quickly found a code on the Internet that saves the canvas in the BMP format: <a href="http://www.nihilogic.dk/labs/canvas2image">www.nihilogic.dk/labs/canvas2image</a> <br>  After tearing out the piece of code I needed, I started on the GIF. <br><br>  But with GIF it was not so simple. <br>  Almost all searches on the topic ‚Äúcanvas to gif‚Äù are directed to the antimatter15 library: <a href="http://github.com/antimatter15/jsgif">github.com/antimatter15/jsgif</a> <br>  Therefore, I tried it first.  Plus, she has one: she still produces a picture in GIF format, which, among other things, can be animated.  Apparently, only the animation was focused, because I did not see any image quality or conversion speed. <br><br>  antimatter15 (PNG to GIF, 100x16px, 56ms): <br><img src="https://habrastorage.org/storage2/ab9/763/dba/ab9763dbaa990fcf479780beb9bfd327.png"><br><br>  antimatter15 (JPEG to GIF, 604x377px, 4564ms): <br><img src="https://habrastorage.org/storage2/96b/497/02b/96b49702b8e4b84f19fa52007506bfab.png"><br><br>  antimatter15 (Transparent PNG to GIF, 256x256px, 1052ms): <br><img src="https://habrastorage.org/storage2/11c/25b/b42/11c25bb427cee1036487ed7aade06281.png"><br><br>  As you can see, all the pictures have distorted colors.  But the third is a special case. <br>  Let me explain what happened to the last picture.  The source file was in PNG format with transparent pixels.  Canvas provides information about pixels in RGBA format, that is, three colors and a level of transparency.  But the antimatter15 library simply ignores the pixel transparency level and it turns out a completely incorrect result. <br><br>  In fairness, I note that the canvas2image library also does not perceive the level of transparency. <br>  canvas2image (Transparent PNG to BMP, 256x256px): <br><img src="https://habrastorage.org/storage2/6c5/3c4/1f4/6c53c41f46861d81eea0e2e8c036c0f1.png"><br><br>  Therefore, I urge everyone not to ignore alpha bytes, which we graciously provide the canvas. <br><br>  Further searches led me to omggif (javascript implementation of GIF 89a encoder, includes animation and compression): <a href="https://github.com/deanm/omggif">github.com/deanm/omggif</a> <br>  Having seen an example that generates a transparent pixel, I immediately began to respect this library. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1x1 transparent 43 bytes. function gen_empty_trans() { var gf = new omggif.GifWriter(buf, 1, 1, {palette: [0x000000, 0x000000]}); gf.addFrame(0, 0, 1, 1, [0], {transparent: 0}); return buf.slice(0, gf.end()); }</span></span></code> </pre><br>  But as you can see from the example, it does not work with canvas.  When you create an object, you need to give a ready-made palette (color list), and when adding a frame, an array of indices in the palette. <br>  Creating a palette and indexes, as it turned out, is nothing more than quantization (quantization).  In the library from antimatter15, a separate NeuQuant.js file was responsible for this.  In omggif there is no quantizer. <br>  I looked at several quantizers for javascript, but no one worked with transparency. <br>  Thanks to the omggif library, I no longer needed to understand the GIF file format, and the quantization task seemed to me not so difficult and even interesting.  Therefore, it was decided to finish the converter yourself. <br><br><h4>  The algorithm for creating palettes and indexes </h4><br>  So, at first I divided the quantization process into 4 stages: <br><ol><li>  Search for pixels to include in the palette. </li><li>  Identify colors that do not fall into the palette. </li><li>  For each color that didn‚Äôt fall into the palette, search for the nearest color from the palette </li><li>  Convert all pixels to color indexes in the palette. </li></ol><br><h5>  Stage 1 </h5><br>  The most important is the first stage.  The quality of the resulting image depends on it.  If the remaining steps are concrete - it is just some conversion of one data array to another, then the first item looks somewhat abstract.  It is not immediately clear by what criteria to evaluate which of the colors is more important than the other. <br><br>  Then I decided not to go deep into this question, but simply reduce the canvas until the number of colors in it is less than 255 (one color is always transparent).  Since scaling is performed by the browser, this part of the algorithm turned out to be the fastest.  Only 20ms for a jpg file with a dog (see above) from 1500ms of the execution of the entire algorithm. <br><br>  Experimentally, I found out that the best way to reduce the picture exactly twice.  Otherwise colors are distorted. <br><br>  Also, given the transparency byte, I applied the following formulas for each pixel: <br><br><pre>  red = 0xFF-alpha * (1-red / 0xFF)
 green = 0xFF-alpha * (1-green / 0xFF)
 blue = 0xFF-alpha * (1-blue / 0xFF) </pre><br>  Thus, all the components of the color I put on a white background.  At the same time, if alpha is 0, then this pixel is completely transparent and it is skipped. <br><br><h5>  Stages 2 and 3 </h5><br>  Next you need to go through all the pixels again and put those pixels that did not fall into the main palette into a separate array (additional palette). <br>  In parallel, when a new pixel is detected, we will determine the closest color from the palette.  If we represent the red, blue and green color components as the coordinate of a point in three-dimensional space, then the difference between two colors is the distance between two points.  And the distance between points is determined by the well-known formula of Pythagoras: <br><br><pre>  d = sqrt ((x1 - x2) ^ 2 + (y1 - y2) ^ 2 + (z1 - z2) ^ 2) </pre><br>  So, we have a main palette and an additional palette - colors that did not fall into the main palette.  And each color of the additional palette has the closest color in the main palette. <br>  Now is the time to pay attention to the first stage.  Due to the fact that the image each time was reduced twice already, the main palette will most likely not be complete.  Instead of 255, it can contain as many as 100 or less colors.  Therefore, you need to supplement the main palette. <br><br><h5>  Additional stage </h5><br>  We will complement with colors that have the maximum difference from the colors in the main palette.  At what we will add one at a time and each time recalculate an additional palette with respect to the added color.  And when the main palette reaches 255 colors or the additional palette is exhausted, we move on to the final stage. <br><br><h5>  Stage 4 </h5><br>  It's simple.  We pass an array of pixels and determine the color index in the main palette by the color of the pixel.  If in the main palette of this color is not, then look for it in an additional palette.  And each color in the additional palette already has the closest color from the main palette. <br><br><h4>  Algorithm Optimization for Javascript </h4><br>  During the implementation of the algorithm on Javascrpt, I came across some features of this language that significantly influenced speed. <br><br><h5>  Optimization of the difference formula in two colors </h5><br>  Let's start by calculating the minimum difference between the two colors.  I will cite several variants of the Pythagorean formula in Javascript.  What do you think is the fastest option? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Math.sqrt(Math.pow(red1-red2,2)+Math.pow(green1-green2,2)+Math.pow(blue1-blue2,2)) // 2 var mypow = function(a){ return a*a; }; Math.sqrt(mypow(red1-red2)+mypow(green1-green2)+mypow(blue1-blue2)) // 3 Math.sqrt((red1-red2)*(red1-red2)+(green1-green2)*(green1-green2)+(blue1-blue2)*(blue1-blue2)) // 4 var distance = function(a,b,c){ return Math.sqrt(a*a+b*b+c*c); }; distance(red1-red2, green1-green2,blue2-blue2)</span></span></code> </pre><br>  I'll start the hit parade with the slowest option - option number 2. The self-written squaring function was 2.5 times slower than the built-in Math.pow.  But if we use the 3rd option, the same part of the algorithm will be executed more than 10 times faster than Math.pow.  From here I conclude that in javascript very slowly the function call occurs.  And the fourth option confirms this, working 10 times slower than the third. <br>  Let's try to increase the speed.  In fact, the result of the calculation of the formula will be used only to search for the minimum and maximum color difference.  Therefore, you can safely remove the square root calculation. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 (red1-red2)*(red1-red2)+(green1-green2)*(green1-green2)+(blue1-blue2)*(blue1-blue2)</span></span></code> </pre><br>  Thus, we increase the speed of the third variant by another 1.5 times. <br>  Moreover, further optimization has little effect on speed.  The following option gives almost the same speed: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 (red=red1-red2)*red+(green=green1-green2)*green+(blue=blue1-blue2)*blue</span></span></code> </pre><br>  Comparative table of the second and third stages with three pictures: <br><table><tbody><tr><th></th><th>  Dog </th><th>  Alpha romeo </th><th>  Browser Icons </th></tr><tr><td>  Math.sqrt (Math.pow (r1-r2,2) + Math.pow (g1-g2,2) + Math.pow (b1-b2,2)) </td><td>  17211ms </td><td>  1762ms </td><td>  117ms </td></tr><tr><td>  Math.sqrt (mypow (r1-r2) + mypow (g1-g2) + mypow (b1-b2)) </td><td>  40790ms </td><td>  3875ms </td><td>  255ms </td></tr><tr><td>  Math.sqrt ((r1-r2) * (r1-r2) + (g1-g2) * (g1-g2) + (b1-b2) * (b1-b2)) </td><td>  1250ms </td><td>  149ms </td><td>  14ms </td></tr><tr><td>  distance (r1-r2, g1-g2, b2-b2) </td><td>  15006ms </td><td>  1556ms </td><td>  99ms </td></tr><tr><td>  (r1-r2) * (r1-r2) + (g1-g2) * (g1-g2) + (b1-b2) * (b1-b2) </td><td>  779ms </td><td>  104ms </td><td>  12ms </td></tr><tr><td>  (r = r1-r2) * r + (g = g1-g2) * g + (b = b1-b2) * b </td><td>  740ms </td><td>  100ms </td><td>  10ms </td></tr></tbody></table><br><h5>  Palette array optimization </h5><br>  First, I used an array of colors to store the palette.  Adding a new color happened like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(palette.indexOf(color) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) palette.push(color);</code> </pre><br>  But in a large array, the execution of indexOf is a very slow function, since it in turn compares all the elements with the desired one. <br>  Therefore, I changed this option to a faster one: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!palette[color)) palette[color]=<span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  This option of filling the main palette worked much faster, and when filling an additional palette, which can turn out to be much larger than the main one, the difference was 2 orders of magnitude.  In order not to calculate the component colors each time, I decided to cache them in the palette: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!palette[color)) palette[color]={<span class="hljs-attr"><span class="hljs-attr">r</span></span>:red, <span class="hljs-attr"><span class="hljs-attr">g</span></span>:green, <span class="hljs-attr"><span class="hljs-attr">b</span></span>:blue};</code> </pre><br><br>  But after filling the palette, the algorithm involves many cycles of passage: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> palette){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rgb=palette[color]; }</code> </pre><br>  Here, on the contrary, work with the object turned out to be much slower than if we worked with an array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>, n=palette.length; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pal=palette[i]; }</code> </pre><br>  Therefore, it is better to use an array (palette) to store the palette, and to check whether there is a color in the palette, use the object (exists): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!exists[color)){ exists[color]=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; palette.push({<span class="hljs-attr"><span class="hljs-attr">c</span></span>:color, <span class="hljs-attr"><span class="hljs-attr">r</span></span>:red, <span class="hljs-attr"><span class="hljs-attr">g</span></span>:green, <span class="hljs-attr"><span class="hljs-attr">b</span></span>:blue}); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>, n=palette.length; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pal=palette[i]; }</code> </pre><br><h5>  Cycle optimization </h5><br>  I will dwell a bit on testing different ways of passing cycles: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 for(var i=0, n=palette.length; i&lt;n; i++){ var pal=palette[i]; } // 2 for(var i=0; i&lt;palette.length; i++){ var pal=palette[i]; } // 3 for(var i=0, pal; pal=palette[i]; i++){ }</span></span></code> </pre><br>  Recently, I have been using the last option more, since for me it is the most convenient.  But if you look at the performance, the situation is ambiguous.  Almost no difference.  Judge for yourself: <br><table><tbody><tr><th></th><th>  Dog </th><th>  Alpha romeo </th><th>  Browser Icons </th></tr><tr><td>  for (var i = 0, n = palette.length; i &lt;n; i ++) </td><td>  238ms </td><td>  51ms </td><td>  3,5ms </td></tr><tr><td>  for (var i = 0; i &lt;palette.length; i ++) </td><td>  244ms </td><td>  55ms </td><td>  3,5ms </td></tr><tr><td>  for (var i = 0, pal; pal = palette [i]; i ++) </td><td>  230ms </td><td>  54ms </td><td>  3,5ms </td></tr></tbody></table><br><br><h4>  Result </h4><br>  PNG to GIF, 100x16px, 35ms: <br><img src="http://habrastorage.org/storage2/aa9/570/b25/aa9570b2573dc014056d6bdb7ae7d6e5.png"><br><br>  JPEG to GIF, 604x377px, 1338ms: <br><img src="http://habrastorage.org/storage2/8bd/2c3/1f2/8bd2c31f23fbe5125e76734e0abd2b9c.png"><br><br>  Transparent PNG to GIF, 256x256px, 268ms: <br><img src="http://habrastorage.org/storage2/50e/e12/767/50ee12767ec1b420eaf708715ee3bb26.png"><br><br>  I am pleased with the result.  The pictures turned out better than the library from antimatter15 gave.  The speed was acceptable.  Well, transparency byte is taken into account. <br><br><div class="spoiler">  <b class="spoiler_title">Here is my code</b> <div class="spoiler_text">  (The main functions of canvasToGIFDataURL and canvasPalette) <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// base64 encodes either a string or an array of charcodes var encodeData = function(data) { var strData = ""; if (typeof data == "string") { strData = data; } else { var aData = data; for (var i=0;i&lt;aData.length;i++) { strData += String.fromCharCode(aData[i]); } } return btoa(strData); }; var readCanvasData = function(oCanvas) { var iWidth = parseInt(oCanvas.width); var iHeight = parseInt(oCanvas.height); return oCanvas.getContext("2d").getImageData(0,0,iWidth,iHeight); }; var makeDataURI = function(strData, strMime) { return "data:" + strMime + ";base64," + strData; }; var cW=0xff; var canvasPalette=function(canvas){ var oData = readCanvasData(canvas), data=oData.data, exists={}, palette=[]; for(var i = 0, n=data.length; i &lt; n; i+=4){ var a=data[i+3]; if(a==0) continue; var r=(cW-a*(1-data[i]/cW))|0, g=(cW-a*(1-data[i+1]/cW))|0, b=(cW-a*(1-data[i+2]/cW))|0, col=b+(g&lt;&lt;8)+(r&lt;&lt;16); if(!exists[col]){ if(palette.length&gt;=255){ var subcanvas=document.createElement('canvas'), width=oData.width&gt;&gt;1, height=oData.height&gt;&gt;1; subcanvas.width=width; subcanvas.height=height; subcanvas.getContext('2d').drawImage(canvas, 0, 0,width,height); return canvasPalette(subcanvas); } else{ exists[col]=true; palette.push({c:col,r:r,g:g,b:b}); } } } return {exists:exists, palette:palette}; } var canvasToGIFDataURL = function(canvas){ var dr,dg,db; var oData = readCanvasData(canvas); var data=oData.data; var palette=canvasPalette(canvas); var exists=palette.exists; palette=palette.palette; var outpalette=[]; var pixels=[]; var maxdDifI=null; var maxdDif=0; for(var i = 0,pi=0,l=data.length; i &lt; l; i+=4, pi++){ var a=data[i+3]; if(a==0){ pixels[pi]=-1; continue; } var r=(cW-a*(1-data[i]/cW))|0, g=(cW-a*(1-data[i+1]/cW))|0, b=(cW-a*(1-data[i+2]/cW))|0, col=b+(g&lt;&lt;8)+(r&lt;&lt;16); pixels[pi]=col; if(!exists[col]){ exists[col]=true; var minDif=0xffffff, minDifColIndex=null; for(var j=0, nj=palette.length; j&lt;nj; j++){ var pal=palette[j], d=(dr=pal.rr)*dr+(dg=pal.gg)*dg+(db=pal.bb)*db; if(d&lt;minDif){ minDif=d; minDifColIndex=j; } } if(minDif &gt; maxdDif) { maxdDif=minDif; maxDifI=outpalette.length; } outpalette.push({c:col, d:minDif, r:r, g:g, b:b, index:minDifColIndex}); } } while(maxdDif!=null &amp;&amp; palette.length&lt;255){ var dif=outpalette.splice(maxdDifI,1)[0]; maxdDif=null; maxdDifI=0; var r=dif.r, g=dif.g, b=dif.b, col=dif.c; var index=palette.length; palette.push({c:col,r:r,g:g,b:b}); for(var j=0, nj=outpalette.length; j&lt;nj; j++){ var dif=outpalette[j], d=(dr=dif.rr)*dr+(dg=dif.gg)*dg+(db=dif.bb)*db; if(d&lt;dif.d){ dif.d=d; dif.index=index; } if(dif.d &gt; maxdDif) { maxdDif=dif.d; maxDifI=j; } } } var map={}; palette.unshift({c:-1}); for(var j=0,pal; pal=palette[j]; j++){ var col=pal.c; map[col]=j; palette[j]=col; } for(var j=0,dif; dif=outpalette[j]; j++){ map[dif.c]=dif.index+1; } var indexes=[]; for(var i = 0, pixel; pixel=pixels[i]; i++){ indexes.push(map[pixel]); } for(var l=2;l&lt;=256;l=l&lt;&lt;1){ if(palette.length==l) break; if(palette.length&lt;l) { while(palette.length&lt;l) palette.push(0); break; } } var buf = []; var gf = new GifWriter(buf, oData.width, oData.height, {palette: palette}); gf.addFrame(0, 0, oData.width, oData.height, indexes,{transparent: 0}); var binary_gif = buf.slice(0, gf.end()); return makeDataURI(encodeData(binary_gif), 'image/gif'); };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Source pictures</b> <div class="spoiler_text">  Browser Icons <br><img src="http://habrastorage.org/storage2/bc9/2a7/670/bc92a767082dd835a0801070f18a808d.png"><br><br>  Dog <br><img src="http://habrastorage.org/storage2/59b/70e/7dd/59b70e7ddda62c1278de9ec4cd097e3a.jpg"><br><br>  Alpha romeo <br><img src="http://habrastorage.org/storage2/6b3/9f6/1b7/6b39f61b767067a33a6d9362b7113d06.png"><br></div></div><br>  Now I can say with confidence: <br>  - Convert images to Javascript! </div><p>Source: <a href="https://habr.com/ru/post/173773/">https://habr.com/ru/post/173773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173763/index.html">Ukraine launches IBM Global Entrepreneur program</a></li>
<li><a href="../173765/index.html">DevTools video course from Google and Codeschool</a></li>
<li><a href="../173767/index.html">Useful tips for beginners in the design for Android</a></li>
<li><a href="../173769/index.html">Using Selenium WebDriver to automatically test the Yandex.Mail web interface</a></li>
<li><a href="../173771/index.html">Ray Kurzweil spoke about the first two months of working at Google.</a></li>
<li><a href="../173777/index.html">A bit of "organic" * in the five-inch compartment</a></li>
<li><a href="../173781/index.html">Low cost IEMs with great sound from SoundMAGIC (E10 and PL30 models)</a></li>
<li><a href="../173783/index.html">Quantum mechanics for all, for nothing, and let no one leave offended: part two</a></li>
<li><a href="../173785/index.html">Restore a broken Coreldraw file</a></li>
<li><a href="../173787/index.html">One task, three tools: cPanel, ISPmanager and Plesk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>