<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Study for a programmer or a crisscross puzzle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think many habrovchanam familiar book "Etudes for Programmers" by Charles Wetherell. If not, here you can read an interview with the author and a sm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Study for a programmer or a crisscross puzzle</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage2/f01/f4d/d9c/f01f4dd9c0272d397f0082c774805192.jpg"><br>  I think many habrovchanam familiar book "Etudes for Programmers" by Charles Wetherell.  If not, <a href="http://habrahabr.ru/post/150238/">here</a> you can read an interview with the author and a small review of the book.  I myself most recently got this thing in my hands, and it was decided to implement one of the tasks. <br><br>  So I propose to disassemble with you one of the etudes.  We will write in Java, work with graphics and GUI + and analyze an iteration algorithm <i>with a return</i> to find our solution.  It is unlikely that the article will interest the pros, but for beginners, and especially for those who are just learning Java, the article may be useful. <br>  All interested - welcome! <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  Here I will give an excerpt from "Etudes", which will introduce the reader to the picture. <br><blockquote>  Many consider crossword puzzles to be too difficult a puzzle, because they cannot guess the word.  But like letters in cells like.  For such people, there is a simpler puzzle - criss-cross.  Each criss-cross consists of a list of words, divided for convenience into groups according to length and ordered alphabetically within each group, as well as from the scheme into which the words should be written.  The scheme follows the same rule as in a crossword puzzle - at the intersection of the word have a common letter, but the numbers are missing, because the words are known in advance, you only need to enter them in the right places. </blockquote><br>  An example of such a puzzle you can see in the picture. <br><img src="https://habrastorage.org/storage2/9e1/3f2/365/9e13f236527569c784047f326278f61c.jpg"><br>  Honestly, I don‚Äôt really like to write letters into the cells, so our program will simply issue a ready-made, completed scheme + a small bonus.  The list of words will be read from a text file.  If there are many who want to solve such puzzles, I will gladly add this opportunity. <br>  Nous, from words to deeds - the task is there, the desire is there, let's go! <br><br><h4>  Architecture </h4><br>  Well, or <i>How will we all store and draw</i> . <br>  I had a lot of options, at this stage I reworked everything almost from scratch several times.  I think there will be those who see the solution easier and more elegant, in any case, sensible criticism is welcome. <br>  The original idea is to create a class ‚Äúcells with a letter‚Äù and a class container for these cells ‚Äúword‚Äù.  Each ‚Äúcell with a letter‚Äù stores its own symbol, plus two logical coordinates, multiplying these coordinates by the cell size (constant) can easily determine the place where the cell and symbol are drawn.  The main difficulty here for me was that all words are divided into two types: horizontal and vertical.  Accordingly, all their processing with this approach will also have two versions.  I wanted to get rid of it. <br>  The next thought: each word has one coordinate common to all cells of horizontal words, Y, and vertical X. Let's do this: we will have a ‚Äúword coordinate‚Äù, a constant value for this word, and each cell in turn contains only one coordinate , different for all cells in the word.  ‚ÄúFuuuuuh, somehow intricate,‚Äù you will say, but I haven‚Äôt found a better solution, maybe it will be clearer in the code.  By the way, at the end of the article look for a link on <b>GitHub</b> , you can see the project code in its entirety. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Our "letter cell" </h6><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharCell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variableCoord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CELL_SIZE = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> variableCoord )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variableCoord = variableCoord; } ... }</code> </pre> <br><h6>  Our "word" </h6><br>  This class contains the CharCell array ‚Äî all the letters of our word, the coordinate of this word, and the <i>int orientation</i> field, which, as you might guess, can have two values <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HORIZ = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VERTIC = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Such is the simple and certainly unsafe implementation of transfers, I apologize in advance, but I did not want to dwell on this point for a long time. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Word</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CharCell [] cells; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> orientation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wordCoord; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String word, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordCoord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialVariableCoord )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.orientation = orientation; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wordCoord = wordCoord; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length = word.length(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharCell[length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; length ; i++ ) { cells[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharCell( word.charAt(i), initialVariableCoord + i ) ; } } ... }</code> </pre><br>  As you can see, the code for creating a new word does not depend at all on its ‚Äúorientation‚Äù in space, nor will there be any differences in processing in other, more complex functions ‚Äî additions, checks, etc.  But first things first, let's consider for now how our letters are actually drawn. <br><br><h6>  Drawing </h6><br>  The drawing code lies in the <i>CharCell</i> class and is enclosed in the <i>showCharCell</i> method (see below) it is here that we divide the horizontal and vertical words. <br>  To start drawing, you need to define a class that inherits <i>JComponent</i> and override the <i>paintComponent ()</i> method.  Such a class in our program is the <i>WordArea</i> class, which will be discussed later.  It is from this class that the <i>showCharCell</i> function takes <i>Graphics2D</i> and other parameters.  The <i>paintComponent ()</i> method gets one parameter of the type <i>Graphics</i> , which contains all the drawing methods and a set of settings for the image drawings, shapes and text.  Every time the window needs to be drawn, the <i>paintComponent ()</i> method of all its components is executed. <br><br>  Actually the procedure of drawing our "cell with a letter" <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCharCell</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Graphics2D g2D, Font font, FontRenderContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orient, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> constCoord )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> coordX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> coordY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( orient == Orientation.HORIZ ) { coordX = variableCoord * CELL_SIZE; coordY = constCoord * CELL_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { coordX = constCoord * CELL_SIZE; coordY = variableCoord * CELL_SIZE; } String s = String.valueOf(value); Rectangle2D bounds = font.getStringBounds( s, context ); LineMetrics metrics = font.getLineMetrics( s, context ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> descent = metrics.getDescent(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leading = metrics.getLeading(); Rectangle2D.Double rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle2D.Double( coordX, coordY, CELL_SIZE, CELL_SIZE ); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = rect.getX() + (rect.getWidth() - bounds.getWidth())/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = rect.getY() + rect.getHeight() - descent - leading; g2D.draw( rect ); g2D.drawString( s, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)y ); }</code> </pre><br>  The <i>getStringBounds ()</i> method returns a rectangle bounding the string we want to draw.  We need this so that our letter is exactly in the middle of the drawn square.  To align with the width, first we get the width of the square in which we want to enter our letter, a part of this width is occupied by a letter, hence the size of the empty space on each side is half the difference between the width of the square and the width of the character.  I think the code should be clear.  To align height, we subtract the landing depth of symbols and leading ( <i>descent</i> and <i>leading</i> ) from the bottom side of our square.  Now all our letters are carefully drawn in their cells. <br>  A <i>Word</i> class method that will draw any word elementary: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showWord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Graphics2D g2D, Font font, FontRenderContext context )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; length ; i++ ) { cells[i].showCharCell ( g2D, font, context, orientation, wordCoord ); } }</code> </pre><br>  It's time to touch the most difficult class of our etude - <i>WordArea</i> <br>  As mentioned above, it is a <i>JComponent</i> and contains a slightly modified <i>ArrayList &lt;Word&gt; mainWordArea</i> .  This is our word scheme; adding a new word to it is very simple to <i>mainWordArea.add (new Word (‚ÄúWord‚Äù, Orientation.HORIZ, x, y))</i> , this is how our program adds words to our scheme, trying all possible options. <br>  Well, here is <i>paintComponent ()</i> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintComponent</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Graphics g )</span></span></span><span class="hljs-function"> </span></span>{ Graphics2D g2D = ( Graphics2D ) g; g2D.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); context = g2D.getFontRenderContext(); g2D.setFont( font ); Iterator&lt;Word&gt; wordAreaIter = mainWordArea.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( wordAreaIter.hasNext() ) wordAreaIter.next().showWord( g2D, font, context ); }</code> </pre><br>  Just go through all the words in <i>mainWordArea</i> , <i>rendering</i> each one of them. <br><br>  I hope I managed to convey to the reader the logic of the program, and we can go further, especially since all the preparations are over and it's time to solve our puzzle! <br><br><h4>  Enumeration Return </h4><br>  Backtracking is a general method for finding solutions to a problem in which a complete search of all possible options is required.  You can read more <a href="http://en.wikipedia.org/wiki/Backtracking">here</a> .  I will tell only the very idea about our program. <br>  It will try to add a new word from the list as long as possible, as soon as it becomes impossible to add a new word to the scheme, go back a step, delete the last added word and try to add another.  Such an algorithm will find us all possible options, it would seem not bad, but such a program works very slowly, and for a list of 10 words I could not wait until it was executed. <br>  Turning to our book for help, Weatherell writes: <br><blockquote>  The quality of the criss-cross schemes is proportional to their ‚Äúconnectedness‚Äù, that is, the closer the words are intertwined with their neighbors, the more interesting the puzzle.  When your program runs, take care of increased connectivity. </blockquote><br>  Connected!  - that's the key to optimizing our program.  The connection will be calculated as the ratio of the number of intersections in the scheme, to its area.  In doing so, going through all the options, we will immediately discard potentially non-optimal (poorly coupled partial solutions). <br>  At this stage, I <i>am</i> ready to present you with the actual brute force method itself - <i>wordsBackTracking ()</i> <br>  It will call several other helper methods.  The <i>reject ()</i> method will be responsible for the deviation of non-optimal partial solutions.  Perhaps because of this approach, there is a list of words for which the program will not produce the most optimal solution, but in most cases the result is quite good.  The <i>accept ()</i> method will determine whether we have reached a decision or not.  I will not post all auxiliary methods here, anyone can look at the source code.  Well, I will introduce the main bundle. <br><div class="spoiler">  <b class="spoiler_title">wordsBackTracking ()</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** *      (Backtracking) *   - */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wordsBackTracking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ArrayWord&lt;Word&gt; wordArea, List&lt;String&gt; words )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( accept( wordArea ) ) { ArrayWord&lt;Word&gt; tempWordArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayWord&lt;Word&gt;( wordArea ); copyArrayWord( tempWordArea, wordArea ); allWordArea.add( tempWordArea ); mainWordArea = tempWordArea; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( reject( wordArea, words ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; words.size() ; i++ ) { List&lt;String&gt; tempWords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;String&gt;( words ); String newWord = tempWords.get(i); tempWords.remove(i); addNewWord( wordArea, tempWords, newWord ); } } <span class="hljs-comment"><span class="hljs-comment">/** *   ,    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewWord</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ArrayWord&lt;Word&gt; wordArea, List&lt;String&gt; words, String newWord )</span></span></span><span class="hljs-function"> </span></span>{ Word existentWord; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; wordArea.size() ; k++ ) { existentWord = wordArea.get(k); <span class="hljs-comment"><span class="hljs-comment">///        for ( int i = 0 ; i &lt; existentWord.length() ; i++ ) { for ( int j = 0 ; j &lt; newWord.length() ; j++ ) { if ( existentWord.get(i).value() == newWord.charAt(j) ) { int newOrient = invert( existentWord.orientation() ); int newWordCoord = existentWord.get(i).coord(); int initialVariableCoord = existentWord.coord() - j; Word word = new Word (newWord,newOrient,newWordCoord,initialVariableCoord); ///  ""  -   int interCount = wordArea.intersectCount(); if ( check ( wordArea, word, existentWord.coord() ) ) { wordArea.add ( word ); ///   (0,0)   int minX = wordArea.minX(); int minY = wordArea.minY(); if ( existentWord.orientation() == Orientation.HORIZ ) wordArea.setMinY( initialVariableCoord ); else wordArea.setMinX( initialVariableCoord ); ///   wordsBackTracking ( wordArea, words ); ///    wordArea.remove( wordArea.size()-1 ); wordArea.reset(); wordArea.setMinX( minX ); wordArea.setMinY( minY ); wordArea.setInterCount( interCount ); } } } } } }</span></span></code> </pre><br></div></div><br>  <i>wordsBackTracking</i> takes two arguments: a criss-cross word scheme (with one word, several or all), and a list of words that have not yet been used.  If the solution is right, remember it.  If the solution is not optimally exit the function, reducing the search tree. <br>  The <i>addNewWord ()</i> method tries to add a new word to the scheme, making sure that it does not violate the rules of creating crossword puzzles, when it turns out, it moves to the next level of recursion again calling <i>wordsBackTracking ()</i> .  So these two indirectly recursive functions find quite suitable schemes.  Too long lists of words, I do not advise you to ask, but the example from the book is once or twice. <br><img src="http://habrastorage.org/storage2/b7a/f4f/d05/b7af4fd0522b950d14c66c7d43324306.jpg"><br>  I almost forgot about the promised bonus, if you can call it that: as a attentive reader could see, all our found solutions are saved, and by clicking the mouse on the frame you can view them.  I think it will be interesting to see how the program finds more and more elegant solutions. <br>  Here is another example of 16 words: <br><img src="http://habrastorage.org/storage2/c7d/486/97d/c7d48697d0d59719dd5a7265ebfb0609.jpg"><br><br><h6>  Thanks for attention! </h6><br>  As promised link to <a href="https://github.com/MIchaelKa/crisscross">github</a> <br>  File with words words.txt <br>  Collect: javac CrissCrossFrame.java <br>  Run: java CrissCrossFrame <br>  On this, dear reader, allow me to bow out and thank you again for reading. </div><p>Source: <a href="https://habr.com/ru/post/166471/">https://habr.com/ru/post/166471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166459/index.html">Students are expelled for using a web vulnerability scanner</a></li>
<li><a href="../166463/index.html">How to find packages and modules for import into Python</a></li>
<li><a href="../166465/index.html">Elophant: at least some access to API League of Legends</a></li>
<li><a href="../166467/index.html">IBM's Watson program went to study in honey. institute</a></li>
<li><a href="../166469/index.html">Dialog boxes in Android. Part 1</a></li>
<li><a href="../166473/index.html">Ultimatum</a></li>
<li><a href="../166475/index.html">Design Camp: how it was</a></li>
<li><a href="../166479/index.html">Lenovo P770 - ‚Äúlong-playing‚Äù smartphone with a 3500mAh battery</a></li>
<li><a href="../166481/index.html">Chinese threat: Android without Google?</a></li>
<li><a href="../166483/index.html">BranchCache in Windows Server 2012 and Windows 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>