<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GCCGO versus "standard" implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Which Go benchmarks show the best results when compiled by gccgo and why? 


 Answers to these questions under the cut. 
 Introduction 


 Currently t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GCCGO versus "standard" implementation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/2f/wu/k7/2fwuk7bfhnrzpldv_zdahdvqpnm.jpeg"><br><br><p>  Which <a href="https://golang.org/">Go</a> benchmarks show the best results when compiled by <a href="https://gcc.gnu.org/onlinedocs/gccgo/">gccgo</a> and why? </p><br><p>  Answers to these questions under the cut. </p><a name="habracut"></a><br><h1 id="vvedenie">  Introduction </h1><br><p>  Currently there are two of the most mature implementations of the Go programming language: </p><br><ol><li>  gc (5g / 6g / 8g / etc.) is the first, "standard" implementation. </li><li>  gccgo is the frontend of the GCC compiler for Go. </li></ol><br><p>  Task setting: find such benchmarks from the standard Go distribution that run in less time when compiling gccgo.  For each significant deviation find the causes of the observed effect. </p><br><p>  The previous similar comparison was made in 2013: <br>  <a href="https://dave.cheney.net/2013/11/19/benchmarking-go-1-2rc5-vs-gccgo">benchmarking Go 1.2rc5 vs gccgo</a> . </p><br><p>  Missing technical details that may be important for reproducing and validating results can be found in the <a href="https://github.com/Quasilyte/gccgo_vs_gc">github repository</a> . </p><br><h1 id="chto-i-kak-izmeryalos">  What and how was measured </h1><br><p>  Since gccgo is lagging behind releases from gc, Go 1.8.1 (GCC 7.2) was used. </p><br><p> Many <code>Benchmark*</code> functions from the standard library packages, as well as all tests from <code>$GOROOT/test/bench/go1</code> . <br>  The full list is listed in <a href="https://github.com/Quasilyte/gccgo_vs_gc/blob/master/packages.txt">packages.txt</a> . </p><br><p>  For GCC, the flags used are " <code>-O3 -march=native</code> ". <br>  Results are available for <a href="https://en.wikipedia.org/wiki/Intel_Core">Intel Core</a> and <a href="https://en.wikipedia.org/wiki/Xeon">Intel Xeon</a> . <br>  <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX2</a> and <a href="https://en.wikipedia.org/wiki/FMA_instruction_set">FMA</a> were available on both machines. <br>  More information about test machines can be found in the <a href="https://github.com/Quasilyte/gccgo_vs_gc/tree/master/stats">/ stats</a> section. </p><br><p>  <a href="https://godoc.org/golang.org/x/perf/cmd/benchstat">Benchstat was</a> used to identify statistically significant deviations. </p><br><p>  An additional test was a comparison with the Go tip version (1.10). <br>  Some of the discrepancies in Go 1.10 are corrected, but some of the advantages of gccgo may persist forever due to the special approach of gc, in which compile time is an important indicator. </p><br><h1 id="obschaya-kartina-vse-rezultaty-v-odnoy-diagramme">  The big picture: all results in a single diagram </h1><br><p>  Before building a general diagram, the following actions were performed: </p><br><ul><li>  Removed anomalies such as zero runtime (explanation below). </li><li>  Removed benchmarks with the same execution time ( <code>gccgo.time=gc.time</code> ). </li><li>  The runtime difference is smoothed using logarithms. </li></ul><br><p><img src="https://habrastorage.org/webt/vy/qc/tp/vyqctpuqppszlo8kxdr32niavqw.png"></p><br><p>  Axis X: benchmarks. <br>  Y axis: the ratio of the gccgo runtime to gc. <br>  If the value of Y is above 0, the program compiled by gccgo runs slower. </p><br><p>  Most tests have significantly better results on gc. <br>  The main advantage over gccgo is <a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">escape analysis</a> . </p><br><p>  There are also deviations in favor of the gccgo (118/808 tests). </p><br><h1 id="suzhenie-oblasti-poiska">  Narrowing the search area </h1><br><p>  Any slight discrepancy in performance is inevitable in any case, so instead of examining all 118 cases, we will filter: </p><br><ol><li>  First remove all the results in which the delta is less than ~ 10%. </li><li>  For the remaining tests we will compare with Go 1.10. <br>  We remove those that in Go 1.10 caught up (or overtook) gccgo. </li><li>  All that remains is considered in more detail. </li></ol><br><p>  The first two points led to intermediate tables that can be viewed. <br>  in the section <a href="https://github.com/Quasilyte/gccgo_vs_gc/tree/master/human-readable">/ human-readable</a> . </p><br><pre> <code class="hljs php">=&gt; ~<span class="hljs-number"><span class="hljs-number">62</span></span>  . =&gt;   ~<span class="hljs-number"><span class="hljs-number">39</span></span>   <span class="hljs-number"><span class="hljs-number">1.10</span></span>. =&gt;   ~<span class="hljs-number"><span class="hljs-number">26</span></span>   .</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">In fact...</b> <div class="spoiler_text"><p>  All 118 tests were investigated. <br>  Some of them didn‚Äôt look stable enough. <br>  For some of the results, I did not find a clear explanation. <br>  Because of this, for the final format, it was decided to perform the filtering described above. </p><br><p>  In the repository, to which the link was repeatedly cited, you can find the "raw" data <br>  according to which anyone can make an analysis in the way he considers more correct. </p></div></div><br><h1 id="samye-interesnye-rezultaty">  The most interesting results </h1><br><p> <a href="" title="Click to enlarge"><img src="https://habrastorage.org/webt/gh/8j/ka/gh8jkatskvya52ty_9hnmeu34qs.png"></a> </p><br><p>  <em>(The diagram is clickable.)</em> </p><br><p>  In the table below, each of the tests is assigned one or more of the most significant reasons, which lead to the acceleration observed above in comparison with gc. <br>  If they are eliminated, then the performance becomes almost identical. </p><br><p>  Almost all the reasons are in the form of GCC optimization flags. <br>  These flags were found by selecting (enabling / disabling) the minimum set of optimization flags that would reduce the performance gap. </p><br><p>  A description of the GCC optimization flags can be found <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">here</a> . </p><br><table><thead><tr><th>  Title </th><th>  The most significant reasons </th></tr></thead><tbody><tr><td> <code>EmptyOpContext</code> </td> <td>  Unused call result <abbr title="The benchmark tests the performance of the function, ignoring the return result. Sometimes this leads to the removal of a call by the optimizer.">[1]</abbr> </td></tr><tr><td> <code>Int31n1000</code> </td> <td>  Unused call result; <code>-finline-functions</code> </td></tr><tr><td> <code>FDCT</code> </td> <td> <code>-ftree-loop-vectorize</code> </td> </tr><tr><td> <code>Modf</code> </td> <td> <code>-mavx</code> </td> </tr><tr><td> <code>Gamma</code> </td> <td> <code>-mfma</code> </td> </tr><tr><td> <code>Sincos</code> </td> <td> <code>-mfma</code> </td> </tr><tr><td> <code>Ilogb</code> </td> <td> <code>-mfma</code> </td> </tr><tr><td> <code>IndexBytePortable/32</code> </td> <td>  Slowing on short cycles <abbr title="It is for the test with n = 32 that this slowdown occurs. It was not possible to reproduce this result in a free context.">[2]</abbr> </td></tr><tr><td> <code>Frexp</code> </td> <td>  Unused call result; <code>-finline-functions</code> </td></tr><tr><td> <code>IDCT</code> </td> <td> <code>-ftree-loop-vectorize</code> </td> </tr><tr><td> <code>Log2</code> </td> <td>  <code>-mfma</code> (depends on <code>Frexp</code> ) </td></tr><tr><td> <code>Lgamma</code> </td> <td> <code>-mfma</code> </td> </tr><tr><td> <code>Erfc</code> </td> <td> <code>-mfma</code> </td> </tr><tr><td> <code>Erf</code> </td> <td> <code>-mfma</code> </td> </tr><tr><td> <code>Max</code> </td> <td>  <code>-mfma</code> ; <code>-finline-functions</code> </td></tr><tr><td> <code>Logb</code> </td> <td> <code>-mavx</code> </td> </tr><tr><td> <code>TrimSpace</code> </td> <td> <code>-finline-functions</code> </td> </tr><tr><td> <code>SkipValue</code> </td> <td> <code>-msse4.1</code> </td> </tr><tr><td> <code>Nextafter64</code> </td> <td>  <code>-finline-functions</code> ; <code>-ftree-loop-vectorize</code> </td></tr><tr><td> <code>Int63n1000</code> </td> <td> <code>-finline-functions</code> </td> </tr><tr><td> <code>Floor</code> </td> <td>  <code>-mavx</code> ( <code>-mavx</code> instruction) </td></tr><tr><td> <code>Int63Threadsafe</code> </td> <td> <code>-finline-functions</code> </td> </tr></tbody></table><br><p>  <strong>[1] The</strong> benchmark tests the performance of the function, ignoring <br>  return result.  Sometimes this leads to the removal of the call by the optimizer. </p><br><p>  <strong>[2]</strong> It is for the test with <code>n=32</code> that this slowdown occurs. <br>  It was not possible to reproduce this result in a free context. </p><br><p>  The rest of the article deals with the most significant optimizations that led to the observed results.  Also touched on the topic is not quite correct benchmarks, which do not work for gccgo, but <em>still</em> work for gc. </p><br><h1 id="gccgo--better-inlining">  gccgo = better inlining </h1><br><p>  By default, Go 1.10 can embed only leaf functions.  Leaf functions are functions that do not contain calls to other functions.  Exceptions are other leaf functions, if the "embedding budget" of the containing function is not exceeded by embedding its body. </p><br><p>  Simplified, here are the restrictions for inline functions: </p><br><ul><li>  Total (after all embeddings) does not exceed a certain threshold of complexity. </li><li>  Does not contain prohibited items.  <a href="https://github.com/golang/go/issues/14768">golang # 14768 - for-loops cannot be inlined</a> . </li><li>  Sheet is.  <a href="https://github.com/golang/go/issues/19348">golang # 19348 - enable mid-stack inlining</a> . </li></ul><br><p>  The calculation of the "price function" occurs <em>before</em> optimizations. <br>  This often leads to the fact that if it matters to you whether a function is embedded or not, you will have to change the structure of the code to be semantically equivalent, but at a lower price, without taking into account optimizations. </p><br><p>  Moreover, the current model has a flaw: cascaded embedded calls increase the total cost of the function.  This makes inline wrapper functions not so free from the inliner's point of view. </p><br><p>  You can check whether a function is embedded or not using special compiler flags.  On the effect of <code>gcflags="-l=4"</code> read closer to the conclusion. </p><br><h1 id="gccgo--better-constant-folding">  gccgo = better constant folding </h1><br><p>  How often have you seen similar benchmarks on Go? </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* . ,    "". */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkFoo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { foo(<span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     foo } }</span></span></code> </pre> <br><p>  Notice the comment to the line calling <code>foo(50)</code> . <br>  The optimizer can remove both the call itself and the entire cycle inside the <code>BenchmarkFoo</code> . <br>  For gccgo, this is the right way to get benchmarks that run 0 nanoseconds: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   YCbCrToRGB/</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-params"><span class="hljs-params">|128|</span></span><span class="hljs-number"><span class="hljs-number">255</span></span>)   YCbCrToRGB/*. /<span class="hljs-regexp"><span class="hljs-regexp">/ gc.time gccgo.time delta YCbCrToRGB/</span></span>* <span class="hljs-number"><span class="hljs-number">12.1</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>.0ns -<span class="hljs-number"><span class="hljs-number">100.00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>8 n=<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">5</span></span>) RGBToYCbCr/* <span class="hljs-number"><span class="hljs-number">12.8</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>.0ns -<span class="hljs-number"><span class="hljs-number">100.00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>8 n=<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">5</span></span>) YCbCrToRGBA/* <span class="hljs-number"><span class="hljs-number">13.8</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% -<span class="hljs-number"><span class="hljs-number">94.78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">000</span></span> n=<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>) NYCbCrAToRGBA/* <span class="hljs-number"><span class="hljs-number">18.5</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.0</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">6</span></span>% -<span class="hljs-number"><span class="hljs-number">94.72</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>8 n=<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  The following is a fairly common idiom: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkBar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { sink = bar(<span class="hljs-number"><span class="hljs-number">50</span></span>) } }</code> </pre> <br><p>  She has two problems: </p><br><ol><li>  Constant function argument </li><li>  The assumption that the assignment of a global (non-exported) variable magically cancels unwanted optimizations. </li></ol><br><p>  Both of these problems are also found in the benchmarks of the standard Go library. </p><br><p>  gccgo can embed the values ‚Äã‚Äãof global variables that in its opinion do not change in the program.  In gc (at least for now) only constants and local data are subject to this optimization. </p><br><p>  When the <code>sink</code> value is not used anywhere, it will not matter whether this variable changes or not.  Like unused exportable functions, gccgo deletes variables that no one ‚Äúreads‚Äù. </p><br><p>  If the function call is embedded (and this happens more often in gccgo), then there is a risk of a complete calculation of the loop body (potentially along with the loop itself) at the compilation stage. </p><br><p>  In real-world applications, it is not often possible to ‚Äúcollapse‚Äù entire cycles at the compilation stage, but some Go benchmarks fall under this optimization. <br>  In them we get a magical acceleration of 100%. </p><br><h1 id="gccgo--better-machine-dependent-optimizations">  gccgo = better machine-dependent optimizations </h1><br><p>  The gc compiler does not generate instructions from extensions after <a href="https://ru.wikipedia.org/wiki/SSE2">SSE2</a> . <br>  This makes binaries under x64 more portable, but potentially less optimal. </p><br><p>  With flags such as <code>-march=native</code> , gccgo can generate <br>  more efficient code for a specific machine on which you plan to run the application. </p><br><p>  We can also attribute vectorization to machine-specific optimizations, since its efficiency is rather limited without access to AVX extensions. <br>  In the current version of gc, there is no vectoring per se, unless you consider combining several movements into one (up to 16 bytes, using SSE). </p><br><p>  Due to the fact that Go has no traditional intrinsic functions, it is necessary to write assembler implementations to achieve maximum acceleration. <br>  <a href="">Go 1.10 assembler</a> supports most of the instructions available on modern x86_64. <br>  There is a chance that you can use AVX512 in Go 1.11 ( <a href="https://github.com/golang/go/issues/22779">golang # 22779 - AVX512 design</a> ). </p><br><table><tbody><tr><td>  Assembler functions are not built in, which sometimes puts an end to productivity, unless you implement the <strong>entire</strong> algorithm in assembly language. <br></td></tr></tbody></table><br><h1 id="gccgo--better-calling-convention">  gccgo = better calling convention </h1><br><p>  For both <code>GOARCH=386</code> and for <code>GOARCH=amd64</code> gc uses a stack to pass arguments and return the results of functions.  In the 64-bit mode, more registers are available, so using the stack for this purpose is not optimal. </p><br><p>  There is some discussion of the <a href="https://github.com/golang/go/issues/18597">register-based calling convention</a> . <br>  It is not easy to judge the potential performance gains at this stage, because now the optimizer does not perform some transformations that are beneficial only for <code>reg-&gt;reg</code> displacements.  Nowadays, <code>mem-&gt;reg-&gt;mem</code> movements are much more characteristic. </p><br><p>  5-10%, discussed in the discussion above, may well turn into 15-30% for individual functions. </p><br><table><tbody><tr><td>  One of the main drawbacks of the new calling convention is the inability of all existing assembly code, which is abound even inside Go. <br></td></tr></tbody></table><br><h1 id="vklyuchaem-mid-stack-inlining">  Include mid-stack inlining </h1><br><p>  Evaluate the effect of <code>-gcflags="-l=4"</code> on those benchmarks, where gccgo showed the best results by using more opportunities for embedding functions. </p><br><p>  Ratio is calculated as <code>gccgo.time/gc.time</code> . </p><br><table><thead><tr><th>  Title </th><th>  Ratio to </th><th>  Ratio after </th></tr></thead><tbody><tr><td> <code>math/rand/Int31n1000</code> </td> <td>  0.77 </td><td>  1.00 <strong>(+0.23)</strong> </td></tr><tr><td> <code>math/rand/Int63n1000</code> </td> <td>  0.82 </td><td>  0.93 <strong>(+0.11)</strong> </td></tr><tr><td> <code>math/rand/Int63Threadsafe</code> </td> <td>  0.80 </td><td>  1.00 <strong>(+0.20)</strong> </td></tr><tr><td> <code>math/Frexp</code> </td> <td>  0.84 </td><td>  0.84 (=) </td></tr><tr><td> <code>math/Max</code> </td> <td>  0.73 </td><td>  0.73 (=) </td></tr><tr><td> <code>math/Nextafter64</code> </td> <td>  0.61 </td><td>  0.81 <strong>(+0.20)</strong> </td></tr><tr><td> <code>bytes/TrimSpace</code> </td> <td>  0.70 </td><td>  0.80 <strong>(+0.10)</strong> </td></tr></tbody></table><br><p>  ( <em>Note</em> : these tests were run with a different configuration, as a separate experiment.) </p><br><p>  Opinion Russ Cox on the use of <code>-l=4</code> in Go 1.9 / 1.10: </p><br><blockquote>  <em>-l = 4 is explicitly untested and unsupported for production use.</em> <em><br></em>  <em>If you‚Äôre doing that, you‚Äôll get programs that get you to keep both pieces.</em> <br>  <a href="https://github.com/golang/go/issues/19348">Link to the message</a> </blockquote><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Making the right performance measurements for gccgo is more difficult than for gc. <br>  It feels like you are implementing benchmarks for C ++ rather than Go (similar "problems"). </p><br><p>  For some specific tasks, gccgo can give some performance boost. <br>  For example, mathematical calculations with the inclusion of the correct GCC optimization flags receive a measurable acceleration, but the rest of the application will be hit. <br>  Considering the features of the most typical programs on Go, the more important part of the application is likely to slow down (an exception may be simple command line utilities). </p><br><p>  Like all performance measures, this study should be evaluated in the context of the specific versions that were used in the comparison. <br>  A significant step forward for gccgo would be high-quality escape analysis. <br>  For gc from the upcoming revolutions, we can name the above-mentioned new convention of challenges and full integration of functions. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348230/">https://habr.com/ru/post/348230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348220/index.html">Reason on which database to choose</a></li>
<li><a href="../348222/index.html">The second part of the comparison of python and tcl</a></li>
<li><a href="../348224/index.html">Simple intent classifier</a></li>
<li><a href="../348226/index.html">Developing a game for Android on Python based on Kivy. From A to Z: pitfalls and non-obvious solutions. Part 1</a></li>
<li><a href="../348228/index.html">News from the world of OpenStreetMap ‚Ññ393 (01/23/2018-29.01.2018)</a></li>
<li><a href="../348232/index.html">3CX v15.5 SP3 Beta: updated conferences, improved hosting and new pricing policy</a></li>
<li><a href="../348234/index.html">Telegram bots. Downloading files larger than 50mb</a></li>
<li><a href="../348236/index.html">Programmer career</a></li>
<li><a href="../348238/index.html">Reverse takeover: VMware can buy Dell</a></li>
<li><a href="../348240/index.html">Native validation as a framework. Lecture in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>