<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern-matching (one more) in coffeescript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Once I was sitting and looking sadly at the Erlang code written as part of a study. I really wanted to write something more useful than...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern-matching (one more) in coffeescript</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Once I was sitting and looking sadly at the Erlang code written as part of a study.  I really wanted to write something more useful than tic-tac-toe on it, but as luck would have it, no suitable tasks occurred to me.  But there is JavaScript, in which there are functions of the first order, and currying, and map / filter / fold, and, most importantly, the task of inventing much easier.  But pattern matching doesn't exist.  A quick search gave me a few libraries, but the syntax suggested by them seemed heavy to me.  Is it possible to make it more concise, closer to the native Erlang syntax? <br><br>  Spoiler: you can, if you take a coffeescript, do this: <br><br><pre><code class="coffeescript hljs">fn = Match -&gt; [ When {command: ‚Äúdraw‚Äù, figure: @figure = {type: ‚Äúcircle‚Äù, radius: @radius}}, <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(@figure, @radius) When {command: ‚Äúdraw‚Äù, figure: @figure = {type: ‚Äúpolygon‚Äù, points: [@first, @second | @rest]}}, <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(@figure, @first, @second, @rest); ] fn {command: ‚Äúdraw‚Äù, figure: {type: ‚Äúcircle‚Äù, radius: <span class="hljs-number"><span class="hljs-number">5</span></span>, color: ‚Äúred‚Äù}} <span class="hljs-comment"><span class="hljs-comment">#output: {type: ‚Äúcircle‚Äù, radius: 5, color: ‚Äúred‚Äù} 5</span></span></code> </pre> <br>  Who cares how it happened - welcome under cat. <br><a name="habracut"></a><br><h2>  Short description </h2><br>  Actually, what is happening here, if in brief: <br><ol><li>  Match accepts a function that returns an array of patterns (patterns) and their corresponding actions; </li><li>  When you call, the context is replaced, so all these &amp; commat; a (== this.a) point to specially prepared properties (properties) that allow the parser to figure out which values ‚Äã‚Äãto bind to; </li><li>  Further, when calling with a specific value, a comparison with the template is made (for the time being, we can assume that there is a recursive detour of the template and value and comparison of specific values, a little more about it will be discussed below); </li><li>  If the value matches the pattern, then the function-action is called.  In her, we also change the context, substituting the appropriate values. </li></ol><br>  So, if we take the example above, then com commat; radius in the first argument When indicates which part of the input object should be removed (in this case, .figure.radius), and in the second argument (function) it also contains a specific value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Work with arrays </h2><br>  Erlang has a convenient syntax for splitting a list into a head (the first element) and a tail (everything else), which is widely used for various recursive algorithms. <br><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> List <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [Head | Tail] -&gt; Head; [] -&gt; {empty}; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  In javascript (and coffeescript) there is no possibility to redefine operators, therefore you can only do something like regular tools using regular tools: <br><br><pre> <code class="coffeescript hljs">When [@head, @tail‚Ä¶], <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(@head, @tail)</code> </pre><br>  In principle, not bad, but in erlang somehow nicer.  Can it still somehow be possible, at least for a number of scenarios? <br>  Here it is worth remembering how generally javascript manages to perform an operation like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object1 = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, object2 = {<span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object1 | object2);</code> </pre><br>  And get 0. This works as javascript tries to reduce the type to a numeric type, for which it calls the valueOf method on the object.  If we change the method of our objects and return the power of two, then as a result you can find out which objects the operation was applied to. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object1 = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, object2 = {<span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>}, object3 = {<span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; object1.valueOf = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } object2.valueOf = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>; } object3.valueOf = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object1 | object2); <span class="hljs-comment"><span class="hljs-comment">//6 == 2 | 4 == object1 and object2</span></span></code> </pre><br>  A bold assumption was made that very rarely would anyone use arrays of concrete numbers in patterns, so if the parser encounters a number at the end of the array, it tries to determine if this is the result of an operation or two objects.  As a result, it became possible to write like this: <br><br><pre> <code class="coffeescript hljs">When [@head | @tail], <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(@head, @tail)</code> </pre><br>  It looks nice, but outside of this task I would not use this method everywhere. <br><br><h2>  Class mapping </h2><br>  The next thing I wanted was to make a comparison of the structures as in Erlang, with an indication of the type and content. <br><br><pre> <code class="erlang hljs">#person{name = Name}</code> </pre><br>  Right so, of course, will not succeed, but something similar can be done.  In the end, I settled on three solutions: <br><br><pre> <code class="coffeescript hljs">When ObjectOf(Point1, {x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span>}), <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> ‚Ä¶ When Point2(x:<span class="hljs-number"><span class="hljs-number">1</span></span>, y:<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> ‚Ä¶ When Point3$(x:<span class="hljs-number"><span class="hljs-number">1</span></span>, y:<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> ...</code> </pre><br>  The first one works out of the box, the second one looks almost like a case class on scala, but it requires inserting such a string into the constructor. <br><br><pre> <code class="coffeescript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">: (@</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectOf</span></span></span><span class="hljs-class">(@, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arguments</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  This is needed to understand whether a function was called as a constructor or not, the constructor itself and the arguments fall into the template. <br><br>  The third option is a variation on the first one; we simply prepare the function in advance: <br><br><pre> <code class="coffeescript hljs">Point3$ = ObjectOf(Point3)</code> </pre><br><h2>  Performance </h2><br>  The first naive version performed a comparison of the pattern and values, passing them recursively.  Basically, I expected the performance to be not up to par when compared with a simple parsing of an object.  But it was worth checking out. <br><br><div class="spoiler">  <b class="spoiler_title">Manual analysis</b> <div class="spoiler_text"><pre> <code class="coffeescript hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">coffeeDestruct</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(demo)</span></span></span><span class="hljs-function"> -&gt;</span></span> {user} = demo <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> user.enabled {firstname, group, mailbox, settings} = user <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> group.id != <span class="hljs-string"><span class="hljs-string">"admin"</span></span> notifications = settings?.mail?.notify ? [] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mailbox?.kind != <span class="hljs-string"><span class="hljs-string">'personal'</span></span> mailboxId = mailbox?.id ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> {unreadmails, readmails} = mailbox; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unreadmails.length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> firstUnread = unreadmails?[<span class="hljs-number"><span class="hljs-number">0</span></span>] ? [] restUnread = unreadmails?.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>) ? [] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> readmails?.length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> readmails?[<span class="hljs-number"><span class="hljs-number">0</span></span>]?.subject != <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> rest = readmails?.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {firstname, notifications, firstUnread, restUnread, rest, mailboxId}</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Template</b> <div class="spoiler_text"><pre> <code class="coffeescript hljs">singlePattern = Match -&gt; [ When {user: { firstname: @firstname, enabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, group: {id: <span class="hljs-string"><span class="hljs-string">"admin"</span></span>}, settings: {mail: {notify: @notifications}}, mailbox: { id: @mailboxId, kind: <span class="hljs-string"><span class="hljs-string">"personal"</span></span>, unreadmails: [ @firstUnread | @restUnread ], readmails: [ {subject: <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>}, Tail(@rest) ] } }}, <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"ok"</span></span> ]</code> </pre><br></div></div><br><br>  Results for 10,000 comparisons: <br><br><pre> Regular: 5ms
 Single Pattern: 140ms
 Multiple patterns: 429ms
</pre><br>  Yes, not that I want to see in production.  Why not convert the pattern to code close to the first example? <br><br>  No sooner said than done.  We go on a pattern and we make the list of conditions and intermediate variables. <br><br>  An interesting feature came out here.  The first version of the compiled function was almost identical to the handwritten parse, but the performance was worse than one and a half times.  The difference was in the way the result object was created: it turned out that creating an object with the specified fields is cheaper than creating an empty object and filling it in later.  For verification, I made this <a href="http://jsperf.com/change-object-vs-create-object">benchmark</a> .  After that, I found two articles on this topic - <a href="https://msdn.microsoft.com/en-us/library/windows/apps/hh781219.aspx">here</a> and <a href="http://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/">now</a> - and also a <a href="http://habrahabr.ru/post/154537/">Habr√©</a> translation. <br><br>  Spent the optimization, run: <br><br><pre> Regular: 5ms
 Single Pattern: 8ms
 Multiple patterns: 164ms
</pre><br>  The second number looks good, but what about the third and why is it still big?  The third is a match expression with several templates, where only the last one is triggered.  Since templates are compiled independently, we get a linear dependence on the number of templates. <br><br>  But in reality, the templates will be very similar - we will analyze objects that differ in some details, and at the same time have a similar structure.  Let's say here: <br><br><pre> <code class="coffeescript hljs">fn = Match -&gt; [ When [<span class="hljs-string"><span class="hljs-string">"wait"</span></span>, <span class="hljs-string"><span class="hljs-string">"infinity"</span></span>], <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"wait forever"</span></span>) When [<span class="hljs-string"><span class="hljs-string">"wait"</span></span>, @time = Number], <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"wait for "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time + <span class="hljs-string"><span class="hljs-string">"s"</span></span>) ]</code> </pre><br>  In both cases, the array consists of two elements and the first is ‚Äúwait‚Äù, the only difference is in the second.  And the parser will do two almost identical functions and will call them one by one.  Let's try to combine them. <br><br>  The meaning is simple: <br><ol><li>  Parser instead of the code will issue a chain of "commands"; </li><li>  Then all the commands are taken and are gathered in one chain with the branches; </li><li>  Now the commands are turned into code. </li></ol><br>  It is worth noting that if we went into one chain, then in case of failure we should not go out, but try the next chain.  I have seen three ways to achieve this: <br><br>  <b>1. Nested conditions</b> <br><br><pre> <code class="coffeescript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-string"><span class="hljs-string">'wait'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-string"><span class="hljs-string">'infinity'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {when: <span class="hljs-number"><span class="hljs-number">0</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">1</span></span>].constructor.name === <span class="hljs-string"><span class="hljs-string">'Number'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {when: <span class="hljs-number"><span class="hljs-number">1</span></span>}; } } } }</code> </pre><br>  It looks awful, and even when generating the code it would not be confused in brackets.  Not. <br><br>  <b>2. Nested functions</b> <br><br><pre> <code class="coffeescript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Array.isArray(val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val.length !== <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-string"><span class="hljs-string">'wait'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res = function fork1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-string"><span class="hljs-string">'infinity'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {when: <span class="hljs-number"><span class="hljs-number">0</span></span>} }()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res = function fork2() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">1</span></span>].constructor.name !== <span class="hljs-string"><span class="hljs-string">'Number'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {when: <span class="hljs-number"><span class="hljs-number">1</span></span>}; }()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res;</code> </pre><br>  Looks better.  But they are straining additional checks and returns, since there is no way to return immediately from an external function (well, except through exceptions, but this is not serious). <br><br>  <b>3. Breaking <s>bad</s> label</b> <br><br><pre> <code class="coffeescript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Array.isArray(val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val.length !== <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-string"><span class="hljs-string">'wait'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; fork1: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-string"><span class="hljs-string">'infinity'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> fork1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {when: <span class="hljs-number"><span class="hljs-number">0</span></span>} } fork2: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val[<span class="hljs-number"><span class="hljs-number">1</span></span>].constructor.name !== <span class="hljs-string"><span class="hljs-string">'Number'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> fork2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {when: <span class="hljs-number"><span class="hljs-number">1</span></span>}; }</code> </pre><br>  It looks good and to me, like an old sishnik, it immediately seemed that this option would be faster.  <a href="http://jsperf.com/return-fn-vs-break-loop">A quick check on jsperf</a> confirmed my guess.  So on this option and stop. <br><br>  Let's look at the performance: <br><br><pre> Regular: 5ms
 Single Pattern: 8ms
 Multiple patterns: 12ms
</pre><br>  It is quite acceptable.  Leave as is. <br><br><h2>  Architecture and Plugins </h2><br>  After adding another functionality by adding new if-s in two different places, I decided to rework the architecture.  Now, instead of the two large functions parse and render, functions parse and render smaller appear, which themselves do not really do anything, but each part of the template is sent along a chain of plug-ins.  Each plugin can: <br><ul><li>  process your piece of the pattern and turn it into a set of commands; </li><li>  say what to parse on; </li><li>  turn your teams into code. </li></ul><br>  For example, the plugin for comparison with the constructor looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pluginConstructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        //    ,       parse_object //  parse,       parse_function: function(part, f) { //    "constructor" //        - .   f.addCheck("constructor", part.name); }, //    ""    "constructor" //  ,     if. render_constructor: function(command, varname) { return varname + ".constructor.name === " + JSON.stringify(command.value); } }; }</span></span></code> </pre><br>  This allowed, on the one hand, to simplify the addition of new features to myself, and on the other, to enable users to add their own plugin and extend the syntax of the templates.  For example, you can add support for regular expressions so that you can write like this: <br><br><pre> <code class="coffeescript hljs">fn = Match -&gt; [ When @res = <span class="hljs-regexp"><span class="hljs-regexp">/(\d+):(\d+)/</span></span>, <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> hours: @res[<span class="hljs-number"><span class="hljs-number">1</span></span>], mins: @res[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-comment"><span class="hljs-comment"># or When RE(/(\d+):(\d+)/, @hours, @min), -&gt; hours: @hours, mins: @mins ]</span></span></code> </pre><br><h2>  Comparison with other solutions </h2><br>  As I wrote at the very beginning, I tried to look for similar solutions, and this is what was found: <br><ul><li>  <a href="">matches.js</a> - similar functionality, similar performance, but patterns are specified as a string - therefore neither highlighting nor rendering common parts into variables </li><li>  the ideological heir to the <a href="https://github.com/natefaubion/sparkler">sparkler</a> - apparently has a similar functionality, but uses the sweet.js macros for syntax, i.e.  code will have to be further compiled.  In general, the problems are the same, although the templates look nicer </li><li>  <a href="https://github.com/CRogers/pun">The pun.js</a> syntax is similar (only in templates instead of @a it is proposed to write $ ('a')), but there are fewer possibilities (for example, arrays of variable length are not supported) and performance is lower - apparently they do not compile. </li></ul><br>  Performance comparison with matches.js, pun and manual analysis can be found <a href="http://jsperf.com/procrust-js-vs-manual-parsing/2">here</a> . <br><br><h2>  Conclusion </h2><br>  Here in general, that's all.  The code itself can be found <a href="https://github.com/AlexeyGrishin/procrust">here</a> .  Despite the fact that the syntax is sharpened under coffeescript, the library itself is written in javascript and can be used in other languages ‚Äã‚Äãcompiled in js. <br><br>  A few cons in pursuit: <br><ol><li>  Splitting arrays into ‚Äúhead‚Äù and ‚Äútail‚Äù is useful for recursive algorithms, but without optimization of tail recursion, there can be problems with performance and stack overflow on large volumes. <br>  <em>Solution: not yet invented</em> <br><br></li><li>  You cannot use functions in templates ‚Äî or rather, you can use them, but they will be called only once when the template is compiled. <br>  <em>Solution: use guards</em> <br><br></li><li>  Because of this context substitution, it will not be possible to bind the action functions to your context.  On the other hand, if we are writing in a functional style, we do not seem to need calls to the methods. <br>  <em>Solution: the old fashioned way, self = this</em> <br><br></li><li>  For the same reason, most likely it will not be possible to use the arrow-functions from ecmascript 6 - they tightly bind the context so that even calls via call / apply do not affect them. <br>  <em>Solution: not yet invented</em> <br></li></ol><br>  I hope something will be useful.  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/253761/">https://habr.com/ru/post/253761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253745/index.html">Creating full-fledged applications on Max 7. Part 1 - Task setting, visual programming</a></li>
<li><a href="../253749/index.html">RAII and unhandled exceptions</a></li>
<li><a href="../253751/index.html">We connect SAP Solution Manager and SAP WPB to the joy of users and support services</a></li>
<li><a href="../253755/index.html">Machine learning - 3. Poisson random process: views and clicks</a></li>
<li><a href="../253759/index.html">Linux file system entirely on tmpfs - speed without compromise</a></li>
<li><a href="../253763/index.html">Testing the Intel¬Æ Storage System JBOD 2000 Family Shelf</a></li>
<li><a href="../253765/index.html">Manage Azure virtual machines with PowerShell</a></li>
<li><a href="../253767/index.html">We invite you to participate in Security Meetup April 9</a></li>
<li><a href="../253769/index.html">How to catch what is not. Part Two: Projectile and Armor</a></li>
<li><a href="../253771/index.html">Kerio Control 8.2 received the certificate of FSTEC of Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>