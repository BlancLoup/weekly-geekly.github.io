<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Initialization lists in C ++: good, bad, evil</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I would like to talk about how the initialization lists ( braced initializer lists ) work in C ++, what problems they were designed to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Initialization lists in C ++: good, bad, evil</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/1ba/69f/d07/1ba69fd07914440ab80d6ab38750ab16.jpg"></div><br><p>  In this article I would like to talk about how the initialization lists ( <em>braced initializer lists</em> ) work in C ++, what problems they were designed to solve, which problems they in turn caused and how not to get into trouble. </p><a name="habracut"></a><br><p>  First of all, I suggest feeling like a compiler (or language lawyer) and understand if the following examples are compiled, why, and what they do: </p><br><p>  Classic: </p><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v1{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v2(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v3({<span class="hljs-number"><span class="hljs-number">5</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v4{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v5 = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p>  Modern C ++ is a safe language, I will never shoot myself in the leg: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; x( {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>} ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; y{ {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>} };</code> </pre> <br><p>  More brackets for god brackets! </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ? std::vector&lt;std::vector&lt;int&gt;&gt; v1{{{{{}}}}};</span></span></code> </pre> <br><p>  If one designer doesn't fit, we take the second one, right? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;); S(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>); S(T, T); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ S{T{}, T{}}; <span class="hljs-comment"><span class="hljs-comment">//    ? S{1., 2.}; //  ? }</span></span></code> </pre> <br><p>  <a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">Almost Always Auto</a> , they said.  This improves readability, they said: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     x? auto y{0}; //   y? //  ?     </span></span></code> </pre> <br><p>  Hello from ancient times: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a, b; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, 2&gt; a, b; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T t1{{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; T t2{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; T t3{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; S s1{{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; S s2{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; S s3{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br><p>  All clear?  Or nothing is clear?  Welcome under cat. </p><br><h2 id="disclaimers">  Disclaimers </h2><br><ol><li>  This article is an introductory, does not claim to be complete and will often sacrifice correctness for the sake of clarity.  On the other hand, the reader assumes a basic knowledge of C ++. </li><li>  I tried to come up with sensible translations into Russian for English terms, but with some I was completely fiasco.  Syntax constructions like <code>{...}</code> I will call <em>braced-init-lists</em> , the type from the standard library is <code>std::initializer_list</code> , and the initialization type when we write something like this: <code>int x{5}</code> is <em>list-init</em> , also known as <em>uniform initialization syntax</em> , or universal initialization syntax. </li></ol><br><h2 id="attention">  Attention! </h2><br><p>  First of all I will pay attention to the important observation.  Even if you only take it out of the whole article, and then it becomes too lazy to read, my mission here will be fulfilled. </p><br><p>  So, <em>braced-init-lists</em> (pieces with curly braces, {1, 2, 3}, <em>uniform initialization syntax</em> ) and <code>std::initializer_list</code> are different things!  They are strongly connected, there are all sorts of subtle interactions between them, but any of them may well exist without the other. </p><br><p>  But first - a little background. </p><br><h2 id="unicorn-initialization-syntax">  Unicorn initialization syntax </h2><br><p><img src="https://habrastorage.org/web/b36/121/79d/b3612179de1f4aab86d85ccdfedf09b6.jpg"></p><br><p>  In C ++ 98 (and its bugfix-update, C ++ 03), there were enough problems and inconsistencies associated with initialization.  Here are some of them: </p><br><ul><li>  The syntax for initializing variables (including arrays and structures) using curly brackets came from C, but it did not interact well with C ++ features (for example, initialization of structures was not available for C ++ classes) </li><li>  Often you want to build some kind of container (for example, <code>std::vector</code> ) from previously known elements - there was no built-in possibility for this in the language, and library solutions ( <code>Boost.Assign</code> ) did not differ in the elegance of the syntax, they were not free in terms of speed and not too good at compile time </li><li>  When initializing primitive types, it is easy to accidentally lose information during a <em>narrowing conversion</em> ‚Äî for example, to randomly assign a <code>double</code> to an <code>int</code> </li><li>  <a href="https://en.wikipedia.org/wiki/Most_vexing_parse"><em>Most vexing parse</em></a> , who love to scare novice C ++ nicknames. </li></ul><br><p>  Therefore, during the development of C ++ 11, the following idea was born: let us give the opportunity to initialize anything using curly braces: </p><br><ul><li>  For cases where this is applicable in C, the new syntax will work the same, only better </li><li>  We will forbid narrowing transformations. </li><li>  And if we try to initialize a class with constructors, then we and the constructor will be able to call, with the passed parameters </li></ul><br><h2 id="pitfalls">  Pitfalls </h2><br><p>  It would seem that this can be finished: container initialization should turn out by itself, because in C ++ 11 there were also templates with a variable number of parameters, so if we write a variadic constructor ... actually, no, it will not work: </p><br><ul><li>  Such a constructor must be a template, which is often undesirable. </li><li>  We'll have to instantiate constructors with all sorts of parameters, which will lead to bloat and slow compilation. </li><li>  Initialization efficiency, for example, for <code>std::vector</code> will still not be perfect. </li></ul><br><p>  To solve these problems, we invented <code>std::initializer_list</code> - the "magic class", which is a very light wrapper for an array of elements of a known size, as well as being able to construct from <em>braced-init-list</em> . </p><br><p>  Why is he "magic"?  Just for the reasons described above, it cannot be effectively constructed in user code, so the compiler creates it in a special way. </p><br><p>  Why is it needed?  Mainly, so that custom classes could say: "I want to construct from <em>braced-init-list</em> elements of such and such type", and they would not need a template constructor for this. </p><br><p>  (By the way, by this point it should be clear that <code>std::initializer_list</code> and <em>braced-init-list</em> are different concepts) </p><br><p>  Is everything all right now?  We just add the <code>vector(std::initializer_list&lt;T&gt;)</code> constructor <code>vector(std::initializer_list&lt;T&gt;)</code> to our container and it all works?  Nearly. </p><br><p>  Consider this entry: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{<span class="hljs-number"><span class="hljs-number">5</span></span>};</code> </pre> <br><p>  What was meant by <code>v(5)</code> or <code>v({5})</code> ?  In other words, do we want to construct a vector of 5 elements, or from one element with a value of <code>5</code> ? </p><br><p>  To solve this conflict, overload resolution ( <em>overload resolution</em> , the choice of the desired function by the arguments passed) in the case of list-initialization occurs in two stages: </p><br><ol><li>  At first, only constructors with a single parameter of the <code>std::initializer_list</code> (this is one of the main moments when the compiler generates <code>std::initializer_list</code> based on the content of curly braces).  Overload resolution occurs between them. </li><li>  If no constructor is suitable, then everything is as usual further - we expand <em>braced-init-list</em> into the argument list and perform overload resolution among all the available constructors. </li></ol><br><p>  Note that the constructor, which lost at the first stage, may well come up at the second.  This explains an example with an excess of parentheses for initializing a vector from the beginning of the article.  For clarity, remove one of the nested templates, and also replace <code>std::vector</code> with your class: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vec</span></span></span><span class="hljs-class"> {</span></span> vec(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;T&gt;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v1{{{}}}; }</code> </pre> <br><p>  Under clause 1, our constructor does not fit - <code>{{{}}}</code> not like <code>std::initializer_list&lt;int&gt;</code> , because <code>int</code> cannot be initialized with <code>{{}}</code> .  However, <code>{}</code> is quite a zero-initialization, so the constructor is adopted in the second step. </p><br><p>  It's funny, however, that a narrowing conversion is not a sufficient reason to throw out a constructor ‚Äî in the following example, the first constructor is taken in the first step of resolving overloads, and then causes a compiler error.  Good or bad - I do not know, for me it is just amazing. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;); S(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ S{<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>}; }</code> </pre> <br><p>  A similar problem with a rather scary result is obtained in the vector row example from the beginning of the article.  Unfortunately, <code>std::string</code> has a constructor that treats the two passed pointers as the beginning and end of a string.  The consequences of such behavior for string literals are obviously deplorable, while syntactically writing looks quite similar to the correct version and may well appear, for example, in generic code. </p><br><h2 id="klassy-agregaty">  Classes Aggregates </h2><br><p>  Now is that all?  Not really.  The old structure initialization syntax, inherited from C, has not gone away, and you can do this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> A a1, a2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ B b1 = {{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; B b2 = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// brace elision B b3 = {{1, 2}}; // clause omission }</span></span></code> </pre> <br><p>  As you can see, when initializing <a href="">units</a> (roughly speaking, C-like structures, not to be confused with <a href="http://eel.is/c%2B%2Bdraft/class">POD</a> , POD is about something else), you can skip nested parentheses and throw out some initializers.  All this behavior was neatly transferred to C ++. </p><br><p>  It would seem, what nonsense, why is it in the modern language?  Let's at least warn the compiler to this output, thought the developers of GCC and clang, and would be right, do not be <code>std::array</code> class aggregate, containing an array.  Thus, a warning about discarding nested brackets, for obvious reasons, works on such an innocent code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, 3&gt; a = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; }</code> </pre> <br><p>  GCC "solved" this problem by turning off the corresponding warning in the <code>-Wall</code> mode, in clang, for three years now everything <a href="http://llvm.org/bugs/show_bug.cgi%3Fid%3D21629">is still the</a> same. </p><br><p>  By the way, the fact that <code>std::array</code> is an aggregate is not a whim of crazy standard authors or lazy developers of standard libraries: it is simply impossible to achieve the required semantics of this class by means of the language without losing efficiency.  Another hello from C and its weird arrays. </p><br><p>  Perhaps the big problem with aggregate classes is not the best interaction with generalized functions (including) from the standard library.  At the moment, functions that construct an object from the passed parameters (for example, <code>vector::emplace_back</code> or <code>make_unique</code> ) cause normal initialization, not "universal".  It is caused by the fact that the use of <em>list-initialization</em> does not allow in any normal way to call the "normal" constructor instead of the receiving <code>std::initializer_list</code> (approximately the same problem as with initialization in non-template code, only here the user cannot bypass it by calling another constructor).  Work in this direction <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">is underway</a> , but for now we have what we have. </p><br><h2 id="almost-always-auto">  Almost Always Auto </h2><br><p>  How do <em>braced-init-lists</em> behave in combination with type inference?  What happens if I write <code>auto x = {0}; auto y = {1, 2};</code> <code>auto x = {0}; auto y = {1, 2};</code>  ?  You can come up with some sensible strategies: </p><br><ol><li>  To prohibit such initialization in general (in fact, what does a programmer want to say by this?) </li><li>  Print the type of the first variable as <code>int</code> , and disable the second option </li><li>  Make it so that both x and y are of type <code>std::initializer_lits&lt;int&gt;</code> </li></ol><br><p>  The last option I like the least (very few people in real life have local variables of the type <code>std::initializer_list</code> ), but it was he who got into the standard C ++ 11.  Gradually, it became clear that this caused problems for programmers (who would have thought), so a patch was added to the standard <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html</a> , which implements behavior # 2 ... only in the case of <em>direct-list-initialization</em> ( <code>auto x{5}</code> ), and in the case of <em>copy-list-initialization</em> ( <code>auto x = {5}</code> ) it leaves everything as usual. <br><img src="https://habrastorage.org/web/ffb/458/ee2/ffb458ee2ac045ce8c6757f0b9c7fde9.jpg"></p><br><p>  I can not comment on this.  In my opinion, this is one of the very rare cases where common sense temporarily left the authors of the language.  If you have something to say about this, let me know in the comments. </p><br><h2 id="promezhutochnye-itogi">  Subtotals </h2><br><p>  Although the universal initialization syntax and <code>std::initializer_list</code> are language features added from good and right reasons, it seems to me that due to the eternal need for backward compatibility and not always forward-looking solutions in the early stages, the whole situation around them is too complicated at the moment, forced and not the most pleasant for all parties involved - the authors of the standard, compilers, libraries and application developers.  We wanted the best, but it turned out like in the famous comic strip: </p><br><p><img src="https://habrastorage.org/web/a24/a32/aa3/a24a32aa32c34fa2abed3c849478ec2f.png"></p><br><p>  As an example, take, for example, the story of <a href="http://eel.is/c%2B%2Bdraft/over">[over.best.ics] /4.5</a> , which was first added to the standard, then, without thinking, <a href="https://wg21.cmeerw.net/cwg/issue1467">removed</a> , as redundant, and then <a href="https://wg21.cmeerw.net/cwg/issue2076">added back</a> in a modified form - as a description of the extreme case with five ( !) conditions. </p><br><p>  Nevertheless, the opportunity is useful and facilitates life, so here I will give a small and not pretending to objectivity list of how not to shoot myself in the foot: </p><br><ol><li>  Spend some time to get acquainted with what is actually happening (I recommend reading the <a href="">paragraph of the</a> standard - surprisingly understandable and not too dependent on the rest) </li><li>  Do not use <code>std::initializer_list</code> , except in the constructor parameter </li><li>  Yes, and use the constructor parameter only if you understand what is happening (if you are not sure, construct better from a vector, a pair of iterators or a range) </li><li>  Do not use aggregate classes unless absolutely necessary; write a constructor that initializes all fields better. </li><li>  Do not use <em>braced-init-list</em> in combination with <code>auto</code> </li><li>  Read this <a href="https://akrzemi1.wordpress.com/2013/05/14/empty-list-initialization/">article</a> about what to do with empty initialization lists (my hands itch to transfer and post it, maybe I will be busy soon) </li><li>  And, as I wrote at the very beginning, keep in mind that <em>braced-init-list</em> and <code>std::initializer_list</code> are different concepts that interact very slyly with each other. </li></ol><br><h2 id="davayte-pomechtaem">  Let's dream </h2><br><p>  Here I finish my introduction to the existing state of affairs, and I want <del>  throw in </del>  dream how things could be if we lived in an ideal world. </p><br><p>  It seems to me that reusing curly braces to create <code>std::initializer_list</code> during initialization is a language design error.  I would be very happy if, instead, we would get a more explicit and separate syntax (albeit more ugly, for example, some strange brackets like <code>&lt;$...$&gt;</code> or a built-in intrinsic like <code>std::of(...)</code> ).  That is, we initialize the vector something like this: <code>std::vector&lt;std::vector&lt;int&gt;&gt; x = std::of(std::of(1, 2), std::of(3, 4));</code> </p><br><p>  What would it give?  A new initialization method (with protection against most vexing parse and narrowing conversions) would be untied from <code>std::initializer_list</code> , there would not have been a need to enter a separate step to resolve the overloads, the problem with the <code>vector&lt;int&gt;</code> or <code>vector&lt;string&gt;</code> would be gone, the new syntax initialization could be used in generalized code without any problems. </p><br><p>  Of course, the drawbacks of this approach are quite serious: a more malformed syntax in the simplest cases and a departure from the goal of making the syntax more uniform with initialization in the C style (I am rather skeptical about such unification, but this is a topic for another conversation). </p><br><p>  I also dislike classes aggregates.  Leaving aside the problem with <code>std::array</code> , I do not see a decent justification for the existence of such a large and special language feature.  The problem with the fact that programmers do not want to write trivial constructors for simple classes could be solved in less invasive ways, for example, to give an opportunity to generate a constructor that would initialize all fields in turn: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, b; S(...) = aggregate; };</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Finally, I repeat once again that I do not pretend to be 100% correct or to the ultimate truth.  Welcome to the comments if something is left incomprehensible, or if there is something to say on this rather specific topic. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330402/">https://habr.com/ru/post/330402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330386/index.html">MySQL 8, Postgres NoSQL, Tarantool Vinyl, CockroachDB, ClickHouse, and yet, why did Uber leave Postgresql?</a></li>
<li><a href="../330394/index.html">Notepad ++: code verification five years later</a></li>
<li><a href="../330396/index.html">Integration of telephony with CRM: what to rely on when self-tuning</a></li>
<li><a href="../330398/index.html">Awless is a powerful alternative CLI utility for working with AWS services.</a></li>
<li><a href="../330400/index.html">Typed components in Vue.js, or how to make friends Vue, TypeScript and Webpack</a></li>
<li><a href="../330406/index.html">Theory and practice of unattended upgrades in Ubuntu</a></li>
<li><a href="../330408/index.html">PyConRu 2017 preliminary program: speakers from Disney, Facebook, Yandex, JetBrains, Tinkoff Bank</a></li>
<li><a href="../330410/index.html">Features ‚Äìwebkit-box or how to ‚Äúfriend‚Äù flexbox with old Safari</a></li>
<li><a href="../330412/index.html">Why it is worth switching completely to Ceylon or Kotlin (part 1)</a></li>
<li><a href="../330414/index.html">Journey inside Avito: platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>