<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using functions in PostgreSQL as parameterized views</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In daily work, there is often the challenge of clearly and simply referring to large lists of columns and expressions in a sample, and / or dealing wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using functions in PostgreSQL as parameterized views</h1><div class="post__text post__text-html js-mediator-article"><p> In daily work, there is often the challenge of clearly and simply referring to large lists of columns and expressions in a sample, and / or dealing with cumbersome and vague conditions in the <code>where</code> clause.  Usually, representations are used for these purposes, which is quite convenient and intuitive. <a name="habracut"></a>  You can compare the query: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> v.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> v_active_user vau, v_detailized_user v <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> v.id=vau.id</code> </pre> <br><p>  which is quite clearly perceived as "we take active users and get detailed information on them" and the same request, but, so to speak, in expanded form: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.first_name, u.last_name, u.patronymic_name, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">'%s %s %s'</span></span>, u.first_name, u.last_name, u.patronymic_name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fio, birth_date, (<span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - birth_date)/<span class="hljs-number"><span class="hljs-number">365.25</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> full_years_count, hire_date, (<span class="hljs-keyword"><span class="hljs-keyword">current_date</span></span> - hire_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> work_time, (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> string_agg(<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">'%s %s'</span></span>, ch.first_name, ch.last_name),<span class="hljs-string"><span class="hljs-string">', '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> children ch <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[u.id] &lt;@ <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[ch.mother_id, ch.father_id]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> children, dep.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dep_id, <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(dep.name, get_localized_message(<span class="hljs-string"><span class="hljs-string">'  - '</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dep_name .... .... <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> last_vaction_date, .... <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> salary_history <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr u <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> dep <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> u.dep_id=dep.id .... <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.state=<span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pending_fires ...) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr_vacation uv <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ...) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> col123&lt;&gt;col321 ...</code> </pre> <br><p>  Requests of this type ‚Äî with a large list of columns and expressions derived from them, with complex conditions and which in real life are often burdened by historical strata ‚Äî are often completely unreadable and obscure.  It is probably worth noting that the very change in the concept of ‚Äúactive‚Äù (for example, to remove or add remote workers or employees on maternity leave, etc.) can become not so nontrivial, but very tedious;  yes and the number of errors it is unlikely to affect quite favorably;  and changing the list of columns or just the expression entails similar consequences.  Perhaps, it can be said that if for the tables the expression <code>select * from table</code> strictly unacceptable, then for representations of this type it is probably even preferable.  Well for some, at least. </p><br><p>  Consider another task.  Suppose we have a simple table of users: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> usr( id <span class="hljs-type"><span class="hljs-type">serial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>, added <span class="hljs-type"><span class="hljs-type">timestamptz</span></span> )</code> </pre> <br><p>  and friends table: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> friend( usr_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> usr(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>), friend_usr_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> usr(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>), primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>(usr_id, friend_usr_id) )</code> </pre> <br><p>  Required: <br>  Get a specific user with a list of friends. </p><br><p>  The solution is trivial: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> f.friend_usr_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> friend f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f.usr_id=u.id) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> friends <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr u</code> </pre> <br><p>  Since this operation is required quite often, we create a representation for it: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> v_usr_with_friends <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> f.friend_usr_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> friend f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f.usr_id=u.id) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> friends <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr u</code> </pre> <br><p>  Everything is good, but there is a new requirement: to get a user with a list of friends who are also friends of another user (for example, a viewer): </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> f.friend_usr_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> friend f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f.usr_id=u.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr_friend f2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f2.usr_id=another_usr_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> f2.friend_usr_id=f.friend_usr_id) ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> friends <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr u</code> </pre> <br><p>  Unfortunately, it is impossible to create a view based on this request - you cannot pass the second user ID as a parameter;  but there is an opportunity to get around this restriction using Cartesian products </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> usr_with_common_friends <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u2.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> another_usr_id, u.id, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> f.friend_usr_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> friend f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f.usr_id=u.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> friend f2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f2.usr_id=u2.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> f2.friend_usr_id=f.friend_usr_id) ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> friends <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr u, usr u2</code> </pre> <br><p>  Using the resulting presentation is completely natural: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr_with_common_friends <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> another_usr_id=<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  A new demand is coming: it is required to receive not just common friends, but common friends who have registered during the specified period of time.  Since creating a table with all possible time intervals is not possible, you will have to create a function: </p><br><pre> <code class="hljs perl">create <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> replace function usr_with_common_friends_created_at_tr(<span class="hljs-keyword"><span class="hljs-keyword">tr</span></span> tstzrange) returns table(another_usr_id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, friends <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]) as $code$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u2.id as another_usr_id, u.id, array(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> f.friend_usr_id from friend f, usr u3 where f.usr_id=u.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * from friend f2 where f2.usr_id=u2.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> f2.friend_usr_id=f.friend_usr_id) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> u3.id=f.friend_usr_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> u3.added &lt;@ <span class="hljs-keyword"><span class="hljs-keyword">tr</span></span> ) as friends from usr u, usr u2; $code$ language sql **stable**</code> </pre> <br><p>  Use is also quite convenient: </p><br><pre> <code class="hljs lisp">select * from usr_with_common_friends_created_at_tr(<span class="hljs-name"><span class="hljs-name">tstzrange</span></span>(<span class="hljs-name"><span class="hljs-name">now</span></span>() - make_interval(<span class="hljs-name"><span class="hljs-name">years</span></span><span class="hljs-symbol"><span class="hljs-symbol">:=1</span></span>), now())) where id=1 and another_usr_id=2</code> </pre> <br><p>  It would seem that a query using this function will work straightforward - first, the function will return all possible strings, and then they will be filtered by condition.  Let's get a look: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> usr_with_common_friends_created_at_tr(<span class="hljs-type"><span class="hljs-type">tstzrange</span></span>(now() - make_interval(years:=<span class="hljs-number"><span class="hljs-number">1</span></span>), now())) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> another_usr_id=<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Plan: </p><br><pre> <code class="hljs pgsql">QUERY PLAN Nested <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.30</span></span>.<span class="hljs-number"><span class="hljs-number">.67</span></span><span class="hljs-number"><span class="hljs-number">.17</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> width=<span class="hljs-number"><span class="hljs-number">8</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Only</span></span> Scan <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> usr_pkey <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> usr u (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.15</span></span>.<span class="hljs-number"><span class="hljs-number">.8</span></span><span class="hljs-number"><span class="hljs-number">.17</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Cond: (id = <span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Only</span></span> Scan <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> usr_pkey <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> usr u2 (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.15</span></span>.<span class="hljs-number"><span class="hljs-number">.8</span></span><span class="hljs-number"><span class="hljs-number">.17</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Cond: (id = <span class="hljs-number"><span class="hljs-number">2</span></span>) SubPlan <span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; Nested <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">19.44</span></span>.<span class="hljs-number"><span class="hljs-number">.50</span></span><span class="hljs-number"><span class="hljs-number">.82</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) -&gt; Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">19.29</span></span>.<span class="hljs-number"><span class="hljs-number">.30</span></span><span class="hljs-number"><span class="hljs-number">.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span> width=<span class="hljs-number"><span class="hljs-number">8</span></span>) Hash Cond: (f.friend_usr_id = f2.friend_usr_id) -&gt; Bitmap Heap Scan <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> friend f (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.24</span></span>.<span class="hljs-number"><span class="hljs-number">.14</span></span><span class="hljs-number"><span class="hljs-number">.91</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">11</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) Recheck Cond: (usr_id = u.id) -&gt; Bitmap <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Scan <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> friend_pkey (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.4</span></span><span class="hljs-number"><span class="hljs-number">.24</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">11</span></span> width=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Cond: (usr_id = u.id) -&gt; Hash (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">14.91</span></span>.<span class="hljs-number"><span class="hljs-number">.14</span></span><span class="hljs-number"><span class="hljs-number">.91</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">11</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) -&gt; Bitmap Heap Scan <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> friend f2 (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.24</span></span>.<span class="hljs-number"><span class="hljs-number">.14</span></span><span class="hljs-number"><span class="hljs-number">.91</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">11</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) Recheck Cond: (usr_id = u2.id) -&gt; Bitmap <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Scan <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> friend_pkey (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.4</span></span><span class="hljs-number"><span class="hljs-number">.24</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">11</span></span> width=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Cond: (usr_id = u2.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Scan <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> usr_pkey <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> usr u3 (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.15</span></span>.<span class="hljs-number"><span class="hljs-number">.3</span></span><span class="hljs-number"><span class="hljs-number">.46</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> width=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Cond: (id = f.friend_usr_id) <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>: (added &lt;@ <span class="hljs-type"><span class="hljs-type">tstzrange</span></span>((now() - <span class="hljs-string"><span class="hljs-string">'1 year'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>), now()))</code> </pre> <br><p>  Surprisingly, this is not the case - the server was able to deploy the function directly to the request body.  Yes, Postgresql in some cases is able to inject the function body directly into the request. <br>  When does this happen? </p><br><p>  Scalar functions: </p><br><ol><li>  The function is implemented in SQL ( <code>LANGUAGE SQL</code> ) as a simple <code>select</code> that returns a scalar type </li><li>  Feature marked <code>immutable</code> or <code>stable</code> </li><li>  The function does not contain subqueries. </li><li>  Function not marked as security definer </li><li>  The function has no specific <code>set</code> (n., <code>set enable_seqscan=off</code> , etc.) </li><li>  The function returns only one column. </li><li>  The returned type must match the type of the function. </li><li>  And a number of restrictions (see the full list below) </li></ol><br><p>  This can be useful for encapsulating uncomplicated but cumbersome logic, for example: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> is_system_catalog_table_name(r anyelement) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $code$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(r.relname <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)=<span class="hljs-string"><span class="hljs-string">'pg_'</span></span> <span class="hljs-comment"><span class="hljs-comment">-- , ,      $code$ immutable language sql</span></span></code> </pre> <br><p>  Request: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class pc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> is_system_catalog_table_name(pc)</code> </pre> <br><p>  Plan: </p><br><pre> <code class="hljs pgsql">Seq Scan <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pg_class pc (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.6955</span></span><span class="hljs-number"><span class="hljs-number">.59</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">827</span></span> width=<span class="hljs-number"><span class="hljs-number">201</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>: ("substring"((relname)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) = <span class="hljs-string"><span class="hljs-string">'pg_'</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>)</code> </pre> <br><p>  As you can see, there is no function call here - the function code was inserted directly into the request body.  This function can be considered as a kind of macro. </p><br><p>  At the same time, I would like to pay attention to the compact syntax of the function call recording - the record is immediately passed as a parameter, and is not taken as a strictly specific type ( <code>pg_class</code> in this case), but as an arbitrary type with a <code>relname</code> column. </p><br><p>  For example: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, relname <span class="hljs-type"><span class="hljs-type">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t(relname) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t pc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> is_system_catalog_table_name(pc) Seq Scan <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t pc (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> width=<span class="hljs-number"><span class="hljs-number">25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>: ("substring"(relname, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) = <span class="hljs-string"><span class="hljs-string">'pg_'</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>)</code> </pre> <br><p>  Table functions have similar, but much softer limitations: </p><br><ol><li>  Function implemented in SQL ( <code>LANGUAGE SQL</code> ) </li><li>  <code>immutable</code> or <code>stable</code> function </li><li>  Function not <code>security definer</code> </li><li>  The function is not <code>strict</code> </li><li>  No specific set </li><li>  The function body contains a single <code>select</code> (and only <code>select</code> , <code>insert</code> / <code>update</code> / <code>delete</code> not allowed) </li><li>  Return column types must match the types in the function declaration. </li><li>  And some more specific limitations. </li></ol><br><p>  Thus, embedding the function body directly into a request in Postgres makes it possible to effectively implement the ‚Äúpresentation with parameters‚Äù that is absent in the standard, but nevertheless in demand and convenient. </p><br><p>  Interestingly, in DB2 and SQL Server, the functions that are embedded in the query are also used to solve the "view with parameters" task. </p><br><p>  References: <br>  <a href="https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions">https://wiki.postgresql.org/wiki/Inlining_of_SQL_functions</a> <br>  <a href="https://www-01.ibm.com/support/knowledgecenter/SSEPGG_9.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000935.html">https://www-01.ibm.com/support/knowledgecenter/SSEPGG_9.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000935.html</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/277335/">https://habr.com/ru/post/277335/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277321/index.html">Decorators and reflection in TypeScript: from beginner to expert (Part 2)</a></li>
<li><a href="../277323/index.html">I am a web developer and for 10 days I can not write the simplest application</a></li>
<li><a href="../277329/index.html">Reflection and code generation in C ++</a></li>
<li><a href="../277331/index.html">DoS on your own: What causes the uncontrolled growth of tables in the database</a></li>
<li><a href="../277333/index.html">Copy elision, or how to shoot the leg to the neck ...</a></li>
<li><a href="../277337/index.html">Experiment: How irrational is exchange trading at short intervals (scalping)</a></li>
<li><a href="../277339/index.html">Theory of restrictions in interfaces (who killed the old graph?)</a></li>
<li><a href="../277341/index.html">NetSkills Online Networking School</a></li>
<li><a href="../277343/index.html">Building Android applications step by step, part two</a></li>
<li><a href="../277345/index.html">In-depth training in the garage - Two networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>