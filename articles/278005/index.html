<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a stable UART, at a speed of 921600 baud or more, in Verilog language under FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. A couple of weeks ago, I started slowly learning programming for FPGAs. For this purpose, I ordered the cheapest motherboard based on the Alter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a stable UART, at a speed of 921600 baud or more, in Verilog language under FPGA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b36/8bc/2c9/b368bc2c94344822b2c0e1e4fc92598a.jpg"><br><br>  Hello.  A couple of weeks ago, I started slowly learning programming for FPGAs.  For this purpose, I ordered the cheapest motherboard based on the Altera Max II EPM240T100C5N chip from the Chinese.  Having established Quartus v15, began to study Verilog of the standard of 2001.  Blinking LEDs decided to try to implement some data transfer protocol.  Naturally, it became UART :) Looking at other people's examples on the network, I didn‚Äôt really like the excessive piling up of logic, a lot of additional counters, and most importantly, problems with synchronization in the receiver and, as a result, not stability at high speeds.  Of course, you can find high-quality implementations that are fully configurable, and indeed, with ‚Äúideal code‚Äù, but there will not be any sports interest. <br><a name="habracut"></a><br>  And so, the task was to implement the most compact, stable and simple 8-bit asynchronous transceiver with the 1st start and 1st stop bits.  In a word - a classic.  But as it turned out, the task is not so trivial as it was at first glance.  Having realized the receiver and the transmitter literally in one evening, I had to spend two more to make the logic of the chip not swallow, to receive and send the stream of bytes correctly, without errors. <br><br>  <strong>Based on the criticism and wishes in the comments, I have worked on errors, and the article already presents the second implementation of this module.</strong>  <strong>Receiving and sending data were transferred to shift registers, a majority scheme was added to the RX input of three elements, got rid of blocking assignments in synchronous blocks and counters of the UART clock signal count from the maximum value to zero.</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/917/aed/b25/917aedb259674f71aa5dabeacb7467c7.jpg"><br>  Project files: <br><br><ul><li>  <strong>Main</strong> </li><li>  <strong>UART</strong> </li><li>  <strong>UART_TX</strong> </li><li>  <strong>UART_RX</strong> </li><li>  <strong>Rxmajority3filter</strong> </li></ul><br><br>  Let's start with the UART_TX module: <br><br><div class="spoiler">  <b class="spoiler_title">UART_TX.v</b> <div class="spoiler_text"><pre><code class="vhdl hljs">module UART_TX # ( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CLOCK_FREQUENCY = <span class="hljs-number"><span class="hljs-number">50_000_000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BAUD_RATE = <span class="hljs-number"><span class="hljs-number">9600</span></span> ) ( input clockIN, input nTxResetIN, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txDataIN, input txLoadIN, output wire txIdleOUT, output wire txReadyOUT, output wire txOUT ); localparam HALF_BAUD_CLK_REG_VALUE = (CLOCK_FREQUENCY / BAUD_RATE / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); localparam HALF_BAUD_CLK_REG_SIZE = $clog2(HALF_BAUD_CLK_REG_VALUE); reg [HALF_BAUD_CLK_REG_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txClkCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg txBaudClk = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txReg = <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h001</span></span>; reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txCounter = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; assign txReadyOUT = !txCounter[<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]; assign txIdleOUT = txReadyOUT &amp; (~txCounter[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assign txOUT = txReg[<span class="hljs-number"><span class="hljs-number">0</span></span>]; always @(posedge clockIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : tx_clock_generate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(txIdleOUT &amp; (~txLoadIN)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txClkCounter &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; txBaudClk &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(txClkCounter == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txClkCounter &lt;= HALF_BAUD_CLK_REG_VALUE; txBaudClk &lt;= ~txBaudClk; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txClkCounter &lt;= txClkCounter - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge txBaudClk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nTxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : tx_transmit <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~nTxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txCounter &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; txReg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~txReadyOUT) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txReg &lt;= {<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>, txReg[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]}; txCounter &lt;= txCounter - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(txLoadIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txReg &lt;= {<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>, txDataIN[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>}; txCounter &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'hA</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txCounter &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br></div></div><br>  Let's sort everything in order: <br><br><pre> <code class="vhdl hljs">module UART_TX # ( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CLOCK_FREQUENCY = <span class="hljs-number"><span class="hljs-number">50_000_000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BAUD_RATE = <span class="hljs-number"><span class="hljs-number">9600</span></span> ) ( input clockIN, input nTxResetIN, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txDataIN, input txLoadIN, output wire txIdleOUT, output wire txReadyOUT, output wire txOUT );</code> </pre><br><br>  The parameters <strong>CLOCK_FREQUENCY</strong> and <strong>BAUD_RATE</strong> are the frequency of the crystal oscillator and the frequency UART of the transmitter, respectively. <br><br>  Incoming ports: <br><br>  <strong>clockIN</strong> is the clock signal port from the quartz resonator. <br>  <strong>nTxResetIN</strong> - port of discharge on a negative front. <br>  <strong>txDataIN</strong> is an eight-bit data bus. <br>  <strong>txLoadIN</strong> - the port of the beginning of data transfer. <br><br>  Outgoing ports: <br><br>  <strong>txIdleOUT</strong> - the transmitter ‚Äúidle‚Äù port, is set in the log.  1 at full completion of the data byte transfer cycle, if there is no log on the <strong>txLoadIN</strong> port.  one. <br>  <strong>txReadyOUT</strong> - port, log.  1 on which, will mean that the stop bit has been sent, and you can upload new data. <br>  <strong>txOUT</strong> is a port for serial transmission of outgoing data that must be assigned to the FPGA leg. <br><br><pre> <code class="vhdl hljs">localparam HALF_BAUD_CLK_REG_VALUE = (CLOCK_FREQUENCY / BAUD_RATE / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); localparam HALF_BAUD_CLK_REG_SIZE = $clog2(HALF_BAUD_CLK_REG_VALUE); reg [HALF_BAUD_CLK_REG_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txClkCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg txBaudClk = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txReg = <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h001</span></span>; reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txCounter = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; assign txReadyOUT = !txCounter[<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]; assign txIdleOUT = txReadyOUT &amp; (~txCounter[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assign txOUT = txReg[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br><br>  The local parameter <strong>HALF_BAUD_CLK_REG_VALUE</strong> is the value of the counter-divider of the half-cycle frequency of the UART clock signal.  Calculated by the formula <strong>CLOCK_FREQUENCY / BAUD_RATE / 2 - 1</strong> . <br><br>  The local parameter <strong>HALF_BAUD_CLK_REG_SIZE</strong> is the width of this counter itself.  It is calculated by the wonderful function $ clog2 - the logarithm of base 2 from the value of the parameter <strong>HALF_BAUD_CLK_REG_VALUE</strong> . <br><br>  Reg registers: <br><br>  <strong>txClkCounter</strong> is a clock frequency divider counter. <br>  <strong>txBaudClk</strong> - clock signal for the transmitter. <br>  <strong>txReg</strong> - shift register in which the data byte, start and stop bits will be written. <br>  <strong>txCounter</strong> - the number of bits sent. <br><br>  Wires wire: <br><br>  <strong>txReadyOUT is</strong> assigned as a continuous connection through logical negation on the 4th, 3rd and 2nd bits of the register. <strong>txCounter</strong> Accepts the state of the log.  1 when <strong>txCounter reaches</strong> 1 or 0. <br>  <strong>txIdleOUT is</strong> assigned as a continuous connection to <strong>txReadyOUT</strong> and through the logical AND primitive to the inverted 1st bit of the <strong>txCounter</strong> register.  Accepts the state log.  1 when the <strong>txCounter reaches</strong> 0. <br>  <strong>txOUT is</strong> assigned by continuous connection to the 1st bit of the <strong>txReg</strong> register <br><br>  Data transfer: <br><br><pre> <code class="vhdl hljs">always @(posedge txBaudClk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nTxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : tx_transmit <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~nTxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txCounter &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; txReg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~txReadyOUT) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txReg &lt;= {<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>, txReg[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]}; txCounter &lt;= txCounter - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(txLoadIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txReg &lt;= {<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>, txDataIN[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>}; txCounter &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'hA</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txCounter &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  On the negative edge on the <strong>nTxResetIN</strong> port, which is checked in the first condition, a log is set on the first bit of the <strong>txReg</strong> register.  1, and the <strong>txCounter</strong> register takes the value 0, which gives the <strong>txIdleOUT</strong> and <strong>txReadyOUT</strong> and <strong>txOUT</strong> log <strong>outputs</strong> .  one. <br><br>  Otherwise, a positive edge at the <strong>txBaudClk</strong> port is <strong>used to</strong> check the signal value of the <strong>txReadyOUT</strong> port, and, for log.  0, the contents of the <strong>txReg</strong> register <strong>are</strong> shifted towards the lower bits, and the <strong>txCounter</strong> counter <strong>is</strong> decremented by one, and when the value 1 is <strong>reached,</strong> a log will be set at the <strong>txReadyOUT</strong> output.  one. <br><br>  Otherwise, the signal of the <strong>txLoadIN</strong> port <strong>is</strong> checked on the positive edge on the <strong>txBaudClk</strong> port, and, with the log.  1, the <strong>txReg</strong> register <strong>receives the</strong> start and stop bits from the <strong>txDataIN</strong> input, the <strong>txCounter</strong> counter takes the value 10 (4'hA), which will give a negative edge at the <strong>txIdleOUT</strong> and <strong>txReadyOUT</strong> and <strong>txOUT outputs</strong> - which will signal the start of data transfer (the start bit). <br><br>  Otherwise, the <strong>txCounter</strong> register takes the value 0, and a log appears at the output of <strong>txIdleOUT</strong> .  one. <br><br>  It is worth noting that, according to this logic, with the log.  1 on <strong>txLoadIN, the</strong> data will be constantly taken from the <strong>txDataIN</strong> input to the <strong>txReg</strong> register and sequentially transmitted to the <strong>txOUT</strong> output.  Those.  To stop sending a data packet, you need to reset <strong>txLoadIN</strong> to the log.  0 before the stop bit is completely transmitted.  The best way is to reset <strong>txLoadIN</strong> on the negative edge on the <strong>txReadyOUT</strong> port.  You cannot interrupt the process of transferring a data byte with a logical zero to <strong>txLoadIN</strong> .  You can use <strong>nTxResetIN</strong> to do this. <br><br>  Transmitter Clock Formation: <br><br><pre> <code class="vhdl hljs">always @(posedge clockIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : tx_clock_generate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(txIdleOUT &amp; (~txLoadIN)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txClkCounter &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; txBaudClk &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(txClkCounter == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txClkCounter &lt;= HALF_BAUD_CLK_REG_VALUE; txBaudClk &lt;= ~txBaudClk; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txClkCounter &lt;= txClkCounter - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  On the positive edge of the clock signal on the <strong>clockIN</strong> port in the first condition, the log is checked.  1 on <strong>txIdleOUT</strong> and log.  0 on <strong>txLoadIN</strong> , and if the condition is met, the <strong>txClkCounter</strong> register <strong>is</strong> reset to 0, and a log is set on the <strong>txBaudClk</strong> clock signal.  0. Ie  thereby, we guarantee that with the log.  1 on the <strong>txDataIN</strong> transmitter will start transmitting data already on the next positive edge <strong>clockIN</strong> . <br><br>  Otherwise, <strong>txClkCounter is</strong> checked for the achievement of the value 0, and if the condition is <strong>met</strong> , the value of the parameter <strong>HALF_BAUD_CLK_REG_VALUE</strong> will be written to the <strong>txClkCounter</strong> and <strong>txBaudClk will</strong> invert its state. <br><br>  Otherwise, <strong>txClkCounter</strong> will decrease its value by 1. <br><br>  The timing diagram of the signals of the module UART_TX: <br><br><img src="https://habrastorage.org/files/3fa/bd3/672/3fabd367223242f79349d3bdf99641f2.jpg"><br><br>  UART_RX module: <br><br><div class="spoiler">  <b class="spoiler_title">UART_RX.v</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module UART_RX # ( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CLOCK_FREQUENCY = <span class="hljs-number"><span class="hljs-number">50_000_000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BAUD_RATE = <span class="hljs-number"><span class="hljs-number">9600</span></span> ) ( input clockIN, input nRxResetIN, input rxIN, output wire rxIdleOUT, output wire rxReadyOUT, output wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxDataOUT ); localparam HALF_BAUD_CLK_REG_VALUE = (CLOCK_FREQUENCY / BAUD_RATE / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); localparam HALF_BAUD_CLK_REG_SIZE = $clog2(HALF_BAUD_CLK_REG_VALUE); reg [HALF_BAUD_CLK_REG_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxClkCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg rxBaudClk = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxReg = <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000</span></span>; wire rx; assign rxIdleOUT = ~rxReg[<span class="hljs-number"><span class="hljs-number">0</span></span>]; assign rxReadyOUT = rxReg[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp; rxIdleOUT; assign rxDataOUT[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = rxReg[<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]; RXMajority3Filter rxFilter ( .clockIN(clockIN), .rxIN(rxIN), .rxOUT(rx) ); always @(posedge clockIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : rx_clock_generate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rx &amp; rxIdleOUT) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxClkCounter &lt;= HALF_BAUD_CLK_REG_VALUE; rxBaudClk &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rxClkCounter == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxClkCounter &lt;= HALF_BAUD_CLK_REG_VALUE; rxBaudClk &lt;= ~rxBaudClk; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxClkCounter &lt;= rxClkCounter - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge rxBaudClk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nRxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : rx_receive <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~nRxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxReg &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~rxIdleOUT) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxReg &lt;= {rx, rxReg[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~rx) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxReg &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h1FF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br></div></div><br><pre> <code class="vhdl hljs">module UART_RX # ( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CLOCK_FREQUENCY = <span class="hljs-number"><span class="hljs-number">50_000_000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BAUD_RATE = <span class="hljs-number"><span class="hljs-number">9600</span></span> ) ( input clockIN, input nRxResetIN, input rxIN, output wire rxIdleOUT, output wire rxReadyOUT, output wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxDataOUT );</code> </pre><br>  In many ways similar to the module UART_TX. <br><br>  Incoming ports: <br><br>  <strong>clockIN</strong> and <strong>nRxResetIN</strong> have the same values ‚Äã‚Äãas in the <strong>UART_RX</strong> module <br>  <strong>rxIN</strong> is the incoming serial data port to be assigned to the FPGA pin. <br><br>  Outgoing ports: <br><br>  <strong>rxIdleOUT</strong> - the ‚Äúidle‚Äù port of the receiver is set in the log.  1 at full completion of the data byte receiving cycle. <br>  <strong>rxReadyOUT</strong> - receiver readiness port.  When you go to the log.  1 indicates that a data byte was received, which ended with a stop bit (log. 1).  Moves to log state.  0 at log.  0 on the <strong>nRxResetIN</strong> port or when starting to receive the next data byte. <br>  <strong>rxDataOUT</strong> is an eight-bit received data bus. <br><br><pre> <code class="vhdl hljs">localparam HALF_BAUD_CLK_REG_VALUE = (CLOCK_FREQUENCY / BAUD_RATE / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); localparam HALF_BAUD_CLK_REG_SIZE = $clog2(HALF_BAUD_CLK_REG_VALUE); reg [HALF_BAUD_CLK_REG_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxClkCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg rxBaudClk = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxReg = <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000</span></span>; wire rx; assign rxIdleOUT = ~rxReg[<span class="hljs-number"><span class="hljs-number">0</span></span>]; assign rxReadyOUT = rxReg[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp; rxIdleOUT; assign rxDataOUT[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = rxReg[<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br>  Reg registers: <br><br>  <strong>rxClkCounter</strong> is a clock frequency divider counter. <br>  <strong>rxBaudClk</strong> - clock signal for the receiver. <br>  <strong>rxReg</strong> is a shift register that stores 8 bits of received data, the start and stop bits. <br><br>  Wires wire: <br><br>  <strong>rx</strong> is a signal of incoming serial data, passed through the majority logic of the <strong>RXMajority3Filter</strong> module. <br>  <strong>rxIdleOUT is</strong> continuously assigned to the inverted 1st bit of the <strong>rxReg</strong> register.  Accepts the log.  1 at the end of data reception, when the stop bit is written to the register <strong>rxReg [0]</strong> . <br>  <strong>rxReadyOUT is</strong> continuously assigned to the 10th bit of the <strong>rxReg</strong> register and <strong>rxIdleOUT</strong> via the logical AND primitive.  Accepts the log.  1 if data reception was completed and in the <strong>rxReg</strong> register the 10th bit took the value of the log.  1 (stop bit). <br>  <strong>rxDataOUT is</strong> assigned from 9 to 1 bits of the <strong>rxReg</strong> register. <br><br>  Receive data: <br><br><pre> <code class="vhdl hljs">always @(posedge rxBaudClk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nRxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : rx_receive <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~nRxResetIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxReg &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~rxIdleOUT) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxReg &lt;= {rx, rxReg[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~rx) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxReg &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h1FF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  On the negative edge on the <strong>nRxResetIN</strong> port, the first condition will be satisfied, and <strong>rxReg</strong> will be <strong>reset</strong> to 0, which will set the log.  0 on the <strong>rxReadyOUT</strong> port and log.  1 on <strong>rxIdleOUT</strong> . <br><br>  Otherwise, when the log.  0 on the <strong>rxIdleOUT</strong> port <strong>, the</strong> contents of the <strong>rxReg</strong> register <strong>are</strong> shifted towards the lower bits, and the current state of the <strong>rx</strong> signal will be written to the high bit. <br><br>  Otherwise, the log.  0 of the <strong>rx</strong> signal will indicate the start of data transfer (the start bit), and units (10'h1FF) will be written into all the bits except the <strong>high</strong> register (the start bit) in the <strong>rxReg</strong> register. <br><br>  Formation of the receiver clock signal: <br><br><pre> <code class="vhdl hljs">always @(posedge clockIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : rx_clock_generate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rx &amp; rxIdleOUT) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxClkCounter &lt;= HALF_BAUD_CLK_REG_VALUE; rxBaudClk &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rxClkCounter == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxClkCounter &lt;= HALF_BAUD_CLK_REG_VALUE; rxBaudClk &lt;= ~rxBaudClk; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxClkCounter &lt;= rxClkCounter - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The assignment of the second and third conditions is identical to the condition from the UART_TX module - generation of a clock signal for the receiver. <br><br>  In the first condition, the log is checked.  1 <strong>rx</strong> signal and log.  1 of the <strong>rxIdleOUT</strong> signal, and when the condition is <strong>met</strong> , the value of the <strong>HALF_BAUD_CLK_REG_VALUE</strong> parameter will be written to <strong>txClkCounter</strong> , and the <strong>log</strong> will be set to <strong>rxBaudClk</strong> .  0 <br>  Those.  when a log appears.  0 (start bit) on the <strong>rx</strong> port, the counter counts down half the receiver clock period, and only after that will the data be received. <br><br>  The timing diagram of the signals of the module UART_RX: <br><br><img src="https://habrastorage.org/files/04a/306/576/04a3065762cc416c8091514e85cf6a59.jpg"><br><br>  RXMajority3Filter Module: <br><br><div class="spoiler">  <b class="spoiler_title">Rxmajority3filter.v</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module RXMajority3Filter ( input clockIN, input rxIN, output wire rxOUT ); reg [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxLock = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b111</span></span>; assign rxOUT = (rxLock[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; rxLock[<span class="hljs-number"><span class="hljs-number">1</span></span>]) | (rxLock[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; rxLock[<span class="hljs-number"><span class="hljs-number">2</span></span>]) | (rxLock[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; rxLock[<span class="hljs-number"><span class="hljs-number">2</span></span>]); always @(posedge clockIN) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rxLock &lt;= {rxIN, rxLock[<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br></div></div><br>  Represents the implementation of a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B6%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25B0%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258D%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582">major element</a> on a three-element shift register. <br><br>  UART module: <br><br><div class="spoiler">  <b class="spoiler_title">UART.v</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module UART # ( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CLOCK_FREQUENCY = <span class="hljs-number"><span class="hljs-number">50_000_000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BAUD_RATE = <span class="hljs-number"><span class="hljs-number">9600</span></span> ) ( input clockIN, input nTxResetIN, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txDataIN, input txLoadIN, output wire txIdleOUT, output wire txReadyOUT, output wire txOUT, input nRxResetIN, input rxIN, output wire rxIdleOUT, output wire rxReadyOUT, output wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxDataOUT ); defparam uart_tx.CLOCK_FREQUENCY = CLOCK_FREQUENCY; defparam uart_tx.BAUD_RATE = BAUD_RATE; UART_TX uart_tx ( .clockIN(clockIN), .nTxResetIN(nTxResetIN), .txDataIN(txDataIN), .txLoadIN(txLoadIN), .txIdleOUT(txIdleOUT), .txReadyOUT(txReadyOUT), .txOUT(txOUT) ); defparam uart_rx.CLOCK_FREQUENCY = CLOCK_FREQUENCY; defparam uart_rx.BAUD_RATE = BAUD_RATE; UART_RX uart_rx ( .clockIN(clockIN), .nRxResetIN(nRxResetIN), .rxIN(rxIN), .rxIdleOUT(rxIdleOUT), .rxReadyOUT(rxReadyOUT), .rxDataOUT(rxDataOUT) ); endmodule</code> </pre><br></div></div><br>  It simply combines the two modules UART_RX and UART_TX into a single whole, forwarding incoming and outgoing signals, and the values ‚Äã‚Äãof the parameters of the frequency of the quartz resonator and the frequency of the UART transmitter. <br><br>  And actually the top level module Main: <br><br><div class="spoiler">  <b class="spoiler_title">Main.v</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module Main ( input wire clockIN, input wire uartRxIN, output wire uartTxOUT ); defparam uart.CLOCK_FREQUENCY = <span class="hljs-number"><span class="hljs-number">50_000_000</span></span>; defparam uart.BAUD_RATE = <span class="hljs-number"><span class="hljs-number">921600</span></span>; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] txData; reg txLoad = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; wire txReset = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; wire rxReset = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rxData; wire txIdle; wire txReady; wire rxIdle; wire rxReady; UART uart ( .clockIN(clockIN), .nTxResetIN(txReset), .txDataIN(txData), .txLoadIN(txLoad), .txIdleOUT(txIdle), .txReadyOUT(txReady), .txOUT(uartTxOUT), .nRxResetIN(rxReset), .rxIN(uartRxIN), .rxIdleOUT(rxIdle), .rxReadyOUT(rxReady), .rxDataOUT(rxData) ); always @(posedge rxReady <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge txReady) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~txReady) txLoad &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rxReady) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> txLoad &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; txData &lt;= rxData; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br></div></div><br>  It is essentially a simple "echo" test. <br><br>  On the positive edge on the <strong>rxReady</strong> port <strong>, the</strong> incoming data will be recorded in the <strong>txData</strong> register, which is assigned to the <strong>txDataIN</strong> input of the transmitter, and the <strong>txLoad</strong> register, which is assigned to the input of the <strong>txLoadIN</strong> transmitter <strong>,</strong> will be logged.  1, to start the transfer. <br><br>  On the negative front on the <strong>txReady</strong> port, the <strong>txLoad</strong> register will take the value of the log.  0 <br><br>  This module was tested on a motherboard with an Altera Max II EPM240T100C5N chip and a quartz resonator with a frequency of 50 megahertz, with a UART speed of 921600 baud (the maximum speed that my USB-UART adapter supports). <br><br>  According to the standard, for the receiver, the sampling frequency of the start bit should be at least 16 times the UART frequency.  So for the stable operation of the module at 921600 baud rate, the frequency of the quartz resonator should not be lower than 921600 * 16 = 14'745'600 Hz.  For example, the crystal will go to 16 megahertz. <br><br>  It is also desirable to put a pull-up resistor at the receiver input. <br><br>  As usual, any optimization tips and improvements are welcome. <br><br>  Download the updated files <a href="">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/278005/">https://habr.com/ru/post/278005/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277989/index.html">View design pattern in languages ‚Äã‚Äãwith dependent types</a></li>
<li><a href="../277991/index.html">What does the VxRail hyper-convergent system look like? Online demo, functionality, availability to order</a></li>
<li><a href="../277995/index.html">Hooks are easy (part 3)</a></li>
<li><a href="../277999/index.html">An example of using the inventory and reporting features in System Center Configuration Manager</a></li>
<li><a href="../278001/index.html">Performance and multithreading at the JPoint 2016 Java Conference</a></li>
<li><a href="../278007/index.html">What mobile devices do public transport passengers prefer?</a></li>
<li><a href="../278009/index.html">Set operations using Google Guava</a></li>
<li><a href="../278011/index.html">Fees for developers and a terminal based on the Russian microprocessor Baykal-T</a></li>
<li><a href="../278017/index.html">Node.js. Design and development patterns</a></li>
<li><a href="../278019/index.html">Table as parameter in postgresql</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>