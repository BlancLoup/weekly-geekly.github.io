<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Through thorns to Haskell. 1/2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first part is a short and hard introduction to Haskell. The second part can be found here. 

 tl; dr : A very brief and concise introduction to Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Through thorns to Haskell. 1/2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/682/33f/00e/68233f00ef8fd54b93ea5495ba5fd3a1.jpg"><br><br>  The first part is a short and hard introduction to Haskell.  The second part can be found <a href="http://habrahabr.ru/post/153383/">here.</a> <br><br>  <abbr title="Too long; didn't read">tl; dr</abbr> : A very brief and concise introduction to Haskell. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/152889/">Introduction</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Installation</a> </li><li>  <a href="https://habr.com/ru/post/152889/">No panic</a> </li><li>  <a href="https://habr.com/ru/post/152889/">The very basics of Haskell</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Function declaration</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Example of using types</a> </li></ul><br></li></ul><br></li><li>  <a href="https://habr.com/ru/post/152889/">Haskell Minimum Required</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Expressions</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Arithmetic</a> </li><li>  <a href="https://habr.com/ru/post/152889/">brain teaser</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Exponentiation</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Lists</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Strings</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Tuples</a> </li><li>  <a href="https://habr.com/ru/post/152889/">We deal with brackets</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/post/152889/">Useful things to write functions</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/post/152889/">Tricky part</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Functional style</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Higher order functions</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/post/152889/">Types</a> <br><ul><li>  <a href="https://habr.com/ru/post/152889/">Type inference</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Creating new types</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Recursive types</a> </li><li>  <a href="https://habr.com/ru/post/152889/">Trees</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/post/152889/">Infinite structures</a> </li></ul><br></li></ul><br>  <b>UPD.</b>  If you like the tutorial, drop a few lines to the author of the <a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/">original article</a> .  Man will be pleased;) <br><a name="habracut"></a><br>  I truly believe that every developer should learn Haskell.  I do not think everyone should be a super-Haskell Ninja.  People just need to know about the opportunities that Haskell opens up.  Learning Haskell expands your mind. <br><br><br>  The basis of mainstream languages ‚Äã‚Äãis very similar. <br><br><ul><li>  variables </li><li>  cycles </li><li>  pointers (even if most languages ‚Äã‚Äãtry to hide this fact, it still remains a fact) </li><li>  structures, objects and classes (in most languages) </li></ul><br><br>  Haskell is very different.  This language uses a bunch of concepts that I have never heard of before.  Many of these concepts will help you become a better programmer. <br><br><br>  But learning Haskell can be hard.  At least it was difficult for me.  And in this article I will try to show what I lacked in the process of studying. <br><br>  This article will be difficult to master.  This was done on purpose.  There are no easy ways to learn Haskell.  This road is difficult and intricate.  But I think this is good.  Because it is the complexity of Haskell that makes it interesting. <br><br>  The usual method of learning Haskell is to read two books. <br>  First <a href="http://learnyouahaskell.com/">‚ÄúLearn You a Haskell‚Äù</a> , and then <a href="http://book.realworldhaskell.org/read/">‚ÄúReal World Haskell‚Äù</a> . <br><br>  I agree that this is the right approach to learning.  But in order to understand what Haskell is, you‚Äôll have to read these books very carefully. <br><br><br>  On the other hand, this article is a very brief and concise introduction to all major aspects of Haskell.  I also added some nuances that I lacked when learning Haskell. <br><br><br>  The article consists of five parts: <br><br><ul><li>  Introduction: A short example to show that Haskell may not be scary. </li><li>  The very basics of Haskell: Haskell syntax and some basic structures. </li><li>  The difficult part: <br><ul><li>  Functional style;  An example with the transition from imperative to functional style </li><li>  Types;  types and standard binary tree example </li><li>  Infinite structures;  Work with an endless binary tree! </li></ul><br></li><li>  Damn hard part: <br><ul><li>  We deal with IO;  Minimal example </li><li>  Parsing trick with IO;  unobvious little thing that kept me from understandingIO </li><li>  Monads;  unrealistically powerful abstraction tool </li></ul><br></li><li>  Application: <br><ul><li>  A few more words about endless trees;  mathematically oriented discussion of infinite trees </li></ul><br></li></ul><br><br><blockquote>  Note: Every time you see a delimiter with a file name and a <code>.lhs</code> extension, <br>  You can download it. <br>  If you save the file as <code>filename.lhs</code> , you can run it with <br>  runhaskell filename.lhs <br><br><br>  Some examples may not work, but most should. <br>  Below you should see a link to the file. <br></blockquote><br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>00_hello_world.lhs</strong></a> <br><br><a name="introduction"></a><br><h2>  Introduction </h2><br><a name="install"></a><br><h3>  Installation </h3><br><br><img src="https://habrastorage.org/storage2/6d0/197/7d9/6d01977d9b53a5870a87ca90d01f3356.png"><br><br><ul><li>  <a href="http://www.haskell.org/platform">The Haskell Platform</a> is the standard way to install Haskell. </li></ul><br><br>  Utilities: <br><br><ul><li>  <code>ghc</code> : A compiler similar to gcc for <code>C</code> </li><li>  <code>ghci</code> : Haskell interactive shell (REPL) </li><li>  <code>runhaskell</code> : Run the program without compiling it.  Convenient, but very slow compared to compiled programs. </li></ul><br><br><a name="don-t-be-afraid"></a><br><h3>  No panic </h3><br><br><img src="https://habrastorage.org/storage2/809/238/2c3/8092382c36b2b005e7035507a2caaee8.jpg"><br><br>  Many books and articles begin their acquaintance with Haskell with some esoteric formulas (quick sort, Fibonacci, etc.).  I will act differently.  I will not immediately show Haskell's superpower.  I will focus on things in which Haskell is similar to other programming languages.  So let's start with the familiar ‚ÄúHello World‚Äù. <br><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = putStrLn <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span></code> </pre> <br><br>  To run it, save this code as <code>hello.hs</code> and execute: <br><br><pre> <code class="haskell hljs"> ~ runhaskell ./hello.hs <span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-type"><span class="hljs-type">World</span></span>!</code> </pre> <br><br>  You can download the source at the link that is under the "Introduction" <br><br>  Save the <code>00_hello_world.lhs</code> file and execute: <br><br><pre> <code class="haskell hljs"> ~ runhaskell <span class="hljs-number"><span class="hljs-number">00</span></span>_hello_world.lhs <span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-type"><span class="hljs-type">World</span></span>!</code> </pre> <br><br>  <a href="">01_basic / 10_Introduction / <strong>00_hello_world.lhs</strong></a> <br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>10_hello_you.lhs</strong></a> <br><br>  And now we‚Äôll write a program that asks for your name and says ‚ÄúHi, name!‚Äù: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> print <span class="hljs-string"><span class="hljs-string">"  ?"</span></span> name &lt;- getLine print (<span class="hljs-string"><span class="hljs-string">" "</span></span> ++ name ++ <span class="hljs-string"><span class="hljs-string">"!"</span></span>)</code> </pre><br><br>  To begin with, let's compare our example with other imperative languages: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Python print "  ?" name = raw_input() print " %s!" % name</span></span></code> </pre><br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Ruby puts "  ?" name = gets.chomp puts " #{name}!"</span></span></code> </pre><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> C #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdio.h&gt; <span class="hljs-type"><span class="hljs-type">int</span></span> main (<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> **argv) { <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>[<span class="hljs-number"><span class="hljs-number">666</span></span>]; // &lt;-  ! //  ,     <span class="hljs-number"><span class="hljs-number">665</span></span> ? printf("  ?\n"); scanf("%s", <span class="hljs-type"><span class="hljs-type">name</span></span>); printf(" %s!\n", <span class="hljs-type"><span class="hljs-type">name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  The structure of the programs is very similar, but there are minor syntactic differences.  The main part of the tutorial will be devoted to these differences. <br><br><br>  In Haskell, each function and object has its own type. <br>  The type of the <code>main</code> function is <code>IO ()</code> . <br>  This means that when executed, <code>main</code> creates side effects. <br><br>  But do not forget that Haskell can look like an ordinary imperative language. <br><br>  <a href="">01_basic / 10_Introduction / <strong>10_hello_you.lhs</strong></a> <br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>20_very_basic.lhs</strong></a> <br><br><a name="very-basic-haskell"></a><br><h3>  Most basic haskell </h3><br><br><img src="http://habrastorage.org/storage2/f92/f4e/784/f92f4e7843c7779f0a92f436cb28f2f0.jpg"><br><br>  Before we continue, I would like to warn you about some of the characteristic features of Haskell. <br><br>  <em>Functionality</em> <br><br>  Haskell is a functional language. <br>  If you started with imperative languages, you will have to learn a lot of new things. <br>  Fortunately, many of these concepts will help you to program better even in imperative languages. <br><br>  <em>Advanced static typing</em> <br><br>  Instead of standing in your way as in <code>C</code> , <code>C++</code> or <code>Java</code> , the type system will help you. <br><br>  <em>Purity</em> <br><br>  Generally speaking, your functions will not change anything in the outside world. <br>  On the one hand, this means that functions cannot change the value of a variable, cannot receive data from the user, cannot write on the screen, cannot launch rockets. <br>  On the other hand, we get easy parallelization of our programs. <br>  Haskell makes a clear distinction between pure functions and functions that produce side effects. <br>  With this approach, it becomes much easier to analyze the properties of your program. <br>  In functionally clean parts of the program, many errors will be eliminated at the compilation stage. <br><br><br>  Moreover, functionally pure functions follow the basic Haskell law: <br><br><blockquote>  Calling a function with the same parameters will always give the same result. <br></blockquote><br><br>  <em>Laziness</em> <br><br>  Default laziness is a very unusual thing in programming languages. <br>  By default, Haskell calculates a value only when it is actually needed. <br>  As a result, we have the ability to very easily work with infinite data structures. <br><br>  The last warning will be about how to read the Haskell code. <br>  For me, this is similar to reading scientific articles. <br>  Some parts may be simple and clear, but if you see the formula, concentrate and read more slowly. <br>  When learning Haskell, it <em>really</em> doesn‚Äôt matter if you don‚Äôt fully understand some of the syntaxist‚Äôs features. <br>  If you meet <code>&gt;&gt;=</code> , <code>&lt;$&gt;</code> , <code>&lt;-</code> or other scary characters, just ignore them and try to understand the general idea of ‚Äã‚Äãthe code. <br><br><a name="function-declaration"></a><br><h4>  Definition of functions </h4><br><br>  You can define functions as follows: <br><br>  On <code>C</code> : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x + y*y; }</code> </pre><br><br>  In Javascript: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x + y*y; }</code> </pre><br><br>  In Python: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x + y*y</code> </pre><br><br>  On Ruby: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span></span> x*x + y*y <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  On Scheme: <br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">fxy</span></span>) (<span class="hljs-name"><span class="hljs-name">+</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> xx) (<span class="hljs-name"><span class="hljs-name">*</span></span> yy)))</code> </pre><br><br>  And finally, Haskell: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fxy</span></span> = x*x + y*y</code> </pre><br><br>  Very clear.  Neither brackets, nor <code>def</code> . <br><br>  Remember that Haskell makes extensive use of functions and types. <br>  And therefore it is very easy to define them. <br>  The language syntax was thought out in order to make the definition as simple as possible. <br><br><a name="a-type-example"></a><br><h4>  An example of creating a new type </h4><br><br>  Usually when writing programs, you specify the type of function. <br>  But this is optional. <br>  The compiler is smart enough to do it for you. <br><br>  Let's play a little. <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--     :: f :: Int -&gt; Int -&gt; Int fxy = x*x + y*y main = print (f 2 3)</span></span></code> </pre><br><br><pre> <code class="haskell hljs">~ runhaskell <span class="hljs-number"><span class="hljs-number">20</span></span>_very_basic.lhs <span class="hljs-number"><span class="hljs-number">13</span></span></code> </pre><br>  <a href="">01_basic / 10_Introduction / <strong>20_very_basic.lhs</strong></a> <br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>21_very_basic.lhs</strong></a> <br><br>  Now try <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> fxy = x*x + y*y main = print (f <span class="hljs-number"><span class="hljs-number">2.3</span></span> <span class="hljs-number"><span class="hljs-number">4.2</span></span>)</code> </pre><br><br>  You will get an error: <br><pre> <code class="haskell hljs"><span class="hljs-number"><span class="hljs-number">21</span></span>_very_basic.lhs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">Fractional</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) arising from the literal `<span class="hljs-number"><span class="hljs-number">4.2</span></span>' <span class="hljs-type"><span class="hljs-type">Possible</span></span> fix: add an <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> declaration for (<span class="hljs-type"><span class="hljs-type">Fractional</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-type"><span class="hljs-type">In</span></span> the second argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> `f', namely `<span class="hljs-number"><span class="hljs-number">4.2</span></span>' <span class="hljs-type"><span class="hljs-type">In</span></span> the first argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> `print', namely `(f <span class="hljs-number"><span class="hljs-number">2.3</span></span> <span class="hljs-number"><span class="hljs-number">4.2</span></span>)' <span class="hljs-type"><span class="hljs-type">In</span></span> the expression: print (f <span class="hljs-number"><span class="hljs-number">2.3</span></span> <span class="hljs-number"><span class="hljs-number">4.2</span></span>)</code> </pre><br><br>  The problem is that <code>4.2</code> is not int. <br><br>  <a href="">01_basic / 10_Introduction / <strong>21_very_basic.lhs</strong></a> <br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>22_very_basic.lhs</strong></a> <br><br>  One solution would not explicitly indicate the type of the function <code>f</code> . <br>  Then Haskell will print the most common type for us: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fxy</span></span> = x*x + y*y main = print (f <span class="hljs-number"><span class="hljs-number">2.3</span></span> <span class="hljs-number"><span class="hljs-number">4.2</span></span>)</code> </pre><br><br>  Earned! <br>  Great, we don‚Äôt need to create a new function for each data type. <br>  For example, in <code>C</code> , you would need to create a function for <code>int</code> , for <code>float</code> , for <code>long</code> , for <code>double</code> , etc. <br><br>  But what type should we specify? <br>  To understand which type Haskell brought us, just run ghci: <br><br><pre> <code class="haskell hljs">% ghci <span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">7.0</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>: http://www.haskell.org/ghc/ :? for help <span class="hljs-type"><span class="hljs-type">Loading</span></span> package ghc-prim ... linking ... done. <span class="hljs-type"><span class="hljs-type">Loading</span></span> package integer-gmp ... linking ... done. <span class="hljs-type"><span class="hljs-type">Loading</span></span> package base ... linking ... done. <span class="hljs-type"><span class="hljs-type">Loading</span></span> package ffi<span class="hljs-number"><span class="hljs-number">-1.0</span></span> ... linking ... done. <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fxy = x*x + y*y <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; :<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> f f :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> a =&gt; a -&gt; a -&gt; a</span></span></code> </pre><br><br>  Hmm ... What is this weird type? <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Num</span></span> a =&gt; a -&gt; a -&gt; a</code> </pre><br><br>  At first we will pay attention to the right part <code>a -&gt; a -&gt; a</code> . <br>  To understand it, let's look at a few examples: <br><br><table><tbody><tr><td>  Specified type </td><td>  Value </td></tr><tr><td> <code>Int</code> </td> <td>  <code>Int</code> type </td></tr><tr><td> <code>Int -&gt; Int</code> </td> <td>  a function that takes an <code>Int</code> as input and returns an <code>Int</code> </td></tr><tr><td> <code>Float -&gt; Int</code> </td> <td>  function that takes an input <code>Float</code> and returns an <code>Int</code> </td></tr><tr><td> <code>a -&gt; Int</code> </td> <td>  the type of the function that accepts any type of input and returns an <code>Int</code> </td></tr><tr><td> <code>a -&gt; a</code> </td> <td>  the type of the function, which takes type <code>a</code> as input and returns the result of type <code>a</code> </td></tr><tr><td> <code>a -&gt; a -&gt; a</code> </td> <td>  the type of the function that takes two arguments of type <code>a</code> as input and returns the result of type <code>a</code> </td></tr></tbody></table><br><br>  In the type <code>a -&gt; a -&gt; a</code> , the letter <code>a</code> is <em>a type variable</em> . <br>  This means that <code>f</code> is a function of two arguments, and both arguments, as well as the result, have the same type. <br>  A variable of type <code>a</code> can take values ‚Äã‚Äãof various types. <br>  For example <code>Int</code> , <code>Integer</code> , <code>Float</code> ... <br><br>  So instead of hard typing the type, as in <code>C</code> and separately define functions for <code>int</code> , <code>long</code> , <code>float</code> , <code>double</code> , etc. ... <br>  We simply create one function, as in a dynamically typed language. <br><br>  Generally speaking, <code>a</code> can be of any type. <br>  <code>String</code> , <code>Int</code> , more complex type, such as <code>Trees</code> , type of another function, etc. <br>  But in our example, the type has the prefix <code>Num a =&gt;</code> . <br><br>  <code>Num</code> is <em>a type class</em> . <br>  Class type can be represented as a set of types. <br>  <code>Num</code> includes only types that behave like numbers. <br>  More strictly, <code>Num</code> is a class containing types that implement a given set of functions, in particular <code>(+)</code> and <code>(*)</code> . <br><br>  Type classes are a very powerful element of the language. <br>  With their help, we can create amazing things. <br>  But we'll talk about this a little later. <br><br>  So, the entry <code>Num a =&gt; a -&gt; a -&gt; a</code> means: <br><br>  Let <code>a</code> be <code>a</code> type belonging to the class of types <code>Num</code> . <br>  This is a function that takes input <code>a</code> and returns ( <code>a -&gt; a</code> ). <br><br>  Well, weird. <br>  In fact, in Haskell no function takes two arguments as input. <br>  Instead, all functions have only one argument. <br>  But note that the function of the two arguments can be represented as a function that takes the first argument and returns a function that takes the second argument as a parameter. <br>  . <br><br>  That is, <code>f 3 4</code> equivalent to <code>(f 3) 4</code> . <br>  Please note that <code>f 3</code> is also a function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a :: a -&gt; a -&gt; a g :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a :: a -&gt; a g = f <span class="hljs-number"><span class="hljs-number">3</span></span> gy ‚áî <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span> + y*y</code> </pre><br><br>  You can also use another entry to create a function. <br>  Lambda expressions allow you to create functions without naming them. <br>  They are also called anonymous functions. <br>  We can write: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">g</span></span> = \y -&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span> + y*y</code> </pre><br><br>  The <code>\</code> character is used because it is similar to the <code>Œª</code> character, but at the same time it is an ASCII character. <br><br>  If functional programming is new to you, by this point your brain starts to boil. <br>  It's time to write a real application. <br><br>  <a href="">01_basic / 10_Introduction / <strong>22_very_basic.lhs</strong></a> <br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>23_very_basic.lhs</strong></a> <br><br>  But before we start, we need to check that the type system works as it should: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a =&gt; a -&gt; a -&gt; a fxy = x*x + y*y main = print (f <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2.4</span></span>)</code> </pre><br><br>  This code works because <code>3</code> can represent either a Fractional (fractional) number of type Float, or an integer of type Integer. <br>  Since <code>2.4</code> is of type Fractional, <code>3</code> also represented as a Fractional number. <br><br>  <a href="">01_basic / 10_Introduction / <strong>23_very_basic.lhs</strong></a> <br><br><hr><br>  <a href="">01_basic / 10_Introduction / <strong>24_very_basic.lhs</strong></a> <br><br>  If we register other types in the function, it will stop working: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a =&gt; a -&gt; a -&gt; a fxy = x*x + y*y x :: <span class="hljs-type"><span class="hljs-type">Int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> y :: <span class="hljs-type"><span class="hljs-type">Float</span></span> y = <span class="hljs-number"><span class="hljs-number">2.4</span></span> main = print (fxy) <span class="hljs-comment"><span class="hljs-comment">--   ,   x ‚â†  y</span></span></code> </pre><br><br>  The compiler signals an error. <br>  Two parameters must be of the same type. <br><br>  If you think this is a bad idea, and the compiler should convert the types for you, you really should see a great and funny video: <br>  <a href="https://www.destroyallsoftware.com/talks/wat">Wat</a> <br><br>  <a href="">01_basic / 10_Introduction / <strong>24_very_basic.lhs</strong></a> <br><br><a name="essential-haskell"></a><br><h2>  Haskell Minimum Required </h2><br><br><img src="http://habrastorage.org/storage2/e12/b2a/e8b/e12b2ae8bb9fd52d4a586fcd82a44711.jpg"><br><br>  I advise you to skim this section. <br>  Think of it as reference material. <br>  Haskell is a very versatile language. <br>  Therefore, some things in this section will be skipped. <br>  If necessary, come back here if any things seem strange or incomprehensible to you. <br><br>  I will use the symbol <code>‚áî</code> to show the equivalence of two expressions. <br>  This is a meta-notation, in Haskell does not exist. <br>  The <code>‚áí</code> symbol will be used to show the result of evaluating an expression. <br><a name="notations"></a><br><h3>  Expressions </h3><br><a name="arithmetic"></a><br><h5>  Arithmetic </h5><br><pre> <code class="haskell hljs"><span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">6</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> ‚áî <span class="hljs-number"><span class="hljs-number">3</span></span> + ((<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">6</span></span>)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br><a name="logic"></a><br><h5>  brain teaser </h5><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">True</span></span> || <span class="hljs-type"><span class="hljs-type">False</span></span> ‚áí <span class="hljs-type"><span class="hljs-type">True</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> &amp;&amp; <span class="hljs-type"><span class="hljs-type">False</span></span> ‚áí <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> == <span class="hljs-type"><span class="hljs-type">False</span></span> ‚áí <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> /= <span class="hljs-type"><span class="hljs-type">False</span></span> ‚áí <span class="hljs-type"><span class="hljs-type">True</span></span> (/=)    </code> </pre><br><a name="powers"></a><br><h5>  Exponentiation </h5><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span>^n   n (<span class="hljs-type"><span class="hljs-type">Int</span></span>  <span class="hljs-type"><span class="hljs-type">Integer</span></span>) x**y    y ( <span class="hljs-type"><span class="hljs-type">Float</span></span>)</code> </pre><br>  <code>Integer</code> not limited in size, except for the memory of the machine: <br><br><pre> <code class="haskell hljs"><span class="hljs-number"><span class="hljs-number">4</span></span>^<span class="hljs-number"><span class="hljs-number">103</span></span> <span class="hljs-number"><span class="hljs-number">102844034832575377634685573909834406561420991602098741459288064</span></span></code> </pre><br><br>  Oh yeah! <br>  And you can also use rational numbers! <br>  But for this you need to use the <code>Data.Ratio</code> module: <br><br><pre> <code class="haskell hljs">$ ghci .... <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; :m <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Ratio</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Ratio</span></span>&gt; (<span class="hljs-number"><span class="hljs-number">11</span></span> % <span class="hljs-number"><span class="hljs-number">15</span></span>) * (<span class="hljs-number"><span class="hljs-number">5</span></span> % <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">11</span></span> % <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br><a name="lists"></a><br><h5>  Lists </h5><br><pre> <code class="haskell hljs">[] ‚áî   [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] ‚áî    [<span class="hljs-string"><span class="hljs-string">"foo"</span></span>,<span class="hljs-string"><span class="hljs-string">"bar"</span></span>,<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] ‚áî   (<span class="hljs-type"><span class="hljs-type">String</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>:[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], (:)    <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:[] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] ++ [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>], (++)   [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] ++ [<span class="hljs-string"><span class="hljs-string">"foo"</span></span>] ‚áî  <span class="hljs-type"><span class="hljs-type">String</span></span> ‚â† <span class="hljs-type"><span class="hljs-type">Integral</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>] [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">11.</span></span><span class="hljs-number"><span class="hljs-number">.100</span></span>] ‚áî !    ! [<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre><br><a name="strings"></a><br><h5>  Strings </h5><br><br>  In Haskell, strings are a list of <code>Char</code> . <br><pre> <code class="haskell hljs">'a' :: <span class="hljs-type"><span class="hljs-type">Char</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span> :: [<span class="hljs-type"><span class="hljs-type">Char</span></span>] <span class="hljs-string"><span class="hljs-string">""</span></span> ‚áî [] <span class="hljs-string"><span class="hljs-string">"ab"</span></span> ‚áî ['a','b'] ‚áî 'a':<span class="hljs-string"><span class="hljs-string">"b"</span></span> ‚áî 'a':['b'] ‚áî 'a':'b':[] <span class="hljs-string"><span class="hljs-string">"abc"</span></span> ‚áî <span class="hljs-string"><span class="hljs-string">"ab"</span></span>++<span class="hljs-string"><span class="hljs-string">"c"</span></span></code> </pre><br><blockquote>  <em>Note</em> : <br>  In real-world tasks, you will not use a list of characters for working with text. <br>  In most cases, <code>Data.Text</code> used for this. <br>  If you need to work with a stream of ASCII characters, you should use <code>Data.ByteString</code> . <br></blockquote><br><br><a name="tuples"></a><br><h5>  Tuples </h5><br><br>  You can set the pair as follows <code>(a,b)</code> . <br>  Elements of a tuple can be of various types. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--    -  (2,"foo") (3,'a',[2,3]) ((2,"a"),"c",3) fst (x,y) ‚áí x snd (x,y) ‚áí y fst (x,y,z) ‚áí ERROR: fst :: (a,b) -&gt; a snd (x,y,z) ‚áí ERROR: snd :: (a,b) -&gt; b</span></span></code> </pre><br><br><a name="deal-with-parentheses"></a><br><h5>  We deal with brackets </h5><br><br>  To get rid of extra parentheses, you can use these functions: <code>($)</code> and <code>(.)</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  : fghx ‚áî (((fg) h) x) -- $    $ --    fg $ hx ‚áî fg (hx) ‚áî (fg) (hx) f $ ghx ‚áî f (ghx) ‚áî f ((gh) x) f $ g $ hx ‚áî f (g (hx)) -- (.)   (f . g) x ‚áî f (gx) (f . g . h) x ‚áî f (g (hx))</span></span></code> </pre><br><br><hr><br>  <a href="">01_basic / 20_Essential_Haskell / <strong>10a_Functions.lhs</strong></a> <br><br><a name="useful-notations-for-functions"></a><br><h3>  Useful things to write functions </h3><br><br>  A small reminder: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> ‚áî x   <span class="hljs-type"><span class="hljs-type">Int</span></span> x :: a ‚áî x     x :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a =&gt; a ‚áî x     a,     <span class="hljs-type"><span class="hljs-type">Num</span></span> f :: a -&gt; b ‚áî f      a     b f :: a -&gt; b -&gt; c ‚áî f  ,    a   (b‚Üíc) f :: (a -&gt; b) -&gt; c ‚áî f  ,    (a‚Üíb)   c</code> </pre><br><br>  It is not necessary to declare a function type before defining it. <br>  Haskell will print the most common type. <br>  But specifying the type of function is a good tone rule. <br><br>  <em>Infix notation</em> <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> :: <span class="hljs-type"><span class="hljs-type">Num</span></span> a =&gt; a -&gt; a square x = x^<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  Note that <code>^</code> used in infix notation. <br>  For each infix operator there is the possibility of prefix notation. <br>  Just enclose the desired operator in brackets. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square'</span></span> x = (^) x <span class="hljs-number"><span class="hljs-number">2</span></span> square'' x = (^<span class="hljs-number"><span class="hljs-number">2</span></span>) x</code> </pre><br><br>  We can remove <code>x</code> from the left and right side of the expression! <br>  This is called Œ∑-reduction. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square'''</span></span> = (^<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Please note that we can use the symbol <code>'</code> in the function name. <br>  For example: <br><blockquote>  <code>square</code> ‚áî <code>square'</code> ‚áî <code>square''</code> ‚áî <code>square '''</code> <br></blockquote><br><br>  <em>Tests</em> <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">absolute</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a, <span class="hljs-type"><span class="hljs-type">Num</span></span> a) =&gt; a -&gt; a absolute x = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -x</code> </pre><br><br>  Note: the <code>if .. then .. else</code> in Haskell is more like an operator <br>  <code>¬§?¬§:¬§</code> in C. You cannot omit <code>else</code> . <br><br>  Another equivalent function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">absolute'</span></span> x | x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> = x | otherwise = -x</code> </pre><br><blockquote>  Warning: alignment <em>is important</em> in Haskell programs. <br>  As in Python, incorrect alignment can break the code! <br></blockquote><br><br><a name="hard-part"></a><br><h2>  Tricky part </h2><br><br>  We proceed to the study of the difficult part. <br><a name="functional-style"></a><br><h3>  Functional style </h3><br><img src="http://habrastorage.org/storage2/4e3/d97/648/4e3d976483399d95f86fff1d92e1c3b8.jpg"><br>  In this section, I'll show you a small example of Haskell's amazing code refactoring capabilities. <br>  We will choose a problem and solve it in a standard imperative way.  Then we will start to improve this code little by little.  The end result will be much easier to understand and more elegant. <br><br><br>  Here is the condition of the problem that we will solve: <br><br><blockquote>  Having a list of integers, you must calculate the sum of even numbers in the list. <br><br>  example: <br> <code>[1,2,3,4,5] ‚áí 2 + 4 ‚áí 6</code> <br> </blockquote><br><br>  In order to show the difference between the functional and the imperative approach, we first write an imperative solution (in Javascript): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evenSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; list.length ; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i] % <span class="hljs-number"><span class="hljs-number">2</span></span> ==<span class="hljs-number"><span class="hljs-number">0</span></span>) { result += list[i]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  But in Haskell there are no variables and loops. <br>  Without cycles, the same result can be obtained using recursion. <br><br><blockquote>  <em>Note</em> : <br>  Recursion in imperative languages ‚Äã‚Äãhas a reputation as a slow tool.  But for most functional languages ‚Äã‚Äãthis is not the case.  In most cases, Haskell optimizes work with recursive functions in a very high quality. <br></blockquote><br><br>  Here is the version of the recursive function written in <code>C</code>  For simple, I assume that the list of numbers ends with a null value. <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evenSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumSum(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accumSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *xs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">list</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if the list is empty return n; } else { x = list[0]; // let x be the first element of the list xs = list+1; // let xs be the list without x if ( 0 == (x%2) ) { // if x is even return accumSum(n+x, xs); } else { return accumSum(n, xs); } } }</span></span></code> </pre><br>  Take a close look at this code.  Because we will translate it into Haskell. <br>  But before I show you three simple, but very useful functions that we will use: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">even</span></span> :: <span class="hljs-type"><span class="hljs-type">Integral</span></span> a =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> head :: [a] -&gt; a tail :: [a] -&gt; [a]</code> </pre><br><br>  <code>even</code> parity check. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">even</span></span> :: <span class="hljs-type"><span class="hljs-type">Integral</span></span> a =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> even <span class="hljs-number"><span class="hljs-number">3</span></span> ‚áí <span class="hljs-type"><span class="hljs-type">False</span></span> even <span class="hljs-number"><span class="hljs-number">2</span></span> ‚áí <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre><br>  <code>head</code> returns the first item in the list: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> :: [a] -&gt; a head [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] ‚áí <span class="hljs-number"><span class="hljs-number">1</span></span> head [] ‚áí <span class="hljs-type"><span class="hljs-type">ERROR</span></span></code> </pre><br><br>  <code>tail</code> returns all list items, except for the first: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> :: [a] -&gt; [a] tail [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] ‚áí [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] tail [<span class="hljs-number"><span class="hljs-number">3</span></span>] ‚áí [] tail [] ‚áí <span class="hljs-type"><span class="hljs-type">ERROR</span></span></code> </pre><br>  Note that for any non-empty list <code>l</code> , <br> <code>l ‚áî (head l):(tail l)</code> <br> <br><hr><br>  <a href="">02_Hard_Part / <strong>11_Functions.lhs</strong></a> <br><br>  So, the first solution to the Haskell problem. <br>  The <code>evenSum</code> function returns the sum of all even numbers in the list: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  1 evenSum :: [Integer] -&gt; Integer evenSum l = accumSum 0 l accumSum nl = if l == [] then n else let x = head l xs = tail l in if even x then accumSum (n+x) xs else accumSum n xs</span></span></code> </pre><br><br>  To test the function, simply run <code>ghci</code> : <br><pre> <code class="haskell hljs">% ghci <span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">7.0</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>: http://www.haskell.org/ghc/ :? for help <span class="hljs-type"><span class="hljs-type">Loading</span></span> package ghc-prim ... linking ... done. <span class="hljs-type"><span class="hljs-type">Loading</span></span> package integer-gmp ... linking ... done. <span class="hljs-type"><span class="hljs-type">Loading</span></span> package base ... linking ... done. <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; :load <span class="hljs-number"><span class="hljs-number">11</span></span>_Functions.lhs [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">Main</span></span> ( <span class="hljs-number"><span class="hljs-number">11</span></span>_Functions.lhs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, modules loaded: <span class="hljs-type"><span class="hljs-type">Main</span></span>. *<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; evenSum [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.5</span></span>] <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><br>  Below is an example of how the function works (I cheat. In the course. We will return to the question of non-strict calculations later): <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; evenSum [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.5</span></span>] accumSum <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> is odd accumSum <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> is even accumSum (<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-number"><span class="hljs-number">3</span></span> is odd accumSum (<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span> is even accumSum (<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>) [<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-number"><span class="hljs-number">5</span></span> is odd accumSum (<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>) [] l == [] <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  From the point of imperative language, everything looks fine.  But there is plenty of room for improvement.  For a start, we can make the type more general. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">evenSum</span></span> :: <span class="hljs-type"><span class="hljs-type">Integral</span></span> a =&gt; [a] -&gt; a</code> </pre><br><br>  <a href="">02_Hard_Part / <strong>11_Functions.lhs</strong></a> <br><br><hr><br>  <a href="">02_Hard_Part / <strong>12_Functions.lhs</strong></a> <br><br>  The next step is to use nested functions defined with <code>where</code> or <code>let</code> . <br>  Thus, our <code>accumSum</code> function <code>accumSum</code> not pollute the global namespace. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  2 evenSum :: Integral a =&gt; [a] -&gt; a evenSum l = accumSum 0 l where accumSum nl = if l == [] then n else let x = head l xs = tail l in if even x then accumSum (n+x) xs else accumSum n xs</span></span></code> </pre><br><br>  <a href="">02_Hard_Part / <strong>12_Functions.lhs</strong></a> <br><br><hr><br>  <a href="">02_Hard_Part / <strong>13_Functions.lhs</strong></a> <br><br>  And now we use pattern matching. <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  3 evenSum l = accumSum 0 l where accumSum n [] = n accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs</span></span></code> </pre><br><br>  What is pattern matching?  This is simply the use of values ‚Äã‚Äãinstead of named parameters.  (For the most daring detailed description of pattern matching can be explored <a href="http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/patterns.html">here</a> ) <br><br>  Instead of this code: <code>foo l = if l == [] then &lt;x&gt; else &lt;y&gt;</code> <br>  You can simply write: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> [] = &lt;x&gt; foo l = &lt;y&gt;</code> </pre><br><br>  But pattern matching can do much more.  It can analyze the internal data of a complex structure.  We can replace <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = head l xs = tail l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> even x <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> foo (n+x) xs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> foo n xs</code> </pre><br>  on <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> even x <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> foo (n+x) xs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> foo n xs</code> </pre><br><br>  Very useful feature. <br>  It makes our code more concise and readable. <br><br>  <a href="">02_Hard_Part / <strong>13_Functions.lhs</strong></a> <br><br><hr><br>  <a href="">02_Hard_Part / <strong>14_Functions.lhs</strong></a> <br><br>  You can simplify writing functions in Haskell using Œ∑-reduction. <br>  For example, instead of this entry: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fx</span></span> = (- ) x</code> </pre><br><br>  can be used <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> = - </code> </pre><br><br>  We can use this approach to get rid of <code>l</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  4 evenSum :: Integral a =&gt; [a] -&gt; a evenSum = accumSum 0 where accumSum n [] = n accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs</span></span></code> </pre><br>  <a href="">02_Hard_Part / <strong>14_Functions.lhs</strong></a> <br><br><hr><br>  <a href="">02_Hard_Part / <strong>15_Functions.lhs</strong></a> <br><br><a name="higher-order-functions"></a><br><h4>  Higher Order Functions </h4><br><img src="http://habrastorage.org/storage2/6a9/49b/585/6a949b585affcbfb2c72072b1c0f0aa6.png"><br><br>  To make our function even more beautiful, we can apply FVP (higher order functions). <br>  You ask, what are these animals? <br>  Higher-order functions are functions that take functions as parameters. <br><br>  A couple of examples: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">filter</span></span> :: (a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; [a] -&gt; [a] map :: (a -&gt; b) -&gt; [a] -&gt; [b] foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</code> </pre><br><br>  We will move in small steps. <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  5 evenSum l = mysum 0 (filter even l) where mysum n [] = n mysum n (x:xs) = mysum (n+x) xs</span></span></code> </pre><br>  Where <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">filter</span></span> even [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre><br>  The <code>filter</code> function accepts a function of type ( <code>a -&gt; Bool</code> ) and a list of type <code>[a]</code> as arguments.  It returns a list containing only those elements for which the function returned <code>true</code> . <br><br>  Our next step will be to further simplify the cycle.  We use the <code>foldl</code> function, which allows you to accumulate a value.  The <code>foldl</code> function implements a popular programming technique: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">myfunc</span></span> list = foo initialValue list foo accumulated [] = accumulated foo tmpValue (x:xs) = foo (bar tmpValue x) xs</code> </pre><br>  The code above can be replaced by: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">myfunc</span></span> list = foldl bar initialValue list</code> </pre><br><br>  If you really want to understand the magic going on, <br>  the implementation of <code>foldl</code> shown below. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> fz [] = z foldl fz (x:xs) = foldl f (fzx) xs</code> </pre><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> fz [x1,...xn] ‚áî f (... (f (fz x1) x2) ...) xn</code> </pre><br><br>  But since Haskell is a lazy language, it does not calculate the value <code>(fzx)</code> , but pushes it <code>(fzx)</code> stack. <br>  Therefore, we will use <code>foldl'</code> instead of <code>foldl</code> ; <br>  <code>foldl'</code> is a <em>strict (or energetic)</em> implementation of <code>foldl</code> . <br><br>  If the difference between lazy and strict functions is not obvious to you, do not worry, just read the code, considering that both functions are the same. <br><br><br>  Now our version of <code>evenSum</code> looks like this: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  6 -- foldl'     --       Data.List import Data.List evenSum l = foldl' mysum 0 (filter even l) where mysum acc value = acc + value</span></span></code> </pre><br>  This code can be simplified even more by using lambda expressions. In this way, we get rid of the temporary identifier <code>mysum</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  7 --     --     import Data.List (foldl') evenSum l = foldl' (\xy -&gt; x+y) 0 (filter even l)</span></span></code> </pre><br>  And of course, we can do the following substitution. <br><pre> <code class="haskell hljs">(\xy -&gt; x+y) ‚áî (+)</code> </pre><br>  <a href="">02_Hard_Part / <strong>15_Functions.lhs</strong></a> <br><br><hr><br>  <a href="">02_Hard_Part / <strong>16_Functions.lhs</strong></a> <br><br>  Eventually <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  8 import Data.List (foldl') evenSum :: Integral a =&gt; [a] -&gt; a evenSum l = foldl' (+) 0 (filter even l)</span></span></code> </pre><br>  <code>foldl'</code> not the most intuitive feature.  But with her, you should definitely figure it out. <br><br>  To do this, we will conduct a step-by-step analysis: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">evenSum</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚áí foldl' (+) <span class="hljs-number"><span class="hljs-number">0</span></span> (filter even [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]) ‚áí foldl' (+) <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚áí foldl' (+) (<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚áí foldl' (+) <span class="hljs-number"><span class="hljs-number">2</span></span> [<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚áí foldl' (+) (<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>) [] ‚áí foldl' (+) <span class="hljs-number"><span class="hljs-number">6</span></span> [] ‚áí <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><br>       <code>(.)</code> . <br>  <code>(.)</code>   . <br><pre> <code class="haskell hljs">(f . g . h) x ‚áî f ( g (hx))</code> </pre><br><br>    ,    Œ∑-  : <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  9 import Data.List (foldl') evenSum :: Integral a =&gt; [a] -&gt; a evenSum = (foldl' (+) 0) . (filter even)</span></span></code> </pre><br><br>    -,    : <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  10 import Data.List (foldl') sum' :: (Num a) =&gt; [a] -&gt; a sum' = foldl' (+) 0 evenSum :: Integral a =&gt; [a] -&gt; a evenSum = sum' . (filter even)</span></span></code> </pre><br><br>   . <br>   ,    ? <br><br>     .     ,      . ,      .   ,          . <br><br><pre> <code class="haskell hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚ñ∑ [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>] ‚ñ∑ [<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>] ‚ñ∑ <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre><br><br>      10  : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">squareEvenSum</span></span> = sum' . (filter even) . (map (^<span class="hljs-number"><span class="hljs-number">2</span></span>)) squareEvenSum' = evenSum . (map (^<span class="hljs-number"><span class="hljs-number">2</span></span>)) squareEvenSum'' = sum' . (map (^<span class="hljs-number"><span class="hljs-number">2</span></span>)) . (filter even)</code> </pre><br><br>       ‚Äú ‚Äù ( ,  <code>squareEvenSum''</code>    .  <code>(.)</code>   .). <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">map</span></span> (^<span class="hljs-number"><span class="hljs-number">2</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>]</code> </pre><br><br>  <code>map</code>   -    . <br><br>      <em></em>  . <br>     . <br>    ,      ¬´¬ª. <br>         . <br>    , map, fold  filter,     . <br><br>         . <br><br>   ,      ,    .,        ,      .     ‚Äî    : <a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire by Meijer, Fokkinga and Paterson</a> . <br><br>     ,      .             .   ,       . <br><br>     Haskell    DSL- (  ). <br><br><br>   , Haskell   ,         .    Haskell,      . <br><br><br>   ,        Haskell-,        ‚Äî <em></em> . <br><a name="types"></a><br><h3>  Types </h3><br><img src="http://habrastorage.org/storage2/0f1/7b4/ef9/0f17b4ef993ce2b9da74e47c8bb1402e.jpg"><br><blockquote> <abbr title="Too long; didn't read">tl;dr</abbr> : <br><br><ul><li> <code>type Name = AnotherType</code>   ,    <code>Name</code>  <code>AnotherType</code>  . </li><li> <code>data Name = NameConstructor AnotherType</code>      . </li><li> <code>data</code>    . </li><li> <code>deriving</code>         . </li></ul><br></blockquote><br><br> Haskell ‚Äî     . <br><br>  Why is this so important?    <em></em>   . <br>  Haskell,        .    ,        . <br>          ,    . <br><a name="type-inference"></a><br><h4>   </h4><br><br>        <br>         . <br><br>     Haskell- <em></em> . <br><br>  A simple example. <br>  <code>square</code>   Haskell: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> x = x * x</code> </pre><br><br>    <code>square</code> (  )    Numeral. <br>       <code>Int</code> , <code>Integer</code> , <code>Float</code> , <code>Fractional</code>   <code>Complex</code> .  For example: <br><br><pre> <code class="haskell hljs">% ghci <span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">7.0</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>: ... <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> square x = x*x <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; square <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; square <span class="hljs-number"><span class="hljs-number">2.1</span></span> <span class="hljs-number"><span class="hljs-number">4.41</span></span> <span class="hljs-type"><span class="hljs-type">Prelude</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">--   Data.Complex Prelude&gt; :m Data.Complex Prelude Data.Complex&gt; square (2 :+ 1) 3.0 :+ 4.0</span></span></code> </pre><br> <code>x :+ y</code>     ( <i>x + iy</i> ). <br><br>          C: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int_square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">complex</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complex_square</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">complex</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">complex</span></span> tmp; tmp.real = z.real * z.real - z.img * z.img; tmp.img = <span class="hljs-number"><span class="hljs-number">2</span></span> * z.img * z.real; } <span class="hljs-keyword"><span class="hljs-keyword">complex</span></span> x,y; y = complex_square(x);</code> </pre><br>       .       .   . C++     ,  : <br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;complex&gt;</span></span></span><span class="hljs-meta"> using namespace std; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt;</span></span></span><span class="hljs-meta"> T square(T x) { return x*x; } int main() { // int int sqr_of_five = square(5); cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; sqr_of_five &lt;&lt; endl; // double cout &lt;&lt; (double)square(5.3) &lt;&lt; endl; // complex cout &lt;&lt; square( complex&lt;double&gt;</span></span></span><span class="hljs-meta">(5,3) ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; endl; return 0; }</span></span></span></span></code> </pre><br><br>   C++    C. <br>           .     <br> <a href="http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/"> </a> <br>  . <br><br>  C++    ,      . <br>  Haskell  . <br>      . <br><br>   Haskell   ,     . <br>       ,  ,      . <br>    Haskell : <br><br><blockquote> ‚Äú  ,      ‚Äù <br></blockquote><br><br><hr><br> <a href="">02_Hard_Part/ <strong>21_Types.lhs</strong></a> <br><br><a name="type-construction"></a><br><h4>    </h4><br><br>      . ,    . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> showInfos :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> showInfos name color = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: " ++ name ++ ", </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class">: " ++ color name :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> name = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Robin</span></span></span><span class="hljs-class">" color :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> color = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Blue</span></span></span><span class="hljs-class">" main = putStrLn $ showInfos name color</span></span></code> </pre><br>        . <br>       <code>showInfos</code>   : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">putStrLn</span></span> $ showInfos color name</code> </pre><br>    .    Name, Color  String   .     . <br>      ‚Äî    <code>data</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NameConstr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ColorConstr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> showInfos :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> showInfos (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NameConstr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ColorConstr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color</span></span></span><span class="hljs-class">) = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: " ++ name ++ ", </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class">: " ++ color name = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NameConstr</span></span></span><span class="hljs-class"> "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Robin</span></span></span><span class="hljs-class">" color = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ColorConstr</span></span></span><span class="hljs-class"> "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Blue</span></span></span><span class="hljs-class">" main = putStrLn $ showInfos name color</span></span></code> </pre><br>   <code>showInfos</code>   ,   .   .     . <br><br>  ,    ‚Äî   : <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">NameConstr</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-type"><span class="hljs-type">ColorConstr</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Color</span></span></code> </pre><br><br>  <code>data</code>   : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeName</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstructorName</span></span></span><span class="hljs-class"> [types] | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstructorName2</span></span></span><span class="hljs-class"> [types] | ...</span></span></code> </pre><br>  For <br> DataTypeName  DataTypeConstructor       . <br>  For example: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Complex</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Complex</span></span></span><span class="hljs-class"> aa</span></span></code> </pre><br>     : <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataTypeName</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataConstructor</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">] , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class">] ... , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldn</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldn</span></span></span><span class="hljs-class">] }</span></span></code> </pre><br><br>         .  ,          . <br><br>  Example: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Complex</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Complex</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">real</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">img</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} c = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Complex</span></span></span><span class="hljs-class"> 1.0 2.0 z = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Complex</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">real</span></span></span><span class="hljs-class"> = 3, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">img</span></span></span><span class="hljs-class"> = 4 } real c ‚áí 1.0 img z ‚áí 4</span></span></code> </pre><br> <a href="">02_Hard_Part/ <strong>22_Types.lhs</strong></a> <br><br><hr><br> <a href="">02_Hard_Part/ <strong>23_Types.lhs</strong></a> <br><a name="recursive-type"></a><br><h4>   </h4><br><br>        ‚Äî  .     ,    : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br><br>         . <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">infixr</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> ::: data List a = Nil | a ::: (List a)</code> </pre><br>   <code>infixr</code> ‚Äî    . <br><br>     ( <code>Show</code> ),  ( <code>Read</code> ),    ( <code>Eq</code> )   ( <code>Ord</code> )    ,    Haskell-,        . <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">infixr</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> ::: data List a = Nil | a ::: (List a) deriving (Show,Read,Eq,Ord)</code> </pre><br><br>    <code>deriving (Show)</code>    , Haskell      <code>show</code> .   ,       <code>show</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">convertList</span></span> [] = <span class="hljs-type"><span class="hljs-type">Nil</span></span> convertList (x:xs) = x ::: convertList xs</code> </pre><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> print (<span class="hljs-number"><span class="hljs-number">0</span></span> ::: <span class="hljs-number"><span class="hljs-number">1</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nil</span></span>) print (convertList [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><br>  : <br><pre> <code class="haskell hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> ::: (<span class="hljs-number"><span class="hljs-number">1</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nil</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span> ::: (<span class="hljs-number"><span class="hljs-number">1</span></span> ::: <span class="hljs-type"><span class="hljs-type">Nil</span></span>)</code> </pre><br><br> <a href="">02_Hard_Part/ <strong>23_Types.lhs</strong></a> <br><br><hr><br> <a href="">02_Hard_Part/ <strong>30_Trees.lhs</strong></a> <br><br><a name="trees"></a><br><h4>  </h4><br><img src="http://habrastorage.org/storage2/036/ef5/5dd/036ef55dd4b1a72d4a2d0d224e6e52c8.jpg"><br><br>     :  . <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List data BinTree a = Empty | Node a (<span class="hljs-type"><span class="hljs-type">BinTree</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) (<span class="hljs-type"><span class="hljs-type">BinTree</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>)</code> </pre><br>   ,       . <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeFromList</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">BinTree</span></span> a treeFromList [] = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeFromList (x:xs) = <span class="hljs-type"><span class="hljs-type">Node</span></span> x (treeFromList (filter (&lt;x) xs)) (treeFromList (filter (&gt;x) xs))</code> </pre><br><br>    . <br>    : <br><br><ul><li>      . </li><li>  <code>(x:xs)</code>  ,  : <br><ul><li>   <code>x</code> </li><li>        <code>xs</code>   <code>x</code>  </li><li>        <code>xs</code>   <code>x</code> . </li></ul><br></li></ul><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = print $ treeFromList [<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre><br><br>   - : <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> (<span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span>)) (<span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span>)</code> </pre><br><br>  ,       . <br><br> <a href="">02_Hard_Part/ <strong>30_Trees.lhs</strong></a> <br><br><hr><br> <a href="">02_Hard_Part/ <strong>31_Trees.lhs</strong></a> <br><br>   ,         .       ,      .       ‚Äî    . <br><br>     . <br>   <code>deriving (Show)</code>    <code>BinTree</code> .     BinTree    ( <code>Eq</code>  <code>Ord</code> ).           . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinTree</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinTree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinTree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  <code>deriving (Show)</code> , Haskell      <code>show</code> . <br>       <code>show</code> .   ,   ,     <code>BinTree a</code> <br>     <code>Show</code> . <br>     : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinTree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> show t = ... <span class="hljs-comment"><span class="hljs-comment">--     </span></span></code> </pre><br><br>      .    ,  .        . <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--   BinTree   Show instance (Show a) =&gt; Show (BinTree a) where --     '&lt;' --   :    show t = "&lt; " ++ replace '\n' "\n: " (treeshow "" t) where -- treeshow pref Tree --        pref --       treeshow pref Empty = "" -- Leaf treeshow pref (Node x Empty Empty) = (pshow pref x) --    treeshow pref (Node x left Empty) = (pshow pref x) ++ "\n" ++ (showSon pref "`--" " " left) --    treeshow pref (Node x Empty right) = (pshow pref x) ++ "\n" ++ (showSon pref "`--" " " right) --        treeshow pref (Node x left right) = (pshow pref x) ++ "\n" ++ (showSon pref "|--" "| " left) ++ "\n" ++ (showSon pref "`--" " " right) --      showSon pref before next t = pref ++ before ++ treeshow (pref ++ next) t -- pshow  "\n"  "\n"++pref pshow pref x = replace '\n' ("\n"++pref) (show x) --    replace c new string = concatMap (change c new) string where change c new x | x == c = new | otherwise = x:[] -- "x"</span></span></code> </pre><br><br>  <code>treeFromList</code>  . <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeFromList</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">BinTree</span></span> a treeFromList [] = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeFromList (x:xs) = <span class="hljs-type"><span class="hljs-type">Node</span></span> x (treeFromList (filter (&lt;x) xs)) (treeFromList (filter (&gt;x) xs))</code> </pre><br><br>     : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"Int binary tree:"</span></span> print $ treeFromList [<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">23</span></span>]</code> </pre><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">print</span></span> $ treeFromList [<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">23</span></span>] <span class="hljs-type"><span class="hljs-type">Int</span></span> binary tree: &lt; <span class="hljs-number"><span class="hljs-number">7</span></span> : |<span class="hljs-comment"><span class="hljs-comment">--2 : | |--1 : | `--4 : | |--3 : | `--6 : `--8 : `--21 : |--12 : `--23</span></span></code> </pre><br><br>  !       <code>&lt;</code> .       <code>:</code> . <br>       . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">putStrLn</span></span> <span class="hljs-string"><span class="hljs-string">"\nString binary tree:"</span></span> print $ treeFromList [<span class="hljs-string"><span class="hljs-string">"foo"</span></span>,<span class="hljs-string"><span class="hljs-string">"bar"</span></span>,<span class="hljs-string"><span class="hljs-string">"baz"</span></span>,<span class="hljs-string"><span class="hljs-string">"gor"</span></span>,<span class="hljs-string"><span class="hljs-string">"yog"</span></span>]</code> </pre><br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">String</span></span> binary tree: &lt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span> : |<span class="hljs-comment"><span class="hljs-comment">--"bar" : | `--"baz" : `--"gor" : `--"yog"</span></span></code> </pre><br><br>            ,     ! <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">putStrLn</span></span> <span class="hljs-string"><span class="hljs-string">"\n      :"</span></span> print ( treeFromList (map treeFromList [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>,<span class="hljs-string"><span class="hljs-string">"zara"</span></span>,<span class="hljs-string"><span class="hljs-string">"bar"</span></span>]))</code> </pre><br><br><pre> <code class="haskell hljs">      : &lt; &lt; 'b' : : |<span class="hljs-comment"><span class="hljs-comment">--'a' : : `--'z' : |--&lt; 'b' : | : |--'a' : | : `--'r' : `--&lt; 'z' : : `--'a' : : `--'r'</span></span></code> </pre><br>         ( )   <code>:</code> . <br><br><img src="http://habrastorage.org/storage2/f7a/bb9/4ef/f7abb94efe490cd5a5db9ab48ff3f378.jpg"><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">putStrLn</span></span> <span class="hljs-string"><span class="hljs-string">"\nTree of Binary trees of Char binary trees:"</span></span> print $ (treeFromList . map (treeFromList . map treeFromList)) [ [<span class="hljs-string"><span class="hljs-string">"YO"</span></span>,<span class="hljs-string"><span class="hljs-string">"DAWG"</span></span>] , [<span class="hljs-string"><span class="hljs-string">"I"</span></span>,<span class="hljs-string"><span class="hljs-string">"HEARD"</span></span>] , [<span class="hljs-string"><span class="hljs-string">"I"</span></span>,<span class="hljs-string"><span class="hljs-string">"HEARD"</span></span>] , [<span class="hljs-string"><span class="hljs-string">"YOU"</span></span>,<span class="hljs-string"><span class="hljs-string">"LIKE"</span></span>,<span class="hljs-string"><span class="hljs-string">"TREES"</span></span>] ]</code> </pre><br><br>   : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">print</span></span> ( treeFromList ( map treeFromList [ map treeFromList [<span class="hljs-string"><span class="hljs-string">"YO"</span></span>,<span class="hljs-string"><span class="hljs-string">"DAWG"</span></span>] , map treeFromList [<span class="hljs-string"><span class="hljs-string">"I"</span></span>,<span class="hljs-string"><span class="hljs-string">"HEARD"</span></span>] , map treeFromList [<span class="hljs-string"><span class="hljs-string">"I"</span></span>,<span class="hljs-string"><span class="hljs-string">"HEARD"</span></span>] , map treeFromList [<span class="hljs-string"><span class="hljs-string">"YOU"</span></span>,<span class="hljs-string"><span class="hljs-string">"LIKE"</span></span>,<span class="hljs-string"><span class="hljs-string">"TREES"</span></span>] ]))</code> </pre><br>   : <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Binary</span></span> tree <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Binary</span></span> trees <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> binary trees: &lt; &lt; &lt; '<span class="hljs-type"><span class="hljs-type">Y'</span></span> : : : `<span class="hljs-comment"><span class="hljs-comment">--'O' : : `--&lt; 'D' : : : |--'A' : : : `--'W' : : : `--'G' : |--&lt; &lt; 'I' : | : `--&lt; 'H' : | : : |--'E' : | : : | `--'A' : | : : | `--'D' : | : : `--'R' : `--&lt; &lt; 'Y' : : : `--'O' : : : `--'U' : : `--&lt; 'L' : : : `--'I' : : : |--'E' : : : `--'K' : : `--&lt; 'T' : : : `--'R' : : : |--'E' : : : `--'S'</span></span></code> </pre><br>  ,    . <br>    ,  <code>"I","HEARD"</code> .     () ,    Tree  <code>Eq</code> . <br><br>       .         ,   ,      .     ,     ! <br><br><br> <a href="">02_Hard_Part/ <strong>31_Trees.lhs</strong></a> <br><br><hr><br> <a href="">02_Hard_Part/ <strong>40_Infinites_Structures.lhs</strong></a> <br><a name="infinite-structures"></a><br><h3>   </h3><br><img src="http://habrastorage.org/storage2/213/7c1/814/2137c1814b908674c5b5c7eddac11fa4.jpg"><br> Haskell   <em></em> . <br><br>   ,  <a href="http://www.haskell.org/haskellwiki/Lazy_vs._non-strict">Haskell  <em> </em> </a> .       . <br><br>    ?  Haskell-wiki: <br><br><blockquote>  (    )   . <br><br>      <code>(a+(b*c))</code> ,     <code>+</code> ,     <code>(b*c)</code> <br></blockquote><br><br>   Haskell   : <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- numbers = [1,2,..] numbers :: [Integer] numbers = 0:map (1+) numbers take' n [] = [] take' 0 l = [] take' n (x:xs) = x:take' (n-1) xs main = print $ take' 10 numbers</span></span></code> </pre><br><br>   . <br><br>  How? <br><br>  ,    <code></code> ,     . <br><br>          Haskell <br><br><pre> <code class="haskell hljs">[<span class="hljs-number"><span class="hljs-number">1.</span></span>.] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4.</span></span>..] [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3.</span></span>.] ‚áî [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">11.</span></span>..]</code> </pre><br><br>        .     <code>take</code>   <code>take'</code> . <br><br> <a href="">02_Hard_Part/ <strong>40_Infinites_Structures.lhs</strong></a> <br><br><hr><br> <a href="">02_Hard_Part/ <strong>41_Infinites_Structures.lhs</strong></a> <br><br> ,       .     : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">nullTree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> nullTree nullTree</code> </pre><br><br>        .    ,       ,   : <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--    BinTree --      treeTakeDepth _ Empty = Empty treeTakeDepth 0 _ = Empty treeTakeDepth n (Node x left right) = let nl = treeTakeDepth (n-1) left nr = treeTakeDepth (n-1) right in Node x nl nr</span></span></code> </pre><br><br>  ,    : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = print $ treeTakeDepth <span class="hljs-number"><span class="hljs-number">4</span></span> nullTree</code> </pre><br><br>   , ,     : <br><pre> <code class="haskell hljs">&lt; <span class="hljs-number"><span class="hljs-number">0</span></span> : |<span class="hljs-comment"><span class="hljs-comment">-- 0 : | |-- 0 : | | |-- 0 : | | `-- 0 : | `-- 0 : | |-- 0 : | `-- 0 : `-- 0 : |-- 0 : | |-- 0 : | `-- 0 : `-- 0 : |-- 0 : `-- 0</span></span></code> </pre><br>    ,    : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">iTree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> (dec iTree) (inc iTree) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dec (<span class="hljs-type"><span class="hljs-type">Node</span></span> xlr) = <span class="hljs-type"><span class="hljs-type">Node</span></span> (x<span class="hljs-number"><span class="hljs-number">-1</span></span>) (dec l) (dec r) inc (<span class="hljs-type"><span class="hljs-type">Node</span></span> xlr) = <span class="hljs-type"><span class="hljs-type">Node</span></span> (x+<span class="hljs-number"><span class="hljs-number">1</span></span>) (inc l) (inc r)</code> </pre><br>         . <br>     <code>map</code> ,     <code>BinTree</code>  . <br>       : <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--      Tree treeMap :: (a -&gt; b) -&gt; BinTree a -&gt; BinTree b treeMap f Empty = Empty treeMap f (Node x left right) = Node (fx) (treeMap f left) (treeMap f right)</span></span></code> </pre><br><br> <em></em> :        .      <code>map</code>    ,     functor()  <code>fmap</code> . <br><br>  : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">infTreeTwo</span></span> :: <span class="hljs-type"><span class="hljs-type">BinTree</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> infTreeTwo = <span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> (treeMap (\x -&gt; x<span class="hljs-number"><span class="hljs-number">-1</span></span>) infTreeTwo) (treeMap (\x -&gt; x+<span class="hljs-number"><span class="hljs-number">1</span></span>) infTreeTwo)</code> </pre><br>    <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = print $ treeTakeDepth <span class="hljs-number"><span class="hljs-number">4</span></span> infTreeTwo</code> </pre><br><br><pre> <code class="haskell hljs">&lt; <span class="hljs-number"><span class="hljs-number">0</span></span> : |<span class="hljs-comment"><span class="hljs-comment">-- -1 : | |-- -2 : | | |-- -3 : | | `-- -1 : | `-- 0 : | |-- -1 : | `-- 1 : `-- 1 : |-- 0 : | |-- -1 : | `-- 1 : `-- 2 : |-- 1 : `-- 3</span></span></code> </pre><br><br> <a href="">02_Hard_Part/ <strong>41_Infinites_Structures.lhs</strong></a> </div><p>Source: <a href="https://habr.com/ru/post/152889/">https://habr.com/ru/post/152889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152873/index.html">Node.js on the Fidonet node: automating recurring publications</a></li>
<li><a href="../152875/index.html">HP ENVY 14 SPECTER Ultrabook Video Review</a></li>
<li><a href="../152883/index.html">Small format niche</a></li>
<li><a href="../152885/index.html">Restore defocused and blurred images. Increase quality</a></li>
<li><a href="../152887/index.html">15 years ago the world saw Fallout</a></li>
<li><a href="../152895/index.html">Release the first version!</a></li>
<li><a href="../152897/index.html">NEC EA273WM - very angry 27 inches</a></li>
<li><a href="../152899/index.html">Spy in your pocket</a></li>
<li><a href="../152903/index.html">CRIU 0.2 and Linux Containers - new features</a></li>
<li><a href="../152907/index.html">Free ASN.1: 2008 compliance test suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>