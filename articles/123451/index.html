<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gearman - distribution framework for tasks, introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to consider one of the unusual ways to optimize the application, namely using the Gearman project for task distribution....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gearman - distribution framework for tasks, introduction</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/a83f1fe1/bf3fb3cb/c6825a17/1a8d1610.gif"><br><br>  In this article, I would like to consider one of the unusual ways to optimize the application, namely using the Gearman project for task distribution.  Gearman is a framework for building such systems.  There are no examples of code in the article, the article is more introductory, although it contains enough practical information. <br><a name="habracut"></a><br>  In any project that is rather complicated in terms of functionality and loading, sooner or later the question of optimization and scalability arises.  There are many approaches to solving this complex of tasks, ranging from the banal increase in the computing power of the entire system or especially its loaded parts, to complex solutions in the form of specialized software and hardware systems.  Combining these solutions is not only the goal - faster, higher, stronger, but also the approach to solving them - finding and identifying weak points.  Often, bottleneck is a resource-intensive task associated with the processing of graphic information, encryption, archiving, heavy database queries, processing and / or returning a large amount of information. <br><br>  Gearman is an open source project that was developed by guys from Danga Interactive.  The name is nothing more than an anagram for the word manager, and it is the role of the manager that is a brief description of the functionality of this application - management, control, and distribution of various tasks.  Originally gearman was implemented in Perl, but over time it was rewritten in C using the <a href="http://monkey.org/~provos/libevent/">libevent</a> library, the presence of which is necessary for the operation of the main part - the task server.  Installation for any * nix system is not a big deal, and in most linux distributions the gearman package is included in the standard repository. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here it is worth explaining why the author used the word ‚Äúframework‚Äù in the title of this article.  The fact is that the use of a gearman, although relatively simple, at the same time, an effective solution of the task will require quite serious development - this is not a ready-made solution. <br><br>  An application that uses Gearman in its work works with 3 main components: <br><ul><li>  task server is a central part of Gearman, it is here that tasks and results from clients and performers will come, and it is from here that tasks and results will be sent to performers and clients, respectively. </li><li>  Executive - is the main part where the implementation of any functionality is necessary.  The contractor accepts and tries to perform the task from the server. </li><li>  the client is also implemented separately, creates and sends the task to the server and, in some cases (about them later), gets the result. </li></ul><br>  The client and the performer use the Gearman API to call and implement the necessary functions.  A diagram that illustrates the above architecture is shown on the main project site: <br><br><img src="http://gearman.org/images/gearman_stack.png" alt="image"><br><br>  Consider a classic example of how such a system works - the user uploaded a photo to the site, and wants to show it to all his friends.  It is necessary to quickly prepare the various sizes of this photograph, for use throughout the site.  Yes, until a certain moment all the work on graphics generation can be carried out in the main system code, and then the habra effect will come, and the whole system will collapse under the influx of applicants.  Now we will consider how this task can be solved using Gearman - when we receive a photo, we create a task for the gearman server, which includes the necessary information about the photo (in principle, it is possible to include even the photo itself in the task, but it seems to me that it will be expensive use the address) and send it to the execution.  The task server selects (round robin) a free performer (as you probably already guessed, there may be several executors) and sends the task for execution.  The contractor receives all the necessary information, processes it as we would like it to - and sends the answer about the successfully completed task and, if the task was synchronous, the result of the work.  Yes, there are two types of tasks - synchronous, when the client waits for the sent task, and accordingly the result, and asynchronous, when the client acts only as the initiator of the task.  Now we add here the fact that the communication protocol between the parts of the gearman application is TCP / IP, that is, it is assumed that each part (server, client, performer) can be located on a separate machine.  Servers and clients can be several.  The client and artist implementations are independent of each other (the available languages ‚Äã‚Äãin which the API is implemented to work with gearman include perl, php, python, java, C, MySQL UDF, etc.).  The project is actively developing - new versions with bug fixes and improvements are released every month.  At the exit, we get a rather rosy picture, where the range of tasks is limited only by the imagination and experience of the developer.  For example, a few common tasks that were successfully solved and solved using the gearman: <br><ul><li>  the above task with processing photos, and you should not be limited only to the generation of various sizes </li><li>  asynchronous invalidation / update in the cache, without the use of crones and delays from the client </li><li>  archiving large amounts of data </li><li>  working with data in the format - (key =&gt; value), using encryption on the side of the contractor </li></ul><br>  Now for some practical information.  The main object of work in gearman is the task - task, which consists of the type (synchronous, asynchronous), the name of the task (for example, resize), and the parameters - workload.  Each task is identified by a name / parameters pair.  That is, if the server receives two identical tasks with the same parameters, only the first will be executed, the second server will drop.  Because of this nuance, a lot of interesting things happen, so you should always remember - is it necessary to perform a specific task for one hundred percent?  - add a unique value to the parameters. <br><br>  The server is a daemon process.  It has a lot of configuration parameters, along with the standard user-port-interface settings for such applications, there are also several specific options.  The number of attempts to perform the task is configured with the -j, --job-retries = parameter.  To use multiple threads, there is a parameter -t, --threads =.  The server has the ability to save the queue of tasks in any storage, so that when restarting it was possible to restore the entire process without losing data.  MySQL / drizzle, memcached, PostgreSQL or sqllite can serve as storage.  More than interesting is the option of using third-party protocols in the client -&gt; task server communication process.  The only such protocol implemented at the moment is HTTP.  With this option, you can configure the gearman server to receive tasks on a specific port via an HTTP request (requested uri is translated to the task name, http body to workload, http headers respectively to the task type), that is, the client implementation is reduced to the implementation of a simple HTTP client on the caller.  It does not impose any restrictions on the type / size of the task.  Read more about using HTTP in gearman <a href="http://gearman.org/index.php%3Fid%3Dmanual:job_server">here</a> .  Using the HTTP protocol and Gearman, building efficiently balanced REST services can be as easy as ever.  You can create tasks for gearman from virtually any programming language, since the wrappers for API function calls are written for most environments. <br><br>  The performing part is accordingly in the so-called performer.  Here the choice of means of implementation is also very extensive, ranging from standard php, python, java and ending with user functions in mysql.  The only condition is the presence of support for the gearman library, which may require additional compilation of any modules.  The so-called worker (worker) is a background process, after starting it registers all the tasks that it can perform and, while in memory, waits for tasks from the server.  The number of servers with which a particular artist keeps in touch is unlimited. <br><br>  Let's talk about the shortcomings, there are several of them, and they are of varying degrees of seriousness.  Since the executor is a long-lived process, any change in its functionality implies a process of restarting the executor himself, the same applies to adding / deleting tasks that this performer can perform.  That is, if you need to add a new function, or change an existing one, you need to restart all the processes of the performers that are associated with the implementation of this task.  This process, when executors are scattered across different servers, in different quantities, is not trivial.  And not all languages ‚Äã‚Äãare designed to write effective demon processes. <br><br>  The distribution of tasks by the server takes place only in one single algorithm - round robin.  Yes, there are tasks with two levels of priority - high and low.  But more precise control over the execution of tasks is not available.  Moreover, it is impossible to know exactly which of the executors will perform the task, and it is also impossible to indicate directly to which node to send it, which greatly complicates the debugging process. <br><br>  From the shortcomings described above, the main one follows - the absence of imputed means of managing the implemented system.  Everything has to be done manually, and all the time keep in mind the structure of the gearman application. <br><br>  Of course, for all the problems described there are solutions, the implementation of which I will try to write in the next article. <br><br>  Now a few links to sources of information and other interesting things about Gearman: <br><ul><li>  proper main site: <a href="http://gearman.org/">gearman.org</a> </li><li>  project page on launchpad: <a href="https://launchpad.net/gearmand/">launchpad.net/gearmand</a> </li><li>  google discussion groups: <a href="http://groups.google.com/group/gearman/topics">groups.google.com/group/gearman/topics</a> </li><li> examples of use in PHP: <a href="http://highload.com.ua/index.php/2010/07/09/gearman-%25D0%25B8-php-%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B5-%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B8/">http://highload.com.ua/</a> </li><li>  Gearman Server Startup Service: <a href="http://gearmanhq.com/">gearmanhq.com</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/123451/">https://habr.com/ru/post/123451/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123444/index.html">Attempt to change the model of cinema monetization - the film "A Lonely Place For Dying"</a></li>
<li><a href="../123445/index.html">Craftsman added another display to the Nexus One</a></li>
<li><a href="../123446/index.html">MS SQL 2011 - New Sequence Object</a></li>
<li><a href="../123447/index.html">Mobile Saturday is now in Odessa!</a></li>
<li><a href="../123448/index.html">metabus - a platform for building thematic search engines</a></li>
<li><a href="../123452/index.html">Pitfalls when working with php-handlersocket</a></li>
<li><a href="../123453/index.html">Do-it-yourself textile printer with minimum cost</a></li>
<li><a href="../123455/index.html">"Store domains" from REG.RU as an alternative to auctions</a></li>
<li><a href="../123456/index.html">The sixth meeting of Apple-developers in St. Petersburg</a></li>
<li><a href="../123457/index.html">We place the files from Assets to the SD card using Infles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>