<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bubble sort and all-all-all</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone knows that the fastest method from the exchange sorting class is the so-called quick sorting . About her write a thesis, it is devoted to man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bubble sort and all-all-all</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/post/204600/"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/44f/067/b77/44f067b77941ac6ebf9acaf03658b819.jpg"></a> <br clear="left">  Everyone knows that the fastest method from the exchange sorting class is the so-called <strong>quick sorting</strong> .  About her write a thesis, it is devoted to many articles on Habr√©, based on it come up with complex hybrid algorithms.  But today we are not talking about <strong>quick sort</strong> , but about another exchange method - the good old <strong>bubble sort</strong> and its improvements, modifications, mutations and varieties. <br><br>  Practical exhaust from these methods is not so hot, and many habrausers passed all this in the first grade.  Therefore, the article is addressed to those who are just interested in the theory of algorithms and take the first steps in this direction. <br><br>  <em>image: bubbles</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  Today we will talk about the simplest <strong>sorting exchanges</strong> . <br><br>  If anyone is interested, I will say that there are other classes - <em>sorting by choice</em> , <em>sorting by inserts</em> , <em>merge sorting</em> , <em>distribution sorting</em> , <em>hybrid sorting</em> and <em>parallel sorting</em> .  There are, by the way, more <em>esoteric sorting</em> .  These are various fake, basically unrealizable, comic, and other pseudo-algorithms, about which I will write a couple of articles in the IT-Humor hub sometime. <br><br>  But this has nothing to do with today's lecture, we are now only interested in simple sorting exchanges.  There are also quite a few sortings of exchanges (I know more than a dozen), so we will look at the so-called <strong>bubble sort</strong> and some others that are closely interrelated with it. <br><br>  I will warn you in advance that almost all the above methods are very slow and there will not be a deep analysis of their time complexity.  Some faster, some slower, but, roughly speaking, we can say that on average <strong>O</strong> ( <strong>n <sup>2</sup></strong> ).  Also, I do not see any reason to clutter an article with implementations in any programming languages.  Those who are interested can easily find code examples on <a href="http://rosettacode.org/wiki/Category:Sorting_Algorithms">Rosetta</a> , on <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">Wikipedia</a> or anywhere else. <br><br>  But back to the sorting exchanges.  Ordering occurs as a result of multiple sequential brute force and comparison of pairs of elements among themselves.  If the compared elements are not sorted relative to each other - then swap them.  The only question is how exactly Makar array to bypass and on what principle to choose pairs for comparison. <br><br>  Let's start not with the reference bubble sort, but with an algorithm called ... <br><br><h1>  Stupid sorting </h1><br>  Sorting really stupid.  We look through the array from left to right and compare the neighbors along the way.  If we meet a pair of mutually unsorted items, then we change them in places and return to their own place, that is, to the very beginning.  Passing through the array again, if we meet again the ‚Äúwrong‚Äù pair of neighboring elements, we switch places and start all over again.  We continue until the array is slowly sortedly sorted. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7ae/81a/1aa/7ae81a1aa491bd3514e5dabdc68028ae.gif"></a> <br><br>  ‚ÄúSo any fool can sort‚Äù - you will say and you will be absolutely right.  That is why sorting and nicknamed "stupid."  In this lecture, we will consistently improve and modify this method.  Now he has the time complexity <strong>O</strong> ( <strong>n <sup>3</sup></strong> ), making one correction, we will bring it to <strong>O</strong> ( <strong>n <sup>2</sup></strong> ), then we will accelerate a little more, then another, and in the end we will get <strong>O</strong> ( <strong>n</strong> log <strong>n</strong> ) - and it will be Not "Quick Sort"! <br><br>  Let's make a single improvement to the stupid sorting.  Having found two neighboring unsorted elements during the passage and swapping them, we will not roll back to the beginning of the array, but calmly continue its detour to the very end. <br><br>  In this case, we have nothing more than everyone knows ... <br><br><h1>  Bubble Sort </h1><br>  Or <strong>sorting by simple exchanges</strong> .  Immortal classics of the genre.  The procedure is simple: we go around the array from the beginning to the end, changing the unsorted adjacent elements along the way.  As a result of the first pass, the maximum element ‚Äúpops up‚Äù to the last place.  Now we go around the unsorted part of the array (from the first element to the penultimate one) and change the unsorted neighbors along the way.  The second largest element will be in the penultimate place.  Continuing in the same vein, we will bypass the ever decreasing unsorted part of the array, stuffing the found maxima to the end. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/187/5a3/929/1875a3929dd14c8ea5ff4ccc3d0db9bd.gif"></a> <br><br>  If not only pushing highs at the end, but also throwing lows at the beginning, then we get ... <br><br><h1>  Shaker sorting </h1><br>  It is <strong>sorting by mixing</strong> , it is also <strong>cocktail sorting</strong> .  The process begins as in a ‚Äúbubble‚Äù: squeezing the maximum to the backyard.  After that, we turn around to 180 <sup>0</sup> and go in the opposite direction, while already rolling at the beginning not the maximum, but the minimum.  Sorting the first and the last elements in the array, again do somersault.  After going round and round several times, we end up with the process, being in the middle of the list. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2a9/ad7/855/2a9ad78556f13396ebc68cb4ac21e91c.gif"></a> <br><br>  Shaker sorting is slightly faster than bubble sorting, since maxima and minima alternately migrate through the array in the right directions.  Improvements, as they say, are obvious. <br><br>  As you can see, if the brute force process is approached creatively, then pushing out heavy (light) elements to the ends of the array occurs faster.  Therefore, the craftsmen offered to bypass the list another non-standard "road map". <br><br><h1>  Even-odd sort </h1><br>  This time we will not go back and forth through the array, but again we will return to the idea of ‚Äã‚Äãa systematic detour from left to right, but just take a wider step.  On the first pass, elements with an odd key are compared with neighbors based on even places (1st is compared with 2nd, then 3rd with 4th, 5th with 6th and so on).  Then, on the contrary, the ‚Äúeven in a row‚Äù elements are compared / changed to the ‚Äúodd‚Äù ones.  Then again ‚Äúodd-odd‚Äù, then again ‚Äúeven-odd‚Äù.  The process stops when, after a successive two passes through the array (‚Äúodd-even‚Äù and ‚Äúeven-odd‚Äù), not a single exchange occurred.  So sorted. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d33/1e9/04f/d331e904f8681df245877c460ae6e6a8.gif"></a> <br><br>  In the usual ‚Äúbubble‚Äù during each pass, we systematically squeeze the current maximum into the end of the array.  If, however, to jump around on even and odd indices, then at once all more or less large elements of the array simultaneously for one run are pushed to the right by one position.  So it turns out faster. <br><br>  Let's <em>sort out the</em> last <em>painting</em> * for <em>Sortuvannya Bulbachka</em> ** - <em>Sortuvane by combinants</em> ***.  This method organizes very quickly, <strong>O</strong> ( <strong>n <sup>2</sup></strong> ) - its worst complexity.  On average, we have <strong>O</strong> ( <strong>n</strong> log <strong>n</strong> ) in time, and the best one even does not believe it, <strong>O</strong> ( <strong>n</strong> ).  That is, a very worthy competitor to every sort of ‚Äúquick sorting‚Äù and note this without using recursion.  However, I promised that today we will not go into cruising speeds, we stop talking and turn directly to the algorithm. <br><br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/59c/a5b/da3/59ca5bda3412f309d81ee7a6a39fd9d3.jpg"><br clear="right"><h1>  Turtles are to blame </h1><br>  A little background.  In 1980, Wlodzimierz Dobosiyevich explained why bubble sorts and derivatives derived from it work so slowly.  <em>This is all because of the turtles</em> .  ‚ÄúTurtles‚Äù are small items that are at the bottom of the list.  As you may have noticed, bubble sorts are focused on ‚Äúrabbits‚Äù (not to be confused with Babushkin's ‚Äúrabbits‚Äù), which are large in value at the top of the list.  They are very briskly moving to the finish line.  But slow reptiles at the start crawling reluctantly.  You can customize the "tortilla" using a <em>comb</em> . <br><br>  <em>image: guilty bug</em> <br><br><h1>  Hairbrush sorting </h1><br>  In the "bubble", "shaker" and "even-odd" when searching an array, adjacent elements are compared.  The basic idea of ‚Äã‚Äãcombing is initially to take a sufficiently large distance between the compared elements and, as the array is ordered, to narrow this distance down to the minimum.  Thus, we kind of comb the array, gradually smoothing it into neater strands. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/15b/1bb/37e/15b1bb37e7d06fc9d2ccd8adb34b8980.gif"></a> <br><br>  The initial gap between the compared elements is better to take, not anyhow, but with the special value called the <strong>reduction factor</strong> , the optimal value of which is approximately 1.247.  First, the distance between the elements is equal to the size of the array divided by <strong>the reduction factor</strong> (the result, of course, is rounded to the nearest integer).  Then, having passed an array with this step, we again divide the step by <strong>the reduction factor</strong> and go through the list again.  This continues until the index difference reaches unity.  In this case, the array is sorted by the usual bubble. <br><br>  Experimentally and theoretically, the optimal value <strong>of the reduction factor is</strong> established: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd3/e3f/b96/fd3e3fb960d4f3f61d63bfb61a656d36.png"><br><br>  When this method was invented, very few people paid attention to it at the junction of the 70s and 80s.  A decade later, when programming ceased to be the lot of IBM scientists and engineers, and already gained mass avalanche-like character, the method was rediscovered, researched and popularized in 1991 by Stephen Lacey and Richard Box. <br><br>  That's all I wanted to tell you about bubble sorting and their ilk. <br><br>  <em>- Notes</em> <br><br>  * pokraschennya ( <em>ukr.</em> ) - improvement <br>  ** Sorbuvannya Bulbaska ( <em>ukr.</em> ) - Sort by bubble <br>  *** Sorting comb ( <em>ukr.</em> ) - Sort by comb </div><p>Source: <a href="https://habr.com/ru/post/204600/">https://habr.com/ru/post/204600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204588/index.html">Swiss scientists taught quadrocopter to stay on the fly after losing rotor</a></li>
<li><a href="../204590/index.html">Meet: IntelliJ IDEA 13</a></li>
<li><a href="../204594/index.html">Flat and thin</a></li>
<li><a href="../204596/index.html">Real-time event handling with SynapseGrid</a></li>
<li><a href="../204598/index.html">Enyo 2. OOP</a></li>
<li><a href="../204602/index.html">Looking for a virtual keyboard or ‚ÄúInternet of Things‚Äù at your fingertip</a></li>
<li><a href="../204604/index.html">VmWare patch for linux 3.13</a></li>
<li><a href="../204610/index.html">Backup: success stories or how I survived OCZ Vertex 2</a></li>
<li><a href="../204612/index.html">Design and design of applications for Windows: look online today at 10:00 (MSK)</a></li>
<li><a href="../204614/index.html">Happy 3D and other graphics!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>