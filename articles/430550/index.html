<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Build a system of reactive components using Kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Anatoly Varivonchik, I'm an Android developer for Badoo. Today I will share with you the translation of the second part of the artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Build a system of reactive components using Kotlin</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/9w/km/zp/9wkmzp6x1umysciwpqgvzuplf7y.png"><br><br>  Hello!  My name is Anatoly Varivonchik, I'm an Android developer for Badoo.  Today I will share with you the translation of the second part of the article by my colleague Zsolt Kocsi on the implementation of MVI, which we use daily in the development process.  The first part is <a href="https://habr.com/company/badoo/blog/429728/">here</a> . <br><br><h2>  What we want and how we will do it </h2><br>  In the first part of the article, we became acquainted with <b>Features</b> , the central elements of <a href="https://github.com/badoo/MVICore">MVICore</a> that can be reused.  They can have the simplest structure and include just one <b>Reducer</b> , and can become a full-featured tool for managing asynchronous tasks, events, and many others. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each Feature is traceable - it is possible to subscribe to changes in its state and receive notifications about it.  In this feature, you can subscribe to the input source.  And this makes sense, because with the inclusion of Rx in the code base, we already have many observable objects and subscriptions at various levels. <br><br>  It is precisely in connection with the increase in the number of reactive components that the time has come to reflect on what we have and whether it is possible to make the system even better. <br><a name="habracut"></a><br>  We have to answer three questions: <br><br><ol><li>  What elements should be used when adding new reactive components? <br></li><li>  What is the easiest way to manage subscriptions? <br></li><li>  Is it possible to abstract from lifecycle management / the need to clear subscriptions to avoid memory leaks?  In other words, can we separate the binding of components from subscription management? <br></li></ol><br>  In this part of the article we will look at the basics and advantages of building a system with the help of reactive components and see how Kotlin helps in this. <br><br><h2>  Main elements </h2><br>  By the time we came to work on the design and standardization of our <b>Features</b> , we had already tried many different approaches and decided that the <b>Features</b> would be in the form of reactive components.  At first we focused on the main interfaces.  First of all, we had to decide on the types of input and output data. <br><br>  We reasoned as follows: <br><br><ul><li>  Let's not reinvent the wheel - let's see which interfaces already exist. <br></li><li>  Since we are already using the RxJava library, it makes sense to refer to its basic interfaces. <br></li><li>  The number of interfaces should be kept to a minimum. <br></li></ul><br>  As a result, we decided to use <b>ObservableSource &lt;T&gt;</b> for output and <b>Consumer &lt;T&gt;</b> for input.  Why not <b>Observable / Observer</b> , you ask.  <b>Observable</b> is an abstract class from which you need to inherit, and <b>ObservableSource</b> is an interface you are implementing that fully satisfies the need for implementing a reactive protocol. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.reactivex; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.reactivex.annotations.*; <span class="hljs-comment"><span class="hljs-comment">/** * Represents a basic, non-backpressured {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observable} source base interface, * consumable via an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observer}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the element type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 2.0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Subscribes the given Observer to this ObservableSource instance. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> observer the Observer, not null * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> NullPointerException if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> observer} is null */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span>; }</code> </pre> <br>  <b>Observer</b> , the first interface that comes to mind, implements four methods: onSubscribe, onNext, onError, and onComplete.  In an effort to simplify the protocol as much as possible, we chose <b>Consumer &lt;T&gt;</b> , which accepts new elements using a single method.  If we chose <b>Observer</b> , the remaining methods would most often be redundant or would work differently (for example, we would like to present errors as part of the state ( <b>State</b> ), and not as exceptions, and certainly not interrupt the flow). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A functional interface (callback) that accepts a single value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the value type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Consume the given value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> t the value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception on error */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br>  So, we have two interfaces, each of which contains one method.  Now we can link them by signing the <b>Consumer &lt;T&gt;</b> on the <b>ObservableSource &lt;T&gt;</b> .  The latter accepts only <b>Observer &lt;T&gt;</b> instances, but we can wrap it in <b>Observable &lt;T&gt;</b> , which is subscribed to <b>Consumer &lt;T&gt;</b> : <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;String&gt; = Observable.just(<span class="hljs-string"><span class="hljs-string">"item1"</span></span>, <span class="hljs-string"><span class="hljs-string">"item2"</span></span>, <span class="hljs-string"><span class="hljs-string">"item3"</span></span>) val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(output).subscribe(input)</code> </pre> <br>  (Fortunately, the <i>.wrap (output)</i> function does not create a new object if <i>output is</i> already an <b>Observable &lt;T&gt;</b> ). <br><br>  You may remember that the <b>Feature</b> component from the first part of the article used input data of the type <b>Wish</b> (corresponds to the Intent from Model-View-Intent) and output data of the <b>State</b> type, and therefore it can be on both sides of the bundle: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Wishes -&gt; Feature val wishes: ObservableSource&lt;Wish&gt; = Observable.just(Wish.SomeWish) val feature: Consumer&lt;Wish&gt; = SomeFeature() val disposable = Observable.wrap(wishes).subscribe(feature) // Feature -&gt; State consumer val feature: ObservableSource&lt;State&gt; = SomeFeature() val logger: Consumer&lt;State&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(feature).subscribe(logger)</span></span></code> </pre> <br>  Such a linking between <i>Consumer</i> and <i>Producer</i> already looks simple enough, but there is an even easier way in which you do not need to create subscriptions manually or cancel them. <br><br>  Introducing <b>Binder</b> . <br><br><h2>  Steroid Binding </h2><br>  <a href="https://github.com/badoo/MVICore">MVICore</a> contains a class called <b>Binder</b> , which provides a simple API for managing Rx subscriptions and has a number of cool features. <br><br>  Why is it needed? <br><br><ul><li>  Creating a binding by subscribing input data for the weekend. <br></li><li>  Ability to unsubscribe at the end of the life cycle (when it is an abstract concept and has no relation to Android). <br></li><li>  Bonus: <b>Binder</b> allows you to add intermediate objects, for example, for logging or time-travel-debugging. <br></li></ul><br>  Instead of manually subscribing, you can rewrite the examples above as follows: <br><br><pre> <code class="java hljs">val binder = Binder() binder.bind(wishes to feature) binder.bind(feature to logger)</code> </pre> <br>  Thanks to Kotlin, everything looks very simple. <br><br>  These examples work if the input and output data types are the same.  But what if it is not?  By implementing the expansion function, we can make the transformation automatic: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;A&gt; = TODO() val input: Consumer&lt;B&gt; = TODO() val transformer: (A) -&gt; B = TODO() binder.bind(output to input using transformer)</code> </pre> <br>  Pay attention to the syntax: it reads almost like a regular sentence (and this is another reason why I love Kotlin).  But <b>binder</b> is not only used as syntactic sugar - it is also useful to us for solving problems with the life cycle. <br><br><h2>  Create Binder </h2><br>  Creating an instance looks easier than ever: <br><br><pre> <code class="java hljs">val binder = Binder()</code> </pre> <br>  But in this case, you need to unsubscribe manually, and you will have to call <code>binder.dispose()</code> whenever you need to remove subscriptions.  There is another way: to introduce a life cycle instance into the constructor.  Like this: <br><br><pre> <code class="java hljs">val binder = Binder(lifecycle)</code> </pre> <br>  Now you do not need to worry about subscriptions - they will be deleted at the end of the life cycle.  At the same time, the life cycle can be repeated many times (like, for example, the start and stop cycle in the Android UI) - and <b>Binder</b> will create and delete subscriptions for you every time. <br><br><h2>  What is the life cycle? </h2><br>  Most Android developers, seeing the phrase "life cycle", represent the cycle Activity and Fragment.  Yes, <b>Binder</b> can work with them, unsubscribing at the end of the cycle. <br><br>  But this is only the beginning, because you will not use the Android interface <b>LifecycleOwner</b> - the <b>Binder</b> has its own, more universal.  It is essentially a BEGIN / END signal flow: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ BEGIN, END } <span class="hljs-comment"><span class="hljs-comment">// Remainder omitted }</span></span></code> </pre><br>  You can either implement this stream using Observable (by mapping), or simply use the <b>ManualLifecycle</b> class from the library for non-Rx environments (as you see below). <br><br>  How does the <b>binder work</b> ?  Receiving a BEGIN signal, it creates subscriptions for components previously configured by you ( <i>input / output</i> ), and receiving an END signal, deletes them.  The most interesting thing is that you can start all over again: <br><br><pre> <code class="java hljs">val output: PublishSubject&lt;String&gt; = PublishSubject.create() val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val lifecycle = ManualLifecycle() val binder = Binder(lifecycle) binder.bind(output to input) output.onNext(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"3"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"4"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"5"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"6"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"7"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// will print: // 2 // 3 // 5 // 6</span></span></code> </pre> <br>  This flexibility in reassigning subscriptions is especially useful when working with Android, when there can be several Start-Stop and Resume-Pause cycles at once, besides the usual Create-Destroy. <br><br><h2>  Android Binder Life Cycles </h2><br>  The library has three classes: <br><br><ul><li>  <b>CreateDestroyBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>StartStopBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>ResumePauseBinderLifecycl</b> e ( <i>androidLifecycle</i> ) <br></li></ul><br>  <code>androidLifecycle</code> is the value returned by the <code>getLifecycle()</code> method, that is, <b>AppCompatActivity</b> , <b>AppCompatDialogFragment</b> , etc. Everything is very simple: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBinderForActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: AppCompatActivity)</span></span></span><span class="hljs-function"> </span></span>= Binder(   CreateDestroyBinderLifecycle(activity.lifecycle) )</code> </pre> <br><h2>  Individual life cycles </h2><br>  Let's not dwell on this, because we are in no way attached to Android.  What is a life cycle <b>binder</b> ?  Literally anything: for example, the playing time of a dialog or the execution time of an asynchronous task.  You can, say, bind it to the scope of the DI - and then any subscription will be deleted along with it.  Full freedom of action. <br><br><ol><li>  Want to keep your subscriptions before the <b>Observable</b> sends an item?  Convert this object to <b>Lifecycle</b> and transfer it to <b>Binder</b> .  Implement the following code in the <i>extension-</i> function and use it further: <br><br><pre> <code class="java hljs">fun Observable&lt;T&gt;.toBinderLifecycle() = Lifecycle.wrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   .first()   .map { END }   .startWith(BEGIN) )</code> </pre></li><li>  Want your bindings to persist until <b>Completable is</b> finished?  No problems - this is done by analogy with the previous paragraph: <br><br><pre> <code class="java hljs">fun Completable.toBinderLifecycle() = Lifecycle.wrap(   Observable.concat(       Observable.just(BEGIN),       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.andThen(Observable.just(END))   ) )</code> </pre> </li><li>  Want some other non-Rx code to decide when to delete subscriptions?  Use <b>ManualLifecycle</b> as described above. <br></li></ol><br>  In any case, you can either lay the jet stream to the <b>Lifecycle.Event</b> element stream, or use the <b>ManualLifecycle</b> if you are working with non-Rx code. <br><br><h2>  System overview </h2><br>  <b>Binder</b> hides the details of creating and managing Rx subscriptions.  All that remains is a concise, generalized review: ‚ÄúComponent A interacts with component B in scope C‚Äù. <br><br>  Suppose we have the following reactive components for the current screen: <br><br><img src="https://habrastorage.org/webt/qu/gn/go/qugngoe-ishhqmff4kd--vlip7m.png"><br><br>  We would like the components to be linked within the current screen, and know that: <br><br><ul><li>  UIEvent can be ‚Äúfed‚Äù directly to <b>AnalyticsTracker</b> ; <br></li><li>  UIEvent can be transformed into <b>Wish</b> for <b>Feature</b> ; <br></li><li>  <b>State</b> can be transformed into a <b>ViewModel</b> for <b>View</b> . <br></li></ul><br>  This can be expressed in a couple of lines: <br><br><pre> <code class="java hljs">with(binder) {   bind(feature to view using stateToViewModelTransformer)   bind(view to feature using uiEventToWishTransformer)   bind(view to analyticsTracker) }</code> </pre> <br>  We make such husks to demonstrate the interconnection of components.  And since we, the developers, spend more time reading the code than writing it, such a brief overview is extremely useful, especially as the number of components increases. <br><br><h2>  Conclusion </h2><br>  We saw how <b>Binder</b> helps in managing Rx subscriptions and how it helps to get an overview of the system built from reactive components. <br><br>  In the following articles, we will describe how we separate reactive UI components from business logic and how to add intermediate objects using <b>Binder</b> (for logging and time travel debugging).  Do not switch! <br><br>  In the meantime, get acquainted with the library on <a href="https://github.com/badoo/MVICore">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/430550/">https://habr.com/ru/post/430550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430536/index.html">Designing window functions that sum up to a unit with a given level of overlap</a></li>
<li><a href="../430538/index.html">Do you read Scaladoc for ‚Äúobvious‚Äù collection methods? Or why laziness is not always good.</a></li>
<li><a href="../430542/index.html">Open webinar "Infrastructure as a code"</a></li>
<li><a href="../430546/index.html">"It was believed that the code will replace the UML-diagrams, and it will not be necessary to test": an interview with Alexey Barantsev</a></li>
<li><a href="../430548/index.html">Interrupts from external devices in the x86 system. Part 1. The evolution of interrupt controllers</a></li>
<li><a href="../430552/index.html">Startup of the day (September-October 2018)</a></li>
<li><a href="../430554/index.html">Google patented VR-shoes in which you can walk forever</a></li>
<li><a href="../430556/index.html">GeekBrains Launches Product Management Training Course</a></li>
<li><a href="../430558/index.html">How scoring works in the car sharing industry. Part 1. Overview of popular tools on real data</a></li>
<li><a href="../430560/index.html">Frontend, algorithms and possum. Parse the tasks of the Yandex contest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>