<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript style elements</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In 1920, the book by William Stranka Jr. "Elements of Style" was published. Recommendations from it concerning the English language are still relevant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript style elements</h1><div class="post__text post__text-html js-mediator-article">  In 1920, the <a href="https://www.amazon.com/Elements-Style-Fourth-William-Strunk/dp/020530902X/ref%3Das_li_ss_tl%3Fie%3DUTF8%26qid%3D1493260884%26sr%3D8-1%26keywords%3Dthe%2Belements%2Bof%2Bstyle%26linkCode%3Dll1%26tag%3Deejs-20%26linkId%3Df7eb0eacba0eab243899626551113119">book by</a> William Stranka Jr. "Elements of Style" was published.  Recommendations from it concerning the English language are still relevant today.  The same principles applied to the code, can improve the quality of programs. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/329152/"><img src="https://habrastorage.org/getpro/habr/post_images/613/4e9/53f/6134e953fa361b9a03290bed614fb639.jpg" alt="image"></a> <br><br>  It should be noted that we are not talking about hard and fast rules.  What we will talk about today is just recommendations.  Even if you decide to follow them, there may well be good reasons for deviating from them, for example, if this helps to make the code clearer.  However, in doing so, be careful and remember that people are subject to <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B3%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">cognitive distortion</a> .  For example, choosing between ordinary and <a href="https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75">arrow functions</a> in JavaScript, those who are not very familiar with the latter, prefer ordinary functions, by virtue of the habit of considering them to be clearer, simpler, more convenient. <br><a name="habracut"></a><br>  The principles of the ‚ÄúElements of Style‚Äù are not by chance alive today.  The fact is that usually their use makes the texts better.  Usually the author of the book is right.  It is worth deviating from them only in those cases when there is a good reason for this - and not because of whims or personal preferences. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many of the recommendations from the chapter "Basic principles of composition" apply to the program code: <br><br><ol><li>  Make the paragraph the minimum part of the composition.  One paragraph - one topic. </li><li>  Avoid unnecessary words. </li><li>  Use a valid deposit. </li><li>  Avoid sequences of weakly related sentences. </li><li>  Words in sentences related to each other should not be separated by other language constructs. </li><li>  Use affirmative statements. </li><li>  Express similar in meaning and purpose of thought in a similar form, using parallel structures. </li></ol><br>  Almost the same can be said about the style of the code: <br><br><ol><li>  Make the minimum part of the composition function.  One function - one task. </li><li>  Avoid unnecessary code. </li><li>  Use a valid deposit. </li><li>  Avoid sequences of loosely connected language constructs. </li><li>  Keep in one place the code and other elements of the programs aimed at solving one problem. </li><li>  Use an affirmative form for variable names and when building expressions. </li><li>  Use the same templates for solving similar problems. </li></ol><br><h2>  <font color="#3AC1EF">Function as a unit of composition</font> </h2><br><blockquote>  <i><font color="#999999">The essence of software development is composition.</font></i>  <i><font color="#999999">We create programs by composing modules, functions, and data structures.</font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">Understanding the process of creating functions and how to use them with other functions is one of the fundamental skills of a programmer.</font></i> </blockquote><br>  A module is a collection of functions or data structures.  Data structures are how we represent the state of a program.  However, nothing interesting happens until it comes to using functions. <br><br>  There are three types of functions in JavaScript. <br><br><ul><li>  Communication functions, that is, those that perform input-output operations. </li><li>  Procedural functions, which are a set of grouped instructions for solving some algorithmic problem. </li><li>  Mapping functions that accept data that transforms it and returns what happened. </li></ul><br>  Functions for implementing I / O operations and some data processing algorithms are needed almost everywhere, but the vast majority of the functions that you have to use will be mapping. <br><br><h3>  <font color="#3AC1EF">‚ñçOne task - one function</font> </h3><br>  If your function is intended to perform I / O operations, do not engage in mapping tasks.  If the function is intended for mapping, do not perform I / O operations in it. <br><br>  It must be said that procedural functions violate both the rule ‚Äúone function - one task‚Äù and the rule concerning weakly related language constructs.  However, one cannot do without such functions. <br><br>  The ideal function is a simple, deterministic, <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure function</a> with the following basic properties: <br><br><ul><li>  The same input data always gives the same output. </li><li>  When you call it there are no side effects. </li></ul><br><h2>  <font color="#3AC1EF">Redundant code</font> </h2><br><blockquote>  <i><font color="#999999">The energetic text is concise.</font></i>  <i><font color="#999999">The sentence should not contain unnecessary words, in the paragraph - unnecessary sentences, for the same reason that there should not be unnecessary lines in the drawing, and unnecessary details in the mechanism.</font></i>  <i><font color="#999999">This does not mean that the writer should use only short sentences, or, avoiding details, get along with general descriptions.</font></i>  <i><font color="#999999">This means that every word should have a meaning.</font></i>  <i><font color="#999999">[Unnecessary words omitted].</font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">William Strank Jr., "Elements of Style"</font></i> </blockquote><br>  Laconic code is very important in software development, since the more code - the more places to make a mistake.  <i>A smaller amount of code means fewer places where an error can disappear, which leads to a decrease in the number of errors.</i> <br><br>  Laconic code is easier to read, as it has a higher level of payload to information "interference".  The reader needs to weed out less syntactic "noise" in order to understand the meaning of the program.  Thus, a smaller amount of code means less syntactic "noise", and, as a result, a clearer transfer of meaning. <br><br>  To put it in the words of the ‚ÄúStyle Elements‚Äù, the compressed code is energetic code.  For example, such a construction: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secret</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message;  } };</code> </pre> <br>  It can be reduced to this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secret = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> () =&gt; msg;</code> </pre> <br>  Those who are familiar with the minimalist syntax characteristic of switch functions (they appeared in ES6 in 2015) are easier to read this entry, and not the code from the first example.  Unnecessary elements, such as parentheses, the <code>function</code> keyword, the <code>return</code> , are omitted here. <br><br>  In the first version, there are many service syntax constructs.  These include parentheses, the <code>function</code> keyword, and <code>return</code> .  They, for someone who is familiar with the switch functions, are nothing more than syntactic ‚Äúnoise‚Äù.  And, in modern JavaScript, such constructions exist only so that the code can be read by those who are not yet confident enough to own ES6.  Although, ES6 became the standard of the language in 2015, so the time to <a href="https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75">get to know</a> it better has long come. <br><br><h2>  <font color="#3AC1EF">Unnecessary variables</font> </h2><br>  Sometimes we give a name to something, for which it is not very necessary.  Say, some intermediate variable, without which you can do.  Why is it harmful?  The problem here is that the human brain has <a href="http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html">limited</a> short-term memory <a href="http://www.nature.com/neuro/journal/v17/n3/fig_tab/nn.3655_F2.html">resources</a> .  Having encountered a variable in the program's text, we are forced to memorize it.  If there are a lot of names, our memory is full, while reading we occasionally have to go back ... <br><br>  That is why experienced developers train themselves to eliminate unnecessary variables. <br><br>  For example, in most situations, variables created only to store the return value of a function should be avoided.  The name of the function should provide adequate information about what the function will return.  Consider an example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{firstName, lastName}</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullName = firstName + <span class="hljs-string"><span class="hljs-string">' '</span></span> + lastName; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fullName; };</code> </pre> <br>  Getting rid of unnecessary code can be rewritten as follows: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{firstName, lastName}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( firstName + <span class="hljs-string"><span class="hljs-string">' '</span></span> + lastName );</code> </pre> <br>  Another common approach to reducing the number of variables is to use the composition of functions and the so-called ‚Äúpointless notation‚Äù. <br><br>  Pointless notation is a way to declare functions without mentioning the arguments with which these functions operate.  The usual ways of applying this approach are currying and composition of functions. <br><br>  Here is an example of currying: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> b =&gt; a + b; <span class="hljs-comment"><span class="hljs-comment">//       inc(), //    1   . const inc = add2(1); inc(3); // 4</span></span></code> </pre> <br>  Take a look at the <code>inc()</code> function declaration.  Notice that neither the <code>function</code> keyword nor the syntax elements specific to the declaration of pointer functions are present.  There is also no description of the parameters of the function, since the function does not use them.  Instead, it returns another function that knows what to do with the arguments passed to it. <br><br>  Take a look at an example that uses composition of functions.  The composition of functions is the application of a function to the results returned by another function.  Whether you realize it or not, you apply composition of functions all the time. <br><br>  For example, when you use chains of method calls like <code>.map()</code> and <code>promise.then()</code> .  If we turn to the most general form of writing the composition of functions, we get the following construction: <code>f(g(x))</code> .  In mathematics, this is usually written as <code>f ‚àò g</code> , which is read as ‚Äúapplying the function <code>f</code> to the result of the function <code>g</code> ‚Äù. <br><br>  Using the composition of two functions, you eliminate the need to create a variable to store the intermediate value between function calls. <br><br>  Let's see how this technique allows you to write more clean code: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> g = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    : const incThenDoublePoints = n =&gt; { const incremented = g(n); return f(incremented); }; incThenDoublePoints(20); // 42 // compose2 ‚Äî        const compose2 = (f, g) =&gt; x =&gt; f(g(x)); //   : const incThenDoublePointFree = compose2(f, g); incThenDoublePointFree(20); // 42</span></span></code> </pre> <br>  The same can be done with any function. <br><br>  <a href="https://medium.com/javascript-scene/functors-categories-61e031bac53f">A functor</a> is an object that implements the mapping function.  For example, in JS these are arrays ( <code>Array.map()</code> ) or promises ( <code>promise.then()</code> ).  We write another version of the <code>compose2</code> function, using a chain of calls to the mapping functions for the purpose of function composition: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose2 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, g</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; [x].map(g).map(f).pop(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> incThenDoublePointFree = compose2(f, g); incThenDoublePointFree(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre> <br>  You do almost the same thing every time, using call chains in promises. <br><br>  In fact, each functional programming library implements at least two ways of composition of functions.  This is the <code>compose()</code> function, which applies functions from right to left, and <code>pipe()</code> , which applies functions from left to right. <br><br>  For example, in Lodash such functions are called, respectively, <code>compose()</code> and <code>flow()</code> .  When I use this library, I use the <code>flow()</code> function like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pipe <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/fp/flow'</span></span>; pipe(g, f)(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre> <br>  However, this functionality can be implemented independently, without libraries: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x); pipe(g, f)(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre> <br>  If the aforementioned seems to you to be something very abstruse, and you do not know how you would use all this, consider the following: <br><br>  <i><font color="#999999">The essence of software development is composition.</font></i>  <i><font color="#999999">We create programs by composing small modules, functions, and data structures.</font></i> <br><br>  Understanding tools for the composition of functions and objects is just as important for a programmer as for a builder ‚Äî the ability to control a drill and a mounting gun.  And the use of an imperative code for combining functions and the unjustified use of variables for storing intermediate results resembles assembling furniture with adhesive tape. <br><br>  As a result, we offer you to remember the following: <br><br><ul><li>  If there is an opportunity to express an idea in a smaller amount of code, without changing or confusing its meaning, do so. </li><li>  The same goes for variables.  If there is such an opportunity, and it does not harm the logic and clarity of the program - the less variables there are the better. </li></ul><br><h2>  <font color="#3AC1EF">Active voice</font> </h2><br><blockquote>  <i><font color="#999999">Actual voice usually means a clearer and more lively expression of thought than a passive.</font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">William Strank Jr., "Elements of Style"</font></i> </blockquote><br>  Give software constructions as clear and precise names as possible: <br><br><ul><li>  <code>myFunction.wasCalled()</code> better than <code>myFunction.hasBeenCalled()</code> </li><li>  <code>createUser()</code> better than <code>User.create()</code> </li><li>  <code>notify()</code> better than <code>Notifier.doNotification()</code> </li></ul><br>  Call the predicate functions and logical variables as if they were questions that allowed the answer ‚Äúyes‚Äù or ‚Äúno‚Äù: <br><br><ul><li>  <code>isActive(user)</code> better than <code>getActiveStatus(user)</code> </li><li> <code>isFirstRun = false;</code>  better than <code>firstRun = false;</code> </li></ul><br>  Use verb forms in function names: <br><br><ul><li>  <code>increment()</code> better than <code>plusOne()</code> <br></li><li>  <code>unzip()</code> better than <code>filesFromZip()</code> </li><li>  <code>filter(fn, array)</code> better than <code>matchingItemsFromArray(fn, array)</code> </li></ul><br><h3>  <font color="#3AC1EF"> Event Handlers</font> </h3><br>  The naming of event handlers and life-cycle methods is an exception to the rule for using verbs in function names, as they are used as qualifiers.  They show not ‚Äúwhat‚Äù to do, but ‚Äúwhen.‚Äù  They should be named according to the following scheme: "&lt;when ‚Äã‚Äãto perform an action&gt;, &lt;verb&gt;". <br><br><ul><li>  <code>element.onClick(handleClick)</code> better than <code>element.click(handleClick)</code> </li><li>  <code>component.onDragStart(handleDragStart)</code> better than <code>component.startDrag(handleDragStart)</code> </li></ul><br>  The names of event handlers from the list that are recognized as unsuccessful look as if we want to trigger an event, and not respond to it. <br><br><h3>  <font color="#3AC1EF"> Life Cycle Techniques</font> </h3><br>  Take a look at the following variants of the hypothetical component life cycle methods that are created to call the handler function before updating this component: <br><br><ul><li> <code>componentWillBeUpdated(doSomething)</code> </li> <li> <code>componentWillUpdate(doSomething)</code> </li> <li> <code>beforeUpdate(doSomething)</code> </li> </ul><br>  In the first example, we use the passive voice (‚Äúwill be updated‚Äù, not ‚Äúupdate‚Äù).  This name is redundant, it is not clearer than other options. <br><br>  The second example looks better, but the point of this life cycle method is to call the handler.  The <code>componentWillUpdate(handler)</code> name is read as if the component is going to affect the handler, update it, which does not express the true value of this software construct.  We mean the following: "Before the component is updated, call the handler."  The name <code>beforeComponentUpdate()</code> expresses our intention most clearly. <br><br>  We can continue on the path of simplification.  Since we are talking about the methods of the object, when they are called, the object itself will be mentioned.  This means that adding an object name to a method name is redundant.  Think about how the following construct will look like if you call a method when accessing a component: <code>component.componentWillUpdate()</code> .  It will be read in the same way as: ‚ÄúVasya Vasya will have cutlets for lunch‚Äù.  Double mentioning an object name is redundant.  As a result, the following is obtained: <code>component.beforeUpdate(doSomething)</code> better than c <code>omponent.beforeComponentUpdate(doSomething)</code> . <br><br>  Functional impurities are functions that add properties and methods to objects.  Such functions are called one after another in a conveyor that resembles an assembly line in a factory.  Each function accepts an <code>instance</code> as an input, an object, and adds something to it before passing the next function in the pipeline. <br><br>  I prefer to call such functions using adjectives.  In order to find the right word, you can use the suffixes "ing" and "able".  Here are some examples: <br><br><ul><li>  const duck = composeMixins (flying, quacking); </li><li>  const box = composeMixins (iterable, mappable); </li></ul><br><h2>  <font color="#3AC1EF">Sequences of weakly related language constructs</font> </h2><br>  <i>... a series of statements soon becomes monotonous and boring.</i> <i><br><br></i>  <i>William Strank, Jr., "Elements of Style."</i> <br><br>  Developers fill functions with sequences of language constructs.  These constructions are conceived so that they are executed one after another, in essence, being an example of a series of loosely related statements.  Such an approach, when too many such calls are collected in a certain program block, leads to the appearance of the so-called ‚Äúspaghetti code‚Äù. <br><br>  In addition, call sets are often repeated in a variety of similar forms.  In this case, each of the repeating blocks may well differ slightly from others, and often such differences arise quite unexpectedly.  For example, the basic needs of a certain user interface component correspond to the needs of almost all such components.  Implementing what is needed by all these components can be based on the different stages of their life cycle, breaking the implementation into several functions. <br><br>  Consider the following call sequence: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> drawUserProfile = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ userId }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userData = loadUserData(userId); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataToDisplay = calculateDisplayData(userData); renderProfileData(dataToDisplay); };</code> </pre> <br>  This function performs three different cases: loading data, building, based on what was loaded, the data model of the interface element, and outputting the element to the page. <br><br>  In most modern libraries for the development of interfaces, each of the above tasks is solved separately from the others, for example, using a dedicated function.  Separating these tasks, we can combine functions without special problems, achieving the desired result in various situations. <br><br>  With this approach, we could completely replace, say, the output function of the component, and it would not affect other parts of the program.  In React, for example, there are many rendering subsystems designed for different platforms and different library usage scenarios.  Here is a far from complete list: ReactNative for native iOS and Android applications, AFrame for WebVR, ReactDOM / Server for rendering components on the server side. <br><br>  Another problem with the above function is that it does not allow preparing the interface element model and displaying it on the page without first loading the initial data.  What if this data is already uploaded?  Ultimately, if a similar function that combines several operations in itself is called several times, this leads to the execution of unnecessary actions. <br><br>  Separation of operations, in addition, opens the way to their independent testing.  In the process of writing code, I constantly run unit tests in order to immediately assess the impact on the application of the changes made to it.  However, if, as in our example, we combine the rendering code of the control with the source data loading code, it will not be possible to simply transfer some conditional data to the output function of the element for test purposes.  There will have to test everything - and download, and preparation, and data output.  This, if you need to check only one thing, will lead to unnecessary time expenses: data, for example, must be downloaded over the network, processed, displayed in the browser ... To get the test results you will have to wait longer than when checking a separate component.  Separation of functions will allow testing them separately from other parts of the application. <br><br>  In our example, there are already three separate functions, the calls of which can be easily put into different methods of the component life cycle.  For example, you can load source data when a component is connected, processing of this data and displaying the component on the screen can be performed in response to an event related to updating the state of an interface element. <br><br>  The application of the above principles leads to the emergence of software with more clearly defined areas of responsibility of its individual components.  Each of the components can reuse the same data structures and life cycle event handlers; as a result, we don‚Äôt perform actions that can be performed only once. <br><br><h2>  <font color="#3AC1EF">Storing code and other elements of programs aimed at solving one problem</font> </h2><br>  Many frameworks and templates provide for organizing program files by their type.  If we are talking about a simple project, such as a small calculator, or a ToDo application, this approach will not cause problems, but in larger projects it is better to group the files according to the functionality of the application, which they implement. <br><br>  For example, here are two variants of the file hierarchy for a ToDo application.  The first option is to group files by type: <br><br><pre> <code class="hljs pgsql">. ‚îú‚îÄ‚îÄ components ‚îÇ   ‚îú‚îÄ‚îÄ todos ‚îÇ   ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> ‚îú‚îÄ‚îÄ reducers ‚îÇ   ‚îú‚îÄ‚îÄ todos ‚îÇ   ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> ‚îî‚îÄ‚îÄ tests   ‚îú‚îÄ‚îÄ todos   ‚îî‚îÄ‚îÄ <span class="hljs-keyword"><span class="hljs-keyword">user</span></span></code> </pre> <br>  The second - grouping according to the logical principle: <br><br><pre> <code class="hljs bash">. ‚îú‚îÄ‚îÄ todos ‚îÇ   ‚îú‚îÄ‚îÄ component ‚îÇ   ‚îú‚îÄ‚îÄ reducer ‚îÇ   ‚îî‚îÄ‚îÄ <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ‚îî‚îÄ‚îÄ user   ‚îú‚îÄ‚îÄ component   ‚îú‚îÄ‚îÄ reducer   ‚îî‚îÄ‚îÄ <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Grouping files according to the functionality they implement allows, if you need to make changes to some part of the application, not to constantly move from folder to folder in search of the necessary files. <br><br>  As a result, we recommend grouping files based on what functionality of the application they implement. <br><br><h2>  <font color="#3AC1EF">Using an affirmative form for variable names and when building expressions</font> </h2><br><blockquote>  <i><font color="#999999">Make clear statements.</font></i>  <i><font color="#999999">Avoid sluggish, colorless, indecisive, evasive language.</font></i>  <i><font color="#999999">Do not use the word as a means of denial, in antithesis, or as a way to avoid the topic.</font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">William Strank Jr., "Elements of Style"</font></i> </blockquote><br>  Let's go straight to examples of variable names: <br><br><ul><li>  <code>isFlying</code> better than <code>isNotFlying</code> </li><li>  <code>late</code> better than <code>notOnTime</code> </li></ul><br><h3>  <font color="#3AC1EF">‚ñçConditional Operator</font> </h3><br>  This design: <br><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">err</span></span>) return reject(<span class="hljs-name"><span class="hljs-name">err</span></span>)<span class="hljs-comment"><span class="hljs-comment">; //  -...</span></span></code> </pre> <br>  ... better this: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...  - } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject(err); }</code> </pre> <br><h3>  <font color="#3AC1EF">Ternal Operator</font> </h3><br>  So: <br><br><pre> <code class="hljs javascript">{ [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]: iterator ? iterator : defaultIterator }</code> </pre> <br>  ... better than this: <br><br><pre> <code class="hljs erlang-repl">{ [Symbol.iterator]: (!iterator) ? defaultIterator : iterator }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçAbout Negative Statements</font> </h3><br>  Sometimes a logical variable interests us only in situations where its value is false.  Using a name for such a variable in an affirmative form will result in the need to use the logical negation operator, when checking it,!  .  In such cases, it is better to give the variables distinct negative names.  The word "not" in the variable name and the operator <code>!</code>  in comparison operations lead to vague wording.  Consider a few examples. <br><br>  <code>if (missingValue)</code> better than <code>if (!hasValue) <br> if (anonymous)</code> <code>if (!hasValue) <br> if (anonymous)</code>  <code>if (!hasValue) <br> if (anonymous)</code> better than <code>if (!user) <br> if (isEmpty(thing))</code> <code>if (!user) <br> if (isEmpty(thing))</code>  <code>if (!user) <br> if (isEmpty(thing))</code> better than <code>if (notDefined(thing))</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçArguments of functions that take null and undefined values</font> </h3><br>  Do not create functions that, when called, require <code>undefined</code> or <code>null</code> instead of optional parameters.  In such situations, it is best to use an object with named parameters: <br><br><pre> <code class="hljs coffeescript">const createEvent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ title = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Untitled'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, timeStamp = Date.now(), description = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ title, description, timeStamp }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... const birthdayParty = createEvent({ title: <span class="hljs-string"><span class="hljs-string">'Birthday Party'</span></span>, description: <span class="hljs-string"><span class="hljs-string">'Best party ever!'</span></span> });</code> </pre> <br>  ‚Ä¶better than: <br><br><pre> <code class="hljs coffeescript">const createEvent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( title = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Untitled'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, timeStamp = Date.now(), description = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ title, description, timeStamp }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... const birthdayParty = createEvent( <span class="hljs-string"><span class="hljs-string">'Birthday Party'</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-string"><span class="hljs-string">'Best party ever!'</span></span> );</code> </pre> <br><h2>  <font color="#3AC1EF">Patterns and solution of similar tasks</font> </h2><br><blockquote>  <i><font color="#999999">... parallel construction requires external similarity of fragments of text that have similar content and purpose.</font></i>  <i><font color="#999999">The similarity of the form allows the reader to more easily recognize the similarity of the content.</font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">William Strank Jr., "Elements of Style"</font></i> </blockquote><br>  When creating applications, the programmer often has to solve very similar tasks.  A code that can be repeated is usually much more than a completely unique one.  As a result, during the work you have to constantly do the same thing.  The good thing here is that it provides an opportunity for generalizing similar code and creating abstractions.  To do this, it is enough to identify the same parts of the code, select them and use them wherever they are needed.  And in the course of development, to pay attention only to unique constructions for a particular fragment of the application.  In fact, various libraries and frameworks serve this purpose. <br><br>  Here, for example, are the components of the user interface. And ten years have not passed since it was commonplace to lump the interface updates using jQuery, the application logic and the organization of its interaction with the outside world.  Later, programmers began to realize that in client web applications, MVC could be used, and they began to separate models from the interface update logic. <br><br>  As a result, web applications began to be built using a component approach, which allowed for declarative modeling of components using something like templates created using HTML or JSX. <br><br>  All this has led to the use of the same user interface update logic for all components, which is much better than the unique imperative code. <br><br>  Those familiar with the components, it is very easy to understand how they work, even if we are talking about an application unfamiliar to them.  ,    ,     ,    ,      ,    ,      ,  ,   . <br><br>         , ,    ,   ,    . <br><br><h2> <font color="#3AC1EF">:    ,   </font> </h2><br>  ES6    2015-,   ,   ,     .    , ,   ,  ,  ,    <a href="https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75"></a> .     ‚Äî  <code>‚Ä¶</code> ,  ,  .      ,   ‚Äî  .      ,   ,   ES6  ,         ES5.          . <br><br> ,    ,   .    ,     : <br><br><ul><li>    . </li><li>   . </li></ul><br> ,   ,   ,   : <br><br><ul><li>     . </li><li>      . </li><li>         . </li></ul><br>   ,         : <br><br><ul><li>   . </li><li>   . </li><li>   . </li></ul><br>   ,  ,     ,   ,     .         .   , ,    ,         ,    ,       ,   . <br><br>   ,            ,          . <br><br>       ,    .   ,      .  ,       ES6,   , ,  ,     ,   ¬´ ¬ª        . , , ,      -,   JS,     . <br><br>  Dear readers!    ES6  ? </div><p>Source: <a href="https://habr.com/ru/post/329152/">https://habr.com/ru/post/329152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329140/index.html">Exception hierarchy in modern PHP application</a></li>
<li><a href="../329142/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ263 (May 15 - 21, 2017)</a></li>
<li><a href="../329146/index.html">Unity3d We play with the mesh. Part 3 - Collision Based Mesh Warp</a></li>
<li><a href="../329148/index.html">[Saint Petersburg] Andrei Ershov - CRDT. Conflict-free data synchronization</a></li>
<li><a href="../329150/index.html">How to write a chat bot in PHP for the VKontakte community</a></li>
<li><a href="../329154/index.html">Online ticket office: first results</a></li>
<li><a href="../329156/index.html">Two words about abstract forces ruling Worlds</a></li>
<li><a href="../329160/index.html">Unreal engine 4. Sequencer instead of Matinee</a></li>
<li><a href="../329166/index.html">Bug in NTFS, or how to hang the whole system</a></li>
<li><a href="../329168/index.html">Pygest # 9. Releases, articles, interesting projects from the world of Python [May 8, 2017 - May 22, 2017]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>