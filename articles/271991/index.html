<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Covering graphs in software testing, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most programs and algorithms can be represented as a graph consisting of a set of vertices ( N ) and edges ( E ). Coverage of graphs in testing is use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Covering graphs in software testing, part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/66f/d2b/227/66fd2b22732c4c52b54c4124b596e526.png" width="30%" align="left"><br>  Most programs and algorithms can be represented as a graph consisting of a set of vertices ( <i>N</i> ) and edges ( <i>E</i> ).  Coverage of graphs in testing is useful because you can design tests using different coverage criteria and identify errors.  With regard to testing the black box, then covering graphs here can also be of great importance if you have to work with states and transitions, entity state graphs, etc.  If the graph is rather complicated, different coverage criteria will allow assessing the sufficiency of the test suite. <br><a name="habracut"></a><br><br><h4>  Definitions </h4><br><h5>  Counts </h5><br>  The formal definition of a graph is given below. <br><ul><li>  <b>The graph</b> , <i>G</i> , consists of a set of one or more (1 .. *) vertices, <i>N</i> , and a set of zero and more (0 .. *) edges, <i>.</i> </li><li>  An <b>initial set of vertices</b> , <i>N <sub>0</sub></i> , and a <b>finite set of vertices</b> , <i>N <sub>f,</sub></i> must be specified.  Both of these sets must be non-empty.  If the graph consists of one vertex, it must be in both sets, then <i>N <sub>0</sub> = N <sub>f</sub></i> will be satisfied.  Starting vertices are indicated by incoming arrows (see green vertices below).  The final vertices are denoted by a bold circle.  Below, the colors are used simply for illustration: green - initial, red - final, blue - normal. </li><li>  <b>Edge</b> <i>e</i> can combine two vertices, <i>n <sub>p</sub></i> and <i>n <sub>s</sub></i> , where <i>p</i> is the source and <i>s</i> is the receiver.  This is represented as <i>(n <sub>p</sub> , n <sub>s</sub> )</i> .  An edge can also start from one vertex and end at the same vertex: <i>(n, n)</i> . </li><li>  <b>A vertex is</b> formally denoted by lowercase <i>n</i> with a numeric index to denote its number.  For brevity and ease of understanding, a simplified sittaxis will be used, where the vertex is simply indicated by a number (if there is any uncertainty, we use formal notation).  Just keep in mind that the tests may require "long" notation. </li></ul><br><br><h5>  Ways in the graph </h5><br>  The graph below is for illustrating the definitions given. <br><img src="https://habrastorage.org/files/dcb/419/e6d/dcb419e6d677425086919c068c081799.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Path</b> - a sequence of connected vertices in the graph G. The path <i>p</i> from vertex 1 to 3, 6, and 4 can be written as follows: p = [n <sub>1</sub> , n <sub>3</sub> , n <sub>6</sub> , n <sub>4</sub> ] (formally).  I will write it like this: [1, 3, 6, 4].  The adjacent pairs of vertices in this path are edges.  For example, the set of edges in this path is {(1, 3), (3, 6), (6, 4)}.  Please note that this is a set of pairs, and I used an informal way of writing (you should also pay attention to the correct placement of parentheses). </li><li>  <b>The path length</b> is the number of edges in the path.  One vertex has a path of length 0 (it is easy to understand, since, generally speaking, it has 0 edges).  Path length <i>p</i> - 3. </li><li>  <b>The length of the path</b> - a subset of vertices in the path <i>p</i> .  [1, 3] - the segment of the path [1, 3, 6, 4].  Do not confuse this with the edge (1, 3). </li><li>  <b>The reach limit (n)</b> can be defined as a subgraph (vertices and edges) that can be reached from vertex n.  Reach limit (2) - a set containing vertices 2, 4 and 5. Note that Reach limit () can take as a parameter sets of vertices and edges.  The resulting graph is simply the union of all the individual reach limits.  For example, the Reach Limit ({6,2}) is the same as the union of the Reach Limit sets (6) and Reach Limit (2).  To get this result, list all the vertices that can be reached from vertex 6, and all the vertices that can be reached from vertex 2, merge the lists and remove duplicates.  Using the graph above, the result is: {6, 4, 2, 5}.  The reach limit ({3, 2}) reaches all vertices and edges in the graph G. You can specify that the reach limit ({2, 3}) = G. </li><li>  <b>The test path</b> starts at the starting point and ends at the ending point.  Path [1, 3, 4] is the correct test path, and [1, 3, 6] is not.  Do you understand why? </li><li>  <b>SESE (single-entry, single-exit) columns</b> are columns with one input and one output, i.e.  those with exactly one initial and one final vertex. </li></ul><br><h4>  Vertex Coverage (PV) </h4><br>  The simplest coverage criteria are vertex and edge finishes.  Covering the vertices assumes that your tests cover all the reachable vertices in the graph.  Requirements for test coverage of vertices in a graph are the set of vertices (N) of a graph. <br><br><img src="https://habrastorage.org/files/852/783/221/852783221b4c4992b645d287ff53fab0.png" width="20%"><br><br>  For this graph, the requirements and the test path satisfying them are given below. <br><br>  requirements = {1, 2, 3} <br>  path (T) = {[1, 2, 3]} <br><br><h4>  Rib Coating (PR) </h4><br>  The purpose of covering the edges is to go through all the edges in the graph.  An edge can be expressed as a path of length 1. The requirements contain all attainable paths of length up to 1 (and inclusive).  The wording ‚Äúto 1‚Äù allows to take into account graphs consisting of one vertex and not having edges. <br><br>  requirements = {(1, 2), (1, 3), (2, 3)} <br>  path (T) = {[1, 2, 3], [1, 3]} <br><br>  The tops of the vertices and the edges are most often the same.  The exceptions are special cases, including conditional constructions (if-else).  (This is the three-vertex graph in the example above: compare the required test paths and see why.) <br><br><h4>  Paired Rib Coating </h4><br>  Requirements include every reachable path of length up to 2 inclusive. <br>  In fact, find all paths that include three vertices and two edges and create a set of test cases covering these paths.  Paths of length 1 will be automatically covered as they will be included in one of these test paths.  If there is a path of length 1 that is not a segment of the paths already listed, you need to include it in the list. <br><br><img src="https://habrastorage.org/files/3be/524/100/3be524100c0742f5870a7928dc3629e2.png" width="25%"><br><br>  In the graph above there are five different pairs of ribs.  Pairing the ribs suggests that each of these pairs is covered by at least one test path. <br><br>  requirements = {[1, 3, 5], [1, 2, 3], [1, 2, 4], [2, 3, 5], [2, 4, 5]} <br>  path (T) = {[1, 3, 5], [1, 2, 3, 5], [1, 2, 4, 5]} <br><br><h4>  Full track coverage (SPT) </h4><br>  Requirements include all paths in G. This is not possible if there is a cycle in the graph.  As a compromise, the covering of established paths is used. <br><br><h4>  Covering specified paths (PPP) </h4><br>  In the PPP, the requirements are a set of <i>S</i> test paths, where <i>S</i> is the set of paths chosen by the tester.  This avoids the problem of having to cover infinitely many paths in the RFP if the graph contains a cycle.  In the PPP, the tester simply eliminates the cycle from <i>S</i> , and the requirements of the PPP can be satisfied. <br><br><img src="https://habrastorage.org/files/d4b/589/bf3/d4b589bf39674410902dee702c9d4533.png"><br><br>  S = {[1, 2, 3], [1, 3], [1, 4, 3]} (All paths in G, except those containing cycles) <br>  requirements = {[1, 2, 3], [1, 3], [1, 4, 3]} <br>  path (T) = {[1, 2, 3], [1, 3], [1, 4, 3]} <br><br>  SPT impractical.  The PPP is a weak compromise to actually satisfy the RFP without adding an infinite set of requirements for graphs with cycles.  However, covering the specified paths is also imperfect.  A tester can skip important paths when making a set of <i>S</i> , which leads to a subjective and error-resistant MFR. <br><br>  Attempts to solve this problem have been made for a long time.  Starting from a single cycle (1970s), passing each cycle exactly once (1980s) to a less formal description ‚Äî passing each cycle 0, 1 or more times (1990s), software testers came up with the idea of ‚Äã‚Äãusing <i>basic paths</i> to limit the total number of paths in the graph. <br><br>  Note in the fields: the <b>cyclomatic complexity of the</b> graph determines the number of tests necessary for all the lines in the program to be executed at least once.  Cyclomatic complexity can be calculated by adding 2 to the difference between the number of edges and vertices in the graph. <br><br>  CA = # edges - # vertices + 2 <br><br>  In the next and last part: the main paths and coverage associated with them. </div><p>Source: <a href="https://habr.com/ru/post/271991/">https://habr.com/ru/post/271991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271981/index.html">New malicious campaign Dridex led to a large number of infections in Europe</a></li>
<li><a href="../271983/index.html">Linux, delayed driver loading and broken interrupts</a></li>
<li><a href="../271985/index.html">Quarterly site security check</a></li>
<li><a href="../271987/index.html">IBM Bluemix Business Quest - Special Project for Application Developers</a></li>
<li><a href="../271989/index.html">Welcome to PGConf 2016 - Russian PostgreSQL conference</a></li>
<li><a href="../271993/index.html">Experimental version of PVS-Studio supporting C #</a></li>
<li><a href="../271997/index.html">Configuration management in a software project</a></li>
<li><a href="../271999/index.html">Successful implementation of SIEM. Part 2</a></li>
<li><a href="../272003/index.html">Check Digit by Damme Method</a></li>
<li><a href="../272005/index.html">Swift! Protocol Oriented</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>