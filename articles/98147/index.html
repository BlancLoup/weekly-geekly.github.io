<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We master the simplest PIC microcontroller. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, we sorted out how to flash the selected MK, how to properly configure it, and also learned how to work with digital ports. 
 Now it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We master the simplest PIC microcontroller. Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/controllers/97795/">first part,</a> we sorted out how to flash the selected MK, how to properly configure it, and also learned how to work with digital ports. <br>  Now it's time to look at the rest of the microcontroller's periphery. <br><a name="habracut"></a><br>  All parameters of the MC are set through the installation of certain values ‚Äã‚Äãin the registers for special purposes (SFR). <br>  Like the configuration bits, all the registers existing in the selected MK are available to us in the form of variables thanks to the connected library. <br><br>  To find out which bits in which registers we need for a particular module, we will have to look into the documentation again. <br>  For an example, take a look at the table of registers related to digital inputs / outputs of port B: <br><br><img src="https://habrastorage.org/storage/habraeffect/09/99/099965ac632b3b43203e6d43fbd41dde.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having read the values ‚Äã‚Äãof the <strong>PORTB</strong> register, we get the current logical level on each leg of the port. <br>  Writing to the register sets the specified level on the corresponding legs of the port. <br>  Each bit of the register is available to us as a separate variable; it is through them that we controlled the LED and read the state of the button. <br><br>  The <strong>TRISB</strong> register <strong>is</strong> responsible for sending data through the port.  Each of the 8 bits of the register is tied to the corresponding leg MK. <br>  Assigning the unit to the desired bit - we will make an input from it, and assigning zero to the output. <br>  It is in this register that we changed the bits through the pin_Bx_direction variables. <br><br>  In the <strong>OPTION_REG</strong> register, only the high-order bit refers to the port: <br><blockquote>  <strong>RBPU</strong> : PORTB Pull-up Enable bit <br>  1 = PORTB pull-ups are disabled <br>  0 = PORTB pull-ups </blockquote><br>  This bit is responsible for connecting the internal braces, which was mentioned in the first part. <br>  According to the table it can be seen that the lift is initially turned off, which means that in the absence of an external pull-up it is necessary to turn on the inner one yourself: <br><blockquote><code>OPTION_REG_NRBPU = <font color="#FF0000">0</font></code> </blockquote> <br><br>  If you want to know the principle of operation of a particular module, you can always find a closer diagram in the documentation. <br><br><h3>  Interruptions </h3><br>  Since microcontrollers do not support multitasking, a number of problems arise in combining several processes. <br><br>  Suppose we need to flash one LED constantly with a long period, and the second switch at the touch of a button. <br>  Whatever order of actions we choose, how it should work will not work for us: for while the microcontroller counts down the time until the switching of the first LED, it can skip the fact of pressing the button. <br><br>  This is where interrupts come in to help us. <br>  Under certain conditions, the microcontroller can interrupt the execution of an infinite loop and execute a small subroutine, and then return to the execution of the main task. <br><br>  In our chosen MK 16f628a there are 10 possible sources of interruptions: <br><ul><li>  external interrupt source int </li><li>  change in signal level on digital inputs RB4: 7 </li><li>  TMR0 timer overflow </li><li>  TMR1 timer overflow </li><li>  match TMR2 and PR2 </li><li>  completion of writing to EEPROM </li><li>  change comparator output level </li><li>  receiving \ completion of sending data via USART </li><li>  CCP interrupts </li></ul><br><br>  An interrupt for each source can be either <strong>enabled</strong> or <strong>disabled by</strong> changing the corresponding bits in the <strong>INTCON</strong> and <strong>PIE1</strong> registers <strong>individually</strong> . <br>  To enable interrupts controlled by the PIE1 register, it is necessary to enable peripheral interrupts with the PEIE bit in the <strong>INTCON</strong> register. <br>  After selecting the necessary interrupt sources, it is necessary to globally enable interrupts with the <strong>GIE</strong> bit in the <strong>INTCON</strong> register. <br><br>  For each interrupt, there is another bit in the <strong>INTCON</strong> register or <strong>PIR1</strong> - the interrupt flag. <br>  When an interrupt is triggered, the corresponding flag is assigned the value 1, by which it is easy to determine which of the interrupts has worked. <br>  It is necessary to reset the interrupt flags manually after entering the interrupt handler, otherwise with several sources it will be impossible to parse who exactly caused it. <br><br>  As an example of using interrupts, let's rewrite our program for flashing LEDs. <br>  We use the source of interrupts INT.  Depending on the state of the INTEDG bit in the OPTION register, an interrupt will be generated either on the leading edge of the signal (transition from low to high) or on the rear. <br>  To change the signal level to INT, it is not necessary to move the button to the corresponding leg (pin 6). <br><blockquote> <code><font color="#0000FF">include 16f628a -- target PICmicro <br></font> <font color="#008080"><i>-- <br></i></font> <b>pragma</b> <font color="#0000FF">target clock</font> <font color="#FF0000">4_000_000</font> <font color="#008080"><i>--   ,       <br> --   <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> OSC INTOSC_NOCLKOUT <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> WDT <font color="#008000">disabled</font> <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> PWRTE <font color="#008000">disabled</font> <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> MCLR external <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> BROWNOUT <font color="#008000">disabled</font> <font color="#008080"><i>--      <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> LVP <font color="#008000">disabled</font> <font color="#008080"><i>--     <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> CPD <font color="#008000">disabled</font> <font color="#008080"><i>--  EEPROM  <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> CP <font color="#008000">disabled</font> <font color="#008080"><i>--    <br> -- <br></i></font> enable_digital_io() <font color="#008080"><i>--   \    <br> -- <br></i></font> <b>alias</b> led <b>is</b> pin_B5 <font color="#008080"><i>--    RB5 <br></i></font> pin_B5_direction = <font color="#008000">output</font> <font color="#008080"><i>--  RB5    <br> -- <br></i></font> <b>alias</b> button <b>is</b> pin_B0 <font color="#008080"><i>--    RB0 <br></i></font> pin_B0_direction = <font color="#008000">input</font> <font color="#008080"><i>--  RB0   <br></i></font> <b>var volatile bit</b> led_blink = <font color="#008000">false</font> <font color="#008080"><i>--   <br> --   <br></i></font> INTCON_INTE = <font color="#008000">on</font> <font color="#008080"><i>--       INT <br></i></font> INTCON_INTF = <font color="#008000">off</font> <font color="#008080"><i>--     INT <br></i></font> OPTION_REG_INTEDG = <font color="#FF0000">0</font> <font color="#008080"><i>--     1-&gt;0 <br></i></font> INTCON_GIE = <font color="#008000">on</font> <font color="#008080"><i>--    <br> --   INT <br></i></font> <b>procedure</b> INT_ISR <b>is <br> pragma</b> <font color="#0000FF">interrupt <br></font> <b>if</b> INTCON_INTF <b>then</b> <font color="#008080"><i>--      <br></i></font> INTCON_INTF = <font color="#008000">off</font> <font color="#008080"><i>--    <br></i></font> led_blink = !led_blink <font color="#008080"><i>--    <br></i></font> <b>end if <br> end procedure <br></b> led = <font color="#008000">off</font> <font color="#008080"><i>--   <br></i></font> <b>forever loop <br></b> led = <font color="#008000">off</font> <font color="#008080"><i>--   <br></i></font> <b>_usec_delay</b> ( <font color="#FF0000">100000</font> ) <font color="#008080"><i>--  0,1  <br></i></font> <b>if</b> led_blink <b>then</b> <font color="#008080"><i>--      <br></i></font> led = <font color="#008000">on</font> <font color="#008080"><i>--  0,1  <br></i></font> <b>_usec_delay</b> ( <font color="#FF0000">100000</font> ) <font color="#008080"><i>--  0,1  <br></i></font> <b>end if <br> end loop <br></b></code> </blockquote><br>  Alas, this is not the best option for two reasons: <br><ul><li>  because of the bounce of the contacts of the button, the interruption can work several times in a row, it is desirable to suppress the bounce by software </li><li>  in the main program loop, we still have pauses, during which the microcontroller does nothing but wait. </li></ul><br><br><h3>  Timers </h3><br>  The main work of timers is counting.  Upon completion of the account, they can generate an interrupt.  And since the counting is hardware, without clogging up CPU time with a wait, the timers are well suited to replace our pauses. <br>  Each of the three timers has its own characteristics, so for performing certain tasks you need to be able to choose the most suitable one. <br><br><h4>  TMR0 </h4><br><ul><li>  8-bit timer (counts from 0 to 255) </li><li>  clocked either from the system frequency or from an external source </li><li>  can read both leading and trailing edges of a clocked signal </li><li>  8-bit prescaler (can read every second, every 4 ... every 256 signal) </li><li>  interrupt is generated when overflowed (when going from 255 to 0) </li><li>  the timer runs constantly </li></ul><br>  What does this give us? <br>  When clocked from the system frequency (in our case - 4 MHz / 4 = 1 Mhz), the timer will generate interrupts with a constant frequency. <br>  It is not difficult to calculate that without a prescaler, interrupts will have a frequency of 3906.25 Hz.  For the LED - a bit too much. <br>  The prescaler can decrease the frequency eight times by an order of magnitude (double, i.e. by 2 times). <br>  With the prescaler 1: 256 we get a frequency of 15.3 Hz.  LED flashing with such a frequency is quite visible to the human eye. <br>  When clocking MK from external quartz, you can achieve a different frequency range. <br><br>  When clocking a timer from an external source, the timer turns into a counter of external pulses.  In principle, the accounts do not change, just depending on the source, there may not be a constant frequency of interruptions.  A counter can be considered as the number of button presses, wheel revolutions, etc. At the same time, no one is obligated to count from zero to an interruption: the current value of the counter is always available both for reading and for writing. <br><blockquote>  If desired, in the timer mode, you can increase the interrupt frequency by changing the start value of the counter with each interruption, but since it takes an unknown time during the transition to the processing procedure, it will not be possible to accurately calculate the frequency. </blockquote><br><h4>  TMR1 </h4><br>  The main differences of the timer from TMR0: <br><ul><li>  this timer is 16 bit </li><li>  the timer can be clocked not only from an external source, but also from an additional watch quartz </li><li>  maximum available prescaler - 1: 8 </li><li>  the timer can read only the leading edges of the signal </li><li>  timer can be used by the CCP module </li><li>  the timer can be turned off </li></ul><br>  You can use TMR1 in the same way as TMR0: either to generate a specific frequency, or to count pulses. <br><br><h4>  TMR2 </h4><br>  This 8-bit timer has a slightly different principle of operation. <br>  It can clock only from the system frequency.  The prescaler can only be set to values ‚Äã‚Äã1: 1, 1: 4 or 1:16. <br>  The received pulses timer counts from zero to a pre-set value of PR2. <br>  After the match between TMR2 and PR2, a signal is sent to the 4-bit post-splitter, and only after the post-splitter is full, an interrupt is generated. <br>  Thanks to this scheme, it is possible to adjust the final interrupt frequency with a minimum step. <br><br>  In addition to the post-divider, the signal when PR2 matches can go to the CCP module as the PWM timing base. <br>  Like TMR1, this timer can be disabled. <br><br><h4>  Usage example </h4><br>  As an example, let's set the flashing frequency of the LED with the timer TMR1. <br>  The list of all necessary variables can be found in the table: <br><br><img src="https://habrastorage.org/storage/habraeffect/c6/d1/c6d168a06513c1bd588d748057fcc060.png"><br><br>  A description of each bit can be found in the documentation for the microcontroller. <br><blockquote> <code><font color="#0000FF">include 16f628a -- target PICmicro <br></font> <font color="#008080"><i>-- <br></i></font> <b>pragma</b> <font color="#0000FF">target clock</font> <font color="#FF0000">4_000_000</font> <font color="#008080"><i>--   ,       <br> --   <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> OSC INTOSC_NOCLKOUT <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> WDT <font color="#008000">disabled</font> <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> PWRTE <font color="#008000">disabled</font> <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> MCLR external <font color="#008080"><i>--    <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> BROWNOUT <font color="#008000">disabled</font> <font color="#008080"><i>--      <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> LVP <font color="#008000">disabled</font> <font color="#008080"><i>--     <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> CPD <font color="#008000">disabled</font> <font color="#008080"><i>--  EEPROM  <br></i></font> <b>pragma</b> <font color="#0000FF">target</font> CP <font color="#008000">disabled</font> <font color="#008080"><i>--    <br> -- <br></i></font> enable_digital_io() <font color="#008080"><i>--   \    <br> -- <br></i></font> <b>alias</b> led <b>is</b> pin_B5 <font color="#008080"><i>--    RB5 <br></i></font> pin_B5_direction = <font color="#008000">output</font> <font color="#008080"><i>--  RB5    <br> -- <br> --   <br></i></font> T1CON_T1CKPS = <font color="#FF0000">0b_11</font> <font color="#008080"><i>-- , 2  <br></i></font> T1CON_TMR1CS = <font color="#FF0000">0</font> <font color="#008080"><i>--     <br></i></font> PIE1_TMR1IE = <font color="#008000">on</font> <font color="#008080"><i>--    TMR1 <br></i></font> PIR1_TMR1IF = <font color="#008000">off</font> <font color="#008080"><i>--     TMR1 <br></i></font> INTCON_PEIE = <font color="#008000">on</font> <font color="#008080"><i>--     <br></i></font> T1CON_TMR1ON = <font color="#008000">on</font> <font color="#008080"><i>--   <br></i></font> INTCON_GIE = <font color="#008000">on</font> <font color="#008080"><i>--    <br> <br> -- <br> ;   Fosc/4 : 4MHz/4 = 1 Mhz <br> ;   1:8 : 1Mhz/8 = 125 kHz <br> ; - 16  : 125 kHz/65536 = 1.9 Hz <br> ;     2  :    0,95 Hz <br> -- <br> <br> --   TMR1 <br></i></font> <b>procedure</b> TMR1_ISR <b>is <br> pragma</b> <font color="#0000FF">interrupt <br></font> <b>if</b> PIR1_TMR1IF <b>then</b> <font color="#008080"><i>--      <br></i></font> PIR1_TMR1IF = <font color="#008000">off</font> <font color="#008080"><i>--    <br></i></font> led = !led <font color="#008080"><i>--    <br></i></font> <b>end if <br> end procedure <br> <br> forever loop <br></b> <font color="#008080"><i>--     <br></i></font> <b>end loop <br></b></code> <br></blockquote><br><br><h3>  CCP </h3><br>  The CCP module (Capture / Compare / PWM) is designed for measuring and generating pulse signals. <br><br><h4>  Capture </h4><br>  In capture mode, the module uses TMR1 as a time meter.  As soon as a monitored event occurs on the pin of CCP1 (pin 9), the module will save the current 16-bit value of TMR1 to the registers CCPR1H: CCPR1L. <br>  These events can be: <br><ul><li>  each leading edge of the signal </li><li>  each leading edge of the signal </li><li>  every fourth front </li><li>  every 16 front front </li></ul><br>  By combining events and calculating the difference between the obtained timer values, you can obtain signal data such as period, pulse duration, or duty cycle.  For example, some accelerometers transmit information about the resulting acceleration by changing the signal's duty cycle. <br><br><h4>  Compare </h4><br>  In the compare mode, the module works in the opposite direction: as soon as the value in the CCPR1H: CCPR1L registers coincides with the current TMR1 value, the module can set 1 or 0 on the CCP1 pin (pin 9) or simply generate an interrupt.  Also, if a match occurs, the module may reset TMR1. <br>  By measuring the required time intervals, it is possible to form pulses of a certain shape.  For example, to control the position of a servo, you need to feed high-level pulses of 700-2,200 Œºs with a frequency of 50 Hz to the signal line.  Depending on the pulse length, the servo will set its position either to one extreme position (700 Œºs), or to another (2200 Œºs), or approximately in the center (1500 Œºs). <br><br><h4>  Pwm </h4><br>  In the PWM mode, the module independently generates a signal with a frequency generated by the TMR2 timer and a specified 10-bit duty cycle. <br><br>  What is a PWM signal? <br>  The microcontroller can produce only a digital signal - logical 1 and 0. <br>  In the PWM signal with a constant frequency, the first part of the period is fed to the output 1, and the second part - 0. By varying the ratio of the duration of both parts, the duty ratio changes.  Durability PWM is the ratio of the pulse duration of a logical unit and the PWM period.  10-bit PWM can ensure the accuracy of changing the duty cycle in 1/1024 period duration. <br><br><img src="https://habrastorage.org/storage/habraeffect/94/67/9467731d1762c9591e187b648ddb57b9.png"><br><br>  How can this be used? <br>  Since the frequency of the signal is large enough, it will seem to low-speed loads that they receive a voltage equal to the percentage of duty ratio of the maximum.  Thus, from the PWM we will have a normal analog output with a voltage range from 0 to Vdd (in our case - 5V). <br><br>  For high-speed loads (for example, for LEDs) the PWM signal will adjust the percentage of running time.  For the human eye, the flashing of the LED with a high frequency and a variable porosity will seem to be a constant light with variable brightness. <br><br>  There is a library to work with PWM, so we will not need much effort to calculate and configure the registers. <br>  Example of using the library: <br><blockquote> <code><font color="#008080"><i>--   <br></i></font> pin_CCP1_direction = <font color="#008000">output</font> <font color="#008080"><i>--  pin 9   <br></i></font> <font color="#0000FF">include pwm_hardware --  ,     <br></font> pwm_max_resolution( <font color="#FF0000">4</font> ) <font color="#008080"><i>--    TMR2     (976 Hz) <br></i></font> pwm1_on() <font color="#008080"><i>--   <br> <br></i></font> <b>var bit</b> fade_type = <font color="#FF0000">1</font> <font color="#008080"><i>--      <br></i></font> <b>var byte</b> i = <font color="#FF0000">0</font> <font color="#008080"><i>--      <br></i></font> <br> <b>forever loop <br></b> <font color="#008080"><i>--    <br></i></font> <b>if</b> fade_type <b>then <br></b> i = i + <font color="#FF0000">1 <br></font> <b>if</b> i == <font color="#FF0000">100</font> <b>then <br></b> fade_type = <font color="#FF0000">0 <br></font> <b>end if <br> else <br></b> i = i - <font color="#FF0000">1 <br></font> <b>if</b> i == <font color="#FF0000">0</font> <b>then <br></b> fade_type = <font color="#FF0000">1 <br></font> <b>end if <br> end if <br></b> pwm1_set_percent_dutycycle(i) <font color="#008080"><i>--     <br></i></font> <b>_usec_delay</b> ( <font color="#FF0000">20000</font> ) <font color="#008080"><i>--  ,        <br></i></font> <b>end loop <br></b></code> </blockquote><br><h3>  Comparators </h3><br>  The whole job of the comparator is to compare two voltages and say which one is greater.  The comparison takes place continuously (when the module is turned on), and an interrupt can be generated when the comparison result changes. <br><br><img src="https://habrastorage.org/storage/habraeffect/a0/38/a0383c1b31919b293215c9568404181d.png"><br><br>  Depending on the settings, comparators can operate in eight modes: <br><br><img src="https://habrastorage.org/storage/habraeffect/d2/bd/d2bd9c726fa6c3464a3d8395dc2c9cd4.png"><br><br>  The diagrams clearly show which voltages are compared in each mode, it‚Äôs worth explaining what the reference voltage <strong>Vref is</strong> . <br><br><h4>  Voltage reference </h4><br>  This is another small module, usually required only for the operation of comparators. <br>  The only task of the module is to divide the supply voltage to the desired value. <br>  The module is a simple divider on 16 resistors.  All that he can do is to isolate the voltage that has been lowered to the desired value from the power supply. <br>  When powered at 5V, the module can supply a voltage from 0 to 3.6V. <br><br><h3>  Eeprom </h3><br>  In the microcontroller 16f628a we have 128 bytes of non-volatile memory. <br><br>  When using an assembler, we would have to read a lot about the order of writing and reading in memory, we only need to connect one library to work with eeprom. <br><br>  To connect the library is enough to write <br><blockquote> <code><font color="#0000F0">include pic_data_eeprom</font></code> </blockquote> <br>  after which a number of procedures and functions become available to us: <br><pre> data_eeprom_read ([offset], [byte]) - the procedure reads byte number [offset] and
                                           - puts the result in the variable [byte]
 data_eeprom_write ([offset], [byte]) - the procedure writes the resulting byte [byte] to the place [offset]
 data_eeprom_read_word ([offset], [word]) - the procedure reads 2 bytes: [offset] and [offset] +1 
 data_eeprom_write_word ([ofset], [word]) - the procedure writes 2 bytes in a row
 data_eeprom_read_dword ([offset], [dword]) - the procedure reads 4 bytes in a row
 data_eeprom_write_dword ([offset], [dword]) - the procedure writes 4 bytes in a row
 [byte] = data_eeprom ([offset]) - reading a byte through a function
 [word] = data_eeprom_word ([offset]) - read two bytes through the function
 [dword] = data_eeprom_dword ([offset]) - read 4 bytes through the function </pre><br>  The only thing to remember is the size of the memory.  Write dword at offset 128 in this case will not succeed. <br><br><h3>  Usart </h3><br>  USART is a serial I / O port.  This module is designed to connect the microcontroller with other devices. <br>  To organize a communication channel, all you need to do is connect the <strong>Rx of</strong> each device with the <strong>Tx of the</strong> other. <br>  If you want to customize the mode of operation of the module, you can examine in detail the documentation for the microcontroller, but again we will need only one library. <br>  The only thing we need to specify is the data transfer rate.  The maximum speed depends on the clock signal MK.  At 4 MHz, the recommended speed is 2400. <br><blockquote> <code><b>const</b> serial_hw_baudrate = <font color="#FF0000">2400</font> <font color="#008080"><i>--   <br></i></font> <font color="#0000FF">include serial_hardware --   <br></font> serial_hw_init() <font color="#008080"><i>--    <br></i></font></code> </blockquote><br>  After setup, you can begin to receive and transmit bytes. <br><pre> serial_hw_write ([byte]) - the procedure for sending bytes [byte]
 serial_hw_data = [byte] - sending a byte through a pseudo-variable
 serial_hw_read ([byte]): [boolean] - if there is a byte sent, puts the value in
                                  - variable [byte] and returns true
                                  - if there is no data received, returns false
 serial_hw_data_available - if there are received bytes, this variable returns true, otherwise - false
 [byte] = serial_hw_data - reading a byte through a pseudo-variable, in the absence of 
                                  - received microcontroller bytes will be waiting for them
                                  - when using this method of reading it is necessary to check
                                  - the fact of the arrival of data </pre><br>  To communicate with a computer, you can use UART-COM and UART-USB adapters.  However, no one bothers to collect them yourself according to the schemes: <br><br><img src="https://habrastorage.org/storage/habraeffect/d1/9b/d19bc05eb6f141db636e7e0aeeabfe2d.gif"><img src="https://habrastorage.org/storage/habraeffect/da/cd/dacd410b4b674865a139f88eb8ac2fa3.gif"><br><br><h3>  Outer quartz </h3><br>  As was seen, external quartz is not always necessary.  But there are also such cases when it is required to use an external clock signal. <br><br>  Connect external quartz to the feet of OSC1 and OSC2 (pin16 and pin 15): <br><br><img src="https://habrastorage.org/storage/habraeffect/a3/14/a3144f56c6638a5175c2862bc042da1c.png"><br>  For common quartz resistor is not needed, the capacitance of the capacitors is selected depending on the frequency of the quartz.  Also, depending on the frequency, the mode set in the <strong>OSC</strong> configuration bit is selected: <br><br><img src="https://habrastorage.org/storage/habraeffect/60/89/6089e94c1b334ea09f75a4ef89fd4d7e.png"><br><br>  Instead of quartz, you can also use a ceramic resonator, it already contains capacitors - to connect the resonator, it is enough to connect the third contact to the ground. <br><br><h3>  Results </h3><br>  So we reviewed the basic features of each module in the 16f628a microcontroller.  Of course, in such a short article it is impossible to describe all the details when working with each module, if necessary, detailed information about each module is available in the documentation for each microcontroller. <br><br>  With the current set of peripherals, you can run quite a few different devices, but sometimes it is easier to switch to a more complete microcontroller.  Thanks to universal libraries, to start working with any other supported MK will not be difficult. </div><p>Source: <a href="https://habr.com/ru/post/98147/">https://habr.com/ru/post/98147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../98140/index.html">Laptop as a work of art</a></li>
<li><a href="../98141/index.html">Eric Schmidt: you can entrust us with your information</a></li>
<li><a href="../98142/index.html">How to quickly and free make a stylus for a capacitive screen</a></li>
<li><a href="../98144/index.html">Gnome: enter characters by code</a></li>
<li><a href="../98146/index.html">Anna Chapman about startups</a></li>
<li><a href="../98148/index.html">rss2sms - we receive Habr's news as SMS messages</a></li>
<li><a href="../98149/index.html">Recognizing images</a></li>
<li><a href="../98150/index.html">Video of unreleased Google Voice Desktop</a></li>
<li><a href="../98151/index.html">Google paid $ 700 million for the purchase of ITA Software</a></li>
<li><a href="../98152/index.html">When you need a cool 2. Vane active cooling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>