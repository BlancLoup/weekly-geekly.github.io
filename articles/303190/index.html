<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Containerization mechanisms: cgroups</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the cycle of articles on containerization mechanisms. Last time we talked about the isolation of processes using the namespaces mechanism....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Containerization mechanisms: cgroups</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/40e/7a6/2f0/40e7a62f0009c2a5b6f5119aeaf12c4c.png" alt="containerization mechanisms" width="100%" height="100%"><br><br>  We continue the cycle of articles on containerization mechanisms.  <a href="https://blog.selectel.ru/mexanizmy-kontejnerizacii-namespaces/">Last time</a> we talked about the isolation of processes using the namespaces mechanism.  But for containerization, resource isolation alone is not enough.  If we run any application in an isolated environment, we must be sure that enough resources are allocated to this application and that it will not consume extra resources, thereby disrupting the rest of the system.  To solve this problem, the Linux kernel has a special mechanism - cgroups (short for control groups, control groups).  We will tell about it in today's article. <br><a name="habracut"></a><br><br>  The theme of cgroups today is particularly relevant: a new version of this mechanism, <a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt" rel="nofollow">group v2</a> , was officially added to the core of version 4.5, released in January of this year. <br>  While working on it, cgroups was essentially rewritten. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Why were such radical changes necessary?  To answer this question, let's take a closer look at how the first version of cgroups was implemented. <br><br><h2>  Cgroups: a brief history </h2><br><br>  The development of cgroups was launched in 2006 by Google employees Paul Management and Rohit Set.  The term ‚Äúcontrol group‚Äù was not yet used, and the term ‚Äúprocess containers‚Äù was used instead.  Actually, at first they did not set themselves the goal of creating cgroups in the modern sense.  The original idea was much more modest: to improve the <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/sec-cpuset.html" rel="nofollow">cpuset</a> mechanism, designed to distribute CPU time and memory between tasks.  But over time, everything grew into a larger project. <br><br>  In late 2007, the name of the process containers was replaced by control groups.  This was done to avoid discrepancies in the interpretation of the term ‚Äúcontainer‚Äù (at that time, the OpenVZ project was actively developing, and the word ‚Äúcontainer‚Äù began to be used in a new, modern meaning). <br><br>  In 2008, the cgroups mechanism was officially added to the Linux kernel (version 2.6.24).  What's new in this version of the kernel compared to previous ones? <br><br>  No system call specifically designed to work with cgroups has been added.  The major changes include the cgroups file system, also known as cgroupfs. <br><br>  In init / main.c, references to functions for activating cgoups at boot time were added: cgroup_init and cgroup_init_early.  The functions used to spawn and terminate the process ‚Äî fork () and exit () ‚Äî were slightly modified. <br><br>  There are new directories in the / proc virtual file system: / proc / {pid} / group (for each process) and / proc / cgroups (for the system as a whole). <br><br><h2>  Architecture </h2><br><br>  The cgroups mechanism consists of two components: the core ( <a href="" rel="nofollow">cgroup core</a> ) and the so-called subsystems.  In the kernel version 4.4.0.21 of such subsystems 12: <br><br><ul><li>  <a href="" rel="nofollow">blkio</a> - sets limits on reading and writing from block devices; </li><li>  <a href="" rel="nofollow">cpuacct</a> - generates reports on the use of processor resources; </li><li>  <a href="" rel="nofollow">cpu</a> - provides access of processes within the control group to the CPU; </li><li>  <a href="">cpuset</a> - distributes tasks within the control group between processor cores; </li><li>  <a href="" rel="nofollow">devices</a> - allows or blocks access to devices; </li><li>  <a href="">freezer</a> - suspends and resumes the execution of tasks within the control group </li><li>  <a href="" rel="nofollow">hugetlb</a> - activates support for large memory pages for control groups; </li><li>  <a href="">memory</a> - manages memory allocation for groups of processes; </li><li>  <a href="" rel="nofollow">net_cls</a> - marks network packets with a special tag that allows you to identify packets generated by a particular task within the control group; </li><li>  <a href="" rel="nofollow">netprio</a> - used to dynamically set traffic priorities; </li><li>  <a href="" rel="nofollow">pids</a> - used to limit the number of processes in the control group. </li></ul><br><br>  You can display the list of subsystems on the console using the command: <br><br><pre><code class="bash hljs">$ ls /sys/fs/cgroup/ blkio cpu,cpuacct freezer net_cls perf_event cpu cpuset hugetlb net_cls,net_prio pids cpuacct devices memory net_prio systemd</code> </pre> <br><br>  Each subsystem is a directory with control files in which all settings are written.  Each of these directories contains the following control files: <br><ul><li>  cgroup.clone_children - allows you to pass parent properties to child control groups; </li><li>  tasks - contains a list of PIDs of all processes included in control groups; <br>  cgroup.procs - contains a list of TGIDs of process groups included in control groups; </li><li>  cgroup.event_control - allows you to send notifications when the status of the control group changes; </li><li>  release_agent - contains the command that will be executed if the notify_on_release option is enabled.  It can be used, for example, to automatically remove empty control groups; </li><li>  notify_on_release - contains a boolean variable (0 or 1), including (or vice versa), the execution of the command specified in the release_agent. </li></ul><br><br>  Each subsystem also has its own control files.  We will describe some of them below. <br><br>  To create a control group, it is enough to create a nested directory in any of the subsystems.  Control files will be automatically added to this nested directory (we will tell about it in more detail below).  Adding processes to a group is very simple: you just need to write their PID to the tasks control file. <br><br>  The set of control groups embedded in the subsystem is called a hierarchy. Let's try to understand the principles of cgroups functioning in simple practical examples. <br><br><h2>  Hierarchy cgroups: practical acquaintance </h2><br><br><h3>  Example 1: CPU Management </h3><br><br>  Run the command: <br><br><pre> <code class="bash hljs">$ mkdir /sys/fs/cgroup/cpuset/group0</code> </pre><br><br>  Using this command, we created a control group containing the following control files: <br><br><pre> <code class="bash hljs">$ ls /sys/fs/cgroup/cpuset/group0 group.clone_children cpuset.memory_pressure cgroup.procs cpuset.memory_spread_page cpuset.cpu_exclusive cpuset.memory_spread_slab cpuset.cpus cpuset.mems cpuset.effective_cpus cpuset.sched_load_balance cpuset.effective_mems cpuset.sched_relax_domain_level cpuset.mem_exclusive notify_on_release cpuset.mem_hardwall tasks cpuset.memory_migrate</code> </pre><br><br>  So far, there are no processes in our group.  To add a process, you need to write its PID to the tasks file, for example: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/cpuset/group0/tasks</code> </pre><br><br>  The $$ characters indicate the PID of the process being executed by the current command shell. <br><br>  This process is not assigned to any CPU core, which is confirmed by the following command: <br><br><pre> <code class="bash hljs">$ cat /proc/$$/status |grep <span class="hljs-string"><span class="hljs-string">'_allowed'</span></span> Cpus_allowed: 2 Cpus_allowed_list: 0-1 Mems_allowed: 00000000,00000001 Mems_allowed_list: 0</code> </pre><br><br>  The output of this command shows that for the process of interest to us are available 2 CPU cores with numbers 0 and 1. <br><br>  Let's try to ‚Äútie‚Äù this process to the kernel with the number 0: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 0 &gt;/sys/fs/cgroup/cpuset/group0/cpuset.cpus</code> </pre><br><br>  Check what happened: <br><br><pre> <code class="bash hljs">$ cat /proc/$$/status |grep <span class="hljs-string"><span class="hljs-string">'_allowed'</span></span> Cpus_allowed: 1 Cpus_allowed_list: 0 Mems_allowed: 00000000,00000001 Mems_allowed_list: 0</code> </pre><br><br><h4>  Example 2: memory management </h4><br><br>  We embed the group created in the previous example into one more subsystem: <br><br><pre> <code class="bash hljs">$ mkdir /sys/fs/cgroup/memory/group0</code> </pre><br><br>  Next, run: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/group0/tasks</code> </pre><br><br>  Let's try to limit the memory consumption for the control group group0.  To do this, we need to register the corresponding limit in the memory.limit_in_bytes file: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 40M &gt; /sys/fs/cgroup/memory/group0/memory.limit_in_bytes</code> </pre><br><br>  The cgroups mechanism provides very extensive memory management capabilities.  For example, with its help we can protect critical processes from falling under the hot hand of OOM-killer: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 &gt; /sys/fs/cgroup/memory/group0/memory.oom_control $ cat /sys/fs/cgroup/memory/group0/memory.oom_control oom_kill_disable 1 under_oom 0</code> </pre><br><br>  If we place a separate control group, for example, an ssh-daemon and disable the OOM-killer for this group, then we can be sure that it will not be "killed" by exaggerating the memory consumption. <br><br><h4>  Example 3: Device Management </h4><br><br>  Add our control group to another hierarchy: <br><br><pre> <code class="bash hljs">$ mkdir /sys/fs/cgroup/devices/group0</code> </pre><br><br>  By default, the group has no device access restrictions: <br><br><pre> <code class="bash hljs">$ cat /sys/fs/cgroup/devices/group0/devices.list a *:* rwm</code> </pre><br><br>  Let's try to set restrictions: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'c 1:3 rmw'</span></span> &gt; /sys/fs/cgroup/devices/group0/devices.deny</code> </pre><br><br>  This command will include the / dev / null device in the list of prohibited for our control group.  We have written a line of the form 'c 1: 3 rmw' to the control file.  First, we specify the type of device - in our case, it is a character device, denoted by the letter c (short for character device).  Two other types of devices are block (b) and all possible devices (a).  Then follow the major and minor numbers of the device.  You can check the numbers with the help of the command: <br><br><pre> <code class="bash hljs">$ ls -l /dev/null</code> </pre><br><br>  Instead of / dev / null, of course, you can specify any other path.  The output of this command looks like this: <br><br><pre> <code class="bash hljs">crw-rw-rw- 1 root root 1, 3 May 30 10:49 /dev/null</code> </pre><br><br>  The first digit in the output is the major number, and the second is the minor number. <br><br>  The last three letters indicate the access rights: r - permission to read files from the specified device, w - permission to write to the specified device, m - permission to create new device files. <br><br>  Next, run: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/devices/group0/tasks $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test"</span></span> &gt; /dev/null</code> </pre><br><br>  When executing the last command, the system will display an error message: <br><br><pre> <code class="bash hljs">-bash: /dev/null: Operation not permitted</code> </pre><br><br>  We cannot interact with the device / dev / null, because access is closed. <br><br>  Restore access: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> a &gt; /sys/fs/cgroup/devices/group0/devices.allow</code> </pre><br><br>  As a result of this command, the entry a *: * rwm will be added to the file /sys/fs/cgroup/devices/group0/devices.allow, and all restrictions will be removed. <br><br><h2>  Cgroups and containers </h2><br><br>  From the examples given, it is clear what the principle of cgroups work is: we put certain processes into a group, which we then ‚Äúembed‚Äù into subsystems.  Let us now analyze more complex examples and consider how cgroups are used in modern containerization tools using the example of LXC. <br><br>  Install LXC and create a container: <br><br><pre> <code class="bash hljs">$ sudo apt-get install lxc debootstrap bridge-utils $ sudo lxc-create -n ubuntu -t ubuntu -f /usr/share/doc/lxc/examples/lxc-veth.conf $ lxc-start -d -n ubuntu</code> </pre><br><br>  Let's see what has changed in the cgroups directory after creating and running the container: <br><br><pre> <code class="bash hljs">$ ls /sys/fs/cgroup/memory cgroup.clone_children memory.limit_in_bytes memory.swappiness cgroup.event_control memory.max_usage_in_bytes memory.usage_in_bytes cgroup.procs memory.move_charge_at_immigrate memory.use_hierarchy cgroup.sane_behavior memory.numa_stat notify_on_release lxc memory.oom_control release_agent memory.failcnt memory.pressure_level tasks memory.force_empty memory.soft_limit_in_bytes</code> </pre><br><br>  As you can see, the lxc directory appeared in each hierarchy, which in turn contains the Ubuntu subdirectory.  For each new container, a separate subdirectory will be created in the lxc directory.  The PID of all processes running in this container will be written to the file / sys / fs / cgroup / cpu / lxc / [container name] / tasks <br><br>  You can allocate resources for containers using either the cgroups control files or using the special lxc commands, for example: <br><br><pre> <code class="bash hljs">$ lxc-cgroup -n [ ] memory.limit_in_bytes 400</code> </pre><br><br>  The situation is similar for Docker, systemd-nspawn, and others. <br><br><h2>  Disadvantages of cgroups </h2><br><br>  For almost 10 years of its existence, the cgroups mechanism has been repeatedly criticized.  As the author of an <a href="https://lwn.net/Articles/484251/" rel="nofollow">article on LWN.net</a> noted, the developers of the cgroups core do not actively like cgroups.  The reasons for such a dislike can be understood even from the examples given in this article, although we tried to present them as neutral as possible, without emotion: it is very inconvenient to embed the control group into each subsystem separately.  Looking more closely, we will see that this approach is extremely inconsistent. <br><br>  If we, for example, create a nested control group, then in some subsystems the settings of the parent group are inherited, and in some - not. <br><br>  In the cpuset subsystem, any change in the parent control group is automatically transmitted to the nested groups, but in other subsystems there is no such change and the clone.children parameter must be activated. <br><br>  Talking about the elimination of these and other cgroups flaws was a long time ago in the community of kernel developers: <a href="https://lwn.net/Articles/484254/" rel="nofollow">one of the first texts on this topic</a> dates from the beginning of 2012. <br><br>  The author of this text, Facebook engineer Techjen Heh, explicitly pointed out that the main problem of cgroups is the wrong organization in which subsystems are connected to numerous hierarchies of control groups.  He proposed using one and only one hierarchy, and adding subsystems for each group separately.  This approach led to major changes, including the change of name: the resource isolation mechanism is now called <a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt" rel="nofollow">cgroup</a> (in the singular), and not cgroups. <br><br>  We will understand in more detail the essence of the implemented innovations. <br><br><h2>  Cgroup v2: what's new </h2><br><br>  As noted above, group v2 has been included in the Linux kernel since kernel version 4.5.  In this case, the old version is supported too.  For version 4.6, a patch already exists that can be used to disable support for the first version when the kernel is loaded. <br><br>  Currently, in cgroup v2, you can only work with three subsystems: blkio, memory, and PID.  Already appeared (for now in the test version) patches that allow you to manage CPU resources. <br><br>  Cgroup v2 is mounted using the following command: <br><br><pre> <code class="bash hljs">$ mount -t cgroup2 none [ ]</code> </pre><br><br>  Suppose we mounted cgroup 2 in the / cgroup2 directory.  The following control files will be automatically created in this directory: <br><br><ul><li>  cgroup.controllers - contains a list of supported subsystems; </li><li>  cgroup.procs ‚Äî upon completion of the mount, contains a list of all running processes in the system, including zombie processes.  If we create a group, then such a file will also be created for it;  it will be empty until processes are added to the group; </li><li>  cgroup.subtree_control - contains a list of subsystems activated for this control group;  default is empty. </li></ul><br><br>  These same files are created in each new control group.  Also, the cgroup.events file is added to the group, which is missing in the root directory. <br><br>  A new group is created like this: <br><br><pre> <code class="bash hljs">$ mkdir /cgroup2/group1</code> </pre><br><br>  To add a subsystem for a group, you need to write the name of this subsystem in the cgroup.subtree_control file: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"+pid"</span></span> &gt; /cgroup2/group1/cgroup.subtree_control</code> </pre><br><br>  To delete the subsystem, use the same command, only in place of the plus is minus: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"-pid"</span></span> &gt; /cgroup2/group1/cgroup.subtree_control</code> </pre><br><br>  When a subsystem is activated for a group, additional control files are created in it.  For example, after activating the PID subsystem, the pids.max and pids.current files will appear in the directory.  The first of these files is used to limit the number of processes in a group, and the second one contains information on the number of processes currently included in the group. <br><br>  Within existing groups, you can create subgroups: <br><br><pre> <code class="bash hljs">$ mkdir /cgroup2/group1/subgroup1 $ mkdir /cgroup2/group1/subgroup2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"+memory"</span></span> &gt; /cgroup2/group1/cgroup.subtree_control,</code> </pre><br><br>  All subgroups inherit the characteristics of the parent group.  In the example just given, the PID subsystem will be activated for both group1 and for both subgroups embedded in it;  pids.max and pids.current files will also be added to them.  This can be illustrated using the scheme: <br><br><img src="https://habrastorage.org/files/e23/65e/4e2/e2365e4e2ee341928372e8dad65cb338.png" width="70%"><br><br>  To avoid misunderstandings with nested groups (see above), the following rule applies to cgroup v2: you cannot add a process to a nested group if any subsystem is already activated in it: <br><br><img src="https://habrastorage.org/files/fad/85b/859/fad85b859111419b993146540b526837.png"><br><br>  In the first version of cgroups, a process could belong to several subgroups at the same time, if these subgroups belonged to different hierarchies embedded in different subsystems.  In the second version, one process can belong to only one subgroup, thus avoiding confusion. <br><br><h2>  Conclusion </h2><br><br>  In this article, we described how the cgroups mechanism works and what changes have been made to its new version.  If you have questions and additions - welcome to comments. <br><br>  For anyone who wants to dive deeper into the topic, here is a list of links to interesting materials: <br><br><ul><li>  <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" rel="nofollow">https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt</a> - documentation of the first version of cgroups; </li><li>  <a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt" rel="nofollow">https://www.kernel.org/doc/Documentation/cgroup-v2.txt</a> - cgroup v2 documentation; </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DPzpG40WiEfM" rel="nofollow">https://www.youtube.com/watch?v=PzpG40WiEfM</a> - Techzhen Xe's lecture on cgroup v2 innovations; </li><li>  <a href="https://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf" rel="nofollow">https://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf</a> - Presentation of the cgroup v2 report with detailed explanations of all the innovations and changes. </li></ul><br><br>  If for one reason or another you cannot leave comments here, welcome to <a href="https://blog.selectel.ru/mexanizmy-kontejnerizacii-cgroups/">our corporate blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/303190/">https://habr.com/ru/post/303190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303174/index.html">How to call css-classes</a></li>
<li><a href="../303178/index.html">JS Programming Contest: Word Classifier (Preliminary Results)</a></li>
<li><a href="../303182/index.html">School of Data "Beeline", without a break for the summer</a></li>
<li><a href="../303186/index.html">jQuery UI Datepicker - adding the ability to select multiple dates on one calendar</a></li>
<li><a href="../303188/index.html">Computer science professor "hired" IBM Watson as his assistant</a></li>
<li><a href="../303194/index.html">‚ÄúHello, world!‚Äù As a tool for evaluating programming skills</a></li>
<li><a href="../303196/index.html">The evolution of neural networks for image recognition in Google: Inception-ResNet</a></li>
<li><a href="../303198/index.html">Cybersecurity on endless seas</a></li>
<li><a href="../303200/index.html">What you need to do before putting open source code</a></li>
<li><a href="../303204/index.html">9 secrets of online payments. Part 7: Fraud Monitoring System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>