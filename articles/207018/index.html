<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows Azure Media Services vs. Amazon Elastic Transcoder. Part 1: Windows Azure Media Services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all who have found the strength to look at Habr in the last working week of this year! This time I would like to share with you the experi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows Azure Media Services vs. Amazon Elastic Transcoder. Part 1: Windows Azure Media Services</h1><div class="post__text post__text-html js-mediator-article">  Good day to all who have found the strength to look at Habr in the last working week of this year!  This time I would like to share with you the experience of using services for working with multimedia content provided by cloud providers.  To make the process more interesting, we will look at two cloud providers: Windows Azure Media Services and Amazon Elastic Transcoder.  After that, of course, do not forget to compare them!  So let's go! <br><a name="habracut"></a><br><h4>  Input data </h4><br>  Let the input data for us will be a video file taken with a mobile device in 720p format (Android).  Its duration is 24 seconds, and the size is 13 MB.  We want to convert it to 480p format. <br><br><h4>  Basic interface </h4><br>  So, we will create a new Solution in Visual Studio.  Suppose that a client to work with each cloud provider must implement some basic functionality.  So that, for example, we could easily replace the use of Windows Azure Media Services with Amazon Elastic Transcoder.  Therefore, we will declare the basic interface: <br> <code>public interface IVideoConverter</code> <br> <code>{</code> <br> <code>void Convert(string sourceFile, string destinationFile);</code> <br> <br> <code>void UploadFile(string localFile);</code> <br> <br> <code>void DownloadFile(string localFile);</code> <br> <br> <code>void WaitForConversionToComplete();</code> <br> <code>}</code> <br> <br>  Each client implementing this interface should be able to: <br><ul><li>  UploadFile - upload a file from local storage to the cloud; </li><li>  DownloadFile - download the recoded file from the cloud storage to the local one; </li><li>  Convert - to actually be able to transcode a file from one format to another; </li><li>  WaitForConversionToComplete - wait for the results of the encoding operation. </li></ul><br><br>  The general principle of working with the client will be as follows: <br> <code>IVideoConverter client = new IVideoConverter();</code> <br> <code>client.Convert(‚Äú___‚Äù, ‚Äú___‚Äù);</code> <br> <br>  Accordingly, the Convert method in pseudocode will look like this: <br> <code>public void Convert(string sourceFile, string destinationFile)</code> <br> <code>{</code> <br> <code>//  </code> <br> <code>UploadFile(sourceFile);</code> <br> <br> <code>//  </code> <br> <code>();</code> <br> <br> <code>//  </code> <br> <code>WaitForConversionToComplete();</code> <br> <br> <code>//   </code> <br> <code>DownloadFile(destinationFile);</code> <br> <code>}</code> <br> <br><h4>  Windows Azure Media Services </h4><br>  Let's begin with implementation of the client for work with Windows Azure Media Services.  Before we start writing code, we need to create a new endpoint to work with this Windows Azure service.  To do this, go to the Windows Azure Management Portal and select New -&gt; App Services -&gt; Media Service -&gt; Quick Create. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/36c/aa3/6f7/36caa36f7ee7b2d18fe0dca4df6402b3.png"><br><br>  We need to specify the name of the new service (Name), the region (Region) in which the capacity will be allocated, the storage account (Storage Account), and the subscription (Subscription) in which we want to use Windows Azure Media Services service. <br><br>  Now, to work with the service, we need to get an Account Name and Access Key.  To do this, go to the Media Services section of the Windows Azure Management Portal and click the Manage Keys button. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/634/d45/a14/634d45a1455010cd98536a1c0c1f9b4e.png"><br><br>  After that, in the window that appears, we need to copy the Account Name and Primary Access Key values. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b5/b34/fbe/8b5b34fbefd22c810de02096596a7cc3.png"><br><br>  We define the copied values ‚Äã‚Äãin the constants of our class working with Windows Azure Media Services: <br> <code>public class MediaServicesClient : IVideoConverter</code> <br> <code>{</code> <br> <code>private const string AccountName = "MEDIA_SERVICE_NAME";</code> <br> <code>private const string AccessKey = "MEDIA_SERVICE_KEY";</code> <br> <code>}</code> <br> <br>  So, before proceeding directly to writing the code of the corresponding class, we need to connect the Windows Azure Media Services SDK assembly.  To do this, use the package manager NuGet.  In the context menu of our project, select the item ‚ÄúManage NuGet Packages ...‚Äù.  We are looking for and install the appropriate package: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bf/b39/31f/6bfb3931f0e867197b3ead287433fd57.png"><br><br>  The base object for working with Windows Azure Media Services is MediaContext.  Similar to the DataContext in the Entity Framework.  In the class constructor, create it using AccountName and AccessKey: <br> <code>public MediaServicesClient()</code> <br> <code>{</code> <br> <code>_mediaContext = new CloudMediaContext(AccountName, AccessKey);</code> <br> <code>}</code> <br> <br>  This object will allow us to work with all entities provided by Windows Azure Media Services. <br><br>  The first entity we need is the Media Processor.  All tasks (Tasks) that we send for processing Windows Azure Media Services must be processed by a specific type of processor.  All possible processor variants are presented <a href="http://msdn.microsoft.com/en-us/library/windowsazure/jj129580.aspx">here</a> .  But we are interested in Windows Azure Media Encoder.  This processor is directly responsible for encoding the video stream into various formats.  Add the receipt of the corresponding processor in our constructor: <br> <code>private const string MediaProcessorName = "Windows Azure Media Encoder";</code> <br> <br> <code>public MediaServicesClient()</code> <br> <code>{</code> <br> <code>...</code> <br> <code>_mediaProcessor = GetMediaProcessor();</code> <br> <code>}</code> <br> <br> <code>private IMediaProcessor GetMediaProcessor()</code> <br> <code>{</code> <br> <code>return _mediaContext.MediaProcessors.Where</code> <br> <code>(x =&gt; x.Name == MediaProcessorName)</code> <br> <code>.ToList()</code> <br> <code>.First();</code> <br> <code>}</code> <br> <br>  You also need to create a so-called Asset - a description of the entities that will be used as input or output parameters for the processor.  This object will store references to the used storage account, links to files intended for processing, etc.  Create such an object.  It will store the input parameters, that is, links to files intended for encoding into the format we need. <br> <code>private const string InputAssetName = "MediaServices_InputAsset";</code> <br> <br> <code>private readonly IAsset _inputAsset;</code> <br> <br> <code>public MediaServicesClient()</code> <br> <code>{</code> <br> <code>...</code> <br> <code>_inputAsset = CreateInputAsset();</code> <br> <code>}</code> <br> <br> <code>private IAsset CreateInputAsset()</code> <br> <code>{</code> <br> <code>return _mediaContext.Assets.Create(InputAssetName, AssetCreationOptions.None);</code> <br> <code>}</code> <br> <br>  All coding tasks (Tasks) are performed as part of some job (Job).  Therefore, we need to create such an object: <br> <code>private const string JobName = "MediaServices_Job";</code> <br> <br> <code>private readonly IJob _job;</code> <br> <br> <code>_job = CreateEncodingJob();</code> <br> <br> <code>private IJob CreateEncodingJob()</code> <br> <code>{</code> <br> <code>return _mediaContext.Jobs.Create(JobName);</code> <br> <code>}</code> <br> <br>  Finally, it is necessary to link all the entities that we have created.  Create appropriate tasks for transcoding one video to another.  To do this, we will declare another method that will be called immediately before starting the job (Job) for encoding: <br> <code>private const string PresetName = "H264 Broadband SD 16x9";</code> <br> <br> <code>private void CreateTask()</code> <br> <code>{</code> <br> <code>var task = _job.Tasks.AddNew(</code> <br> <code>TaskName,</code> <br> <code>_mediaProcessor,</code> <br> <code>PresetName,</code> <br> <code>TaskOptions.ProtectedConfiguration);</code> <br> <br> <code>task.InputAssets.Add(_inputAsset);</code> <br> <code>task.OutputAssets.AddNew(OutputAssetName, AssetCreationOptions.None);</code> <br> <code>}</code> <br> <br>  Here you should pay attention to the name Preset, which we ask.  This is an indication of exactly what format we want to recode our video.  A list of all possible options can be found <a href="http://msdn.microsoft.com/en-us/library/windowsazure/jj129582.aspx">here</a> .  According to the condition - we will encode the original video in the format 480p. <br><br>  Thus, having created several tasks (Tasks) for coding into different formats, you can use one source file, say, shot in 1080p. <br><br>  So, all the methods that are specific to working with Windows Azure Media Services we have implemented.  Let us turn to the implementation of the IVideoConverter interface. <br><br>  Since Windows Azure Media Services is working in the cloud, before starting the encoding operation, you need to upload the necessary files to the storage.  The UploadFile method deals with this in our interface.  Actually its implementation: <br> <code>public void UploadFile(string localFile)</code> <br> <code>{</code> <br> <code>var fileName = Path.GetFileName(localFile);</code> <br> <br> <code>var assetFile = _inputAsset.AssetFiles.Create(fileName);</code> <br> <code>assetFile.Upload(localFile);</code> <br> <code>}</code> <br> <br>  We assume that the file name is the key to access the object in the repository.  That is, all objects will be stored in the root container of the repository.  Using Asset for input parameters we add a link to a new object (file name in the storage) and, in fact, we load this file directly into the storage using the Upload method of the AssetFile object. <br><br>  Accordingly, the method of uploading a file from the repository will be similar: <br> <code>public void DownloadFile(string localFile)</code> <br> <code>{</code> <br> <code>var outputAsset = _job.OutputMediaAssets.Single();</code> <br> <code>var outputFile = outputAsset.AssetFiles.ToList().Single(x =&gt; x.Name.Contains(".mp4"));</code> <br> <br> <code>outputFile.Download(localFile);</code> <br> <code>}</code> <br> <br>  Since we have only one output parameter (actually, output Asset), then in the OutputMediaAssets collection corresponding to Job, we get a reference to a single object. <br>  In addition to the output file with the mp4 extension, Asset contains metadata files about the encoding process.  We need to download exactly mp4 file.  As a matter of fact, this is what we do with the Download method of the corresponding AssetFile object. <br><br>  Now we will implement a method that will run the encoding and wait for the results of its execution: <br> <code>public void WaitForConversionToComplete()</code> <br> <code>{</code> <br> <code>_job.StateChanged += JobOnStateChanged;</code> <br> <br> <code>_job.Submit();</code> <br> <br> <code>_job.GetExecutionProgressTask(CancellationToken.None).Wait();</code> <br> <code>}</code> <br> <br>  The Job object provides notification of a change in its state using the corresponding events.  Sign up for this event: <br> <code>private void JobOnStateChanged(object sender, JobStateChangedEventArgs state)</code> <br> <code>{</code> <br> <code>switch (state.CurrentState)</code> <br> <code>{</code> <br> <code>case JobState.Finished:</code> <br> <code>{</code> <br> <code>Console.WriteLine("Conversion complete!");</code> <br> <code>break;</code> <br> <code>}</code> <br> <code>case JobState.Queued:</code> <br> <code>case JobState.Scheduled:</code> <br> <code>case JobState.Processing:</code> <br> <code>{</code> <br> <code>Console.WriteLine("Conversion in progress...");</code> <br> <code>break;</code> <br> <code>}</code> <br> <code>case JobState.Canceled:</code> <br> <code>case JobState.Canceling:</code> <br> <code>case JobState.Error:</code> <br> <code>{</code> <br> <code>Console.WriteLine("An error has been occured during the job execution!");</code> <br> <code>break;</code> <br> <code>}</code> <br> <code>}</code> <br> <code>}</code> <br> <br>  Then we send this task for processing by performing the Submit method.  And wait until the task is completed. <br><br>  Thus, the only method that remains unrealized is Convert.  This method will essentially simply call previously implemented methods in the appropriate order.  Its implementation: <br> <code>public void Convert(string sourceFile, string destinationFile)</code> <br> <code>{</code> <br> <code>Console.WriteLine("Uploading the source file...");</code> <br> <code>UploadFile(sourceFile);</code> <br> <br> <code>Console.WriteLine("Creating processing task...");</code> <br> <code>CreateTask();</code> <br> <br> <code>Console.WriteLine("Starting conversion...");</code> <br> <code>WaitForConversionToComplete();</code> <br> <br> <code>Console.WriteLine("Downloading converted file...");</code> <br> <code>DownloadFile(destinationFile);</code> <br> <code>}</code> <br> <br>  As we can see, everything is quite simple: <br><ol><li>  Uploaded file; </li><li>  Created a coding task; </li><li>  We sent the task for execution and waited for the results; </li><li>  Download the file. </li></ol><br><br>  As a result, calling the Convert method is allowed in the console application, we get the following result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/688/4ae/00f/6884ae00f458f5347a6f6bbf8b919863.png"><br><br>  Compare the source and received files: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d9/9aa/333/3d99aa333ff35068220e93207cd2b213.png"><br><br>  This completes the implementation of the client for working with Windows Azure Media Services.  Next year, we will write a client to work with Amazon Elastic Transcoder.  Do not switch!  All successful working week and happy New Year! <br><br>  <a href="http://habrahabr.ru/company/epam_systems/blog/209012/">Continued ...</a> </div><p>Source: <a href="https://habr.com/ru/post/207018/">https://habr.com/ru/post/207018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207004/index.html">IT systems of large companies can even be hacked by a novice hacker.</a></li>
<li><a href="../207006/index.html">The concept of the perfect messenger</a></li>
<li><a href="../207010/index.html">The case of life, or to the question of choosing antivirus for home use</a></li>
<li><a href="../207012/index.html">Embree 2.1 has been released.</a></li>
<li><a href="../207014/index.html">IBM FlashSystem 820 testing</a></li>
<li><a href="../207020/index.html">The percentage of programming languages ‚Äã‚Äãthat are currently taught in high school</a></li>
<li><a href="../207024/index.html">Things you may not have known about Unity3D</a></li>
<li><a href="../207026/index.html">6 errors reduce the conversion of your store</a></li>
<li><a href="../207030/index.html">Dive into Litecoin, or how to start mining scrypt currency</a></li>
<li><a href="../207032/index.html">Installing the lightweight Jabber Prosody server (v0.9 and v0.10beta)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>