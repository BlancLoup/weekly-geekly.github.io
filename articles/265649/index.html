<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js and Express as they are</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, lovers of our Habroblog and other readers! 

 We plan to once again be noted on the field of unfading Node.js and are considering the possibili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js and Express as they are</h1><div class="post__text post__text-html js-mediator-article">  Hello, lovers of our Habroblog and other readers! <br><br>  We plan to once again be noted on the field of unfading Node.js and are considering the possibility of publishing <a href="http://www.amazon.com/Web-Development-Node-Express-Leveraging/dp/1491949309/">this</a> book: <br><br><img src="https://habrastorage.org/files/136/e4e/e6d/136e4ee6dbdc42349dbe3cb097258944.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since the reader's interest is quite understandable, ‚Äúhow did he shove it all into two hundred pages, and why do I need it?‚Äù  under the cut, we offer the translation of a thorough article by Tomislav Kapan on why Node.js is really needed. <br><a name="habracut"></a><br><br>  <b>Introduction</b> <br><br>  Thanks to the growing popularity, the JavaScript language is actively developing nowadays, and modern web development has dramatically changed from the recent past.  Those things that we can do today on the Web with JavaScript, running on the server, as well as in the browser, it was difficult to imagine a few years ago - at best, such opportunities existed only in sandboxes like Flash or Java Applets. <br>  Before talking in detail about Node.js, you can read about the benefits of <a href="http://www.toptal.com/javascript/guide-to-full-stack-javascript-initjs">using full-window JavaScript</a> .  At the same time, the language and data format (JSON) are closely intertwined, which allows for optimal reuse of development resources.  Since this advantage is inherent not so much in Node.js, as JavaScript as a whole, we will not dwell on this topic in detail.  But therein lies the key advantage that you gain by incorporating the Node into your stack. <br><br>  <a href="https://en.wikipedia.org/wiki/Node.js">Wikipedia</a> reads: ‚ÄúNode.js is a package that includes Google‚Äôs JavaScript V8 engine, the platform‚Äôs level of abstraction is the libuv library, and the core library, which is itself written in JavaScript.‚Äù In addition, it should be noted that Ryan Dahl, the author of Node .js, wanted to create real-time, push-enabled sites, inspired by apps like Gmail. ‚Äù  In Node.js, he provided programmers with a tool for working with the non-blocking, event-oriented I / O paradigm. <br><br>  After 20 years of the domination of the paradigm of ‚Äústateless stateless web applications based on request-response stateless communication‚Äù, we finally have real-time bidirectional communication applications. <br>  In short: Node.js shines <b>in real-time applications, as it uses push technology via web sockets</b> .  What is so revolutionary about this?  Well, as already mentioned, after 20 years of using the aforementioned paradigm, such bidirectional applications have appeared, where a connection can initiate both a client and a server, and then proceed to the free exchange of data.  Such technology contrasts sharply with the typical paradigm of web responses, where the client always initiates communication.  In addition, the whole technology is based on an open web stack (HTML, CSS and JS), the work goes through the standard port 80. <br><br>  A reader may argue that we have had all this for more than one year - in the form of Flash and Java applets - but in fact they were just sandboxes that used the Web as a transport protocol for delivering data to the client.  In addition, they worked in isolation and often operated through non-standard ports, which could require additional access rights, etc. <br>  For all its merits, Node.js currently plays a key role in the technological stack of <a href="https://www.quora.com/What-companies-are-using-Node-js-in-production">many prominent companies</a> that directly depend on the unique properties of Node. <br><br>  In this article, we‚Äôll talk not only about how these benefits are achieved, but also why you might prefer Node.js - or opt out - taking as an example a few classic models of web applications. <br>  How it works? <br><br>  The main idea of ‚Äã‚ÄãNode.js is to use non-blocking event-oriented I / O to remain lightweight and efficient when handling applications that process large amounts of real-time data and operate on distributed devices. <br><br>  Spacious. <br><br>  In essence, this means that Node.js is not a platform for all occasions that will dominate the world of web development.  <b>On the contrary, it is a platform for solving strictly defined tasks</b> .  To understand this is absolutely necessary.  Of course, you should not use Node.js for operations that intensively load the processor, moreover, the use of Node.js in heavy computations virtually nullifies all its advantages.  Node.js is really good for creating fast, scalable network applications, because it allows you to simultaneously handle a huge number of high bandwidth connections, which is equivalent to high scalability. <br><br>  The subtleties of the work of Node.js "under the hood" are quite interesting.  Compared to traditional web services, where each connection (request) generates a new thread, loading the system‚Äôs RAM and, finally, sorting out this memory without a trace, Node.js is much more economical: it works in a single stream, it uses non-blocking I / O allows you to support tens of thousands of competitive connections (which exist in <a href="https://en.wikipedia.org/wiki/Node.js">the event loop</a> ). <br><br><img src="https://habrastorage.org/files/a57/d81/149/a57d81149d874a7ab1dbde76c07a13ce.png"><br><br>  Simple calculation: let's say each stream can potentially request <a href="http://nodejs.org/about/">2 MB of memory</a> and works in a system with 8 GB of RAM.  In this case, we can theoretically expect a maximum of 4,000 concurrent connections, plus the cost of <a href="http://www.slideshare.net/marcusf/nonblocking-io-event-loops-and-nodejs">context switching between threads</a> .  It is with this scenario that one has to deal with using traditional web services.  By avoiding all of this, Node.js can scale to more than a million competitive connections (as an <a href="http://blog.caustik.com/2012/08/19/node-js-w1m-concurrent-connections/">experiment to validate the concept</a> ). <br><br>  Of course, the question arises about the separation of a single stream between all client requests, this is the main "trap" when writing applications using Node.js.  First, complex calculations can clog a single Node.js thread, which is fraught with problems for all clients (more on this below), since incoming requests will be blocked until the requested calculation is completed.  Secondly, developers should be very careful and not allow exceptions to pop up to the base (topmost) Node.js event cycle, because otherwise the Node.js instance will end (in fact, the entire program will crash). <br><br>  To avoid exceptions that pop up to the surface itself, the following technique is used: errors are sent back to the caller as callback parameters (and not thrown away, as in other environments).  In case any unhandled exception skips and pops up, there are <a href="http://shapeshed.com/uncaught-exceptions-in-node/">many paradigms and tools</a> that allow you to monitor the Node process and perform the necessary restoration of an abnormally terminated instance (although user sessions cannot be restored at the same time).  The most common of these are the <a href="http://blog.nodejitsu.com/keep-a-nodejs-server-up-with-forever">Forever module</a> , or work using external system tools <a href="http://howtonode.org/deploying-node-upstart-monit">upstart and monit</a> . <br><br>  <b>NPM: Package Manager Node</b> <br><br>  When discussing Node.js, you just need to mention the built-in support for package management that exists in it, for which the <a href="http://docs.nodejitsu.com/articles/getting-started/npm/what-is-npm">NPM</a> tool is used, which by default is present in any Node.js installation.  The idea behind NPM modules is in many ways similar to Ruby Gems: it‚Äôs a set of reusable, publicly available components that are easy to install via an online repository;  they support version and dependency management. <br><br>  A complete list of packaged modules is available on the NPM site <a href="https://npmjs.org/">npmjs.org</a> , and is also available using the NPM CLI tool, which is automatically installed along with Node.js.  The module ecosystem is completely open, anyone can publish their own module in it, which will appear in the list of NPM repository.  A brief introduction to NPM (a bit oldish, but still relevant) is on <a href="http://howtonode.org/introduction-to-npm">howtonode.org/introduction-to-npm</a> . <br>  Some of the most popular modern NPM modules: <br><br><ul><li>  <a href="http://expressjs.com/">express</a> : Express.js, a web development framework for Node.js, written in the spirit of Sinatra, is the de facto standard for most Node.js applications that exist today. </li><li>  <a href="http://www.senchalabs.org/connect/">connect</a> : Connect is an extensible framework that works with Node.js as an HTTP server, providing a collection of high-performance "plug-ins", collectively known as middleware;  serves as the basis for express. </li><li>  <a href="http://socket.io/">socket.io</a> and <a href="https://github.com/sockjs">sockjs</a> are the back end of the two most common web socket components today. </li><li>  <a href="http://jade-lang.com/">Jade</a> is one of the most popular template engines written in the spirit of HAML, the default is used in Express.js. </li><li>  <a href="https://npmjs.org/package/mongodb">mongo</a> and <a href="https://github.com/gett/mongojs">mongojs</a> are MongoDB wrappers providing APIs for MongoDB object databases in Node.js. </li><li>  <a href="https://github.com/mranney/node_redis">redis</a> is the Redis client library. </li><li>  <a href="https://npmjs.org/package/coffee-script">coffee-script</a> is a CoffeeScript compiler that allows developers to write programs with Node.js using Coffee. </li><li>  <a href="https://npmjs.org/package/underscore">underscore</a> ( <a href="http://lodash.com/">lodash</a> , <a href="https://npmjs.org/package/lazy">lazy</a> ) - The most popular JavaScript helper library, packaged for use with Node.js, as well as two similar libraries that provide <a href="http://philosopherdeveloper.com/posts/introducing-lazy-js.html">enhanced performance</a> , because they are implemented a little differently. </li><li>  <a href="https://www.npmjs.com/package/forever">forever</a> - Probably the most common utility that provides uninterrupted script execution on a given node.  Maintains the performance of your Node.js process in case of any unexpected failures. </li></ul><br><br>  The list goes on.  There are many generally available useful packages, it is simply impossible to list them all here. <br><br>  <i><b>When should Node.js be used?</b></i> <br><br>  <b>CHAT</b> <br><br>  Chat is the most typical multi-user real-time application.  From IRC (there were times) using a variety of open and open protocols that function through non-standard ports, we have come to modern times when everything can be implemented on Node.js using web sockets operating through standard port 80. <br><br>  Chat software is really the ideal product for using Node.js: it is a lightweight, high-traffic application that intensively processes data (but does not consume any computing power) and runs on many distributed devices.  In addition, it is very convenient to learn, as with all its simplicity it covers most of the paradigms that you might need to use in a typical Node.js application. <br><br>  Let's try to depict how it works. <br><br>  In the simplest case, we have the only chat room on the site where users come and exchange messages in the ‚Äúone to many‚Äù mode (in fact, ‚Äúto all‚Äù).  Suppose we have three visitors on our site, and they all can write messages on our forum. <br><br>  On the server side, we have a simple <a href="http://expressjs.com/">Express.js</a> application that implements two things: 1) the GET '/' request handler, which serves the web page that hosts both the message forum and the 'Send' button, which initializes the new message entered and 2) a web socket server listening to new messages issued by web socket clients. <br><br>  On the client side, we have an HTML page that has two handlers configured: one of them listens for click events on the 'Send' button, which picks up the entered message and drops it onto the web socket, and the other listens for new incoming messages on the client for maintenance Web sockets (i.e., messages sent by other clients that the server is about to display using this special client). <br><br>  This is what happens when one of the clients sends a message: <br><br><ol><li>  The browser picks up a click on the 'Send' button using a JavaScript handler, retrieves the value from the input field (ie, the message text) and issues a web socket message using the web socket client connected to our server (this client is initialized together with a web page). </li><li>  The server component of the web socket connection receives the message and forwards it to all other connected clients by the broadcast method. </li><li>  All clients receive a push message using a web socket component running on a web page.  Then they pick up the content of the message and update the web page, adding a new entry to the forum. </li></ol><br><br><img src="https://habrastorage.org/files/7c5/01b/c66/7c501bc662e0427b907bc94b4a595346.png"><br><br>  This is the <a href="http://net.tutsplus.com/tutorials/javascript-ajax/real-time-chat-with-nodejs-socket-io-and-expressjs/">simplest example</a> .  For a more <a href="http://jinzhang.me/posts/2013/sockjs-redis-nodejs-tutorial/">reliable solution,</a> you can use a simple cache based on Redis storage.  An even more advanced solution is a message queue that allows you to process message routing to clients and provide a more reliable delivery mechanism that can compensate for temporary connection breaks or store messages for registered clients while they are offline.  But no matter what optimizations you perform, Node.js will still act according to the same basic principles: react to events, handle many competitive connections, and maintain smooth user interactions. <br><br>  <b>API OVER THE OBJECT DATABASE</b> <br><br>  Although Node.js is especially good in the context of real-time applications, it is also quite suitable for providing information from object databases (for example, MongoDB).  Data stored in the JSON format allows Node.js to function without loss of compliance and without data conversion. <br><br>  For example, if you use Rails, then you would have to convert JSON to binary models, and then submit them again as JSON over HTTP, when the data will be consumed by Backbone.js, Angular.js, or even by regular jQuery AJAX calls.  Working with Node.js, you can simply provide your JSON objects to the client through the REST API so that the client consumes them.  In addition, you don‚Äôt have to worry about converting between JSON and anything else when reading a database and writing to it (if you use MongoDB).  So, you do without a lot of transformations using the universal data serialization format used on the client, on the server, and in the database. <br><br>  <b>ENTRY TURN</b> <br><br>  If you get large amounts of concurrent data, then the database can become a bottleneck.  As shown above, Node.js easily handles competitive connections as such.  But since accessing the database is a blocking operation (in this case), we have problems.  The solution is to record the client's behavior before the data is actually written to the database. <br><br>  With this approach, the responsiveness of the system is maintained under high load, which is especially useful if the client does not need confirmation that the data record was successful.  Typical examples: logging or recording user activity data (user tracking), processed on a batch basis and not used afterwards;  operations, the result of which should be reflected instantly (for example, updating the number of likes on Facebook), where <a href="http://www.allthingsdistributed.com/2007/12/eventually_consistent.html">consistency is ultimately</a> acceptable, which is so often used in the world of NoSQL. <br><br>  The data is lined up using a special infrastructure for caching and working with message queues (for example, <a href="http://www.rabbitmq.com/">RabbitMQ</a> , <a href="http://zeromq.org/">ZeroMQ</a> ) and is digested by a separate database process intended for packet writing or by special database interface services designed for intensive calculations.  Similar behavior can be realized with the help of other languages ‚Äã‚Äã/ frameworks, but on different hardware and not with such high and stable bandwidth. <br><br><img src="https://habrastorage.org/files/79a/d99/ee9/79ad99ee97fc4edf8fd82994356b94ee.png"><br><br>  In short, Node allows you to postpone write operations to the database for later, continuing to work in this mode, as if these records were completed successfully. <br><br>  <b>DATA TRANSFER</b> <br><br>  On more traditional web platforms, HTTP requests and responses are treated as isolated events;  but in fact they are streams.  This point can be used in Node.js to create some cool features.  For example, you can process files while they are still being uploaded, since data is being streamed and we can work with them online.  This can be done, for example, when <a href="https://transloadit.com/blog/2010/12/realtime-encoding-over-150x-faster/">encoding video or audio in real time</a> , as well as when installing a proxy between different data sources (for details, see the next section). <br><br>  <b>PROXY</b> <br><br>  Node.js can be used as a server proxy, and in this case it can handle a large number of simultaneous connections in non-blocking mode.  This is especially useful when mediating between different services, which have different response times, or when collecting data from multiple sources. <br>  For example, let's consider a server application that exchanges information with third-party resources, collects information from various sources, or stores resources such as images and video, which are then provided to third-party cloud services. <br><br>  Although there are dedicated proxy servers, it is convenient to use Node instead, especially if the proxy infrastructure does not exist, or if you need a solution for local development.  Here, I mean that you can create a client application where the Node.js development server will be used, where we will store resources and make proxies / stubs for requests to the API, and in real life such interactions will already be performed using a dedicated proxy service (nginx, HAProxy, etc.) <br><br>  <b>INFORMATION PANEL EXCHANGE TRADER</b> <br><br>  Let's go back to the application level.  Another segment where PC programs dominate, but they can easily be replaced by a real-time web solution - this is trading software, where quotes are tracked, calculations and technical analysis are performed, and charts and diagrams are drawn. <br>  If you use a real-time web solution in such a case, the broker using it can easily switch between workstations or sites.  Soon we will begin to notice such brokers on the beaches of Florida ... Ibiza ... Bali. <br><br>  <b>PANEL FOR MONITORING APPLICATIONS</b> <br><br>  This is another practical case for which the ‚ÄúNode + Web Sockets‚Äù model is ideal.  Here we monitor site visitors and visualize their interactions in real time (if you are interested in such an idea, then it is already solved with the help of <a href="http://projects.nuttnet.net/hummingbird/">Hummingbird</a> ). <br><br>  You can collect statistics about the user in real time and even go to a higher level by adding targeted visitor interactions to the program, opening a communication channel as soon as the guest reaches a specific point in your funnel (if you are interested in this idea, then it is already solved with <a href="http://canddi.com/">CANDDi</a> ). <br><br>  Imagine how you could optimize your business if you could find out in real time what your users are doing - and also visualize their interactions.  Bidirectional Node.js sockets offer you this opportunity. <br><br>  <b>INFORMATION PANEL FOR TRACKING SYSTEM</b> <br><br>  Now let's talk about the infrastructure aspects.  Suppose there is a SaaS provider who wants to offer users a page for tracking services (say, the <a href="https://status.github.com/">GitHub status page</a> ).  With the Node.js event loop, you can create a powerful web-based interface, where service states will be asynchronously checked in real time, and data will be sent to the client via web sockets. <br><br>  This technology allows you to report on the status of both internal (intra-corporate) and publicly available services in real time.  Let's develop this idea a bit and try to introduce a <a href="https://en.wikipedia.org/wiki/Network_operations_center">network operations center (NOC)</a> that tracks the work of the telecom operator's applications, cloud service provider / hosting provider, or some financial institution.  All this works in an open web stack based on Node.js and web sockets, not Java and / or Java applets. <br><br>  Note: Do not attempt to create hard real-time systems on the Node (i.e., requiring well-defined response times).  Perhaps, such applications are <a href="http://nodeguide.com/convincing_the_boss.html">better developed on Erlang</a> . <br><br>  <i><b>Where can I use Node.js</b></i> <br><br>  <b>SERVER WEB APPLICATIONS</b> <br><br>  Node.js with Express.js can also be used to create classic web applications on the server side.  However, even if it is possible, such a request / response paradigm, where Node.js will transfer the rendered HTML, is not typical for this technology.  There are arguments both in favor of this approach and against it.  Please note the following: <br><br>  Behind: <br><br><ul><li>  If your application does not perform intensive computations that load the processor, you can write it completely in JavaScript, including even the database, if you use an object database (for example, MongoDB) and JSON.  This greatly simplifies not only the development, but also the selection of specialists. </li><li>  Search robots receive in return fully rendered HTML, which is much more convenient for search engine optimization than, for example, working with single-page applications or a web socket application running on Node.js. </li><li>  Any intensive computations that load the processor will block Node.js agility, so in this case it is better to use a multi-threaded platform.  You can also try horizontal scaling calculations [*]. </li><li>  Using Node.js with a relational database is still rather inconvenient (see below for more details).  Do yourself a favor and choose some other medium, such as Rails, Django, or ASP.Net MVC, if you are going to do relational operations. </li></ul><br><br>  [*] As an alternative to such CPU-intensive calculations, you can create a highly scalable MQ environment with processing on the database interface so that Node remains at the forefront and asynchronously processes client requests. <br><br>  <i><b>When should Node.js be used?</b></i> <br><br>  SERVER WEB APPLICATION FOR WHICH RELATIONAL DATABASE IS LOCATED <br><br>  Comparing Node.js plus Express.js with Ruby on Rails, we confidently choose the second option when it comes to accessing relational data. <br><br>  The relational database tools for Node.js are still in their infancy, and working with them is rather unpleasant.  On the other hand, Rails automagically configures data access right at installation, plus it provides tools to support database schema migrations and other Gems.  Rails and related frameworks have mature and proven implementations of access to the data layer (Active Record or Data Mapper), which you will be sorely lacking if you try to reproduce such a construct in pure JavaScript. [*] <br><br>  Still, if you are firmly committed to doing everything in JavaScript, pay attention to <a href="http://docs.sequelizejs.com/en/latest/">Sequelize</a> and <a href="https://github.com/dresende/node-orm2">Node ORM2</a> - both tools are not devoid of roughness, but over time they may ripen. <br><br>  [*] Node can be used exclusively in the client part (and this is often done), and the machine interface can be executed on Rails, thus maintaining easy access to the relational database. <br><br>  <b>COMPLEX SERVER CALCULATIONS AND PROCESSING</b> <br><br>  When it comes to complex calculations, Node.js leaves much to be desired.  Of course, you are not going to program a Node <a href="http://zef.me/4561/node-js-and-the-case-of-the-blocked-event-loop">server for Fibonacci calculations</a> .  In principle, any computational operations that heavily load the processor devalue the gain in throughput, which in Node is achieved thanks to event-oriented non-blocking I / O.  The point is that any incoming requests will be blocked, while a single stream is busy digesting numbers. <br><br>  As mentioned above, Node.js is single-threaded and uses only one processor core.  You may need to implement competition on a multi-core server, for this the Node kernel development team is already preparing a special cluster module.  In addition, you could easily run multiple instances of the Node.js server behind the <a href="http://blog.argteam.com/coding/hardening-node-js-for-production-part-2-using-nginx-to-avoid-node-js-load/">reverse proxy using nginx</a> . <br><br>  When clustering, it is possible to unload all complex calculations into background processes running in a more suitable environment, and to ensure communication between them through a message queue server, for example, RabbitMQ. <br><br>  Although initially your background processing could run all on the same server, this approach provides very high scalability.  Such background processing services can easily be distributed to separate working servers without the need to configure the load on the front-facing web servers. <br><br>  Of course, such an approach is also appropriate on other platforms, but in the case of Node.js, that same huge bandwidth, which we mentioned above, is acquired, since each request is a small task that is processed very quickly and efficiently. <br><br>  <i><b>Conclusion</b></i> <br><br>  We discussed Node.js from a theoretical and practical point of view, starting with its goals and purpose and ending with a conversation about all sorts of goodies and pitfalls.  If you have problems with Node.js, then remember that they almost always boil down to the following fact: <b>blocking operations are the cause of all ills</b> .  In 99% percent of cases, all problems begin due to misuse of the Node. <br><br>  Remember: Node.js was never intended to solve the problem of scaling computing.  It was created to scale I / O, which really <a href="http://www.srirangan.net/2012-05-node-js-critics-which-part-of-event-driven-non-blocking-io-model-you-dont-understand">handles very well</a> . <br><br>  Why use Node.js?  If your task does not involve intensive calculations and access to blocking resources, then you can fully take advantage of Node.js and enjoy fast and easily scalable web applications. </div><p>Source: <a href="https://habr.com/ru/post/265649/">https://habr.com/ru/post/265649/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265635/index.html">Navigation in major projects for Vim and Emacs</a></li>
<li><a href="../265639/index.html">Application for replacing SMS and Email notifications on mobile devices</a></li>
<li><a href="../265641/index.html">Improved tab selection in the assembly Vivaldi 1.0.258.3</a></li>
<li><a href="../265645/index.html">Digest of useful materials for iOS developers</a></li>
<li><a href="../265647/index.html">AMI. Versatile Originate. CTI application</a></li>
<li><a href="../265651/index.html">Case "Visualization. What is the benefit for a retailer? ‚Äù</a></li>
<li><a href="../265653/index.html">3CX API - what are they and what to do with them? (Part 1)</a></li>
<li><a href="../265655/index.html">Thousand and one blister. Search for overpriced drugs</a></li>
<li><a href="../265657/index.html">Interview with the co-founder of the service to increase the conversion of mobile applications SplitMetrics</a></li>
<li><a href="../265661/index.html">"Who is on the first base" - a new geographical reference from Mapzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>