<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LibGDX Tutorial Translation - Part 2 (Drawing Images)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the translation of the second tutorial on libGDX. The original is here . The first part is here . 

 This tutorial gives an idea of ‚Äã...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LibGDX Tutorial Translation - Part 2 (Drawing Images)</h1><div class="post__text post__text-html js-mediator-article">  I present to you the translation of the second tutorial on libGDX.  The original is <a href="http://code.google.com/p/libgdx/wiki/SpriteBatch">here</a> .  The first part is <a href="http://habrahabr.ru/post/142976/">here</a> . <br><br>  This tutorial gives an idea of ‚Äã‚Äãhow to draw images using OpenGL and how libGDX simplifies and optimizes this process using the SpriteBatch class. <br><br><h4>  Drawing images. </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The image obtained from its original format (for example, PNG) and uploaded to the GPU is called a texture.  Textures are drawn according to some specification, which is a description of a geometric figure and how the texture is superimposed on the vertices of this figure.  For example, a geometric shape can be a rectangle, and each corner of the rectangle refers to the corresponding angle of the texture. <br><a name="habracut"></a><br><br>  For drawing, it is necessary that the texture be made current (attached) and that geometry is specified.  The size and location of the place where the texture will be displayed are determined by the geometry and setting of the OpenGL viewport.  Many 2D games customize the viewport so that it matches the screen resolution.  This means that the geometry is defined in pixels, which makes it easy to draw textures of the appropriate size and in the right place on the screen. <br><br>  Very often texture drawing takes place in a rectangular geometry.  Also very often one texture or its different parts are drawn many times.  It is inefficient to send a single rectangle for drawing to the GPU.  Instead, many rectangles for one texture can be described and sent to the GPU all together.  This is what the SpriteBatch class does. <br><br>  SpriteBatch gets the texture and coordinates of each rectangle where this texture will be displayed.  It accumulates this information without being sent to the GPU.  When it receives a texture that is different from the last loaded texture, it activates the last loaded texture, sends the accumulated drawing information to the GPU, and begins to accumulate drawing data for the next texture. <br><br>  Changing the texture every few rectangles that need to be drawn prevents SpriteBatch from grouping a lot of rectangles.  Also, texture snapping is quite an expensive operation.  Considering these reasons, they often store many small images in one large image and then draw parts of a large image, maximizing the number of accumulated rectangles for drawing and avoiding texture changes.  See <a href="http://code.google.com/p/libgdx/wiki/TexturePacker">TexturePacker</a> for more details. <br><br><h5>  SpriteBatch (sprite packer) </h5><br><br>  Using the SpriteBatch class in an app looks like this: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SpriteBatch batch; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ batch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteBatch(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT); <span class="hljs-comment"><span class="hljs-comment">//     batch.begin(); //   ! batch.end(); } public void resize (int width, int height) { } public void pause () { } public void resume () { } public void dispose () { } }</span></span></code> </pre> <br><br>  All SpriteBatch calls for rendering should be enclosed between the begin () and end () methods.  Calls to methods for drawing by other means (not the SpriteBatch class) should not occur between the begin () and end () methods. <br><br><h5>  Texture </h5><br><br>  The Texture class gets an image from a file, and loads it into the GPU.  The image file must be located in the "assets" directory, as described in (REFERENCE) Project Setup.  Image sizes should be a power of two (16x16, 64x256, etc.). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Texture texture; ... texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(Gdx.files.internal(<span class="hljs-string"><span class="hljs-string">"image.png"</span></span>)); ... batch.begin(); batch.draw(texture, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); batch.end();</code> </pre><br><br>  This creates a texture and sends it to the SpriteBatch class for drawing.  The texture is drawn in a right-angled, the lower left corner of which is located at the point (10, 10), with a width and height equal to the size of the texture.  SpriteBatch has many methods for drawing textures: <br><br><pre> <code class="java hljs">draw(Texture texture, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y)</code> </pre>  Draws a texture at x, y, using texture dimensions. <br><br><pre> <code class="java hljs">draw(Texture texture, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcX, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcY, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcHeight)</code> </pre>  Draws a piece of texture. <br><br><pre> <code class="java hljs">draw(Texture texture, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcX, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcY, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcHeight, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flipX, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flipY)</code> </pre>  Draws a part of the texture that is stretched to the width * height, and possibly reflected. <br><br><pre> <code class="java hljs">draw(Texture texture, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originX, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originY, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scaleX, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scaleY, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcX, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcY, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcHeight, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flipX, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flipY)</code> </pre>  This monstrous method draws a part of the texture with the possibility of compression (stretching), rotation around a point and the possibility of reflection. <br><br><pre> <code class="java hljs">draw(Texture texture, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u2, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v2)</code> </pre>  Draws a part of the texture stretched to the width * height.  This is a more advanced method.  Coordinates are not in pixels, but in real numbers. <br><br><pre> <code class="java hljs">draw(Texture texture, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] spriteVertices, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length)</code> </pre>  Draws a part of the texture, ‚Äúdragging‚Äù it onto the shape specified in spriteVerticles <br><br><h5>  TextureRegion (region of the texture or part of the texture) </h5><br><br>  The TextureRegion class describes a rectangle inside a texture and is used to draw only parts of the texture. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TextureRegion region; ... texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(Gdx.files.internal(<span class="hljs-string"><span class="hljs-string">"image.png"</span></span>)); region = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextureRegion(texture, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); ... batch.begin(); batch.draw(region, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); batch.end();</code> </pre><br><br>  Here 20, 20, 50, 50 describes the part of the texture, which will then be drawn at the point (10, 10).  The same action can be done by passing the texture and additional parameters to the SpriteBatch class, but the TextureRegion class makes it more convenient, since it is easier to define a single object and work with it than to remember about a bunch of additional parameters. <br><br>  SpriteBatch has many methods for drawing a TextureRegion: <br><br><pre> <code class="java hljs">draw(TextureRegion region, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y)</code> </pre>  - draws a region using the width and height of the region. <br><br><pre> <code class="java hljs">draw(TextureRegion region, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height)</code> </pre>  - draws a region compressed (stretched) to the size of width and height. <br><br><pre> <code class="java hljs">draw(TextureRegion region, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originX, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originY, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scaleX, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scaleY, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation)</code> </pre>  - draws a region stretched (compressed) to width and height, with the possibility of scaling and rotation relative to the point originX, originY. <br><br><h5>  Sprite (Sprite) </h5><br><br>  The Sprite class describes the region of the texture, the position where this region will be drawn and the color it will be for the region (the color for tinting is color shading). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Sprite sprite; ... texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(Gdx.files.internal(<span class="hljs-string"><span class="hljs-string">"image.png"</span></span>)); sprite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(texture, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); sprite.setPosition(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); sprite.setRotation(<span class="hljs-number"><span class="hljs-number">45</span></span>); ... batch.begin(); sprite.draw(batch); batch.end();</code> </pre><br><br>  Here 20, 20, 50, 50 describes the region of the texture that will be rotated 45 degrees and then drawn at (10, 10).  The same can be done by passing the texture or part of it to SpriteBatch and passing other parameters, but the Sprite class makes it more convenient because you store all the parameters in one place.  Also, due to the fact that the Sprite class stores geometry within itself and recalculate it only if necessary, this slightly improves performance in scaling, rotating, or other properties that do not change between frames. <br><br>  It should be noted that the Sprite class mixes information about the model (location, information about rotation and others) with information about the view (the texture was drawn by the same class).  This makes it inappropriate to use Sprite in architecture where you want to strictly separate the model from the presentation.  In this case, using the Texture class or TextureRegion can make more sense. <br><br><h5>  Tinting (color (shading) color) </h5><br><br>  When the texture is drawn, it can be painted over with a specific color: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Texture texture; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TextureRegion region; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Sprite sprite; ... texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(Gdx.files.internal(<span class="hljs-string"><span class="hljs-string">"image.png"</span></span>)); region = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextureRegion(texture, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); sprite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(texture, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); sprite.setPosition(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); sprite.setColor(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); ... batch.begin(); batch.setColor(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); batch.draw(texture, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); batch.setColor(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); batch.draw(region, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); sprite.draw(batch); batch.end();</code> </pre><br><br>  This code shows how to draw a texture, its region and a sprite with a coloring color.  The color is described in the RGBA model, where each component lies in the range from 0 to 1. The alpha channel is ignored if blending is turned off. <br><br><h5>  Blending </h5><br><br>  Blending is enabled by default.  This means that when a texture is drawn, the transparent parts of this texture can be combined from the pixels that are already drawn on the screen in this place. <br><br>  When blending is turned off, everything that was on the screen is erased by the texture that is drawn in this place.  This is more efficient and, thus, you can always turn off the mixing, if you do not need it.  For example, if you draw a large background image on the full screen, performance can be improved primarily by disabling blending: <br><br><pre> <code class="java hljs">Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT); <span class="hljs-comment"><span class="hljs-comment">//     batch.begin(); batch.disableBlending(); backgroundSprite.draw(batch); batch.enableBlending(); //     batch.end();</span></span></code> </pre><br><br>  Note.  Make sure the screen is cleared every frame.  If this is not the case, the alpha channel texture will be drawn on top of itself many times, which will give the wrong effect.  Also, some graphics accelerator architectures work better if you clear the screen every frame, instead of drawing the image on the whole screen. <br><br><h5>  Viewport (viewport) </h5><br><br>  SpriteBatch has its own projection and transformation matrix.  When a SpriteBatch is created, it uses the dimensions of the current application to adjust the orthogonal projection using the coordinate system with the Y axis pointing up (i.e., 0, 0 is the bottom left corner of the screen - interpreter's note).  When the begin () method is called, SpriteBatch sets its viewport. <br><br>  Note.  As soon as more detailed documentation on the viewing area appears, it will be posted here. <br><br><h5>  Performance improvement. </h5><br><br>  SpriteBatch has a constructor that accepts the maximum number of sprites that will be accumulated before being sent to the GPU.  If this number is too small, there will be a lot of unnecessary calls to the video accelerator.  If the number is large, SpriteBatch will use too much memory. <br><br>  SpriteBatch has a public field called maxSpritesInBatch.  It indicates the maximum number of sprites that can be sent to render the video accelerator at a time during the SpriteBatch life cycle.  You can set this number to be very large and check it.  This will help you choose the optimal size of SpriteBatch.  The size of SpriteBatch (the number you pass to the constructor) should slightly exceed the maxSpritesInBatch number.  You can always set maxSpritesInBatch to zero ‚Äî that is, reset this counter. <br><br>  SpriteBatch has a public field renderCalls.  After the next rendering cycle, it stores the number of times SpriteBatch sent different data about the geometry between the begin () and end () calls.  This happens if different textures bind, or if the SpriteBatch was full (the cache is too small).  If the size of SpriteBatch is correct and renderCalls is too large (around 15-20), this indicates that you use too many textures.  Try to place some of the textures in one big texture. <br><br>  SpriteBatch has an additional constructor that accepts the number and size of buffers.  This is an advanced feature that orders to work with VBO (vertex buffer objects) instead of the usual VA (vertex arrays).  SpriteBatch stores a list of buffers and uses the next buffer for each successive rendering cycle.  When maxSpritesInBatch is small and the renderCalls is large, this chip can give a small performance boost. </div><p>Source: <a href="https://habr.com/ru/post/143405/">https://habr.com/ru/post/143405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143398/index.html">With three LEDs it was easy, now there are 6!</a></li>
<li><a href="../143399/index.html">We grow mobile developers</a></li>
<li><a href="../143402/index.html">Several useful services. Continuation</a></li>
<li><a href="../143403/index.html">SkypeKit as an XMPP gateway</a></li>
<li><a href="../143404/index.html">The site of the radio station "Echo of Moscow" attacked three botnets at once</a></li>
<li><a href="../143406/index.html">We extort music from the contact. Geek way</a></li>
<li><a href="../143407/index.html">Differentiation of Google search for Russia, Ukraine and Belarus</a></li>
<li><a href="../143408/index.html">20 years of Wolfenstein 3D: shareware model in games</a></li>
<li><a href="../143410/index.html">Free we remove the limit of five people for closed BitBucket repositories</a></li>
<li><a href="../143411/index.html">Droider Show # 39. Galaxy S III and space miners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>