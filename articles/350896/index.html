<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effective data compression methods when training neural networks. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, Gennady Pekhimenko, a professor at the University of Toronto and a PhD from Carnegie Mellon University, came to Yandex. He gave a lec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Effective data compression methods when training neural networks. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, Gennady Pekhimenko, a professor at the University of Toronto and a PhD from Carnegie Mellon University, came to Yandex.  He gave a lecture on coding algorithms that allow to bypass the problem of limited memory of a GPU when learning deep neural networks. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qx3iM2aa2yU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - I belong to several groups of the University of Toronto.  One of them is Computer Systems and Networking Group.  There is also my own group - EcoSystem Group.  As can be seen from the names of the groups, I am not an expert directly in machine learning.  But neural networks are now quite popular, and people who are engaged in computer architecture and networks, computer systems, have to deal with these applications on an ongoing basis.  Therefore, the last one and a half or two years I have been closely involved in this topic. <br><a name="habracut"></a><br>  I'll tell you how to properly do compression in memory, in the processor cache.  This was the topic of my doctoral thesis in America at Carnegie Mellon.  And it will help to understand what problems we encountered when we wanted to apply similar mechanisms for other applications, such as neural networks. <br><br>  One of the main problems in computer architecture is that we want to get high-performance systems - graphics cards, coprocessors, phones, laptops - with good energy efficiency parameters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the moment, it is easy to get a fairly high performance, if you do not limit yourself to memory.  You can get and exoflop computer, if necessary.  The question is how much electricity you have to spend.  Therefore, one of the main problems is to get good results on performance with the available resources and at the same time not to disturb the balance of energy efficiency. <br><br>  One of the main problems in the path of energy efficiency is that many key applications used in cloud computing and on various mobile devices have significant data costs, both for shipping and storage.  These include modern databases, graphic cards, and, of course, machine learning.  All this requires very serious resources from all levels of the stack, from the core down to network resources. <br><br>  Here is one of the key problems that arise when you have to perform various optimizations: you can actually replace one type of resource with another.  In the past, in computing architecture, computing resources themselves, such as addition, multiplication, and arithmetic operations, were very expensive.  However, this situation has changed in recent years, and this is due to the fact that the development of the processor core has progressed much faster than the speed of access to memory. <br><img src="https://habrastorage.org/webt/sb/st/tw/sbsttwnxhnkusydvv4z2yaq2oxk.jpeg"><br><br>  As a result, one arithmetic addition operation in terms of energy will cost you approximately 1 picojoule.  In this case, a single floating point operation, floating point, will cost approximately 20 pj.  If you want to read 4 or 8 bytes from memory, it will cost you at least two orders of magnitude more in energy.  And this is a significant problem.  Any attempt to work with memory is quite expensive.  And it doesn‚Äôt matter what devices we are talking about.  The situation is the same for mobile phones, that for large clusters and supercomputers. <br><br>  It follows from this that very many resources that even the current mobile phone does not have can be fully utilized for energy resources.  If you take a modern phone, it does not matter, Android or iPhone, we can use the available bandwidth between memory and the core in peak and only by about 50%.  If we do not do this, the phone will overheat, or rather, no one will overheat to it - the bus frequency will be reduced when communicating between the memory and the core, and the performance will also fall. <br><br>  Many resources are now impossible to use if you do not apply clever optimization. <br><img src="https://habrastorage.org/webt/yi/ao/ve/yiaovelmeb1uu3xth05rw3rjgnk.jpeg"><br><br>  One way to deal with the lack of different resources at different levels is data compression.  This is not a new optimization, it has been successfully applied both to networks and to disks, we all used various utilities.  Say, on Linux, many have used gzip or bzip2 utilities.  All these utilities have been very successfully applied at this level.  Algorithms are usually applied either on the basis of Huffman encoding or Lempel-Ziv. <br><br>  All of these algorithms usually require a large vocabulary, and the problem is that their algorithms are very consistent, and do not really fall on modern architecture, which is very parallel.  If we look at existing hardware, memory-level, cache, or processor-level compression has hardly ever been applied, at least until some of our first jobs five years ago. <br><br>  I will tell why this happened, and what can be done to make compression available at various levels, that is, compression directly in the cache.  Cache compression - meaning that the compression takes place directly in the hardware, that is, a part of the logic of the processor cache itself is changing.  Briefly tell you what this bonuses.  I'll tell you about the compression in memory, what problems are there.  It seems that this is the same thing, but to effectively implement compression in memory is quite different, not the same as in the cache.  I'll tell you about the collaboration with NVidia, where we made Bandwidth Compression in real hardware for modern GPUs, and the optimization that we did is in the latest generation of GPU cards - Volt.  And I‚Äôll tell you about a completely radical optimization, when execution takes place directly on compressed data without decompression at all. <br><br>  A few words about the compression in the cache.  This was an article at the PACT conference in 2012, and the work was done in conjunction with Intel.  To make it clear what the main problem is, if you want to turn your 2 MB or 4 MB processor cache into 4 MB or 8 MB.  You did L-compression, and what's the problem? <br><br>  Roughly speaking, when you have a memory access operation, if we are talking about the x86 architecture, load or store in memory, then if there is no data on the registers, then we go to the first level cache.  Usually it is three or four clock cycles on a modern processor.  If the data is there, they go back to the CPU.  If they are not there, then the request to memory goes further along the hierarchy, comes to the L2 cache. <br><img src="https://habrastorage.org/webt/n6/pg/uh/n6pguhrzgbjbxo1phtse1d1eovg.jpeg"><br><br>  L2-cache on most Intel processors 15-20 cycles, depending on the size of the cache.  And then the data usually go back, if they were found in the L2 cache, if you did not go to the memory.  The data goes both to the processor immediately and to the L1 cache, if you continue to reuse this data so that they are closer to the processor. <br><br>  The problem is that if the data is compressed, then it doesn't matter how you optimize the compression process, decompression is always on the critical launch path.  If earlier a second level cache call took 15 cycles, then any delay associated with decompression is added to the delay of your request.  And this restriction is true for almost all applications of compression, and in memory, and when we use for real-world applications, such as training neural networks, decompression is always on a critical path, and its delays, the time for its execution is very critical. <br><br>  What does this mean for us?  If you understand that the cache latency is at 15 cycles, decompression should be very optimized.  We can afford only a few processor cycles.  To understand how small it is, one plus takes about two cycles, one such simple operation.  That is, you can not do anything super complex. <br><br>  Largely because of this, Intel at some point focused on developing cache compression.  They had a whole group that worked there, and in 2005-2006 they developed an algorithm that gave decompression of about 5 cycles.  This delay increased by approximately 30%, but the cache became almost twice as large.  Nevertheless, their designers looked at most applications and said it was too expensive. <br><br>  When I started working on this topic in 2011, they said that if you can do something in 1‚Äì2 cycles, you can do it in real hardware, try it. <br><br>  I tried different algorithms, and one of the reasons why it was not possible to use the algorithms that already existed in the literature is that they were all made originally in the software.  In the software, other restrictions, people use different dictionaries and other similar techniques.  If these techniques try to do in real hardware, they are quite slow.  IBM made the Lempel-Ziv algorithm completely the same as in gzip used, completely in hardware, and decompression took 64 clocks.  Clearly, in the cache you will not use this, only in memory. <br><br>  I tried to change the strategy.  Instead of trying to optimize software algorithms, I decided to see what kind of data is actually stored in the cache, and try to make an algorithm that will work well for this data. <br><img src="https://habrastorage.org/webt/12/za/i1/12zai1dcyanp2gnnp1hcvj_tajc.jpeg"><br>  I saw that paradoxically a lot of zeros, from 20% to 30%.  If you take a large package of applications from Intel, there are 200 different applications that people use for computing - there are a lot of zeros.  This is initialization, these are matrices with a large number of zeros, these are null pointers.  There are many reasons for this. <br><br>  Very often there are duplicate values.  In some small area of ‚Äã‚Äãmemory, in the cache, very similar values ‚Äã‚Äãcan be repeated.  This, for example, and if you work with graphics, you have a bunch of pixels, and if you have a part of a picture with the same colors, then you have all the pixels that are in a row going to be the same.  In addition, narrow values, single-byte and two-byte values, which are stored in 2, 4 and 8 bytes.  Why is this happening and whose error is this?  Where does such redundancy come from? <br><br>  Redundancy is related to how we program the code.  We use some language, for example, C ++.  If we want to allocate memory for some object, say, for a whole array, imagine that in the array we store statistics about some events, and these events can be both very frequent, say, billions, and single.  For example, reference to memory with a specific instruction.  Most instructions are not memorized, but some can be accessed billions of times during startup. <br><br>  The programmer is forced to allocate an array of eight-byte numbers, because in the worst case, his integer values ‚Äã‚Äãcan take large values.  However, this is redundant.  Many of these values ‚Äã‚Äãare not really needed, and there will be a bunch of incomplete zeros, but some of the leading zeros. <br><br>  In addition, we have many other values ‚Äã‚Äãthat also have different types of redundancy.  For example, pointers.  Anyone who once debugged the code and looked at the pointers, you can see that they are changing quite large.  But if you have pointers with approximately one memory area, then most of the bits ahead will be the same.  This type of redundancy is also evident. <br><br>  I have seen many types of redundancy.  The first question is how many are there? <br><img src="https://habrastorage.org/webt/mw/mr/-y/mwmr-yxht1yejbzplc_8qnpbdki.jpeg"><br><br>  Here, the experiment in which I periodically took data from the second-level cache saved the snapshot of this cache and watched how many zeros there were, repeated values.  On the X axis, various applications from the SPEC2006 package, which is actively used in the computer architecture, as well as other various applications from Intel, include both the database and various web workflows, such as the Apachi server, for example.  And here is the assumption that this is a 2 megabyte L2 cache. <br><br>  You may notice that there is a large variation between redundancy in different applications, but even these very simple patterns are quite common.  Only they cover 43% of all cache lines, all data that is stored in the cache. <br><br>  You can come up with something quite simple that will cover these and maybe some other patterns, and give us good compression performance. <br><br>  However, the question is, what makes these patterns related?  Will I have to do some kind of compression algorithm that will work specifically for each of these patterns, or can I do something in common? <br><br>  The general was the idea of ‚Äã‚Äãobservation.  All these values, they can be both large and small, there is very little difference between them.  Roughly speaking, the dynamic range of values ‚Äã‚Äãin each specific cache line is very small.  And you can imagine the values ‚Äã‚Äãstored in the cache, for example, the 32-byte cache line can be represented simply using Base + Delta Encoding. <br><img src="https://habrastorage.org/webt/py/st/_h/pyst_hvsutxdwodu6unif0sxfam.jpeg"><br><br>  Take, for example, the first value for the base, and all the others as an offset from this base.  And since the values ‚Äã‚Äãfrom each other differ in most cases not much, then our delta fits in one byte, and instead of 32 or 64 bytes we can do with only 12 bytes and save about 20 bytes of space. <br><br>  I will not talk about all the details of how to implement it in real hardware.  We made a real prototype, wrote a prototype on Verilog, drove it on modern FPGAs, talked to Intel about implementation.  You can make an algorithm based on this idea, which will require only one or two clocks in decompression.  This algorithm is applicable, and it gives a good compression ... <br><img src="https://habrastorage.org/webt/qb/yi/nl/qbyinlrptnx1e_zpasqscn6clw8.jpeg"><br><br>  The best previous works that were used in the cache, gave about 50% of additional space.  This is not a pure compression - it can give a lot more - this is a real bonus to effective compression, that is, how much cache looks to users.  There are still any problems with fragmentation and so on that need to be addressed. <br><br>  Compression is at the level of the best previous mechanisms that Intel had, but the main gain in the middle of the slide is decompression.  The previous algorithms, they had the best decompression was 5-9 cycles.  We managed to do it in 1-2 clocks, while the compression is also quite effective. <br><br>  Algorithms of this kind can be done in real hardware and applied in the cache, for example, in memory. <br><br>  The effect of applying such optimization in the cache leads to the fact that the cache looks to the user often almost twice as much in efficiency.  What does it mean?  If you look at the modern processor, in the photos, there are almost no cores themselves.  There, most of the space is occupied by processor caches - 40-50% easily from both IBM and Intel.  In fact, Intel can not just take and double the cache, there is simply no room for more cache.  And such optimizations that cost only a few percent of the core itself are, of course, very interesting. <br><br>  We worked with various optimizations in the second work, which I will not talk about today, about how to work with such caches, which now can have different cache line sizes.  All these problems have been successfully resolved. <br><br>  I want to talk about our third work, which was also done with Intel, about how to compress memory. <br><br>  What problems are there? <br><img src="https://habrastorage.org/webt/la/s7/jt/las7jtmy-hfav0ljubz5i26r7qe.jpeg"><br><br>  The main problem is that if in Linux or Windows I have a 4 KB memory page, then in order to compress it, I need to solve the following problem: I need to solve the problem of how the data addresses on this page change.  Initially, you have 4 KB, and each cache line in it is also 64 bytes.  And the offset of any cache line inside this memory page is trivial to find: you take 64 and multiply by the offset you need. <br><br>  However, if you use compression, each line is now potentially of a different size.  And if you need to read some page from the memory now, you do not have these displacements. <br><br>  We can say that you can save them somewhere.  And where to keep them?  Either again in memory or in cache.  But if you want to save all offsets for each memory, you don‚Äôt have enough cache, you need resources of the order of hundreds of MB to serve all the memory.  You cannot save this data in the chip, and you don‚Äôt want to store it in memory, because each memory access will now be several memory accesses.  First you will go for the metadata, and then for the real data. <br><img src="https://habrastorage.org/webt/qz/vb/r0/qzvbr0oczkdp5t5kkb62nl46s5u.jpeg"><br><br>  The second problem that everyone faced when working with the OS is data fragmentation.  Here it becomes extremely complex, because each page also occupies a different place in memory.  At the same time, in the virtual address space all pages are still 4 Kb, but after compression they all occupy completely different sizes.  And this is a problem, how now to work with this empty place.  The OS is not aware that we have allowed the pages to be made smaller, it just does not see these fragmented pieces.  Just like that, without changing anything, we will not receive bonuses from compression. <br><img src="https://habrastorage.org/webt/dy/a9/i_/dya9i_6c_zukc3bih0agzczonvw.jpeg"><br><br>  What did we suggest to solve this problem?  Compression using a linear coefficient.  We imposed a set of certain restrictions, which are described in detail in the article, but the bottom line is that if I apply compression to memory, I use an algorithm that ensures that every cache line on this page either compresses with a certain factor, say, 4 to 1, 3 to 1 or not compressed at all. <br><br>  We potentially lose something in terms of data compression, because we impose additional restrictions, but the main bonus is that the design is very simple, it can be implemented, which we have successfully done, for example, in Linux. <br><img src="https://habrastorage.org/webt/wq/ai/rn/wqairneyfgsh2qhwjq0ns9j8mzq.jpeg"><br>  Linearly Compressed Pages (LCP), a technique that we proposed, copes with the main problem that now the addresses of all the data are quite simple.  We have a small block of metadata that is stored on the same page, and there are either original data that is stored in a compressed form, or the so-called exception storage, cache lines are stored there, which we could not compress in this way. <br><br>  Based on these ideas, we managed to get good data compression, and most importantly, I compare it with the best previous works that were made mainly by IBM, they also had good algorithms for compression. <br><img src="https://habrastorage.org/webt/od/ft/pg/odftpgnagpy4mz9_ow4xppy9_eg.jpeg"><br>  Our compression was not particularly better than theirs, but most importantly, we got more memory without paying extra performance for it.  Roughly speaking, they got more memory, but for this they had a loss of performance, albeit small, but there was.    .       ,     ,    . <br><br>    ,     .     Nvidia.              .       ,       ,  5-6      .          bandwidth,      . <br><br> ,    Nvidia,        2014 ,    ,       ,         .     ,        :    ,   DVFS,  ,        ,     ,      ,   ,     ,      . <br><br>   ‚Äî  ,     , .   ,     ,     .        .  ,   -   ,     ,  ,    .         Nvidia     ,     . <br><img src="https://habrastorage.org/webt/9h/gj/zr/9hgjzrcbotbjvfk_fgpvhasjxv8.jpeg"><br><br>    ,        ,      .    . ,    , , 0011.       .     0101.     ,    0    0,    ,         bit toggle,        ,  ,  ,   ,    ,     0  1   1  0.         ,     .     ,    .      ,       . <br><br>     ‚Äî   ,         .     , ,  networks of chip   DRM  ,    ,    . <br><br>  What is going on?             ? <br><img src="https://habrastorage.org/webt/lz/xt/fw/lzxtfwuts9pfptow3dnrmcmum8i.jpeg"><br><br>          Nvidia,   .     ,  32   16 ,     .   ?   ,     .  ,  ,     XOR,         16  8 ,         ,    . <br><br>    - , , frequent pattern compression,   Intel,  ,       .       15,   16 .    ,  ,     ,      alignment.          ,       .     ,     .  ,   Nvidia  .    ,  ,     ,  ,        .   ,     2%,    40%.    ,   . <br><br>    ,    .     ,   ,    ,     ,    ,    , ,    ,   ,     ,    . <br><img src="https://habrastorage.org/webt/tx/ba/qj/txbaqjyg-vlnrbmbjuccnvqrkn0.jpeg"><br><br>            .   ,   ,     ,         .     ,        ,   ,  -    ,       ‚Äî  ,       .  ,     ,  .  ,   ,      ,    ,       ,      . <br><br>             ,     ,   ,     Microsoft Research  ,   machine learning. <br><br>   ,     ,     ,        ,    .          DNNs.       .     ,  DNNs ‚Äî  ,       -  Ajura,       ,       ,  , .  ,       10%.    ,   ,     ,        : TensorFlow, CNTK, MXNet.     ,   ,     . <br><br>   DNNs   ,      ,     ,   GPU. <br><img src="https://habrastorage.org/webt/m1/w1/tk/m1w1tkk8qndrhemtjjopdpqjmim.jpeg"><br><br> DNNs     .   ,   ,   ,   ,   .    .   ,      ,     ,       ,   .     ,      . <br><br>        ,     .    ,   ,    inference. <br><img src="https://habrastorage.org/webt/ea/jv/as/eajvasuhnvaoxn8jaklo1tfsbg4.jpeg"><br><br>      ,  Google   TPU  ,    ,     ,     inferent        ,     ,      Microsoft. <br><br>     ?         ?      Google,  ,  TPU       inference.     ,     .  ,   inference,  .    forward pass.      ,  - ,   inference    .    ‚Äî    .  ,       .      backward pass,       ,   ,         . <br><br>   ,   ,    .        ,       .   ,       ,       feature maps  activations.  inference    ,            .  back propagation,  ,     ,       ,    .  ,      L2,     ,  forward pass   ,        ,       ,   ,    . <br><br>      ,  ,     100,  200 , , ResNet,   image classification.      - .   ‚Äî  ,   ,   ResNet  101 ,  ,  ,    -  mini batch , , 64   ,     ,      ,  16 .    , P100 Pascal   Volt100,    16 .          ,   . <br><br>  ,   Facebook,     .    ,    ,       ,      .        ,    . <br><br>      ,       .      GPU,     .        ,        . <br><img src="https://habrastorage.org/webt/yf/qi/mv/yfqimv3wpnhxukfs1wcunxohjiq.jpeg"><br><br>  ,   ,    ,    ,      ,    .   X  AlexNet,     DNN ,    : Overfeat, VGG16, Inception (      Google version 3,    ,   Google).     mini batch.  , ,      .  ,     ,   ImageNet,    220  220   3,    1000 : , ,    . <br><br>   ?       AlexNet      ,   2011 ,     .    ,     ,      feature maps,  . <br><br>    ?   ,    ,       mini batch,          ,       ,          inputs.        ?    GPU .  GPU      8000 threads,     ,       ,  GPU    .   ,   ?     ,   CPU  ISAC. <br><br>    ,    .    ,   .     ,      ,  ,    ,    ,   ,   ,    DNN inference,    ,   ISCA, MICRO,  2015    15   ,  deep neural networks,    inference,    . <br><br> -,    inference,   ,       forward pass,      ,        ,    . <br><br> ,      ,     .  ,     inference,    - ,  ,    32- floating point, ,     16 , 8  4.       ,     ,    -  stochastic gradient descend,    .    ,        .         GPU,       ISAC, -   TPU       -    FPGA  .  GPU       . <br><img src="https://habrastorage.org/webt/zn/pr/wi/znprwit55apb2yuneuyjlqbj32k.jpeg"><br><br>   ,            .    ,   ,     ,   ,      ,  ,      ,  ,      ,   , ,    LX,         .       ,   ,     .         .        :    . <br><br>      ,      .    -      ,         .      ,      .         .          .       ,   .        ,   .       ,    .       . <br><br>   ,     ,         ?             ,     .   ,   ,     .     ,      ,  , .     ,        .   -      ,       . <br><img src="https://habrastorage.org/webt/0x/g3/ti/0xg3tiqgen3x5n8rprsdh0tk5mc.jpeg"><br><br>  ,   ,    :     feature maps       .   ,   ,      ,   ,  . , ,  ,  Relu ,    rectified linear function  pulling layer,   ,        ,      . <br><br>   ,     ,    .   ,    .  ,         ,  ,   Relu,   pulling layer.    layers,        . <br><br> ,  Relu   , ,    -     ‚Äî       .         ‚Äî      . <br><img src="https://habrastorage.org/webt/yv/ee/2u/yvee2uxiob7eqrfm7fqhokorhug.jpeg"><br><br>   ,    Relu,    .     ,      .  Relu ‚Äî   ,      ,    ,  0,    .   ‚Äî   ,  ,  . <br><br>      ,        ,  ,   by modal.        .  ,      ,         . ,     ,   .     -  ,     32 ,  ,   , 31  .  ,    ,   . <br><br>       32 ,      .    .    ,     . , pulling layer ‚Äî    2  2,     , 2  2  3  3.            ,     ,   ,    .      TensorFlow,  CNTK,   ,   ,   .    ,     ,  machine learning,  ,   .        .  ,   ,      ,   -   ,   ,     . <br><br> - ,  ,        ,  ,         .   Relu    32 , pulling layer    8 .   ,  ,      TensorFlow,     .          -  .          . <br><br>    ,    32  1 .  ,          ,       .    ,    .   32-,      ,     .         . <br><br>      ,   lossless,   . <br><img src="https://habrastorage.org/webt/dk/x1/oe/dkx1oevsxjz-_jfab0z3tgnuhci.jpeg"><br><br>     ,  Relu       .       .   ,    ,   VGG16,     10 ,  ,       ‚Äî  ,  . 1  100% ,  0,6 ‚Äî 60% .  ,      . <br><br>     , , Relu_1, Relu_2   ,        .  ,   ,  60%,   70%.       ,   ,    ,       .       ,      . <br><br>  What does it mean?     ,     .      ,   ,  GPU.    CUDA ,      .   ,   -   CUDA  .    ,  NVidia ,        99%.     .      ,       50%  80% .      ,  GPU .           , , ,  CUDNN ,   Nvidia  .     ,  CUDA ,      . <br><br> ,    ,        ,   Lossy Encoding,     .   ,    IBM    . , L1  - .  32 ,    8   16,   -   ,  . <br><br>   ,     32-  16- ,       ,   ,  ,   , , AlexNet,   32   16   - ,   ,      ,     ,        validation.  ,     ,     .  ,   ,   ,     .   ,       ,     ,   . <br><br>             . ,   ,    ,        . ,   ,   .   ‚Äî    .   forward pass   .     ,    ,  backward pass,       .     backward pass,    . <br><br>    ? <br><img src="https://habrastorage.org/webt/qw/iu/sy/qwiusydal4vudoi3rjhoxdzcibk.jpeg"><br><br>   ,      .     ‚Äî    AlexNet  FP32, 32 .   ,  IBM ,  All-FP16,    16 ,       .   -    16 ,   ,      16 ,  ,  ,   -   . <br><br>     ,   ,       ,        ,      16 ,    8 .       ,     . <br><br>   ,       ,      .     ,       ,    . <br><img src="https://habrastorage.org/webt/8f/_p/ii/8f_piibmusvwdlsiocxcnbpoi7w.jpeg"><br><br>   ,    Gist,        ¬´¬ª.   DNN,  execution graph,    ,        , ,   CNTK     ,     Microsoft.           CUDA    .     execution graph,   ,  TensorFlow,  MXNet,        .     GPU  ,      ,   .       ,   ,    . <br><br>     ,       , , cuDNN,       ,     .       .     .           ,   TensorFlow. GIST       . <br><img src="https://habrastorage.org/webt/bf/gy/k9/bfgyk9qxj3dvqm09sv07xzgkncu.jpeg"><br><br> ,       ,    ?    . ,     , ,   ,     ,   , 90-100     ,    .      .      ,         ,                .      6%  8%,    ,    ,   ,      .     ,    ,      Microsoft. <br><br>   ,         .  ,    ,    Microsoft,     PhD ,  ,   DNN Training,    ,        ,  ,       , .         .    Microsoft ,      LSTM ,    speech ,   ,    .    -    -,      . <br><br>   .      ,     ,   .         image classification,   AlexNet, ResNet   ,       . Image classification ‚Äî   , ,    ,      Facebook.      ,  machine learning     . <br><br>  ,   ,    ,   . ,  . ,  MXNet,    Amazon,      , ,     TensorFlow.   ResNet 50, ,    ¬´¬ª ,   40% ,  TensorFlow .   ,  MXNet ,  TensorFlow?    .       .   LSTM,    MXNet    ,      TensorFlow,   - ,   Amazon   Google,  TensorFlow  2,5    .  ,     .         . <br><br>    ,    .     ,    .    ,   ,       , ,     machine learning,        . <br><br>  , , Image Classification,   ,    .   object detection,   ,   ,    Faster RCNNs,  16-17-     Google   MIT,  .        :   LSTM,  , , .  nmt ‚Äî   Google,  open source.     sockeye  Amazon.   . <br><br>      Transformer,   Attention layers.     2013-,    ,   ,   ,  ,       Attention layers.    Google ,        GPU,  ,         . <br><br>    speech recognition,     LSTM.   adversarial networks,    reinforcement learning,  Google     AlphaGo .     supervise,   n-supervise learning.   image classification.  ,      .   16-17- ,  . <br><br> ,      .    TensorFlow, CNTK, MXNet.     ,     ,   ,     .     TensorFlow  , -    CNTK  MXNet.  ,      ,    , .    ,      ,       . <br><br>    .    GPU.   ,  CPU     .   ,    ,  GPU,  FPGA,   ISAC         Google. ,       TensorFlow,        . <br><br>    : , ,     ,   ,    -.     . <br><br>    ,     ,   ,    ,   . ,   ,  ,     CNTK.     .    ,     .   TensorFlow  ,    ,    2000 ,   ,    ,   ,   .      .    ,    CNTK,  MXNet. TensorFlow     ,     .    ,         Google ‚Ä¶      ,    ,    ,    ,    ,   . <br><br>     ,   . <br><img src="https://habrastorage.org/webt/uf/rt/yp/ufrtyp0ox4sd5u0ihucp9zjx_xy.jpeg"><br><br>  ,    TensorFlow  MXNet  .  ,   NMT  Google,   Sockeye.    ,    - ,       LSTM ,   batch,     ,   . <br><br>  ,   ,     , -,   Y    blue score.  ,  ,      .  ,      .         . <br><br>   ?  ,       ,   ,   blue score  20    .    ,       ,    .       SGD. ,    , -  ,         . <br><br>     - ,     learning rate   ,   -,    .             .   ,  ,   ,    ,    ,         ,  .     ,  TensorFlow        LSTM .     CUDNN,  MXNet      LSTM.         ,      . <br><br>   ,       ,       TensorFlow,          MXNet. ,    GPU,   LSTM   ,   30%  GPU . 70%  .  ,  ,        .      TensorFlow  10-15%,  .          ,  MXNet.       . <br><br>     LSTM,     , Nvidia    CUDNN   ,   LSTM   .     ,    .     -,   E ,  ,  CUDNN  2,5     LSTM.      ,   ¬´¬ª  P100  CUDNN 8 ,  ¬´¬ª  100  CUDNN 9 .             .          ,    .       . <br><img src="https://habrastorage.org/webt/na/sn/ic/nasnicqb18rwiaqjjnxe6eymhpu.jpeg"><br><br>     reinforcement learning,     .   ,         NIPS  ICLR,     .   ,    machine learning     MATLAB          .     ,      ,  .    ,    ,  ,    .       .        Google,    ,       . <br><br>     ,  -         ,     .    . <br><img src="https://habrastorage.org/webt/1y/ig/kz/1yigkznipopx1ipat626lnmm-kw.jpeg"><br><br>   reinforcement learning,  MXNet  TensorFlow,   ,   . <br><br>          ,    .  ,  ,   ,    ,  ,   ,         .    , ,  . <br><br>      ,        ,      :       ,   .  What does it mean?     , , .    ,   - ,   ,      .      ,    . , Google ,           5-7%. <br><img src="https://habrastorage.org/webt/tr/ko/dj/trkodjs0ebif8mkq84nxvyfd8ja.jpeg"><br><br>  cloud tax    20‚Äì25%,   , ,   .   ,     Google Cloud, 25% ‚Äî   ,       . <br><br>     ‚Äî . ,    -   ,       ?     ,  ,   ,   . <br><img src="https://habrastorage.org/webt/wf/ou/yq/wfouyq2v5ri4vig24rvwslvedri.jpeg"><br><br>     ,      .      . ,     -,       -  .   - ,    - .           .      ,     ,        ,      . ,     where value = 10,    value  .       ,    . <br><br>      ,   4   . <br><img src="https://habrastorage.org/webt/8g/mh/az/8gmhazr6muk34lcpxp4fjqczuag.jpeg"><br><br> ,     ,    , Base+Delta Encoding,   - . ,       1 ,   .  . <br><br> ,      -. ,    ,   ?    -   ,      ,    .     ,    ,  - ,    n  .    ,  ,     ,      .    ,   Base+Delta Encoding  .  ,     ,     Base+Delta Encoding. <br><br>  What does it mean?    ,        ,     .             . <br><br>   ,  ,    ,      ,  ,     ,       . <br><br>  ,        1    ‚Äî ,  .    ,           ,      ‚Äî .     ,           .   .       ,    CND- Intel      .       ,     1  ,      .        4  8 . <br><br>   ,  .           .     ,        ,   .        ,       .  It's all. </div><p>Source: <a href="https://habr.com/ru/post/350896/">https://habr.com/ru/post/350896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350886/index.html">Simple static webpack site 4</a></li>
<li><a href="../350888/index.html">Service Portal: how does a single interface work for interacting with an IaaS provider?</a></li>
<li><a href="../350890/index.html">The Power of Open: The Power of Openness</a></li>
<li><a href="../350892/index.html">Customize Syncthing. Blue insulating tape in small business and at home</a></li>
<li><a href="../350894/index.html">Digest of interesting materials for the mobile developer # 244 (March 5 - March 11)</a></li>
<li><a href="../350898/index.html">10 main qualities of a manager according to Google</a></li>
<li><a href="../350900/index.html">Multi-classification of Google queries using neural network in Python</a></li>
<li><a href="../350902/index.html">Podcast "Rules of the Game": accounting subtleties for technological (and other) business</a></li>
<li><a href="../350904/index.html">Object in a case or Optional in Java 8 and Java 9: ‚Äã‚ÄãPart 5: Untold and a poster as a gift</a></li>
<li><a href="../350906/index.html">Remember everything. Waiting and reality in IT: 2017 vs 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>