<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network code for the poor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The more you learn in your field of knowledge, the more clearly you understand that no one can know everything. 

 For some reason (why, my God, for w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network code for the poor</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/np/qw/xbnpqwwvw6dmxhpddwxfc5vtfpu.png"></div><br>  The more you learn in your field of knowledge, the more clearly you understand that no one can know everything. <br><br>  For some reason (why, my God, for what?), The development of games has become my area.  Everyone who works in this field will tell you: never add a network multiplayer mode to a ready-made game, never drunk you are a clown. <br><br>  Anyway, I did just that, and I hate myself for it.  Surprisingly, it turned out great.  None of us knows everything. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Problem number 1: resources </h2><br>  The first question I had was: how to tell the client that you need to use such and such a mesh for rendering the object? <br><br>  Serialize the whole mesh?  Not worth it, the client already has it on the disk. <br><br>  Transfer the file name?  Nah, ineffective and unsafe. <br><br>  Well, maybe just a string identifier? <br><br>  Fortunately, before I had time to implement my own delusional ideas, I looked at the report of Mike Acton, in which he spoke about the dangers of "lazy decision-making."  The point is this: strings allow developers to lazily ignore decision making until the creation of a working application, when it is too late to correct errors. <br><a name="habracut"></a><br>  If I rename the texture, I don‚Äôt want to receive error reports from players with the following screenshots: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/2b8/287/4d02b82877b781bb71a3acb68c5f79c9.jpg"></div><br>  I never wondered how powerful and complex the lines are.  Half of the tasks in computer science are related to strings and their capabilities.  Usually they require dynamic memory allocation or even something even more complex, such as ropes and a pool of strings. <br><br>  I usually don‚Äôt bother with their length, so the line expands the space of possibilities to infinity, destroying the constraints necessary for the program‚Äôs predictable behavior during execution. <br><br>  And here I use these complex monsters to <em>identify objects</em> .  Yes, I used strings even to access the properties of objects.  What a madness! <br><br>  In short, I have developed in myself a strong installation: avoid lines where it is possible. <br>  I wrote a preprocessor that creates some of the following header files during the build process: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Asset { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Mesh { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AssetID player = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AssetID enemy = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AssetID projectile = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br>  Therefore, I can refer to meshes as follows: <br><br><pre> <code class="cpp hljs">renderer-&gt;mesh = Asset::Mesh::player;</code> </pre> <br>  If I rename the mesh, the compiler will turn it into my problem, and not into the problem of some unfortunate player.  And this is good! <br><br>  The bad news is that I still need to interact with the file system, and for this you need to use strings. <br><br>  The good news is that the preprocessor can save us again. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* Asset::Mesh::filenames[] = { <span class="hljs-string"><span class="hljs-string">"assets/player.msh"</span></span>, <span class="hljs-string"><span class="hljs-string">"assets/enemy.msh"</span></span>, <span class="hljs-string"><span class="hljs-string">"assets/projectile.msh"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, };</code> </pre> <br>  Thanks to all this, I was able to easily transfer resources over the network. <br>  These are just numbers!  I can even check them out. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mesh &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || mesh &gt;= Asset::Mesh::count) net_error(); <span class="hljs-comment"><span class="hljs-comment">//    , ?</span></span></code> </pre> <br><h2>  Problem number 2: links to objects </h2><br>  The next question I had was: how can I politely ask a client to move / delete / process ‚Äúthe object that you used to know which one‚Äù. <br><br>  And here again I was lucky to hear the advice of smart people, before shooting myself in the foot. <br><br>  From the very beginning, I knew that I would need a bunch of lists of various kinds of objects, like these: <br><br><pre> <code class="cpp hljs">Array&lt;Turret&gt; Turret::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Array&lt;Projectile&gt; Projectile::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Array&lt;Avatar&gt; Avatar::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>;</code> </pre> <br>  Suppose I want to refer to the first object in the Avatar list, even without a network, just on a local machine.  My first idea was to use a simple pointer: <br><br><pre> <code class="cpp hljs">Avatar* avatar; avatar = &amp;Avatar::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  At the same time there is a mountain of unobvious problems. <br><br>  First, I compile for a 64-bit architecture, that is, the pointer occupies 8 bytes of memory entirely, even though most of them will most likely be filled with zeros.  And memory is the main ‚Äúbottleneck‚Äù of game speed. <br><br>  Secondly, if I add a lot of objects to the array, it will be reassigned to another part of the memory, and the pointer will point to garbage. <br><br>  Okay, fine.  I will use instead of the pointer ID. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ref</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> id; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Type* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Type::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[id]; } <span class="hljs-comment"><span class="hljs-comment">//   "="  }; Ref&lt;Avatar&gt; avatar = &amp;Avatar::list[0]; avatar.ref()-&gt;frobnicate();</span></span></code> </pre> <br>  The second problem: if I remove this Avatar from the list, then another Avatar will be moved to its place, and I will not know anything about it. <br><br>  The program will continue to perform, majestically and calmly cracking everything until some player sends me an error report ‚Äúthe game behaves strangely.‚Äù <br><br>  I prefer when the program explodes immediately to at least get an emergency dump with the line number. <br><br>  All right, all right.  Instead of deleting an avatar, I will assign a version number to it: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Avatar</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> revision; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ref</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> revision; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Type* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Type* t = &amp;Type::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[id]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t-&gt;revision == revision ? t : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } };</code> </pre> <br>  I do not delete the avatar completely, but mark it as ‚Äúdead‚Äù and increment the version number.  Now everything that tries to access it will receive a null pointer exception.  And serializing links over the network is just a matter of passing two easily verifiable numbers. <br><br><h2>  Problem number 3: delta compression </h2><br>  If I had to cut my article down to one line, then it would be just a link to Glenn Fiedler's blog. <br><br>  By the way, here it is: <a href="https://gafferongames.com/">gafferongames.com</a> <br><br>  When I decided to implement my own version of Glenn's network code, I studied <a href="https://gafferongames.com/post/snapshot_compression/">this article</a> , <br>  in which one of the most serious problems of multiplayer games is considered in detail.  Namely, the following: if you want to transmit the state of the whole world over the network 60 times per second, then you will score 17 Mbps from the width of the channel. <br><br>  And this is only <em>for one customer</em> . <br><br>  Delta compression is one of the best ways to reduce the amount of data transferred.  If the client already knows where the object is, and he did not move, then we do not need to send his position again.  But to implement it correctly can be quite difficult. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://etodd.io/assets/e31avw2.mp4" type="video/mp4"></video></div></div></div><br>  The first part is the most difficult: does the client even know where the object is located?  The fact that I sent the position does not mean that the client received it.  The client can send back confirmations like "I received the package 218, but this was 0.5 seconds ago and since then I haven‚Äôt received anything else." <br><br>  That is, in order to send a packet to this client, I have to remember what the world looked like when I sent a packet 218, and perform a delta compression on it of the new packet.  Another client could get everything up to package 224 inclusive, that is, for him I need to perform another delta compression.  The point is that we have to keep a whole bunch of different copies of the whole world. <br><br>  Someone asked a question on Reddit: ‚ÄúIsn't it a huge amount of memory?‚Äù <br><br>  No, not huge. <br><br>  I keep in memory <em>255</em> copies of the world in a single huge array.  But that is not all - <br>  each copy has enough space for the maximum number of objects (2048) even if only 2 are active. <br><br>  If you store the state of the object as a position and rotation, then you need 7 float numbers: 3 on the coordinates XYZ and 4 on the quaternion.  Each float number is 4 bytes.  The game supports up to 2048 objects.  7 float * 4 bytes * 2048 objects * 255 copies = ... <br><br>  14 MB.  That is about half of the modern texture. <br><br>  I can imagine how I would write this system five years ago in C #.  I would immediately begin to worry about the memory used, just like that person with Reddit, without even thinking about the actual amount of data involved.  I would write some unnecessary, insanely sophisticated, buggy-filled compression system.  When you take a second and think about what the real data will be, this is called <em>Data-Oriented Design</em> .  When I tell people about DOD, many immediately begin to say: ‚ÄúWow, this is a very low-level approach.  Looks like you want to max out your productivity.  I don't have time for this.  Yes, and my code works fine. "  Let's break this phrase into statements. <br><br>  <strong>Statement 1: ‚ÄúThis is a very low-level approach.‚Äù</strong> <br><br>  You see - I just multiplied four numbers, this is not quantum physics. <br><br>  <strong>Statement 2: "We have to sacrifice readability and simplicity for the sake of speed."</strong> <br><br>  Let's imagine two different solutions to this problem with network code.  For clarity, let's imagine that we need only three copies of the world, each of which contains two objects. <br><br>  Here is the solution I just described.  Everything is statically located in <a href="https://en.wikipedia.org/wiki/.bss">the .bss segment</a> .  It never moves, is always the same size and does not use pointers at all: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/ce6/b50/f9ece6b504b06de2c129be3a493e4d2d.png"></div><br>  But the characteristic for C # solution.  Everything is randomly scattered across dynamic memory.  The elements are redistributed or moved right in the middle of the frame, the array is chaotic, 64-bit pointers are everywhere: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f1/3c7/290/6f13c72903caf81f0ab5c925792b717f.png"></div><br>  What is easier? <br><br>  In fact, the second scheme is far from exhaustive.  In the real world, C # territory is much more complicated.  In the comments, they will probably correct me and tell me how C # actually works. <br><br>  But this is my point of view.  In my decision, I can easily construct a ‚Äúgood enough‚Äù mental model to understand what is actually happening in the car.  And in the C # solution, I barely started the implementation.  I have no idea how it will behave in the process of execution. <br><br>  <strong>Assumption 3: "Writing code in this way is worth only for the sake of performance."</strong> <br><br>  In my opinion, speed is a nice side effect of Data Oriented Design.  The main advantage is clarity of thought.  Five years ago, if I began to solve a problem, the first thing I would think was not about the task itself, but how to cram it into classes and interfaces. <br><br>  Recently, I witnessed with my own eyes such an analysis paralysis on gamejam.  My friend stalled on creating a grid for <a href="https://tilerisers.etodd.io/">playing in the style of 2048</a> .  He could not understand whether each number should be an object, or each grid cell, or all of them.  I said, ‚ÄúThe grid is an array of numbers.  Each operation is a function that changes the grid. "  Suddenly, everything became crystal clear to him. <br><br>  <strong>Assumption 4: "My code is working fine."</strong> <br><br>  I repeat: speed is not the main problem, but it is important.  It was because of her that the whole world switched from Firefox to Chrome. <br><br>  Try the experiment: run calc.exe.  Now copy the 100 megabyte file from one folder to another. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96a/18a/f3b/96a18af3b328997467d75cedc72229b3.png"><br><br>  I do not know what calc.exe does for these infinite 300 ms, but you can draw your own conclusions from a two-minute study: calc.exe starts the Calculator.exe process, and one of the command line arguments is called "-ServerName". <br><br>  Tell me, calc.exe "works fine"?  Does adding to the server make it all easier, or just slow down <em>and</em> complicate it? <br><br>  I do not want to be distracted from the topic.  The point is that I want to think about the task before me and about the data related to it, and not about classes with interfaces.  One of the objections to this way of thinking is that "this is too different from what I know." <br><br><h2>  Problem number 4: lag </h2><br>  Now I will briefly tell you about that part of the story in which the network code somehow works. <br><br>  I immediately had problems with network latency.  Games must respond to players instantly, even if the receiving package from the server takes 150 ms.  Especially useless in a lagging network of bullets and shells.  They can not aim. <br><br>  I decided to reuse these 14 MB copies of the world.  When the server receives a command to fire a shot, it rewinds the world back 150 ms to the moment the player was in when he pressed the shooting button.  Then the server simulates the projectile and rewinds the world forward step by step until it coincides with the current state.  And here he creates a shell. <br><br>  As a result, my client instantly creates a fake shell, and then, when he receives information from the server that the shell has been created, replaces it with a real one.  If everything goes well, then it should be in the same place due to the magic of the server time flywheel. <br><br>  This is how it works in practice.  A fake shell appears instantly, but passes right through the wall.  The server receives a message and rewinds the projectile forward to the part where it hits the wall.  150 ms later, the client receives the packet and sees the effect of particles of hit. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://etodd.io/assets/5jbF8PA.mp4" type="video/mp4"></video></div></div></div><br>  The problem with the network code is that each mechanic requires its own approach to lag compensation.  For example, in my game there is the ability "active armor".  If players react quickly enough, they can reflect the damage back into enemies. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://etodd.io/assets/vfbs0J9.mp4" type="video/mp4"></video></div></div></div><br>  This ability falls apart in cases with a high lag.  By the time the player sees that the projectile hits his character, the server has already registered a hit 100 ms back.  But the package has not even reached the client.  This means that we must anticipate the upcoming damage and react well before it hits.  Watch the video above and notice how early I had to press a button. <br><br>  To fix this, the server implements what I call ‚Äúdamage buffering‚Äù.  Instead of instantly applying damage, a server for 100 ms (or any time it takes for the full path to the client and back) writes the damage to the buffer.  At the end of this time, he either applies the damage, or, if the player has reacted, reflects it back. <br><br>  Here is what it looks like in action.  You can see a delay of 200 ms between the hit of a projectile and the application of damage. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://etodd.io/assets/JQ3WgIt.mp4" type="video/mp4"></video></div></div></div><br>  Here is another example.  In my game, players can throw themselves at enemies.  With a perfect hit, the enemies die instantly, but the sliding blows they reflect and send you flying in the following way: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://etodd.io/assets/oTh4dFj.mp4" type="video/mp4"></video></div></div></div><br>  In which direction should the player bounce?  The player needs to simulate a rebound even before the server finds out about it.  The server and client must agree on the direction of the rebound, otherwise they will become out of sync, but they do not have time to exchange data in advance. <br><br>  At first I tried to discretize the collision vector, so that only six possible directions remained.  So I increased the likelihood that the client and server would choose the same direction, but still it did not guarantee anything. <br><br>  As a result, I implemented another buffering system.  When recognizing a hit, both the client and the server go into a ‚Äúbuffer‚Äù state in which the player stands and waits for the remote host to confirm the hit.  To minimize jerks, the server always relies on the client in determining the direction of the rebound.  If the client does not confirm the hits, the server acts as if nothing had happened, and continues to move the player along his original trajectory, rewinding him forward to compensate for the time during which he waited for confirmation. <br><br><h2>  Problem number 5: jitter </h2><br>  My server sends packets 60 times per second.  But what will happen to the players whose computers give a higher frame rate?  They will see a jerky animation. <br><br>  The industry standard solution is interpolation.  Instead of instantly using data received from the server.  we buffer them for a short time and then smoothly mix them with the data we have. <br><br>  In my previous attempt to implement network multiplayer, I tried to make sure that each object independently tracked its position data and smoothed itself.  As a result, I got confused, and the system did not work as it should. <br><br>  This time, since I can easily store the entire state of the world in a struct, it turned out that it was enough for me to write only two functions so that everything worked out.  One function gets two states of the world and mixes them.  Another function gets the state of the world and applies it to the game. <br><br>  How big should the buffer delay be?  Initially, I used a constant, but then I watched the <a href="https://www.youtube.com/watch%3Fv%3DvTH2ZPgYujQ">video of Overwatch developers</a> , in which they mention the adaptive interpolation delay.  The buffer delay should smooth out not only the frequency of frames received from the server, but all fluctuations in the delivery time of the packets. <br><br>  It was an easy win.  Clients start with a small interpolation delay, and each time a packet is further interpolated, they increase their ‚Äúlag counter‚Äù.  When it exceeds a certain limit, clients ask the server to switch them to a higher interpolation delay. <br><br>  Of course, such automated systems often act against the desire of the player, so you must add tuning capabilities to the algorithm! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6a/d1d/682/a6ad1d68225348527a94e333f0461524.gif"></div><br><h2>  Problem number 6: connect to the server in the middle of the match </h2><br>  Wait, I already have a way to serialize the entire game state.  So what's the problem? <br><br>  It turns out that serializing a new game state from scratch requires not one, but several packages.  And to send a packet to the client it may take several attempts.  It may take several hundred milliseconds to get a complete state, and as we have seen, it is an eternity.  If the game is already underway, this time is enough to transfer 20 packets with new messages that the client is not yet ready to process, because it has not yet loaded. <br><br>  The solution, you guessed it, is in another buffer. <br><br>  I changed the message system so that it supports two separate message flows in one package.  The first stream contains map data that is processed immediately upon receipt. <br><br>  The second stream is the usual avalanche of game messages received while the client is loading.  The client buffers these messages until it completes the download, and then processes them all until it overtakes the state of the server. <br><br><h2>  Problem number 7: partitioning issues </h2><br>  This part will be the most controversial. <br><br>  Remember the worldly wisdom of game developers mentioned at the beginning of the article?  "Never add a multiplayer network mode to a ready-made game." <br><br>  It so happened that most of the network code is literally glued to this game with scotch tape.  It is in its own source file for 5000 lines.  The code is embedded in the game, writes some data to the memory, and then the game renders them. <br><br>  Before you crucify me for this, wait a second.  Which is better: group the whole network code in one place, or scatter it inside each game object? <br><br>  I think both approaches have their advantages and disadvantages.  In fact, in different parts of the game I used the first and second, for various reasons, from personal to technical. <br><br>  But some design paradigms (* hhm * OOP) do not allow me to make such decisions.  Of course, you need to insert the network code into the object!  His data is private, so you still have to write an interface to access it.  You may also have to use all sorts of intellectual transformations. <br><br><h2>  Conclusion </h2><br>  I'm not saying that you should write code like I did;  just saying that this approach is still working for me.  <a href="">Examine the code</a> and decide for yourself. <br><br>  In each case, there is an objectively optimal approach to the solution, but people may disagree on which one.  Strive to choose freely and be based on real constraints, and not on those that are due to a paradigm. <br><br>  Thanks for reading.  My game DECEIVER will appear in Kickstarter soon.  <a href="https://deceivergame.com/">Register on the site</a> to download the demo! </div><p>Source: <a href="https://habr.com/ru/post/349732/">https://habr.com/ru/post/349732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349722/index.html">How we built VDI with 14,000 jobs for the VTB Group</a></li>
<li><a href="../349724/index.html">How we improved technical support with cohort analysis</a></li>
<li><a href="../349726/index.html">Basics of programming on the SAS Base. Lesson 2. Access to data</a></li>
<li><a href="../349728/index.html">Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 1</a></li>
<li><a href="../349730/index.html">Best hackathon ravers: big data and mobile development</a></li>
<li><a href="../349734/index.html">Theory and practice of time: what developers think about the management of working hours</a></li>
<li><a href="../349736/index.html">Seminar "Data Storage Systems for the Cloud and in the Cloud", March 1, St. Petersburg</a></li>
<li><a href="../349738/index.html">STM32 blink ++ or read incremental encoder data</a></li>
<li><a href="../349740/index.html">On the use of person (characters) users in product development</a></li>
<li><a href="../349742/index.html">Game development for NES in C. Chapters 14-16. Working with sound</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>