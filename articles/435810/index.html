<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JOIN local collection and DbSet in the Entity Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A little more than a year the following ‚Äúdialogue‚Äù took place with my participation: 


 .Net App : Hey Entity Framework, kindly give me a lot of data...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JOIN local collection and DbSet in the Entity Framework</h1><div class="post__text post__text-html js-mediator-article"><p>  A little more than a year the following ‚Äúdialogue‚Äù took place with my participation: </p><br><p>  <strong>.Net App</strong> : Hey Entity Framework, kindly give me a lot of data! <br>  <strong>Entity Framework</strong> : Sorry, I did not understand you.  What do you mean? <br>  <strong>.Net App</strong> : Yes, I just flew a collection of 100k transactions.  And now we need to quickly check the correctness of the prices for the papers that are indicated there. <br>  <strong>Entity Framework</strong> : Aah, well, let's try ... <br>  <strong>.Net App</strong> : Here's the code: </p><br><pre><code class="cpp hljs">var query = from p in context.Prices join t in transactions on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { p.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; query.ToList();</code> </pre> <br><p>  <strong>Entity Framework</strong> : </p><br><p><img src="https://habrastorage.org/webt/kc/jh/lp/kcjhlpnggo_fhkdgik481svjuea.png"></p><br><p>  Classic!  I think many people are familiar with this situation: when you really want to ‚Äúbeautifully‚Äù and quickly do a search in the database using the <em>JOIN of the</em> local collection and <em>DbSet</em> .  Usually this experience is frustrating. </p><br><p>  In this article (which is a <em>free translation of another of my articles</em> ) I will conduct a series of experiments and try different ways to get around this limitation.  There will be a code (simple), reflections and something like a happy ending. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  Everyone knows about the <em>Entity Framework</em> , many use it every day, and there are many good articles on how to prepare it correctly (use simpler requests, use parameters in Skip and Take, use VIEW, request only the required fields, monitor the caching of requests and etc.), however, the <em>JOIN</em> topic of the local collection and <em>DbSet</em> is still a weak point. </p><br><h2 id="zadacha">  Task </h2><br><p>  Suppose that there is a database with prices and there is a collection of transactions that need to check the correctness of prices.  And, suppose we have the following code. </p><br><pre> <code class="cpp hljs">var localData = GetDataFromApiOrUser(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in localData on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { s.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; var result = query.ToList();</code> </pre> <br><p>  This code does not work in <em>Entity Framework 6</em> at all.  In <em>Entity Framework Core</em> - it works, but everything will be done on the client side even in the case when there are millions of records in the database - this is not the way out. </p><br><p>  As I said, I will try different ways to get around this.  From simple to complex.  For my experiments, I use the code from the following <a href="https://github.com/neisbut/EFContainsBenchmark">repository</a> .  The code is written using: <em>C #</em> , <em>.Net Core</em> , <em>EF Core</em> and <em>PostgreSQL</em> . </p><br><p>  I also shot some metrics: elapsed time and memory consumption.  Disclaimer: if the test was performed for more than 10 minutes - I interrupted it (restriction from above).  Machine for tests Intel Core i5, 8 GB RAM, SSD. </p><br><div class="spoiler">  <b class="spoiler_title">DB schema</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d5/f8c/cec/1d5f8ccec6ef1b7361195c18ac139d09.png" alt="image"></p><br><p>  Only 3 tables: <em>prices</em> , <em>securities</em> and <em>price sources</em> .  <em>Prices</em> - contains 10 million records. </p></div></div><br><h4 id="sposob-1-naive">  Method 1. Naive </h4><br><p>  Let's start with a simple one and use the following code: </p><br><div class="spoiler">  <b class="spoiler_title">Code for method 1</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in TestData) { result.AddRange(context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId)); } }</code> </pre> </div></div><br><p>  The idea is simple: in a loop we read the records from the database one by one and add them to the resulting collection.  This code has only one advantage - simplicity.  And one drawback is low speed: even if there is an index in the database, communication with the database server will take most of the time.  Metrics turned out such: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/985/61c/b6a/98561cb6a2566faff490fc2bf7432fb9.png" alt="image"></p><br><p>  Memory consumption is low.  For a large collection takes 1 minute.  For a start, not bad, but I want to quickly. </p><br><h4 id="sposob-2-naive-parallel">  Method 2. Naive parallel </h4><br><p>  Let's try to add parallelism.  The idea is to access the database from several threads. </p><br><div class="spoiler">  <b class="spoiler_title">Code for method 2</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;Price&gt;(); var partitioner = Partitioner.Create(<span class="hljs-number"><span class="hljs-number">0</span></span>, TestData.Count); Parallel.ForEach(partitioner, range =&gt; { var subList = TestData.Skip(range.Item1) .Take(range.Item2 - range.Item1) .ToList(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in subList) { var query = context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId); foreach (var el in query) { result.Add(el); } } } });</code> </pre> </div></div><br><p>  Result: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/916/d22/428/916d224282a3020dc31df6c67a18b070.png" alt="image"></p><br><p>  For small collections, this approach is even slower than the first method.  And for the biggest - 2 times faster.  Interestingly, 4 threads were generated on my machine, but this did not lead to 4x acceleration.  This suggests that the overhead in this method is significant: both on the client side and on the server side.  Memory consumption has increased, but only slightly. </p><br><h4 id="sposob-3-multiple-contains">  Method 3. Multiple Contains </h4><br><p>  Time to try something different and try to reduce the task to the execution of a single request.  Can be done as follows: </p><br><ol><li>  Prepare 3 collections of unique <em>Ticker</em> , <em>PriceSourceId</em> and <em>Date</em> values </li><li>  Run query and use 3 <em>contains</em> </li><li>  Recheck results locally </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code for method 3</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">//   var tickers = TestData.Select(x =&gt; x.Ticker).Distinct().ToList(); var dates = TestData.Select(x =&gt; x.TradedOn).Distinct().ToList(); var ps = TestData.Select(x =&gt; x.PriceSourceId).Distinct().ToList(); //    3 Contains var data = context.Prices .Where(x =&gt; tickers.Contains(x.Security.Ticker) &amp;&amp; dates.Contains(x.TradedOn) &amp;&amp; ps.Contains(x.PriceSourceId)) .Select(x =&gt; new { Price = x, Ticker = x.Security.Ticker, }) .ToList(); var lookup = data.ToLookup(x =&gt; $"{x.Ticker}, {x.Price.TradedOn}, {x.Price.PriceSourceId}"); //  foreach (var el in TestData) { var key = $"{el.Ticker}, {el.TradedOn}, {el.PriceSourceId}"; result.AddRange(lookup[key].Select(x =&gt; x.Price)); } }</span></span></code> </pre> </div></div><br><p>  The problem here is that the execution time and the amount of data returned strongly depends on the data itself (both in the query and in the database).  That is, only the necessary data can be returned, and even extra records can be returned (even 100 times more). </p><br><p>  This can be explained using the following example.  Suppose there is the following table with data: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2bb/ea5/f3f2bbea5148127963cab9010d2b2f10.png" alt="image"></p><br><p>  Suppose also that I need prices for <em>Ticker1</em> with <em>TradedOn</em> = <em>2018-01-01</em> and for <em>Ticker2</em> with <em>TradedOn</em> = <em>2018-01-02</em> . </p><br><p>  Then unique values ‚Äã‚Äãfor <em>Ticker</em> = ( <em>Ticker1</em> , <em>Ticker2</em> ) <br>  And unique values ‚Äã‚Äãfor <em>TradedOn</em> = ( <em>2018-01-01</em> , <em>2018-01-02</em> ) </p><br><p>  However, the result will be returned 4 entries, because they really correspond to these combinations.  This is bad because the more fields are used - the greater the chance of getting extra records as a result. </p><br><p>  For this reason, the data obtained in this way must be further filtered on the client side.  And this is the biggest drawback. <br>  The metrics are as follows: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd5/078/5ef/dd50785efd38900c4d18467607b87a1e.png" alt="image"></p><br><p>  Memory consumption is worse than all previous methods.  The number of read lines is many times the number of requested.  Tests for large collections were interrupted for more than 10 minutes.  This method is no good. </p><br><h4 id="sposob-4-predicate-builder">  Method 4. Predicate builder </h4><br><p>  Now let's try the other side: good old <em>Expression</em> .  Using them, you can build 1 large query in the following form: </p><br><p> <code>‚Ä¶ (.. AND .. AND ..) OR (.. AND .. AND ..) OR (.. AND .. AND ..) ‚Ä¶</code> </p> <br><p>  This gives hope that it will be possible to build 1 query and get only the necessary data for 1 visit.  Code: </p><br><div class="spoiler">  <b class="spoiler_title">Code for method 4</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { var baseQuery = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId select <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestData() { Ticker = s.Ticker, TradedOn = p.TradedOn, PriceSourceId = p.PriceSourceId, PriceObject = p }; var tradedOnProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>); var priceSourceIdProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>); var tickerProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>); var paramExpression = Expression.Parameter(typeof(TestData)); Expression wholeClause = null; foreach (var td in TestData) { var elementClause = Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, tradedOnProperty), Expression.Constant(td.TradedOn) ), Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, priceSourceIdProperty), Expression.Constant(td.PriceSourceId) ), Expression.Equal( Expression.MakeMemberAccess( paramExpression, tickerProperty), Expression.Constant(td.Ticker)) )); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wholeClause == null) wholeClause = elementClause; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> wholeClause = Expression.OrElse(wholeClause, elementClause); } var query = baseQuery.Where( (Expression&lt;Func&lt;TestData, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt;)Expression.Lambda( wholeClause, paramExpression)).Select(x =&gt; x.PriceObject); result.AddRange(query); }</code> </pre> </div></div><br><p>  The code turned out more complicated than in previous methods.  Building an <em>Expression</em> manually is not the easiest or quickest operation. </p><br><p>  Metrics: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/312/373/4fc/3123734fc82c4fc4d783f4f9ce2cf225.png" alt="image"></p><br><p>  Temporary results were even worse than in the previous method.  It seems that the overhead during the construction and passage through the tree turned out to be much greater than the gain from using one query. </p><br><h4 id="sposob-5-shared-query-data-table">  Method 5. Shared query data table </h4><br><p>  Now let's try another option: <br>  I created a new table in the database to which I will write the data necessary for the execution of the query (the new <em>DbSet</em> in context is implicitly needed). </p><br><p>  Now, to get the result you need: </p><br><ol><li>  Start transaction </li><li>  Load query data into new table </li><li>  Run the query itself (using the new table) </li><li>  Roll back a transaction (to clear the data table for queries) </li></ol><br><p>  The code looks like this: </p><br><div class="spoiler">  <b class="spoiler_title">Code for method 5</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { context.Database.BeginTransaction(); var reducedData = TestData.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedQueryModel() { PriceSourceId = x.PriceSourceId, Ticker = x.Ticker, TradedOn = x.TradedOn }).ToList(); <span class="hljs-comment"><span class="hljs-comment">//      context.QueryDataShared.AddRange(reducedData); context.SaveChanges(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in context.QueryDataShared on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); context.Database.RollbackTransaction(); }</span></span></code> </pre> </div></div><br><p>  First metrics: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df0/ab7/d7d/df0ab7d7d01b0aeaeebf2b9a41f5e75b.png" alt="image"></p><br><p>  All tests worked and worked quickly!  Memory consumption is also acceptable. <br>  Thus, due to the use of a transaction, this table can be used simultaneously by several processes.  And since this is a real-life table, all the capabilities of the <em>Entity Framework</em> are available to us: all we need is to load data into a table, build a query using a <em>JOIN,</em> and execute it.  At first glance, this is what is needed, but there are significant drawbacks: </p><br><ul><li>  You must create a table for a specific type of query. </li><li>  You need to use transactions (and spend DBMS resources on them) </li><li>  And the very idea that you need to WRITE something when you need to READ looks strange.  And on Read Replica it just will not work. <br>  And the rest - the solution is more or less working, which can already be used. </li></ul><br><h4 id="sposob-6-memoryjoin-extension">  Method 6. MemoryJoin extension </h4><br><p>  Now you can try to improve the previous approach.  Reflections are: </p><br><ul><li>  Instead of using a table that is specific to one type of query, you can use a generic version.  Namely, create a table with a name like <em>shared_query_data</em> , and add several <em>Guid</em> fields to it, several <em>Long</em> , several <em>String</em> , etc.  You can take simple names: <em>Guid1</em> , <em>Guid2</em> , <em>String1</em> , <em>Long1</em> , <em>Date2</em> , etc.  Then this table can be used for 95% of query types.  Property names can be ‚Äúcorrected‚Äù later using the <strong>Select</strong> projection. </li><li>  Next you need to add <em>DbSet</em> for <em>shared_query_data</em> . </li><li>  And what if instead of writing data to the database - to transfer values ‚Äã‚Äãusing the <strong>VALUES</strong> construction?  That is, it is necessary that in the final SQL query, instead of referring to <em>shared_query_data,</em> there be an appeal to <strong>VALUES</strong> .  How to do it? <br><ul><li>  In Entity Framework Core - just using <em>FromSql</em> . </li><li>  In Entity Framework 6, you will have to use <a href="https://docs.microsoft.com/ru-ru/ef/ef6/fundamentals/logging-and-interception">DbInterception</a> ‚Äî that is, change the generated SQL by adding the <strong>VALUES</strong> construct right before execution.  This will lead to the restriction: in one query - no more than one <strong>VALUES</strong> construct.  But it will work! </li></ul></li><li>  Since we are not going to write to the database, does the table <em>shared_query_data</em> , created in the first step, <em>turn</em> out to be not needed at all?  Answer: yes, it is not needed, but <em>DbSet</em> is still needed, since the Entity Framework needs to know the data schema in order to build queries.  It turns out that you need a <em>DbSet</em> for some generalized model that does not exist in the database and is used only to instill the Entity Framework that it knows what it is doing. </li></ul><br><div class="spoiler">  <b class="spoiler_title">An example of converting IEnumerable to IQueryable</b> <div class="spoiler_text"><ol><li>  At the entrance came a collection of objects of the following type: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeQueryData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Ticker {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTimeTradedOn {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PriceSourceId {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} }</code> </pre> </li><li>  We have a <em>DbSet</em> with the fields <em>String1</em> , <em>String2</em> , <em>Date1</em> , <em>Long1</em> , <em>etc</em> </li><li>  Let the <em>Ticker</em> be stored in <em>String1</em> , <em>TradedOn</em> in <em>Date1</em> , and <em>PriceSourceId</em> in <em>Long1</em> ( <em>int</em> maps into <em>long</em> , so as not to separate the fields for <em>int</em> and <em>long</em> ) </li><li>  Then <em>FromSql</em> + <em>VALUES</em> will be like this: <br><pre> <code class="cpp hljs">var query = context.QuerySharedData.FromSql( <span class="hljs-string"><span class="hljs-string">"SELECT * FROM ( VALUES (1, 'Ticker1', @date1, @id1), (2, 'Ticker2', @date2, @id2) ) AS __gen_query_data__ (id, string1, date1, long1)"</span></span>)</code> </pre> </li><li>  Now you can make a projection and return a convenient <em>IQueryable</em> that uses the same type as the input: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeQueryData() { Ticker = x.String1, TradedOn = x.Date1, PriceSourceId = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x.Long1 });</code> </pre> </li></ol></div></div><br><p>  I managed to implement this approach and even arrange it as a NuGet package <a href="https://www.nuget.org/packages/EntityFrameworkCore.MemoryJoin/">EntityFrameworkCore.MemoryJoin</a> ( <a href="https://github.com/neisbut/EntityFramework.MemoryJoin">code is</a> also available).  Despite the fact that the name has the word <em>Core</em> , <em>Entity Framework</em> 6 is also supported.  I called it <strong>MemoryJoin</strong> , but in fact it sends local data to the DBMS in the <em>VALUES</em> construction and all the work is done on it. </p><br><p>  The code is obtained as follows: </p><br><div class="spoiler">  <b class="spoiler_title">Code for method 6</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">// :    ,      var reducedData = TestData.Select(x =&gt; new { x.Ticker, x.TradedOn, x.PriceSourceId }).ToList(); //  IEnumerable&lt;&gt;   IQueryable&lt;&gt; var queryable = context.FromLocalList(reducedData); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in queryable on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); }</span></span></code> </pre> </div></div><br><p>  Metrics: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a7/d72/bb2/6a7d72bb265d9dedbc8e54d94fe16a4f.png" alt="image"></p><br><p>  This is the best result I've ever tried.  The code turned out very simple and clear, and at the same time working for Read Replica. </p><br><div class="spoiler">  <b class="spoiler_title">Sample generated query to get 3 items</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"ClosePrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"OpenPrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"Price"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-string"><span class="hljs-string">"Security"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"s"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> = <span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"string1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"date1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"long1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> int4) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, @__gen_q_p0, @__gen_q_p1, @__gen_q_p2), (<span class="hljs-number"><span class="hljs-number">2</span></span>, @__gen_q_p3, @__gen_q_p4, @__gen_q_p5), (<span class="hljs-number"><span class="hljs-number">3</span></span>, @__gen_q_p6, @__gen_q_p7, @__gen_q_p8) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> __gen_query_data__ (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, string1, date1, long1) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"t"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ((<span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (<span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>)</code> </pre> <br><p>  It also shows how the generic model (with the fields <em>String1</em> , <em>Date1</em> , <em>Long1</em> ) with the help of Select turns into the one that is used in the code (with the fields <em>Ticker</em> , <em>TradedOn</em> , <em>PriceSourceId</em> ). </p></div></div><br><p>  All work is done for 1 query on the SQL server.  And this is a small happy ending, which I mentioned at the beginning.  And yet the use of this method requires an understanding of the following steps: </p><br><ul><li>  You need to add an additional <em>DbSet</em> to your context (although you can not add the table itself) </li><li>  In the generalized model, which is used by default, 3 fields of the types <em>Guid</em> , <em>String</em> , <em>Double</em> , <em>Long</em> , <em>Date</em> , etc. are declared.  That should be enough for 95% of request types.  And if you pass a collection of objects with 20 fields to <em>FromLocalList</em> , <em>Exception</em> will be thrown, saying that the object is too complex.  This is a mild restriction and it can be circumvented - you can declare your type and add at least 100 fields there.  However, more fields - slower work. </li><li>  More technical details are described in my <a href="http://tsherlock.tech/2018/03/20/joining-in-memory-list-to-entity-framework-query/">article</a> . </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, I set out my thoughts on the JOIN of the local collection and DbSet.  It seemed to me that my development using <em>VALUES</em> might be of interest to the community.  At least I have not met such an approach when I solved this task myself.  Personally, this method helped me to overcome a number of performance problems in my current projects, maybe it will help you too. </p><br><p>  Someone will say that the use of <em>MemoryJoin is</em> too "abstruse" and needs to be improved, but until then it is not necessary to use it.  This is exactly the reason why I really doubted and did not write this article for almost a year.  I agree that I would like it to work easier (I hope it will happen one day), but I will also say that optimization has never been the task of the Juniors.  Optimization always requires an understanding of how the tool works.  And if there is an opportunity to get acceleration ~ 8 times ( <em>Naive Parallel</em> vs <em>MemoryJoin</em> ), then I would master 2 points and documentation. </p><br><p>  And finally, the charts: </p><br><p>  Time spent  Only 4 ways completed the task in less than 10 minutes, and <em>MemoryJoin</em> is the only way that completed the task in less than 10 seconds. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/720/256/846/72025684620477d221c0f113a6cb354f.png" alt="image"></p><br><p>  Memory consumption.  All methods showed approximately the same memory consumption, except for <em>Multiple Contains</em> .  This is due to the amount of data returned. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e07/a91/b63/e07a91b63375d49a21adb81e8213ffdb.png" alt="image"></p><br><p>  Thanks for reading! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435810/">https://habr.com/ru/post/435810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435798/index.html">Sony WH-1000XM3 - the best wireless headphones?</a></li>
<li><a href="../435800/index.html">Letter of the Decembrist11</a></li>
<li><a href="../435802/index.html">OpenVPN, about which you knew so little</a></li>
<li><a href="../435804/index.html">Intel Cyclone does not save configuration after reboot</a></li>
<li><a href="../435806/index.html">Clinical trials of bioengineering heart patch announced in Japan</a></li>
<li><a href="../435812/index.html">The theory of happiness. Statistics, as a scientific way to not know anything</a></li>
<li><a href="../435814/index.html">[The Old New Thing] Can I use my stack as I like?</a></li>
<li><a href="../435816/index.html">Massachusetts Hospital and DeepMind independently opened the "black box" of AI in medicine</a></li>
<li><a href="../435822/index.html">How to manage iron in the data center using sound</a></li>
<li><a href="../435824/index.html">What you need to know before you start a career in the audio industry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>