<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional programming jargon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Functional programming has many advantages, and its popularity is constantly growing. But, like any programming paradigm, the FP has its own jargon. W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional programming jargon</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/c94/6aa/c01/c946aac01f494ceb8e9e8f6986802b4c.jpg"></p><br><p>  Functional programming has many advantages, and its popularity is constantly growing.  But, like any programming paradigm, the FP has its own jargon.  We decided to make a small dictionary for everyone who is familiar with the OP. </p><br><p>  The examples use javascript ES2015).  ( <a href="https://github.com/hemanth/functional-programming-jargon/wiki/Why-JavaScript%253F">Why javascript?</a> ) </p><br><p>  <em>Work on the material <a href="https://github.com/hemanth/functional-programming-jargon/issues/20">continues</a> ;</em>  <em>send your pull-requests to the original repository in English.</em> </p><br><p>  The document uses terms from the <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a> specification as needed. </p><br><h2>  Arity </h2><br><p>  The number of function arguments.  From the words unary, binary, ternary (unary, binary, ternary) and so on.  This is an unusual word because it consists of two suffixes: "-ary" and "-ity.".  Addition, for example, takes two arguments, so this is a binary function, or a function that has an arity equal to two.  Sometimes the term "dyadic" (dyadic) is used if they prefer Greek roots instead of Latin ones.  A function that takes an arbitrary number of arguments is called the variadic, respectively.  But a binary function can take two and only two arguments, without regard to currying or partial application. <a name="habracut"></a></p><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arity = sum.length <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arity) <span class="hljs-comment"><span class="hljs-comment">// 2 // The arity of sum is 2</span></span></code> </pre> <br><h2>  Higher-Order Functions (high order functions) </h2><br><p>  A function that takes a function as an argument and / or returns a function. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">predicate, xs</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; idx &lt; xs.length; idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate(xs[idx])) { result.push(xs[idx]) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result }</code> </pre> <br><pre> <code class="hljs lisp">const is = (<span class="hljs-name"><span class="hljs-name">type</span></span>) =&gt; (<span class="hljs-name"><span class="hljs-name">x</span></span>) =&gt; Object(<span class="hljs-name"><span class="hljs-name">x</span></span>) instanceof type</code> </pre><br><pre> <code class="hljs cs">filter(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(Number), [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// [0, 2]</span></span></code> </pre> <br><h2>  Partial Application (partial application) </h2><br><p>  Partial application of the function means the creation of a new function with the pre-filling of some of the arguments of the original function. </p><br><pre> <code class="hljs sql">// Helper to <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> partially applied functions // Takes a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> arguments const <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> = (f, ...args) =&gt; // <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> that takes the rest <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the arguments (...moreArgs) =&gt; // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calls the original <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> them f(...args, ...moreArgs) // Something <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> const add3 = (a, b, c) =&gt; a + b + c // Partially applying <span class="hljs-string"><span class="hljs-string">`2`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">`3`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">`add3`</span></span> gives you a one-argument <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> const fivePlus = <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span>(add3, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) // (c) =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + c fivePlus(<span class="hljs-number"><span class="hljs-number">4</span></span>) // <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br><p>  Also in JS, you can use <code>Function.prototype.bind</code> to partially apply the function: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add1More = add3.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">// (c) =&gt; 2 + 3 + c</span></span></code> </pre> <br><p>  Due to preliminary data preparation, partial application helps to create simpler and more complex functions.  Functions with currying automatically perform partial applications. </p><br><h2>  Currying </h2><br><p>  The process of converting a function that takes several arguments to a function that takes one argument at a time. </p><br><p>  For each function call, it takes one argument and returns a function that takes one argument until all arguments have been processed. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> curriedSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> (b) =&gt; a + b curriedSum(<span class="hljs-number"><span class="hljs-number">40</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 42. const add2 = curriedSum(2) // (b) =&gt; 2 + b add2(10) // 12</span></span></code> </pre><br><h2>  Auto Currying (automatic currying) </h2><br><p>  Transform a function that takes several arguments to a new function.  If you pass a smaller number of arguments to the new function, it will return a function that accepts the remaining arguments.  When the function receives the correct number of arguments, it is executed. </p><br><p>  In Underscore, lodash and ramda there is a <code>curry</code> function. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> = (x, y) =&gt; x + y <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> curriedAdd = _.curry(<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>) curriedAdd(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 3 curriedAdd(1) // (y) =&gt; 1 + y curriedAdd(1)(2) // 3</span></span></code> </pre> <br><p>  <strong>Additional materials</strong> </p><br><ul><li>  <a href="http://fr.umio.us/favoring-curry/">Favoring curry</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3Dm3svKOdZijA">Hey Underscore, You're Doing It Wrong!</a> </li></ul><br><h2>  Function Composition </h2><br><p>  Combining two functions to form a new function in which the output of the first function is the input of the second. </p><br><pre> <code class="hljs coffeescript">const compose = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, g)</span></span></span><span class="hljs-function"> =&gt;</span></span> (a) =&gt; f(g(a)) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Definition const floorAndToString = compose(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span><span class="hljs-function"> =&gt;</span></span> val.toString(), Math.floor) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Usage floorAndToString(<span class="hljs-number"><span class="hljs-number">121.212121</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'121'</span></span></code> </pre> <br><h2>  Purity </h2><br><p>  A function is pure if the value returned to it is determined solely by the input values, and the function has no side effects. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Hi, '</span></span> + name greet(<span class="hljs-string"><span class="hljs-string">'Brianne'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 'Hi, Brianne'</span></span></code> </pre><br><p>  Unlike: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greeting <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { greeting = <span class="hljs-string"><span class="hljs-string">'Hi, '</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.name } greet() <span class="hljs-comment"><span class="hljs-comment">// "Hi, Brianne"</span></span></code> </pre><br><h2>  Side effects </h2><br><p>  A function has side effects if, in addition to returning a value, it interacts (reads or writes) with an external changeable state. </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> differentEveryTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()</code> </pre> <br><pre> <code class="hljs vhdl">console.log(<span class="hljs-symbol"><span class="hljs-symbol">'IO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-literal"><span class="hljs-literal">side</span></span> effect!')</code> </pre> <br><h2>  Idempotent (idempotency) </h2><br><p>  A function is idempotent if its repeated execution produces the same result. </p><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f(x))</span></span></span><span class="hljs-function"> ‚âç </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span></code> </pre> <br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-type"><span class="hljs-type">Math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><pre> <code class="hljs lisp">sort(<span class="hljs-name"><span class="hljs-name">sort</span></span>(<span class="hljs-name"><span class="hljs-name">sort</span></span>([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])))</code> </pre> <br><h2>  Point-Free Style (Pointless Notation) </h2><br><p>  Writing functions in such a way that the definition implicitly indicates the number of arguments used.  This style usually requires currying or another high-order function (or, in general, implicit programming). </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Given const map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span><span class="hljs-function"> =&gt;</span></span> (list) =&gt; list.map(fn) const add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function"> =&gt;</span></span> (b) =&gt; a + b <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Then <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Not points-free - `<span class="javascript"><span class="javascript">numbers</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an explicit argument const incrementAll = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(numbers)</span></span></span><span class="hljs-function"> =&gt;</span></span> map(add(<span class="hljs-number"><span class="hljs-number">1</span></span>))(numbers) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Points-free - The list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an implicit argument const incrementAll2 = map(add(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><p>  The <code>incrementAll</code> function defines and uses the <code>numbers</code> parameter, so that it does not use pointless notation.  <code>incrementAll2</code> simply combines functions and values ‚Äã‚Äãwithout mentioning arguments.  It <strong>uses no-</strong> point notation. </p><br><p>  Definitions with no-point notation look like ordinary assignments without <code>function</code> or <code>=&gt;</code> . </p><br><h2>  Predicate (predicate) </h2><br><p>  A predicate is a function that returns true or false depending on the value passed.  A common case of using a predicate is a callback function for an array filter. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predicate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].filter(predicate) <span class="hljs-comment"><span class="hljs-comment">// [3, 4]</span></span></code> </pre> <br><h2>  Categories </h2><br><p>  Objects with functions that obey certain rules.  For example, monoids. </p><br><h2>  Value </h2><br><p>  Anything that can be assigned to a variable. </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, age: <span class="hljs-number"><span class="hljs-number">30</span></span>}) // The `<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> enforces immutability. ;(a) =&gt; a ;[<span class="hljs-number"><span class="hljs-number">1</span></span>] undefined</code> </pre> <br><h2>  Constant (constant) </h2><br><p>  Variable that cannot be reassigned after definition. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> five = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> john = {name: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, age: <span class="hljs-number"><span class="hljs-number">30</span></span>}</code> </pre> <br><p>  Constants have referential transparency or referential transparency.  That is, they can be replaced by the values ‚Äã‚Äãthat they represent, and this will not affect the result. </p><br><p>  With constants from the previous listing, the following expression will always return <code>true</code> . </p><br><pre> <code class="hljs pgsql">john.age + five === ({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, age: <span class="hljs-number"><span class="hljs-number">30</span></span>}).age + (<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><h2>  Functor (functor) </h2><br><p>  An object that implements the <code>map</code> function, which, when traversing all values ‚Äã‚Äãin an object, creates a new object, and obeys two rules: </p><br><pre> <code class="hljs pgsql">//    (<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.map(x =&gt; x) === <span class="hljs-keyword"><span class="hljs-keyword">object</span></span></code> </pre> <br><p>  and </p><br><pre> <code class="hljs vhdl">//   object.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(x =&gt; f(g(x))) === object.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(g).<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(f)</code> </pre> <br><p>  ( <code>f</code> , <code>g</code> - arbitrary functions) </p><br><p>  JavaScript has an <code>Array</code> functor because it obeys these rules: </p><br><pre> <code class="hljs javascript">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x) <span class="hljs-comment"><span class="hljs-comment">// = [1, 2, 3]</span></span></code> </pre> <br><p>  and </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> g = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x * <span class="hljs-number"><span class="hljs-number">2</span></span> ;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> f(g(x))) <span class="hljs-comment"><span class="hljs-comment">// = [3, 5, 7] ;[1, 2, 3].map(g).map(f) // = [3, 5, 7]</span></span></code> </pre> <br><h2>  Pointed Functor (pointing functor) </h2><br><p>  An object with a of function with <em>any</em> value.  In ES2015, there is <code>Array.of</code> , which makes arrays a pointing functor. </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// [1]</span></span></code> </pre> <br><h2>  Lift </h2><br><p>  Lifting is when a value is placed in an object like a functor.  If we "lift" (lift) a function into an applicative functor, then we can make it work with values ‚Äã‚Äãthat are also present in the functor. </p><br><p>  In some implementations, there is a function <code>lift</code> or <code>liftA2</code> , which are used to simplify the launch of functions on functors. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> liftA2 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) =&gt;</span></span> (a, b) =&gt; a.map(f).ap(b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mult = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> b =&gt; a * b <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> liftedMult = liftA2(mult) <span class="hljs-comment"><span class="hljs-comment">// this function now works on functors like array liftedMult([1, 2], [3]) // [3, 6] liftA2((a, b) =&gt; a + b)([1, 2], [3, 4]) // [4, 5, 5, 6]</span></span></code> </pre> <br><p>  Raising a function with one argument and applying it does the same thing as <code>map</code> . </p><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> = (x) =&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span> lift(<span class="hljs-keyword"><span class="hljs-keyword">increment</span></span>)([<span class="hljs-number"><span class="hljs-number">2</span></span>]) // [<span class="hljs-number"><span class="hljs-number">3</span></span>] ;[<span class="hljs-number"><span class="hljs-number">2</span></span>].map(<span class="hljs-keyword"><span class="hljs-keyword">increment</span></span>) // [<span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><h2>  Referential Transparency </h2><br><p>  If an expression can be replaced with its value without affecting the program's behavior, then it has transparency of the links. </p><br><p>  For example, there is a <code>greet</code> function: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span></code> </pre> <br><p>  Any <code>greet()</code> call can be replaced with <code>Hello World!</code>  so this function is transparent (referentially transparent). </p><br><h2>  Lambda (lambda) </h2><br><p>  An anonymous function that can be used as a value. </p><br><pre> <code class="hljs javascript">;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (a</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> + 1 }) ;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Lambdas are often passed as arguments to higher order functions. </p><br><pre> <code class="hljs javascript">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>].map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// [2, 3]</span></span></code> </pre> <br><p>  Lambda can be assigned to a variable. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add1 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>  Lambda Calculus (lambda calculus) </h2><br><p>  Informatics, in which functions are used to create a <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%258F%25D0%25BC%25D0%25B1%25D0%25B4%25D0%25B0-%25D0%25B8%25D1%2581%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">universal model of calculus</a> . </p><br><h2>  Lazy evaluation </h2><br><p>  The calculation mechanism, if necessary, with a delay in the calculation of the expression until the value is required.  In functional languages, this allows you to create structures like endless lists that are not normally possible in imperative programming languages, where the order of commands matters. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rand = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() } }</code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randIter = rand() randIter.next() <span class="hljs-comment"><span class="hljs-comment">//     ,    .</span></span></code> </pre> <br><h2>  Monoid </h2><br><p>  An object with a function that "combines" an object with another object of the same type.  A simple example of a monoid is the addition of numbers: </p><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre> <br><p>  In this case, the number is an object, and <code>+</code> is a function. </p><br><p>  There must be a neutral element (identity), so that combining the value with it does not change the value.  In the case of addition, such an element is <code>0</code> . </p><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br><p>  It is also necessary that the grouping of operations does not affect the result (associativity): </p><br><pre> <code class="hljs lisp"><span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>) === (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">3</span></span> // true</code> </pre> <br><p>  Concatenation of arrays is also a monoid: </p><br><pre> <code class="hljs objectivec">;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>].concat([<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4]</span></span></code> </pre> <br><p>  The neutral element is an empty array <code>[]</code> </p><br><pre> <code class="hljs objectivec">;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>].concat([]) <span class="hljs-comment"><span class="hljs-comment">// [1, 2]</span></span></code> </pre> <br><p>  If there are functions of a neutral element and composition, then the functions as a whole form a monoid: </p><br><pre> <code class="hljs lisp">const identity = (<span class="hljs-name"><span class="hljs-name">a</span></span>) =&gt; a const compose = (<span class="hljs-name"><span class="hljs-name">f</span></span>, g) =&gt; (<span class="hljs-name"><span class="hljs-name">x</span></span>) =&gt; f(<span class="hljs-name"><span class="hljs-name">g</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span>))</code> </pre><br><p>  <code>foo</code> is any function with one argument. </p><br><pre> <code class="hljs pgsql">compose(foo, <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>) ‚âç compose(<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>, foo) ‚âç foo</code> </pre> <br><h2>  Monad </h2><br><p>  A monad is an object with the functions <code>of</code> and <code>chain</code> .  <code>chain</code> is similar to <code>map</code> , but it decomposes nested objects as a result. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Implementation Array.prototype.chain = function (f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reduce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, it)</span></span></span><span class="hljs-function"> =&gt;</span></span> acc.concat(f(it)), []) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Usage ;Array.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">'cat,dog'</span></span>, <span class="hljs-string"><span class="hljs-string">'fish,bird'</span></span>).chain(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function"> =&gt;</span></span> a.split(<span class="hljs-string"><span class="hljs-string">','</span></span>)) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'dog'</span></span>, <span class="hljs-string"><span class="hljs-string">'fish'</span></span>, <span class="hljs-string"><span class="hljs-string">'bird'</span></span>] <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Contrast to map ;Array.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">'cat,dog'</span></span>, <span class="hljs-string"><span class="hljs-string">'fish,bird'</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function"> =&gt;</span></span> a.split(<span class="hljs-string"><span class="hljs-string">','</span></span>)) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [[<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'dog'</span></span>], [<span class="hljs-string"><span class="hljs-string">'fish'</span></span>, <span class="hljs-string"><span class="hljs-string">'bird'</span></span>]]</code> </pre> <br><p>  <code>of</code> also known as <code>return</code> in other functional languages. <br>  <code>chain</code> also known as <code>flatmap</code> and <code>bind</code> in other languages. </p><br><h2>  Comonad </h2><br><p>  An object with <code>extract</code> and <code>extend</code> functions. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CoIdentity = (v) =&gt; ({ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>: v, extract () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> }, extend (f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CoIdentity(f(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } })</code> </pre> <br><p>  Extract takes a value from the functor. </p><br><pre> <code class="hljs objectivec">CoIdentity(<span class="hljs-number"><span class="hljs-number">1</span></span>).extract() <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br><p>  Extend performs a function on the board.  The function should return the same type as the comonade. </p><br><pre> <code class="hljs javascript">CoIdentity(<span class="hljs-number"><span class="hljs-number">1</span></span>).extend(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">co</span></span></span><span class="hljs-function">) =&gt;</span></span> co.extract() + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// CoIdentity(2)</span></span></code> </pre> <br><h2>  Applicative Functor (applicative functor) </h2><br><p>  An object with the <code>ap</code> function.  <code>ap</code> applies a function in an object to a value in another object of the same type. </p><br><pre> <code class="hljs pgsql">// Implementation <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.ap = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (xs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.reduce((acc, f) =&gt; acc.concat(xs.map(f)), []) } // Example <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span> ;[(a) =&gt; a + <span class="hljs-number"><span class="hljs-number">1</span></span>].ap([<span class="hljs-number"><span class="hljs-number">1</span></span>]) // [<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br><p>  This is useful when there are two objects, and you need to apply a binary operation on their contents. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Arrays that you want to combine const arg1 = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] const arg2 = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> combining function - must be curried <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> to work const add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> =&gt;</span></span> (y) =&gt; x + y const partiallyAppliedAdds = [add].ap(arg1) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [(y) =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + y, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> + y]</code> </pre> <br><p>  As a result, we obtain an array of functions that can be called with <code>ap</code> to get the result: </p><br><pre> <code class="hljs objectivec">partiallyAppliedAdds.ap(arg2) <span class="hljs-comment"><span class="hljs-comment">// [5, 6, 7, 8]</span></span></code> </pre> <br><h2>  Morphism </h2><br><p>  Transformation function </p><br><h3>  Endomorphism (endomorphism) </h3><br><p>  A function whose input and output are of the same type. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> uppercase :: String -&gt; String const uppercase = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span><span class="hljs-function"> =&gt;</span></span> str.toUpperCase() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> decrement :: Number -&gt; Number const decrement = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> =&gt;</span></span> x - <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3>  Isomorphism (isomorphism) </h3><br><p>  A pair of structural transformations between two types of objects without data loss. </p><br><p>  For example, two-dimensional coordinates can be stored in array <code>[2,3]</code> or object <code>{x: 2, y: 3}</code> . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Providing functions to convert <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> both directions makes them isomorphic. const pairToCoords = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pair)</span></span></span><span class="hljs-function"> =&gt;</span></span> ({x: pair[<span class="hljs-number"><span class="hljs-number">0</span></span>], y: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]}) const coordsToPair = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coords)</span></span></span><span class="hljs-function"> =&gt;</span></span> [coords.x, coords.y] coordsToPair(pairToCoords([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>])) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] pairToCoords(coordsToPair({x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span>})) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> {x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span>}</code> </pre> <br><h2>  Setoid </h2><br><p>  An object that has an <code>equals</code> function that can be used to compare objects of the same type. </p><br><p>  Make an array a setoid: </p><br><pre> <code class="hljs kotlin">Array.prototype.equals = (arr) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len !== arr.length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] !== arr[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>].equals([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// true ;[1, 2].equals([0]) // false</span></span></code> </pre> <br><h2>  Semigroup (semigroup) </h2><br><p>  An object with a <code>concat</code> function that combines it with another object of the same type. </p><br><pre> <code class="hljs objectivec">;[<span class="hljs-number"><span class="hljs-number">1</span></span>].concat([<span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// [1, 2]</span></span></code> </pre> <br><h2>  Foldable </h2><br><p>  An object in which there is a <code>reduce</code> function that transforms an object into another type. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) =&gt;</span></span> list.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> acc + val, <span class="hljs-number"><span class="hljs-number">0</span></span>) sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br><h2>  Type Signatures (type signatures) </h2><br><p>  Often functions in JavaScript contain comments indicating the types of their arguments and return values.  There are different approaches in the community, but they are all similar: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> functionName :: firstArgType -&gt; secondArgType -&gt; returnType <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> add :: Number -&gt; Number -&gt; Number const add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> =&gt;</span></span> (y) =&gt; x + y <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> increment :: Number -&gt; Number const increment = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  If the function takes another function as an argument, then it is placed in parentheses. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> call :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a -&gt; b)</span></span></span><span class="hljs-function"> -&gt;</span></span> a -&gt; b const call = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span><span class="hljs-function"> =&gt;</span></span> (x) =&gt; f(x)</code> </pre><br><p>  The symbols <code>a</code> , <code>b</code> , <code>c</code> , <code>d</code> show that the arguments can be of any type.  The next version of the <code>map</code> function accepts: </p><br><ol><li>  a function that transforms a value of type <code>a</code> to another type <code>b</code> </li><li>  array of values ‚Äã‚Äãof type <code>a</code> , </li></ol><br><p>  and returns an array of values ‚Äã‚Äãof type <code>b</code> . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> map :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a -&gt; b)</span></span></span><span class="hljs-function"> -&gt;</span></span> [a] -&gt; [b] const map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span><span class="hljs-function"> =&gt;</span></span> (list) =&gt; list.map(f)</code> </pre><br><p>  <strong>Additional materials</strong> </p><br><ul><li>  <a href="https://github.com/ramda/ramda/wiki/Type-Signatures">Ramda's type signatures</a> </li><li>  <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch7.html">Mostly Adequate Guide</a> </li><li>  <a href="http://stackoverflow.com/a/399392/22425">What is Hindley-Milner?</a>  on stack overflow </li></ul><br><h2>  Union type </h2><br><p>  The combination of two types in one, a new type. </p><br><p>  There are no static types in JavaScript, but let's imagine that we invented the type <code>NumOrString</code> , which is the addition of <code>String</code> and <code>Number</code> . </p><br><p>  The <code>+</code> operation in JavaScript works with strings and numbers, so you can use our new type to describe its input and output: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> add :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NumOrString, NumOrString)</span></span></span><span class="hljs-function"> -&gt;</span></span> NumOrString const add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> =&gt;</span></span> a + b add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">3</span></span> add(<span class="hljs-string"><span class="hljs-string">'Foo'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"Foo2"</span></span> add(<span class="hljs-string"><span class="hljs-string">'Foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'Bar'</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"FooBar"</span></span></code> </pre> <br><p>  A union type is also known as an algebraic type, a marked union, and a sum-type. </p><br><p>  There are a <a href="https://github.com/paldepind/union-type">couple of</a> JavaScript <a href="https://github.com/puffnfresh/daggy">libraries</a> to define and use such types. </p><br><h2>  Product type </h2><br><p>  Type- <strong>product</strong> combines types in such a way that you are most likely familiar with: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> point :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Number, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> {x: Number, y: Number} const point = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> =&gt;</span></span> ({x: x, y: y})</code> </pre> <br><p>  It is called the product, because the possible value of the data structure is the product (product) of different values. </p><br><p>  See also: <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2">set theory</a> . </p><br><h2>  Option (option) </h2><br><p>  Type-union with two cases: <code>Some</code> and <code>None</code> .  Useful for composing functions that may not return values. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Naive definition const Some = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ val: v, map (f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Some(f(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val)) }, chain (f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val) } }) const None = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ map (f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, chain (f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } }) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> maybeProp :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String, {a})</span></span></span><span class="hljs-function"> -&gt;</span></span> Option a const maybeProp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key, obj)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> obj[key] === <span class="hljs-string"><span class="hljs-string">'undefined'</span></span> ? None() : Some(obj[key])</code> </pre><br><p>  Use <code>chain</code> to build a sequence of functions that return <code>Option</code> . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> getItem :: Cart -&gt; Option CartItem const getItem = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cart)</span></span></span><span class="hljs-function"> =&gt;</span></span> maybeProp(<span class="hljs-string"><span class="hljs-string">'item'</span></span>, cart) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> getPrice :: Item -&gt; Option Number const getPrice = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item)</span></span></span><span class="hljs-function"> =&gt;</span></span> maybeProp(<span class="hljs-string"><span class="hljs-string">'price'</span></span>, item) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> getNestedPrice :: cart -&gt; Option a const getNestedPrice = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cart)</span></span></span><span class="hljs-function"> =&gt;</span></span> getItem(obj).chain(getPrice) getNestedPrice({}) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> None() getNestedPrice({item: {foo: <span class="hljs-number"><span class="hljs-number">1</span></span>}}) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> None() getNestedPrice({item: {price: <span class="hljs-number"><span class="hljs-number">9.99</span></span>}}) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Some(<span class="hljs-number"><span class="hljs-number">9.99</span></span>)</code> </pre> <br><p>  <code>Option</code> also known as <code>Maybe</code> .  <code>Some</code> sometimes called <code>Just</code> .  <code>None</code> sometimes called <code>Nothing</code> . </p><br><h2>  JavaScript functional programming libraries </h2><br><ul><li>  <a href="https://github.com/ramda/ramda">Ramda</a> </li><li>  <a href="http://folktalejs.org/">Folktale</a> </li><li>  <a href="https://github.com/lodash/lodash">lodash</a> </li><li>  <a href="https://github.com/jashkenas/underscore">Underscore.js</a> </li><li>  <a href="">Lazy.js</a> </li><li>  <a href="">maryamyriameliamurphies.js</a> </li><li>  <a href="https://github.com/casualjavascript/haskell-in-es6">Haskell in ES6</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/310172/">https://habr.com/ru/post/310172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310162/index.html">Progrobot: programming language help bot</a></li>
<li><a href="../310164/index.html">Linux debugging tools</a></li>
<li><a href="../310166/index.html">Modern web development for schoolchildren</a></li>
<li><a href="../310168/index.html">The potential benefits of iOS 10 for developing and testing mobile applications (Translated article)</a></li>
<li><a href="../310170/index.html">Forcing to caching: fasten L2 Apache Ignite cache to Activiti</a></li>
<li><a href="../310174/index.html">Exposing antivirus tests</a></li>
<li><a href="../310176/index.html">Logeek Night in Voronezh</a></li>
<li><a href="../310180/index.html">What is such a Data? Or again about MapReduce</a></li>
<li><a href="../310182/index.html">The problem of dissonance between the narrative and the gameplay</a></li>
<li><a href="../310186/index.html">Responsive Font Size</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>