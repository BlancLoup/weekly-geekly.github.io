<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why can't I send UDP packets through a browser?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In 2017, most of the popular web games like agar.io use WebSockets over TCP for data transfer. If browsers had a built-in UDP analogue ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why can't I send UDP packets through a browser?</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In 2017, most of the popular web games like <a href="https://agar.io/">agar.io</a> use WebSockets over TCP for data transfer.  If browsers had a built-in UDP analogue of WebSockets, then this would greatly improve the work with networks in these games. <br><br><h2>  Introductory information </h2><br>  Web browsers are based on the <a href="https://ru.wikipedia.org/wiki/HTTP">HTTP protocol</a> (stateless request and response protocol).  It was originally designed to serve static web pages.  HTTP works on top of TCP, a low-level protocol that guarantees reliable delivery and correct order of data transmitted over the Internet. <br><br>  All of this worked fine for many years, but recently websites have become more interactive and have stopped responding to the request-response paradigm of the HTTP protocol.  To solve this problem, modern web protocols, such as WebSockets, WebRTC, HTTP 2.0, and QUIC, have the potential to significantly improve network interactivity. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unfortunately, the new set of web development standards does not meet the needs of multiplayer games or is too complicated to implement. <br><br>  This is frustrating for game developers, because they just want to be able to send and receive UDP packets through a browser. <br><a name="habracut"></a><br><h2>  Problem </h2><br>  The web is built on top of TCP, which is a packet-ordering protocol.  For reliable delivery of data in the right order in the face of packet loss, TCP must keep the latest data in the queue, waiting for resending the lost packets.  Otherwise, the data will be delivered in the wrong order. <br><br>  This principle is called <strong>blocking the turn of the queue</strong> .  It creates an annoying developer and an almost tragicomic situation.  The most recent data that they need is waiting for the old data to be sent again, but at the time of sending the data they are already outdated and are becoming useless. <br><br>  Unfortunately, this process cannot be corrected within the framework of TCP; in it all data must be received without fail in the necessary order.  Therefore, the standard solution for the gaming industry over the past 20 years has been the transfer of data over UDP. <br><br>  In practice, this meant that each game developed its own protocol over UDP, implementing all the necessary functionality, and sending most of the data in an unreliable way without preserving order.  This ensured the fastest possible delivery of time data without waiting for the retransmission of lost packets. <br><br>  And what should be done in the case of web games? <br><br>  The main problem of web games today is that game developers are not able to use the best solution chosen by the gaming industry in the browser.  Instead, web games send game data over TCP, which results in low responsiveness. <br><br>  Using TCP is completely optional, this problem could be solved "at the click of a finger", if web games had the opportunity to send and receive UDP packets. <br><br><h2>  What is WebSockets? </h2><br>  WebSockets is an extension to the HTTP protocol that modifies an HTTP connection so that data can be transferred in both directions.  At the same time, the standard request-response pattern is not used. <br><br>  This technique allows you to elegantly solve the problem of web sites that need to display dynamically changing content, because after installing a websocket connection, the server can send data to the browser without a request. <br><br>  Unfortunately, since WebSockets is implemented on top of TCP, data is still subject to blocking the start of the queue. <br><br><h2>  What is QUIC? </h2><br>  <a href="https://ru.wikipedia.org/wiki/QUIC">QUIC</a> is an experimental protocol created over UDP and developed as a replacement transport layer for HTTP.  Currently it is supported only by Google Chrome. <br><br>  The most important feature of QUIC is support for multiple data streams.  A client or server can implicitly create new channels by increasing the channel id. <br><br>  The concept of channels provides two big advantages: <br><br><ol><li>  Avoids sending connection confirmation requests each time a new request is created. </li><li>  Eliminates blocking the beginning of the queue between unrelated data streams. </li></ol><br>  Unfortunately, although we eliminate the problem of blocking the beginning of the queue for individual threads, it still exists <em>inside</em> each thread. <br><br><h2>  What is WebRTC? </h2><br>  <a href="https://ru.wikipedia.org/wiki/WebRTC">WebRTC</a> is a set of protocols that provide a peer-to-peer connection between browsers for applications such as streaming audio and video. <br><br>  I note that WebRTC supports a data channel that can be configured to ‚Äúunreliable‚Äù mode, which allows for unreliable data transfer through the browser without saving the order. <br><br>  So why are we still using WebSockets in modern 2017 browser games? <br><br>  The reason is that in multiplayer games there is a tendency of transition from peer-to-peer transmission to the client-server model.  And although WebRTC allows you to conveniently send unreliable "erratic" data from the browser to the browser, it crashes when data transfer between the browser and the dedicated server is required. <br><br>  The problem arises due to the <em>extreme complexity of</em> WebRTC.  The reasons for this complexity are clear: WebRTC was primarily designed for peer-to-peer data exchange between browsers, therefore, in the worst case, it requires support for STUN, ICE and TURN to bypass NAT. <br><br>  But from the point of view of game developers, all this complexity falls on them as a dead load, because STUN, ICE and TURN are absolutely not needed to exchange data with dedicated servers that have public IP addresses. <br><blockquote>  <b>‚ÄúI felt that we needed a UDP version of WebSockets.</b>  <b>This is the only thing we dreamed of. ‚Äù</b> <br>  Matheus Valadares, creator of agar.io </blockquote>  In short, game developers love simplicity, and a solution like WebSockets for UDP attracts them much more than the complexity of WebRTC. <br><br><h2>  Why not just allow sending UDP? </h2><br>  The final solution to the problem is simply to allow users to send and receive UDP packets directly through the browser.  Of course, this is <em>an absolutely terrible idea</em> and there are good reasons why this should never be allowed. <br><br><ol><li>  Websites could launch DDoS attacks by coordinating the mass distribution of UDP packets from browsers. </li><li>  There would be new security holes, because JavaScript running on web pages could create malicious UDP packets to ‚Äúprobe‚Äù the internal system of corporate networks and transmit reports via HTTPS. </li><li>  UDP packets are not encrypted, so it is very easy for an attacker to organize sniffing and reading all the data transmitted in these packets, or even to change them during transmission.  Ensuring that browsers can transmit unencrypted packets would be a huge step backwards in network security. </li><li>  There is no authentication in UDP, so a dedicated server that reads packets sent by the browser would have to apply its own validity method to the users connecting to it.  Such labor costs are much higher than the efforts that game developers are willing to invest in solving this problem. </li></ol><br>  So, it is absolutely clear that JavaScript should not in any way create UDP packets in a browser. <br><br><h2>  What could be the solution? </h2><br>  But what if you come from the other end?  Instead of trying to build bridges from the world of the web to games, we can start with the right games for the technician and refine them to a solution that works well on the web. <br><br>  My name is <a href="https://www.linkedin.com/in/glennfiedler">Glenn Fiedler</a> , I have been developing games for the past 15 years.  For most of this time, I specialized in network programming.  I got a lot of experience working on dynamic action games.  The last game I worked on was <a href="https://www.titanfall.com/">Titanfall 2</a> . <br><br>  About a month ago I read this article on Hacker News: <a href="https://news.ycombinator.com/item%3Fid%3D13264952">WebRTC: The Future of Web Games</a> . <br><br>  In it, the creator of <a href="https://agar.io/">agar.io,</a> Mateus Valadares, said that WebRTC is too complicated for him, and he continues to use WebSockets in his games. <br><br>  I wondered: surely there must be a simpler solution than WebRTC? <br><br>  I wondered what that solution would look like? <br><br>  In my opinion, the solution should have the following properties: <br><br><ol><li>  <strong>It must establish a connection</strong> so that it cannot be used in DDoS attacks and to search for security holes. </li><li>  <strong>Encryption</strong> , because in 2017 no game or application should send unencrypted packets. </li><li>  <strong>Authentication</strong> , because dedicated servers should only accept connections from clients that are authorized in the backend. </li></ol><br>  I want to present my solution.  I do not amuse myself with the illusions that it will be fully accepted as a standard for browsers, I am not a web programmer, I write games.  But I hope that it, at least, will help browser creators and web developers see what client-server games really need.  I want the solution I proposed to at least partially help build bridges between the games and the web. <br><br>  Hopefully, as a result, in the near future we will get a much better performance of multiplayer browser games. <br><br><h2>  netcode.io </h2><br>  The solution I came to is <a href="http://netcode.io/">netcode.io</a> <br><br>  netcode.io is a simple network protocol that allows clients to securely connect to dedicated servers and exchange data over UDP.  It is connection-oriented, encrypts and signs packets, and provides authentication support so that only authorized clients can connect to dedicated servers. <br><br>  It is designed for games such as <a href="https://agar.io/">agar.io</a> , which need to spread players from the main website to instances of dedicated servers.  Each of the servers has a limit on the maximum number of players (in the basic implementation - up to 256 players per server instance). <br><br>  The basic idea is that the web backend performs authorization.  When a player wants to play, the backend makes a REST call to get <em>a connection token</em> , which is sent to the dedicated server as part of the UDP connection confirmation request. <br><br>  Connection tokens have a short lifetime and rely on a shared private key between the web backend and instances of dedicated servers.  The advantage of this approach is that only authorized users can connect to dedicated servers. <br><br>  netcode.io outperforms WebRTC in simplicity.  It uses the scheme only with dedicated servers, so ICE, STUN and TURN are not required.  By implementing encryption, signatures, and authentication with <a href="https://libsodium.org/">libsodium</a> , it avoids the complexity of a full DTLS implementation, while providing the same level of security. <br><br>  Over the past month, I created a <a href="http://netcode.io/">base implementation of</a> netcode.io in C. It is released under the BSD license of three points.  In a few months, I hope to improve this implementation, write a specification and work with other developers on porting netcode.io to various languages. <br><br><h2>  How it works </h2><br>  The client is authorized in the web backend using standard authentication techniques (for example, through OAuth).  After authorizing the client, he sends a request to start the game, making a REST call.  The REST call returns a connection- <em>token</em> encoded in base64 to the client over HTTPS. <br><br>  The connection token consists of two parts: <br><br><ol><li>  The private part is encrypted and signed with a shared private key using the AEAD primitive from libsodium.  It can not be considered, modified or forged in the client. </li><li>  Public part that provides the information necessary for the client to connect.  For example, encryption keys for UDP packets and a list of server addresses to which you can connect, as well as other information related to the AEAD ‚Äúlinked data‚Äù part. </li></ol><br>  The client reads the connection token and has a list of N IP addresses to which you can connect.  Since N can be equal to 1, it is best to pass the address of several servers to the client in case the first server is already full by the time the client tries to connect. <br><br>  When connecting to a dedicated server, the client periodically sends a <em>connection request packet</em> via UDP.  This package contains private connection token data, as well as additional data for AEAD, for example, netcode.io version information, protocol identifier (64-bit unique for each particular game), connection token expiration time stamp and AEAD primitive sequence number . <br><br>  When a dedicated server receives a connection request via UDP, it first checks the validity of the packet contents using the AEAD primitive.  If any public data in the connection request packet has been changed, the signature verification will generate an error.  This prevents clients from changing the timestamp of the connection token, and also allows them to quickly reject expired tokens. <br><br>  If the connection token is valid, it is decrypted.  Inside it contains a list of addresses of dedicated servers for which it is valid.  This prevents malicious clients from using a single token to connect to all available servers. <br><br>  The server also checks if the connection token has already been used by searching for a brief history of the <a href="https://ru.wikipedia.org/wiki/HMAC">HMAC</a> token.  If a match is found, the connection request is ignored.  Due to this, one token cannot be used to connect multiple clients. <br><br>  In addition, the server allows only one client to connect to a single IP address and port at any one time.  Also, at the same time only one client can be connected to the server using a unique <em>client id</em> .  The <em>client id</em> is a 64-bit integer that uniquely identifies the client authorized by the web backend. <br><br>  If the connection token has not expired, it is decrypted.  If the public IP address of the dedicated server is in the list of server addresses and all other checks have been completed successfully, then the dedicated server establishes the correspondence between the client's IP address and the encryption keys contained in the private data of the connection token. <br><br>  From this point on, all packets transmitted between the client and the server are encrypted with these keys.  If during a short period of time (for example, five seconds), UDP packets from the address do not arrive, then the bundle of address and encryption keys becomes invalid. <br><br>  The server then checks if the server has room for the client.  Each server supports a certain maximum of clients.  For example, in the game for 64 players there will be 64 places for connecting customers.  If the server is full, it responds <em>with a connection request rejection packet</em> .  This allows customers to quickly find out that the server is full and need to move to the next server in the list. <br><br>  If the server <em>has</em> room for a client, the server does not provide this place immediately.  Instead, it stores the address + HMAC of the client connection token as a <em>potential client</em> .  The server then responds <em>with a connection call packet</em> containing the <em>call token</em> .  A call token is a block of data encrypted with a random key.  The key is released when the server starts. <br><br>  Key randomization ensures that there are no security problems arising when encrypting tokens of multiple server calls by one ordinal number (servers are not coordinated with each other).  In addition, a connection call packet is significantly smaller than a connection request packet, which avoids the use of a protocol for ‚Äúgain‚Äù DDoS attacks. <br><br>  The client receives <em>a connection call packet</em> via UDP and switches to the state in which it sends <em>connection response packets to the</em> server.  Connection response packets simply send the <em>call token</em> back to a dedicated server, thus confirming that the client can actually receive packets to the original IP address from which, he informed, packets were sent.  This avoids spoofing source addresses of packets. <br><br>  When the server receives <em>a response packet to the connection</em> , it looks for the corresponding record of the waiting client, and if it exists, it again searches for a place for the client to connect.  If there are no empty seats, it responds <em>with a connection rejection package</em> , because the place that was free at the time of the first receipt of the connection request is already taken. <br><br>  Otherwise, the server assigns the client free space on the server and responds with a <em>connection support</em> package, which informs the client that it has allocated server space.  Such a place is called <em>a customer index</em> .  In multiplayer games, it is usually used to identify clients connected to the server.  For example, clients 0, 1, 2, 3 in a game with four players correspond to players 1, 2, 3 and 4. <br><br>  Now the server considers that the client is connected and that it can send <em>packets of the payload</em> .  These packages contain data related to the game.  Packages are delivered without order.  The only drawback of this method is that since the client, before getting the client index and making sure the connection is complete, he must first receive the <em>connection support</em> package, and the server keeps track of whether the client is <em>confirmed by</em> checking the location for each client. <br><br>  The confirmation flag for each client initially is false and becomes true when the server receives a connection support packet or a payload packet from the client.  As long as the client is not confirmed, each time the payload packet is sent to this client, the connection support packet is also pre-sent.  This ensures the statistical probability that the client knows its index and will be fully connected before receiving the first packet of the payload, which minimizes the number of connection setup cycles. <br><br>  After the client and server are fully connected, they can exchange UDP packets in both directions.  Usually, game protocols send information entered by a player from a client to a server at high speed, for example, 60 times per second, and the state of the world from server to client is slightly less frequent, for example, 20 times per second.  However, in the most advanced AAA games, the server data refresh rate is increased. <br><br>  If the server or client does not transmit a stable packet flow, connection support packets are automatically generated so that the connection is not interrupted by a timeout.  If during a short period of time, for example, five seconds, not a single packet is received from both sides, the connection is terminated by a timeout. <br><br>  If either party explicitly wants to terminate the connection, then an excess amount of <em>connection completion packets is</em> sent to ensure a high statistical likelihood of receiving packets even if they are partially lost.  This allows you to quickly complete the connection so that the other party does not expect a timeout. <br><br><h2>  Conclusion </h2><br>  Popular web games like <a href="https://agar.io/">agar.io</a> transfer data via WebSockets over TCP, since it is difficult to use WebRTC in the context of a client-server structure with dedicated servers. <br><br>  One solution for Google is to make the integration of WebRTC data feed support for dedicated servers <em>much</em> easier for game developers. <br><br>  Or you can use <a href="http://netcode.io/">netcode.io</a> , which uses a much simpler solution like ‚ÄúWebSockets for UDP‚Äù.  If you standardize it and embed it in browsers, this can also solve the problem. <br><br><hr><br>  <i><strong>Glenn Fiedler (Glenn Fiedler)</strong> - the founder and president of <a href="http://thenetworkprotocolcompany.com/">The Network Protocol Company</a> .</i>  <i>It provides services for setting up the network part of games.</i>  <i>Prior to founding the company, Glenn was the lead programmer for Respawn Entertainment, where he worked on Titanfall 1 and 2.</i> <br><br>  <i>Glenn is also the author of several popular article cycles on <a href="http://www.gafferongames.com/">gafferongames.com</a> about online data transfer and physics in games.</i>  <i>Fiedler has created open-source <a href="http://www.libyojimbo.com/">libyojimbo</a> and <a href="http://netcode.io/">netcode.io</a> network libraries.</i> </div><p>Source: <a href="https://habr.com/ru/post/322690/">https://habr.com/ru/post/322690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322676/index.html">Animated Easter eggs, or a tribute to the studio upon dismissal from it</a></li>
<li><a href="../322678/index.html">How IT professionals work. Andrei Volosyuk, CTO Digital Society Laboratory at SocialKey Ads</a></li>
<li><a href="../322680/index.html">New version of Panda Systems Management has been released.</a></li>
<li><a href="../322686/index.html">Practice Continuous Delivery with Docker (review and video)</a></li>
<li><a href="../322688/index.html">Automation on the methodology of BDD. Our experience of successful implementation</a></li>
<li><a href="../322692/index.html">How to understand who you are: Junior, Middle or Senior?</a></li>
<li><a href="../322694/index.html">How a two-year repository on GitHub has become a trend in 48 hours</a></li>
<li><a href="../322696/index.html">EMC DPO: How to protect your products from fakes</a></li>
<li><a href="../322700/index.html">The hunt for the mythical MVC. User Interface Building</a></li>
<li><a href="../322702/index.html">Mechanical Shakespeare: Are machines capable of literary creativity?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>