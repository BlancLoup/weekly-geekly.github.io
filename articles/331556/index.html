<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automated programming - a new milestone or myth? Part 1. Introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of automatic programming ( AP , AP ) for many years occupies a prominent place in the popular science media. However, despite this, the PA d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automated programming - a new milestone or myth? Part 1. Introduction</h1><div class="post__text post__text-html js-mediator-article">  <i>The topic of automatic programming ( <abbr title="automata programming">AP</abbr> , <abbr title="Automated programming">AP</abbr> ) for many years occupies a prominent place in the popular science media.</i>  <i>However, despite this, the PA did not become a major trend.</i>  <i>The main reason for this is insufficient experience in using, and as a result, the lack of popularizers.</i>  <i>It cannot be said that there are not enough articles devoted to the AP, but the range of issues discussed in the articles largely reduces to the description of the UML Statechart, i.e.</i>  <i>to the tool for describing automata, or to the question ‚ÄúHow are software automata implemented?‚Äù.</i>  <i>It's sad but true, there is no discussion of what prospects for professional programmers open when using this technology.</i> <i><br><br></i>  <i>This article is an attempt to look at <abbr title="software machines">programmers</abbr> through the eyes of a pragmatist, using the example of a task taken from the actual practice of programming microcontrollers.</i>  <i>However, it may be of interest not only to embedders, since the automata approach can be effectively used to create both drivers and interactive applications in event-based systems, such as Windows.</i> <br><a name="habracut"></a><br><p><a name="Content"></a><br>  <u>Table of contents.</u> <br>  <a href="https://habrahabr.ru/post/331556/">1. Introduction</a> <br>  <a href="https://habrahabr.ru/post/332508/">2. State and transition diagram.</a> <br>  <a href="https://habrahabr.ru/post/332664/">3. State and transition diagram.</a>  <a href="https://habrahabr.ru/post/332664/">Continuation</a> <br>  <a href="https://habrahabr.ru/post/341888/">4. Efficiency of auto-designed programs</a> <br>  <a href="https://habrahabr.ru/post/342048/">Automated workshop - 1. Example ‚ÄúDisplay‚Äù, development of OA and UA</a> <br>  <a href="https://habrahabr.ru/post/343736/">Avtomatny workshop - 2. Example "Crossing", the mathematical transformations of TK in OA</a> </p><br><br><p>  Probably, there are not so many programmers who have not heard of digital machines, but in order not to cut off the audience, I will briefly describe the essence.  An automatic machine is a digital device built on the principle: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/9b3/27b/e36/9b327be36a5642fb8d6663614e4ad99d.PNG"></div><br><br>  Figure 1. The general structure of digital machines <br><br>  Where: <br><br><ul><li>  combinational circuit (CS) - a digital logic circuit that does not contain inside the memory elements.  Those.  her condition is determined only by what she has at the entrance. <br></li><li>  The inputs of the CS are conventionally divided into two groups: I (n) ‚Äîexternal signals (inputs of the automaton), S (n) ‚Äîthe <b>internal state of the automaton</b> at the current step.  The internal state is, figuratively speaking, a kind of ‚Äúmode‚Äù, which determines how the automaton will convert external signals I (n) into signals O (n).  In the classical combinational circuit (there is no group of inputs S (n)), this ‚Äúmode‚Äù is only one. <br></li><li>  The outputs of the CS are also divided into two groups O (n) - signals that go outside, which actually perform the ‚Äúuseful work‚Äù, S (n + 1) internal state for the next step.  That is, <i>at each step, the</i> automaton, depending on the input signal I (n), not only calculates the desired output signal O (n), but also turns on the signal processing mode for the next step (i.e., signals I (n + 1)) and, if necessary, this mode can be the same or different.  In other words, you can set the required modes for <i>any possible cases of sequences of input signals</i> , which makes the automata so ‚Äúall-powerful‚Äù. <br></li><li>  For the purpose of synchronization, a memory device (memory, parallel register) is inserted which separates the word relating to the previous step from the word related to the next in the feedback circuit.  The symbols n and n + 1 denote the current step, and the next step, i.e.  n does not correspond to the time axis, but a sequence of steps.  The steps are set by the clock signal, and the clock signal is linked to the time axis through the clock signal.  The steps may not be associated with a periodic clock signal, but with the event ‚Äúarrival of signal I‚Äù. <br></li><li>  A similar storage device for the same purpose is inserted into the channel of the input signals I <br></li></ul><br><p>  If you were not familiar with automata, for all the clarity of the explanation, the benefits of such devices are not obvious, but there is a mathematical abstraction that illustrates the essence well.  The operation of the machine can be visually described using <b>the state diagram and transitions</b> .  Below is a diagram describing the operation of the device that controls the elevator.  This is a very simplified diagram that does not take into account the processes of opening / closing doors, accelerating / stopping, but it gives a visual representation of how the work of real-world objects is modeled using automata.  Above the arrows is written the condition under which the transition will occur, in the oval is written <br>  <i>state_name / what_will_to_out_exit_ bye_automatic_in_this_state.</i> <i><br></i> <br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/512/a8c/8e3/512a8c8e3fb4440c8b0a8057cd351b0d.png"></div><br><br>  Figure 2. An example of a state and transition diagram <br><br>  To the above, I add that the diagram shows Moore‚Äôs machine gun.  The state of the outputs of such an automaton depends <i>on the current state</i> .  The alternative is the Mile machine gun.  Its output signal depends <i>on the last perfect transition</i> , so what_ will be_to_exit is recorded above the corresponding arrow.  Despite this distinction, Mile and Mura automatons are mathematically transformed into each other.  Moore‚Äôs machines are more suitable for our cognitive purposes, but in the practice of programming both abstractions are useful, so in the next part we will not ignore the Miles‚Äôs machines. <br><br><p>  All more or less complex digital circuits are designed exactly as digital machines.  Why?  The indispensability of the automaton approach in the design of digital circuits is facilitated by three main advantages of the automaton approach: <br><br></p><ul><li>  Decomposition. <br></li><li>  A look at the processes not as a <i>sequence of steps</i> , but as a <i>collection of all possible steps</i> . <br></li><li>  Maths. <br></li></ul><br>  Automata are a mathematical entity, their theory is widely and deeply developed, which allows using exact mathematical methods to optimize and analyze the automata obtained.  From this point of view, the development of programs in a non-automatic way can be considered as the ‚Äúwork of the humanities‚Äù.  Mathematical methods are discussed in the second part.  Consider the advantages described, starting with decomposition. <br><br><h3>  Part 1. Constructive decomposition. </h3><br><p>  In the mathematical theory of automata, decomposition is the creation from an automaton, working according to a complex state and transition diagram, of several simple and clear automata that have a parallel and / or sequential connection and add up to the original automaton.  This is a mathematical and, therefore, an exact procedure. <br><br>  We consider practical machine building, therefore, in the first part, by decomposition we mean not a mathematical decomposition, but a splitting of an automaton in accordance with common sense.  In the second part, examples of mathematical decomposition will be given. <br><br></p><p> Machines are usually divided into <b>operating</b> and <b>control</b> .  The meaning is obvious from the name - the operating machine is the "hands", the manager is the "head".  Moreover, the partitioning can be multi-level: the operating automaton, in turn, can be divided into executive and management parts.  Those.  a manipulator arm can have its own ‚Äúminimal brain‚Äù, translating common commands (‚Äútake an object‚Äù) into a set of detailed commands that control each ‚Äúfinger‚Äù.  An even more illustrative example is a processor with pipelines, registers, ALUs and FPU ‚Äî operating machines, and a microprogram ‚Äî a control machine. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/9be/130/d26/9be130d26dbc447ca2899763d6586395.png"></div><br>  Figure 3. Decomposition of an automaton into an operating and managing director <br><br><p>  The principle of splitting a large task into small subtasks is actually already widely used in programming practice; it is the division of a task into subprograms.  However, automaton interpretation of programs, i.e.  the representation of any software object in the form of an automaton, which has an operating part and a control part, allows you to get away from the mechanistic and naive (in a good sense) fragmentation of the source code and gives a set of practical considerations how to do it, which significantly improves the quality of the program <i>at the stage design</i> .  Consider an example that will allow to talk about programmata more substantive.  This example will be cross-cutting over several articles. <br><br><a name="Conditions"></a><br></p><h3>  Formulation of the problem </h3><br>  _____________________________________________________________________ <br><br><p>  Suppose we have a b / w graphic display.  Its video memory has a standard byte organization, in which each bit represents a certain point.  Suppose we need to output text in different, non-monospaced fonts. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/web/c33/4be/b56/c334beb5618546e096e5f59c1b35db15.PNG"></div><br>  a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1f9/4d0/2f9/1f94d02f9f064cdebe4d662289d71d09.png"></div><br>  b) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/887/58b/029/88758b0295974107b20932f7cffd08dd.png"></div><br>  at) <br><br>  Figure 4. Display module requirements <br><br><p>  All characters in the same font height, but the font can be changed on the fly, in the process of outputting the same line.  Similarly, attributes can be changed - bold, italic, underline.  To control the parameters, <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D1%258F%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_ANSI">esc-sequences are used</a> , which include the control character '\ n', a line break, i.e.  the text of one line can be displayed on several lines on the display.  For example, the text: <br><br></p><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"Text 1 \033[7m Text 2 \033[27m \033[1m Text 3 \033[21m \n Text 42"</span></span></code> </pre> <br>  will be displayed as shown in the illustration (Fig. 4, b) <br><br><p>  The text is displayed in the area bounded by a rectangle (Fig. 4, c) and may have an offset.  The coordinates of the output area are not specified in familiarity, but in pixels, the coordinates can be negative, which means going beyond the output area.  Text outside the output area is clipped. <br><br></p><p>  We need to create a function that implements all this, with a prototype <br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Out_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x_shift, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y_shift, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * Text)</span></span></span></span>;</code> </pre> <br>  This is an important, basic function for all text operations: the work of the printf function, the implementation of virtual windows, crawlers, and so on. <br>  _____________________________________________________________________ <br><br><p>  The compilation of an automaton (that is, a <i>model of</i> the process being implemented) is carried out from the general to the particular, from top to bottom, but the detailed elaboration of the model and its software implementation, on the contrary, occur from the bottom up.  This is dictated by the fact that usually the lowest level is directly tied to the actuators, which puts us in a certain framework and limits the possibility of "maneuver", while the higher levels are more flexible in this regard, and the framework for them follows from the implementation of the underlying automatons. <br><br></p><p>  The process of creating the software implementation is iterative, first the lowest level of the model (developed <i>from top to bottom</i> ) is implemented, then the next level is developed, the underlying level is being corrected in parallel, after which the development proceeds to a higher level, with the underlying being adjusted as necessary.  Competent design requires minimal <i>processing of the</i> underlying levels, limited to their <i>addition</i> .  The final realization of automata in the form of program code is carried out after the compilation of all automata, but nevertheless, the sketches of algorithms are performed in parallel with the design of automata.  All the underlying calculations were performed by me, not after drawing up the program, as an illustration, but before creating the program code, as an important design stage.  So, let's start developing. <br><br></p><p>  As follows from the condition of the problem, the initial sequence of characters in the general case looks like: <b>Text1</b> <i>control1</i> <b>Text2</b> <i>control2</i> <b>Text3</b> <i>control3</i> <b>Text4</b> <i>control4</i> <b>Text5</b> <i>\ 0</i> <br>  where <i>upN</i> control esc-sequences, characters of translation and end of line that separate text blocks from each other.  The breakdown of text into blocks is convenient in that it allows you to use the maximum number of identical settings within one block (for example, text height and the coordinates of the beginning of a line). <br><br></p><p>  The development of a pair of OA-UA always begins with the development of OA.  OA is built on the basis of our attempts to model all aspects of the process that our machine gun will control.  In the case of the display, we have a couple of distinct aspects: splitting the text into blocks separated by control sequences and assembling graphic data in a buffer that will be reset to video memory.  Consequently, the automaton will consist of two sub-devices shown in fig.  five. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/f51/72d/2e2/f5172d2e27cf448fa46b015f3fd21dbf.PNG"></div><br>  Figure 5. Initial partition <br><br>  The need for an intermediate buffer assembly text block due to the fact that often work with the display is carried out over a communication channel with limited compared to the RAM bandwidth, according to the protocol type: <br><br><ul><li>  first send the Write_byte command (byte coordinates on the display) </li><li>  after which it is possible to get confirmation </li><li>  and only after that you can transfer bytes. </li></ul><br>  In this case, the displays can receive a continuous stream of bytes, sequentially, line by line filling the video memory.  This feature pushes us to collect a string in the buffer, throwing it in a stream of bytes in the video memory. <br><br>  Each text block is characterized by <i>x</i> , <i>y</i> text block coordinates (relative to the output window), <i>x_shift</i> , <i>y_shift offset</i> relative to text block x, y coordinates, fonts and attributes, such as inverse or blinking, bold, italic, underline, and so on. <br><br>  <u>Automatic breakdown of text into blocks</u> <br><br><p>  The operating part of <i>the blocking machine</i> consists of an input stream of bytes, which is divided into blocks.  To avoid unnecessary copying, text blocks are parts of the source line that are passed to the <i>Text Block Output Machine</i> in the form of two Text_begin and Text_end pointers. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/f25/8d4/507/f258d4507bd2425cbebb24f40152ada5.png"></div><br><br>  Figure 6. Explanation of the blocking machine OA <br><br><p>  <i>The breakdown machine</i> controls the settings of <i>the Text Block Output Machine</i> through direct access to the corresponding variables of the machine. <br><br></p><p>  The automatic breakdown of text into blocks is a very simple OA, it can be said that there is no automaton, just a couple of pointers plus a set of replaceable variables, but we consider the general principle, the principle that will be useful when developing the second automaton - <i>Automatic output of a text block</i> <br><br></p><p>  Once an OA has been developed, it is easy to make up the control automaton required for it. <br><br><a name="Image_7"></a></p><p></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/45b/7b8/5fd/45b7b85fd3a142a2934d43a821fc16e6.PNG"></div><br><br>  Figure 7. State diagram of the text breakdown machine <br><br><p>  In this case, the controlling automaton is well described both in terms of the algorithmic graph-scheme and in terms of the state diagram, but since this is an automaton, we use the state diagram.  <i>The state diagram</i> not only emphasizes the ‚Äúautomatism‚Äù of the task, it is useful in that it is an alternative, more convenient way of writing conventional software algorithms.  If you look at the essence of the question, a state diagram is a natural form of recording a software process in a broad sense, while an algorithmic graph-diagram is an artificial construction that already contains implementation features that are most often obvious and do not require their separate recorded.  Moreover, it is these very features of the implementation (when they are minor details) that sometimes disguise the main idea, pushing itself to the forefront along with the really important details.  In the next part, a fine example will be given showing the difference between the algorithm given by the graph scheme and the algorithm given by the state diagram.  The state diagram is elementarily converted into program code. <br><br>  <u>Text block output machine</u> <br><br>  As was shown above, control sequences can, among other things, set the output coordinates of the next text block.  The coordinates of the current text block are set by variables x, y. <br><br><a name="Image_8"></a></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/d9d/401/e4a/d9d401e4aa2649e0938736a549c60062.png"></div><br><br>  Figure 8. Coordinates used to display the text block <br><br>  Explanation of the figure. <br><br>  x_max, y_max - display size <br>  x0, y0, x1, y1 - coordinates of the output window, Out_text function parameters <br>  x_shift, y_shift - offset, can be positive and negative, affects the location of all text blocks. <br>  x, y - coordinates of the output of the current text block, can be changed by esc commands.  Coordinates are relative to the output window. <br><br>  As noted earlier, the text is initially output to the line buffer, after which the contents of the line buffer are copied to the video memory. <br><br><p>  The example uses a 5x7 font, but the described module supports work with characters of any size.  As a result, a large string build buffer may be required, which is often an important factor for embedders.  To minimize the buffer, instead of a set of parallel registers, one can be used that performs ‚Äúvertical scanning‚Äù, we are talking about vertical scanning of the entire text block, i.e.  displays a line one pixel high and wide across the entire text block. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/b9c/e05/3c3/b9ce053c37d9487485dc0c21d49ae4f6.png"></div><br>  Figure 9. Vertical scan when displaying text block <br><br><p>  When correctly implemented, the speed of this variant of the algorithm is almost as good as the case with parallel registers, although it still requires overhead: 3 bytes per character, but it allows you to completely refuse the line buffer, which for the 256 pixels wide display and 24 pixels high gives savings <br><br></p><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>&amp;#x2217;</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><msub><mi>h</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>s</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>8</mn></mrow><mo>=</mo><mn>768</mn><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="43.08ex" height="2.66ex" viewBox="0 -832 18548.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-48" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-65" x="888" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-69" x="1355" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-67" x="1700" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-68" x="2181" y="0"></use><g transform="translate(2757,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-74" x="0" y="0"></use><g transform="translate(361,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-68" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-61" x="1010" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-72" x="1539" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-61" x="1991" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-63" x="2520" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-74" x="2954" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-65" x="3315" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-72" x="3782" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-73" x="4233" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-2217" x="6766" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-57" x="7489" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-69" x="8537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-64" x="8883" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-74" x="9406" y="0"></use><g transform="translate(9768,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-68" x="0" y="0"></use><g transform="translate(576,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-73" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-63" x="469" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-72" x="903" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-65" x="1354" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-65" x="1821" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-6E" x="2287" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-2F" x="12487" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-38" x="12987" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-3D" x="13765" y="0"></use><g transform="translate(14822,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-37"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-36" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMAIN-38" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-62" x="16323" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-79" x="16753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-74" x="17250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-65" x="17612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/331556/&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhaa-33ypFzPtNHCA2OlCoxqIsbtw#MJMATHI-73" x="18078" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>‚àó</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><msub><mi>h</mi><mrow class="MJX-TeXAtom-ORD"><mi>s</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>n</mi></mrow></msub><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>8</mn></mrow><mo>=</mo><mn>768</mn><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> {Height_ {characters} * Width_ {screen} / 8} = 768 bytes </script></p><br>  From these relationships, one can estimate in which case the savings will be significant.  In this article we will consider the option with a full line buffer, as more simple, leaving the consideration of the "practical" option outside the scope of this article. <br><br><p>  Since the development of a pair of OA-UA always starts with the development of OA, and the development of OA starts from the lowest level, we will compose OA for an automatic text output. <br><br></p><p>  Operational automatic output of characters on the screen consists of a buffer in which a text string is collected.  Since the width of the character does not equal the width of the byte, each new character will have some shift.  For the implementation of the shift is used shift register.  If the string buffer is a set of parallel registers corresponding to individual rows, then one shift register is required.  As can be seen from the illustration, we have two end-to-end counters Current_byte and Current_shift, which, increasing from symbol to symbol, determine the amount of shift and the place where to put the shifted symbol. <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/c5d/800/b97/c5d800b97e8a450999b09c0b42cde1bb.png"></div><br><br>  Figure 10 a.  Explanation of the operation of the operating unit of drawing text block. <br><br>  The text collected in the string buffer is dropped into the video memory. <br>  The control machine for the described operation machine will be <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/fe5/a3c/f34/fe5a3cf348424acc8f2bf50328d198a0.png"></div><br><br>  Figure 10 b.  A control automaton for an operating automat of drawing a text block. <br><br><div class="spoiler">  <b class="spoiler_title">This control automaton can be implemented as a function.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//         int Current_shift, Current_byte; //        u1x * Text; u1x * Text_end; tFont * Current_font; //     Width  -     u1x * Symbol_array; int Width; //        int Line_width; //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// inline void Out_text_block () { Clear_line_buffer(); //     while(Text &lt; Text_end) { Width = Current_font-&gt;Width_for(*Text); Symbol_array = Current_font-&gt;Image_for(*Text); Line_width -= Width; //      ,    if(Line_width &lt;= 0) break; //       10 Out_symbol(); // Current_byte, Current_shift     . Current_shift += Width; Current_byte += (Current_shift &gt;&gt; 3); Current_shift = Current_shift &amp; 0x7; Text ++; }// while(Text &lt; Text_end) Finalize: Out_line_buffer_in_videomemory(); return; }// inline void Out_text_block ()</span></span></code> </pre> <br></div></div><br><br>  <i>Note.</i>  <i>During the actual design, this version of the function was not worked out and is presented here solely for reasons of clarity.</i> <br><br>  Our model describes the inference process in general, but does not take into account some of the features that can be illustrated in Figure 11. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/b7e/4f3/77e/b7e4f377e1d242b189161d93214d1957.png"></div><br><br>  Figure 11. Explanation of features of output to the line buffer and video buffer. <br><br>  This drawing shows that both the line buffer and the video memory have byte organization, and the output window may not coincide with the byte boundary in the video memory.  That is, output to the line buffer should be made with some initial indentation so that you can perform byte-by-byte copying. <br>  In addition, the text can be shifted to the left outside the window border and in this case a part of the text is not displayed, and the border of the displayed part of the text can pass so that a part of the symbol is displayed and a part is not. <br>  In other words, when developing an operational output slot machine, it should be noted that: <br><br>  a) there are overlapping bytes ‚Äî the bytes that contain both old data from the video memory and new data from the line buffer, so the overlapping bytes of video memory and the lines from the buffer are masked by complementary masks, after which the overlapping bytes are overlaid by <i>or</i> .  Data of non-intersecting bytes is copied to the video memory entirely. <br>  b) text output to the line buffer always starts with the zero byte of the line buffer, but not always from the zero position, more often it starts with some indent Current_shift <sub>initial</sub> . <br>  c) the text, in addition to the initial shift associated with the value of the x coordinate, can be shifted beyond the left border and a part of the text beyond it is not displayed. <br>  d) the text may protrude on the right, which requires additional masking, and, with appropriate dimensions, the same symbol may protrude on the right and on the left. <br><br><p>  When composing an operational automaton, it is imperative to take into account all the described points, so we turn to the following abstraction.  This (compilation of abstraction) is also part of the automaton approach ‚Äî one should not neglect the clear visual representation of the problem, although this does not follow directly from the automaton theory.  This abstraction was born after I portrayed different versions of the layout of the text. <br>  All characters of the string are divided into categories: <br><br></p><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/be0/a0a/29e/be0a0a29ec754b94b8d967d3d2f5147b.png"></div><br>  Figure 12. Categories of characters displayed on the screen, depending on the location relative to the output window. <br><br>  Each category implies its own processing mode: <br><br><ul><li>  Characters that do not fall into the output window (1) are simply ignored. <br></li><li>  The first character, partially or completely trapped in the output window (2), may require an additional shift to the left compared to the type 3 in order to cut off the pixels protruding beyond the output area.  The dropped bytes and bits are simply lost. </li></ul><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/d6b/c25/d93/d6bc25d93eeb4da0ac094110242352c2.png"></div><br>  Figure 13. Explanation of the initial shear mechanism.  The numbers indicate the ordinal number of pixels in the character image. <br><br><ul><li>  Characters that fall completely into the output area (3), as well as characters of type (2), require shifting to the right, the value of which depends on the coordinate of the character. </li></ul><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/cdf/81c/a05/cdf81ca05a844efb8dde13e19371f434.PNG"></div><br>  Figure 14. Explanation of the sliding shear mechanism <br><br>  For the first character, the left and right shifts are performed, so it is possible to save - to actually shift the difference of the corresponding values ‚Äã‚Äãwith additional masking of the dropped pixels.  The mask is obtained in a tabular way, so it practically does not require additional calculations, but this approach allows you to save up to 7 shifts per byte of the first character, which, with a character size of 16 * 24, saves up to 336 shifts. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/646/f69/d4b/646f69d4bfda4486acfab6877284f9df.png"></div><br>  Figure 15. Avoiding double shift <br><br>  From the shift register, the data is dropped into the string buffer, which is reset before the output of the text block.  Data is overlaid by <i>or</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/70b/d82/320/70bd8232051b484e8210c577c9310449.png"></div><br>  Figure 16. Filling the line buffer. <br><br>  Bits of the line buffer that protrude beyond the output area on the right (may belong to both category 2 and category 3, are marked with an apostrophe) require additional clipping of the part of the character that does not fit on the screen on the right. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/7c0/6d8/216/7c06d8216b6b42019128258e989fa6e1.png"></div><br>  Figure 17. Handling characters 2 'and 3'. <br><br>  Finalization involves copying information from the line buffer to the video memory, and if the extreme bytes intersect (see above), their information is read from the video memory and is masked by the corresponding <i>mask for the video memory</i> after which the trimmed byte is superimposed on the line buffer contents by <i>or</i> after which all the line buffer bytes is simply copied to video memory. <br><br><p>  As was shown above, the polishing of the software implementation occurs at the last stage, however, for clarity, I will give the source code in its final form, despite the fact that the idea of ‚Äã‚Äãeliminating double shift appeared already in the process of optimization, after the entire module was debugged, and for this we only had to slightly change the function Out_symbol.  The same applies to the use of the Start_line and End_line variables, which will appear only when developing the outgoing Out_text function, but adding them only slightly affected the appearance of the Out_symbol function. <br><br>  The full version of the source is located by <a href="https://bitbucket.org/dashingresearches/psm_demo_1/src">reference</a> in the Display.h / Display.cpp file.  There is also a compiled example (Project1.exe).  The project itself under Builder 6 <br><br></p><div class="spoiler">  <b class="spoiler_title">The implementation of the operating machine</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tShift_register</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol_buffer</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; tShift_register &gt; Line_buffer; <span class="hljs-comment"><span class="hljs-comment">//         int Start_line, End_line; int Left_shift, Current_shift, Current_byte; //     Width  -     u1x * Symbol_array; int Width; int bytes_Width; //    bytes_Width,      int bytes_Width_after_shift; inline void Out_symbol () { for(int Current_line = Start_line; Current_line &lt;= End_line; Current_line++) { Symbol_buffer.Clear(); //////////////////////// //   2  3    Out_symbol,      if(Left_shift)//  2 { //     8          int Start_symbol_byte = Left_shift &gt;&gt; 3; // void tShift_register::Load(int Start_index_in_destination, u1x * Source, int Width); Symbol_buffer.Load(0,Symbol_array + bytes_Width * Current_line + Start_symbol_byte,\ bytes_Width - Start_symbol_byte); // .15 // void tShift_register::Shift(int Start, int End, int Amount); Symbol_buffer.Shift (0, bytes_Width_after_shift, Current_shift - (Left_shift &amp; 7) ); Symbol_buffer[0] &amp;= Masks_array__left_for_line_buffer[ Current_shift ]; // .16 Line_buffer[Current_line].Or(Current_byte, &amp;Symbol_buffer[0], bytes_Width_after_shift ); } else //  3 { Symbol_buffer.Load(0,Symbol_array + bytes_Width * Current_line, bytes_Width); // .14 Symbol_buffer.Shift(0, bytes_Width_after_shift, Current_shift); // .16 Line_buffer[Current_line].Or(Current_byte, &amp;Symbol_buffer[0], bytes_Width_after_shift ); } }// for(int Current_line = Start_line, Current_line &lt;= End_line, Current_line++) }// inline void Out_symbol ()</span></span></code> </pre> <br></div></div><br>  We now turn to the control automaton.  The algorithm of his work is intuitively clear from the above description of OA.  As mentioned above, the state diagram is a natural and minimalistic form of writing algorithms, allowing you to show the essence without littering the drawing with minor details, so we write the algorithm for the UA as a state diagram. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/99f/74e/8d5/99f74e8d577c4124bf2bba47f9c3c5f0.png"></div><br>  Figure 18. State diagram is a good alternative to classic graph-schemes. <br><br>  According to the algorithm written by this state diagram, it is easy to compose a program code consisting of classical structural structures - cycles and branching.  This turns out to be simple in particular because this directed graph is, in general, not cyclic (that is, it does not contain transitions to previous states).  The exception is a pair of loops (state Type 1 and Type 3), which are easily developed in cycles.  However, even for those automata that are described by a more complex graph with cyclic paths of traversing nodes, it is also possible to write a structural program, although at first glance this task may seem difficult and cumbersome.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I ask you to emphasize: since the state diagram deals with blocks of states that are absolutely identical from the point of view of the program process, the links between which are clearly and unambiguously defined, this allows the </font><b><font style="vertical-align: inherit;">goto</font></b><font style="vertical-align: inherit;"> operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to go between states</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> without disturbing the structure of the language. That is, if the goto operator is used to make transitions between states of the automaton, </font><i><font style="vertical-align: inherit;">this in itself is a new structure, the same as cycles and branches</font></i><font style="vertical-align: inherit;"> . This structure is called the </font><b><font style="vertical-align: inherit;">transition between states</font></b><font style="vertical-align: inherit;"> , and it enriches the programming toolkit. At the same time, it should be understood that the </font><i><font style="vertical-align: inherit;">use of the goto operator outside of this program structure still remains non-structural.</font></i></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i.e. </font><font style="vertical-align: inherit;">breaking the standard structures of which the program code is built.</font></font> This is an important point.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It may take time for people to become accustomed and stop being afraid, but I want to believe that the new structural design will take a worthy place in the programmers' toolkit. </font></font><br><br><p></p><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The controlling automatic output of the text block is implemented by the following code:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tShift_register</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol_buffer</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; tShift_register &gt; Line_buffer; tVideomemory Videomemory; <span class="hljs-comment"><span class="hljs-comment">//        int Start_line, End_line; //         int Left_shift, Current_shift, Current_byte; //        u1x * Text; u1x * Text_end; tFont * Current_font; //      Out_text_block //     Width  -     u1x * Symbol_array; int Width; int bytes_Width; //    bytes_Width,      int bytes_Width_after_shift; //        //      int Line_width; //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////// inline void Out_text_block () { Clear_line_buffer(); //////////////////////////////////////// //        Type_1: //     while(Text &lt; Text_end) { Width = Current_font-&gt;Width_for(*Text); //         if(Left_shift &gt;= Width) { Left_shift -= Width; Text++; } else goto Type_2; }// while(Text &lt; Text_end) //   return; //////////////////////////////////////// Type_2: //  Current_byte = Current_shift &gt;&gt; 3; Current_shift = Current_shift &amp; 7; Symbol_array = Current_font-&gt;Image_for(*Text); bytes_Width = (Width + 7) &gt;&gt; 3; bytes_Width_after_shift = (Width + Current_shift + 7) &gt;&gt; 3; Line_width -= (Width - Left_shift); //  ? if(Line_width &lt;= 0) { Width -= Left_shift; goto Type_4; } Out_symbol(); //  Left_shift Width -= Left_shift; Left_shift = 0; //    Text++; //////////////////////////////////////// Type_3: //  ? while(Text &lt; Text_end) { // Current_byte, Current_shift     . Current_shift += Width; Current_byte += (Current_shift &gt;&gt; 3); Current_shift = Current_shift &amp; 0x7; //     Width = Current_font-&gt;Width_for(*Text); Symbol_array = Current_font-&gt;Image_for(*Text); bytes_Width = (Width + 7) &gt;&gt; 3; bytes_Width_after_shift = (Width + Current_shift + 7) &gt;&gt; 3; Line_width -= Width; //  ? if(Line_width &lt;= 0) goto Type_4; Out_symbol(); Text++; }// while(*Text &lt; Text_end) Current_shift += Width; Current_byte += (Current_shift &gt;&gt; 3); Current_shift = Current_shift &amp; 0x7; //   goto Finalize; //////////////////////////////////////// //   4     2'  3' Type_4: Out_symbol(); Current_shift += (Width + Line_width); Current_byte += (Current_shift &gt;&gt; 3); Current_shift = Current_shift &amp; 0x7; for(int Current_line = Start_line; Current_line &lt;= End_line; Current_line++) { Line_buffer[Current_line][Current_byte] &amp;= Masks_array__right_for_line_buffer[Current_shift]; } Finalize: Out_line_buffer_in_videomemory(); return; }// inline void Out_text_block ()</span></span></code> </pre> <br></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This algorithm is easy and organic, literally 1 in 1, implemented in assembly language. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Values ‚Äã‚Äãsuch as Start_line, End_line, the initial values ‚Äã‚Äãof Left_shift, Current_shift, Current_byte are set at the stage of initialization of the block output process. </font><font style="vertical-align: inherit;">This happens even in the blocking machine. </font><font style="vertical-align: inherit;">Consider how this happens. </font><font style="vertical-align: inherit;">Let me remind you that one line can be output not by a single block, but by several, therefore, when outputting each block, we deal with the parameters shown in </font></font><a href="https://habr.com/ru/post/331556/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The coordinates of each text block (x, y) can be set individually (esc sequences, however there is a difference ‚Äî the coordinates of the cursor are not specified in familiarity but in pixels). They are counted relative to the coordinates of the output window (x0, y0, x1, y1). The x_shift, y_shift offset affects the coordinates of each text block. All text blocks that fall entirely into the output window are not cut off even if a negative offset is specified. Only that which does not fall into the output window is clipped, i.e. negative bias itself is not a criterion for trimming text blocks. To implement the described behavior, the output of each text block is accompanied by the following transformations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculating the parameters horizontally is illustrated in Fig.</font></font> nineteen <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/1cc/7f4/153/1cc7f4153fa74a41b86ee00b2d641fe4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 19. Explanation of the calculation of parameters horizontally. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value of x_shift is not shown, it is compensated by adding to x. </font><font style="vertical-align: inherit;">The x_byte and Start_shift parameters are used during output to the video memory, which is carried out according to the scheme shown in Fig.</font></font> 20 <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/0c2/127/2a4/0c21272a412446bb85698773b5bebf9d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Figure 20. Output to video memory. </font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The output process is obvious, but the explanations are not redundant: </font></font><br><br></p><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the left byte intersects, then the corresponding byte of the video memory is read, masked and superimposed on the leftmost byte of the line buffer (which is already masked during the output to the line buffer). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the rightmost byte is intersecting, the corresponding byte of video memory is read, masked, and then superimposed on the rightmost byte of the line buffer (which is masked by the padding mask). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After that, the entire line buffer is copied to video memory, the line Start_line of the line buffer goes to line y of the buffer, and so on up to End_line and y + End_line - Start_line, respectively, as shown in Figure 20. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The parameters Start_line and End_line are determined based on the considerations shown in </font></font><br>  rice  21. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/web/49e/dd2/1ac/49edd21ac79345379033b71b8fbc83f5.png"></div><br>  Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21. Determination of the parameters of the vertical. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The transformation shown in Fig. 20, Fig. 21 corresponds to the algorithm.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   //     //////////////////////////////////////////////////////////////////////////////////// if(x1 &lt; x0) { int temp = x0; x0 = x1; x1 = temp; } if(y1 &lt; y0) { int temp = y0; y0 = y1; y1 = temp; } if(x0 &lt; 0) { x_shift += x0; x0 = 0; } if(y0 &lt; 0) { y_shift += y0; y0 = 0; } if(x1 &gt; x_max) { x1 = x_max; } if(y1 &gt; y_max) { y1 = y_max; } //    inline bool Init_text_block() { //   //////////////////////////////////////////////////////////////////////////////////// x += ( x0 + x_shift); y += ( y0 + y_shift); //   //////////////////////////////////////////////////////////////////////////////////// if (x &lt; x0) { Left_shift = x - x0; x = x0; } else { Left_shift = 0; } if(x &gt;= x1) return false; x_byte = x &gt;&gt; 3; Start_shift = Current_shift = x &amp; 7; Current_byte = 0; Line_width = x1-x; //   //////////////////////////////////////////////////////////////////////////////////// if (y &lt; y0) { Start_line = y0 - y; y = y0; } else Start_line = 0; if(Start_line &gt;= Current_font-&gt;Height()) return false; if( (Current_font-&gt;Height() - Start_line) &lt; ( y1 - y) ) End_line = Current_font-&gt;Height() - 1; else End_line = Start_line + (y1 - y) - 1; return true; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be added that only the content of the text block is actually displayed, and not the entire output window bounded by the coordinates x0, y0, x1, y1. </font><font style="vertical-align: inherit;">If necessary, you can pre-clear the entire window separately. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic breakdown of the source text into blocks. </font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The state and transition diagram has already been shown in </font></font><a href="https://habr.com/ru/post/331556/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 7.</font></font></a> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and it is easy to draw up the following algorithm.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////////////////// //   void Out_text_block (); inline void Control_processing (); void Out_text (int arg_x0, int arg_y0, int arg_x1, int arg_y1, int arg_x_shift, int arg_y_shift, unsigned char * argText) { //  // ... while(*Text_end) { ////////////////////////////////////// state__Inside_text_block: while(1) { switch(*Text_end) { //            case '\0': case '\n': goto state__Out_text_block; } Text_end++; } ////////////////////////////////////// state__Out_text_block: if( (Text_begin != Text_end) &amp;&amp; Init_text_block()) Out_text_block(); Text_begin = Text_end; ////////////////////////////////////// state__Control_processing: if(*Text_end == 0) return; //      Control_processing(); }//while(*Text_end) }//void Out_text (int arg_x0, int arg_y0,</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So in general terms the solution to the problem. </font></font><a href="https://bitbucket.org/dashingresearches/psm_demo_1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under the link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can see the source code and the working version of the program (Project1.exe file). The only question that remains is not solved - the structure of the function Control_processing, which parses esc-sequences and executes commands. It is based on another type of automata, which differs markedly from those considered above, but which are at the same time classic software automata - symbolic automata. We consider the implementation of such machines in one of the following parts.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is impossible to describe such a versatile topic as Automata programming in one article. </font><font style="vertical-align: inherit;">This article is an introductory, it is a sketch of the first cycle of articles, in which I want to acquaint the reader with the ‚Äúautomaton programming culture‚Äù. </font><font style="vertical-align: inherit;">The central element of the automaton approach is the automaton method of describing the processes occurring in time - with the help of a state diagram and transitions. </font><font style="vertical-align: inherit;">This is an alternative form of writing algorithms. </font><font style="vertical-align: inherit;">The next article will be devoted to a state diagram and transitions</font></font></div><p>Source: <a href="https://habr.com/ru/post/331556/">https://habr.com/ru/post/331556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331544/index.html">Mikrotik: Balancing in the CPSU and the observance of speed limits</a></li>
<li><a href="../331546/index.html">Installing ArchLinux ARM next to Android without chroot</a></li>
<li><a href="../331548/index.html">Connect: Modern Frontend Tips</a></li>
<li><a href="../331552/index.html">Autoencoders in Keras, Part 3: Variational autoencoders (VAE)</a></li>
<li><a href="../331554/index.html">New features of C # that can be expected soon</a></li>
<li><a href="../331558/index.html">Whether to limit users on resources?</a></li>
<li><a href="../331560/index.html">Selection of the distribution law of a random variable according to statistical sampling using Python tools</a></li>
<li><a href="../331562/index.html">Digital counterparts. Design through reflection</a></li>
<li><a href="../331564/index.html">nstd - C ++ library - "gentleman's set" of useful classes</a></li>
<li><a href="../331566/index.html">Optimize AWS Costs in SaaS Business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>