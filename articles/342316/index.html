<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Actors for fun and profit</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is an adapted version of the text of the report of the same name from the C ++ CoreHard Autumn 2017 conference . The article is considere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Actors for fun and profit</h1><div class="post__text post__text-html js-mediator-article"><p>  This article is an adapted version of the text of the report of the same name from <a href="https://corehard.by/2017/11/21/corehard-autumn-2017-actors/">the C ++ CoreHard Autumn 2017 conference</a> .  The article is considered as the completion of the topic raised earlier in the publications ‚Äú <a href="https://habrahabr.ru/post/322250/">Model of Actors and C ++: What, Why and How?</a> ‚Äù And ‚ÄúCones Stuffed in 15 Years of Using Actors in C ++‚Äù <a href="https://habrahabr.ru/post/324420/">Part I</a> and <a href="https://habrahabr.ru/post/324978/">Part II</a> .  Today we will talk about how to understand that the Actor Model can be successfully used in your project. </p><br><p>  In principle, the article is "captain", because  The things described in it are quite obvious and are dictated by common sense.  But, unfortunately, not often attention is focused on them. </p><br><h2>  Lyrical digression on the topic ‚ÄúModel of Actors and C ++: Myth or Reality?‚Äù </h2><br><p>  The article discusses the things that are inherent in the Actor Model itself, regardless of specific programming languages.  But, since  The author is closely related to software development in C ++, that is, some emphasis on the applicability of actors in C ++. </p><br><a name="habracut"></a><br><p>  There is a lot of information on the Internet about how to use the Erlang programming language or the Akka framework.  But there is little information about how the Model of Actors is used in C ++.  And it may seem that the Model of Actors and C ++ are not compatible in principle. </p><br><p>  This is not true.  The model of actors can be successfully used in C ++.  And, characteristically, it does apply.  Here is a small list of application areas for which I know examples of using the Actor Model in C ++: </p><br><ul><li>  industrial automation (ACS TP); </li><li>  telecom; </li><li>  electronic and mobile commerce; </li><li>  simulation modeling; </li><li>  CAD; </li><li>  game construction; </li><li>  Middleware (DBMS, ...) </li></ul><br><p>  There are even a few ready-made, live and developing frameworks for C ++, here are the most famous ones: </p><br><ul><li>  <a href="http://www.state-machine.com/qpcpp/">QP / C ++</a> (dual license); </li><li>  <a href="http://www.stdthread.co.uk/pro/">Just :: Thread Pro: Actors Edition</a> (commercial license); </li><li>  <a href="http://www.actor-framework.org/">C ++ Actor Framework</a> (BSD-3-Clause license); </li><li>  <a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a> (BSD-3-Clause license). </li></ul><br><p>  Besides: </p><br><ul><li>  <a href="http://www.oosmos.com/">OOSMOS</a> (dual license, C language, but can also be used in C ++); </li><li>  <a href="https://msdn.microsoft.com/en-us/library/dd492627.aspx">Asyncronous Agents Library</a> (included in Visual Studio); </li></ul><br><p>  In principle, there is plenty to choose from.  You can not even write your bike.  Although we, C ++ programmers, love this very much.  However, being an old developer of one of these frameworks, I can say two things: </p><br><ul><li>  Firstly, the Actor Model can be safely used in C ++.  It brings positive results.  Repeatedly tested in practice; </li><li>  secondly, doing your own implementation of the Model Actors for C ++ is a thankless task.  Labor and time will have to invest a lot.  And whether it will pay off in the medium or long term is unknown, most likely it will not pay off. </li></ul><br><p>  So if you want to use the Actor Model in C ++, then it makes sense to try something from the ready one first.  And only if nothing suits your task, then you can already think about your bike.  Or even at the expense of changing the programming language. </p><br><h2>  Is it worth it to talk about Model Actors? </h2><br><p>  The main part of the story should start with a million question: ‚ÄúDo we really need a model of actors?‚Äù </p><br><p>  Especially often this question arises on specialized resources.  There, anonymous experts who know and are able to do everything in the world claim that they are not needed.  Perhaps such mega-monsters do not need either the Actor Model or other approaches to competitive programming.  But I am interested in an adequate and balanced response to this survey. </p><br><p>  And in my opinion, the question ‚ÄúDo we need a model of actors?‚Äù Is very similar to the question ‚ÄúDo we need a dump truck on the Formula 1 track?‚Äù </p><br><p>  The bottom line is that both one and the second question are meaningless without one important clarification ... Namely: " <b><i>For what?</i></b> " </p><br><p>  If we ask the question ‚ÄúWhat is a dump truck on the Formula 1 track for?‚Äù, We immediately get quite meaningful space for normal answers.  For example: to repair the Formula 1 track.  Is a dump truck needed for this?  Probably yes.  And the question gained meaning, and there is a normal answer for it. </p><br><p>  Likewise with the need for the Model Actors.  As soon as we ask the question ‚ÄúWhat is the Model of Actors for in such and such conditions?‚Äù, We immediately get the opportunity to find a meaningful answer. </p><br><p>  And this answer will often be: in order to simplify your life! </p><br><h3>  But... </h3><br><p>  However, not all so simple.  Perhaps you read the book ‚ÄúYou are, of course, joking, Mr. Feiman!‚Äù There was a story about how in the Princeton laboratory the young Richard Feiman tried to put on a toy experience and he exploded a large bottle of water.  Photos with the results of previous important experiments were spoiled.  The head of the laboratory then told Feyman: ‚ÄúExperiments of beginners should be carried out in the laboratory for beginners!‚Äù </p><br><p>  And the same words can be addressed to all those who want to drag technology into a real project, with which no one has worked before. </p><br><p>  Basically, we love it.  There is even the term HDD - Hype Driven Development.  When we learned something new, were inspired, dragged into a combat project and for a long time and persistently struggled with the consequences. </p><br><p>  So, in order for the Model Actors not to cause unbearable pain in a large project, you need to first practice.  For example, on cats :) </p><br><h4>  Need to train on cats! </h4><br><p>  Try first Model Actors in some small, toy tasks.  Create actors, send messages between them.  See where you liked it, where you didn't like it.  Think about why not like it. </p><br><p>  Very often at the beginning of work with actors people abuse messages.  They try to represent any entity in the program as actors, and any interaction between them through asynchronous messages.  But this does not always work well.  It is necessary to experience firsthand that line when the advantages of asynchronous messages begin to turn into the disadvantages of asynchronous messages. </p><br><p>  If you haven‚Äôt felt this line yet, then having dragged the Model of Actors into a real big project you, most likely, will create superfluous actors who will exchange unnecessary messages.  This will be a headache for you and cause problems with your code. </p><br><p>  In general, everything is good in moderation, and this measure is better to find on toy puzzles, rather than in a combat project. </p><br><h2>  Model Actors as a way to look at the world </h2><br><p>  When we take on the Model of Actors, we must understand that the Model of Actors is not only a way of organizing interaction between entities within a program.  It is also an approach to analyzing the problem and the design method. </p><br><p>  Here it is appropriate to draw an analogy with the Object-Oriented Approach.  25 or 30 years ago, the object approach with its three simple principles was a real breakthrough.  Breakthrough, which allowed not only to simplify the writing of the code of large software systems.  But, most importantly, the object approach has become a tool that has significantly simplified the analysis and design of these largest software systems. </p><br><p>  The principles of the objective approach allowed to look at the subject area with different eyes.  People learned in a special way to classify the objects of their subject area.  And this made it possible to more easily implement objects within the program. </p><br><p>  Here is something similar giving people and using the Model Actors.  She herself is based on three simple principles: </p><br><ul><li>  an actor is an entity with behavior; </li><li>  actors respond to incoming messages; </li><li>  having received the message the actor can: <br><ul><li> send a certain number of messages to other actors; </li><li>  create a number of new actors; </li><li>  define for yourself a new behavior for processing subsequent messages. </li></ul></li></ul><br><p>  But these principles give the developer, first of all, a different way to look at their subject area.  Working with the Actor Model, we begin to see in the subject area not just some objects with some properties.  We begin to see objects with their own behavior.  As well as ways to communicate these objects with other similar objects. </p><br><p>  It turns out that we first learn to detect actors in the subject area itself.  And then we get the opportunity to safely transfer these actors to objects within our code. </p><br><p>  And it is precisely this that the Model of Actors is valuable: we have the opportunity to operate with the same concepts both in relation to the subject domain, and in relation to the program implementation. </p><br><h3>  but on the other hand </h3><br><p>  We can look at some subject area and not see actors there in general. </p><br><p>  A typical example: computational mathematics.  There is practically nothing to represent in the form of actors.  Of course, you can try, but it will not make sense.  For example, you can make an actor matrix and an actor vector.  And the vector will send to the matrix the message ‚Äúmultiply yourself by me‚Äù.  But it even sounds pretty stupid. </p><br><p>  Some kind of actor may arise when paralleling mathematical calculations.  There are entities that are responsible for paralleling and collecting results.  These entities may be similar to actors.  But far from being a fact that they are profitable to do actors.  It may be easier to use map-reduce or task based parallelism. </p><br><p>  So there are subject areas in which the use of the Actor Model does not only bring no bonuses, but it can also complicate our lives.  In such areas it makes no sense to use the Model Actors.  And if you have such an area, then you simply do not need a dump truck, that's all. </p><br><h2>  Litmus paper </h2><br><p>  Let's look at a few markers, the presence of which may prompt you that the Actor Model in your task will take root. </p><br><p>  Immediately make a reservation: these markers are necessary, but they do not guarantee anything.  However, the more markers in your subject area you find, the higher the likelihood that the Actor Model will simplify your work. </p><br><h3>  Fire-and-Forget Principle </h3><br><p>  The first marker is the ability to use the send-and-forget principle. </p><br><p>  What is this principle about? </p><br><p>  First, it‚Äôs about the fact that the progress of work in your task is not very much needed to be controlled.  Everything itself is done when the appropriate time and resources are found for this.  You simply do your part, give the results of your work somewhere further and you are no longer interested in what happens with these results. </p><br><p>  Secondly, this principle is that in most cases you do not need to know the result of the operation started here and now.  If you need something, then you send your application somewhere and you can continue your work without waiting for the result of processing your application. </p><br><p>  Thirdly, this principle is that if something is not done at all, then there is nothing terrible about it.  We can either ignore the lack of result, or we can repeat the operation after some time. </p><br><p>  In general, this is a simple and obvious principle that we regularly use in everyday life.  Including to solve complex and important tasks. </p><br><p>  For example, you want to hold a conference for C ++ developers.  You need to invite interesting speakers.  You make a list of those you would like to see and send them letters asking about the possibility of participation.  Letters are gone, you do not need to wait for immediate responses.  While people think, you can deal with other organizational issues.  If someone didn‚Äôt answer your question at all, you can ask him again.  Or simply consider that the person did not want to take part and will not rely on him. </p><br><p>  Those.  in real life, we often apply the send-and-forget principle.  But from the same real life, we know that it does not always work.  Actually, the same thing happens when writing programs.  Somewhere we can use "send-and-forget", but somewhere - no. </p><br><p>  For example, we may have two worker threads.  In the first we hang on select or epoll.  When data for reading appears, we read it, give the second working thread for parsing, and proceed to read data from another socket.  For the first working thread, it does not matter when the second working thread performs the parsing and whether this parsing will be successful or not. </p><br><p>  Another example.  We commit a transaction to the database.  Most likely, we would immediately like to know the result: whether the commit was successful or not.  And we can hardly continue to work until the result of the commit is unknown. </p><br><p>  In general, if you see that the principle of "send-and-forget" for your task is quite natural, then you can try on the Task Actors Model.  But if you see that you almost always need to immediately know the results of the operations you started, then the Actor Model is unlikely to suit you. </p><br><h3>  State machines </h3><br><p>  The next important marker is the presence in your subject domain of entities that can be represented as finite automata. </p><br><p>  In general, if you look at the principles of the Model Actors, you can see that the actors, in fact, are finite automata, albeit simple: </p><br><ul><li>  <b>an actor is an entity with behavior;</b> </li><li>  actors respond to incoming messages; </li><li>  <b>having received the message the actor can:</b> <br><ul><li>  send a certain number of messages to other actors; </li><li>  create a number of new actors; </li><li>  <b>define for yourself a new behavior for processing subsequent messages.</b> </li></ul></li></ul><br><p>  Indeed, each actor has a behavior that determines how the actor will handle the next message.  During the processing of the message, the actor can choose for itself a new behavior. </p><br><p>  This is the same as the state machine: the automaton has its current state, which determines how the input signal will be processed.  The new state of the automaton is determined by its current state and the type of incoming signal. </p><br><p>  Therefore, it is not surprising that tasks in which finite automata are widely used fit well into the Actor Model. </p><br><h4>  Not all state machines are equally useful. </h4><br><p>  Suppose that we have an entity that coordinates the process of user input into the system, for example, to an online cinema site.  This entity receives an input request with a username and password, and then requests an authentication subsystem.  If the authentication is successful, then a request is made to the billing subsystem to determine the user's balance.  After that, a request is made to the notification subsystem to receive a list of notifications for the user.  As a result, the initial page for the user is formed, which displays information about his current balance and the list of notifications awaiting reaction. </p><br><br><img src="https://habrastorage.org/webt/zn/ol/1n/znol1n3ok7hyjkhl1dqwwjdj7ps.png"><br><br><p>  It seems that everything is simple and clear.  But something confuses. </p><br><p>  And confuses the fact that here the finite state machine is not needed at all.  In fact, we have a simple linear sequence of actions with synchronous calls to external subsystems. </p><br><p>  To express such a sequence, it is much better to use ordinary threads of the operating system.  So that each call to a third-party subsystem is a simple synchronous call. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> login_params &amp; params)</span></span></span><span class="hljs-function"> -&gt; start_page_data </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> auth_result = request_auth_service(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(auth_result.valid_user()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> balance = request_balance(auth_result.user_token()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pending_messages = request_pending_messages(auth_result.user_token()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_start_page_data(auth_result, balance, pending_messages); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_unknown_user_page_data(); }</code> </pre> <br><p>  Of course, there are problems with scalability, because the creation of a separate thread for each user is too expensive.  But this problem is solved if we have the opportunity to use filers or coroutines.  Then all actions are made out in the form of a linear coroutine with blocking calls inside.  And we do not need any state machines. </p><br><p>  Accordingly, if the majority of activities in your program are represented as linear sequences from synchronous operations, then you hardly need the Actor Model.  And you need to look somewhere in the direction of CSP or task-based parallelism. </p><br><h4>  Really useful finite automata </h4><br><p>  And in what cases are finite automata useful? </p><br><h5>  Several types of input signals in each of the states </h5><br><p>  First, when we are waiting at each moment of time not just one type of input signal, but several. </p><br><p>  Imagine that we need to program an intercom panel.  The panel is activated when you first press a button with a number.  After that, we can wait for either pressing another button with a number, or pressing the ‚ÄúCall‚Äù button, or pressing the ‚ÄúReset‚Äù button to reset the entered number, but remain in the activated state, or a timer signal that it is time to deactivate the intercom panel. </p><br><img src="https://habrastorage.org/webt/b0/2f/jc/b02fjcu_qkq6ja-e9706llrjjze.png"><br><p>  That's when in each state we have to respond to several different types of signals, finite state machines can be simpler and easier to implement than any other approach. </p><br><h5>  Nonlinear transitions between states </h5><br><p>  Secondly, finite automata can be useful when the logic of behavior is nonlinear.  Those.  when we can go from state S1 to state S2, from there to S3, and from there, depending on the input signal, we can return to either S1 or S2, but we can also go to S4, from where we can return to S2. </p><br><br><img src="https://habrastorage.org/webt/xk/lw/ig/xklwigx26kz1ohpdb8gmq8agplu.png"><br><br><p>  In cases of such cyclic transitions between states, the finite state machine may also be more convenient to try to write a linear code. </p><br><h5>  Advanced state machines </h5><br><p>  Third, you may need advanced state machine capabilities: </p><br><ul><li>  reaction to the entrance / exit to / from the state; </li><li>  state hierarchy (nested states, event inheritance); </li><li>  history for states; </li><li>  restrictions on the time spent in the state. </li></ul><br><h4>  Everything you wanted to know about state machines, but ... </h4><br><p>  In general, there is a fundamental article on the formal notation for state diagrams from David Harel: <a href="http://www.inf.ed.ac.uk/teaching/courses/seoc/2005_2006/resources/statecharts.pdf">Statecharts: A Visual Formalism For Complex Systems (1987)</a> . </p><br><p>  They understand the various situations that can occur when working with finite automata on the example of control of a conventional electronic clock.  If someone did not read it, I highly recommend it.  In principle, everything that Harel described was then transferred to the UML notation.  But when you read the description of state diagrams from UML, I don‚Äôt always understand what, for what and when.  But in the article by Harel, the presentation goes from simple situations to more complex ones.  And you are better aware of all the power that finite automata hide in you. </p><br><h4>  Obvious summary on state machines </h4><br><p>  If your subject area is literally teeming with finite automata, then you have a direct route to the Actor Model. </p><br><h3>  Shared Nothing Architecture </h3><br><p>  The next marker is perhaps the most important: how simple is it in your subject area to follow the principle of Shared Nothing. </p><br><p>  Those.  Can your entities live and work without shared data at all? </p><br><p>  If you bring it to the limit, is it possible to present your every entity as an autonomous OS process that communicates with other similar processes only through asynchronous messages? </p><br><p>  Ideally, actors should not have any shared data.  Each actor is an autonomous independent entity.  With its own state, which no one else can see.  Therefore, such a limiting view that each actor is an independent and independent process with its own address space is very justified. </p><br><p>  It is, however, somewhat extreme.  And we can move away from it, for example, for reasons of efficiency.  Nevertheless, if in principle we can imagine a solution in which each actor is a separate process, then this is a good sign. </p><br><p>  Here it is necessary to emphasize two important points. </p><br><h4>  Shared Nothing is not always possible. </h4><br><p>  First, it is obvious that not always we can adhere to the principle of Shared Nothing. </p><br><p>  For example, we can keep in mind a large graph of social connections.  And in order to efficiently handle multiple requests to it, we may need multi-threaded processing of these requests.  Workflows will be forced to jointly own the graph and use some synchronization mechanisms in order not to violate its integrity. </p><br><p>  Another example: computational problems.  We can keep in mind several large matrices that are involved in the calculations.  To speed up the calculation, we can run several parallel threads and these threads will work together with common data. </p><br><h4>  It all depends on the height from which we look down ... </h4><br><p>  Secondly, the situation may change fundamentally depending on the level of abstraction at which you are considering your task. </p><br><p>  Let's go back to the example of online cinema.  If you look ‚Äúby the big top‚Äù, then we see quite a Shared Nothing architecture.  The authentication subsystem works with own data, the billing works with own data, the notification subsystem works with its own data.  They all have nothing to share.  They communicate with each other only through asynchronous messages.  That is, in fact, they are all actors. </p><br><p>  However, if we descend to the level of implementation of a specific component, then there can already be no autonomous actors in principle. </p><br><p>  For example, in the billing subsystem there can be a huge data structure in RAM and several workflows that work very cleverly with it (for example, using lock-free algorithms and persistent data structures). </p><br><p>  Those.  we may be confronted with the fact that at the conceptual level we seem to have the Model of Actors, but at the level of implementation, in the code, we have the usual multi-threaded imperative trash, hardcore and sodomy. </p><br><p>  And that's fine.  Recall once again that the Model Actor is not just a set of techniques for writing code.  It is also an approach to analyzing the subject area and designing a software system. </p><br><p>  Therefore, we can use the Actor Model at the design level, highlighting the components that are conceptually actors.  But at the level of implementation there will be nothing left of the Model Actors. </p><br><p>  In general, there may be a reverse situation: your application can be a huge monolith and do use shared data between streams, but in some part of this application you can easily use the Actor Model, effectively isolating part of the application from the rest of the code. </p><br><h4>  Total about Shared Nothing </h4><br><p>  If the use of Shared Nothing architecture is difficult and / or leads to additional overhead, then you can not look in the direction of the Model Actors. </p><br><p>  But in general, Shared Nothing is a great thing.  Very much simplifies life.  Especially in multi-threaded programming.  And the Actor Model facilitates the implementation of the Shared Nothing architecture.  So, if you are trying to build your application using the Shared Nothing architecture, then actors can help you a lot. </p><br><h3>  Timers </h3><br><p>  Separately worth staying at work with timers. </p><br><p>  It cannot be said that timers are a special marker that is inherent in the Actor Models.  But because of the send-and-forget principle, working with timers is very important.  It so happens that we run some kind of operation, and after a while we should check its result.  In this case, you can not do without convenient work with timers. </p><br><p>  In the case of actors, timers are implemented via pending messages.  Which is very convenient, because  When the timer is triggered, you receive a normal message. </p><br><p>  Let's look at a simple example: </p><br><p>  You receive a request from the user.  But you do not want to immediately process it, because the processing of single requests is not profitable.  You can wait a bit.  Suddenly a few more requests will come, then you can process them all in a crowd.  For example, it is beneficial for you to process requests in groups of 100 applications.  This, of course, worsens the latency for a separate request, but it improves the throughput of your service. </p><br><p>  It turns out that you need to wait for the fulfillment of two conditions: </p><br><ol><li>  Or you have accumulated 100 requests and processed them all at once. </li><li>  Or you waited, say, 250 milliseconds and process everything that you managed to do.  99 means 99. One means one. </li></ol><br><p>  It is implemented very simply: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bunch_processor</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request &amp; req)</span></span></span><span class="hljs-function"> </span></span>{ requests_.push_back(move(req)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> == requests_.size()) timeout_timer_ = send_delayed&lt;timeout&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>ms); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> == requests_.size()) { timeout_timer_.reset(); handle_collected_requests(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeout&amp;)</span></span></span><span class="hljs-function"> </span></span>{ handle_collected_requests(); } ... };</code> </pre> <br><p>  Summarizing the topic of timers, I can say that actors and timers are very good friends with each other.  Therefore, if your task has a lot of work with timers, then the Actor Model can help you with this. </p><br><h2>  Where does all this apply? </h2><br><p>  Well, in order to consolidate the material, let's try to briefly walk through the areas in which the Actor Model has proven itself well.  What I will say further is based on my own experience and on the experience of colleagues with whom I have occasioned to discuss the topic of the Model Actors. </p><br><h3>  Equipment management </h3><br><p>  The first area that comes to mind is the management of real equipment using a computer.  For example, in the tasks of industrial automation. </p><br><p>  The operation of external devices is often described using state machines.  It is therefore not surprising that state machines are also used to work with devices in the program itself. </p><br><p>  The interaction between actors through asynchronous messages also turns out to be very similar to working with real equipment.  Since communication with external devices is often exactly asynchronous.  Let's say we write a command to some kind of I / O port.  Then we have to wait for some time, then read the contents of some other I / O port to see if our command is executed or not.  By the way, convenient work with timers helps a lot in such cases. </p><br><h3>  Simulation </h3><br><p>  Another direction is the simulation modeling of any processes, for example, in queuing systems.  Especially processes that include many diverse entities (see, for example, <a href="https://en.wikipedia.org/wiki/Agent-based_model">Agent-Based Model</a> ). </p><br><p>  Since the actor is an autonomous entity with its own behavior, it is convenient to use them to simulate objects of the real world.  You can create completely different types of actors, you can create the same type of actors, which differ only in the values ‚Äã‚Äãof some parameters.  You can fill your model with at least a million actors, each of which will be at least somewhat different from the others.  And it allows you to conduct complex experiments in the field of simulation. </p><br><h3>  Development of test environments </h3><br><p>  When developing components of large software systems, it is necessary to create a test environment that simulates the behavior of adjacent components.  This can be done for various reasons: </p><br><ul><li>  adjacent components themselves may not yet be available.  They are being developed in parallel and may not yet be ready for joint integration testing.  Therefore, you need some kind of simulator that can replace an adjacent component here and now; </li><li>  You may need to simulate the abnormal behavior of an adjacent component.  For example, you need the adjacent component to delay the response to every 5th request strongly, not to respond to every 10th request at all, and to every 20th request to respond with some kind of garbage. </li></ul><br><p>  Own test environment may be required even when developing small systems, for example, when working with external equipment, when you do not have this equipment yet.  But you need some kind of external device simulator. </p><br><p>  Experience shows that in such cases, simulators based on the model of actors are implemented easily and naturally.  And this is not by chance, since here you can find a lot in common between work with equipment and simulation modeling, which was discussed earlier. </p><br><h3>  Pipeline data / transaction processing </h3><br><p>  Pipeline processing of data streams or transaction flows is not exactly the subject of the Actor Model.  This is an area of ‚Äã‚Äãdata flow programming.  However, in practice, the Model Actors can easily become the foundation on which pipeline processing is built.  Thus, the pipeline stages are easily implemented by actors, and the transfer of information from one stage to another is done through asynchronous messages (in such tasks, the send-and-forget principle feels good). </p><br><p>  A big plus of actors in such tasks is that actors have a state and this allows them to do interesting things.  For example, to accumulate single requests into packets so that further batch processing is performed.  We have already considered such an example above: the actor receives the first request, cocks the timer and waits for either the complete package to be generated or for the timer to work. </p><br><p>  Another good point is that actors can rebuild their connections in dynamics.  For example, there may be an actor performing load balancing on five subordinate worker-workers.  The balancer can track how long each worker processes the next packet.  And if it finds out that this time starts to grow, then the balancer can reduce the load on this problem worker. </p><br><p>  True, if actors are used in pipelining tasks, the problem of back pressure comes up.  But that's another story.  Especially since it is quite solvable.  And in the same Akka there is Akka Streams, which are built just above the usual Akka-actors. </p><br><h2>  Several platitudes in the end </h2><br><p>  I want to finish in the role of Captain Obvious, therefore, a few platitudes: </p><br><ol><li>  You need to be guided by common sense when choosing an approach to solve your problem. </li><li>  Common sense says that the Model Actor is not a silver bullet. </li><li>  In some cases, the Actor Model really makes life easier. </li><li>  But in order to make life easier, you need to have experience working with the Actor Model. </li><li>  This experience is better to get on toy prototypes. </li><li>  In order to get this experience, you can take any of the existing ready-made actor frameworks for C ++. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/342316/">https://habr.com/ru/post/342316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342306/index.html">How we played with neural networks</a></li>
<li><a href="../342308/index.html">Future of wikipedia</a></li>
<li><a href="../342310/index.html">Installing Proxmox VE on Debian Stretch using Ansible</a></li>
<li><a href="../342312/index.html">Configuring Jail on FreeBSD 11.1</a></li>
<li><a href="../342314/index.html">Playing with Nextgen-antivirus from Palo Alto Networks: it injects its dll into executable processes like * .exe</a></li>
<li><a href="../342318/index.html">PouchDB or what to do when the ‚Äúinternet is stable‚Äù</a></li>
<li><a href="../342324/index.html">Errors in smart contracts or Parity's new Security Alert</a></li>
<li><a href="../342326/index.html">PVS-Studio report is now in Html format</a></li>
<li><a href="../342330/index.html">Insight on metrics: how do I understand what metrics are and what is their main charm</a></li>
<li><a href="../342332/index.html">Storage of personal data on a foreign hosting: if it is possible, how?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>