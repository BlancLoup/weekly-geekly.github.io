<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monitoring System Delays with JHiccup</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About JHiccup 


 JHiccup is a simple program that allows you to measure the delays of the operating system in terms of the final application. It was ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monitoring System Delays with JHiccup</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/cb2/66a/cd7/cb266acd7222435a9726f83b494c1701.png"><br><h2>  About JHiccup </h2><br><p>  JHiccup is a simple program that allows you to measure the delays of the operating system in terms of the final application.  It was written by Azul CTO - Gil Shadow to measure OS delays. </p><br><a name="habracut"></a><br><h2>  Why delays are so important </h2><br><p>  We live in the days of network applications.  Most programs running on our computer regularly go to the Internet.  If we launch the browser and open google.com, then 50‚Äì60 requests will occur. </p><br><img src="https://habrastorage.org/web/541/c82/3e0/541c823e0a974dbba5e2156f546fe642.png"><br><p>  <i>56 requests to open google.com</i> </p><br><p>  If we are talking about more complex sites, then the number of requests will be in the hundreds.  And the delay of any of these requests may delay the rendering of the entire site. </p><br><p>  Having considered the example of sites, we can easily draw an analogy with a client-server application or popular micro-services.  If in the micro service call chain one of the micro services returns an answer later than usual, this can slow down all the logic.  For example, a slow response to the price of a product from the database may slow down the whole process of buying in an online store. </p><br><p>  Therefore, when we talk about program performance and delays, not only the best and average results, but also the worst results are important. </p><br><h2>  Why do we need OS monitoring </h2><br><p>  Often, developers receive complaints from customers or other systems that the application has processed the request for too long.  Unfortunately, such a problem can be difficult to reproduce locally or even notice in a real environment. </p><br><p>  Many developers in this case immediately begin to look for problems in the code.  For this is used for example logs, metrics and profiler.  But the correct performance analysis should start from the bottom up, starting with the level of iron and wasps and ending with the program. </p><br><p>  Most wasps are not real-time operating systems.  So they can not give guarantees for a certain time the execution of operations.  This means that the performance of programs running on such wasps can be very different during the time the program is running.  Simply put, the program may not even get CPU time at some point.  And then it doesn't matter what code is executed in the program. </p><br><p>  Here are some reasons why a program can ‚Äúsleep‚Äù without being able to perform useful actions: </p><br><ul><li>  The OS can perform internal garbage collection; </li><li>  Another resource-intensive application may use a CPU or other resources; </li><li>  The OS can run on top of the hypervisor and not knowing this to be not the only OS running on this hardware. </li></ul><br><h2>  Why jHiccup? </h2><br><p>  There are many utilities and metrics that allow you to see the workload of different system components with varying degrees of detail.  The problem is that there are a lot of such metrics and for each programmer you need to answer two questions: </p><br><ul><li>  Could this metric be the cause of the delay? </li><li>  Is the specific value of this metric anomalous? </li></ul><br><p>  <strong>jHiccup</strong> allows you to look at the system from the point of view of the application.  jHiccup is a small application with a simple function: an endless stream falls asleep and asks the OS to wake him up after a certain period, for example, 1 second.  If the OS was busy after 1 second and could not wake up the stream, then the application will see this by comparing the wake-up time with the estimated wake-up time (sleep time + 1 sec).  We can build a graph where we will see system delays during program execution. </p><br><img src="https://habrastorage.org/web/1e8/32a/a8c/1e832aa8cd3947a3a18f03726e328fd9.png"><br><p>  <i>On the X axis, the program execution time in seconds.</i>  <i>On the Y axis, the wake up delay in milliseconds (how long the program waited for the OS to allow it to run)</i> </p><br><p>  Knowing the time of complaint about the slow response of our system to the client and seeing the schedule of delays in the awakening of our program, we can tell if it was the cause of the delay or not. </p><br><p>  In the previous graph, we looked at delays relative to the program execution time.  In addition, it is convenient to take all the delays and sort them in ascending order.  This will give us an idea of ‚Äã‚Äãthe distribution of delays and their likelihood. </p><br><img src="https://habrastorage.org/web/ab6/a5d/fbe/ab6a5dfbe0dd42be8b74a4371788834f.png"><br><p>  <i>The delay in milliseconds on the y axis and its probability on the x axis</i> </p><br><p>  <strong>Some features of JHiccup</strong> : </p><br><ul><li>  does not suffer from the problem of Coordinate Omission well described by Gil Tene in his <a href="https://www.youtube.com/watch%3Fv%3DlJ8ydIuPFeU">video</a> </li></ul><br><p>  Inside jHiccup uses a histogram as a data structure.  A regular histogram breaks the entire delay interval (for example, from 1 ms to 1 sec) into segments and counts how many delays fall into a certain interval.  This allows you to present data on delays in a more compact form than just a list of observed values ‚Äã‚Äã(1.55ms, 2.6ms, etc.). </p><br><p>  In fact, jHicuup uses a special histogram implementation - HDR-Histogram, which has the following properties: </p><br><ul><li>  Histograms have high resolution.  We can see not only 95% and 99% of the worst results, but also much more detailed data (99.999%). </li><li>  Stores data in a compact form that allows you to measure performance over time.  For this, the size of the histogram segment increases exponentially.  This makes it more compact to store anomalous values. </li></ul><br><p>  Library HDR-Histogram is widespread.  You can find implementations in different languages.  Different systems for collecting metrics began to support hdr-historgram as one of the internal formats, due to its compactness and accuracy. </p><br><h2>  Why such accuracy? </h2><br><p>  In the graphs above, we saw data on the 99.9999% case.  For many, the question arises whether such accuracy is necessary and whether the data should be considered further than 95% or 99% of the percentile.  Let's look at two examples.  In both examples, we take the probability of the anomalous delay P (A) as 5% and 1%, respectively.  We need to answer the question, what is the probability that the user will see the anomalous request P (B): </p><br><ul><li>  We have seen google.com making about 60 requests.  For example, consider the site of an online store where to purchase, you must perform 200 requests.  In the case of P (A) = 5%, P (B) = 1‚Äì (0.95 to the power of 200) = 99.997%.  In the case of P (A) = 1%, P (B) = 1- (0.99 to the power of 200) = 86.6% </li><li>  Suppose we have 10 micro-services.  And each is called twice during the execution of a certain script, that is, there are 20 calls.  In the case of P (A) = 5%, P (B) = 1‚Äì (0.95 to the power of 20) = 64.15%.  In the case of P (A) = 1%, P (B) = 1- (0.99 to the power of 20) = 18.2%. </li></ul><br><p>  As we see, it is not enough to consider data only up to the 95th or 99th percentel. </p><br><h2>  JHiccup usage example </h2><br><p>  You can download jhiccup from <a href="http://www.azul.com/downloads/jhiccup/">http://www.azul.com/downloads/jhiccup/</a> or <a href="https://github.com/giltene/jHiccup">https://github.com/giltene/jHiccup</a> . </p><br><pre><code class="bash hljs">./jHiccup -d 4000 /usr/bin/java org.jhiccup.Idle -t 300000 <span class="hljs-comment"><span class="hljs-comment">#  4     ,    300 .       5  (    -i). #  hiccup.170617.1120.3461.hlog ./jHiccupLogProcessor -i hiccup.170617.1120.3461.hlog -o hiccup.170617.1120.3461 #  hiccup.170617.1120.3461  hiccup.170617.1120.3461.hgrm</span></span></code> </pre> <br><p>  The file hiccup.170617.1120.3461 can be viewed using the excel file jHiccupPlotter.xls. </p><br><img src="https://habrastorage.org/web/1e8/32a/a8c/1e832aa8cd3947a3a18f03726e328fd9.png"><br><img src="https://habrastorage.org/web/ab6/a5d/fbe/ab6a5dfbe0dd42be8b74a4371788834f.png"><br><p>  To view hiccup.170617.1120.3461.hgrm, you can use the online application <a href="https://hdrhistogram.github.io/HdrHistogram/plotFiles.html">https://hdrhistogram.github.io/HdrHistogram/plotFiles.html</a> .  It is also convenient for comparing several hdrm files (for example, during different system loads or from different servers). </p><br><img src="https://habrastorage.org/web/742/7ab/e7a/7427abe7a1af49a08fa71a61622f9900.png"><br><p>  Comparing the graph of the performance of our program (for example, the delay of http responses) with the resulting hdr-diagram, we can understand whether the whole system worked slowly in a certain period or only our program. </p><br><p>  We ran jhiccup as a separate process.  Another way is to run javaagent with our program. </p><br><pre> <code class="bash hljs">java -javaagent:jHiccup.jar=<span class="hljs-string"><span class="hljs-string">"-d 0 -i 1000 -l hiccuplog -c"</span></span> MyProgram.jar -a -b -c</code> </pre> <br><p>  In this case, the jhiccup will wake up and save information about delays during the entire program execution time. </p><br><p>  There are one important difference in these two launch methods.  In the first case, jHiccup runs on a separate JVM in another on the same JVM.  That is, in the second case, we will see delays associated with the operation of the JVM (for example, the GC pause), on which the main application is running. </p><br><p>  In jHiccupPlotter.xls, you can add SLA lines to the chart. </p><br><img src="https://habrastorage.org/web/591/c5a/07b/591c5a07bcbb450ab2b4b9212e9c9345.png"><br><p>  I see two convenient applications for SLA: </p><br><ul><br>  jHiccup is a handy utility for monitoring system delays.  Unlike system metrics, jHiccup allows you to take a look at system loading from an application point of view. </ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331436/">https://habr.com/ru/post/331436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331426/index.html">Videos: Android meetup at Badoo office</a></li>
<li><a href="../331428/index.html">The final of the SAP contest Koder 2017 will be held live</a></li>
<li><a href="../331430/index.html">"Gonochki" on SVG</a></li>
<li><a href="../331432/index.html">SIP: this growth does not stop</a></li>
<li><a href="../331434/index.html">We put Selenium Grid on Apache Mesos wheels</a></li>
<li><a href="../331438/index.html">Artificial Intelligence Half-Life SDK: Retrospective</a></li>
<li><a href="../331440/index.html">Medici effect or is it possible to cross a peach and melon or Windows and iOs</a></li>
<li><a href="../331442/index.html">Consider Kotlin more closely</a></li>
<li><a href="../331444/index.html">Dynamic Apache NiFi cluster creation</a></li>
<li><a href="../331446/index.html">Abnormal GraphQL in Electron or as I wrote a desktop client for Tinder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>