<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bible movements doom. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to the Doom Movements Bible! In the second part, as in the first, all the quirks and whims of the movement code in Doom, including intricate s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bible movements doom. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Welcome to the Doom Movements Bible!  In the second part, as in the <a href="https://habrahabr.ru/company/ua-hosting/blog/306556/">first,</a> all the quirks and whims of the movement code in Doom, including intricate stunts describing their work, are sorted out and categorized. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/q2/jj/inq2jja19wmoh2dve0dnzwxzdve.png"></div><br><h2>  SlideMove: slippery moments </h2><br>  Up to the present moment, all the considered tricks with the character's movement in the game relied on the discrete nature of movement in the DOOM engine.  Now we will dig the game code much deeper, and get to the function with the innocent name P_SlideMove.  The function contains a comment warning the careless reader of the code that there is ‚Äútotal confusion‚Äù in front of it.  I don‚Äôt know whether John Carmack or Bernd Kreimeier added this commentary, but it‚Äôs very, very accurate. <br><a name="habracut"></a><br><h3>  WALL RUNNING </h3><br>  We have already analyzed how a large SPT (‚ÄúState of Attempted Teleportation‚Äù, which can be perceived as a directional impulse of movement of the character, discussed in Part 1) can lead to bugs, for example, line skip (crossing the border).  Fortunately, the game engine is not so stupid and tries to take into account such errors!  So, if the bugs start, if the character moves too fast, the perfect solution would be to simply divide one move into several suitable sizes, wouldn't it?  And this is exactly what the game engine does: if the X or Y vector of movement exceeds 15 units (which, as you can see, is one unit less than the player‚Äôs radius), the engine tries to divide the player‚Äôs movements into two parts in order to calculate each of them separately.  Thus, if the speed is too high, the program checks if the character crosses the obstacle in the "intermediate" state and, if necessary, does not miss it.  Since the program conducts two movements instead of one, we will call this process ‚Äúdouble SPT‚Äù. <br><br>  ‚ÄúWait a minute!‚Äù - the reader will be indignant here.  - ‚ÄúRecently you talked about crossing borders at SPT&gt; 15, and now you are describing a code that does not allow you to do this!  How can it work at all? ‚Äù  Well, then let's just look at the code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs lisp">f (<span class="hljs-name"><span class="hljs-name">xtap</span></span> &gt; <span class="hljs-number"><span class="hljs-number">15</span></span> OR ytap &gt; <span class="hljs-number"><span class="hljs-number">15</span></span>)</code> </pre> <br>  Did you notice?  Well, what happens when a character moves south or west?  X-, as well as Y- suddenly appear ... Negative!  And, for unknown reasons, the game engine will not verify this curious fact. <br><br>  But back to the main idea.  So, the engine uses the SPT to determine where to "teleport" the character in the next step.  If the ‚Äúdrop zone‚Äù is occupied, the game code calls the P_SlideMove function, whose task is to check the fact of a collision with an obstacle and, if that happened, to ensure the character‚Äôs movement so that the collision looks natural.  To start, the engine determines the direction of the player‚Äôs movement and calculates three vectors emanating from the three leading corners of the character box.  Then it checks each vector for collision with an obstacle.  If a collision is detected, the program determines the percentage of the path to the obstacle and makes the character move to the point found.  And then he takes the rest of the SPT, directs it parallel to the wall, which the player hit, this part of the movement is the ‚Äúslide‚Äù along the wall. <br><br><img src="https://habrastorage.org/webt/co/f_/it/cof_itfhxi2adl4yqlxwzvxf7xi.png"><br><br>  And it works, more or less.  There is a small internal problem hiding here: to calculate the ‚Äúslide‚Äù, the subroutine uses the initial SPT of the character, even if it was divided into two separate movements due to the player‚Äôs high speed. <br><br>  Now that we know this, let's step through the entire process: <br><br><ul><li>  the player runs against the long horizontal wall </li><li>  that a player‚Äôs SPT, for example, is X- = 20 and Y- = 2 </li><li>  the engine determines that X-SPT is too large, and divides the movement into two, each with impulses X-SPT = 10 and Y-SPT = 1 </li><li>  now the engine checks the first of two movements and determines the collision with the wall to the north of the player </li><li>  P_SlideMove comes to the rescue and draws three vectors from the character's "corners" directed north and east.  But for the calculation of the vectors takes the base SPT, that is, X-SPT = 20 and Y-SPT = 2 (and not X-SPT = 10 and Y-SPT = 1, as it should) </li><li>  vector crosses the wall in the north </li><li>  the engine moves the character, for example, by 5% from the current SPT </li><li>  and, finally, the engine redirects the remaining 95% of the base SPT along the wall, moving the player to 19 units. </li><li>  after which, satisfied with the work done, the engine proceeds to the second half of the player‚Äôs movement, performs the usual procedure and sends the character another 19 units to the east. </li></ul><br>  To summarize the above: if a player moves north or east with a sufficiently high speed (X-SPT or Y-SPT exceeds 15 units), the initial movement attempt is blocked by an obstacle, the engine performs two complete moves in one tick!  Note that as a result, the SPT or something else does not change; it just happens two moves during one. <br><br><h3>  THING RUNNING </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5jGkdY2YmYY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>trick at 0:12</i> <br><br>  Now that we have mastered ‚Äúwallrunning‚Äù (‚Äúrunning against the wall‚Äù), let's think about it: what if we replace the wall with any impassable object, and better with a long line of such objects? <br><br>  The engine will try to teleport the player to a new position and detect an obstacle in the landing zone.  Then the program will call the P_SlideMove known to us, and she will draw three vectors from the corners and find out: there is no collision.  And what will the engine do now? <br><br>  Strangely enough, the specified function does not actually check the character's collision with objects, it only checks the intersection of the boundaries of the objects with the vectors drawn by it.  And if P_SlideMove could not find the line blocking the movement, it uses its last secret weapon: ‚Äústairstep‚Äù (running by a ladder).  The program tries to move the player exactly along the Y axis, and if it could not, along the X axis. Let me remind you that all the objects in DOOM are enclosed in a ‚Äúbox‚Äù with the sides parallel to the axes of coordinates.  Thus, if a player moves along an obstacle and the stairstep program decides to move it horizontally, the player will slide along one side of the object. <br><br>  Now, having put the above in mind, it is easy to understand that the thingrunning is exactly the same as wallrunning: the player moves north or east with ‚Äúspeeding‚Äù, the movement test divides each movement into two equal parts, and each half gets the full initial vector PST with a generous P_SlideMove feed (as long as the initial landing point is blocked).  The character successfully makes two complete movements instead of one for each tick, simply sliding at double speed along the ‚Äúedge‚Äù of objects.  This trick is best known for its use on Map23, where a player can accelerate by doing thingrunning along a number of barrels, and as a result, jumping over part of the map in a seemingly impossible way. <br><br><img src="https://habrastorage.org/webt/bs/7k/dr/bs7kdrom7cr4htni9rb3wqrj3q0.gif"><br><br><h3>  WALLRUN "AIR CONTROL" </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJLRuQEl2YI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>trick at 10:17</i> <br><br>  When I first saw this trick, he stunned me so much that I decided to write an article about the magic of the DOOM engine - the very guide that is now before your eyes. <br><br>  One of the easiest and most understandable rules for a player to move to DOOM is: ‚Äúair control does not exist!‚Äù This means that when a character‚Äôs feet do not touch the ground, the character‚Äôs movements depend only on local laws of physics, but not on the player.  And how I was amazed when, when viewing the Map14 speed crane, I saw that the player performed wallrunning high in the air, ran along the wall directly to the exit, and at the end simply turned above the ground and headed towards the south door, although before that it was just running east. <br><br>  At first, I just couldn‚Äôt realize how such a trick is possible - the player's PTA was directed exactly to the east!  He had zero Y-TSP, how could he start going south!  But, as always, the seemingly understandable code contains surprises and dirty tricks. <br><br>  It turns out that if the player is close to the obstacle, the engine will not try to bring the player closer to the barrier.  He will simply use his last resort, the already familiar ‚Äústairstep‚Äù.  Here we get to know the magic number 3.125%.  If one of the vectors drawn by the program from the player‚Äôs corners crosses the wall in less than 3.125% of its length, the program does not even attempt to make the player move in the initial direction.  Skipping all the extra steps, the engine will use the "stairstep".  Well, the code of the ladder, as we remember, is able to move the character strictly horizontally (or vertically), without at the same time not changing the initial SPT of the player. <br><br>  Now that we have reviewed the logic of the process, the incredible ‚Äúturn in flight‚Äù can be explained.  The player "goes for takeoff", pressing "up" against the wall, while having a high X-SPT and a small southern Y-SPT.  Each tick, while the player is above the ground, the engine tries to move the character to the east and a little to the south, but detects a wall at the end point of the move.  The engine instantly gives up and calls for help "stairsteps" and sends the character to the east, while not changing the vector of SPT in any way.  As a result, Y-TSP remains slightly negative throughout the ‚Äúair run‚Äù.  And in the final, when the passage to the exit is reached, the movement check is successful, and the player changes the direction of movement in the air, which would seem impossible in the realities of DOOM physics. <br><br><img src="https://habrastorage.org/webt/yq/qj/yv/yqqjyvmv0rareatra3fzg5aax8q.gif"><br><br><h3>  MOMENTUM PRESERVATION </h3><br>  This trick is not as obvious and entertaining as described above, and it was difficult for me to find a suitable name for it.  I have heard the name ‚Äúdoor trick‚Äù, and it is very often used by speedrunners while waiting for the door to open. <br><br>  The trick is trivial - resting the impassable wall in the right way, the player can keep the accumulated impulse of movement (SPT) at the maximum value, remaining motionless (the result is easy to detect visually, observing the fast oscillation of the weapon in the player's hands, as at full speed of the race. Therefore this trick is called ‚Äú wobble glide "- swaying glide).  With a speedran, this means that the player maintains the maximum speed while waiting for the door to open, and when the passage becomes large enough, the bullet rushes further, saving precious milliseconds. <br><br><img src="https://habrastorage.org/webt/sk/ii/3v/skii3vjv7ctbj9s80yfjas3zes4.gif"><br><br>  But how does this trick work?  Usually, if a character runs into a wall, its speed (its SPT) is instantly reduced by the engine.  This can be detected by changing the animation of the weapon in the hands of the player.  To understand the nature of what is happening, we will again have to delve into the code of the DOOM engine and understand how it defines collisions. <br><br>  Recall that usually when encountering a wall, the subroutine P_SlideMove known to us calculates the percentage of the motion vector directed into the wall (or skips this part if the collision is found at a distance of less than 3.125% of the vector), and then redirects the ‚Äúremainder‚Äù of the movement parallel to the wall.  In a normal situation, this quite reasonable algorithm will quench your speed - if you hit a wall run at a right angle, the slip speed will be proportional to the cosine of the angle difference between the direction of movement and the direction of the wall, and cos 90 is zero. <br><br>  But let's look deeper.  How exactly does the engine determine the future collision with a wall?  To solve this problem, the program solves a simple mathematical equation: take a line representing an impassable wall, take a motion vector directed from one of the corners of the character box and find the intersection point.  These calculations can be made using vectors, matrices, and other mathematical tools.  But the DOOM engine uses the simplest method: take the end points of segment A and check which side they are relative to segment B. Then we check which side of A are the extreme points of segment B. If in both cases the extreme points are on different sides of the lines, the segments intersect. <br><br>  To perform such a simple test, we need a little division and multiplication.  And here the game engine reveals another aspect.  The engine stores all data in the form of 32-bit values, and, most importantly, in the form of numbers with a fixed comma.  In this case, one bit is used to indicate the sign of the number (positive / negative), 15 bits store the integer part and the remaining 16 bits are fractional.  15 bits is quite a bit;  in fact, the allowable range of values ‚Äã‚Äãis from -32768 to 32768. So, if you need to multiply two numbers, you have to be very careful that the result is not out of range.  The square root of 32768 is just 181, which means that checking the intersection of two lines of 200 units each will overflow the memory cell.  And how to cope with such a puzzle? <br><br>  Here is a part of the code from the ‚Äúcrossing check‚Äù function that copes with the problem: <br><br><pre> <code class="hljs lisp">left = (<span class="hljs-name"><span class="hljs-name">line-&gt;dy</span></span> / <span class="hljs-number"><span class="hljs-number">256</span></span>) * (<span class="hljs-name"><span class="hljs-name">dx</span></span> / <span class="hljs-number"><span class="hljs-number">256</span></span>)<span class="hljs-comment"><span class="hljs-comment">; right = (dy / 256) * (line-&gt;dx / 256);</span></span></code> </pre> <br>  As you can see, it simply divides all values ‚Äã‚Äãby 256 before the start of calculations (to be perfectly accurate, it performs a bitwise right shift by 8, although this does not change anything).  In this simple way, the engine ensures that the result of the calculations will be small enough to avoid overflow.  At the same time, we reduced the fractional part from 16 to 8 bits, so there are no problems, is it? <br><br>  Well, in most cases there are no problems.  But what happens if the SPT in one of the directions is extremely small?  For example, a player runs into a corner, having an X-TPS 20 and a Y-TFS 0.001.  Let's take a closer look: <br><br><ul><li>  the engine tries to move the character 20 units east, and by 0.001 units north, but cannot, as it detects a wall in the north </li><li>  the engine calls P_SlideMove to handle collisions, draws three vectors from the corners </li><li>  the engine checks the first vector and detects the intersection with the wall in the north, as intended </li><li>  the engine checks the second vector, but due to division by 256, the tiny 0.001 Y-CPT is already rounded to zero, and the program does not find the intersection of the vector with the wall in the north </li><li>  then the engine tries to make a partial movement of the player in the direction of the first vector, for example, by 50% of the vector size </li><li>  but when the engine tries to move the player to 0.0005 units in a northerly direction, it fails, finding a wall at the end point </li><li>  the engine helplessly lowers its hands and causes a ‚Äústairstep‚Äù, which, as we know, in no way changes the initial SPT. </li></ul><br>  To sum up: if a player runs, resting on a corner, with an extremely small Y_SPT or X-SPT, he can maintain a high SPT, as a result of an erroneous zeroing of the vector. <br><br><h3>  VOID GLIDE </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UVWwoE-Q284" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>trick: 0:20</i> <br><br>  And now it's time to withdraw the heavy artillery.  Instead of breaking the conventional lines of separation, we will ignore the absolutely impassable lines. <br><br>  At first glance, this trick is simply impossible.  To pass through the wall, the character must instantly move at least 32 units.  Then, even after dividing into two parts, each ‚Äúhalf‚Äù will be&gt; = 16 units (character size).  We already know that the maximum speed that can be reached with the use of the SR50 is 23.57 units per tick, but even if the limit is reached, the engine will split 23.57 into two separate movements.  Moreover, the game code contains a hard speed limit of 30 units, which is applied at the very beginning of the movement calculation.  And how in such conditions to achieve the speed of movement of the character to 32 units in one movement? <br><br>  In general, it is true that 23.57 is the maximum speed achievable with conventional character controls, but what if ‚Äúconventional means‚Äù is not the only way to increase the SPT?  Armed with this knowledge, you can squeeze out much, much more from the DOOM engine.  (I will not intentionally describe the damage boosts - it is difficult to control and test. Of course, you can get a speed of more than 23.57, for example, by undermining yourself with a rocket, but there is a much simpler and safer way). <br><br>  It's time to go back to P_SlideMove.  As I already described, in a collision, after performing a partial displacement in the direction of the vector, the rest of the SPT is redirected parallel to the obstacle.  So, how is this piece of logic implemented?  The following three steps are performed: <br><br><ul><li>  determine the amount of unused TSP </li><li>  create a vector of the same size, directed along the obstacle </li><li>  divide the new vector into the x- and y-component to determine the new X-SPT and Y-SPT of the player. </li></ul><br>  All these calculations are very simple to perform using sines and cosines.  But it is here that the code seems to forget about the existence of trigonometry and uses just a brilliant simplification.  Instead of determining the value of the remainder of the SPT correctly, it calls the function named P_AproxDistance.  And what does this P_AproxDistance (Approximate Distance) do? <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (the longer <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> XTAP <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> YTAP) + (half the shorter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> XTAP <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> YTAP)</code> </pre> <br>  Yes, yes, you were not mistaken.  We do not need sines and cosines, square and cubic roots are not needed; addition is enough for us.  Just add one axis to half the second axis.  You can imagine how approximately this "aproximation" (approximation). <br><br>  Thus, the function gives the player a very serious bonus.  The fact is that the result of such a calculation is consistently more than the correct result.  Let's check with an example: calculate the player's ‚Äúslip‚Äù vector when X- = 3 and Y- = 4. The Pythagorean theorem tells us that the size of the slip vector is 5: this is the hypotenuse of a right triangle with sides 3 and 4. But the P_AproxDistance function returns size 5.5.  And here, we received acceleration for 10% simply because of an inaccuracy of calculations!  The size of such a bonus depends on the angle of movement of the player, and unfortunately, if the angle is 45 degrees (the usual situation with the void glide trick), the bonus will be a measly 6%.  And this is more than enough. <br><br><img src="https://habrastorage.org/webt/3j/dc/y9/3jdcy95vauchluwb4_maogf0xj0.png"><br><br>  However, a little more effort is needed to achieve an amazing result.  Usually P_SlideMove does this: <br><br><ul><li>  starts the meter starting from one </li><li>  draws vectors from corners, and tries to move the player in the direction of one of them </li><li>  if there is a remainder of the vector after a collision, it cheats a new vector directed parallel to the obstacle and tries to move the player in a new direction </li><li>  if the movement "slip" is impossible, it starts all over again, increasing the counter by one </li><li>  well, if the counter has already reached 3, helplessly gives up and calls for help ‚Äústairstep‚Äù. </li></ul><br>  Now the logic of what is happening has become obvious: if a player is in a corner, the first collision with the wall causes a slide to the second wall.  A second collision occurs immediately there, and the algorithm is restarted, taking as the initial data the existing RTS - that is, the remainder of the ‚Äúslip‚Äù from the previous cycle.  The whole trick comes down to creating a situation where P_SlideMove constantly fails when trying to move.  This is what happens: <br><br><ul><li>  three vectors known to us are drawn </li><li>  the shorter of them intersect with the wall at a distance of less than 3.125% of its own length </li><li>  instantly calculated "slip vector", using 100% of the current TSP </li><li>  in the process of calculating, the PST grows due to the inaccuracy of the ‚Äúapproach‚Äù P_AproxDistance </li><li>  however, slipping in a new direction is impossible; therefore, the process is restarted </li><li>  described steps are repeated twice </li><li>  the algorithm gives in, causing the stairstep, which also fails, but at the same time saves the player's twice-increased SPT. </li></ul><br>  But this is not all: if during a ‚Äúrun in the corner‚Äù a player‚Äôs SPT exceeds 15 units and is directed north or east, the described process will occur twice, thanks to splitting the movement into two parts.  That is, an increase in PTA will occur four times in one tick! <br><br><img src="https://habrastorage.org/webt/be/jf/fc/bejffcw1p4u6ti1m18xkkk9m1k0.gif"><br><br>  Now we saw the whole process.  You just need to choose the correct position and the code will enter the cycle, which gives a constant increase in TPS.  Each SPT tick is increased twice (or four times) by a relatively small amount due to a rough approximation.  At the end of each tick, an SPT grown up, of course, is reduced by "friction", but as long as the increase in TPS per tick is at least 10%, this is enough to exceed the decline due to friction and to ensure a constant increase.  It remains to wait until SPT exceeds 32 units. <br><br> ¬´        30 !¬ª ‚Äî   .  Yeah, right.       ¬´  ¬ª     30 ,    ,      32 . -,        37  38 . <br><br>   :  ,          .     X-   Y-,     .            ,   void glide  . <br><br><h3> ELASTIC COLLISIONS </h3><br>  void glide    ,      : ¬´elastic collisions¬ª ( ).      ,      ,          . <br><br><img src="https://habrastorage.org/webt/hh/h_/kc/hhh_kcammwpftfsbv6jfcm11l_e.gif"><br><br>  elastic collisions       .     ‚Äì     15 ,     -15,  -  .  ,     -       ,     ,   . <br><br>   elastic collisions,        DOOM. ,      ,      ?  : -   .          .   ,     :      X-  Y-  16 ,        16. <br><br> ¬´,    ?¬ª ‚Äî  . ,    ,     -:       ,        .    ,    ,        . <br><br> ,   ,    .   :       ,           .   line intersection ( ):          ,         .      DOOM     ,   . <br><br>               ,   .  , ,       . ,   ¬´¬ª       ,  .        ‚Äì   ,        .     wall gliding       ‚Äî    .  ,     ,  , ,  . <br><br>      elastic collisions,   !    .   ,      ¬´¬ª,     . <br><br>      ,       .   ,        ,            .   ,      0 (   )  180 ( ,    ). <br><br>   :   ,        ,  - ,    ? <br><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">deltaangle</span></span> &gt; ANG180) deltaangle += ANG180<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>   :  ¬´ ¬ª    ‚Äì  ,  ,  .    ,      ,   ? <br><br>    ,        ,   ( ,   ¬´¬ª ) ‚Äì   ?     ¬´¬ª    ,       . <br><br>      ,       ,    ?      ,  ,  ,  .    , :     16      ,    ,       ,      ( )  ( ).     ¬´ ¬ª   -   .            , ,  . <br><br><img src="https://habrastorage.org/webt/fg/qm/dy/fgqmdyw-66ig66uwnb7ihywyt1s.gif"><br><br> ,     ,    .   ,           ? <br><br> <b>BLACK FRIDAY :</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30% discount on the first payment on the promo code </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BLACK30%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when ordering for 1-6 months!</font></font><br><br>  These are not just virtual servers!  This is a VPS (KVM) with dedicated drives, which can be no worse than dedicated servers, and in most cases - better!  <b><a href="https://ua-hosting.company/vpsnl">We made VPS (KVM) with dedicated drives in the Netherlands and the USA</a> (configurations from VPS (KVM) - E5-2650v4 (6 Cores) / 10GB DDR4 / 240GB SSD or 4TB HDD / 1Gbps 10TB available at a uniquely low price - from $ 29 / month , options are available with RAID1 and RAID10)</b> , do not miss the chance to place an order for a new type of virtual server, where all resources belong to you, as on a dedicated one, and the price is much lower, with a much more productive hardware! <br><br>  <a href="https://habrahabr.ru/company/ua-hosting/blog/329618/">How to build the infrastructure of the building.</a>  <a href="https://habrahabr.ru/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b> </div><p>Source: <a href="https://habr.com/ru/post/342286/">https://habr.com/ru/post/342286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342276/index.html">Weekdays tester, or what's the Pyramid of Maslow</a></li>
<li><a href="../342278/index.html">Storage. Multi-tier software-defined storage. Why, why, and how is implemented using the example of the MIRhosting cloud</a></li>
<li><a href="../342280/index.html">HistoryAPI: How to write once, and so that the head does not hurt</a></li>
<li><a href="../342282/index.html">Question: Does the software really use the new instruction sets?</a></li>
<li><a href="../342284/index.html">New release Oh, My Code - Cloud, Perl and good programmers</a></li>
<li><a href="../342288/index.html">SparrowHub Plugin Overview</a></li>
<li><a href="../342290/index.html">November 29, Kharkiv: Report "Analytics in a Gaming Company: Big Data Architecture and Tools"</a></li>
<li><a href="../342292/index.html">Introduction to Seneca.JS</a></li>
<li><a href="../342298/index.html">Andrei Karpov believes that the code for the Manticore project is better than the code for the Sphinx project</a></li>
<li><a href="../342300/index.html">How not to put thousands of servers using centralized configuration management using the example of CFEngine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>