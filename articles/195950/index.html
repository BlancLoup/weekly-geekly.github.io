<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast tracks on google maps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am working on the visualization of paragliding competitions - I am writing a race viewer for Airtribune.com . In the process of work, I come across ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast tracks on google maps</h1><div class="post__text post__text-html js-mediator-article">  I am working on the visualization of paragliding competitions - I am writing a race viewer for <a href="http://airtribune.com/">Airtribune.com</a> .  In the process of work, I come across interesting and non-standard tasks.  One of them is the task of quickly drawing markers and tracks on google maps. <br><br>  The scales are as follows: there are ~ 200 trackers in a fairly limited area (50x50km), each transmitting data about its position every 10 seconds.  It is necessary to draw them all on the map and smoothly move when the coordinates change.  A track should be drawn behind each marker.  The picture is about the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9e/f23/bce/c9ef23bcedda6dd641257f9e4f52a803.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It soon became apparent that the built-in objects ‚Äî google.maps.Marker and google.maps.Polyline ‚Äî are too slow for this task.  There was a lot of ideas for optimization, and as a result we got a solution on the canvas that works at a speed of 40fps even on a thousand markers.  However, you can measure fps yourself - I assembled a test application for comparing 4 engines, in which you can plug in different chips on the fly and look at the speed of work. <br><br><a name="habracut"></a><br><br><h4>  Test application </h4><br>  <a href="http://kasheftin.github.io/gmaps/">kasheftin.github.io/gmaps</a> is a demo here, <a href="https://github.com/Kasheftin/gmaps">github.com/Kasheftin/gmaps</a> is the source code here.  Works in firefox and chrome, html + js.  Used google maps api v3, knockout, require, underscore and bootstrap. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/2a1/8e1/6b22a18e13cda967a065b474039be9bc.png" alt="settings"><br><br>  The settings are divided into two parts - in the right part is the coordinate generator.  In addition to managing the number of markers there is little interesting.  The generator emulates a real server, i.e. spits out data in chunks a minute ahead.  Therefore, if the settings change, the changes are not immediately visible.  Speed ‚Äã‚Äãis the maximum value by which latitude or longitude can change in a second.  Angle - the maximum angle at which the course can change.  The probability of movement is the probability that data with the coordinates of the pilot will arrive at this second, and hold is the probability that the data will come the same (ie, the pilot will hang in one place).  Between control points, the movement is considered uniform straight. <br><br>  The most interesting is in the left column of settings.  Here you can switch the engines, when you select the engine, checkboxes with its settings are displayed under it, and everything is connected on the fly on the same data set - this is done in order to adequately evaluate fps.  The fps itself will be displayed if you click on the play button above the map.  Fps is measured stupidly and practically - the requestAnimFrame method is used to play the animation - how many times it has time to work in a second, such and fps. <br><br><br><h4>  Native engine </h4><br>  This is a drawing using standard google maps.  The first thing that comes to mind is to use <a href="https://developers.google.com/maps/documentation/javascript/reference">google.maps.Marker</a> to display the current position of the trackers and <a href="https://developers.google.com/maps/documentation/javascript/reference">google.maps.Polyline</a> to draw the tracks.  The reason for the brakes during animation is object logic.  Markers and lines are pictures on canvas, but we communicate with them as with objects.  And it is expensive.  Marker movements should be smooth.  If at this point in time the marker has no coordinates, its instantaneous coordinates are calculated as a linear proportion between the existing coordinates before and after.  This means that EVERY markers are shifted in each frame. <br><br>  Suppose that 100 markers with random coordinates were created in the markers array.  Consider the code: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> run = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; markers.length; i++) markers[i].setPosition(getRandomCoords()); requestAnimFrame(run); } run();</code> </pre> <br>  The run function is roughly an animation frame.  In each frame, each marker in turn moves to a new position using the very convenient setPosition method.  It is about the following: <br><ol><li>  Geographic coordinates are converted to rectangular and then pixel by WGS84. </li><li>  It is determined on which canvas tile there was a marker, and on which one it should jump now. </li><li>  Canvas is a bitmap, it does not have a vector structure.  There is a complete redraw. </li></ol><br><br><h4>  Retreat: problem-joke </h4><br>  Suppose there is a code that performs an action in a loop, and it is not known how long it takes (a classic example is the function requestAnimFrame).  I want to know this time, add it to the timer and get some time to show in the player.  It is natural to expect that the calculated time will go at the same speed as the present.  The obvious solution: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> run = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    var startDt = (new Date).getTime(); //  -  ,    callback requestAnimFrame(function() { // ,    var currentDt = (new Date).getTime(); // ,     requestAnimFrame var diffDt = currentDt-startDt; //       ourTimer += diffDt; }); //   run(); }</span></span></code> </pre><br>  It seems all right?  I propose to run an exaggerated example and find what the error is - <a href="http://jsfiddle.net/kasheftin/a5sen/1/">jsfiddle.net/kasheftin/a5sen/1</a> . <br><br><br><h4>  Wonderful engine </h4><br>  We'll deal with the tracks later, but for now we‚Äôll optimize the drawing of markers.  In google maps v2 and leaflet markers are drawn by divs.  It is logical to assume that moving 100 divs is faster than 100 times to redraw canvases with objects.  Especially if at the same time to optimize the calculations of coordinates. <br><br>  There are two mechanisms for imposing your objects on google maps - using overlays ( <a href="https://developers.google.com/maps/documentation/javascript/overlays">overlays</a> ) or using your own <a href="https://developers.google.com/maps/documentation/javascript/maptypes">map type</a> ( <a href="https://developers.google.com/maps/documentation/javascript/maptypes">overlay map type</a> ).  For marvelous markers we will use the overlay.  Create a div container, which we will put on top of the map, and in which we will add divs with icons of markers.  In each frame of the animation, we will run through the array of markers, calculate the new coordinates and shift the divs. <br><br><div class="spoiler">  <b class="spoiler_title">code with comments</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Overlay = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._map = map; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setMap(map); } <span class="hljs-comment"><span class="hljs-comment">//     google.maps.OverlayView Overlay.prototype = new google.maps.OverlayView(); //          Overlay.prototype.onAdd = function() { //    - this._container = document.createElement("div"); this._container.style.position = "absolute"; //   ,     ,   z-index- // floatPane -   ,      this.getPanes().floatPane.appendChild(this._container); this.relayout(); } //          -          //       ,   -    -    Overlay.prototype.relayout = function() { var bounds = this._map.getBounds(); // - -   var corner = new google.maps.LatLng(bounds.getNorthEast().lat(),bounds.getSouthWest().lng()); //    this.sqCorner = this._map.getProjection().fromLatLngToPoint(corner); //      this.pxCorner = this.getProjection().fromLatLngToDivPixel(corner); //      this._container.style.top = Math.floor(this.pxCorner.l)+"px"; this._container.style.left= Math.floor(this.pxCorner.t)+"px"; } //       Overlay.prototype.appendChild = function(child) { this._container.appendChild(child); } var map = new google.maps.map(...); var overlay = new Overlay(map);</span></span></code> </pre></div></div><br><br><h4>  Bad optimization </h4><br>  In google maps there are several places where you can add your own elements.  Overlays are recommended to add to one of the containers <a href="https://developers.google.com/maps/documentation/javascript/reference">MapPanes</a> .  The controls (for example, your zoom scale or switches) are in <a href="https://developers.google.com/maps/documentation/javascript/controls">MapControls</a> .  Accordingly, all the layers of MapPanes are ‚Äúglued‚Äù to tile tiles of the map and move at the dredge.  The controls are on top of the tiles and are fixed. <br><br>  An idea arises - since every time a dam is overloaded, the overlay card needs to be returned back to the upper left corner, why not place it in a fixed layer of controls?  This works (discussion on <a href="http://stackoverflow.com/questions/17414425/is-it-a-correct-way-to-add-layer-to-google-maps">stackoverflow</a> and a working example on <a href="http://jsfiddle.net/wcfPG/">jsfiddle</a> ).  The idea may even seem successful - as long as the application is not running on a slow android-like system.  It turns out that the map is moving, and the markers do not have time and blunt in place.  Everyone is accustomed to the fact that during a dredging, unloaded gray areas can come out, which are then filled with data (for example, they moved the map - and the track on the new area was drawn only after a second).  But the desynchronization in the movement of the layers is invalid. <br><br><br><h4>  Canvas engine </h4><br>  Since the markers are constantly in motion, it is logical to assume that they all redraw at once faster than moving one at a time.  No observable or events emitter is needed, no need to follow when the marker changes its coordinates (it may happen more than once between frames).  Instead, in each frame we will run over all the markers and re-draw them on one large canvas, which is superimposed over the map. <br><br><div class="spoiler">  <b class="spoiler_title">Code with comments</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Overlay = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._map = map; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._mapDiv = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._map.getDiv(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setMap(map); } <span class="hljs-comment"><span class="hljs-comment">//     google.maps.OverlayView Overlay.prototype = new google.maps.OverlayView(); //          Overlay.prototype.onAdd = function() { //  canvas-   this._container = document.createElement("canvas"); this._canvas.style.position = "absolute"; this._container.style.pointerEvents = "none"; this._container.style.webkitTransform = "translate3d(0,0,0)"; this._container.style.imageRendering = "optimizeSpeed"; //   ,     ,   z-index- // floatPane -   ,      this.getPanes().floatPane.appendChild(this._canvas); this.relayout(); } //          -          //       ,   -    -    Overlay.prototype.relayout = function() { var bounds = this._map.getBounds(); // - -   var corner = new google.maps.LatLng(bounds.getNorthEast().lat(),bounds.getSouthWest().lng()); //    this.sqCorner = this._map.getProjection().fromLatLngToPoint(corner); //      this.pxCorner = this.getProjection().fromLatLngToDivPixel(corner); //      this._container.style.top = Math.floor(this.pxCorner.l)+"px"; this._container.style.left= Math.floor(this.pxCorner.t)+"px"; //      ,     ,   if (this._width != this._mapDiv.offsetWidth || this._height != this._mapDiv.offsetHeight) { this._width = this._mapDiv.offsetWidth; this._height = this._mapDiv.offsetHeight; this._container.width = w; this._container.height = h; } }</span></span></code> </pre></div></div><br>  The author of this overlay is <a href="http://habrahabr.ru/users/napa3um/" class="user_link">napa3um</a> .  He proposed the following optimization.  Each time when the coordinates of a point change, its rectangular coordinates are calculated using the WGS84 Mercator projection formula.  To avoid computations, you can calculate and store rectangular coordinates on the server, and send the computation results to the client. <br><br>  There is no server in the test application, and therefore do not test the result of this optimization.  To simulate the effect, I replaced the calculation of the projection with a simpler linear transformation (the geographical and rectangular coordinates of the map corners are known, and based on them the rectangular coordinates of any point are calculated as a linear proportion).  In the application settings there is a checkbox "optimize geo calculations", which includes this method of calculation.  On large zooms, the proportion lies, but on those zooms on which it is noticeable, paragliding races are not looking.  However, the results show that any calculations are now happening very quickly, and the brakes occur at the drawing stage. <br><br>  When using canvas, it is often necessary to solve the problem of handling mouse events on drawn objects.  On <a href="http://airtrubune.com/">Airtribune</a> , both engines are used to handle paraglider clicks - the markers themselves are drawn on the canvas, and a divine overlay with empty divas lives above the canvas, which move synchronously to the markers and catch clicks. <br><br><br><h4>  Caching icons </h4><br>  This is just an illustration of what sprites, icons, texts and other small graphics should be cached.  In a canvas engine, markers are drawn along with captions.  Drawing text on canvas, especially with stroke (strokeText) is a very expensive operation.  There is a setting that includes caching the icon with the text on a separate small canvas (the prepared image is then inserted into the overlay with the drawImage command).  All other things being equal, on 100 markers, the performance of the cached and non-cached versions differs 15 times. <br><br><br><h4>  Tracks </h4><br>  The server returns the position of the marker as an array of control points [[time, lat, lng], ..].  The track that needs to be drawn after the marker is broken down into constant and dynamic parts.  The constant part of the track is a polyline connecting the control points with a time shorter than the current one.  Dynamic is a segment from the last drawn control point to the current position of the marker (due to the smoothness of movement, the marker is almost always between some control points). <br><img src="http://habrastorage.org/getpro/habr/post_images/667/787/ced/667787cedb52bfc709c0eca57eea76b5.png" alt="constant and dynamic parts of the track"><br>  In the native and marvelous engines, tracks are drawn using the google.maps.Polyline object.  There is a setting - use one polyline for the entire track or two (one for the dynamic part, the other for the static part).  The longer the track, the more a single polyline loses split into two.  This is due to the fact that in the first case in each frame you need to remove the last point from the track (the one that indicates the current position of the marker) and add it again. <br><br><br><h4>  Main feature </h4><br>  Work with canvas recalls drawing with a pen on paper.  You can finish the line pretty quickly, but in order to move it later, it is easier to take a new sheet and redraw everything anew.  Drawing tracks fits well with this technology.  The very essence of the track is that it is a trace behind the marker.  The idea is that when adding a new link, you do not need to redraw the entire track again! <br><br>  We use two canvases, one for the static part of the tracks, the other for the dynamic part.  Dynamic is still redrawn once per frame.  Static - only when the map shifts and the zoom changes.  When you need to extend the track - just draw a new link to what is already drawn on the canvas.  The speed of such tracks is high and does not depend on the length of the track.  In fact, if it were not for the map shifts (and a few more cases when redrawing is needed), the coordinates of the track points could not have been remembered at all on the client. <br><br><br><h4>  Simplify.js </h4><br>  <a href="http://mourner.github.io/simplify-js/">Simplify.js is</a> created as if specifically for this task, it is silly not to use it.  On the default settings of the generator, the effect is not visible, but the real tracks are less reminiscent of Brownian motion.  In this task, speed is more important than accuracy, so we use a fast radial algorithm. <br><br><br><h4>  Tile Tracks </h4><br>  All the described optimizations are now working on <a href="http://airtribune.com/">Aitribune</a> .  Examples of races - <a href="http://airtribune.com/play/61/2d">1</a> , <a href="http://airtribune.com/play/96/2d">2</a> .  From the point of view of performance, the main thing that does not suit now is the brakes in the drawing when the map shifts, when everyone, even a small shift, causes a complete redrawing of all the tracks.  To solve this problem, instead of overlaying, we will use our own <a href="https://developers.google.com/maps/documentation/javascript/maptypes">map type</a> with tiles.  A tile is a square with a side of 256 pixels.  When map shifts, the google maps engine completes new squares and removes old ones.  All that is required of us is to write a method that should be called when the new square is completed: <br><br><div class="spoiler">  <b class="spoiler_title">Code with comments</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CanvasTileMapType = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">//    CanvasTileMapType.prototype.tileSize = new google.maps.Size(256,256); // ,       //  coord = {x:..,y:..} -     x  y       //  ,          {x: coord.x*256, y: coord.y*256} // ,      {x: coord.x*256/(1&lt;&lt;zoom), y: coord.y*256/(1&lt;&lt;zoom)}. CanvasTileMapType.prototype.getTile = function(coord,zoom,ownerDocument) { var tile = { coord: coord, zoom: zoom, size: this.tileSize.width, }; tile.canvas = ownerDocument.createElement("canvas"); tile.canvas.width = tile.size; tile.canvas.height = tile.size; tile.canvas.tile = tile; return tile.canvas; } var map = new google.maps.Map(...); //   --     google maps var canvasTileMapType = new CanvasTileMapType; map.overlayMapTypes.push(canvasTileMapType);</span></span></code> </pre></div></div><br>  Static pieces of tracks will be drawn on this layer, while the track is considered as a set of segments.  Two options are possible: <br><img src="http://habrastorage.org/getpro/habr/post_images/a28/418/a50/a28418a507e1cd4b9bc1447a7b621782.png" alt="image"><br>  Option 1: send new data, you need to complete the track.  In this case, we run only on the new points of the track.  For each new segment, you can very quickly get the number (a) of the square in which it is contained.  We got the number of the square, rendered it (in the picture: we determine that of all existing tiles, the segment is in the squares (2,3) and (3,3), we draw on them). <br><br>  Option 2: there was a shift of the map, as a result of which new tiles were initialized.  In this case, you need to re-run through all the segments, but draw only those that fall into the new tiles.  When adding a new tile, the drawing should not be started immediately, since tiles are usually added several times in rows or columns (in the picture: the map is shifted to the left, while the new column from the tiles is completed on the right, all existing segments need to be drawn on them). <br><br><br><h4>  Conclusion </h4><br>  The article ended unexpectedly.  A rather narrow task of drawing tracks on a map was considered, however, some techniques can be applied in a wide area.  Using the canvas overlay, you can draw any objects on the map (see <a href="http://www.mapnificent.net/sanfrancisco/">example</a> ).  Own tile layer can also be used in many places.  For example, in some tasks you can generate tiles with markers on the server, and transfer ready-made pictures to the client (see <a href="https://developers.google.com/maps/articles/toomanymarkers">fusion tables</a> ).  Well, the very idea of ‚Äã‚Äãthe tracks is also common for any animation: less redraw - complete more. </div><p>Source: <a href="https://habr.com/ru/post/195950/">https://habr.com/ru/post/195950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195934/index.html">Migrating to Chef Server 11</a></li>
<li><a href="../195938/index.html">KINS client part leaked</a></li>
<li><a href="../195942/index.html">Impressions of forty days of open source daily work on GitHub.</a></li>
<li><a href="../195944/index.html">We do not need your coffee</a></li>
<li><a href="../195948/index.html">Lock-free data structures. Basics: Atomicity and atomic primitives</a></li>
<li><a href="../195954/index.html">New configuration of dedicated servers</a></li>
<li><a href="../195956/index.html">Old typewriter with Arduino and Raspberry Pi as a printer</a></li>
<li><a href="../195958/index.html">Digest of news of the Windows Azure platform, October 1, 2013</a></li>
<li><a href="../195960/index.html">Another way to record working time in Redmine</a></li>
<li><a href="../195966/index.html">Full mouse events on Canvas graphics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>