<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>BEM methodology: how it all began and why it is all needed</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, much has already been written about the methodology of BEM, which grew up in Yandex. And we decided that it was time to systematically tell ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>BEM methodology: how it all began and why it is all needed</h1><div class="post__text post__text-html js-mediator-article">  On Habr√©, much has already been written about the methodology of BEM, which grew up in Yandex.  And we decided that it was time to systematically tell about where it came from and what made BEM as we know it.  We think it will be interesting not only to those who already use BEM, but also to those who believe that this methodology is not suitable for their projects.  Perhaps they will see that we have solved problems similar to their own, and will find something useful for themselves. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/09d/d3b/d6d/09dd3bd6d684e767c5f4d5b9564607d8.png" alt="image"><br><br>  Of course, it all started with Yandex‚Äôs own needs.  At the same time, as he grew, the number of employees involved in the front-end grew.  Gradually, the team has grown so much that it became obvious that without uniform standards it will be difficult to work.  In addition, we are located in Yandex offices in different cities.  The idea was to create a common methodology that will help organize the processes in a large team working on different projects.  And the main thing is that we wanted not only to streamline and accelerate development, but also to lower the project entry threshold for a new developer. <br><a name="habracut"></a><br><h2>  What is the BEM methodology for? </h2><br>  What requirements we formulated: <br><ul><li>  The developer must understand his code (even returning to it in a year) and the code of any programmer in the BEM project team. </li><li>  Any block of code can be reused: you need to create a common knowledge base and not to write everything from scratch every time, but to use ready-made developments. </li><li>  Working as a team, developers, managers, designers and layout designers should name the same things the same way.  That is, speak the same language. </li><li>  Teams can exchange experts for the implementation of a specific functionality. </li><li>  The entry threshold for the transition to a new project should be reduced due to the same organization structure of all BEM projects and the same naming rules for all entities. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We wanted to improve the quality of the product with an increase in the number of developers.  This means that developers should be aware of each other‚Äôs work and not reinvent what has already been implemented.  We wanted to create a single team that works on different projects. <br><br><h2>  The history of the development of BEM </h2><br><h3>  How to make up 10 years ago </h3><br>  But when it all began, there was no talk about any component approaches and modularity in web development.  All sites were made up, putting the CSS in one <code>project.css</code> file, the scripts that were very few in <code>project.js</code> , and the pictures in the <code>images</code> folder. <br><br>  In 2005, the usual, in terms of interface, the project was a set of static HTML-pages.  That was the typical project structure of the time: <br><br><pre> <code class="bash hljs">about.html <span class="hljs-comment"><span class="hljs-comment">#      HTML- index.html ‚Ä¶ project.css #         project.js #         images/ #      yandex.png</span></span></code> </pre><br><br>  CSS used <code>id</code> , classes and tags. <br><br>  <b>Example</b> <br><br><pre> <code class="css hljs"> <span class="hljs-selector-id"><span class="hljs-selector-id">#foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-position</span></span>: <span class="hljs-number"><span class="hljs-number">54%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(../i/foot-4.png); }</code> </pre><br><br>  Typical CSS of the time in most cases contained a long cascade. <br><br>  The slightest changes required a long refactoring.  Rolled up static HTML pages were cut into templates.  If HTML was changed, all edits needed to be manually transferred to the template. <br><br>  Layout in large projects was unmanageable. <br><br><a name="present"></a><br><h3>  Fundamentals of BEM Methodology </h3><br>  The technologies (HTML, CSS, JavaScript) that we used varied depending on the requirements of the project, and the principles of BEM should have been universal. <br><br>  We have formulated the basic rules by which our projects will live and develop, and which will in no way depend on technologies and tools. <br><br>  To speed up development, it was necessary to facilitate the HTML and CSS support for individual components of the page, to make the code less related.  For this we have divided the page into parts.  So a new concept appeared - a <a href="https://ru.bem.info/method/key-concepts/">block</a> .  A block could consist of various <a href="https://ru.bem.info/method/key-concepts/">elements</a> that were not used outside the block itself.  The states and behavior of the block and the element could be set using the <a href="https://ru.bem.info/method/key-concepts/">modifier</a> . <br><br>  These were the three key concepts on which most of the rules were based.  The abbreviation for the three words ‚ÄúBloc, Element, and <b>M</b> ‚Äù is the name of the methodology ‚Äî BEM. <br><br><h4>  Block </h4><br>  Logically and functionally independent component of the page.  The block is completely self-sufficient: it can have its own behavior, patterns, styles, documentation, and more.  Blocks can be used anywhere on the page, repeatedly, even in another project. <br><br>  Some blocks can be nested in others, assembled, used to create more complex blocks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/569/22d/95c/56922d95c9a9725976d8010279baf919.png" alt="image"><br><br><h4>  Element </h4><br>  The part of the block that cannot be used in isolation from it and makes sense only within the framework of its parent.  Items may be required and optional. <br><br>  When working with elements, it is important to remember the rule: it is not recommended to create elements of elements.  If you put one element into another, it will be impossible to change the internal structure of the block: elements cannot be swapped, deleted or added without adjusting the existing code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4f/9c7/a51/f4f9c7a516e679b4dec1e90eb25f6640.png" alt="image"><br><br><h4>  Modifier </h4><br>  A property of a block or element that changes their appearance, state, or behavior. <br>  The modifier has a name and can have a value.  Using modifiers is optional.  A block / element can have several different modifiers at the same time. <br><br>  For example, using the modifier, you can change not only the color of the sword, but also its functionality (as shown in the case of the red sword): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81c/325/0b2/81c3250b2a8b7cbb09420e82aed2c34c.png" alt="image"><br><br><h3>  CSS Naming Guidelines </h3><br>  All the principles of BEM were formed and implemented gradually.  We started by formulating strict rules for naming CSS selectors. <br><br>  According to the BEM methodology, the blocks are not unique and can always be reused, therefore, in the description of the CSS rules, the use of <code>id</code> abandoned. <br><br>  A block should not depend on the blocks surrounding it and should not itself affect neighboring blocks, so the CSS refused from: <br><ul><li>  tags; </li><li>  nested selectors; </li><li>  global reset rules for the entire page. </li></ul><br><br>  An important defining entity in the naming of selectors is the block: <br><ul><li>  The full name of the element / modifier is formed so that it can be used to determine the belonging of this element / modifier to a specific block. </li><li>  By the name of the element modifier, it should be possible to determine whether this modifier belongs to a specific element of a particular block. </li></ul><br><br><h4>  Rules for the formation of the name of the BEM entity </h4><br><ul><li>  Each BEM entity must have its own class. </li><li>  CSS properties for blocks, elements, and modifiers are described only through classes. </li><li>  To separate words in names, a hyphen ( <code>-</code> ) is used. </li><li>  The element is separated from the block by two underscores ( <code>__</code> ).  The modifier is one ( <code>_</code> ). </li><li>  The names of BEM entities are written using lowercase letters and Latin letters. </li></ul><br><br>  We experimented with prefixes in names for a long time, but eventually we abandoned them. <br><br>  <b>Example</b> <br><br><ul><li>  The block name is <code>header</code> . </li><li>  The name of the block element - <code>header__search-form</code> is the <code>search-form</code> element of the <code>header</code> block. </li><li>  The name of the block modifier is <code>header_theme_green-forest</code> ‚Äî the <code>theme</code> modifier in the <code>green-forest</code> value of the <code>header</code> block. </li><li>  The name of the element modifier is <code>header__search-form_disabled</code> ‚Äî the boolean <code>disabled</code> modifier of the <code>search-form</code> element of the <code>header</code> block. </li></ul><br><br>  HTML <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header header_theme_green-forest"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  CSS <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br><br>  There are a number of <a href="https://ru.bem.info/method/naming-convention/">alternative naming schemes</a> .  The choice is always yours. <br><br>  But we recommend sticking to the scheme described above, since the BEM platform tools can work with this naming option. <br><br><h3>  BEM to HTML </h3><br>  We wanted to streamline HTML and eventually came to the conclusion that we no longer write HTML with our hands.  Read more in the section on the description of <a href="https://habr.com/ru/company/yandex/blog/276035/">BEM tools</a> . <br><br>  In HTML, each BEM entity is defined by its class. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"block-name"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"block-name__elem"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  In the simplest case, a block corresponds to a DOM node, one to one.  But the DOM node and the block are not always the same.  Several entities can be combined on one DOM node.  This is called a <a href="https://ru.bem.info/method/key-concepts/">mix</a> . <br><br>  With the help of mixes you can: <br><ul><li>  combine the behavior and styles of several BEM entities without duplicating the code; </li><li>  create semantically new interface components based on the available blocks, elements and modifiers; </li><li>  set the position of the nested block in the parent, without creating additional modifiers.  Read more about how to create wrappers in HTML, read on the <a href="https://ru.bem.info/forum/656/">forum</a> . </li></ul><br><br>  <b>Example</b> <br><br>  The buttons are implemented in the <code>button</code> block.  It is necessary to place the button in the search form ( <code>search-form</code> ) and set indents for the button.  To do this, use the mix of the <code>button</code> block and the <code>button</code> element of the <code>search-form</code> block: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"search-form"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"button search-form__button"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Mix allows you to use a universal button that knows nothing about the indents from the borders of a particular form.  In this case, the search form has an element <code>search-form__button</code> , which knows where it needs to be, and a <code>button</code> block that needs to be displayed. <br><br>  Instead of a mix, you can create an additional modifier to the <code>button</code> block, but we do not recommend this method, since the positioning of the <code>button</code> block is not necessarily part of the universal block, but only suitable for its particular place of use. <br><br><h3>  File System Organization </h3><br>  We were not satisfied with the original structure of the project in the file system: it was difficult to navigate and find the necessary technologies of the entities. <br><br>  What we wanted to get from the new structure: <br><ul><li>  Unified file system of any BEM project. </li><li>  Universal extensible repository structure.  When adding additional technology to a project, it is known in advance where the new files will be located. </li><li>  Quick search in the project file system. </li><li>  Reuse code. </li><li>  Unlimited ability to transfer the code of the entire unit from the project to the project. </li></ul><br><br>  First we tried to divide the project repository by technology: <br><br><pre> <code class="bash hljs">css/ html/ js/ xml/ xsl/</code> </pre><br><br>  This approach showed no dramatic changes.  Therefore, we brought the common part of the code, suitable for all projects and platforms, into a separate <code>common</code> directory.  Specific implementations needed only for certain projects were added separately - to the <code>service</code> directory.  And examples - in the <code>example</code> directory. <br><br><pre> <code class="bash hljs">common/ css/ js/ xml/ xsl/ example/ html/ service/ auto/ css/ xml/</code> </pre><br><br>  So we quickly found the right code for individual projects.  But this structure still did not meet all our requirements. <br><br><h4>  Blocks are primary, technologies are secondary </h4><br>  In order to create the necessary project structure for us and to realize our goals, which we set for ourselves, we brought to the forefront blocks, not technologies. <br><br>  A block in the file system is completely independent: all the technologies necessary for its implementation are located in the directory of this block. <br><br><h5>  What we have achieved: </h5><br>  <b>Acceleration development</b> <br><ul><li>  Blocks can be reused. </li><li>  The implementation of the blocks can be changed at the new level of redefinition, without affecting the basic functionality and styles. </li><li>  A block is an independent component of a page and its directory contains everything that is necessary for correct functioning.  Therefore, it is easy to transfer blocks from a project to a project; simply copy the directory of a block. </li></ul><br>  <b>Acceleration of refactoring</b> <br><ul><li>  The developer works with small blocks of code. </li><li>  Technology implementation of one unit is not related to the technology of another. </li><li>  The same repository structure allows you to quickly navigate the project and find the files you need. </li></ul><br>  <b>Universal Extensible System</b> <br><ul><li>  There are levels of overriding. </li><li>  The number of technologies is not limited.  Any new implementation technology is in the file of a specific block.  So, when we created a new file structure, we did not plan to write unit tests in JavaScript.  But when such a need arose, we knew where we would place these files in the project. </li></ul><br><br><h4>  Implementation technologies </h4><br>  Invented a new term - <b>technology implementation</b> . <br><br>  Blocks can perform different functions on the page.  Depending on the purpose of the unit, its implementation may vary.  Under the implementation in BEM understand the behavior, appearance, patterns, documentation for the unit, all types of tests, pictures, and so on. <br><br>  To implement the block, various technologies are used, for example: <br><ul><li>  behavior - javascript, coffeeScript; </li><li>  appearance - CSS, Stylus, Sass; </li><li>  templates - Jade, Handlebars, XSL, BEMHTML, BH; </li><li>  documentation - Markdown, Wiki, XML. </li></ul><br><br>  The choice of implementation technologies is not limited, unless the requirements of your project. <br><br>  In the new organization of the file structure, each implementation technology is a separate file with the appropriate extension.  All block implementation files are stored in this block directory. <br><br>  Everything in the project is rebuilt with respect to this new principle.  The block becomes the key concept of BEM.  Accordingly, the file system structure changes. <br><br><h4>  Rules for the organization of the file system of the BEM project </h4><br><ul><li>  Block - a separate directory in the file system.  The name of the block and its directory are the same. </li><li>  The implementation of the block is divided into separate files. </li><li>  Files related to a block are always in its directory. </li><li>  Optional elements and modifiers are placed in separate files. </li><li>  The project is divided into <a href="https://ru.bem.info/method/key-concepts/">override levels</a> . </li></ul><br><br>  <b>Example</b> <br><br><pre> <code class="hljs mel">blocks/ input/ #   input _theme/ #    theme input_theme_forest.css #   theme   forest   CSS __clear/ #    <span class="hljs-keyword"><span class="hljs-keyword">clear</span></span> input__clear.css #   <span class="hljs-keyword"><span class="hljs-keyword">clear</span></span>   CSS input__clear.png #   <span class="hljs-keyword"><span class="hljs-keyword">clear</span></span>   PNG input.css #  input   CSS input.js #  input   JavaScript <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>/ #   <span class="hljs-keyword"><span class="hljs-keyword">button</span></span> <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.css <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.png</code> </pre><br><br><h5>  Override Level </h5><br>  The level of overriding we began to call the directory with the implementation of blocks.  The appearance of levels allowed changing the implementation of the block, adding new properties (add) or changing old (override) at another level.  The final implementation of the block is collected from all levels sequentially. <br><br>  Override levels allow you to: <br><ul><li>  Connect libraries and update them without making changes to the code. </li><li>  Allocate the common parts of block implementations to one level, and special cases (for example, a specific implementation for individual services) to another. </li><li>  Split project into platforms.  The overall implementation for all platforms is stored on the same level, and platform-specific - to make on the other. </li><li>  Avoid copying code and creating new entities, if you need to change the already existing functionality. </li></ul><br><br>  If we compare the levels with the layers, then the base layer is the initial implementation of the block, and each subsequent layer is superimposed on top and complements (inherits) or modifies the base implementation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/9a7/157/a9f9a71573795ac5d54e513b4141a2af.png" alt="image"><br><br>  <b>Example</b> <br><br><pre> <code class="bash hljs">project/ <span class="hljs-comment"><span class="hljs-comment">#   input/ #    input button/ header/ library-blocks/ #   input/ #    input button/ popup/</span></span></code> </pre><br><br><h3>  How to start working with BEM </h3><br>  As you can see, our team also started working with BEM gradually.  The flexibility of the BEM methodology allows you to customize it for your current processes. <br><br>  There is no universal method to start applying the methodology in your project.  Each specific team embeds it in the development process and uses it as it is convenient for it. <br><br>  For example, you have a project in which you want to apply BEM only for layout.  You use CSS and HTML in your project, so you can start with the rules for naming CSS selectors.  This is the most common way to use the BEM methodology.  Many teams start with him.  We also started with this. <br><br>  As new rules are introduced, the need arises for its own tools and technologies. <br><br><h4>  BEM and technology </h4><br>  In web development, the final product consists of various technologies (for example, HTML, CSS, JavaScript).  The basic principle of the BEM methodology is to use common terms and approaches to implementation in all the technologies used. <br><br><h5>  Javascript </h5><br>  In order to work in BEM terms and write declarative JavaScript, which can be divided into redefinition levels, we needed our own framework, <a href="https://ru.bem.info/technology/i-bem/">i-bem</a> . <br><br><h5>  BEM tree </h5><br>  Typical web development boiled down to what we wrote HTML, then cut it into templates.  When you change the design, you had to change the HTML and templates manually. <br>  To get rid of manual work, we added a new level of abstraction - <b>BEM-tree</b> , which allows you to work with the structure of the web page in terms of blocks, elements and modifiers.  A BEM tree is an abstraction over a DOM tree. <br><br>  The BEM tree describes all the BEM entities that are used on the page, their states, order, nesting.  It can be expressed in any format that supports a tree structure, such as XML or JSON. <br><br>  <b>Example</b> <br><br>  Consider an example of a DOM tree: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"logo"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"search-form"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"input"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"button"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lang-switcher"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  It corresponds to the BEM-tree: <br><br><pre> <code class="bash hljs">header logo search-form input button lang-switcher</code> </pre><br><br>  It can be compared to the <a href="http://jade-lang.com/">Jade</a> template engine, but the difference is that we do not write HTML, but use abstractions. <br><br>  This BEM tree will have the following form in XML and BEMJSON formats: <br><br>  XML <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:header</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:logo</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:search-form</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:input</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:button</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:search-form</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:lang-switcher</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">block:header</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  <a href="https://ru.bem.info/technology/bemjson/">BEMJSON</a> is a JavaScript format that allows you to work in BEM terms.  BEMJSON allows you to abstract from HTML markup and describe the page in terms of blocks, elements, and modifiers. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">content</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-string"><span class="hljs-string">'logo'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-string"><span class="hljs-string">'search-form'</span></span>, <span class="hljs-attr"><span class="hljs-attr">content</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-string"><span class="hljs-string">'input'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-string"><span class="hljs-string">'button'</span></span> } ] }, { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-string"><span class="hljs-string">'lang-switcher'</span></span> } ] }</code> </pre><br><br>  We describe the page that we want to get in the browser as a BEM tree and do not write HTML with our hands: the <a href="https://ru.bem.info/technology/bemhtml/current/rationale/">BEMHTML</a> template <a href="https://ru.bem.info/technology/bemhtml/current/rationale/">engine</a> processes BEMJSON and generates HTML. <br><br><a name="tools"></a><br><h4>  BEM and tools </h4><br>  To work with all technologies in a convenient form for the developer, we divided the project into many separate files.  This gave us the advantages described above.  But we needed <a href="https://ru.bem.info/method/build/">assembly</a> and optimization that the created code could work in the browser. <br><br>  It is inconvenient to collect all files manually; we begin to automate most repetitive processes.  <a href="https://ru.bem.info/tools/bem/bem-tools">Bem-tools</a> appear - a set of tools for working with files using the BEM methodology.  Later beb-tools replaced the <a href="https://ru.bem.info/tools/bem/enb-bem/">ENB</a> . <br><br>  To be able to collect disparate files that know nothing about each other, <a href="https://ru.bem.info/technology/deps/">DEPS</a> technology is <a href="https://ru.bem.info/technology/deps/">used</a> , which indicates the dependencies of one block on another or on a set of blocks. <br><br>  The BEM tools are designed so that the developer writes the code as he likes, and the robots were engaged in optimizing and connecting only the necessary files to the project in the correct order. <br><br><h4>  BEM and libraries </h4><br>  Many BEM libraries can be found in open source.  The basic ones are: <br><br><ul><li>  <a href="https://ru.bem.info/libs/bem-core/">bem-core</a> is a basic block library that contains a javascript framework <code>i-bem</code> and 20 helper blocks for development using the BEM methodology. </li><li>  <a href="https://ru.bem.info/libs/bem-components/">bem-components</a> is a universal library of ready-made visual components (blocks).  Contains form controls and other basic components for building interfaces. </li></ul><br><br>  The bem-components library can be connected in the same way as Bootstrap: add pre-assembled library files and insert them into HTML pages using <code>link</code> and <code>script</code> elements. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://yastatic.net/bem-components/latest/desktop/bem-components.css"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://yastatic.net/bem-components/latest/desktop/bem-components.js+bemhtml.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  This delivery method is called <a href="https://ru.bem.info/libs/bem-components/v2.4.0/">Dist</a> and includes pre-assembled CSS and JavaScript code and templates.  With it, you do not need tools for assembly or template engines - the blocks are pre-assembled and work. <br><br>  How to connect files from CDN or locally, use bower or independently assemble library files from source, read in the <a href="https://ru.bem.info/libs/bem-components/current/">description of the library</a> . <br><br><h4>  Project Procurement </h4><br>  You can quickly start developing a BEM project using a <a href="https://ru.bem.info/tutorials/project-stub/">project-stub</a> project with pre-installed technologies and tools.  It is worth starting an acquaintance with him with the help of a <a href="https://ru.bem.info/tutorials/quick-start-static/">quick start on BEM</a> . <br><br>  An extended example of using the project-stub is described in the document <a href="https://ru.bem.info/tutorials/start-with-project-stub/">Creating Your Project in BEM</a> . <br><br><h3>  In conclusion </h3><br>  BEM methodology is a set of rules and recommendations for organizing work on a project. <br><br>  At some point we separated the methodology from its practical implementation - the platform. <br>  The BEM platform is a special case of the implementation of the general principles of the BEM methodology.  Since all technologies were created taking into account the requirements of our projects and developed gradually, the BEM platform most fully covers all the possibilities offered by the BEM methodology.  You can read more about it <a href="https://ru.bem.info/method">here</a> . <br><br>  All parts of the BEM platform are integrated for collaboration, but can be used separately.                . <br><br>       , .      <a href="https://ru.bem.info/built-with-b/"></a> .       . </div><p>Source: <a href="https://habr.com/ru/post/276035/">https://habr.com/ru/post/276035/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276023/index.html">Install / Update Veeam B & R v9 on Hyper-V Server</a></li>
<li><a href="../276025/index.html">SLES 12, Watchdog Timer and IBM / Lenovo Servers</a></li>
<li><a href="../276027/index.html">Debugging and Profiling in Visual Studio 2015</a></li>
<li><a href="../276031/index.html">From Phone to Cloud: Azure Mobile Services. Where to begin?</a></li>
<li><a href="../276033/index.html">BPG format can replace animated gif and not only</a></li>
<li><a href="../276037/index.html">Prime numbers: history and facts</a></li>
<li><a href="../276039/index.html">The largest hackathon in the history of software development with a prize fund of $ 140,000</a></li>
<li><a href="../276041/index.html">Updates in the service ViaLatM</a></li>
<li><a href="../276047/index.html">Backup: Google Case</a></li>
<li><a href="../276049/index.html">5 common mistakes with working with Amazon Web Services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>