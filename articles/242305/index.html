<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data Types Strike Back</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of my thoughts on ‚ÄúPython, how would I like to see it,‚Äù and in it we take a closer look at the type system. To do this, we aga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data Types Strike Back</h1><div class="post__text post__text-html js-mediator-article">  This is the second part of my thoughts on ‚ÄúPython, how would I like to see it,‚Äù and in it we take a closer look at the type system.  To do this, we again have to delve into the specifics of the implementation of the Python language and its interpreter, CPython. <br><br>  If you are a Python programmer, the data types for you are always behind the scenes.  Somewhere they exist by themselves and somehow interact with each other, but most often you think about their existence only when an error occurs.  And then the exception tells you that some of the data types behave differently than you expected. <br><br>  Python has always been proud of its type system implementation.  I remember reading the documentation many years ago, which contained a whole section on the benefits of duck typing.  Let's be honest: yes, for practical purposes duck typing is a good solution.  If you are not limited by anything and there is no need to deal with data types because of their absence, you can create very beautiful APIs.  Especially easy in Python it turns out to solve everyday problems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Practically all APIs that I implemented in Python did not work in other programming languages.  Even such a simple thing as a command line <a href="http://click.pocoo.org/">interface</a> ( <a href="http://click.pocoo.org/">click</a> library) just doesn't work in other languages, and the main reason is that you have to constantly struggle with data types. <br><br>  Not so long ago, the question of adding static typing in Python was raised, and I sincerely hope that the ice has finally broken.  I will try to explain why I am against explicit typing, and why I hope that Python will never go this way. <br><br><a name="habracut"></a><h1>  What is a "type system"? </h1>  A type system is a set of rules according to which types interact with each other.  There is a whole section of computer science devoted exclusively to data types, which in itself is impressive, but even if you are not interested in theory, it will be difficult for you to ignore the type system. <br><br>  I will not go too deep into the type system for two reasons.  Firstly, I myself do not fully understand this area, and secondly, in fact, it is not at all necessary to understand everything in order to ‚Äúfeel‚Äù the interrelationships between data types.  For me, it is important to take into account their behavior because it affects the interface architecture, and I will talk about typing not as a theorist, but as a practice (using the example of building a beautiful API). <br><br>  Type systems can have many characteristics, but the most important difference between them is the amount of information that the type of data provides about yourself when you try to work with it. <br><br>  Take, for example, Python.  There are types in it.  Here is the number 42, and if you ask this number what type it has, it will answer that it is an integer.  This is exhaustive information, and it allows the interpreter to define a set of rules according to which integers can interact with each other. <br><br>  However, there is one thing that is missing in Python: composite data types.  All data types in Python are primitive, and this means that at a certain point in time you can work with only one of them, in contrast to composite types. <br><br>  The simplest composite data type found in most programming languages ‚Äã‚Äãis structures.  In Python, there are none as such, but in many cases, libraries need to define their own structures, for example, the ORM models in Django and SQLAlchemy.  Each column in the database is represented by a Python descriptor that corresponds to a field in the structure, and when you say that the primary key is called id, and this is IntegerField (), you define the model as a composite data type. <br><br>  Composite types are not limited to structures.  When you need to work with more than one number, you use collections (arrays).  In Python, there are lists for this, and each element of the list can have a completely arbitrary data type, as opposed to lists in other programming languages ‚Äã‚Äãthat have a given element type (for example, a list of integers). <br><br>  The phrase "list of integers" always makes more sense than a list.  You can argue with that, because you can always go through the list and see the type of each element, but what to do with an empty list?  When you have an empty list in Python, you cannot determine its data type. <br><br>  The same problem occurs when using the value None.  Suppose you have a function that takes a ‚ÄúUser‚Äù argument.  If you pass the parameter None to it, you will never know that it should have been a user object. <br><br>  What is the solution to this problem?  Do not have null pointers and have arrays with explicitly specified element types.  Everyone knows that everything is in Haskell, but there are other languages ‚Äã‚Äãthat are less hostile to developers.  For example, Rust is a programming language that is closer and more understandable to us, since it is very similar to C ++.  And in Rust there is a very powerful type system. <br><br>  How can you pass the value "user not set" if there are no null pointers?  For example, in Rust, there are optional types for this.  So, the Option expression is a flagged enumeration that wraps the value (of a particular user in this case), and it means that either Some (user) or None can be transferred.  Since now a variable can either have a value or not have it, all the code working with this variable must be able to correctly handle cases of passing None, otherwise it will not compile. <br><br><h1>  Gray future </h1>  Previously, there was a clear separation between interpreted languages ‚Äã‚Äãwith dynamic typing and compiled languages ‚Äã‚Äãwith static typing.  New trends change the current rules of the game. <br><br>  The first sign that we are stepping onto uncharted territory is the appearance of the C # language.  This is a compiled language with static typing, and at first it was very similar to Java.  As C # developed, new features began to appear in its type system.  The most important event was the emergence of generalized types, which made it possible to strictly typify collections that are not processed by the compiler (lists and dictionaries).  Further - more: the creators of the language have introduced the ability to abandon the static typing of variables for entire blocks of code.  This is very convenient, especially when working with data provided by web services (JSON, XML, etc.), because it allows you to perform potentially unsafe operations, catch exceptions from the type system and inform users about incorrect data. <br><br>  Nowadays, the C # type type system is very powerful and supports generic types with covariant and contravariant specifications.  It also supports working with types that allow null pointers.  For example, in order to define default values ‚Äã‚Äãfor objects represented as null, a union statement with the value null ("??") was added.  Although C # has already gone too far to get rid of null, all bottlenecks are under control. <br><br>  Other compiled languages ‚Äã‚Äãwith static typing also try new approaches.  Thus, in C ++, it has always been a language with static typing, but its developers have begun experiments with type deduction at many levels.  The days of MyType &lt;X, Y&gt; :: const_iterator iterators are a thing of the past, and now in almost all cases you can use autotypes, and the compiler will substitute the necessary data type for you. <br><br>  In the Rust programming language, type inference is also very well implemented, and this allows you to write programs with static typing without specifying the types of variables at all: <br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> m = HashMap::new(); m.insert(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-string"><span class="hljs-string">"tags"</span></span>, <span class="hljs-string"><span class="hljs-string">"here"</span></span>]); m.insert(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-string"><span class="hljs-string">"more"</span></span>, <span class="hljs-string"><span class="hljs-string">"here"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, values) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> m.iter() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{} = {}"</span></span>, key, values.connect(<span class="hljs-string"><span class="hljs-string">"; "</span></span>)); } }</code> </pre> <br>  I believe that in the future we expect the emergence of powerful type systems.  But in my opinion, this will not lead to the end of dynamic typing; rather, these systems will evolve along the path of static typing with local type inference. <br><br><h1>  Python and explicit typing </h1>  Some time ago at one of the conferences, someone convincingly argued that static typing is great and the Python language is extremely necessary.  I don‚Äôt remember exactly how this discussion ended, but the result was a project called mypy, which, in conjunction with the syntax of annotations, was proposed as the gold typing standard in Python 3. <br><br>  In case you have not seen this recommendation, she suggests the following solution: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> List <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_all_usernames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(users: List[User])</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> users: print(user.username)</code> </pre><br>  I am sincerely convinced that this is not the best solution.  There are many reasons, but the main problem is that the type system in Python is, unfortunately, not so good.  In essence, a language has different semantics depending on how you look at it. <br><br>  For static typing to make sense, the type system must be implemented well.  If you have two types, you should always know how these types need to interact with each other.  In Python, this is not the case. <br><br><h1>  Python Type Semantics </h1>  If you read the previous article about the system of slots, you should remember that types in Python behave differently, depending on the level at which they are implemented (C or Python).  This is a very specific feature of the language and this you will not see anywhere else.  At the same time, at an early stage of development, many programming languages ‚Äã‚Äãimplement fundamental data types at the interpreter level. <br><br>  In Python, there are simply no ‚Äúfundamental‚Äù types, however there is a whole group of data types implemented in C. And these are not only primitives and fundamental types, it can be anything, without any logic.  For example, the collections.OrderedDict class is written in Python, and the collections.defaultdict class from the same module is written in C. <br><br>  This gives a lot of problems to the PyPy interpreter, for which it is important to emulate the original types as well as possible.  This is necessary in order to get a good API, in which any differences with CPython will not be noticeable.  It is very important to understand what the main difference is between the level of the interpreter written in C and the rest of the language. <br><br>  Another example is the re module in versions of Python up to 2.7.  In later versions, it was completely rewritten, but the main problem is still relevant: the interpreter does not work like a programming language. <br><br>  In the re module, there is a compile function for compiling a regular expression into a pattern.  This function takes a string and returns a pattern object.  It looks like this: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>re.compile(<span class="hljs-string"><span class="hljs-string">'foobar'</span></span>) &lt;_sre.SRE_Pattern object at <span class="hljs-number"><span class="hljs-number">0x1089926b8</span></span>&gt;</code> </pre><br>  We see that the pattern object is specified in the _sre module, which is an internal module, and yet it is available to us: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>type(re.compile(<span class="hljs-string"><span class="hljs-string">'foobar'</span></span>)) &lt;type <span class="hljs-string"><span class="hljs-string">'_sre.SRE_Pattern'</span></span>&gt;</code> </pre><br>  Unfortunately, this is not the case, because the _sre module does not actually contain this object: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _sre &gt;&gt;&gt; _sre.SRE_Pattern Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'SRE_Pattern'</span></span></code> </pre><br>  Well, this is not the first or the only time when a type deceives us about its location, and in any case it is an internal type.  Moving on.  We know the type of the pattern (_sre.SRE_Pattern), and this is a descendant of the object class: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(re.compile(<span class="hljs-string"><span class="hljs-string">''</span></span>), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  We also know that all objects implement some of the most common methods.  For example, instances of such classes have a __repr__ method: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>re.compile(<span class="hljs-string"><span class="hljs-string">''</span></span>).__repr__() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AttributeError: __repr__</code> </pre><br>  What is going on?  The answer is rather unexpected.  For reasons unknown to me, in Python prior to version 2.7, the SRE pattern object had its own tp_getattr slot.  This slot has implemented its own attribute search logic, which provided access to its own attributes and methods.  If you examine this object using the dir () method, you will notice that many things are simply missing: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dir(re.compile(<span class="hljs-string"><span class="hljs-string">''</span></span>)) [<span class="hljs-string"><span class="hljs-string">'__copy__'</span></span>, <span class="hljs-string"><span class="hljs-string">'__deepcopy__'</span></span>, <span class="hljs-string"><span class="hljs-string">'findall'</span></span>, <span class="hljs-string"><span class="hljs-string">'finditer'</span></span>, <span class="hljs-string"><span class="hljs-string">'match'</span></span>, <span class="hljs-string"><span class="hljs-string">'scanner'</span></span>, <span class="hljs-string"><span class="hljs-string">'search'</span></span>, <span class="hljs-string"><span class="hljs-string">'split'</span></span>, <span class="hljs-string"><span class="hljs-string">'sub'</span></span>, <span class="hljs-string"><span class="hljs-string">'subn'</span></span>]</code> </pre><br>  This small study of the behavior of the pattern object leads us to rather unexpected results.  This is what actually happens. <br><br>  The data type declares that it is inherited from object.  This is true in CPython, but not in Python itself.  At the Python level, this type is not associated with an object type interface.  Every call that passes through the interpreter will work, unlike calls that pass through the Python language.  So, for example, type (x) will work, and x .__ class__ will not. <br><br><h1>  What is subclass </h1>  The above example shows us that in Python there may be a class that inherits from another class, but its behavior will not correspond to the base class.  And this is an important issue if we are talking about static typing.  So, in Python 3, you cannot implement an interface for the type dict until you write it to C. The reason for this restriction is that this type dictates behavior that can not be implemented to visible objects.  It's impossible. <br><br>  Therefore, when you use type annotation and declare that a function takes a dictionary as an argument with keys as strings and values ‚Äã‚Äãas integers, it will be impossible to understand from your annotation whether this function accepts a dictionary, or an object with a dictionary behavior, or will pass the dictionary subclass. <br><br><h1>  Undefined behavior </h1>  The strange behavior of the regular expression pattern object was changed in Python 2.7, but the problem remained.  As shown by the example of dictionaries, the language behaves differently, depending on how the code is written, and it is simply impossible to fully understand the exact semantics of the type system. <br><br>  The very strange behavior of the internals of the interpreter of the second version of Python can be seen when comparing types of class instances.  In the third version, the interfaces have been changed, and this behavior is no longer relevant for it, but the fundamental problem can still be detected at many levels. <br><br>  Let's take as an example the sorting of sets (set).  Python sets are a very useful data type, but they behave very strangely when comparing.  In Python 2, we have a cmp () function that takes two objects as arguments and returns a numeric value that indicates which of the arguments passed is greater. <br><br>  Here's what happens if you try to compare two instances of a set object: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>cmp(set(), set()) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: cannot compare sets using cmp()</code> </pre><br>  Why is that?  To be honest, I have no idea.  Perhaps the reason is how the comparison operators work with sets, and this does not work in cmp ().  And at the same time, instances of frozensets objects are remarkably compared: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>cmp(frozenset(), frozenset()) <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Except for those cases when one of these sets is not empty, then we will again get an exception.  Why?  The answer is simple: it is the optimization of the CPython interpreter, and not the behavior of the Python language.  An empty frozenset always has the same value (it is an immutable type and we cannot add elements to it), therefore it is always the same object.  When two objects have the same address in memory, the cmp () function immediately returns 0. Why this happens I could not figure out right away, since the code of the comparison function in Python 2 is too complicated and confusing, however this function has several ways which can lead to this result. <br><br>  The point is not only that this is a bug.  The point is that in Python there is no clear understanding of the principles of the interaction of types with each other.  Instead, there was always one answer to all the features of the type system behavior in Python: ‚Äúthis is how CPython works‚Äù. <br><br>  It is difficult to overestimate the amount of work that was done in PyPy to reconstruct the behavior of CPython.  Given that PyPy is written in Python, an interesting problem emerges.  If the Python programming language were described in the way the current Python part of the language is implemented, PyPy would have far fewer problems. <br><br><h1>  Instance level behavior </h1>  Now let's imagine that we, hypothetically, have a version of Python in which all the problems described are fixed.  Even in this case, we cannot add static types to the language.  The reason is that at the Python level, types do not play a significant role, much more important is how objects interact with each other. <br><br>  For example, datetime objects, in general, can be compared with other objects.  But if you want to compare two datetime objects with each other, then this can be done only if their timezone is compatible.  Also, the result of many operations can be unpredictable until you carefully examine the objects involved in them.  The result of concatenating two strings in Python 2 can be either unicode or bytestring.  Different encoding or decoding APIs from a codec system can return different objects. <br><br>  Python, as a language, is too dynamic for type annotations to work well.  Just imagine the important role that generators play in the language, and they can perform many type conversion operations in each iteration. <br><br>  The introduction of type annotations will, at best, have an ambiguous effect.  However, it is more likely that this will adversely affect the API architecture.  At a minimum, if these annotations are not cut before the programs are launched, they will slow down the execution of the code.  Type annotations will never allow efficient static compilation to be implemented without turning Python into something that Python is not. <br><br><h1>  Luggage and semantics </h1>  I think my personal negative attitude towards Python was due to the absurd complexity that this language has reached.  It simply lacks specifications, and today the interaction between types has become so confusing that we may never be able to figure it all out.  There are so many crutches and all these small behavioral features in it that the only possible specification of the language today is a detailed description of the work of the CPython interpreter. <br><br>  In my opinion, in view of the foregoing, the introduction of type annotations has almost no sense. <br><br>  If anyone in the future wants to develop a new programming language with predominantly dynamic typing, they should spend extra time on a clear description of how the type system should work.  In JavaScript, this is done quite well, all semantics of built-in types are described in detail, even in cases where it does not make sense, and this is good practice in my opinion.  If you have clearly defined how the semantics of the language works, in the future it will be easy for you to optimize the speed of the interpreter or even add an optional static typing. <br><br>  Maintaining a slim and well-documented language architecture avoids many problems.  Architects of future programming languages ‚Äã‚Äãshould definitely avoid all the mistakes that were made by developers of PHP, Python and Ruby, when the behavior of the language is ultimately explained by the behavior of the interpreter. <br><br>  I believe that Python is unlikely to change for the better.  It takes too much time and effort to rid the language of all this heavy heritage. <br><br>  <em>Translated <a href="https://habrahabr.ru/users/dreadatour/" class="user_link">Dreadatour</a> , text read <a href="https://habrahabr.ru/users/dreadatour/" class="user_link">%%</a> username.</em> </div><p>Source: <a href="https://habr.com/ru/post/242305/">https://habr.com/ru/post/242305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242289/index.html">The Queen of the click: the story of the most outstanding keyboard in history</a></li>
<li><a href="../242293/index.html">Three things forgotten by beginner conversion optimizers</a></li>
<li><a href="../242295/index.html">First week report at Oxygen Accelerator</a></li>
<li><a href="../242297/index.html">Announcement Brackets 1.0 and Extract for Brackets (Preview version)</a></li>
<li><a href="../242301/index.html">Nexus 5 + javascript + 48 hours = touch surface?</a></li>
<li><a href="../242307/index.html">Open Terminal Client OTC-110 - news "November 2014"</a></li>
<li><a href="../242309/index.html">Optimization for beginners, or the benefits of profiling</a></li>
<li><a href="../242311/index.html">Captain America vs VirtualSurfaceImageSource</a></li>
<li><a href="../242313/index.html">ProductCamp Minsk 2014 - video and conference review</a></li>
<li><a href="../242315/index.html">Projector on the knee</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>