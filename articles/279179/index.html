<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bot for Telegram. Rails way</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is about a telegram-bot library for writing Telegram bots. Among its main objectives in its creation were ease of development, debugging and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bot for Telegram. Rails way</h1><div class="post__text post__text-html js-mediator-article">  This post is about a <a href="https://github.com/telegram-bot-rb/telegram-bot">telegram-bot</a> library for writing Telegram bots.  Among its main objectives in its creation were ease of development, debugging and testing bots, keeping the interfaces minimal, but extensible, easy to integrate with a Rails application, and providing the necessary tools for writing a bot.  Here is what is included: <br><br><ul><li>  Lightweight client API bot. </li><li>  Base class for update controller with message parser.  Made on the basis of AbstractController from ActionDispatch, provides callbacks, sessions, saving the context of messages, and more. </li><li>  Rack-middleware for production to accept update-hooks, and poller with automatic downloading of updated code for convenient development. </li><li>  Rake taskki, helpers for rail routes and tests. </li></ul><br>  Interesting?  To install, add a <code>telegram-bot</code> to the <code>Gemfile</code> , details under the cat. <br><a name="habracut"></a><br><h2>  Client to bot-api </h2><br>  Creating a client is simple: <code>Telegram::Bot::Client.new(token, username)</code> .  The <code>username</code> value is optional and is used for parsing commands with hits ( <code>/cmd@BotName</code> ) and in the session key prefix in the Key-Value store. <br><br>  The base client method is <code>request(path_suffix, body)</code> , for all commands from the documentation there are shortcuts in the Ruby style - with underscores ( <code>.send_message(body)</code> , <code>answer_inline_query(body)</code> ).  All these methods simply perform POST with the passed parameters to the desired URL.  The files in the <code>body</code> will be automatically transferred with <code>multipart/form-data</code> , and the nested hashes are encoded in json, as documentation requires. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="ruby hljs">bot.request(<span class="hljs-symbol"><span class="hljs-symbol">:getMe</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> bot.get_me bot.request(<span class="hljs-symbol"><span class="hljs-symbol">:getupdates</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">offset:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> bot.get_updates(<span class="hljs-symbol"><span class="hljs-symbol">offset:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) bot.send_message <span class="hljs-symbol"><span class="hljs-symbol">chat_id:</span></span> chat_id, <span class="hljs-symbol"><span class="hljs-symbol">text:</span></span> <span class="hljs-string"><span class="hljs-string">'Test'</span></span> bot.send_photo <span class="hljs-symbol"><span class="hljs-symbol">chat_id:</span></span> chat_id, <span class="hljs-symbol"><span class="hljs-symbol">photo:</span></span> File.open(photo_filename)</code> </pre> <br>  Out of the box, the client will return the usual distributed json to each request.  You can use the <code>telegram-bot-types</code> and get a virtus model at the output: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#   Gemfile: gem 'telegram-bot-types', '~&gt; xxx' #  typecasting   : Telegram::Bot::Client.typed_response! #    : bot.extend Telegram::Bot::Client::TypedResponse bot.get_me.class # =&gt; Telegram::Bot::Types::User</span></span></code> </pre> <br><h2>  Customization </h2><br>  Gem adds methods to the <code>Telegram</code> module to configure and access common clients for the application (they are thread-safe, there will be no problems with multiple threads): <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#   Telegram.bots_config = { #     default: 'bot_token', #    username chat: { token: 'other_token', username } } #     : Telegram.bots[:chat].send_message(params) Telegram.bots[:default].send_message(params) #  :default    (,   ): Telegram.bot.get_me</span></span></code> </pre> <br>  For Rails applications, you can do without manual configuration of <code>bots_config</code> , the config will be read from <code>secrets.yml</code> : <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">development</span></span>: telegram: bots: chat: <span class="hljs-type"><span class="hljs-type">TOKEN_1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: token: <span class="hljs-type"><span class="hljs-type">TOKEN_2</span></span> username: <span class="hljs-type"><span class="hljs-type">ChatBot</span></span> #     bots.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> bot: token: <span class="hljs-type"><span class="hljs-type">TOKEN</span></span> username: <span class="hljs-type"><span class="hljs-type">SomeBot</span></span></code> </pre> <br><h2>  Controllers </h2><br>  To handle updates in geme there is a base controller class.  As in <code>ActionController</code> , all public methods are used as action methods for processing commands.  That is, if the message comes <code>/cmd arg 1 2</code> , then the method <code>cmd('arg', '1', '2')</code> will be called (if it is defined and public).  Unlike ActionController, if an unsupported command arrives, it is simply ignored, without ActionMissing errors. <br><br>  The controller is able to handle commands with references.  If such comes, then the name from the command is compared with the bot's <code>username</code> .  In the case of a match, the command is executed, otherwise the message is processed as normal text. <br><br>  To process other updates (not messages), you must also define public methods with the name from the name of the update type (there are 3 of them available now: `message, inline_query, chosen_inline_result ').  These methods take as an argument the corresponding object from the update. <br><br>  To respond to the incoming notification, there are helpers <code>reply_with(type, params)</code> and <code>answer_inline_query(results, params)</code> , which set the recipient and other fields from the incoming update. <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TelegramWebhookController</span></span></span><span class="hljs-class"> &lt; Telegram::Bot::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatesController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reply_with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">: "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Echo</span></span></span><span class="hljs-class">: </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#{message['text']}" end def start(*) #    chat  from: reply_with text: "Hello #{from['username']}!" if from #        payload: log { "Started at: #{payload['date']}" } end #       splat-  #  -,       #    ,     . def help(cmd = nil, *) message = if cmd help_for_cmd?(cmd) ? t(".cmd.#{cmd}") : t('.no_help') else t('.help') end reply_with text: message end end</span></span></span></span></code> </pre> <br>  Most likely the bot will need to remember the chat status between messages.  To do this, the controller can use the session.  The interface is similar to the session interface in ActionController, the difference in storage method.  As an adapter, you can use any ActiveSupport :: Cache-compatible storage ( <code>redis-activesupport</code> , for example). <br><br>  By default, this value is used as the session ID (it can be changed by overriding the method): <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">session_key</span></span></span><span class="hljs-function"> "</span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{bot.username}:#{from ? "from:#{from['id']}" : "chat:#{chat['id']}"}" end</span></span></span></span></code> </pre> <br>  Using sessions, you can implement a message context ‚Äî support for commands sent in several messages: the user sends a command without arguments, the bot specifies which arguments he expects, and the user sends them in the next message (s) (as does BotFather, for example).  Such functionality is available in the <code>Telegram::Bot::UpdatesController::MessageContext</code> : <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TelegramWebhookController</span></span></span><span class="hljs-class"> &lt; Telegram::Bot::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatesController</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Telegram::Bot::UpdatesController::MessageContext</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rename</span></span></span><span class="hljs-class">(*) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#     : save_context :rename reply_with :message, text: 'What name do you like?' end #     : context_handler :rename do |message| update_name message[:text] reply_with :message, text: 'Renamed!' end #   -.  rename,      #   . def rename(name = nil, *) if name update_name name reply_with :message, text: 'Renamed!' else #    ,   : save_context :rename reply_with :message, text: 'What name do you like?' end end #          ,    . #      ,   ,     #  '/rename %text%' context_handler :rename #    ,  : context_to_action! #              . end</span></span></span></span></code> </pre> <br><h2>  Application integration </h2><br>  The controller can be used in several versions: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#   : ControllerClass.dispatch(bot, update) #   ,  . controller = ControllerClass.new(bot, from: telegram_user, chat: telegram_chat) controller.process(:help, *args)</span></span></code> </pre> <br>  There is a Rack-endpoint for handling hooks.  Rails applications have route helpers: a bot token will be used as a path suffix.  When using a single bot in an application, add: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># routes.rb telegram_webhooks Telegram::WebhookController</span></span></code> </pre> <br>  Using this helper allows you to <code>setWebhook</code> for bots, using the resulting URL, using the task: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">rake</span></span> telegram:bot:set_webhook RAILS_ENV=production</code> </pre> <br><h2>  Testing </h2><br>  In the game there is a <code>Telegram::Bot::ClientStub</code> to replace the API clients in the tests.  Instead of executing requests, it saves them in the <code>#requests</code> hash.  To stop all created clients and not to send requests to Telegram during the execution of tests, you can write this: <br><br><pre> <code class="ruby hljs">RSpec.configure <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|config|</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... Telegram.reset_bots Telegram::Bot::ClientStub.stub_all! config.after { Telegram.bot.reset } # ... end</span></span></code> </pre> <br>  There are helpers for testing controllers in the same way as ActionController: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'telegram/bot/updates_controller/rspec_helpers'</span></span> RSpec.describe TelegramWebhookController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> include_context <span class="hljs-string"><span class="hljs-string">'telegram/bot/updates_controller'</span></span> describe <span class="hljs-string"><span class="hljs-string">'#rename'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { -&gt; { dispatch_message <span class="hljs-string"><span class="hljs-string">"/rename </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{new_name}</span></span></span><span class="hljs-string">"</span></span> } } let(<span class="hljs-symbol"><span class="hljs-symbol">:new_name</span></span>) { <span class="hljs-string"><span class="hljs-string">'new_name'</span></span> } it { should change { resource.reload.name }.to(new_name) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2>  Development and debugging </h2><br>  For local debugging, you can run an update poller.  To do this, you will most likely need to create a separate bot.  <code>rake telegram:bot:poller</code> will launch a poller.  It will automatically download code updates when processing updates, there is no need to restart the process. <br><br>  The source code and more detailed description are available on <a href="https://github.com/telegram-bot-rb/telegram-bot">github</a> . <br><br>  Pleasant development! <br></div><p>Source: <a href="https://habr.com/ru/post/279179/">https://habr.com/ru/post/279179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279169/index.html">Announcement of the .NET conference DotNext 2016 Piter</a></li>
<li><a href="../279171/index.html">Preview of email sent from Laravel</a></li>
<li><a href="../279173/index.html">Create passwordless authentication in Laravel using only email</a></li>
<li><a href="../279175/index.html">The second mystery of Mars</a></li>
<li><a href="../279177/index.html">‚ÄúES7‚Äù is the wrong name for JavaScript development plans.</a></li>
<li><a href="../279181/index.html">Live migration of Docker containers between clouds</a></li>
<li><a href="../279185/index.html">Review of the book scanner Qidenus SMART book scan 3.0 in the Odessa city archive</a></li>
<li><a href="../279187/index.html">Ixia released intelligent network packet broker - Vision ONE</a></li>
<li><a href="../279189/index.html">Do I need a microscope when connecting ‚Äúpatchcords‚Äù?</a></li>
<li><a href="../279193/index.html">What to read about promising programming languages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>