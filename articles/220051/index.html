<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>One opinion on the future of PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, there has been a very lively discussion in the developer community about everything that concerns PHP and its future. What pleases - most of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>One opinion on the future of PHP</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/49b/b46/0c1/49bb460c1f1423fa5fee401d46c91de7.jpg"><br><br>  Recently, there has been a very lively discussion in the developer community about everything that concerns PHP and its future.  What pleases - most of these conversations are held in a positive way.  Discussions on PHP 6 and what it might look like are popular.  People ask a lot of questions about HHVM and its role in the future of the language and community.  So let me share with you some of my thoughts on this. <br><br><a name="habracut"></a><br><h5>  Backward compatibility </h5><br>  I believe that each subsequent release is <b>obliged to</b> maintain backward compatibility with the previous one: 6, 7, 99, ‚Äúelephant enthusiast‚Äù - call it what you like.  And now I will say "mostly", since some incompatibilities will still occur.  But these incompatibilities must be justified and controlled.  They should also be directed only at revising the behavior of borderline cases and all that.  Although this does not mean that there can not be a serious internal reorganization and striving for purity and simplicity of things.  This means that incompatibilities should not put obstacles in the way of developers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This approach is very easy to verify: <br><br><blockquote>  The code you write should run without problems on both PHP 5.x and PHP 6.x (and any two consecutive major releases). </blockquote><br><br>  Why is it important?  Take a look at the transition from PHP 4 to PHP 5. It was fairly easy for programmers to write code that worked on both versions, although the final transition to PHP 5 took about 10 years.  And imagine if it was difficult to do? <br><br>  Although, as it turns out, nothing is needed.  This is exactly what happened with Python.  The first release of Python 3 was released about 5 years ago.  And today, in 2014, he is still not involved to the fullest.  Not because it is bad, but because it is very difficult to use a single code that would work without problems on both versions.  That is, you use either Python 2 or its functionality that will work in Python 3 (as a result, losing the advantages of both).  And if the libraries or platforms you need do not have a version for Python 3, you need to either port them yourself, or well ... you just have no luck.  In fact, that's exactly what happens. <br><br>  I do not want to say that this approach is wrong: the language acquires a million different advantages from such changes.  But, as it seems to me, for the community and the average user such a transition is still unnecessarily cardinal. <br><br><h5>  About rewriting the engine </h5><br>  Many people say: you need to rewrite the PHP engine.  Despite the fact that I definitely see this as a plus (yes, the engine is very intricate), I have to ask the question: is this really so necessary?  Where is the fundamental dog buried?  Undoubtedly, the PHP engine has architectural flaws, but by and large it works well. <br><br>  So I would prefer to see the transition of the engine to the component basis, its division into subsystems.  Today it is already partially done.  But I would like to see changes that would make the engine truly component.  Why is it important?  Because with this approach, individual improvements will be able to make a significant contribution to the development of the engine. <br><br>  For example, at the moment the most confusing part of PHP is the parser and compiler.  They are so closely related and confused that it leads to a lot of problems in development.  On the other hand, if they were separate components of the engine, then that parser, that the compiler would be much easier to replace.  And their common part could be some kind of Abstract Syntax Tree.  Why AST?  Because this is a kind of general idea that both components could use.  Yes, it would take a lot and a lot of work on this, but the advantages would not keep you waiting: from a consistent and more predictable syntax to adding the ability to define your own syntax using PHP itself (imagine the ability to define DSL in PHP, which are actually part of language). <br><br>  So there is no need to rewrite.  Refactor and mop up. <br><br><h5>  On the transition of the standard library to the object-oriented approach </h5><br>  Some people suggest moving the standard PHP library to an object-oriented approach: even scalar types would have object behavior.  So you could write something like this: <br><br><pre><code class="php hljs">$string = <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>; var_dump($string-&gt;length); <span class="hljs-comment"><span class="hljs-comment">// 3 var_dump($string-&gt;toLower()); // string(3) "foo" // etc</span></span></code> </pre> <br><br>  I do not think that this <i>needs to</i> happen, although, I confess, it sounds cool. <br><br>  The reason is simple: scalars are not objects.  But, most importantly, they do not belong to any type at all.  PHP relies on a type system that considers strings to be integers.  The flexibility of the system also lies in the fact that any scalar type can easily be converted to another scalar type.  Of course, this is not always good, because of this a very large number of errors occur. <br><br>  However, such situations could be resolved by more specific behavior.  For example, you could throw a warning or an exception to be thrown when trying to "dirty" type conversions, so if someone tried to convert "123abc" to an integer, you would get a message about partial data loss. <br><br>  More importantly, with such a type system, you cannot know 100% what type a variable has at a given time.  You can assume various options, but what is really there is not known.  The situation will not change very much even after type casting or if the language will support scalar type hints, since these types can still be changed later. <br><br>  Thus, all this means that with the object-oriented approach, all scalar operations had to be tied to all scalar types.  That would lead to an object model in which scalars would have not only mathematical methods, but also methods for working with strings.  What kind of nonsense ... <br><br><h5>  HHVM formation </h5><br>  Today, at the time of this writing, I do not recommend using HHVM in production.  There are several reasons for this.  They are all known and not fundamental.  Time will tell if they can be solved, but I really hope so. <br><br><ol><li>  HHVM is controlled by one company.  Do not get me wrong, the problem is not that Facebook spends a lot of money on development.  But the fact that the project is controlled by a company whose business does not depend on whether you use HHVM or not.  It‚Äôs one thing if they provided paid support and made HHVM a complete product.  Another is that now it is neither an open source project, nor a commercial project - something in between.  And I would be very tense, translating production to HHVM in such a situation. </li><li>  HHVM does not have a public specification, that is, in general, you will program in the same way as under the Zend engine.  However, this is a trial and error method, since everything will be fine as long as you do not try to support multiple implementations.  As a library developer, I already felt it the hard way.  On the other hand, if HHVM and PHP ended up with some kind of general specification, many things would be <i>much</i> simpler ... </li><li>  HHVM is a closed source project, although it accepts code from third-party developers (already good).  However, the flow of pull requests and patches does not produce an open source project.  Well, where is the clarity of the process?  Where is the clarity of perspective?  Where is the openness of participation?  Where is the lead? </li></ol><br><br>  At the same time, I know that I am not alone in my judgments.  HHVM will be a strong contender in the future, but I believe that while the above issues are not resolved, the time for HHVM in commercial production has not come. <br><br><h5>  Can PHP and HHVM coexist? </h5><br>  Naturally.  Although some tests look convincing, JIT compilers are not magic.  They make compromises with this our real world: many tests reveal this.  Well, in fact, if you look closely at the vast majority of tests, you will notice that they do not execute the ‚Äúreal‚Äù code.  Stop-stop, so you are still comparing the performance of HelloWorld or the Fibonacci number generator?  Well, good luck to you, just calm down now, please, and throw out all these useless results. <br><br>  Let me repeat that tests that do not use real systems are useless: this is nonsense and even worse - they are simply dangerous. <br><br>  In practice, there are tasks that HHVM can do much faster than PHP.  But at the same time, there are tasks where PHP will show its speed.  The only way to test is to test your application. <br><br>  <b>But HHVM executes my code as native!</b>  <b>How can PHP be faster?</b> <br>  Remember, I said that JIT is not magic?  So, this is actually the case.  You cannot compile PHP directly because it is an interpreted programming language.  Which means that you can‚Äôt know which code is in the compilation queue until exactly as you don‚Äôt execute this code.  So JIT does just that.  It analyzes the executable code and, having received sufficient information about it, generates a native code.  This process is not free of costs, because of this HHVM is slow in the console. <br><br>  More importantly, the JIT does not generate generic code.  It generates code in accordance with the conditions that existed at the time of the creation of this code.  So, if your function adds two integers, then such code could be compiled into a simple add instruction.  However, the compiler will also add instructions for checking parameters on an integer type.  And if then you transfer to your function not a number (which is normal from the standpoint of PHP), one of the checks will give a false result. <br><br>  When the check gives a false result, something like a ‚Äúfailover‚Äù occurs.  Simply put, the engine will ‚Äúcancel‚Äù everything that has been compiled for this method and will switch to interpreter mode.  Such an operation is much more expensive than a permanent job in the interpreter mode. <br><br>  And this is just one reason why JIT compilers are not magic. <br><br>  I don‚Äôt want you to think now that I‚Äôm against JIT compilers.  On the contrary, for most tasks, they will show a significant increase in productivity.  But still they are not perfect. <br><br>  Look at other communities and you will see implementations of virtual machines along with JIT compilers.  CPython and PyPy are good examples of this.  It is also worth noting that Python has a language specification, so you can easily change one implementation to another. <br><br>  <b>But HACK is cool!</b> <br>  Hack is a new programming language developed by Facebook and included in HHVM.  Roughly speaking, this is a statically typed version of PHP with some additional features ... <br><br>  And Hack is awesome!  I really want the HHVM problems I identified to be somehow resolved, and I could contribute! <br><br>  After all, this is an interesting idea.  Now there are several meta languages ‚Äã‚Äãbuilt on the basis of PHP.  Leaders - Hack and Zephir.  But there is a problem.  Both are designed for a specific runtime environment: Hack runs on HHVM, and Zephir runs on PHP.  How to solve this? <br><br>  Honestly, I would just throw Zephir and build a compiler from Hack to PECL.  Since Hack is a statically typed language, there must be the possibility of cross-compiling between Hack and PECL.  And given that Hack already supports C ++ bindings (for connecting system libraries), theoretically the compiler should handle this as well.  In this case, there would be no point in writing the PECL extension.  You would write your extension on Hack (which has static code analyzers, debuggers), and would generate a 100% compatible PECL extension.  This thing, of course, is very nontrivial in implementation, but it would be great to try this!  Here, by the way, is another argument in favor of the language specification. <br><br><h5>  About language specification </h5><br>  You, probably, noticed that I have already mentioned several times in the text about the need to specify a language ... <br>  I hint that this is the most important thing that would help improve the future of PHP as a language, platform, ecosystem and community. <br><br><h5>  Summing up </h5><br>  PHP is entering a very interesting phase of its development.  People write cool stuff, move progress.  So if we want further growth of PHP, I think we should be very well aware of what we are doing by making this or that choice. <br></div><p>Source: <a href="https://habr.com/ru/post/220051/">https://habr.com/ru/post/220051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220037/index.html">Ruby on Rails Developer Competency Matrix</a></li>
<li><a href="../220041/index.html">Family stories, dining table and sales growth</a></li>
<li><a href="../220043/index.html">MetaPhone: the importance of phone metadata</a></li>
<li><a href="../220045/index.html">Practical Robotics Video Course on Lego NXT</a></li>
<li><a href="../220049/index.html">Lessons from space accidents: the defeat and triumph of "Apollo 13"</a></li>
<li><a href="../220053/index.html">Toy for Arduino: Tuk-tuk locker</a></li>
<li><a href="../220057/index.html">Simple Science - Digest Experiences # 31</a></li>
<li><a href="../220059/index.html">7 hidden gadgets</a></li>
<li><a href="../220061/index.html">Print and play sound on paper</a></li>
<li><a href="../220065/index.html">Useful materials for mobile developer # 49 (April 14-20)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>