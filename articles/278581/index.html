<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>History of Chatto</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our chat is outdated: for several years of evolution, it has become a cumbersome View Controller with strange fixes that no one could figure out. It b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>History of Chatto</h1><div class="post__text post__text-html js-mediator-article">  Our chat is outdated: for several years of evolution, it has become a cumbersome View Controller with strange fixes that no one could figure out.  It became difficult to add new types of messages, but new bugs appeared with ease.  Therefore, we decided to rewrite the chat to Swift from scratch and put it in <a href="https://github.com/badoo/Chatto">open source</a> . <br>  We began work on the project, setting two goals: <br><ul><li>  <b>scalable architecture</b> : we needed the ability to easily add new message types without sacrificing previously written code; </li><li>  <b>good performance</b> : we wanted to ensure smooth loading and scrolling of messages. </li></ul><br>  This article will describe in more detail how we achieved our goals, what methods were used and what we got in the end.  On our <a href="https://github.com/badoo/Chatto">page on GitHub there</a> is a fairly detailed description of the application architecture. <br><br><img src="https://habrastorage.org/files/67b/c7f/f27/67bc7ff27b1b4b5e8adbb6ecf5fe68ae.png"><br><a name="habracut"></a><br><h2>  Which is better: UICollectionView or UITableView? </h2><br>  UITableView was used in our old chat.  It is quite good, but UICollectionView offers a richer API with more options for customizations ( <a href="https://www.objc.io/issues/12-animations/collectionview-animations/">animation</a> , <a href="https://www.objc.io/issues/5-ios7/collection-views-and-uidynamics/">UIDynamics</a> , etc.) and optimization (UICollectionViewLayout and UICollectionViewLayoutInvalidationContext). <br>  Moreover, we <a href="http://petersteinberger.com/blog/2013/how-to-inspect-the-view-hierarchy-of-3rd-party-apps/">studied</a> several already existing chat applications and it turned out that they all use UICollectionView.  Therefore, the decision in favor of choosing a UICollectionView was self-evident. <br><br><h2>  Text messaging </h2><br>  No chat can do without clouds with text.  In truth, in terms of performance, it is the most difficult to implement exactly this type of message, since text rendering and scaling is slow.  We wanted the chat to automatically detect links and perform regular actions, as iMessage does. <br>  UITextView initially has support for all these requirements, so there is no need to write a single line of code for link processing.  Therefore, we chose this class, but this solution has become a source of problems for us.  Next we will tell why. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Auto Layout and Self-Sizing Cells </h2><br>  Layout and sizing always cause difficulties: it is very easy to write duplicate code, and it is more difficult to maintain and it leads to the appearance of bugs, so we tried to avoid it.  Since we provided support for iOS 8 from the very beginning, it was decided to try auto layout and sizing cells.  <a href="https://github.com/diegosanchezr/Chatto/tree/badoo-blog-autolayout-try">Here is a</a> thread with a general description of the implementation of such an approach.  After trying, we faced two major problems: <br><br><ul><li>  <b>jumps while scrolling</b> .  Usually in chat rooms, scrolling occurs from bottom to top, so at the beginning the sizes of the lower cells are considered, and then, during scrolling, the sizes of the cells appearing from above are considered.  At the same time, the exact size of the cells located above is not known in advance, and for calculating the contentSize and the position of the lower cells, the UICollectionView uses the indicated estimatedItemSize.  To get the exact cell size, UICollectionViewFlowLayout calls the preferredLayoutAttributesFittingAttributes (_ :) method of UICollectionViewCell.  Then, since this size does not correspond to the specified estimatedItemSize, the position of the cells created earlier is adjusted, which leads to their downward shift.  We could bypass this bug by turning the UICollectionView and UICollectionViewCells 180¬∫ (the lower cells would actually be the topmost ones), but there was another problem, namely ... </li><li>  <b>poor scrolling performance</b> .  We could not achieve scrolling at a speed of 60 frames per second, even with precisely calculated cell sizes.  The bottleneck was Auto Layout and UITextView resizing.  We were not very surprised, because we knew that Apple does not use Auto Layout inside cells in iMessage.  It does not follow at all that the Auto Layout should not be used;  in fact, Badoo uses it very widely.  However, it does have performance issues, usually affecting UICollectionView and UITableView. </li></ul><br><h2>  Manual layout </h2><br>  So, for the layout, instead of Auto Layout, we decided to use the traditional approach.  We settled on the classic method, in which a cell-blank is used to calculate the dimensions, and as much as possible of the general code would be used for the layout and size calculation.  This approach worked much faster, but it was still not enough for the iPhone 4s.  <a href="https://yalantis.com/blog/mastering-uikit-performance/">Profiling</a> revealed too much work inside the layoutSubviews method. <br>  In fact, we performed the same work twice: at the beginning we considered the dimensions in a blank, and then we did it again in a real cell inside layoutSubviews.  To solve this problem, we could cache sizeThatFits (_ :) values ‚Äã‚Äãfor UITextView, which is very expensive to calculate, but we went even further and created a layout model, within which the cell size and frames of all subviews were recorded and cached.  As a result, we managed not only to significantly increase the scrolling speed, but also with maximum efficiency to reuse the code between calls to sizeThatFits (_ :) and layoutSubviews. <br>  In addition, our attention was drawn to the updateViews method.  With a small size, it turned out to be one of the main methods responsible for updating the cell in accordance with a given style and type of displayed data.  Having one main method for updating the UI simplified the logic and maintenance of the code in the future, but it was called for almost every action that changes the properties of the cells.  To cope with this problem, we have come up with two ways to optimize. <br><br><ul><li>  <b>Two different contexts</b> : .Normal and .Sizing.  The .Sizing context we used for our dummy cell to skip some redundant calls to updateViews (for example, updating the image of a little cloud or disabling link detection in UITextView). </li><li>  <b>Batch update</b> : we implemented the function performBatchUpdates (_: animated: completion) for cells.  This allowed us to update the properties of the cells as many times as necessary, but in doing so, call updateViews only once. </li></ul><br><h2>  More speed </h2><br>  We have already achieved a good scroll speed, but loading more messages (in batches of 50 units) caused the main thread to block too long, and this, in turn, suspended scrolling for a split second.  Of course, the UITextView.sizeThatFits (_ :) function was again a bottleneck.  We managed to significantly speed it up by disabling the ability to detect links and text selection in a blank cell and enable non-contiguous layout: <br><br><pre><code class="objectivec hljs">textView.layoutManager.allowsNonContiguousLayout = <span class="hljs-literal"><span class="hljs-literal">true</span></span> textView.dataDetectorTypes = .None textView.selectable = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  After that, the simultaneous display of 50 new messages ceased to be a problem - provided that there were not very many messages before that.  But we decided that we could go further. <br>  Considering the level of abstractions that we achieved by caching and reusing the layout model to perform the tasks of calculating dimensions and position, we now had everything we needed to try to perform calculations in the background thread.  But ... not counting UIKit. <br>  As you know, UIKit is not thread safe, and our initial strategy (which was to simply ignore this fact) led to a number of expected failures in the UITextView.  We knew that the NSString.boundingRectWithSize (_: options: attributes: context) method could be used in the background, but the sizes returned by it did not match the sizes obtained from UITextView.sizeThatFits (_ :).  We spent a lot of time, but still managed to find a solution: <br><br><pre> <code class="objectivec hljs"> textView.textContainerInset = <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsetsZero</span></span> textView.textContainer.lineFragmentPadding = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  We also used rounding sizes derived from NSString.boundingRectWithSize (_: options: attributes: context) to screen pixels using <br><br><pre> <code class="objectivec hljs">extension <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> { func bma_round() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span>(width: ceil(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.width * scale) * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / scale), height: ceil(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.height * scale) * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / scale) ) } }</code> </pre><br><br>  Thus, we could prepare the cache in the background thread, and then very quickly get all the sizes in the main thread - provided that the layout did not have to deal with 5,000 messages. <br>  In this case, during the call to the UICollectionViewLayout.prepareLayout () method, the iPhone 4s began to slow down.  The main bottleneck was the creation of UICollectionViewLayoutAttributes objects and the sizing of 5000 messages from NSCache.  How did we solve this problem?  We did the same thing as with the cells: we created a model for UICollectionViewLayout, which was involved in creating UICollectionViewLayoutAttributes, and in the same way we transferred its creation to the background thread.  Now in the main thread we simply replaced the old model with a new one.  And everything began to work amazingly fast, but ... <br><br><h2>  Rotation and Split View </h2><br>  While the device was rotating or resizing the Split View, the available width changed to show the messages, so you had to read all the sizes and positions of the messages again.  For us, this was not a particular problem, since our application does not support rotation, but we were already going to release Chatto in open source and decided that decent support for rotation and Split View would be a big plus for these purposes.  By that time, we had already implemented the size calculation in the background thread with smooth scrolling and loading of new messages, but this didn‚Äôt help much when the application had to deal with 10,000 messages.  To calculate the size for such a large number of messages in the background, the iPhone 4s took from 10 to 20 seconds, and, of course, it was impossible to keep users waiting for so long.  We have seen two ways to solve the problem: <br><ul><li>  calculate the dimensions twice: for the first time - for the current width, and the second - for the width that the message on the device would accept after turning it 90¬∫. </li><li>  avoid having to deal with 10,000 messages. </li></ul><br>  The first option is rather a hack than the actual solution ‚Äî it doesn‚Äôt really help in Split View mode and doesn‚Äôt scale.  Therefore, we have chosen the second method. <br><br><h2>  Sliding data source </h2><br>  After several tests on the iPhone 4s, we concluded that supporting fast rotation meant processing no more than 500 messages, so we implemented a sliding data source with a configurable number of simultaneously displayed messages.  In accordance with this, when opening a chat, 50 messages were to be loaded first, and then the next portion of 50 messages would load as the user scrolled through the chat to see earlier entries.  When the user scrolled back a sufficiently large number of messages, the first ones were deleted from the memory.  So the pagination worked in both directions.  Implementing this method was a fairly simple task, but now we had a problem in another case ‚Äî when the data source was already filled and a new message arrived. <br>  If 500 messages had already been received and a new one arrived, then it was necessary to delete the topmost message, move all the rest up one position and insert the just-received message into the chat.  There was no difficulty with solving this either, but this approach was not liked by the UICollectionView.performBatchUpdates method (_: completion :).  There were two main problems (they can be reproduced <a href="https://github.com/diegosanchezr/Chatto/tree/badoo-blog-sliding-datasource-glitches">here</a> ): <br><br><ul><li>  slow scrolling and jumps when receiving a large number of new messages; </li><li>  broken animation when adding a message due to a change in contentOffset. </li></ul><br>  To eliminate these problems, we decided to relax the restriction providing for the maximum number of messages.  Now we allowed the application to insert new messages, breaking the set limit and thus ensuring a smooth update of the UICollectionView.  After performing the insert and in the absence of unprocessed changes in the update queue, we sent a warning to the data source that there were too many messages.  After that, we made the necessary adjustments using reloadData, not performBatchUpdates.  Since we couldn‚Äôt particularly control the moment when it would happen, and considering that the user could scroll the chat to any position, we needed to inform the data source where the user had scrolled through the chat in order not to delete the messages that were currently being viewed. : <br><br><pre> <code class="objectivec hljs">public protocol ChatDataSourceProtocol: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { ... func adjustNumberOfMessages(preferredMaxCount preferredMaxCount: Int?, focusPosition: Double, completion:(didAdjust: Bool) -&gt; Void) }</code> </pre><br><h2>  Khaki UITextView </h2><br>  So, we have so far considered only the problems with the performance of Auto Layout and the calculation of sizes, as well as the obstacles to solving the problem of calculating the sizes in the background thread using NSString.boundingRectWithSize (_: options: attributes: context). <br>  To take advantage of the ability to find links and some other available actions, we had to activate the UITextView.selectable property.  This led to some undesirable side effects for the clouds (for example, you can select text and a magnifying glass).  In addition, to support these features, UITextView uses a gesture recognition system that interfered with actions such as highlighting clouds with text and handling long clicks inside them.  We are not going to talk in detail about what hacks we managed to get around these problems with, but you can learn more about it yourself by following the links: <a href="https://github.com/badoo/Chatto/blob/ea3dc6b79adb0df07ff3578a919a039a25eb4549/ChattoAdditions/Source/Chat%2520Items/TextMessages/Views/TextBubbleView.swift">ChatMessageTextView</a> and <a href="https://github.com/badoo/Chatto/blob/ea3dc6b79adb0df07ff3578a919a039a25eb4549/ChattoAdditions/Source/Chat%2520Items/BaseMessage/BaseMessagePresenter.swift">BaseMessagePresenter</a> . <br><br><h2>  Interactive keyboard </h2><br>  In addition to the above problems, the work of UITextView affected the keyboard as well.  The idea is that nowadays, the implementation of interactive keyboard hiding should be a fairly simple task.  Just override inputAccessoryView and canBecomeFirstResponder in your controller, as shown <a href="https://robots.thoughtbot.com/input-accessorizing-uiviewcontroller">here</a> .  However, this method did not work efficiently when displaying UIActionSheet from UITextView, when the user made a long press on any link. <br>  The essence of the problem was that the menu appeared under the keyboard and was not visible at all.  Here is another <a href="https://github.com/diegosanchezr/Chatto/tree/badoo-blog-uitextview-keyboard-bug">branch</a> in which you can play <a href="https://openradar.appspot.com/radar%3Fid%3D4992538469466112">around</a> with this problem <a href="https://openradar.appspot.com/radar%3Fid%3D4992538469466112">yourself</a> ( <a href="https://openradar.appspot.com/radar%3Fid%3D4992538469466112">rdar: // 23753306</a> ). <br>  We tried to make the input field a part of the view controller hierarchy, track notifications from the keyboard, and manually change the contentInsets of a UICollectionView.  However, when the user interacted with the keyboard, no notifications were received, and the input field was shown in the center of the screen, leaving a gap between it and the keyboard when the user pulled the keyboard down.  This problem is solved with the help of a special hack, which consists in using a dummy inputAccessoryView (located under the input field) and observing it with the help of KVO.  Read more about this <a href="https://medium.com/ios-os-x-development/a-stickler-for-details-implementing-sticky-input-fields-in-ios-f88553d36dab">here</a> . <br><br><h2>  Summary </h2><br><ul><li>  We tried to use Auto Layout, but due to insufficiently high performance we had to switch to manual layout. </li><li>  We came to our own positioning model, which allowed us to reuse the code in layoutSubViews and sizeThatFits (_ :), and also implemented the calculation of the layout in the background.  It turns out that the solutions we found in something coincided with some ideas from the <a href="http://asyncdisplaykit.org/">AsyncDisplayKit</a> project. </li><li>  We implemented the performBatchUpdates method (_: animated: completion) and two separate contexts for the cells to minimize the number of view updates. </li><li>  We implemented a sliding data source with a limited number of messages in the code, thereby achieving a fast scaling when the device rotates and switches to Split View. </li><li>  UITextView turned out to be really hard to use, and it still remains a bottleneck that degrades performance when scrolling on older devices (iPhone 4s) due to link detection.  Nevertheless, we continued to use it, because we needed the ability to perform regular actions when interacting with links. </li><li>  Because of the UITextView, we had to manually implement the interactive hiding of the keyboard by observing with the help of KVO the fictitious inputAccessoryView. </li></ul><br>  <i>Badoo development team for iOS</i> </div><p>Source: <a href="https://habr.com/ru/post/278581/">https://habr.com/ru/post/278581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278571/index.html">Preparing an ASP.NET 5 (Core) project and DNX environment to participate in the hackathon as part of hack.summit () 2016 at Koding.com</a></li>
<li><a href="../278573/index.html">Adaptive Split View Controller and Popover in iOS 9 (Swift). Part 1</a></li>
<li><a href="../278575/index.html">Superscalar Stacking Processor: We Cross Horror And Hedgehog</a></li>
<li><a href="../278577/index.html">Automation of easy database 1C list management</a></li>
<li><a href="../278579/index.html">Using the Chromium project codebase as an SDK for developing cross-platform applications</a></li>
<li><a href="../278583/index.html">Work with FireBird from 1C. Collection of proven recipes</a></li>
<li><a href="../278585/index.html">Margaret Hamilton: "Guys, I'll send you to the moon"</a></li>
<li><a href="../278589/index.html">libuniset2 is a library for creating ACS. It‚Äôs better to see once ... Part 4 (Adjustment)</a></li>
<li><a href="../278593/index.html">We get acquainted with web standards. Work with audio. - Video and creation history</a></li>
<li><a href="../278595/index.html">SQL engine for generating reports. Idea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>