<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about Singularity, but were afraid to ask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to write something about Microsoft Singularity. This is a very cool thing, and in IT today everyone is talking about it. Here is a review...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about Singularity, but were afraid to ask</h1><div class="post__text post__text-html js-mediator-article"><img src="http://www.onlinekosten.de/news/bilder/microsoft-singularity.jpg"><br><br><p>  I would like to write something about Microsoft Singularity.  This is a very cool thing, and in IT today everyone is talking about it.  Here is a review of Singularity for those who do not want to read official publications. </p><br><a name="habracut"></a><br><br>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  What it is </h1><br><p>  Singularity is an operating system research project.  This is a team of smart people who were told: "How would you make an operating system that was originally focused on reliability?". </p><br><br><p>  People on popular forums like Slashdot or OSNews have <em>been</em> dreaming for <em>years</em> about Microsoft abandoning Windows and starting from scratch - to overcome the problems of unreliability or malicious code (malware).  Usually, the dreams of all these people revolve around the idea of ‚Äã‚Äãporting Windows to some UNIX - but this is a shitty idea, it would not solve the main problems.  If you want to solve the problems caused by the fundamental features of the design, you should start with the design.  What is being done in Singularity. </p><br><br><p>  Reliability is a rather broad question.  At a minimum, this means that applications do not crash and that they are safe.  But despite the fact that the development of Singularity affects many areas, developers do not have the task to make a full-fledged OS - for example, they are not engaged in GUI development. </p><br><br><br><br><h1>  What is the difference? </h1><br><p>  Actually, this is what I will talk about here. </p><br><br><p>  Singularity is a micronuclear design, as well as high performance, a single address space, static type verification and flexible access rights management. </p><br><br><p>  Oh yes, in the previous sentence there was a whole bunch of frightening academic terms.  Let's try to sort them out.  This will not be easy, because Singularity is rather far from standard OS designs from textbooks. </p><br><br><p>  Singularity is <em>highly productive</em> .  Actually, performance was not the goal of the project, but the developers turned out to be smart enough to realize that without this, their development would ‚Äúfly off into the clouds‚Äù and become completely non-commercialized.  This indirectly indicates that Microsoft plans to someday use this development in real products, so it needs to be quick (more on that a bit later). </p><br><br><p>  And Singularity is a microkernel.  Let's focus now on what it is.  We will talk about the rest of things later.  Scroll down if you are already aware of all this - in this case, we assume that you absolutely know what a microkernel is and why it is considered slow. </p><br><br><br><br><h1>  Uh-uh ... micro what? </h1><br><p>  Historically, there are two ways to design an operating system, two ways to do the same thing, using different cost-benefit ratios: a microkernel or a monolithic core.  Notice, we are now talking about a low-level design ... this does not affect whether you use the taskbar or the dock in your UI. </p><br><br><p>  In micronuclear design, subsystems like the file system or network drivers work as more or less normal programs outside the kernel itself (which differs from other programs in that it works in a special processor mode).  The kernel is only responsible for creating processes / threads, sending messages between them and for some other small things, such as allocating CPU resources.  True micronuclei today almost anywhere you will not meet.  Most likely, you used it without even knowing it.  For example, QNX is an operating system designed for embedded applications, such as Cisco routers.  QNX is a pure microkernel. </p><br><br><blockquote><h3>  Mistress note </h3><br><p>  Here is a quick overview of virtual memory.  When your code reads something from memory, the CPU internally converts your address from a virtual address to a physical address, which it can feed to the memory controllers.  On a 32-bit CPU, they are both 32-bit pointers, and you will most likely never see the immediate physical address unless you are a nuclear developer.  This transformation is done by a processor component called MMU (memory management unit) - it also implements access control.  The memory is divided into ‚Äúpages‚Äù of 4 kilobytes (in Intel / AMD chips) and a mapping is created for each page.  The display page has access bits ‚Äî read / write / execute ‚Äî just like files on UNIX. </p><br><br><p>  This memory mapping is the basis of security in all operating systems.  It does not allow a buggy program to spoil into the memory of other programs, and - since only the kernel can update the memory page tables, plus all access to the hardware occurs through the kernel - such a program operating in the user mode of the processor cannot do anything "interesting" until the kernel does not allow to do it.  And since the MMU does not allow you to read the memory of the kernel, you cannot access it.  It also means that we can use swap files to use the disk as a RAM chip ‚Äî just unload the part of the process address space, catch the read error from it ‚Äî and load the display again. </p><br><br><p>  Virtual memory is a great thing, one of the biggest improvements in computer reliability over the past 13 years.  Windows 3.1 did not use it, unlike Windows 95 - and this is why so many people have updated their OS.  The advantages of the microkernel are obvious here - the buggy components of the kernel cannot send the computer to BSOD aka "blue screen of death" - as they do today.  If your file system crashes - just restart it! </p></blockquote><br><br><p>  In monolithic design, file systems, drivers, and even web servers load directly into the kernel and run in privileged processor mode.  The kernel still provides a message-passing system for user-mode processes ‚Äî but this is not specifically used anywhere.  Today, any popular server or desktop OS - Windows, Linux and MacOS - is monolithic.  Notice that Linux has always been monolithic, Windows NT was initially micronuclear, and MacOS ‚Äî based on Mach ‚Äî is theoretically micronuclear.  However, I do not know anyone who would believe in it. </p><br><br><p>  It is probably difficult to say whether any operating system is microkernel or monolithic, because it is not binary ‚Äúyes / no‚Äù logic ‚Äî for example, in Linux, the graphics subsystem works in a separate process (X Server), whereas in Windows when <em>it was so</em> - but not today.  One way or another, no one argues that Linux is not a microkernel.  A good evaluation criterion is whether the file system works in kernel mode or not ‚Äî graphical systems may be in a gray area, but not file systems. </p><br><br><p>  In any case, the fact that Singularity employs a microkernel design looks rather strange, because historically it has won over the microkernel in an academic environment, but the monolithic core has always been defeated in the market, mainly due to performance problems.  These disputes flared up in the 80s - <a href="http://www.oreilly.com/catalog/opensources/book/appa.html">here you can read the famous dispute between Torvalds and Tanenbaum</a> .  So, at first glance it may seem that Singularity is another academic development of theoretically pure, but practically non-usable things ... but it is not. </p><br><br><br><br><h1>  Why is the microkernel slower? </h1><br><p>  Microkernels are typically slower than monolithic kernels - due to the overhead of switching between processor modes (user-mode to kernel-mode and back).  In addition, there are also costs for switching the processor between two user-mode processes (context switching). </p><br><br><p>  These costs are small, but real, and when you make a stop hundred of such switchings per second, this leads to the fact that all the work of the processor is reduced to switching back and forth, and there is no time left for real work.  And it‚Äôs quite difficult to measure these costs, although the Singularity team did it. </p><br><br><p>  The reason why these switches take up valuable time is that the CPU has to do an unusual job for it, and since the processor spends most of the time <em>without doing</em> this work, it is not very well optimized.  This has changed in the latest generations of x86 chips, but overall, everything remains the same. </p><br><br><p>  For example, by doing syscall to force the kernel to do something, you use a special processor instruction.  This is usually ‚Äúint 80‚Äù on Linux, but today you can use the ‚Äúsysenter‚Äù opcode on the kernels and processors that support it (almost everyone can).  In this case, control passes to the kernel.  This is pretty fast on modern computers, but this was not always the case - for example, earlier versions of Windows used incorrect processor instructions, as the developers found that a CPU exception was a quicker way to get into kernel mode than using an interrupt (‚Äúofficial‚Äù way).  Intel fixed it :) </p><br><br><p>  Context switching is more expensive;  firstly, because it obviously causes a switch to kernel mode, and also because reconfiguring the memory mapping tables is not a quick thing. </p><br><br><p>  Not quick because it is, again, an unusual operation (for this you need to use special registers in x86 chips), but mainly because it requires resetting the so-called ‚Äútranslation lookaside buffers‚Äù (TLB).  These buffers store the result of MMU requests.  After all, even if the MMU is hardware specialized for its task, its use is not free - and the translation of memory addresses must be done every time the code is accessed to memory (which happens all the time) - and here caching is necessary. </p><br><br><p> Because of this, it is difficult to measure how expensive context switching is.  We know that this is worth something there - due to the fundamental design features of the CPU.  But the real cost is spread over the code of the running process.  Immediately after the context switch, your computer runs a bit slower and picks up progress as you fill out the TLB. </p><br><br><p>  So we have two conflicting priorities.  On the one hand, using virtual memory to separate address spaces can improve the reliability of separating programs from each other (which is good), but, on the other hand, it costs us hard to measure performance loss - which is bad.  Even worse, even though processors become faster from time to time - they become faster in the execution of the code, but not in manipulating the address space, so we cannot rely on the help of Moore's law this time. </p><br><br><br><br><h1>  Message exchange </h1><br><p>  Micro-cores are based on the idea of ‚Äã‚Äãforwarding messages between processes in different address spaces.  So, to read the file, you need to send a message from your program to the file system server.  You form a message in your memory (this is fast), you do a syscall ‚Äúsend message‚Äù (not so fast anymore), then the kernel copies the message to its own address space (rather slowly), switches the context to the file system server (slowly), and then copies the message to the memory of the file system server before leaving the kernel mode. </p><br><br><p>  When the file system reads the file you are looking for, you need to repeat all this tin in the reverse order, this time copying the data into the return message ... and since the cost of sending the message grows with its size - this is even slower than the initial request! </p><br><br><p>  It looks completely different in a monolithic design: you form your request (it is fast), you do syscall (not so fast), wait until the file system receives your data, then the kernel copies the data directly to your address space (or if you use DMA), returning control to user mode ... wow, it's easier and faster!  The disadvantage here is that if the file system is booted up, the entire OS will crash into the BSOD and you will lose everything. </p><br><br><p>  About 80% of crashes in Windows are caused by crooked drivers.  So, if we could prevent system crashes due to drivers in the same way as we prevented crashes because of buggy programs, we would prevent 80% of all BSODs in the world!  This is pretty cool!  It also means that security mechanisms can work with drivers.  If you install a third-party file system today, who knows what you will actually get?  Until you view and compile the code yourself - you have to trust the one who gave it to you.  Even if this is all right, a bug in the new driver can open a hole for the rootkit, bending the entire security system: ( </p><br><br><p>  Probably, it is not surprising that academics preferred a slow, but reliable solution - while desktop OS developers preferred a quick but unstable one.  But do not think that they did not try to do otherwise!  Windows NT was developed as a purely microkernel solution, but even with a super-optimized interprocess communication, they once gave up and ‚Äúmoved‚Äù to the kernel along with the GUI - for which they received a lot of criticism, but this made Windows responsive and the users happy. </p><br><br><br><br><h1>  Singularity </h1><br><p>  Singularity manages to "sit down and eat" - to get all the advantages of a microkernel and even better performance than a monolithic core.  Cool! </p><br><br><br><br><h1>  How it works? </h1><br><p>  Singularity is impressive in that it has a clean micronuclear design, ~ 30% faster than the traditional approach and 10% faster than the monolithic (in the benchmark heavy file I / O).  How does she do it? </p><br><br><p>  The trick is very simple - they just gave up hardware memory protection, completely.  In Singularity, everything works in kernel mode and everything works in a single address space.  In other words, the MMU does nothing.  And there are no ‚Äúprocesses‚Äù in the traditional sense. </p><br><br><p>  Of course, if this were the only thing they did, it would not be so interesting.  Eighty percent of the crash of Windows is caused by buggy drivers, and not by errors in the kernel (I suspect that the remaining 20% ‚Äã‚Äãare caused by glitches in the hardware).  Numerous vulnerabilities that allow escalation of privileges are caused by glitches in the drivers.  Each such vulnerability - a gift to "bad guys."  Protection against software errors is what makes microkernels useful. </p><br><br><p>  Programs in Singularity are <em>isolated</em> from each other ‚Äî but isolation is done entirely and programmatically, using type theory, not silicon.  This is possible because Singularity programs are written in a C # descendant named Sing # (theoretically, you can use any language for .NET ‚Äî Singularity uses quite a few features added to C #, so any other language will require only these few changes) . </p><br><br><p>  You probably already know that in most modern languages ‚Äã‚Äã- like Java or C # - you do not have direct memory access.  Roughly speaking, you cannot write a similar C-code in Java: </p><br><br><p></p><blockquote><code>*((<font color="blue">char</font> *)0x1234) = <font color="#770000">‚ÄòX‚Äô</font>; <font color="green">//     1234</font></code><br>
</blockquote><p></p><br>
<br>
<p>    ,     .   Java/C#  -,      ,  ,     . ,  ,   JVM/MSIL   ¬´ ¬ª,   ,     ,        ,    /  .       ‚Äî        !</p><br>
<br>
<br>
<br>
<h1>    </h1><br>
<p>,    .       .   ,      C   ,     ‚Äî      Java/.NET           (  C++)      .</p><br>
<br>
<p>   ,    ,   reflection ()        ,     .</p><br>
<br>
<p>        JVM-  .  ,    JRE ‚Äî    .</p><br>
<br>
<br>
<br>
<h1></h1><br>
<p> Singularity    ‚Äî      C#,      C++  .         .  Microsoft     ‚Äî    ,           .</p><br>
<br>
<p>   Singularity ‚Äî  SIP, software isolated process  ¬´  ¬ª. Singularity   ,  -,    ,         ‚Äî      .</p><br>
<br>
<p>SIP    (heap),    (        GC,     ,    GC     )     .   SIP  ,      ( KaffeOS),                 .   ,           SIP.     ,  SIP       ‚Äî      ,          .   ,      ,   GC   ,     .</p><br>
<br>
<p>      CPU ‚Äî   ,  ,   ¬´¬ª.  Singularity ¬´¬ª   ,   SIP' ,  ,   SIP'     . ,      /  ,   C++  .      SIP ( ), ,    ,     .</p><br>
<br>
<p>SIP'   ,     .    ,  GC       SIP' ‚Äî     .    syscall     .</p><br>
<br>
<p>SIP'     ¬´¬ª.  ‚Äî     ,  UNIX' ,     .  ,  ,   ‚Äî         -     .        .         SIP' ( ,     -)  .</p><br>
<br>
<br>
<br>
<h1> </h1><br>
<p>   ,         .   ?   SIP'       ?</p><br>
<br>
<p>  ,  SIP  (,  CD),   MSIL-.       (just-in-time, JIT)  ,     Java  .NET.  ,          .       Singularity ‚Äî    .       .</p><br>
<br>
<p>       MSIL    CPU ,  ¬´   I/O ¬ª  ¬´  ¬ª,     ‚Äî   -   ,     .     ,   ,        ,       .        ,      ‚Äî    CPU    .</p><br>
<br>
<br>
<br>
<h1></h1><br>
<p>  OS  -  .      :  , iTunes  ,  ,     iPod. ,  -,         ,        ‚Äî , -,    .</p><br>
<br>
<p> SIP'  ,   (  )      SIP'.       ‚Äî   ?  <em></em>  ,   ?</p><br>
<br>
<p>  Singularity  .  ,   .NET, XML-,  SIP'    ,   .         .   , ,  .</p><br>
<br>
<br>
<br>
<h1>  Singularity</h1><br>
<p>     , :<br>
<br>
</p><blockquote><ol>
<li> 80%    Windows    .<br>
&nbsp;</li>
<li>  Linux ,     7    ,    .<br>
&nbsp;</li>
<li>  ,   ¬´  ¬ª  ,       ‚Äî   ‚Äî  .<br>
&nbsp;</li>
<li>   ,       .      ¬´ ¬ª.</li>
</ol></blockquote><p></p><br>
<p> Singularity  - ,    ,  ‚Äî    Sing#- (Sing#   ¬´¬ª C#),     MSIL-.    SIP,     . ,   C#       ‚Äî  ,   ¬´overflow¬ª        .</p><br>
<br>
<p>  MSIL      ,    ,    -  .   ,  -   DLL,  ,  ,  .  DLL (<code>Singularity.DriverRuntime</code>)   ,  Microsoft  ¬´trusted computing base¬ª,        -  DRM,    .    DLL,    ,           .    <code>IoPortRange</code>, <code>IoIrqRange</code> ( ..)    -    .</p><br>
<br>
<p>Singularity        ,        .        . ,   ‚Äî       ,       ?      ?</p><br>
<br>
<p>Singularity     ,  ,          .     .NET  ‚Äî ,       .         XML- ( ,   )       (compile-time transform),   ,   .            ‚Äî       HAL (hardware abstraction layer).</p><br>
<br>
<p> , Singularity     ,    .   ,          (   )     ‚Äî       . ,   ,               .</p><br>
<br>
<br>
<br>
<h1>  ?</h1><br>
<p>     ,   - (    ?).   ,   ,   DMA-    ,     .</p><br>
<br>
<p>DMA ‚Äî Direct Memory Access (    ) ‚Äî ,      RAM,   CPU.         ,         ,  ,     .  , DMA      CPU,     MMU,   ,  DMA-      .      ,          .   Singularity  .</p><br>
<br>
<p>   ,    DRM! ,   !   CPU,   Intel  AMD,  -,  ( ) IOMMU.      ,   MMU    ‚Äî    ,  /  DMA   .   IOMMU,         DMA.               (      DRM-).  , ,      ,      .</p><br>
<br>
<p>     ,     ,   DMA-      - ¬´¬ª.</p><br>
<br>
<br>
<br>
<h1>   ?</h1><br>
<p> 2001-   Microsoft       .        ,           .           ‚Äî ,    ,      ,        . Microsoft     unit-,    ,      .            Microsoft.  ?</p><br>
<br>
<p>, ,   . ,   .  ,    ,   .        $250  ,        ¬´OK¬ª      . .</p><br>
<br>
<p>           .     ,       ‚Äî       .</p><br>
<br>
<p> ,   ,       : ¬´, ,        ‚Äú ‚Äù,   DMA,     (  ,    ,       )¬ª.     ,      ?  .      ,   ,    .       BSOD,       .   ,  ,    ‚Äî     ,            .</p><br>
<br>
<p> ,       ( Singularity   ,  SIP'),     ‚Äî      .    ?      , .       ( DoS' -   ?   ).  ,  ,      -       ,    ,      .        ,      Microsoft,      .</p></div><p>Source: <a href="https://habr.com/ru/post/31605/">https://habr.com/ru/post/31605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316038/index.html">News Yii 2. ‚Ññ1</a></li>
<li><a href="../31604/index.html">Applied psychology for web design</a></li>
<li><a href="../316040/index.html">New survey ‚ÄúState of the Nation of Developers‚Äù by Vision Mobile</a></li>
<li><a href="../316046/index.html">Strange games</a></li>
<li><a href="../316048/index.html">How to open a startup in Berlin [infographics]</a></li>
<li><a href="../316050/index.html">Badoo Worldwide Billing QA Eyes</a></li>
<li><a href="../316052/index.html">Oracle buys high-profile Dyn provider in hopes of bypassing Amazon in the cloud market</a></li>
<li><a href="../316054/index.html">Auto-Deploying Django from GitLab</a></li>
<li><a href="../316056/index.html">How I did mirroring virtual machines for Free ESXi</a></li>
<li><a href="../316058/index.html">Rambler.Android # 4 results</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>