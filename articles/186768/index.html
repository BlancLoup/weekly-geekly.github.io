<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using JSON-Schema in API Testing and Documentation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reference API 2GIS has been developed for 4 years. There are about 40 methods that return fairly large and hierarchically complex structures in JSON a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using JSON-Schema in API Testing and Documentation</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://api.2gis.ru/%3Futm_source%3Dnews%26utm_medium%3Dhabr%26utm_campaign%3Dpost_json">Reference API 2GIS has</a> been developed for 4 years.  There are about 40 methods that return fairly large and hierarchically complex structures in JSON and XML.  Recently I decided to share my experience and speak at the DevConf conference. <br>  One of the topics of the report caused the greatest interest among participants - the use of JSON-Schema when testing the format of issuing API.  In this article I will tell you what problems this approach solves, what restrictions it has, what you get out of the box, and what comes with a bonus.  Go! <br><br><img src="https://habrastorage.org/storage2/45a/581/117/45a58111727dcbbbb9a38d2c05fa2ae2.jpg"><br><a name="habracut"></a><br>  JSON Schema is a JSON equivalent of the XML Schema format.  Its essence is that it in the declarative form sets the structure of the document.  Nothing prevents JSON schemas from being used for testing purposes. <br><br>  It would seem that there may be difficulties in testing API?  This is not some sophisticated UI.  Just think, execute the query and compare the result with the expected. <br>  Frustrating cumbersome hierarchical structures that may be in queries or responses.  When there are parameters in the region of 50, it is extremely problematic to take into account all possible characteristic cases. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition to the fact that the API must fulfill the duties assigned to it, you expect reasonableness and consistency from it.  Including this refers to the format.  It would be desirable, that numbers always were given, as numbers, instead of lines.  What if the array is empty, it should not be null, or be completely absent in the answer, and let it be an empty array.  This, of course, little things, but API users are very unpleasant to stumble about them.  Plus it can lead to hidden errors.  So the rigor of the format should be given attention. <br><br>  In general, testing the structure and format is not a tricky task.  For each method, you can describe the structure of the request and response using the JSON-Schema format. <br>  As they say, everything is already invented before us.  It should just correctly use this. <br><br><h5>  API format testing </h5><br><h6>  Request and Reply </h6><br>  We will consider testing the format of responses API.  It‚Äôs just closer to us, because  Our API is focused on reading data only.  But when the API is able to receive data in the form of complex objects, the fundamental approach remains the same as in the case of reading. <br><br><h6>  JSON-Schema </h6><br>  <b>Format</b> <br><br>  So, help us in our difficult task JSON-Schema.  A brief introduction to the format itself is already <a href="http://habrahabr.ru/post/158927/">in place</a> .  Therefore, we restrict ourselves to a trivial example.  Take a JSON object: <br><br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"a"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>:<span class="hljs-string"><span class="hljs-string">"boo"</span></span> }</code> </pre> <br>  To set its structure, type of parameters, mandatory, it is enough to replace the values ‚Äã‚Äãof the parameters with special objects.  We look: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"a"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-string"><span class="hljs-string">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"b"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br>  Agree, quite clearly.  By and large, JSON-Schema aims to be an analogue of the XML Schema format. <br><br>  <b>PHP implementation</b> <br><br>  Of course, it is not necessary to use JSON-Schema when describing the response.  The format is relatively young, not completely settled down.  Not so many libraries and tools as for the XML Schema format.  But for so many developers, the JSON format is much clearer.  And if we talk about PHP, then JSON is almost native to it thanks to the json_encode and json_decode functions. <br><br>  JSON-Schema format implementations are available for <a href="http://json-schema.org/implementations.html">different languages</a> .  As you can see, the choice is not great.  For PHP, there are two libraries from two institutions: <a href="https://github.com/hasbridge/php-json-schema">MIT</a> and <a href="https://github.com/justinrainbow/json-schema">Berkeley</a> . <br>  At the time of this writing, the last committee at MIT was February 2012, and at Berkeley, June 2013. So, a quick review prompted Berkeley to choose. <br><br>  As a fly in the ointment, it can be noted that for objects in the response there can be not only the fields described in the diagram, but also completely left ones.  And the answer will be completely valid, which in most cases is not acceptable.  This is treated, in my opinion, by a misunderstanding by a small preprocessor, which explicitly sets the special property AdditionalProperties to false by default. <br><br><h6>  Validation </h6><br>  It does not make much sense to include validation of API responses in combat, extra overhead.  But when we run tests - this is it.  To switch modes, a flag in the application configuration file is sufficient. <br>  If we talk about a specific Berkeley library, then an example of validation from tests: <br><br><pre> <code class="php hljs">$validator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Validator(); $validator-&gt;check(json_decode($input), json_decode($schema)); <span class="hljs-comment"><span class="hljs-comment">//  $input    $schema $this-&gt;assertTrue($validator-&gt;isValid(), print_r($validator-&gt;getErrors(), true));</span></span></code> </pre><br><br>  It is even intuitively clear what is happening. <br><br>  It should be noted that there is no need to write tests specifically for testing JSON schema.  We believe that functional tests have already been written to the API.  This means that if we turn on filtering, then when running tests automatically in the background, the response format will be checked.  As if between times.  No special efforts except, in fact, writing schemes do not need to be applied. <br><br>  Yes, and a small addition: for performance tests, validation should be disabled so that there are no ‚Äúpickups‚Äù.  And on the developers' machines, on the contrary, turn it on in order to quickly detect a format violation.  The question is - who should write JSON schemes?  We write the developers, it is more convenient.  Schemes live in the project code, and with any changes in the format, the developer immediately corrects the scheme. <br><br><h5>  Documentation </h5><br>  We dealt with testing, we connect to unit tests and at the output we get confidence in the correctness of the format.  But there is another big bonus when using the JSON scheme to which we arrived - this is documenting the API. <br><br>  The problem with the documentation is one - her, damn, you need to write  API documentation is its specification, all nuances should be reflected in it.  Well, how else?  The API does not exist by itself, it exists only so that its clients can work with it.  And the less surprises you expect from him, the clearer it is and users can use it faster and more comfortably.  Perhaps the only case where the documentation can save, if the developers of the API - at the same time its users.  And this is not always the case.  Therefore, the documentation would be better.  Well, if the total number of parameters is hundreds, how to keep the documentation up to date?  Not only do we write code with tests, we also have to keep track of the documentation.  In short, plus one ‚Äúsmut‚Äù, of which there is enough without documentation. <br><br><h6>  Versioning </h6><br>  So, what about document versioning?  The fact is that we, like many, have adopted an approach - each feature is made in a separate branch in git. <br>  Well, if each branch would have its own version of the documentation.  So it's easier for everyone: both the developer and the tester.  I made the task in the branch, immediately wrote the documentation and ‚Äúforgot‚Äù about the task. <br><br>  Therefore, it is good when the documentation lives with the code.  And in order to make it easier to merge the same document from different tasks, it is logical to store it in a certain text format.  You can store it in <a href="http://ru.wikipedia.org/wiki/Markdown">Markdown</a> format, semantic <a href="http://ru.wikipedia.org/wiki/BbCode">bb-codes</a> or something else.  But in fact it still remains almost a bare text, with different tables, links between them, cross-references, etc.  It is not entirely clear how to test the correctness of the documentation.  Every time you carefully check everything manually, ‚Äúyou get dirty‚Äù.  This is the first, and secondly, the errors still remain. <br><br><h6>  JSON-Schema </h6><br>  Well, all the same: <br><br><img src="https://habrastorage.org/storage2/586/1b5/16d/5861b516dfc1e210997d9011d6efebb8.jpg"><br><br>  You can‚Äôt completely abandon it, but you can greatly reduce the amount of effort to support it.  We already have a JSON-Schema.  It already contains all the names of the parameters in the API response, the hierarchical relationships between them, the data types, the binding parameter.  Namely, this information is also needed to generate documentation. <br><br>  Therefore, we decided to cross a bulldog with a rhinoceros and write documentation right in JSON-Schema.  In the JSON-Schema format, the description tag is already provided.  But it must be a string, according to the specification.  And it would be nice to add more examples (the nested examples tag), and some specific options, such as a secret parameter (nested hide tags) and so on.  Therefore, the tag object is better suited for this.  We have chosen the name of the tag - ‚Äúmeta‚Äù.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"reviews_count"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-string"><span class="hljs-string">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"meta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"hide"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br><br><h5>  Representation </h5><br>  Now we set our JSON scheme on spec.  parser, and it turns into elegant documentation.  While forming the documentation, not only the content of our own ‚Äúmeta‚Äù tag is taken into account, but also information from the native tags of the schema. <br><br>  The specific way of submitting documentation may be different.  We preferred ordinary flat tables with links between them.  But this, of course, is not ideal.  Be that as it may, placing documentation in a JSON scheme does not tie to the final mapping method, which gives more freedom. <br><br>  For maximum flexibility, the documentation should not be built entirely from the JSON schema.  We have a well-established approach when there is a separate text file for each page of the documentation.  And already a link to a specific JSON scheme is inserted into it.  When the page is assembled, the JSON schema is converted to the final text view.  Thus, we solve the problem of placing in the documentation of arbitrary text, examples, and other materials.  And at the same time we are not trying everything that can be stuffed into the JSON scheme. <br><br><h5>  Self test </h5><br>  It turns out that the same JSON schemas are used for both tests and documentation.  And this means that JSON-schemes are always relevant and correct, otherwise the tests will fall down.  So in the documentation, in principle, there can be no errors associated with the names of the parameters, their types, binding / non-binding, list of acceptable values, hierarchical relationships between the parameters.  What, you see, is no longer enough. <br><br><h5>  Examples </h5><br>  Documentation without examples of use greatly increases the threshold of entry for users of the API.  Therefore, they should be added without fail.  We organize them as follows.  We describe in the documentation a request and a sample response. <br><br>  But, as it is not difficult to guess, the problem of the relevance of the response text emerges.  It will take a week, the format will expand, and what, examples re-make?  There is a better way out. <br><br>  We came to the fact that the results of the queries in the examples of documentation should be dynamic.  Here different approaches are possible.  Since our API responses are often very large, we show them in the documentation for a click on a specific area.  It is at this moment that we execute the request.  The simplest scheme, but with a slight delay in receiving data. <br><br>  If this option is not suitable, you can dynamically perform all requests in the examples with a special command, and fill in the answers in the documentation page.  You can do this, for example, before the release. <br><br>  By the way, since we are still writing examples, they can also be considered a kind of functional tests.  Well, really, we collect all requests in the documentation, turn on the JSON scheme and check the validity.  At the same time, it is thus possible to identify broken methods or incorrectly written queries. <br><br><h5>  Empty values </h5><br>  Speaking about format validation, you should decide what to do with parameters with empty values ‚Äã‚Äãin the response.  We have come to the following agreement. <br><br>  The parameter in any case must be present in the response, even if it contains an empty value.  So the response structure is better visible.  There is no need to consult the documentation only in order to find out. <br><br>  An array type parameter returns an empty array.  The object is null.  For numeric and string parameters, if zero and an empty string are meaningful values, then we return them.  For example, the parameter "number of reviews" may well return zero - this is logical.  But the parameter ‚Äúthe number of floors of the building‚Äù if it returns zero is nonsense.  If, say, its number of floors is not known for a certain house, return null. <br>  Where null is possible, and where not, is clearly indicated in the JSON scheme.  And that means in the documentation.  Your approach may differ, as long as it is consistent across all parameters, otherwise the end users of the API will have a headache. <br><br><h5>  Conclusion </h5><br>  JSON-Schema saves valuable time for testing and documenting APIs.  This is the case when a small amount of effort brings a lot of profit.  And the larger the API, the more effort this approach saves. <br><br>  However, once you have to invest in writing a small toolkit to use JSON-schemes. <br><br>  In addition to saving time on tests, it is easier to maintain backward compatibility in the API, since  API format is clearly expressed in the JSON scheme.  A heavy load of documentation becomes easy hand luggage. </div><p>Source: <a href="https://habr.com/ru/post/186768/">https://habr.com/ru/post/186768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186758/index.html">Experience of entering the ‚Äúbusy‚Äù market of regional real estate portals</a></li>
<li><a href="../186760/index.html">Step-by-step firmware OpenWRT to TP-LINK TL-WR741ND router from Windows</a></li>
<li><a href="../186762/index.html">Access javascript webpage from chrome extension</a></li>
<li><a href="../186764/index.html">Linux 3.11 officially named ‚ÄúLinux For Workgroups‚Äù</a></li>
<li><a href="../186766/index.html">Beacon Mountain - now for MacOS X</a></li>
<li><a href="../186774/index.html">Mobile version of GitHub</a></li>
<li><a href="../186778/index.html">Be wary of generalizations</a></li>
<li><a href="../186780/index.html">Meet Intel Integrated Performance Primitives 8.0</a></li>
<li><a href="../186782/index.html">Relay of 50 quineas</a></li>
<li><a href="../186784/index.html">Metric # 15 - Podcast on technologies and design of interfaces and services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>