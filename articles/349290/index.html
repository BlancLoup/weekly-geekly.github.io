<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to graph APIs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! We continue to track the theme of the API design after we met this book in the Manning publishing portfolio. Today we decided to publish an ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to graph APIs</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  We continue to track the theme of the API design after we met <a href="https://www.manning.com/books/irresistible-apis">this</a> book in the Manning publishing portfolio.  Today we decided to publish an overview article about the new Graph API and suggest once again to think about what the new API will be after the undivided popularity of REST. <br><br>  Enjoy reading! <br><a name="habracut"></a><br>  If in the past 10 years you have consumed an API, I‚Äôm willing to bet that it was a REST API.  Probably, the data was structured around resources, id included in the responses pointing to related objects, and using HTTP commands it was told how to deal with the information: read, write and update (yes, I agree, this is a loose definition, not Roy‚Äôs canonical REST) Fielding).  For a while, REST-style APIs have been the dominant standard in our industry. <br><br>  However, REST has its problems.  A client can get used to extracting extra data by requesting a whole resource in case he needs only one or two pieces of information.  Or, the client may regularly require several objects at the same time, but he cannot retrieve them all in one request - then a so-called ‚Äúunder-extraction‚Äù of data arises.  With regard to support, changes in the REST API can lead to the fact that the client will need to update the entire integration in order for the program to comply with the new API structure or response schemes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To solve such problems in recent years, fundamentally different APIs, called "graph", have been increasingly developed. <br><br><h4>  What is Graph API? </h4><br>  Simplified definition of a graph API: This is an API that models data in terms of nodes and edges (objects and relationships) and allows the client to interact with many nodes at once within a single query.  Suppose the server contains data about authors, blog posts and comments to them.  If we have a REST API, then to get the author and comments to a specific post from the client, you may need to make three HTTP requests, for example: <code>/posts/123</code> , <code>/authors/455</code> , <code>/posts/123/comments</code> . <br><br>  In the graph API, the client formulates the call in such a way that the data from all three resources are drawn in one go.  The client can also indicate the fields that are really important to him, giving more complete control over the response scheme. <br>  To explore in detail how this mechanism works, consider a couple of cases describing living non-fictional APIs. <br><br>  <b>Case 1: Facebook Graph API</b> <br><br>  Facebook released version 1.0 of <a href="https://developers.facebook.com/docs/graph-api/overview/%3Futm_source%3Dzapier.com%26utm_medium%3Dreferral%26utm_campaign%3Dzapier">its API</a> in 2010 and has since been designing new versions, inspired by the example of graph databases.  There are nodes that correspond, for example, to posts and comments, as well as edges connecting them and indicating that this comment is ‚Äúrelevant‚Äù to this post.  This approach provides the entire structure with no less high-quality detectability than the typical REST API, however, it still allows the client to optimize data retrieval.  Take as an example a separate post and consider what simple operations can be done with it. <br><br>  First, the client selects a post from the root of the API using the GET request, based on the post ID. <br><br><pre> <code class="hljs objectivec">GET /&lt;post-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;</code> </pre> <br>  By default, in this case, most of the top-level fields of this post are returned.  If the client only needs access to certain elements of the post ‚Äî for example, the title and creation time ‚Äî you can only request these fields, specifying this information as one of the request parameters: <br><br><pre> <code class="hljs objectivec">GET /&lt;post-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;?fields=caption,created_time</code> </pre> <br>  To select the required data, the client requests an edge, for example, comments to the post: <br><br><pre> <code class="hljs objectivec">GET /&lt;post-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;/comments</code> </pre> <br>  Until now, all this is reminiscent of the REST API functions.  Perhaps the ability to specify a subset of fields is new, but in general, the data are perceived largely as resources.  The situation becomes more interesting when the client collects the attached request.  Here's how the client can choose comments to the post: <br><br><pre> <code class="hljs objectivec">GET /&lt;post-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;?fields=caption,created_time,comments{<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,message}</code> </pre> <br>  The above query returns a response, which contains the time when the post was created, its title and a list of comments (from each message only the id and the message are selected).  In REST, you could not do this.  The client would need to select the post first and then the comments. <br><br>  And what if the client needs a deeper investment? <br><br><pre> <code class="hljs objectivec">GET /&lt;post-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;?fields=caption,created_time,comments{<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,message,from{<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,name}}</code> </pre> <br>  In this query, post comments are selected, including the id and the name of the author of each comment.  Consider how this would be done in REST.  The client would need to request a post, request comments, and then, in a series of separate requests, extract information about the author of each comment.  Immediately recruited a lot of HTTP calls!  However, when designing in the form of a graph, all this information is condensed in one call, and in that call it turns out only that information that the client needs. <br><br>  Finally, the last point that should be noted about graph design: any object selected from the edge itself is a node and, therefore, it can be requested directly.  Here, for example, how additional information about a specific commentary is selected: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /&lt;<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>-id&gt;</code> </pre> <br>  Note: the client does not need to collect the URLs of the form <code>/posts/&lt;post-id&gt;/comments/&lt;comment-id&gt;</code> , as might be required when working with the REST API.  This can be useful in situations where the client does not have direct access to the id of the parent object. <br><br>  The same situation occurs when data changes.  For example, if we need to update and / or delete an object (say, a comment), the PUT or DELETE request is applied, respectively, sent directly to the end point <code>id</code> .  To create an object, the client can send a POST to the corresponding node edge.  So, to add a comment to a post, the client makes a POST request to the edge with comments from this post: <br><br><pre> <code class="hljs pgsql">POST /&lt;post-id&gt;/comments message=This+<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>+a+<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span></code> </pre> <br>  <b>Case 2: GitHub V4 GraphQL API</b> <br><br>  Another competitor to the graph API is the specification called GraphQL.  This concept is significantly different from REST, here only one endpoint is provided that accepts GET and POST requests.  For all interactions with the API, queries are sent that comply with the GraphQL syntax. <br><br>  In May 2017, GitHub released the 4th version of its API corresponding to this specification.  To try what GraphQL is, let's look at the individual operations that can be done with the repository. <br><br>  To select a repository, the client defines a GraphQL query: <br><br><pre> <code class="hljs pgsql">POST /graphql { "query": "repository(owner:\"zapier\", name:\"transformer\") { id description }" }</code> </pre> <br>  In this query, the ID and description of the ‚Äútransformer‚Äù repository are selected from the Zapier org resource.  There are several things to note here.  First, we read the data from the API using POST, since we send the message body in the request.  Secondly, the payload of the request itself is written in JSON format, which is prescribed in the GraphQL standard.  Thirdly, the structure of the request will be exactly as specified in our request, <code>{"data": {"repository": {"id": "MDEwOlJlcG9zaXRvcnk1MDEzODA0MQ==", "description": "..."}}}</code> ( The root <code>data</code> key is another mandatory element that must be present in GraphQL responses). <br><br>  To select data related to the repository - for example, tasks and their authors, the client applies a subquery: <br><br><pre> <code class="hljs pgsql">POST /graphql { "query": "repository(owner: \"zapier\", name: \"transformer\") { id description issues(last: 20, orderBy: {field: CREATED_AT, direction: DESC}) { nodes { title body author { login } } } }" }</code> </pre><br>  This request snatches the ID and description of the repository, the name and text of the last 20 tasks created in the repository, as well as the login name of the author of each task.  That is, in each request fit a lot of information.  Imagine what the REST equivalent of such a query would look like - and it becomes clear what features and flexibility the GraphQL clients provide in this regard. <br><br>  When updating data, GraphQL uses a concept called ‚Äúmutation‚Äù.  Unlike REST, where an update is performed by PUT or POST of a modified copy of the resource to the same endpoint with which the client extracted it, the GraphQL mutation is an explicit operation defined by the API.  If the client needs to correct the data, then it is required to know which mutations are supported on the server.  Conveniently, GraphQL allows them to be detected as part of a process called ‚Äúintrospection scheme‚Äù. <br><br>  Before discussing what ‚Äúintrospection‚Äù is, it is necessary to clarify the term ‚Äúscheme‚Äù.  In GraphQL, each API defines a set of types used in validating queries.  So far in GitHub, we have worked with <code>repository</code> , <code>issue</code> and <code>author</code> .  Each type describes the data it contains, as well as the relationships of this type with others.  Together, all these types form an API schema. <br><br>  If there is a detailed GraphQL schema, it is imperative that the client have the opportunity to request this schema in accordance with the GraphQL syntax.  In this way, the client can learn the capabilities of the API through introspection. <br><br>  If a client wants to know which mutations are possible in GitHub, you can simply request: <br><br><pre> <code class="hljs pgsql">POST /graphql { "query": "__type(name: \"Mutation\") { name kind description fields { name description } }" }</code> </pre><br>  Among the mutations listed in the response, we find, for example, <code>addStar</code> , which allows the client to put an asterisk repository (or any rated object).  To implement a mutation, a similar query is used: <br><br><pre> <code class="hljs pgsql">POST /graphql { "query": "mutation { addStar(input:{starrableId:\"MDEwOlJlcG9zaXRvcnk1MDEzODA0MQ==\"}) { starrable { viewerHasStarred } } }" }</code> </pre> <br>  This request indicates that the client is about to use the <code>addStar</code> mutation and provides the arguments necessary to perform such an operation;  in this case, it is only the repository ID.  Note: in this query, the keyword mutation is used as the prefix of the query.  This is how GraphQL finds out that the client is about to perform a mutation.  In all previous queries, the query keyword could also be supplied as a prefix, but it is customary to use it if the type of operation is not specified.  Finally, it should be noted that the client fully controls the data contained in the response.  In this request, the client requests the <code>viewerHasStarred</code> field from the repository ‚Äî in this scenario, it doesn‚Äôt interest us much, because an asterisk is added during the mutation, and we know that it will return <code>true</code> .  However, if a client has committed a different mutation ‚Äî say, he created a task, he can receive in response generated values, for example, the task ID or number, as well as embedded data, for example, the total number of open tasks in this repository. <br><br>  <b>API of the future</b> <br><br>  I hope these cases demonstrate how the design of the API is developing in the SaaS industry.  I'm not trying to say that the graph API is the future, and REST is dead.  Architectures like GraphQL have their own problems.  But it's good that the circle of possibilities is expanding, and the next time when you need to create an API, you will be able to weigh all the compromises that you have to make with one or another design variant, and choose the best solution. </div><p>Source: <a href="https://habr.com/ru/post/349290/">https://habr.com/ru/post/349290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349280/index.html">Room: One to many</a></li>
<li><a href="../349282/index.html">Hamster Marketplace development team: how our outsourcer became a partner and why AI is to blame</a></li>
<li><a href="../349284/index.html">Sign symbol: iOS denial of service</a></li>
<li><a href="../349286/index.html">How to buy 1C</a></li>
<li><a href="../349288/index.html">RoboCon 2018: Robot Framework First Conference Report</a></li>
<li><a href="../349292/index.html">Journalists suspect Apple‚Äôs problems based on Tim Cook‚Äôs response in an interview</a></li>
<li><a href="../349296/index.html">Again EA, again NFS, again bugs. We repair</a></li>
<li><a href="../349300/index.html">"Calendar tester" for January. Disassemble backlog</a></li>
<li><a href="../349304/index.html">MOSDROID # 5 Boron in Tutu.ru office: video speeches</a></li>
<li><a href="../349306/index.html">Creating a modal component using Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>