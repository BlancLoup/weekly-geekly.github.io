<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ordinary (or unusual) Python transliteration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once there was a need to write a transliteration in Python - from Cyrillic to Latin. From the word "Sith" is obtained "sith", and from the "rustle" co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ordinary (or unusual) Python transliteration</h1><div class="post__text post__text-html js-mediator-article">  Once there was a need to write a transliteration in Python - from Cyrillic to Latin.  From the word "Sith" is obtained "sith", and from the "rustle" comes out "shelest". <br><br>  It would seem, what is there to write at all - the task is hardly more difficult to print "Hello world".  And this is partly the case - but not quite. <br><br>  The fact is that some letters in Russian in transliteration are converted not into one but several Latin letters at once: these are F, C, H, W, U, Y and I. In fact, if the transliteration rules were to be converted into one a Latin letter, then transliteration of Russian into English would really not be much more complicated than that very simple program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But, since we are not exactly going to change the transliteration rules, we will see what happens when we use the usual transliteration. <br><br>  For example, the phrase “SHAPKA and Yulia” is converted to “SHAPKA and YUlya”, or “ShAPKA and Yulya” - depending on what is specified in the transliteration table for “W” and “U” (sometimes “SH” and “YU”, and sometimes “Sh” and “Yu”). <br><br>  That is, the case of the next letter in the standard transliteration functions is not taken into account, and all letters in upper case are replaced by the general rules.  Therefore, in the course of transliteration for the words “BOWL” and “Schi” it is easy to get something like “ChAShA” or “SCHi”, when in reality we would rather like to get “CHASHA” and “Schi”. <br><br>  Nevertheless, all found implementations of the transliteration from Cyrillic to Latin in Python, as it turned out, did not take this feature into account.  These are the numerous solutions <a href="http://www.google.ru/search%3Fq%3Dpython%2B%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">given in the forums</a> , and the <a href="https://github.com/j2a/pytils">pytils</a> library, which implements transliteration in one of its modules. <br><br>  So, we will write our transliteration function, with blackjack and ^ W ^ W ^ W ^ H ^ H.  :) <br><br><a name="habracut"></a><br>  So, the <a href="https://gist.github.com/1683896">first option</a> is to go through the string character by character.  In this case, it is always known which character is next (if it is not the last character in the string). <br><br>  The principle is as follows: <br><br><ol><li>  For each character it is checked whether it is among the keys of the dictionary lower_case_letters. </li><li>  If so, it is replaced with the value for the given key in lower_case_letters. </li><li>  If not, it is checked whether this symbol is among the keys of the capital_letters dictionary. </li><li>  If it is, it is checked whether the last character is in a string (if the length of the string is greater than the position of the current character + 1, then this is not the last character, provided that the position is counted from zero). </li><li>  If the character is not the last, then it is checked whether the next character is among the keys of the lower_case_letters dictionary. </li><li>  If not, or if it is the last character in the string, then the current character is replaced with the value for the given key in the capital_letters dictionary, the upper () method is used for the value — that is, “SH” is SH, and so on. </li><li>  If the next character is among the keys of the lower_case_letters dictionary, then the upper () method does not apply. </li></ol><br>  The advantages of this option are that it is slightly shorter than the next four (actually only a few lines), and, more interestingly, it works very quickly with very small lines.  But with large lines, on the contrary, it works very slowly - that is, the time required for transliteration of a line strongly depends on the number of characters in a line - on the graph you can see exactly how the transliteration time changes for different numbers of characters. <br><br>  For greater accuracy, the execution time (both on this and the other graphic) is indicated not for one transliteration operation, but for 500. The processor installed on the computer is Intel Core 2 Quad CPU Q9400 @ 2.66GHz. <br><br><img src="https://habrastorage.org/storage2/bac/df8/b84/bacdf8b84ae1b7c638605c3d7ccd2e81.png" alt="Schedule"><br><br>  Well, it became obvious that for faster processing of long strings it is necessary to somehow use the replacement of each individual character along the entire string (replace).  And as a matter of fact, not one character can be replaced, but a group of characters at once.  So there was a second option. <br><br>  In general, it must be said that the replacement of groups of characters is not the only solution that came to mind.  First, for example, the idea arose of dividing a line into words, then checking the case for each word (if the word in which all characters are converted to upper case is equal to the original word, then the whole word is in upper case), and if the word is written in upper case then apply a separate transliteration table, especially for words in upper case.  Accordingly, in this case the letter “” in the word “Chess” will be transliterated as “Sh”, but in the word “CHESS” already as “SH”. <br><br>  True, in words written in a mixed register (for example, "SHAHMATS"), the usual transliteration table will be used in any case (that is, it will turn out to be ShAHmatY).  But this is, in general, not so important. <br><br>  Or, alternatively, it would be possible to make it even more universal - use replace for words written in lower case, and process the remaining words character-by-character.  But it probably would have been slower now, because there are likely to be many such words. <br><br>  Nevertheless, let us return to the <a href="https://gist.github.com/1685047">second written version</a> .  His principle is to single out those Russian letters, which are represented as several Latin characters, into a separate dictionary, and then create a dictionary (transliteration table) from pairs of characters, where for each of these letters (F, C , W, W, U, Y and I) there are 33 different versions, with each of the lowercase letters of the Russian alphabet.  Accordingly, it remains to first make a replacement for such pairs of characters, and then for all other characters that are not translated. <br><br>  But it was precisely this option that turned out to be very slow (in fact, implementation turned out to be slow - but more on that below). <br><br>  More precisely, it is faster than the first option only with a very large number of characters - about 10 thousand. <br><br>  And when processing lines from 100 to 1000 characters, the first option is approximately 10 times faster. <br><br>  Well, 7 * 33 = 231. That is, 231 additional replacements.  Of course, in the dictionary we will not meet many of these combinations of letters - that is, theoretically, fewer replacements could have been done.  But, on the other hand, the text can consist not only of words that are in the dictionary, but in general, it would not be desirable to introduce such restrictions once again. <br><br>  In fact, as it turned out, the point is not that a large number of replacement operations are performed, but how exactly the replacement of characters is implemented (see the fourth option). <br><br>  However, first consider the third option. <br><br>  <a href="https://gist.github.com/1685065">The third option is</a> somewhat similar to the second, but there are no longer 231 separate replacements for every possible combination of F, C, H, W, U, Y and I with lowercase letters.  Instead, it uses a regular expression that is used for just 7 substitutions.  Each of the letters corresponding to several Latin letters, followed by a lowercase character ([az]) is replaced by the Latin representation of this letter, followed by the same lowercase character (without transliteration).  After that, respectively, the remaining lowercase letters are replaced separately, as, by the way, and capital.  When replacing capital letters corresponding to several Latin characters, the upper () method is used for the Latin representation of the letter. <br><br>  And this option has just turned out to be very fast compared to the second. <br><br>  On lines of 100 characters, it should be noted, slower than the first option.  But on the 1000 character line, it is already twice as fast as the first option, and 19.5 times faster than the second. <br><br>  In principle, this could have been completed, but in reality there is something else that can and should be added. <br><br>  If we write import this, then we get the well-known text, the Zen language of Python.  Among other things, there is a phrase that "there must be one - and, preferably, only one - the obvious way to do it."  However, anyone who has been programming in Python for a long time knows that there are cases when there are quite a few ways to do the same thing, and using any of them the result may be exactly the same, but the time spent on the operation can differ very much. <br><br>  So, for example, u "Your name is% s"% username runs much faster than u "Your name is" + username.  This is well and thoroughly written in the article <a href="http://www.skymind.com/~ocrow/python_string/">“Efficient String Concatenation in Python”</a> . <br><br>  Similarly, the string can be replaced by re.sub, or the string replace method can be used.  Moreover, if any replacement does not use regular expressions, it is strongly recommended to use the second method, which, moreover, works much faster.  By the way, in the same pytils the string replace method is used. <br><br>  So, the <a href="https://gist.github.com/1685068">fourth option</a> (the second version with edits).  Only three lines were edited, but the productivity increased tremendously. <br><br>  This option is better than all the others with lines of 1000 and 10000 characters.  On lines of 100 characters, the difference compared with what was (the second option) is also very large. <br><br>  But what about editing the third option?  After all, of the three cycles where the replacement of characters is performed, regular expressions are used only in one.  Well, great, edit and the third option, too. <br><br>  <a href="https://gist.github.com/1685075">The fifth variant</a> differs from the third one only in that in two cycles, where regular expressions are not used for the replacement, the replacement operation is performed using the string replace method. <br><br>  Without a doubt, this should have greatly affected the performance: the speed of the fifth variant turned out on average 1.5 times more than the third.  Moreover, it turned out that on the 100-character string, the fifth version works even faster than the first (that is, faster than character-by-character processing). <br><br><img src="https://habrastorage.org/storage2/766/f51/38a/766f5138afbe13db0d3b02e60e6f9acb.png" alt="Schedule"><br><br>  It turns out that replacement algorithms turned out to be faster than character-by-character processing for lines of 100, 1000, and 10000 characters. <br><br>  And yet, each option has its advantages and disadvantages.  For example, even though in the fifth version, a line of 100 characters is processed faster than using character-by-line traversal, on very small lines (several characters, and sometimes this) character-by-character processing will still be the fastest option. <br><br>  Perhaps the most correct solution is a combination of the best algorithm for processing short lines and the best algorithm for processing long lines.  That is, first of all, we check the length of the string, and then, depending on this, we use either one or another algorithm. <br><br>  In conclusion, I want to quote Mike Hertel (Mike Haertel - author of GNU Grep) from his <a href="http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">post</a> on the freebsd-current mailing list regarding why GNU Grep works so fast: <br><br><blockquote>  The key to making programs.  ;-) </blockquote><br>  "The key to making programs quick is to make sure that they practically do nothing." <br><br>  If there are any other thoughts - feel free to add, add.  If there are any other improvements, I think it may be interesting for many. <br></div><p>Source: <a href="https://habr.com/ru/post/137089/">https://habr.com/ru/post/137089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137084/index.html">Not a computer mouse and high technology</a></li>
<li><a href="../137085/index.html">BlackBerry PlayBook in police service</a></li>
<li><a href="../137086/index.html">How to model business processes in eEPC notation?</a></li>
<li><a href="../137087/index.html">PayPal and US shipping address</a></li>
<li><a href="../137088/index.html">Beta-test Bitcasa do it yourself</a></li>
<li><a href="../137092/index.html">1/998001</a></li>
<li><a href="../137093/index.html">Bitcasa - unlimited file storage for $ 10 ... for now free</a></li>
<li><a href="../137095/index.html">The jump in attendance of file hosting sites</a></li>
<li><a href="../137097/index.html">Unit testing in Codeception</a></li>
<li><a href="../137098/index.html">Songsterr - now on Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>