<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating Shaders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To master the creation of graphic shaders is to take control of the full power of the video processor with its thousands of parallel cores. This way o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating Shaders</h1><div class="post__text post__text-html js-mediator-article">  To master the creation of graphic shaders is to take control of the full power of the video processor with its thousands of parallel cores.  This way of programming requires a different way of thinking, but revealing its potential is worth the effort. <br><br>  Virtually any modern graphic simulation uses code written for a video processor: from realistic lighting effects in high-tech AAA games to two-dimensional post-processing effects and fluid simulation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ed/24d/433/8ed24d433b42e50ab03d5f9a4a6aa47d.jpg"><br>  <i>Scene from Minecraft, before and after the addition of <a href="http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/1280299-sonic-ethers-unbelievable-shaders-v10-1">several shaders</a> .</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  The task of this tutorial </h2><br>  Sometimes shader programming is mysterious black magic and is often misunderstood.  There are many examples of code that demonstrate the creation of incredible effects, but in which there are practically no explanations.  In my guide, I want to fill this gap.  I will focus mainly on the basic principles of creating and understanding shader code so that you can easily customize, combine or write your own shaders from scratch! <br><a name="habracut"></a><br>  This is a general guide, so everything studied in it can be applied in any technology that uses shaders. <br><br><h2>  What is a shader? </h2><br>  A shader is simply a program running in the graphics pipeline.  It tells the computer how to render each pixel.  These programs are called shaders (‚Äúshaders‚Äù), because they are often used to control <a href="https://www.youtube.com/watch%3Fv%3DG8-ivm3iuKc" rel="external">lighting</a> and <a href="http://threejs.org/examples/" rel="external">shading</a> effects, but nothing prevents them from being used for other special effects. <br><br>  Shaders are written in a special shader language.  Do not worry, you will not have to learn a completely new language: we will use GLSL (OpenGL Shading Language), which is similar to C. (There are several <a href="http://en.wikipedia.org/wiki/Shading_language" rel="external">shader languages</a> for different platforms, but since they are all adapted to run in a video processor, they are similar to friend.) <br><br>  <i><strong>Note: This article is devoted exclusively to fragment shaders.</strong></i>  <i><strong>If you're curious about what other types of shaders are, you can read about the <a href="https://www.khronos.org/opengl/wiki/Shader">different stages of the graphics pipeline</a> in the OpenGL Wiki.</strong></i> <br><br><h2>  Getting started! </h2><br>  In this tutorial we will use <a href="https://www.shadertoy.com/">ShaderToy</a> .  It allows us to start programming shaders right in the browser, without fussing with the installation and configuration!  (For rendering, it uses WebGL, so a browser with the support of this technology is required.) <a href="https://www.shadertoy.com/signin">Creating an account is</a> not necessary, but convenient for saving code. <br><br>  <em>Note:</em> at the time of writing, ShaderToy was in beta state <i>[approx.</i>  <i>per .: article written in 2015]</i> .  Some interface / syntax details may be slightly different. <br><br>  By clicking on the <a href="https://www.shadertoy.com/new">New Shader</a> , you will see something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99c/a00/8aa/99ca008aa5e06aafc5467b08a7efc426.jpg"><br><br>  If you are not registered, the interface may be slightly different. <br><br>  The small black arrow below serves to compile the code. <br><br><h2>  What's happening? </h2><br>  I am going to describe how shaders work in one sentence.  Are you ready?  Here it is! <br><br>  <em>The sole purpose of the shader is to return four numbers:</em> <code><em>r</em></code> <em>,</em> <code><em>g</em></code> <em>,</em> <code><em>b</em></code> <em>and</em> <code><em>a</em></code> <em>.</em> <br><br>  This is the only shader that can do.  The function is performed for each pixel on the screen.  It returns these four color values, which become the color of a pixel.  This is what is called a <em>pixel shader</em> (sometimes called a <em>fragment shader</em> ). <br><br>  With this in mind, let's fill the screen with a solid red.  The RGBA values ‚Äã‚Äã(red, green, blue and alpha, which defines transparency) vary from <code>0</code> to <code>1</code> , so the only thing to do is to return <code>r,g,b,a = 1,0,0,1</code> .  ShaderToy expects the final pixel color to be stored in <code>fragColor</code> . <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec4 fragColor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec2 fragCoord </span></span></span><span class="hljs-function">)</span></span> { fragColor = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Congratulations!  Here is your first ready shader! <br><br>  <strong>Task:</strong> Try changing color to solid gray. <br><br>  <code>vec4</code> is just a data type, so we could declare a color as a variable, like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec4 fragColor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec2 fragCoord </span></span></span><span class="hljs-function">)</span></span> { vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); fragColor = solidRed; }</code> </pre> <br>  It does not look very inspiring.  We have the power to execute code for <em>hundreds of thousands of</em> pixels simultaneously, and we paint them in one color. <br><br>  Let's try to render a gradient on the screen.  We will not be able to achieve much without knowing a couple of things about the pixels that we influence, for example, their position on the screen ... <br><br><h2>  Shader Input </h2><br>  The pixel shader passes several <a href="https://www.opengl.org/wiki/Built-in_Variable_(GLSL)" rel="external">variables</a> that we can use.  The most useful is <code>fragCoord</code> , which contains the X and Y coordinates of a pixel (and Z, if you work in 3D).  Let's try turning all the pixels on the left side of the screen into black, and all the pixels on the right into red: <br><br><pre> <code class="hljs ruby">void mainImage( out vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>);<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xy.x &gt; <span class="hljs-number"><span class="hljs-number">300.0</span></span>){<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,     ! solidRed.r = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">1.0</span></span> } fragColor = solidRed; }</code> </pre> <br>  <em>Note:</em> You can access the components of any <code>vec4</code> using <code>obj.x</code> , <code>obj.y</code> , <code>obj.z</code> and <code>obj.w</code> <em>or</em> using <code>obj.r</code> , <code>obj.g</code> , <code>obj.b</code> , <code>obj.a</code>  They are equivalent; it‚Äôs just a convenient naming <code>obj.r</code> that <code>obj.r</code> it easier to read the code, because when people see <code>obj.r</code> , they understand that <code>obj</code> is a color. <br><br>  Have you noticed the problem in the above code?  Try clicking on the <strong>go fullscreen</strong> button in the lower right corner of the preview window. <br><br>  The sizes of the red part of the screen will be different and depend on the size of the screen.  To paint in red exactly half the screen, we need to know its size.  Screen size is <em>not</em> a built-in variable, like pixel position, because it is usually chosen by the programmer who creates the application.  In our case, the screen size is set by the ShaderToy developers. <br><br>  If something is not a built-in variable, then you can send this information from the CPU (from the main program) to the video processor (to your shader).  ShaderToy takes on this task.  All variables transmitted to the shader are indicated in the <strong>Shader Inputs</strong> tab.  Variables transmitted in this way from the CPU to the video processor are called in the GLSL <em>uniform (global)</em> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5b/5bd/189/d5b5bd1897442a49cc8a7fd20961edb8.png"><br><br>  Let's change the code to correctly determine the center of the screen.  We need to use the input data of the <code>iResolution</code> shader: <br><br><pre> <code class="hljs ruby">void mainImage( out vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    xy.x = xy.x / iResolution.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     xy.y = xy.y / iResolution.y; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  x      <span class="hljs-number"><span class="hljs-number">0</span></span>,      <span class="hljs-number"><span class="hljs-number">1</span></span> vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xy.x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>){ solidRed.r = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">1.0</span></span> } fragColor = solidRed; }</code> </pre> <br>  If you try now to resize the preview window, the colors should accurately split the screen in half. <br><br><h2>  From separation to gradient </h2><br>  Turning it into a gradient is pretty easy.  The color values ‚Äã‚Äãvary from <code>0</code> to <code>1</code> , and the coordinates also vary from <code>0</code> to <code>1</code> . <br><br><pre> <code class="hljs ruby">void mainImage( out vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    xy.x = xy.x / iResolution.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     xy.y = xy.y / iResolution.y; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  x      <span class="hljs-number"><span class="hljs-number">0</span></span>,      <span class="hljs-number"><span class="hljs-number">1</span></span> vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    solidRed.r = xy.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     x fragColor = solidRed; }</code> </pre> <br>  Voila! <br><br>  <strong>Task:</strong> Can you turn this image into a vertical gradient?  What about the diagonal?  What about a gradient of several colors? <br><br>  If you experiment with the code, you will notice that the upper left corner has coordinates <code>(0,1)</code> , and <em>not</em> <code>(0,0)</code> .  It is important to remember. <br><br><h2>  Image drawing </h2><br>  Experimenting with colors is interesting, but if we want to do something impressive, then our shader has to learn how to get an image as input and change it.  In this way, you can get a shader that affects the entire game screen (for example, an ‚Äúunderwater‚Äù effect or color correction), or only affect certain objects (for example, to create a realistic lighting system). <br><br>  If we were programming on a conventional platform, then we would have to transfer the image (or texture) as <em>uniform</em> to the video processor, just as we would transfer the screen resolution.  ShaderToy will take care of this for us.  At the bottom of the screen there are four input channels: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/3c1/787/54c3c17871f758c4726528343b65b5f0.png"><br>  <i>Four input channels ShaderToy</i> <br><br>  Click on <strong>iChannel0</strong> and select any texture (image). <br><br>  As a result, you will have an image transmitted to the shader.  However, there is one problem: the lack of the <code>DrawImage()</code> function.  Do not forget, the only thing that a pixel shader can do is <em>change the color of each pixel</em> . <br><br>  If we can only return the color, how can we draw the texture on the screen?  We need to somehow bind the current pixel of the shader to the corresponding pixel of the texture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86d/b1a/00b/86db1a00bf6ea3f6d3d0c5fb3cba1610.png"><br>  <i>Depending on the location (0,0), it may be necessary to reflect the Y-axis on the screen to properly bind the texture.</i>  <i>At the time of writing, the ShaderToy has been updated and the starting point is in the upper left corner, so nothing needs to be reflected.</i> <br><br>  We can bind using the <code>texture(textureData,coordinates)</code> function, which receives texture data and a pair of coordinates <code>(x, y)</code> at the input, which returns the color of texture in these coordinates as <code>vec4</code> . <br><br>  You can snap the coordinates to the screen as you like.  You can draw the entire texture on a quarter of the screen (skipping pixels, that is, reducing its scale) or simply draw a part of the texture. <br><br>  We only want to see the image, so the pixels will match on a 1: 1 scale: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec4 fragColor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec2 fragCoord </span></span></span><span class="hljs-function">)</span></span> { vec2 xy = fragCoord.xy / iResolution.xy;<span class="hljs-comment"><span class="hljs-comment">//     vec4 texColor = texture(iChannel0,xy);//  iChannel0    xy fragColor = texColor;//     }</span></span></code> </pre> <br>  So we got our first image! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/acb/36a/4c6acb36ad42c65c5a7da269d4d6ec87.jpg"><br><br>  Now, having learned how to correctly obtain data from a texture, we can do anything with it!  We can stretch or scale them, experiment with colors. <br><br>  Let's try to put a gradient on the image, similar to what we did before: <br><br><pre> <code class="hljs">texColor.b = xy.x;</code> </pre> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11d/01b/5b6/11d01b5b65174a8c7698d8a9a2edd1e3.jpg"><br><br>  Congratulations, you just wrote your first post-processing effect! <br><br>  <strong>Task:</strong> Can you write a shader that makes an image in black and white? <br><br>  Please note that although we have chosen a static image, everything that you see is performed in real time.  To see this, replace the static image with the video: click on <strong>iChannel0</strong> and select any video. <br><br><h3>  Add motion </h3><br>  So far, all our effects have been static.  We can do much more interesting things by using the input data provided by ShaderToy.  <code>iGlobalTime</code> is an ever-increasing variable.  We can use it as a seed to create periodic effects.  Let's try playing a little with the flowers: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> mainImage( <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy / iResolution.xy; //      vec4 texColor = texture(iChannel0,xy); //   iChannel0    xy texColor.r *= abs(sin(iGlobalTime)); texColor.g *= abs(cos(iGlobalTime)); texColor.b *= abs(sin(iGlobalTime) * cos(iGlobalTime)); fragColor = texColor; //      }</code> </pre> <br>  GLSL has built-in sine and cosine functions, as well as many other useful functions, such as getting the length of a vector or the distance between two vectors.  Color values ‚Äã‚Äãcannot be negative, so you need to get an absolute value using the <code>abs</code> function. <br><br>  <strong>Task:</strong> Can you make a shader that changes the image from black and white to color and back? <br><br><h2>  Shader Debugging Note </h2><br>  When debugging code, you can execute it step by step or print values, but this is not possible when writing shaders.  You can search for debugging tools for your platform, but in general, it is best to link the value to be checked to some graphical information that can be seen. <br><br><h2>  Summarize </h2><br>  These are just the basics of working with shaders, but by becoming familiar with them, you can achieve much more.  <a href="https://www.shadertoy.com/browse">See ShaderToy effects</a> and see if you can understand or play them! <br><br>  In this tutorial, I did not mention the <em>Vertex Shaders (Vertex Shaders)</em> .  They are written in the same language, but they are executed for each vertex, not a pixel, and return with the color also the position.  Vertex shaders typically project a 3D scene onto a screen (this feature is built into most graphics pipelines).  Pixel shaders provide most of the complex effects seen on the screen, so I‚Äôm looking at them. <br><br>  <strong>Another task:</strong> Can you write a shader that removes the green color from the video from ShaderToy and adds another video as the background of the first video? <br><br>  <a href="https://www.shadertoy.com/" rel="external">ShaderToy</a> , with which we worked earlier, is great for quick testing and experiments, but its capabilities are rather limited.  For example, you can not control the data transmitted to the shader.  If we have our own environment for running shaders, we can create all sorts of interesting effects and use them in our own projects!  To run shaders in the browser, we will use the Three.js framework.  WebGL is a Javascript API that allows rendering of shaders. Three.js is needed only to simplify the work. <br><br>  If you are not interested in JavaScript or a web platform, do not worry, we will not go into the features of web rendering (but if you want to learn more about the framework, then learn <a href="http://gamedevelopment.tutsplus.com/articles/how-to-learn-threejs-for-game-development--gamedev-11787">this tutorial</a> ).  Setting up shaders in the browser is the fastest way to get started, but by becoming familiar with this process, you can easily set up and use shaders on any platform. <br><br><h2>  Customization </h2><br>  In this section, we will look at local shader configuration.  You can repeat after me without having to download something thanks to <a href="http://codepen.io/tutsplus/pen/OVxXZE">this built-in widget CodePen</a> : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/OVxXZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  You can <a href="http://codepen.io/tutsplus/pen/OVxXZE">create a fork and edit the project</a> on CodePen. <br><br><h3>  Hello Three.js! </h3><br>  <a href="http://threejs.org/" rel="external">Three.js</a> is a JavaScript framework that takes over most of the boilerplate code for WebGL needed to render shaders.  The easiest way to start is to use the <a href="http://cdnjs.com/libraries/three.js/" rel="external">version laid out on the CDN</a> . <br><br>  You can download <a href="https://github.com/tutsplus/Beginners-Guide-to-Shaders/blob/master/Part2/shader_base.html">an HTML file</a> that is a simple Threejs scene. <br><br>  Save the file to disk and open it in the browser.  You should see a black screen.  It's not very interesting so far, so let's try to add a cube, just to check that everything works. <br><br>  To create a cube, we need to define its geometry and material, and then add it to the scene.  Add this code snippet to the <code>Add your code here</code> field: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BoxGeometry( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial( { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0x00ff00</span></span>} );<span class="hljs-comment"><span class="hljs-comment">//    var cube = new THREE.Mesh( geometry, material ); //     scene.add( cube ); cube.position.z = -3;//   ,    </span></span></code> </pre> <br>  We will not consider the cube in detail, because we are more interested in the shader.  But if everything is done correctly, then you will see a green cube in the center of the screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/aff/085/f13aff085864d87899a776f089aab3e7.png"><br><br>  While we are here, let's make it rotate.  The <code>render</code> function is executed every frame.  You can access the cube rotation through <code>cube.rotation.x</code> (or <code>.y</code> , or <code>.z</code> ).  Try increasing the value so the rendering function looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cube.rotation.y += <span class="hljs-number"><span class="hljs-number">0.02</span></span>; requestAnimationFrame( render ); renderer.render( scene, camera ); }</code> </pre> <br>  <strong>Task:</strong> Can you rotate the cube along a different axis?  What about two axes at the same time? <br><br>  So, everything is ready, it's time to add shaders! <br><br><h2>  Add shaders </h2><br>  At this stage we can start thinking about the implementation process of the shaders.  Most likely, you will have a similar situation regardless of the platform: everything is set up, objects are drawn on the screen, so how do you get access to the video processor now? <br><br><h4>  Step 1: Download the GLSL Code </h4><br>  To create a scene, we use JavaScript.  In other situations, C ++, Lua or any other language can be used.  Regardless, shaders are written in a special <em>shader language</em> .  The OpenGL shader language is called <em>GLSL</em> (Open <strong>GL</strong> <strong>S</strong> hading <strong>L</strong> anguage).  Since we use WebGL based on OpenGL, we will write on GLSL. <br><br>  How and where is GLSL code written?  The main rule: the GLSL code is loaded as a <code></code> .  Then it can be passed for parsing and execution in a video processor. <br><br>  In JavaScript, this can be done by simply passing the code inside a variable, like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderCode = <span class="hljs-string"><span class="hljs-string">"  ;"</span></span></code> </pre> <br>  This will work, but since there are no easy ways to create multi-line strings in JavaScript, this is not very convenient for us.  Most programmers write shader code in text files and give them the extension <code>.glsl</code> or <code>.frag</code> (short for <em>fragment shader</em> ), and then just load the file. <br><br>  This is possible, but in this tutorial we will write the shader code inside the new <code>&lt;script&gt;</code> and load it into JavaScript from there so that all the code is in one file. <br><br>  Create a new <code>&lt;script&gt;</code> in HTML that looks like this: <br><br><pre> <code class="javascript hljs">&lt;script id=<span class="hljs-string"><span class="hljs-string">"fragShader"</span></span> type=<span class="hljs-string"><span class="hljs-string">"shader-code"</span></span>&gt;; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  We will assign him ID <code>fragShader</code> so that you can access it later.  The <code>shader-code</code> type is actually a non-existent, made-up type of script.  (You can choose any other name for it).  We do this so that the code is not executed and not displayed in HTML. <br><br>  Now let's insert a very simple shader that returns white. <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fragShader"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"shader-code"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main() { gl_FragColor = vec4(</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1.0</span></span></span><span class="actionscript">,</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1.0</span></span></span><span class="actionscript">,</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1.0</span></span></span><span class="actionscript">,</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1.0</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  (The <code>vec4</code> components in this case correspond to the RGBA value, as explained at the beginning of the tutorial.) <br><br>  Now we need to download this code.  We will do this in a simple JavaScript line that finds the HTML element and retrieves the inner text: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderCode = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"fragShader"</span></span>).innerHTML;</code> </pre> <br>  It must be under the cube code. <br><br>  Do not forget: only the code loaded as a string will be parsed as a valid GLSL code (that is, <code>void main() {...}</code> . The rest is just a HTML boilerplate.) <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/BNwzxP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  You can <a href="http://codepen.io/tutsplus/pen/BNwzxP">create a fork and edit the project</a> on CodePen. <br><br><h4>  Step 2: Apply the Shader </h4><br>  The methods of using the shader may vary, they depend on the platform used and its interface with the video processor.  There are never any difficulties with this, and a quick search can figure out <a href="http://threejs.org/docs/">how to create an object and apply shaders to it using Three.js</a> . <br><br>  We need to create a special material and pass it to the shader code.  We will create a plane as a shader object (but we can also use a cube).  Here is what you need to do: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      var material = new THREE.ShaderMaterial({fragmentShader:shaderCode}) var geometry = new THREE.PlaneGeometry( 10, 10 ); var sprite = new THREE.Mesh( geometry,material ); scene.add( sprite ); sprite.position.z = -1;//   ,    </span></span></code> </pre> <br>  At this point, you should see a white screen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/warWjE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  You can <a href="http://codepen.io/tutsplus/pen/warWjE">create a fork and edit the project</a> on CodePen. <br><br>  If you replace the color in the shader code with another one and refresh the page, you will see a new color. <br><br>  <strong>Task:</strong> Can you make one part of the screen red and the other blue?  (If it doesn't work out, then in the next step I will give a hint!) <br><br><h4>  Step 3: Data Transfer </h4><br>  At this point, we can already do anything with the shader, but do not yet know what <em>can be</em> done.  We only have the built-in ability to determine the position of the pixel <code>gl_FragCoord</code> and, if you remember, this position is normalized.  We at least need to know the size of the screen. <br><br>  To transfer data to the shader, we need to send what we call a <em>uniform</em> variable.  To do this, we create an <code>uniforms</code> object and add our variables to it.  Here is the screen resolution transfer syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = {}; uniforms.resolution = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'v2'</span></span>,<span class="hljs-attr"><span class="hljs-attr">value</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth,<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight)};</code> </pre> <br>  Each uniform must have a <code></code> and <code></code> .  In this case, it is a two-dimensional vector, whose coordinates are the width and height of the window.  The table below (taken from the <a href="http://threejs.org/docs/">Three.js documentation</a> ) shows all the data types that can be sent, along with their identifiers: <br><table><thead><tr><th>  Uniform String </th><th>  Type GLSL </th><th>  Javascript type </th></tr></thead><tbody><tr><td> <code>'i', '1i'</code> <br> </td><td> <code>int</code> <br> </td><td> <code>Number</code> <br> </td></tr><tr><td> <code>'f', '1f'</code> </td> <td> <code>float</code> <br> </td><td> <code>Number</code> <br> </td></tr><tr><td> <code>'v2'</code> <br> </td><td> <code>vec2</code> <br> </td><td> <code>THREE.Vector2</code> <br> </td></tr><tr><td> <code>'v3'</code> <br> </td><td> <code>vec3</code> <br> </td><td> <code>THREE.Vector3</code> <br> </td></tr><tr><td> <code>'c'</code> </td> <td> <code>vec3</code> <br> </td><td> <code>THREE.Color</code> <br> </td></tr><tr><td> <code>'v4'</code> </td> <td> <code>vec4</code> <br> </td><td> <code>THREE.Vector4</code> <br> </td></tr><tr><td> <code>'m3'</code> </td> <td> <code>mat3</code> <br> </td><td> <code>THREE.Matrix3</code> <br> </td></tr><tr><td> <code>'m4'</code> </td> <td> <code>mat4</code> <br> </td><td> <code>THREE.Matrix4</code> <br> </td></tr><tr><td> <code>'t'</code> </td> <td> <code>sampler2D</code> <br> </td><td> <code>THREE.Texture</code> <br> </td></tr><tr><td> <code>'t'</code> </td> <td> <code>samplerCube</code> <br> </td><td> <code>THREE.CubeTexture</code> </td> </tr></tbody></table>  To send it to the shader, modify the ShaderMaterial instance <code>ShaderMaterial</code> by adding a vector there: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({<span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>:uniforms,<span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>:shaderCode})</code> </pre> <br>  We haven't finished yet!  Now that the shader gets this variable, we need to do something with it.  Let's create a gradient like we did before: normalizing the coordinate and using it to create a color value. <br><br>  Change the shader code as follows: <br><br><pre> <code class="hljs ruby">uniform vec2 resolution;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      uniform- void main() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     vec2 pos = gl_FragCoord.xy / resolution.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ! gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,pos.x,pos.y,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  As a result, we get a beautiful gradient! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/bdoeMm" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  You can <a href="http://codepen.io/tutsplus/pen/bdoeMm">create a fork and edit the project</a> on CodePen. <br><br>  <strong>Task:</strong> Try to divide the screen into four equal parts of different colors.  Like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b6/dd0/454/6b6dd0454b0c552c42f9f59cd86ab035.png"><br><br><h4>  Step 4: Update Data </h4><br>  It's good that we learned to send data to the shader, but what if we need to update them?  For example, if you open the <a href="http://codepen.io/tutsplus/pen/bdoeMm" rel="external">previous example in a new tab</a> , and then resize the window, the gradient will not be updated, because it uses the old screen sizes. <br><br>  To update the variables usually just re-send the uniform variable.  However, in Three.js, it is enough just to update the <code>uniforms</code> object in the <code>render</code> function; you do not need to re-send data to the shader. <br><br>  Here's what the rendering function looks like after making changes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cube.rotation.y += <span class="hljs-number"><span class="hljs-number">0.02</span></span>; uniforms.resolution.value.x = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; uniforms.resolution.value.y = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; requestAnimationFrame( render ); renderer.render( scene, camera ); }</code> </pre> <br>  If you <a href="http://codepen.io/tutsplus/pen/MwEeBN" rel="external">open a new CodePen</a> and resize the window, you will see how the colors change, despite the fact that the original size of the viewing window remains the same).  The easiest way to notice this is by looking at the colors in the corners and making sure that they do not change. <br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sending data to a video processor is usually a costly task. </font><font style="vertical-align: inherit;">Sending several variables in one frame is quite normal, but when hundreds of variables are transmitted per frame, the frame rate will drop significantly. </font><font style="vertical-align: inherit;">It seems that this is unlikely, but if there are several hundred objects on the screen, and lighting with different properties is applied to all of them, then everything quickly goes out of control. </font><font style="vertical-align: inherit;">Later we will learn about shader optimization. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Try gradually changing colors.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 5: working with textures </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardless of the method of loading and the format of textures on all platforms, they are transmitted to the shader as uniform variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A quick note about uploading files to JavaScript: you can easily upload images from an external URL (this is how we will do it). </font><font style="vertical-align: inherit;">However, if you want to upload an image locally, you will encounter permissions problems, because JavaScript usually cannot and should not have access to files in the system. </font><font style="vertical-align: inherit;">The easiest way to solve this is </font></font><a href="https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to start a local Python server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is actually easier than it sounds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Three.js there is a small convenient function for loading an image as a texture:</font></font><br><br><pre> <code class="javascript hljs">THREE.ImageUtils.crossOrigin = <span class="hljs-string"><span class="hljs-string">''</span></span>;<span class="hljs-comment"><span class="hljs-comment">//     var tex = THREE.ImageUtils.loadTexture( "https://tutsplus.github.io/Beginners-Guide-to-Shaders/Part2/SIPI_Jelly_Beans.jpg" );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first line is given only once. </font><font style="vertical-align: inherit;">You can paste any image URL into it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we need to add a texture to the object </font></font><code>uniforms</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs">uniforms.texture = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-attr"><span class="hljs-attr">value</span></span>:tex};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, we need to declare a uniform variable in the shader code, and then draw it in the same way as we did before - using the function </font></font><code>texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> vec2 resolution; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D texture; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> pos = gl_FragCoord.xy / resolution.xy; <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(texture,pos); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A stretched candy image should appear on the screen: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/NqarME" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(This is a standard test image in computer graphics, it is taken from the </font></font><a href="http://sipi.usc.edu/database/database.php%3Fvolume%3Dmisc%26amp%3Bimage%3D7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Signal and Image Processing Institute (SIPI)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (therefore it shows the abbreviation IPI) University of Southern California. I think it suits us, because we are just studying graphic shaders!) </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task :</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Try gradually changing texture colors from full color to grayscale.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional step: apply shaders to other objects </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is nothing special about the plane we created. </font><font style="vertical-align: inherit;">We could apply a shader to the cube. </font><font style="vertical-align: inherit;">In fact, you can simply replace the line with the geometry of the plane:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PlaneGeometry( <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BoxGeometry( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voila, candy painted on a cube: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/QbqErY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can argue: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúWait, but this is not like the correct projection of the texture on the cube!‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You are right: if you look at the shader, you can see that we are actually telling him ‚Äúplace all the pixels of this image on the screen‚Äù. </font><font style="vertical-align: inherit;">The fact that they are on a cube simply means that all pixels outside of it are discarded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we wanted to apply the texture so that it looked physically painted on a cube, then our work would resemble the invention of the 3D engine again (which would be pretty stupid, considering that we already use the 3D engine and </font></font><a href="http://codepen.io/tutsplus/pen/mJmjog" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can just ask it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">draw the texture separately on each side). In this tutorial we use shaders for what would otherwise be impossible to achieve, so we will not go into such details. (If you want to learn more, Udacity has a </font></font><a href="https://www.udacity.com/course/interactive-3d-graphics--cs291" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">great course on the basics of 3D graphics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !)</font></font><br><br><h2>  Next steps </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, we can already do everything that we did in ShaderToy, but now we are able to use any textures and any objects on any platform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With all this freedom, we can do something like a lighting system, with realistic shadows and light sources. This we will do below. In addition, I will talk about shader optimization techniques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having mastered the basics of shaders, we will practically apply the power of the video processor to create realistic dynamic lighting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From this point on, we will consider general concepts of graphic shaders without reference to a specific platform. (For convenience, all code examples will still use JavaScript / WebGL.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, find a suitable way for you to perform shaders. </font><font style="vertical-align: inherit;">(JavaScript / WebGL is the easiest way, but I recommend you experiment with your favorite platform!)</font></font><br><br><h2>  Goals </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the end of this tutorial, you will not only begin to be well versed in lighting systems, but also create your own from scratch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here‚Äôs what the end result will look like (click the mouse to turn on the light):</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/RPYbqp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many game engines have ready-made lighting systems, but an understanding of how they are made and how to create your own gives you more opportunities to give the game a unique look. </font><font style="vertical-align: inherit;">In addition, the shader effects do not have to be only ‚Äúcosmetic‚Äù, they open the doors to stunning new game mechanics! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An excellent example of this is </font></font><a href="http://iamclaw.com/%3Fpage_id%3D15" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chroma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The player can run on dynamic shadows created in real time:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/G8-ivm3iuKc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Getting Started: Our Original Scene </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will miss a lot in the initial setup, because it is discussed in detail above. </font><font style="vertical-align: inherit;">Let's start with a simple fragmentary shader rendering our texture:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/eNLOba" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is nothing complicated going on here. </font><font style="vertical-align: inherit;">The JavaScript code sets the scene and sends the shader the texture for rendering and screen sizes.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = { <span class="hljs-attr"><span class="hljs-attr">tex</span></span> : {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-attr"><span class="hljs-attr">value</span></span>:texture},<span class="hljs-comment"><span class="hljs-comment">//  res : {type: 'v2',value:new THREE.Vector2(window.innerWidth,window.innerHeight)}//   }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the GLSL code, we declare and use these uniform variables: </font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D tex; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> vec2 res; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> pixel = gl_FragCoord.xy / res.xy; <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> color = texture2D(tex,pixel); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = color; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before using pixel coordinates for texture drawing, we normalize them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just to make sure you understand everything, here‚Äôs a small warm-up task for you: </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Render the texture without changing its aspect ratio (Try it yourself, we will look at the solution below.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It‚Äôs pretty obvious why the texture is stretched, but if it‚Äôs not clear then here‚Äôs a hint: look at the line where we normalize the coordinates:</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> pixel = gl_FragCoord.xy / res.xy;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We divide </font></font><code>vec2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>vec2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is analogous to dividing each individual component. </font><font style="vertical-align: inherit;">In other words, the above is equivalent to:</font></font><br><br><pre> <code class="hljs lisp">vec2 pixel = vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">; pixel.x = gl_FragCoord.x / res.x; pixel.y = gl_FragCoord.y / res.y;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We divide x and y into different numbers (by the width and height of the screen). </font><font style="vertical-align: inherit;">Naturally, the image will be stretched. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What happens if we divide x and y </font></font><code>gl_FragCoord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only by x </font></font><code>res</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Or just on y? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the sake of simplicity, in the tutorial we will leave the normalized code the same, it would be nice to figure out what is happening here.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 1: Add Light Source </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before you create something interesting, we need a light source. </font><font style="vertical-align: inherit;">The ‚Äúlight source‚Äù is simply a point transmitted to the shader. </font><font style="vertical-align: inherit;">For this point we will create a new uniform:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = { <span class="hljs-comment"><span class="hljs-comment">//    light: {type:'v3', value:new THREE.Vector3()}, tex : {type:'t',value:texture},//  res : {type: 'v2',value:new THREE.Vector2(window.innerWidth,window.innerHeight)}//   }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have created a vector with three dimensions, because we want to use </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source on the screen, and </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- as the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radius</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's assign JavaScript values ‚Äã‚Äãto our light source:</font></font><br><br><pre> <code class="javascript hljs">uniforms.light.value.z = <span class="hljs-number"><span class="hljs-number">0.2</span></span>;<span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will use the radius as a percentage of the screen size, so it </font></font><code>0.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be 20% of the screen. </font><font style="vertical-align: inherit;">(There is nothing special about this choice. We could set the size in pixels. This number doesn‚Äôt mean anything until we start doing something with it in the GLSL code.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get the mouse position, you just need to add an event receiver (event listener ):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,      uniforms.light.value.x = event.clientX; uniforms.light.value.y = event.clientY; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's now write the shader code to use this coordinate of the light source. </font><font style="vertical-align: inherit;">Let's start with a simple task: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let's make every pixel within the radius of the light source visible and the rest black</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On GLSL, this might look something like this:</font></font><br><br><pre> <code class="hljs ruby">uniform sampler2D tex; uniform vec2 res; uniform vec3 light;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     uniform! void main() { vec2 pixel = gl_FragCoord.xy / res.xy; vec4 color = texture2D(tex,pixel); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        float dist = distance(gl_FragCoord.xy,light.xy); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(light.z * res.x &gt; dist){<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,      gl_FragColor = color; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here we did the following: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Announced uniform light source. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We used the built-in </font></font><a href="http://www.shaderific.com/glsl-functions/" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">to calculate the distance between the light source and the current pixel.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check if this distance is longer (in pixels) 20% of the screen width; </font><font style="vertical-align: inherit;">if so, then return the color of the pixel, otherwise return the black.</font></font></li></ul><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/vOzBPx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Oops!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The light source follows the mouse in a strange way. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Can you fix it? </font><font style="vertical-align: inherit;">(Try to figure it out again before we solve this problem below.)</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correction of the movement of the light source </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You may remember that the Y axis is inverted here. </font><font style="vertical-align: inherit;">You can hurry to just enter:</font></font><br><br><pre> <code class="hljs">light.y = res.y - light.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is mathematically true, but if you do this, the shader will not compile! </font><font style="vertical-align: inherit;">The problem is that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uniform variables cannot be changed</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To understand why, you need to remember that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this code is executed for each individual pixel in parallel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Imagine that all processor cores try to change a single variable at the same time. </font><font style="vertical-align: inherit;">Bad situation! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can correct the error by creating a new variable instead of uniform. </font><font style="vertical-align: inherit;">Or even better - we can just take this step </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">before</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transferring the data to the shader:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/ZGMzPZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><pre> <code class="javascript hljs">uniforms.light.value.y = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight - event.clientY;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have successfully determined the apparent radius of our scene. </font><font style="vertical-align: inherit;">However, it looks too sharp ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add gradient </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of simply trimming to black outside the radius, let's try to create a smooth gradient at the edges. </font><font style="vertical-align: inherit;">You can do this with the help of the distance that we already calculate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of assigning all pixels within the radius of a texture color:</font></font><br><br><pre> <code class="hljs dos">gl_FragColor = <span class="hljs-built_in"><span class="hljs-built_in">color</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we can multiply it by the distance factor: </font></font><br><br><pre> <code class="hljs lisp">gl_FragColor = color * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - dist/(<span class="hljs-name"><span class="hljs-name">light</span></span>.z * res.x));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/RPYbOV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will work because </font></font><code>dist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is the distance in pixels between the current pixel and the light source. </font></font><code>(light.z * res.x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- is the length of the radius. </font><font style="vertical-align: inherit;">So when we look at a pixel exactly under the light source, it‚Äôs </font></font><code>dist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, we multiply </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and get the full color. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5de/436/abe/5de436abe8a4c068ae282ca07efabf87.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This figure is </font></font><code>dist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculated for an arbitrary pixel. </font></font><code>dist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes depending on which pixel we are in, and the value is </font></font><code>light.z * res.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constant. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we look at the pixel on the border of the circle, it </font></font><code>dist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal to the length of the radius, that is, as a result, we multiply </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and get the black color.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 2: Add Depth </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Until we did anything special, we just added a gradient mask to our texture. Everything still looks </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To understand how to fix it, let's see what the lighting system is doing now and compare it with what it </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/fb7/154/62dfb715455977869dccdccf21bc8aa6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case presented above, we should expect that point </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be lit most of all, because the light source is directly above it, and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be darker, because there are practically no rays on the sides. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this is what our lighting system sees now: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f80/186/7f2/f801867f208dbf2d2780b16795a6e6c5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All points are processed the same way, because the only factor that the system takes into account is the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distance on the xy plane.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You might think that we only need the height of each of these points, but this is not quite so. To understand why, consider this picture: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/e2e/b56/e51e2eb56f5f9cdfb88ef8cbc0c43df1.png"><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is at the top of the figure, and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are on the sides. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is another point on earth. We see that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should be the brightest, with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D being</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slightly darker because the light reaches it at an angle. On the other hand, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should be very dark, because they almost do not get the light, because they are directed from the light source. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The height is not as important as the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direction in which the surface is rotated</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It's called</font></font><em><a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C" rel="external"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surface </font><a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C" rel="external"><font style="vertical-align: inherit;">normal</font></a></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But how to pass this information to the shader? After all, we probably cannot transmit a huge array of thousands of numbers for each individual pixel? In fact, we do! Only we call it not an</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but a</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is what makes normal map: it simply is an image in which the values</font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each pixel represents no color, and direction.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e99/b5b/f01/e99b5bf01c18c4e92b33902a924ad58a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The picture above shows a simple normal map. If you use the eyedropper tool, we see that the default direction (‚Äúflat‚Äù) is represented by color.</font></font><code>(0.5, 0.5, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(blue color occupying most of the image). </font><font style="vertical-align: inherit;">This direction is pointing straight up. </font><font style="vertical-align: inherit;">The values ‚Äã‚Äãof x, y, and z are assigned to the values ‚Äã‚Äãof r, g, and b. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sloping side on the right is turned to the right, so its x value is higher. </font><font style="vertical-align: inherit;">The x value is also red, which is why the side looks a little reddish or pinkish. </font><font style="vertical-align: inherit;">The same applies to all other parties. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The map looks funny because it is not intended for rendering, it simply encodes the values ‚Äã‚Äãof the normals of these surfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's load this simple dough normal map:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normalURL = <span class="hljs-string"><span class="hljs-string">"https://raw.githubusercontent.com/tutsplus/Beginners-Guide-to-Shaders/master/Part3/normal_maps/normal_test.jpg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = THREE.ImageUtils.loadTexture(normalURL);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And add it as one of the uniform variables: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = { <span class="hljs-attr"><span class="hljs-attr">norm</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'t'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>:normal}, <span class="hljs-comment"><span class="hljs-comment">//..    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To check that we loaded it correctly, let's try rendering it instead of a texture, changing the code to GLSL (remember that at this stage we use just the background texture, not the normal map): </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/doqbBO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 3: Apply the Lighting Model </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have the surface normal data, we need to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implement a lighting model</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In other words, you need to tell the surface how to take into account all the factors available to calculate the final brightness. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest model to implement is </font></font><a href="http://content.gpwiki.org/index.php/D3DBook:(Lighting)_Blinn-Phong" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Phong model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Here's how it works: suppose we have a surface with normals data: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/448/a82/8aa448a822cb65e8050dd3a3ff6ad647.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We simply calculate the angle between the light source and the surface normal: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bfa/50d/a50/bfa50da50e28ec427f819d0afabb52de.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The smaller the angle, the brighter the pixel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that when a pixel is directly under the light source, where the angle difference is 0, it will be the brightest. The darkest pixels will point in the same direction as the light source (it will look like the back of an object).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's implement this model. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we are using a simple normal map for testing, let's fill the texture with a solid color to clearly understand whether everything works out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, instead of:</font></font><br><br><pre> <code class="hljs lisp">vec4 color = texture2D(...)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's make a solid white color (or any other color): </font></font><br><br><pre> <code class="hljs mel">vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a GLSL abbreviation for creation </font></font><code>vec4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with all components equal </font></font><code>1.0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the algorithm:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Get the normal vector of the current pixel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Get the vector of the direction of light. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normalize the vectors. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calculate the angle between them. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multiply the final color by this factor. </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Get the normal vector of the current pixel. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to know in which direction the surface ‚Äúlooks‚Äù so that we can calculate the amount of light falling on this pixel. </font><font style="vertical-align: inherit;">This direction is stored in the normal map, so getting the normal vector is to get the color of the current pixel in the normal texture:</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> NormalVector = texture2D(norm,pixel).xyz;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since the alpha value doesn‚Äôt mean anything on the normal map, we only need the first three components. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2. Get the vector of the direction of light </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to know in which direction the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">light</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> points </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can imagine that the illumination surface is a flashlight aimed at the screen at the point of the mouse cursor. </font><font style="vertical-align: inherit;">Therefore, you can calculate the vector of the direction of light simply by using the distance between the light source and the pixel:</font></font><br><br><pre> <code class="hljs lisp">vec3 LightVector = vec3(<span class="hljs-name"><span class="hljs-name">light</span></span>.x - gl_FragCoord.x,light.y - gl_FragCoord.y,<span class="hljs-number"><span class="hljs-number">60.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It must also have a Z coordinate (so that it is possible to calculate the angle relative to the three-dimensional vector of the surface normal). </font><font style="vertical-align: inherit;">You can experiment with this value. </font><font style="vertical-align: inherit;">You will notice that the smaller it is, the sharper is the contrast between bright and dark areas. </font><font style="vertical-align: inherit;">One can imagine that this is the height of the flashlight above the stage: the farther it is, the more evenly the light spreads.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Normalize the vectors </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we need to normalize: </font></font><br><br><pre> <code class="hljs lisp">NormalVector = normalize(<span class="hljs-name"><span class="hljs-name">NormalVector</span></span>)<span class="hljs-comment"><span class="hljs-comment">; LightVector = normalize(LightVector);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for both vectors to have length </font></font><code>1.0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will use the </font></font><a href="http://www.shaderific.com/glsl-functions/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalize</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> built-in function </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is necessary because we want to calculate the angle using the </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dot product</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you do not really understand how it works, then you should study linear algebra a little. </font><font style="vertical-align: inherit;">For our purposes, we only need to know that the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scalar product returns the cosine of the angle between vectors of the same length</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Calculate the angle between the vectors </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's do this with the built-in </font></font><a href="http://www.shaderific.com/glsl-functions/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs lisp">float diffuse = dot( <span class="hljs-name"><span class="hljs-name">NormalVector</span></span>, LightVector )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I called the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diffuse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">because this term is used in the Phong lighting model, because it determines the amount of light that reaches the surface of the scene.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Multiply the final color by this factor. </font></font></h4><br>  That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now multiply the color by the value. </font><font style="vertical-align: inherit;">I created a variable </font></font><code>distanceFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to make our equation easier to read:</font></font><br><br><pre> <code class="hljs lisp">float distanceFactor = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - dist/(<span class="hljs-name"><span class="hljs-name">light</span></span>.z * res.x)); gl_FragColor = color * diffuse * distanceFactor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we got a working lighting model! </font><font style="vertical-align: inherit;">(Try increasing the radius of the light source so that the effect is more noticeable.)</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/yNxBmw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, it seems something is wrong. </font><font style="vertical-align: inherit;">It seems that the source is somehow inclined. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at our calculations again. </font><font style="vertical-align: inherit;">We have a vector of light:</font></font><br><br><pre> <code class="hljs lisp">vec3 LightVector = vec3(<span class="hljs-name"><span class="hljs-name">light</span></span>.x - gl_FragCoord.x,light.y - gl_FragCoord.y,<span class="hljs-number"><span class="hljs-number">60.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Which, as we know, will give us </font></font><code>(0, 0, 60)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when the light source is above the current pixel. After normalization, it will be equal </font></font><code>(0, 0, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget that for maximum brightness we need a normal, directed strictly upwards, towards the light source. The default surface normal, upward, is </font></font><code>(0.5, 0.5, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do you understand what the solution is? Can you implement it? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem is that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the texture as the color values ‚Äã‚Äãcan not be stored negative values</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is impossible to denote a vector directed to the left as </font></font><code>(-0.5, 0, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Therefore, when creating normal maps, you need to add to everything</font></font><code>0.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Or, to put it more generally, you need to shift the coordinate system). </font><font style="vertical-align: inherit;">You need to understand this in order to know that before using the map you need to subtract from each pixel </font></font><code>0.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here‚Äôs what the demo looks like after subtracting the </font></font><code>0.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal vector from the x and y coordinates:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/qdMBBN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to make one more fix. </font><font style="vertical-align: inherit;">Remember that the dot product returns the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cosine of an</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angle. </font><font style="vertical-align: inherit;">This means that the output is limited to the interval from -1 to 1. Color values ‚Äã‚Äãcannot be negative, and since WebGL automatically discards negative values, in some cases the behavior will be strange. </font><font style="vertical-align: inherit;">To solve this problem, you can use the built-in </font></font><a href="http://www.shaderific.com/glsl-functions/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">and turn it into:</font></font><br><br><pre> <code class="hljs lisp">float diffuse = dot( <span class="hljs-name"><span class="hljs-name">NormalVector</span></span>, LightVector )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  in it: <br><br><pre> <code class="hljs lisp">float diffuse = max(<span class="hljs-name"><span class="hljs-name">dot</span></span>( <span class="hljs-name"><span class="hljs-name">NormalVector</span></span>, LightVector ),<span class="hljs-number"><span class="hljs-number">0.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we have a working lighting model! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can put a stone texture on the background, and take the real normal map in the </font></font><a href="https://github.com/tutsplus/Beginners-Guide-to-Shaders/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repository of this tutorial on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (namely </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We just need to change one line in JavaScript, with:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normalURL = <span class="hljs-string"><span class="hljs-string">"https://raw.githubusercontent.com/tutsplus/Beginners-Guide-to-Shaders/master/Part3/normal_maps/normal_test.jpg"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normalURL = <span class="hljs-string"><span class="hljs-string">"https://raw.githubusercontent.com/tutsplus/Beginners-Guide-to-Shaders/master/Part3/normal_maps/blocks_normal.JPG"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And one line on GLSL: </font></font><br><br><pre> <code class="hljs mel">vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>);<span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We no longer need a solid white color, we will load the real texture, like this: </font></font><br><br><pre> <code class="hljs lisp">vec4 color = texture2D(<span class="hljs-name"><span class="hljs-name">tex</span></span>,pixel)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And here is the final result: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/RPYbqp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimization Tips </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The video processor performs its work very effectively, but it is very important to know what can slow it down. </font></font> Here are some tips: <br><br><h3>  Branching </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In shaders, it is usually desirable to avoid </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">branching</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> whenever possible </font><font style="vertical-align: inherit;">. Although a large number of designs are </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rarely a problem in any code for the CPU, in shaders for a video processor they can become a bottleneck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To understand why, it is worth remembering again that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the GLSL code is executed for each pixel on the screen in parallel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A graphics card can perform many optimizations based on the fact that all pixels need to perform the same operations. However, if there is a heap in the code </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then some optimizations will not be possible, because now different code is executed for different pixels. Will there be designs</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slowing down or not depends on the implementation on the specific hardware and in the graphics card, but remember this if you want to speed up the shader. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deferred rendering </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a very useful concept when working with lighting. </font><font style="vertical-align: inherit;">Imagine that we need two sources of illumination, or three, or ten. </font><font style="vertical-align: inherit;">We will have to calculate the angle between each surface normal and each point of the light source. </font><font style="vertical-align: inherit;">As a result, the shader will run at snooty speed. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deferred rendering</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a way to optimize such a process by splitting the work of the shader into several passes. </font></font><a href="http://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> explaining in detail what this means. </font><font style="vertical-align: inherit;">I will quote an important part for us:</font></font><br><br><blockquote>  ‚Äî        .                  <strong><em>     </em></strong> . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, instead of transferring an array of points of light sources, you can draw them onto textures in the form of circles, the color of each pixel of which will represent the intensity of illumination. </font><font style="vertical-align: inherit;">In this way, we can calculate the combined effect of all sources of lighting in the scene, and then simply transfer it to the final texture (or buffer, as it is sometimes called) to calculate the lighting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to divide work into several passes is a very useful technique when creating shaders. </font><font style="vertical-align: inherit;">For example, it is used to accelerate the shader when calculating the blur effect, as well as in fluid / smoke shaders.</font></font><br><br><h2>  Next steps </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now that you have a working lighting shader, here‚Äôs something else you can experiment with: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Try changing the height (value </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) of the light vector to observe its effect.</font></font></li><li>    . (  ,   diffuse  .) </li><li>       <em>ambient</em> ( ). ( ,     ,           .      ,        ,        ) </li><li>      <a href="http://gamedevelopment.tutsplus.com/tutorials/building-shaders-with-babylonjs-and-webgl-theory-and-examples--cms-24146">  WebGL</a> .    Babylon.js,    Three.js,      ,   GLSL.  ,    -    . </li><li>    <a href="http://glslsandbox.com/">GLSL Sandbox</a>  <a href="https://www.shadertoy.com/">ShaderToy</a> <br></li></ul><br><h2>  Links </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stone texture and normal map for this tutorial are taken from OpenGameArt: </font></font><a href="http://opengameart.org/content/50-free-textures-4-normalmaps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://opengameart.org/content/50-free-textures-4-normalmaps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many programs to help create normal maps. </font><font style="vertical-align: inherit;">If you are interested in learning more about creating your own normal maps, then </font></font><a href="http://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-a-normal-map--gamedev-3893"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can help </font><font style="vertical-align: inherit;">.</font></font></div><p>Source: <a href="https://habr.com/ru/post/333002/">https://habr.com/ru/post/333002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332990/index.html">Linux Foundation Unveils Free Kubernetes Introductory Online Course</a></li>
<li><a href="../332992/index.html">7 ways to improve the design of the site</a></li>
<li><a href="../332994/index.html">Testing in Openshift: An Introduction</a></li>
<li><a href="../332998/index.html">ES8: major innovations</a></li>
<li><a href="../333000/index.html">IBM has created a new generation of carbon nanotube transistors</a></li>
<li><a href="../333006/index.html">Noty.js V3 is a smart javascript library for creating notifications. And also a ready plugin for vuejs</a></li>
<li><a href="../333008/index.html">Doctor Web: gosuslugi.ru portal has been compromised and may begin to infect visitors or steal information</a></li>
<li><a href="../333012/index.html">Testing in Openshift: Internal cluster structure</a></li>
<li><a href="../333014/index.html">Testing in Openshift: Automated Testing</a></li>
<li><a href="../333016/index.html">Delhi - cut, or as we did mobile 2GIS Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>