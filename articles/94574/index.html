<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ruby Threading</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the Multithreading chapter by David Thomas and Andrew Hunt Programming Ruby: The Pragmatic Programmers' Guide, Second Edition. 

 Often...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ruby Threading</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation of the Multithreading chapter by David Thomas and Andrew Hunt Programming Ruby: The Pragmatic Programmers' Guide, Second Edition.</i> <br><br>  Often the easiest way to do two things at the same time is to use threads in Ruby.  They are in-process, embedded in the Ruby interpreter.  This makes Ruby threads fully portable, i.e.  independent of the operating system.  But at the same time, you will definitely not benefit from the use of native, native streams.  What does it mean? <br><br>  You may experience starvation ( <a href="http://java.sun.com/docs/books/tutorial/essential/concurrency/starvelive.html">thread starvation</a> is when a thread with a small priority has no chance to start).  If you want to block your threads, then the whole process will stop with a screech.  And if a situation arises that some threads will send calls to the operating system, which require a considerable amount of time to complete, then all threads will hang until the interpreter gets control back.  Finally, if your machine has more than one processor, Ruby threads will not use it, because  they run in the same process, and in a single native thread they will be forced to run on the same processor at a time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It all sounds scary.  However, in practice, in many cases, the benefits of using threads largely outweigh any potential problems that may arise.  Ruby streams are an efficient and easy way to achieve concurrency in your code.  You just have to understand the basic problems of implementation, and, accordingly, the architecture. <br><a name="habracut"></a><br><h4>  Creating Ruby Threads </h4><br>  Creating a new thread is pretty straightforward.  The following code is a simple example.  He simultaneously downloads a set of Web pages.  For each URL requested for download, the code creates a separate stream that controls the HTTP transaction. <br><br><blockquote><code><font color="#008000">require</font> <font color="#BA2121">'net/http'</font> <br> pages <font color="#666666">=</font> <font color="#008000">%w( www.rubycentral.com slashdot.org www.google.com )</font> <br> threads <font color="#666666">=</font> <font color="#666666">[]</font> <br> <font color="#008000"><strong>for</strong></font> page_to_fetch <font color="#008000"><strong>in</strong></font> pages <br> threads <font color="#666666">&lt;&lt;</font> <font color="#880000">Thread</font> <font color="#666666">.</font> new(page_to_fetch) <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> url <font color="#666666">|</font> <br> h <font color="#666666">=</font> <font color="#880000">Net</font> <font color="#666666">::</font> <font color="#880000">HTTP</font> <font color="#666666">.</font> new(url, <font color="#666666">80</font> ) <br> <font color="#008000">puts</font> <font color="#BA2121">"Fetching:</font> <font color="#BB6688"><strong>#{</strong></font> url <font color="#BB6688"><strong>}</strong></font> <font color="#BA2121">"</font> <br> resp <font color="#666666">=</font> h <font color="#666666">.</font> get( <font color="#BA2121">'/'</font> , <font color="#008000">nil</font> ) <br> <font color="#008000">puts</font> <font color="#BA2121">"Got</font> <font color="#BB6688"><strong>#{</strong></font> url <font color="#BB6688"><strong>}</strong></font> <font color="#BA2121">:</font> <font color="#BB6688"><strong>#{</strong></font> resp <font color="#666666">.</font> message <font color="#BB6688"><strong>}</strong></font> <font color="#BA2121">"</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> threads <font color="#666666">.</font> each { <font color="#666666">|</font> thr <font color="#666666">|</font> thr <font color="#666666">.</font> join }</code> </blockquote> <br><br>  Result: <br><pre>  Fetching: www.rubycentral.com
 Fetching: slashdot.org
 Fetching: www.google.com
 Got www.google.com: OK
 Got www.rubycentral.com: OK
 Got slashdot.org: OK </pre><br><br>  Let's take a closer look at this code: here are a few subtle points.  New threads are created by calling Thread.new.  This sets the block containing the code to be executed in the new thread.  In our case, the block uses the net / http library to extract the main page of the specified sites.  Our trace clearly shows that these extracts are performed in parallel. <br><br>  When we create a stream, we specify the required URL as a parameter.  This parameter is passed to the block as a variable url.  Why do we do this when it would be easier to use the value of the page_to_fetch variable inside the block? <br><br>  A thread shares all global, instance variables, and local variables that are available at the time the thread starts.  Anyone with a younger brother can tell you that sharing or sharing is not always a good thing.  In this case, all three threads will share the page_to_fetch variable.  When the first thread starts, page_to_fetch takes the value ‚Äú <a href="http://www.rubycentral.com/">www.rubycentral.com</a> ‚Äù.  Meanwhile, the thread-creating loop is still working.  At the next point in time, page_to_fetch is set to slashdot.org.  If the first thread has not yet finished using the page_to_fetch variable, then it will suddenly start using its new value.  This kind of error is very difficult to track down. <br><br>  However, local variables created inside a stream block are truly local to this stream ‚Äî each thread will have its own copy of the page address.  You can specify any number of arguments in a block using Thread.new. <br><br><h5>  Flow control </h5><br>  Another subtlety occurs on the last line of our program.  Why do we call join for each thread we create? <br><br>  When the Ruby program terminates, all threads are killed, despite their state.  However, you can wait for the completion of a single thread by calling the Thread # join method.  The calling thread is blocked until the current thread ends.  By calling join for each thread, you can be sure that all three queries will be executed before the end of the main program.  If you do not want to block the stream permanently, you can pass a time limit parameter to the join ‚Äî if this limit ends before the end of the stream, the call to join will return the value nil.  Another join option is the Thread # value method, which returns the value of the last operation performed on the thread. <br><br>  In addition to join, several other convenient operations are used to control threads.  Access to the current thread can always be obtained using Thread.current.  You can get a list of all threads using Thread.list, which returns a list of all Thread objects: both working and stopped.  To determine the status of a separate thread, you can use Thread # status and Thread # alive ?. <br>  Additionally, you can set the thread priority using Thread # priority =.  Higher priority threads will run before lower priority threads.  We will talk a little later about scheduling of threads, as well as their start and stop. <br><br><h5>  Flow variables </h5><br>  A thread has normal access to all variables that are in scope at the time of its launch.  Local variables of a block containing a stream code are local to the stream itself and are not shared with each other. <br><br>  But what to do, if you need such variables in the stream, over which you could have access from other streams ‚Äî to include them in the main stream?  A characteristic feature of the class Thread is a special feature that allows you to create and have access by name to the local variables of the stream.  You simply treat the stream object as a hash, setting the values ‚Äã‚Äãof the elements with [] = and reading them with [].  In the following example, each thread writes the current value of the counter to the local variable of the stream with the key mycount.  To accomplish this, the code uses the string "mycount" as an index of the stream object. <br><br><blockquote> <code>count <font color="#666666">=</font> <font color="#666666">0</font> <br> threads <font color="#666666">=</font> <font color="#666666">[]</font> <br> <font color="#666666">10.</font> times <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> i <font color="#666666">|</font> <br> threads <font color="#666666">[</font> i <font color="#666666">]</font> <font color="#666666">=</font> <font color="#880000">Thread</font> <font color="#666666">.</font> new <font color="#008000"><strong>do</strong></font> <br> <font color="#008000">sleep</font> ( <font color="#008000">rand</font> ( <font color="#666666">0.1</font> )) <br> <font color="#880000">Thread</font> <font color="#666666">.</font> current <font color="#666666">[</font> <font color="#BA2121">"mycount"</font> <font color="#666666">]</font> <font color="#666666">=</font> count <br> count <font color="#666666">+=</font> <font color="#666666">1</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> threads <font color="#666666">.</font> each { <font color="#666666">|</font> t <font color="#666666">|</font> t <font color="#666666">.</font> join; <font color="#008000">print</font> t <font color="#666666">[</font> <font color="#BA2121">"mycount"</font> <font color="#666666">]</font> , <font color="#BA2121">", "</font> } <br> <font color="#008000">puts</font> <font color="#BA2121">"count =</font> <font color="#BB6688"><strong>#{</strong></font> count <font color="#BB6688"><strong>}</strong></font> <font color="#BA2121">"</font> <br></code> </blockquote><br><br>  Result: <br><pre>  4, 1, 0, 8, 7, 9, 5, 6, 3, 2, count = 10 </pre><br><br>  The main thread waits for the remaining threads to complete, and then displays the counter values ‚Äã‚Äãcaptured by each thread.  For interest, we added a random delay to each stream before writing the counter value. <br><br><h4>  Threads and Exceptions </h4><br>  What happens if an unhandled exception occurs in the stream?  It depends on the value of the abort_on_exception flag and on the value of the interpreter's debug flag. <br>  If abort_on_exception = false and the debug flag is not enabled (the default state), then an unhandled exception will simply kill the current thread, and all others will continue their work.  In reality, you don't even know anything about the exception, until the thread that threw this exception is called join. <br><br>  In the following example, stream 2 swells and cannot output anything.  However, you can still see the trace of the rest of the streams. <br><br><blockquote> <code>threads <font color="#666666">=</font> <font color="#666666">[]</font> <br> <font color="#666666">4.</font> times <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> number <font color="#666666">|</font> <br> threads <font color="#666666">&lt;&lt;</font> <font color="#880000">Thread</font> <font color="#666666">.</font> new(number) <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> i <font color="#666666">|</font> <br> <font color="#008000"><strong>raise</strong></font> <font color="#BA2121">"Boom!"</font> <font color="#008000"><strong>if</strong></font> i <font color="#666666">==</font> <font color="#666666">2</font> <br> <font color="#008000">print</font> <font color="#BA2121">"</font> <font color="#BB6688"><strong>#{</strong></font> i <font color="#BB6688"><strong>}</strong></font> <font color="#BB6622"><strong>\n</strong></font> <font color="#BA2121">"</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> threads <font color="#666666">.</font> each { <font color="#666666">|</font> t <font color="#666666">|</font> t <font color="#666666">.</font> join } <br></code> </blockquote><br><br>  Result: <br><pre>  0 
 one
 3
 prog.rb: 4: Boom!  (RuntimeError)
 from prog.rb: 8: in `join '
 from prog.rb: 8
 from prog.rb: 8: in `each '
 from prog.rb: 8 </pre><br><br>  We can catch an exception at join time. <br><blockquote> <code>threads <font color="#666666">=</font> <font color="#666666">[]</font> <br> <font color="#666666">4.</font> times <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> number <font color="#666666">|</font> <br> threads <font color="#666666">&lt;&lt;</font> <font color="#880000">Thread</font> <font color="#666666">.</font> new(number) <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> i <font color="#666666">|</font> <br> <font color="#008000"><strong>raise</strong></font> <font color="#BA2121">"Boom!"</font> <font color="#008000"><strong>if</strong></font> i <font color="#666666">==</font> <font color="#666666">2</font> <br> <font color="#008000">print</font> <font color="#BA2121">"</font> <font color="#BB6688"><strong>#{</strong></font> i <font color="#BB6688"><strong>}</strong></font> <font color="#BB6622"><strong>\n</strong></font> <font color="#BA2121">"</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> threads <font color="#666666">.</font> each <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> t <font color="#666666">|</font> <br> <font color="#008000"><strong>begin</strong></font> <br> t <font color="#666666">.</font> join <br> <font color="#008000"><strong>rescue</strong></font> <font color="#880000">RuntimeError</font> <font color="#666666">=&gt;</font> e <br> <font color="#008000">puts</font> <font color="#BA2121">"Failed:</font> <font color="#BB6688"><strong>#{</strong></font> e <font color="#666666">.</font> message <font color="#BB6688"><strong>}</strong></font> <font color="#BA2121">"</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br></code> </blockquote><br><br>  Result: <br><pre>  0
 one
 3 
 Failed: Boom! </pre><br>  However, if you set abort_on_exception to true or use -d to disable the debug flag, an unhandled exception will kill all running threads.  As soon as stream 2 dies, no more output will be made. <br><br><blockquote> <code><font color="#880000">Thread</font> <font color="#666666">.</font> abort_on_exception <font color="#666666">=</font> <font color="#008000">true</font> <br> threads <font color="#666666">=</font> <font color="#666666">[]</font> <br> <font color="#666666">4.</font> times <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> number <font color="#666666">|</font> <br> threads <font color="#666666">&lt;&lt;</font> <font color="#880000">Thread</font> <font color="#666666">.</font> new(number) <font color="#008000"><strong>do</strong></font> <font color="#666666">|</font> i <font color="#666666">|</font> <br> <font color="#008000"><strong>raise</strong></font> <font color="#BA2121">"Boom!"</font> <font color="#008000"><strong>if</strong></font> i <font color="#666666">==</font> <font color="#666666">2</font> <br> <font color="#008000">print</font> <font color="#BA2121">"</font> <font color="#BB6688"><strong>#{</strong></font> i <font color="#BB6688"><strong>}</strong></font> <font color="#BB6622"><strong>\n</strong></font> <font color="#BA2121">"</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> threads <font color="#666666">.</font> each { <font color="#666666">|</font> t <font color="#666666">|</font> t <font color="#666666">.</font> join } <br></code> </blockquote><br><br>  Result: <br><pre>  0
 one
 prog.rb: 5: Boom!  (RuntimeError)
 from prog.rb: 4: in `initialize '
 from prog.rb: 4: in `new '
 from prog.rb: 4
 from prog.rb: 3: in `times'
 from prog.rb: 3 </pre><br><br>  This example also illustrates a glitch.  Inside the loop, it is preferable to use print to print a number than puts.  Why?  Because puts secretly breaks its work into two components: it prints its argument, and then prints the newline character.  Between the two, a stream may start, and the output will alternate.  By calling print of a single line that already contains a newline character, we can work around this problem. <br><br><h4>  Flow Scheduler Management </h4><br>  In a well-designed application, you just let the threads do their work.  Creating time dependencies in a multithreaded application is usually considered bad form because  this makes the code much harder to read, and also makes it impossible to optimize the execution of your program by the thread scheduler. <br><br>  However, sometimes you will need to manage threads explicitly.  For example, a jukebox featuring light music.  We have to stop it at the time when the music stops.  You can use two streams in the form of a producer-consumer scheme, where the consumer must wait if the manufacturer has incomplete orders. <br><br>  The Thread class provides a set of methods for managing the thread scheduler.  A call to Thread.stop stops the current thread, and a call to Thread # run starts a separate thread.  Thread.pass starts the scheduler to transfer execution to another thread, and Thread # join and Thread # value pauses the calling thread until the specified threads are completed. <br><br>  We can demonstrate this feature in the next completely meaningless program.  It creates two child threads: t1 and t2, each of which is an instance of the class Chaser.  The chase method increments the counter, but does not allow it to become larger than two compared to the counter in another thread.  To stop this increase, the method calls Thread.pass, which allows the chase method to start in another thread.  For the interest, we immediately after the start suspend the threads, and then randomly start. <br><br><blockquote> <code><font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>Chaser</strong></font> <br> <font color="#008000">attr_reader</font> <font color="#19177C">:count</font> <br> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">initialize</font> ( <font color="#008000">name</font> ) <br> <font color="#19177C">@name</font> <font color="#666666">=</font> <font color="#008000">name</font> <br> <font color="#19177C">@count</font> <font color="#666666">=</font> <font color="#666666">0</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">chase</font> (other) <br> <font color="#008000"><strong>while</strong></font> <font color="#19177C">@count</font> <font color="#666666">&lt;</font> <font color="#666666">5</font> <br> <font color="#008000"><strong>while</strong></font> <font color="#19177C">@count</font> <font color="#666666">-</font> other <font color="#666666">.</font> count <font color="#666666">&gt;</font> <font color="#666666">1</font> <br> <font color="#880000">Thread</font> <font color="#666666">.</font> pass <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#19177C">@count</font> <font color="#666666">+=</font> <font color="#666666">1</font> <br> <font color="#008000">print</font> <font color="#BA2121">"</font> <font color="#BB6688"><strong>#@name</strong></font> <font color="#BA2121">:</font> <font color="#BB6688"><strong>#{</strong></font> count <font color="#BB6688"><strong>}</strong></font> <font color="#BB6622"><strong>\n</strong></font> <font color="#BA2121">"</font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> <font color="#008000"><strong>end</strong></font> <br> <br> c1 <font color="#666666">=</font> <font color="#880000">Chaser</font> <font color="#666666">.</font> new( <font color="#BA2121">"A"</font> ) <br> c2 <font color="#666666">=</font> <font color="#880000">Chaser</font> <font color="#666666">.</font> new( <font color="#BA2121">"B"</font> ) <br> threads <font color="#666666">=</font> <font color="#666666">[</font> <br> <font color="#880000">Thread</font> <font color="#666666">.</font> new { <font color="#880000">Thread</font> <font color="#666666">.</font> stop; c1 <font color="#666666">.</font> chase(c2) }, <br> <font color="#880000">Thread</font> <font color="#666666">.</font> new { <font color="#880000">Thread</font> <font color="#666666">.</font> stop; c2 <font color="#666666">.</font> chase(c1) } <br> <font color="#666666">]</font> <br> start_index <font color="#666666">=</font> <font color="#008000">rand</font> ( <font color="#666666">2</font> ) <br> threads <font color="#666666">[</font> start_index <font color="#666666">].</font> run <br> threads <font color="#666666">[1</font> <font color="#666666">-</font> start_index <font color="#666666">].</font> run <br> threads <font color="#666666">.</font> each { <font color="#666666">|</font> t <font color="#666666">|</font> t <font color="#666666">.</font> join } <br></code> </blockquote><br><br>  Result: <br><pre>  B: 1
 B: 2
 A: 1
 B: 3
 A: 2
 B: 4
 A: 3
 B: 5
 A: 4
 A: 5 </pre><br><br>  However, it is not so easy to use such elementary actions to achieve synchronization in real code - the state of the races will constantly haunt you.  And when you work with general data, the state of racing guarantees you a long and disappointing debugging.  In fact, the previous example contains an error: it is possible to increment a counter in one thread, but before displaying its value, another thread starts and displays the value of its counter.  As a result, the output will be in the wrong order. <br><br>  Fortunately, streams have one additional possibility - the idea of ‚Äã‚Äãmutual exclusion (mutual exclusion).  Using this, we can create secure synchronization schemes. </div><p>Source: <a href="https://habr.com/ru/post/94574/">https://habr.com/ru/post/94574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../94569/index.html">Nigma learned to draw graphics</a></li>
<li><a href="../94570/index.html">Unfair game 1freehost or how in our time are gaining customers</a></li>
<li><a href="../94571/index.html">New indicators of the percentage of download on the tabs of the future Firefox tabs</a></li>
<li><a href="../94572/index.html">The first augmented reality system for Android navigators</a></li>
<li><a href="../94573/index.html">Yandex. Direct. Props or how to ruin a competitor</a></li>
<li><a href="../94577/index.html">IrDA 2.0. "Love is on the wire," and the Internet on LEDs</a></li>
<li><a href="../94579/index.html">NSA publishes the history of computers used in the agency before 1964</a></li>
<li><a href="../94580/index.html">Three releases of Ruby on Rails in three days</a></li>
<li><a href="../94581/index.html">Naked motherboards and network cards - equipment provider "Apanet"</a></li>
<li><a href="../94582/index.html">Google Wave is now available for Google Apps.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>