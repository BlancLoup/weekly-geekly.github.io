<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Machine learning with Node.js using the Tensorflow.js library</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone, colleagues! 

 Perhaps the fans of the Tensorflow library, who have already noticed this book in pre-order, also looked closely at the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Machine learning with Node.js using the Tensorflow.js library</h1><div class="post__text post__text-html js-mediator-article">  Hello everyone, colleagues! <br><br>  Perhaps the fans of the Tensorflow library, who have already noticed <a href="https://www.piter.com/product_by_id/124311707">this book</a> in pre-order, also looked closely at the possibilities of machine and in-depth training in the browser, especially since the topic was <a href="https://www.manning.com/books/deep-learning-with-javascript">not overlooked</a> by <a href="https://www.piter.com/collection/all/product/glubokoe-obuchenie-na-python">Francois Chollet</a> himself.  We invite those interested in the cat section, where it is described how images are recognized using the Tensorflow.js library. <br><a name="habracut"></a><br>  <a href="https://js.tensorflow.org/">TensorFlow.js</a> is a new version of the popular open source library that enriches the JavaScript language with deep learning capabilities.  Developers can now define, train, and run models using the <a href="https://js.tensorflow.org/api/0.12.0/">high-level library API</a> . <br><br>  Thanks to <a href="https://github.com/tensorflow/tfjs-models/">pre-trained models,</a> developers can now easily solve such complex tasks as <a href="https://emojiscavengerhunt.withgoogle.com/">pattern recognition</a> , <a href="https://magenta.tensorflow.org/demos/performance_rnn/index.html">music generation,</a> or <a href="https://storage.googleapis.com/tfjs-models/demos/posenet/camera.html">defining human poses in</a> just a few lines of JavaScript. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Tensorflow.js started as a front-end browser library, but this year <a href="https://github.com/tensorflow/tfjs-node">experimental support for</a> Node.js was added to it.  Thus, TensorFlow.js can be used in JavaScript backend applications, which completely eliminates the need to resort to Python. <br><br>  <i>Reading about this library, I decided to try it on a simple task ...</i> <br><blockquote>  Use TensorFlow.js to visually recognize patterns on images when using JavaScript from Node.js </blockquote>  Unfortunately, the <a href="https://js.tensorflow.org/">documentation</a> and <a href="https://js.tensorflow.org/tutorials/webcam-transfer-learning.html">code samples</a> basically describe the use of this library in the browser. <a href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet">Project utilities</a> designed to simplify the loading and use of pre-trained models at the time of this writing did not yet support Node.js.  I had to spend a lot of time to thoroughly read the Typescript sources for this library. <br><br>  However, after a few days of chiselling, I did <a href="https://gist.github.com/jthomas/145610bdeda2638d94fab9a397eb1f1d">it</a> anyway!  Hooray! <br><br>  <i>Before turning to a detailed analysis of the code, let's talk about other implementations of the TensorFlow library.</i> <br><br>  <b>Tensorflow</b> <br><br>  <a href="https://www.tensorflow.org/">TensorFlow</a> is a free software library for machine learning applications.  TensorFlow can be used to create neural networks and implement other deep learning algorithms. <br><br>  This library, released by Google in November 2015, was originally <a href="https://www.tensorflow.org/api_docs/python/">written in Python</a> .  In order to train and evaluate the models created in it, calculations on a CPU or GPU are applied.  Initially, this library was created to work on high-performance servers using resource-intensive GPUs. <br><br>  Recent updates have made it possible to optimize this library and use it in environments with more limited resources ‚Äî for example, on mobile devices and in web browsers. <br><br>  <b>TensorFlow Lite</b> <br><br>  <a href="https://www.tensorflow.org/lite/">Tensorflow Lite</a> , a lightweight version of this library for mobile and embedded systems, was released in May 2017.  Along with it, a new set of pre-trained deep models for problems related to pattern recognition is provided;  This collection is called <a href="https://ai.googleblog.com/2017/06/mobilenets-open-source-models-for.html">MobileNet</a> .  MobileNet models have been designed specifically to work effectively in environments with limited resources, such as mobile devices. <br><br>  TensorFlow.js <br><br>  Following Tensorflow Lite in March 2018, TensorFlow.js was <a href="https://medium.com/tensorflow/introducing-tensorflow-js-machine-learning-in-javascript-bf3eab376db">announced</a> .  This version of the library is designed to work in the browser and is based on an earlier project called <a href="https://twitter.com/deeplearnjs">deeplearn.js</a> .  WebGL provides GPU library access.  Developers use the JavaScript API to train, load, and run models. <br><br>  Later TensorFlow.js was extended to work with Node.js, for this the <a href="https://github.com/tensorflow/tfjs-node">library add</a> <code>tfjs-node</code> <a href="https://github.com/tensorflow/tfjs-node">on</a> <code>tfjs-node</code> . <br><br>  <b>Import existing models in TensorFlow.js</b> <br><br>  TensorFlow and Keras ready-made models can be implemented using the TensorFlow.js library.  Before running the model, you need to translate into a new format with <a href="https://github.com/tensorflow/tfjs-converter">this tool</a> .  Pre-trained and transformed models for image classification, posturing and k-nearest-neighbor detection <a href="https://github.com/tensorflow/tfjs-models">are available on Github</a> . <br><br>  <b>Using TensorFlow.js with Node.js</b> <br><br>  Installing TensorFlow libraries <br><br>  TensorFlow.js can be installed from the <a href="https://www.npmjs.com/">NPM registry</a> . <br><br><ul><li>  <code>@tensorflow/tfjs</code> - <a href="https://www.npmjs.com/package/%40tensorflow/tfjs">Core TensorFlow.js Library</a> </li><li>  <code>@tensorflow/tfjs-node</code> - <a href="https://www.npmjs.com/package/%40tensorflow/tfjs-node">TensorFlow.js Node.js</a> extension </li><li>  <code>@tensorflow/tfjs-node-gpu</code> - <a href="https://www.npmjs.com/package/%40tensorflow/tfjs-node-gpu">TensorFlow.js Node.js</a> extension <a href="https://www.npmjs.com/package/%40tensorflow/tfjs-node-gpu">with support for GPU computing</a> </li></ul><br><pre> <code class="plaintext hljs">npm install @tensorflow/tfjs @tensorflow/tfjs-node // ... npm install @tensorflow/tfjs @tensorflow/tfjs-node-gpu</code> </pre> <br>  Both extensions for Node.js use native dependencies that will be compiled on demand. <br><br>  <b>Loading TensorFlow libraries</b> <br><br>  <a href="https://js.tensorflow.org/api/0.12.0/">The JavaScript API</a> for Tensorflow is provided from the core library.  Extension modules that support Node.js do not provide additional APIs. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ( CPU) require('@tensorflow/tfjs-node') //    ( GPU) require('@tensorflow/tfjs-node-gpu')</span></span></code> </pre> <br>  <b>Loading TensorFlow models</b> <br><br>  TensorFlow.js provides <a href="https://github.com/tensorflow/tfjs-models">the NPM library</a> ( <code>tfjs-models</code> ), which <code>tfjs-models</code> easy to load pre-trained and transformed models for <a href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet">classifying images</a> , <a href="https://github.com/tensorflow/tfjs-models/tree/master/posenet">determining poses,</a> and <a href="https://github.com/tensorflow/tfjs-models/tree/master/knn-classifier">finding the k-nearest neighbors</a> . <br><br>  <a href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet">The MobileNet model</a> for image classification is a deep neural network, trained to distinguish between <a href="">1000 different image classes</a> . <br><br>  The following code is used <a href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet">as an example in the</a> project's README file for the model loading. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mobilenet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   const model = await mobilenet.load();</span></span></code> </pre> <br>  One of the first problems I encountered was that this code does not work with Node.js. <br><br><pre> <code class="plaintext hljs">Error: browserHTTPRequest is not supported outside the web browser.</code> </pre> <br>  After examining the <a href="">source code</a> , we see that the mobilenet library is a wrapper for the <code>tf.Model</code> class.  When called, the <code>load()</code> method automatically loads the necessary model files located at the external HTTP address and instantiates the TensorFlow model. <br><br>  The Node.js extension at the time of this writing did not yet support HTTP requests for dynamic model retrieval.  It remained only to manually upload the model to the file system. <br><br>  <i>However, after reading the library source code, I found a workaround ...</i> <br><br>  <b>Loading models from the file system</b> <br><br>  If the MobileNet class is created manually, you can not call the module's <code>load</code> method, but overwrite the automatically generated <code>path</code> variable containing the model's HTTP address by replacing this address with the local path in the file system.  After that, when calling the <code>load</code> method in an instance of a class, <a href="https://js.tensorflow.org/tutorials/model-save-load.html">the file system loader</a> class will work;  in this case, we refuse to use the HTTP browser loader. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-string"><span class="hljs-string">"mobilenet/model.json"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load()</code> </pre> <br>  Cool, it works! <br><br>  But where do the model files come from? <br><br>  <b>MobileNet Models</b> <br><br>  Models for TensorFlow.js consist of two types of files: model configuration file, stored in JSON format, and model weights, stored in binary format.  Model weights are often fragmented into multiple parts to optimize browser caching. <br><br>  After reviewing the <a href="">automatic load code</a> for MobileNet models, we see that the models, their configurations and weight fragments are retrieved from the public container at the following address. <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/</code> </pre> <br>  The template parameters in the URL describe the model versions listed <a href="">here</a> .  The resulting classification accuracy is also displayed on the same page. <br><br>  The source code states that only models of the MobileNet v1 version can be downloaded using the <code>tensorflow-models/mobilenet</code> . <br><br>  The HTTP retrieval code loads the <code>model.json</code> file from the storage location, and then recursively selects all model fragments with weights referenced.  These are files in the format <code>groupX-shard1of1</code> . <br><br>  <b>Manual download of models</b> <br><br>  If you need to save all the model files in the file system, you can do this: extract the model configuration file, parse the syntax of all weight files referenced in the configuration file, and then download each weight file manually. <br>  <b>I was going to use the MobileNet V1 module with an alpha value of 1.0 and an image size of 224 pixels</b> .  So I get the <a href="">following URL</a> for the model configuration file. <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json</code> </pre> <br>  Once this file is downloaded locally, you can use the <code>jq</code> <a href="https://stedolan.github.io/jq/">tool</a> to parse the names of all weight files. <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> group1-shard1of1 group2-shard1of1 group3-shard1of1 ...</code> </pre> <br>  Using the <code>sed</code> tool, you can put in front of the name of each HTTP URL element to generate a URL for each weight file. <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//'</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group1-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group2-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group3-shard1of1 ...</span></span></code> </pre><br>  The <code>parallel</code> and <code>curl</code> commands allow you to then download all these files to my local directory. <br><br><pre> <code class="plaintext hljs">cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' | parallel curl -O</code> </pre> <br>  <b>Image classification</b> <br><br>  <a href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet">This sample code</a> provided with TensorFlow.js demonstrates how to return the result of image classification. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> img = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'img'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   const predictions = await model.classify(img);</span></span></code> </pre> <br>  This does not work in Node.js due to the lack of DOM support. <br><br>  <a href="">The</a> <code>classify</code> <a href="">method</a> accepts various DOM elements ( <code>canvas</code> , <code>video</code> , <code>image</code> ) and automatically extracts and converts the ‚Äúpicture‚Äù bytes from these elements into the <code>tf.Tensor3D</code> class used as input to the model.  Alternatively, the <code>tf.Tensor3D</code> input information can be transmitted directly. <br><br>  <b>I decided not to try to use the external package to simulate the DOM element manually, but found that <code>tf.Tensor3D</code> easier to manually assemble <code>tf.Tensor3D</code></b> . <br><br>  <b>We generate Tensor3D from the image</b> <br><br>  Reading the <a href="">source code of the</a> method used to convert the DOM elements to the Tensor3D classes, we find that the following input parameters are used to generate the Tensor3D class. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(image.height * image.width * numChannels); <span class="hljs-comment"><span class="hljs-comment">//     ,    const outShape = [image.height, image.width, numChannels]; const input = tf.tensor3d(values, outShape, 'int32');</span></span></code> </pre> <br>  <code>pixels</code> is a two-dimensional array of type <code>(Int32Array)</code> containing a sequential list of channel values ‚Äã‚Äãfor each pixel.  <code>numChannels</code> is the number of channel values ‚Äã‚Äãper pixel. <br><br>  <b>Creating input values ‚Äã‚Äãfor JPEG</b> <br><br>  <a href="https://www.npmjs.com/package/jpeg-js">The</a> <code>jpeg-js</code> <a href="https://www.npmjs.com/package/jpeg-js">library</a> is a JPEG encoder / decoder for Node.js, written in pure JavaScript.  Using this library, you can extract RGB values ‚Äã‚Äãfor each pixel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buffer, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  As a result, we obtain a Uint8Array with four channel values ‚Äã‚Äã( <code>RGBA</code> ) per pixel ( <code>width * height</code> ).  In the MobileNet model, only three color channels ( <code>RGB</code> ) are used for classification, the alpha channel is ignored.  This code converts a four-channel array into the correct three-channel version. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numChannels = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } }</code> </pre> <br>  <b>Input Requirements for MobileNet Models</b> <br><br>  The <a href="">MobileNet model</a> used here classifies images with a height and width of 224 pixels.  Input tensors must contain floating-point values ‚Äã‚Äãin the range from -1 to 1 for each of the three channel values ‚Äã‚Äãof each pixel. <br><br>  Input values ‚Äã‚Äãfor images with a different dimension must be recalculated to the correct size before classification.  In addition, pixel values ‚Äã‚Äãobtained from a JPEG decoder are in the range of 0 - 255, and not -1 - 1. These values ‚Äã‚Äãalso need to be converted before classification. <br><br>  TensorFlow.js has library methods that simplify this process, but, even better, there is a <b>special library <code>tfjs-models/mobilenet</code> that <a href="">automatically solves this problem</a> !</b> <br><br>  The developer can transfer input Tensor3D of type <code>int32</code> , as well as various dimensions to the <code>classify</code> method, which prior to classification translates the input values ‚Äã‚Äãinto the correct format.  That is, we do not have to do anything here.  Super! <br><br>  <b>Getting forecasts</b> <br><br>  MobileNet models in Tensorflow learn how to recognize objects from <a href="">1000 of the most important classes</a> from the <a href="http://image-net.org/">ImageNet</a> data <a href="http://image-net.org/">set</a> .  At the output of the model, probabilistic values ‚Äã‚Äãare given, which characterize the chances of finding these objects in the classified image. <br><br>  <i>A complete list of the trained classes for the model used is in <a href="">this file</a></i> . <br><br>  The <code>tfjs-models/mobilenet</code> offers a <code>classify</code> method in the <code>MobileNet</code> class, which returns the top X most likely classes, based on what is shown in the picture. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  <code>predictions</code> is an array of X classes and probabilities in the following format. <br><br><pre> <code class="javascript hljs"> { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'panda'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> }</code> </pre> <br>  <b>Example</b> <br><br>  So, we figured out how to use the TensorFlow.js library and MobileNet models in Node.js, and now we will look at how this script classifies the image specified as a command line argument. <br><br>  <i>Source</i> <br><br>  Save this script file and package descriptor in local files. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"tf-js"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"script.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@tensorflow-models/mobilenet"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.2.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.12.3"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs-node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.1.9"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpeg-js"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.3.4"</span></span> } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobilenet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs-node'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jpeg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jpeg-js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NUMBER_OF_CHANNELS = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readImage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = fs.readFileSync(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pixels } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageByteArray = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = image.data <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageToInput = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = imageByteArray(image, numChannels) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outShape = [image.height, image.width, numChannels]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = tf.tensor3d(values, outShape, <span class="hljs-string"><span class="hljs-string">'int32'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadModel = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> path =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mn } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classify = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (model, path) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = readImage(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = imageToInput(image, NUMBER_OF_CHANNELS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn_model = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loadModel(model) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'classification results:'</span></span>, predictions) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.argv.length !== <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'incorrect arguments: node script.js &lt;MODEL&gt; &lt;IMAGE_FILE&gt;'</span></span>) classify(process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>], process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>])</code> </pre> <br>  <b>Testing</b> <br><br>  Download the model files to the mobilenet directory, following the instructions above. <br>  Install project dependencies with NPM <br><br> <code>npm install</code> <br> <br>  Download a sample JPEG file for classification <br><br> <code>wget http://bit.ly/2JYSal9 -O panda.jpg</code> <br> <br><img src="https://habrastorage.org/webt/vt/sm/-2/vtsm-2o5y-t3vhqx5-qaomhxnfw.jpeg"><br><br>  Run the script, whose arguments will be the model file and the input image. <br><br> <code>node script.js mobilenet/model.json panda.jpg</code> <br> <br>  If everything worked correctly, then the following output should appear in the console. <br><br><pre> <code class="javascript hljs"> classification results: [ { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'giant panda, panda, panda bear, coon bear'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> } ]</code> </pre> <br>  The image is correctly classified as containing a panda with a probability of 99.93%! <br><br>  <b>Conclusion</b> <br><br>  The TensorFlow.js library opens up deep learning opportunities for JavaScript developers.  The use of pre-trained models with the TensorFlow.js library makes it easy to build new applications in JavaScript applications to solve complex machine learning tasks, with minimal effort and concise code. <br><br>  The TensorFlow.js library was created especially for working in the browser, but now it interacts with Node.js, although not all tools and utilities support this new execution environment.  Having fiddled with the library for several days, I learned to use it with MobileNet models for visual recognition of images from a local file. </div><p>Source: <a href="https://habr.com/ru/post/432984/">https://habr.com/ru/post/432984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432972/index.html">Source: "Conway's Law"</a></li>
<li><a href="../432976/index.html">Anonymous Father Frost 2018-2019: post boasting New Year's gifts</a></li>
<li><a href="../432978/index.html">John Romero: reflection on DOOM</a></li>
<li><a href="../432980/index.html">VMware NSX for the smallest. Part 1</a></li>
<li><a href="../432982/index.html">The shortest introduction to compiler creation</a></li>
<li><a href="../432986/index.html">C vs Go cycles and simple math</a></li>
<li><a href="../432988/index.html">Eighth Webmaster. Live on Habr√©</a></li>
<li><a href="../432990/index.html">Edison Wooden Lamp with voice control. Issue price of $ 5</a></li>
<li><a href="../432992/index.html">Put on headphones and died: we deal with the strange death of a schoolboy in Rembau</a></li>
<li><a href="../432994/index.html">Vivaldi 2.2 - Quantity, turning into quality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>