<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting the text of requests from SoapHttpClientProtocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET has several options for creating a SOAP client, one of which is to generate it using wsdl.exe. The output is a file (since I write in C #, I gene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting the text of requests from SoapHttpClientProtocol</h1><div class="post__text post__text-html js-mediator-article">  .NET has several options for creating a SOAP client, one of which is to generate it using wsdl.exe.  The output is a file (since I write in C #, I generated cs, respectively), which is based on a class inherited from SoapHttpClientProtocol.  Read more <a href="https://msdn.microsoft.com/en-us/library/7h3ystb6(v%3Dvs.100).aspx">here</a> . <br><br>  From my point of view, this is quite a convenient way, besides, the client itself can be tweaked using sgen.exe (a <a href="https://uwekaessner.wordpress.com/2009/02/08/crm-4-0-tutorial-boost-performance-with-pre-generated-xmlserializers/">very good example</a> ).  Nevertheless, he has one very serious drawback - the lack of a regular opportunity to receive the text of the request / response.  And this would be extremely convenient for the initial debugging of services, the analysis of errors and, most importantly, for possible proceedings from the side, these same services provide. <br><br>  However, if you really want, you need to do. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  main idea </h3><a name="habracut"></a><br>  It is quite a good way to override the SoapHttpClientProtocol in some way and add this same logging capability.  The option for receiving client requests presented <a href="httpclientprotocol">here</a> was taken as a basis, after which the possibility of logging and server responses was ‚Äúscrewed‚Äù onto it. <br><br><h3>  Override SoapHttpClientProtocol </h3><br>  We release our class, let it be SoapHttpClientProtocolSpy, inherited from SoapHttpClientProtocol, respectively.  To intercept client requests, override the GetWriterForMessage method, and to intercept server responses, GetReaderForMessage.  The first returns an XmlWriter, the second returns an XmlReader;  instead, we‚Äôll return our own implementations that will allow us to get XMl passing through them. <br><br>  We get the following class: <br><br><div class="spoiler">  <b class="spoiler_title">SoapHttpClientProtocolSpy</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SoapHttpClientProtocolSpy</span></span>: <span class="hljs-title"><span class="hljs-title">SoapHttpClientProtocol</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> XmlWriterSpy writer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> XmlReaderSpy reader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SoapHttpClientProtocolSpy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> XmlWriter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWriterForMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SoapClientMessage message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bufferSize</span></span></span><span class="hljs-function">)</span></span> { writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlWriterSpy(<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetWriterForMessage(message, bufferSize)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> writer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> XmlReader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReaderForMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SoapClientMessage message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bufferSize</span></span></span><span class="hljs-function">)</span></span> { reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlReaderSpy(<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetReaderForMessage(message, bufferSize)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reader; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> XmlRequest =&gt; reader?.Xml; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> XmlResponce =&gt; writer?.Xml; }</code> </pre> <br></div></div><br>  XmlWriterSpy and XmlReaderSpy are decorators for XmlWriter and XmlReader. <br><br><h3>  XmlWriterSpy </h3><br>  In essence, the implementation itself consists of adding a StringWriter, into which we will store the query text during processing.  That is, it is necessary to override all recording methods so that they call the regular handler and pass the result to the StringWriter. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XmlWriterSpy</span></span> : <span class="hljs-title"><span class="hljs-title">XmlWriter</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     ,   private XmlWriter _me; private XmlTextWriter _bu; private StringWriter _sw; public XmlWriterSpy(XmlWriter implementation) { _me = implementation; _sw = new StringWriter(); _bu = new XmlTextWriter(_sw); _bu.Formatting = Formatting.Indented; } public override void Flush() { _me.Flush(); _bu.Flush(); _sw.Flush(); } public string Xml =&gt; _sw?.ToString(); public override void Close() { _me.Close(); _bu.Close(); } public override string LookupPrefix(string ns) { return _me.LookupPrefix(ns); } public override void WriteBase64(byte[] buffer, int index, int count) { _me.WriteBase64(buffer, index, count); _bu.WriteBase64(buffer, index, count); } public override void WriteCData(string text) { _me.WriteCData(text); _bu.WriteCData(text); } //  ,     }</span></span></code> </pre> <br></div></div><br>  Thanks again to <a href="httpclientprotocol">this article</a> for that. <br><br><h3>  XmlWriterSpy </h3><br>  Here the idea is absolutely the same.  But only with the implementation will have to tinker a bit.  On the one hand, it is enough to climb only 1 method (Read), on the other hand, there is reading from the stream, and it is not so easy not to break it.  The idea took <a href="https://msdn.microsoft.com/ru-ru/library/system.xml.xmltextreader.read(v%3Dvs.110).aspx">from here</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XmlReaderSpy</span></span> : <span class="hljs-title"><span class="hljs-title">XmlReader</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     ,   private XmlReader _baseXmlReader; StringWriter _sw; public string Xml =&gt; _sw?.ToString(); public XmlReaderSpy(XmlReader xmlReader) { _sw = new StringWriter(); _baseXmlReader = xmlReader; } public override bool Read() { //   var res = _baseXmlReader.Read(); //      - switch (_baseXmlReader.NodeType) { case XmlNodeType.Element: _sw.Write("&lt;" + _baseXmlReader.Name); while (_baseXmlReader.MoveToNextAttribute()) _sw.Write(" " + _baseXmlReader.Name + "='" + _baseXmlReader.Value + "'"); _sw.Write(_baseXmlReader.HasValue || _baseXmlReader.IsEmptyElement ? "/&gt;" : "&gt;"); //    ,     _baseXmlReader.MoveToElement(); break; case XmlNodeType.Text: _sw.Write(_baseXmlReader.Value); break; case XmlNodeType.CDATA: _sw.Write(_baseXmlReader.Value); break; case XmlNodeType.ProcessingInstruction: _sw.Write("&lt;?" + _baseXmlReader.Name + " " + _baseXmlReader.Value + "?&gt;"); break; case XmlNodeType.Comment: _sw.Write("&lt;!--" + _baseXmlReader.Value + "--&gt;"); break; case XmlNodeType.Document: _sw.Write("&lt;?xml version='1.0'?&gt;"); break; case XmlNodeType.Whitespace: _sw.Write(_baseXmlReader.Value); break; case XmlNodeType.SignificantWhitespace: _sw.Write(_baseXmlReader.Value); break; case XmlNodeType.EndElement: _sw.Write("&lt;/" + _baseXmlReader.Name + "&gt;"); break; } return res; } }</span></span></code> </pre> <br></div></div><br>  All other methods are overridden by a simple call to the same method for _baseXmlReader. <br><br><h3>  Using </h3><br>  Recall the generated class, now you just need to inherit it from SoapHttpClientProtocolSpy.  It is worth saying that this implementation works even if the server returns an error (that is, it will also be logged).  Well, then the method call looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Service()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = worker.Metod(....); Log.Info((worker?.XmlRequest ?? <span class="hljs-string"><span class="hljs-string">""</span></span>)+(worker?.XmlResponce ?? <span class="hljs-string"><span class="hljs-string">""</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (System.Exception ex) { Log.Error((worker?.XmlRequest ?? <span class="hljs-string"><span class="hljs-string">""</span></span>)+(worker?.XmlResponce ?? <span class="hljs-string"><span class="hljs-string">""</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; } }</code> </pre><br>  Ps.  From my point of view, it will be quite convenient to take it all to a separate lib.  The only thing that will constantly strain is the need to climb into the file after updating the client and replace SoapHttpClientProtocol there, but these are trifles. </div><p>Source: <a href="https://habr.com/ru/post/337672/">https://habr.com/ru/post/337672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337662/index.html">JavaScript: Asynchronous Programming Techniques</a></li>
<li><a href="../337664/index.html">Report with mitap for back-end developers</a></li>
<li><a href="../337666/index.html">How to meet the requirements of the quality management system according to ISO 9001: 2015</a></li>
<li><a href="../337668/index.html">How to use Java with CryptoPro to sign a PDF document</a></li>
<li><a href="../337670/index.html">Interserver WebRTC</a></li>
<li><a href="../337674/index.html">Kindergarten, pants with straps: where do programmers come from</a></li>
<li><a href="../337676/index.html">How to optimally calculate the amount of "iron": Sizing model of the EFS</a></li>
<li><a href="../337678/index.html">The practice of forming requirements in IT projects from A to Z. Part 6. System behavior. Excellence requirements</a></li>
<li><a href="../337680/index.html">Plugin for HANA Database project in Visual Studio</a></li>
<li><a href="../337682/index.html">Oracle actually eliminates Sun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>