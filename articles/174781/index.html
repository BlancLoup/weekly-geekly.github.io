<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing the trivial code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Even if the code is trivial, you still need to test it. 
 A couple of days ago, Robert Martin published the post ‚ÄúPragmatism of TDD‚Äù , ( where the tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing the trivial code</h1><div class="post__text post__text-html js-mediator-article">  <i>Even if the code is trivial, you still need to test it.</i> <br>  A couple of days ago, Robert Martin published the post <a href="http://blog.8thlight.com/uncle-bob/2013/03/06/ThePragmaticsOfTDD.html">‚ÄúPragmatism of TDD‚Äù</a> , ( <a href="http://habrahabr.ru/post/173961/">where the translation</a> is - <i>comment of the</i> <a href="http://habrahabr.ru/post/173961/">translator</a> ) where he told that <i>absolutely all code is</i> not being tested.  Among the exceptional situations where TDD should not be applied, Uncle Bob mentions writing GUI code, and I see the point in such statements, but among the exceptions there are a couple, in my opinion, <i>illogical</i> . <a name="habracut"></a><br>  Robert Martin claims he doesn‚Äôt develop through testing: <br><ul><li>  getters and setters; </li><li>  single line functions; </li><li>  absolutely trivial functions. </li></ul><br>  In essence, these statements boil down to the only rule that ‚Äútrivial‚Äù code, such as getters and setters (properties for .NET programmers), should not be developed through testing. <br>  There are several issues with this TDD application rule that I would like to discuss: <br><ul><li>  here there is a confusion of cause and effect; </li><li>  trivial code may change in the future; </li><li>  This is terrible advice for newbies. </li></ul><br>  Let me consider each of these points in more detail. <br><br><h4>  Causal relationship </h4><br>  The whole point of TDD is that tests <i>direct</i> implementation.  A test is a <i>cause</i> , and an implementation is a <i>consequence</i> .  If you follow this principle, then how on planet Earth, you can decide not to write a test because the expected implementation will be a trivial complexity?  <i>You still do not even know.</i>  It is logically impossible. <br>  Robert Martin himself proposed <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">the transformation transformation order</a> (TPP), and one of the thoughts is that when you begin to direct the development of new code through tests, you should try to do it in small formalized steps.  The first step is likely to lead you to a trivial implementation, such as returning a constant. <br>  From the point of view of TPP, the only difference between the trivial and non-trivial code is how far you have come to the direction of implementation through testing.  Thus, if ‚Äútriviality‚Äù is all you need, the only true way is to write a single test that will demonstrate that the trivial behavior works as expected.  Thus, according to TPP, you are done with the task. <br><br><h4>  Encapsulation. </h4><br>  Robert Martin‚Äôs exception about getters and setters baffles in particular.  If you consider this or that getter / setter (or .NET property) to be trivial, why did you implement it at all?  Why not, then, implement an open field in the classroom? <br>  There are excellent reasons to avoid implementing open class fields, and <a href="http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/">all of them are related to encapsulation.</a>  The data must be implemented through getters and setters, because it will give the opportunity to change their implementation in the future. <br>  What exactly do we call the process of changing the implementation without changing the behavior? <br>  We call this <i>refactoring</i> .  How can we know that by changing the implementation code we will not change the behavior? <br>  As <a href="http://martinfowler.com/">Martin Fowler</a> argues <a href="http://www.amazon.com/gp/product/0201485672/ref%3Das_li_ss_tl%3Fie%3DUTF8%26camp%3D1789%26creative%3D390957%26creativeASIN%3D0201485672%26linkCode%3Das2%26tag%3Dploeh-20">in the book Refactoring</a> , you <i>must</i> have a good set of tests as a safety net, otherwise you won‚Äôt know if you broke something or not. <br>  A good code lives and develops for a long time.  What was trivial in the beginning can change over a long period of time and you cannot predict whether trivial members will remain trivial for several years.  It is important to be sure that the trivial behavior remains correct with the addition of complexity to it.  The regression test suite is designed to solve this problem, but only if you actually write tests for trivial features. <br>  Robert Martin cites as an argument that the getters and setters are tested indirectly through other tests, but despite the fact that this may be true at the stage of member declaration, it is not a fact that this will be true for a long time.  After months, these tests can be removed, leaving the trivial member entered uncovered by tests. <br>  You can look at it this way: you can follow or not follow TPP with TDD, but for trivial members, the time gap between the first and second transformations can be measured in months, not minutes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  TDD study </h4><br>  I think that being a pragmatist is good, but the ‚Äúrule‚Äù that says that you don‚Äôt have to develop a ‚Äútrivial‚Äù code through testing is simply <a href="http://programmers.stackexchange.com/questions/185719/how-should-you-tdd-a-yahtzee-game/188188">terrible advice for newbies</a> .  If you give someone who studies TDD a way to follow which you can avoid this very TDD, then this someone, facing any difficulties, will go this way every time.  If you already provide such a workaround, you should at least make the conditions explicit and measurable. <br>  A vague condition that sounds like ‚Äúyou can predict that the implementation will be trivial,‚Äù is absolutely unmeasurable.  You may think that you know what an implementation will look like, but by allowing you to direct the implementation through tests, you will often be surprised.  This is the way of thinking that TDD directs us - what you originally thought will work, will not work. <br><br><h4>  Root Cause Analysis </h4><br>  Do I insist that you have to apply TDD to all getters and setters?  Yes, I really insist. <br>  You could say that such an approach would take too much time.  Robert Martin ironically <a href="http://blog.8thlight.com/uncle-bob/2013/03/05/TheStartUpTrap.html">remarked</a> on this: <blockquote>  "The only way to move fast is to move right." </blockquote><br>  And yet, let's see what the application of TPP to properties looks like (java-programmers can continue to read. Properties in C # are just syntactic sugar for getters and setters). <br>  Let's say I have a DateViewModel class and I want it to have an <a href="http://msdn.microsoft.com/en-us/library/system.int32.aspx">int</a> property representing the year.  The first test will be: <br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetYearReturnsAssignedValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sut = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateViewModel(); sut.Year = <span class="hljs-number"><span class="hljs-number">2013</span></span>; Assert.Equal(<span class="hljs-number"><span class="hljs-number">2013</span></span>, sut.Year); }</code> </pre> <br>  Without taking anything for granted and doubting everything, the correct implementation will be the following: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Year { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2013</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { } }</code> </pre><br><br>  Following the TPP, this code will look like this.  Well, let's write one more test: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetYearReturnsAssignedValue2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sut = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateViewModel(); sut.Year = <span class="hljs-number"><span class="hljs-number">2010</span></span>; Assert.Equal(<span class="hljs-number"><span class="hljs-number">2010</span></span>, sut.Year); }</code> </pre><br>  Together, these two tests encourage me to implement the property correctly: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Year { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Despite the fact that these two tests can be refactored to one <a href="http://xunitpatterns.com/Parameterized%2520Test.html">parameterized test</a> , there is still a lot of work done.  After all, we have to write two tests not only for one property, but also to do this for everyone! <br>  ‚ÄúDo the exact same thing?‚Äù You ask.  What are you, just what? <br>  Oh, well, you're a programmer.  What do programmers do when they have to do the same thing over and over again? <br>  Well, if you put up with conflicting rules that allow you to avoid hurting your work, this is the wrong answer.  If the work hurts you - do it more often. <br>  Programmers automate repetitive actions.  You can also do this with property testing.  Here's how I did the same thing using <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> : <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Theory, AutoWebData</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YearIsWritable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WritablePropertyAssertion a</span></span></span><span class="hljs-function">)</span></span> { a.Verify(Reflect&lt;DateViewModel&gt;.GetProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(sut =&gt; sut.Year)); }</code> </pre><br>  This is a declarative way to test the same behavior as in the previous two tests, but one line long. <br>  This is where the root cause analysis is appropriate.  One gets the feeling that the cost / benefit ratio regarding the use of TDD to getters and setters is very high.  However, I think that Robert Martin stopped there because he considered the costs fixed and the benefits too small.  However, while the benefits may seem insignificant, the costs do not have to remain fixedly high.  Reduce costs and cost / benefit ratio improve.  That is why you should always lead the development of getters and setters through testing. <br><br><blockquote>  <b>From the translator: I</b> plan to release a translation of a review of AutoFixture next time, or to review it myself.  IMHO, a very interesting tool. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/174781/">https://habr.com/ru/post/174781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../174769/index.html">Server on NetWare 3.12 with uptime of 16.5 years</a></li>
<li><a href="../174771/index.html">Do you pay by SMS?</a></li>
<li><a href="../174773/index.html">Graphic Password Vulnerability</a></li>
<li><a href="../174775/index.html">"T-Platforms" were on the list of US enemies</a></li>
<li><a href="../174779/index.html">Technique: Moving Functions Between Objects (M. Fowler refactoring)</a></li>
<li><a href="../174787/index.html">Practice in Microsoft USA (resume and telephone interview)</a></li>
<li><a href="../174789/index.html">Runic processing</a></li>
<li><a href="../174793/index.html">Widget for displaying custom data on Android</a></li>
<li><a href="../174795/index.html">What to do with bad code</a></li>
<li><a href="../174799/index.html">They laugh at your callbacks or async / await "for the poor"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>