<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenMCAPI: simultaneous launch of Linux and RTOS on multi-core processors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the daily practice of the developer of embedded systems, one has to face the need to run two or more diverse operating systems on n-core systems on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenMCAPI: simultaneous launch of Linux and RTOS on multi-core processors</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/9d0/600/87f/9d060087f4a0c271f7e2a863f13d14b3.jpg"><br><br>  In the daily practice of the developer of embedded systems, one has to face the need to run two or more diverse operating systems on n-core systems on a chip.  This is usually Linux and specialized RTOS.  Linux is shouldered by working with heavy protocol stacks, while RTOS also deals with real-time tasks. <br><br>  One of the main tasks that arises with such an organization of the system is to provide an interaction mechanism, that is, inter-core data exchange.  If you are interested in finding out one of the solutions based on the OpenMCAPI open library, scroll through a couple of dozen lines of program code and see the real throughput numbers when using this library, welcome to Cat. <br><a name="habracut"></a><br>  The task of inter-core data exchange is successfully solved through the use of shared memory and inter-core interrupts with the writing of its interaction layer and porting it to various operating systems.  To bring such an <abbr title="(application programming interface) - application programming interface">API</abbr> to a standardized form, the Multicore Association (MCA) developed and released the first version of the MCAPI (Multicore Communications API) specification, and the second version was soon released. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The OpenMCAPI library in question is based on the MCAPI 2.0 specification, developed by Mentor Graphics Corporation and has open source code under the free BSD / GPL license.  Source codes can be obtained using <a href="https://bitbucket.org/hollisb/openmcapi/wiki/Home">the project site</a> , there is also a brief information on launching and porting. <br><br>  The OpenMCAPI library initially provides the ability to work under Linux OS using a virtual transport or shared memory (but only on mpc85xx and mv78xx0 platforms). <br><br>  The proposed structure of interaction between Linux and RTOS through OpenMCAPI with the division into abstract levels is as follows (see Figure 1): <br><br><img src="https://habrastorage.org/storage2/539/58d/dc6/53958ddc6e4b65ca4a07696fc132fceb.png"><br>  <i>Picture.</i>  <i>1. The structure of the interaction of Linux and RTOS through OpenMCAPI</i> <br><br>  Consider the implementation of the structure on the examples of the source port code for Linux: <br><ol><li>  MCAPI Generic is an implementation of an external MCAPI API. <br></li><li>  OS Layer is part of the MCAPI Generic level, which contains code that is dependent on the operating system.  This part is presented in the file libmcapi / mcapi / linux / mcapi_os.c and contains the implementation: </li><li>  Transport Generic is an abstraction layer that provides a mechanism for working with shared memory at the user space level.  It is represented by the files libmcapi / shm / shm.c and libmcapi / shm / linux / shm_os.c and contains the implementation: </li><li>  OS Specific Driver is represented by a Linux kernel module that provides direct access to hardware from user space.  The module is located in the libmcapi / shm / linux / kmod folder and contains the implementation: </li></ol><br>  To fully understand the mechanism of interaction through a transport that uses shared memory, which is implemented in the OpenMCAPI library, it is necessary to consider the internuclear signaling mechanism and the data structure in shared memory. <br><br>  Further consideration will be based on the mpc85xx platform ( <a href="http://www.freescale.com/webapp/sps/site/prod_summary.jsp%3Fcode%3DP1020">Freescale's P1020 chip</a> ).  Software: Linux kernel version 2.6.35 with patches, which comes with the Freescale development toolkit (SDK) QorIQ_SDK_V1_03 (available for download after registering on their site), <a href="http://www.rtems.org/">RTEMS is</a> used as the real-time operating system (RTOS) get in git-repository by reference git: //git.rtems.org/rtems.git. <br><br>  In order to implement inter-core signaling, Freescale provides at least two mechanisms: <br><ol><li>  Interprocessor Interrupts (IPIs) - inter-core interrupts, up to 4 pieces with multicast interrupt support. </li><li>  Message Interrupts (MSGRs) - inter-core 32-bit messages with generating an interrupt when writing a message to the register, up to 8 pieces. </li></ol><br>  The opencci library uses the MSGRs mechanism for implementing the OS Specific Driver for this platform. <br><br>  Consider the data structure contained in shared memory (see Figure 2): <br><br><img src="https://habrastorage.org/storage2/d52/811/1d5/d528111d5c0a09330c7fb1132633c4c4.png"><br>  <i>Figure 2. Data structure in shared memory</i> <br><br>  The area of ‚Äã‚Äãshared memory by space can be divided into two blocks: <br><ul><li>  <b>The first block</b> , the SHM_MGMT_BLOCK area, is represented by the structure: </li></ul><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* SM driver mamagement block */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _shm_drv_mgmt_struct_ { shm_lock shm_init_lock; mcapi_uint32_t shm_init_field; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _shm_route_ shm_routes[CONFIG_SHM_NR_NODES]; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _shm_buff_desc_q_ shm_queues[CONFIG_SHM_NR_NODES]; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> _shm_buff_mgmt_blk_ shm_buff_mgmt_blk; };</code> </pre> <br>  The structure contains the following elements: <br><ol><li>  Global shared memory lock - shm_init_lock, used to delimit n-core access to the shared area. </li><li>  The variable shm_init_field contains the <abbr title="The master is the first kernel that performs the full initialization of structures in shared memory, all subsequent ones are slave devices">master</abbr> initialization completion key, takes the value SHM_INIT_COMPLETE_KEY at the end of initialization. </li><li>  Shm_routes - routing table with connections of internuclear messages, contains CONFIG_SHM_NR_NODES connections by the number of cores (nodes) participating in the exchange.  In our case, 2 nodes. </li><li>  Shm_queues - message queues with binding to a specific node, contains CONFIG_SHM_NR_NODES.  In our case, 2 turns. </li><li>  Shm_buff_mgmt_blk - the buffer management structure (SHM_BUFFER) in the data area. </li></ol><br><br><ul><li>  <b>The second area</b> , the data area, contains SHM_BUFF_COUNT (128 by default) of SHM_BUFFER structures.  This area serves directly to store the transmitted data.  The SHM_BUFFER structure consists of an array of sizes MCAPI_MAX_DATA_LEN and an additional element control structure. </li></ul><br>  Before considering the porting process, it is necessary to provide a flowchart of the low-level communication mechanism through shared memory (the mechanism is implemented in OpenMCAPI, see Fig. 3): <br><br><img src="https://habrastorage.org/storage2/c0f/cbc/f97/c0fcbcf978ed4affc240b1ee869c1606.png"><br><br>  <i>Picture.</i>  <i>3. SDL diagrams of the low-level communication mechanism through shared memory (implemented in OpenMCAPI).</i> <br><br>  Some explanations for diagrams: <br><ul><li>  ‚ÄúHW-Notification‚Äù - the diagram describes the process of sending a notification to a remote or current kernel: <br><ol><li>  The function call accepts the kernel id for which the message is intended (the openmcapi_shm_notify function). </li><li>  If the notification is intended for the remote kernel ‚Äútarget id‚Äù, then a remote message is generated via the MSGRs mechanism (discussed above) with the value in the data field equal to one (see box 3), otherwise the interrupt_handle interrupt handler is called directly (‚ÄúHW-Receive‚Äù diagram ), see block 4. </li></ol><br></li><li>  The ‚ÄúHW-Receive‚Äù diagram describes the process for receiving a notification from a remote or current kernel: <br><ol><li>  Interrupt_handle is an interrupt handler configured to trigger when a message is received by MSGRs, also used for an explicit call. </li><li>  In blocks 2‚Äì6, the status of all MSGRs messages is organized; if the data field of the MSGR message is not 0, the stream that processes data in the shared memory area is unblocked. </li><li>  In blocks 7‚Äì8, the check of the place where the interrupt handler is called (‚Äúinterrupt_handler‚Äù) occurs.  If the call was interrupted, the MSGR message presence flag is cleared. </li></ol><br></li></ul><br>  Before proceeding to the description of porting for RTEMS, briefly consider this OS. <br><br><img src="https://habrastorage.org/storage2/332/0a1/e60/3320a1e6062c2a29f266539e6772e7f5.png"><br><br>  <strong>RTEMS (Real-Time Executive for Multiprocessor Systems)</strong> is an open-source RTOS, a full-featured real-time operating system with support for many open standard application programming interfaces (APIs), POSIX standards, and BSD sockets.  It is designed for use in space, medical, network and many other embedded devices.  RTEMS contains a wide range of processor architectures such as ARM, PowerPC, Intel, Blackfin, MIPS, Microblaze, etc. It contains a large stack of implemented network protocols, in particular tcp / ip, http, ftp, telnet.  Provides standardized access to RTC, NAND, UART and other equipment. <br><br>  Let's proceed to the process of porting OpenMCAPI.  Based on the document located by reference [1] is required: <br><ol><li>  Implement OS Layer files: <br><ul><li>  libmcapi / mcapi / rtems / mcapi_os.c; </li><li>  libmcapi /include/rtems/mgc_mcapi_impl_os.h. </li></ul><br></li><li>  Implement support for a compatible shared memory transport file: <br><ul><li>  libmcapi / shm / rtems / shm_os.c. </li></ul><br></li><li>  Add recipes to the <a href="https://code.google.com/p/waf/">waf collector</a> that is used for OpenMCAPI. </li></ol><br>  Since the target platform P1020 (powerpc, 500v2) and porting was carried out on RTOS, where the absence of kernel / user space separation is allowed, there is no need to write: <br><ol><li>  libmcapi / include / arch / powerpc / atomic.h; </li><li>  libmcapi / shm / rtems / kmod /. </li></ol><br>  There is also no need for an implementation of OS Layer, since RTEMS supports POSIX-compatible calls, the files mcapi_os.c and mgc_mcapi_impl_os.h were simply copied from the Linux implementation. <br><br>  The implementation of the shared memory transport is fully implemented in the file shm_os.c and includes the adaptation of calls from the Transport Generic abstraction layer (the file libmcapi / shm / shm.c) and the implementation of the exchange mechanism through MSGRs. <br><br>  Functions requiring implementation: <br><p>  <strong>1) mcapi_status_t openmcapi_shm_notify (mcapi_uint32_t unit_id, mcapi_uint32_t node_id)</strong> - the function sends a notification to the remote core (s), the implementation is represented by a diagram (see Figure 3).  The source code is below: </p><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* send notify remote core */</span></span> <span class="hljs-function"><span class="hljs-function">mcapi_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openmcapi_shm_notify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mcapi_uint32_t unit_id, mcapi_uint32_t node_id</span></span></span><span class="hljs-function">)</span></span> { mcapi_status_t mcapi_status = MCAPI_SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; rc = shm_rtems_notify(unit_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc) { mcapi_status = MGC_MCAPI_ERR_NOT_CONNECTED; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mcapi_status; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> inline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shm_rtems_notify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mcomm_core_t target_core</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> mcomm_qoriq_data *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = &amp;mcomm_qoriq_data; <span class="hljs-comment"><span class="hljs-comment">/* If the target is the local core, call the interrupt handler directly. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target_core == mcomm_qoriq_cpuid()) { _mcomm_interrupt_handler(NO_IRQ, data); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mcomm_qoriq_notify(target_core); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Wake up the process(es) corresponding to the mailbox(es) which just received * packets. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _mcomm_interrupt_handler(rtems_vector_number irq, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> mcomm_qoriq_data *data) { register <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *mbox = data-&gt;mbox_mapped; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data-&gt;nr_mboxes; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> active; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (data-&gt;mbox_size) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: active = readb(mbox); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: active = readl(mbox); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: active = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (active) { LOG_DEBUG(<span class="hljs-string"><span class="hljs-string">"%s: waking mbox %d\n"</span></span>, __func__, i); (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) rtems_event_send( data-&gt;rid, MMCAPI_RX_PENDING_EVENT ); } mbox += data-&gt;mbox_stride; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq != NO_IRQ) { mcomm_qoriq_ack(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  <strong>2) mcapi_uint32_t openmcapi_shm_schedunitid (void)</strong> - the function returns the number of the current kernel (that is, the kernel that executes this code), implemented trivially by reading the register of the processor.  The source code is below: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get current cpu id */</span></span> <span class="hljs-function"><span class="hljs-function">mcapi_uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openmcapi_shm_schedunitid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (mcapi_uint32_t) ppc_processor_id(); }</code> </pre><br><br>  <strong>3) mcapi_status_t openmcapi_shm_os_init (void)</strong> - the function creates and starts a low-level data reception flow, implemented by calling the rtems_task_create and rtems_task_start functions.  The source code is below: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Now that SM_Mgmt_Blk has been initialized, we can start the RX thread. */</span></span> <span class="hljs-function"><span class="hljs-function">mcapi_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openmcapi_shm_os_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> mcomm_qoriq_data *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = &amp;mcomm_qoriq_data; rtems_id id; rtems_status_code sc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( RTEMS_SELF != data-&gt;rid ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCAPI_ERR_GENERAL; } sc = rtems_task_create( rtems_build_name( <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> ), MMCAPI_RX_TASK_PRIORITY, RTEMS_MINIMUM_STACK_SIZE, RTEMS_DEFAULT_MODES, RTEMS_DEFAULT_ATTRIBUTES, &amp;id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( RTEMS_SUCCESSFUL != sc ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCAPI_ERR_GENERAL; } <span class="hljs-comment"><span class="hljs-comment">/* global save task id */</span></span> data-&gt;rid = id; sc = rtems_task_start( id, mcapi_receive_thread, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( RTEMS_SUCCESSFUL != sc ) { perror( <span class="hljs-string"><span class="hljs-string">"rtems_task_start\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCAPI_ERR_GENERAL; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCAPI_SUCCESS; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> rtems_task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mcapi_receive_thread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rtems_task_argument argument</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { rc = shm_rtems_wait_notify(MCAPI_Node_ID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shm_rtems_wait_notify"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } MCAPI_Lock_RX_Queue(); <span class="hljs-comment"><span class="hljs-comment">/* Process the incoming data. */</span></span> shm_poll(); MCAPI_Unlock_RX_Queue(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); printk(<span class="hljs-string"><span class="hljs-string">"%s exiting!\n"</span></span>, __func__); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> inline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shm_rtems_wait_notify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mcapi_uint32_t unitId</span></span></span><span class="hljs-function">)</span></span> { rtems_event_set event_out; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { LOG_DEBUG(<span class="hljs-string"><span class="hljs-string">"mcomm_mbox_pending start\n"</span></span>); (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) rtems_event_receive( MMCAPI_RX_PENDING_EVENT, RTEMS_DEFAULT_OPTIONS, RTEMS_NO_TIMEOUT, &amp;event_out ); LOG_DEBUG(<span class="hljs-string"><span class="hljs-string">"rtems_event_receive\n"</span></span>); ret = mcomm_mbox_pending(&amp;mcomm_qoriq_data, (mcomm_mbox_t)unitId); LOG_DEBUG(<span class="hljs-string"><span class="hljs-string">"mcomm_mbox_pending end ret=%d\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  <strong>4) mcapi_status_t openmcapi_shm_os_finalize (void)</strong> - the function stops the low-level data reception flow, implemented by calling the rtems_task_delete function.  The source code is below: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Finalize the SM driver OS specific layer. */</span></span> <span class="hljs-function"><span class="hljs-function">mcapi_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openmcapi_shm_os_finalize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> mcomm_qoriq_data *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = &amp;mcomm_qoriq_data; rtems_id id = data-&gt;rid; rtems_status_code sc; sc = rtems_task_delete(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( RTEMS_SUCCESSFUL != sc ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCAPI_ERR_GENERAL; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCAPI_SUCCESS; }</code> </pre><br><br>  <strong>5) void * openmcapi_shm_map (void)</strong> - the function of preparing and configuring the interface MSGRs, the preparation of shared memory.  The source code is below: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* full open mcom device and get memory map addres*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *openmcapi_shm_map(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *shm; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; size_t shm_bytes; <span class="hljs-comment"><span class="hljs-comment">// low level init // mcomm_qiroq_probe(); shm_bytes = shm_rtems_read_size(); if (shm_bytes &lt;= 0) { perror("read shared memory size\n"); return NULL; } /* initialized device. */ rc = shm_rtems_init_device(); if (rc &lt; 0) { perror("couldn't initialize device\n"); goto out; } shm = shm_rtems_read_addr(); if (shm == NULL) { perror("mmap shared memory"); goto out; } return shm; out: return NULL; } static size_t shm_rtems_read_size(void) { struct mcomm_qoriq_data *const data = &amp;mcomm_qoriq_data; return (size_t) (data-&gt;mem.end - data-&gt;mem.start); } static inline int shm_rtems_init_device(void) { struct _shm_drv_mgmt_struct_ *mgmt = NULL; /* xmmm */ return mcomm_dev_initialize(&amp;mcomm_qoriq_data, (uint32_t)&amp;mgmt-&gt;shm_queues[0].count, CONFIG_SHM_NR_NODES, sizeof(mgmt-&gt;shm_queues[0].count), ((void *)&amp;mgmt-&gt;shm_queues[1].count - (void *)&amp;mgmt-&gt;shm_queues[0].count)); } static void *shm_rtems_read_addr(void) { struct mcomm_qoriq_data *const data = &amp;mcomm_qoriq_data; return (void*)data-&gt;mem.start; }</span></span></code> </pre><br><br>  <strong>6. void openmcapi_shm_unmap (void * shm)</strong> - the function closes the MSGRs interface, cancels the use of shared memory.  The source code is below: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* full close mcom device and revert memory */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openmcapi_shm_unmap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shm</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* deinitialized device. */</span></span> shm_rtems_deinit_device(); <span class="hljs-comment"><span class="hljs-comment">// low level deinit // mcomm_qoriq_remove(); } static inline int shm_rtems_deinit_device(void) { return mcomm_dev_finalize(&amp;mcomm_qoriq_data); }</span></span></code> </pre><br>  We should separately consider the implementation of the mcapi_receive_thread low-level receive stream function (see the source code above).  When a thread is launched by calling the rtems_event_receive function, it is placed into the event waiting mode (implemented by the event mechanism available in RTEMS).  Then, when a start event arrives, sent in the interrupt_handler handler (see Fig. 3, ‚ÄúHW-Receive‚Äù diagram), changes in the shared memory area are processed (the internal function openmcapi is called shm_poll ()), with its preliminary blocking, after which flow returns to idle state. <br><br>  Below are the results obtained from the interaction of Linux and RTEMS through OpenMCAPI.  The test bench is a Freescale P1020RDB-PB debug board with a P1020 processor installed (2 cores).  Frequencies: core frequency - 800 MHz, DDR2 - 400 MHz, CCB - 400 MHz.  On the 0/1 cores, Linux / RTEMS were launched, respectively.  The exchange was two-way, the time spent on 10,000 two-way parcels was measured.  The test results are summarized in the table: <br><br><table border="1"><tbody><tr><td width="30">  No <br></td><td width="441">  Test description <br></td><td width="168">  Time for one package, ms <br></td></tr><tr><td width="30">  one <br></td><td width="441">  Symmetric packets of 512 bytes <br></td><td width="168">  37.5 <br></td></tr><tr><td width="30">  2 <br></td><td width="441">  Symmetric packets of size 52430 bytes <br></td><td width="168">  121 <br></td></tr><tr><td width="30">  3 <br></td><td width="441">  Symmetric 100 kB Packets <br></td><td width="168">  346 <br></td></tr><tr><td width="30">  four <br></td><td width="441">  Asymmetric packages with sizes 1k / 100k-linux / rtems <br></td><td width="168">  185 <br></td></tr></tbody></table><br>  From all the above, we can conclude that the OpenMCAPI library provides a worthy version of the implementation of the MCAPI specification, which has a clear source code structure that facilitates porting;  illustrative examples of porting (powerpc and arm platforms);  free license and performance sufficient for most applications. <br><br>  <b>[!?]</b> Questions and comments are welcome.  They will be answered by the author of the article Ruslan Filipovich, the programmer <a href="http://promwad.ru/uslugi/razrabotka-programmnogo-obespecheniya">of the electronics design center Promwad</a> . </div><p>Source: <a href="https://habr.com/ru/post/186806/">https://habr.com/ru/post/186806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186792/index.html">CloudEngine. Application for leadership from Huawei. Part 1</a></li>
<li><a href="../186794/index.html">"Pioneers" of the moon race</a></li>
<li><a href="../186796/index.html">Extended ‚ÄúHello! World "on the Flask microform</a></li>
<li><a href="../186800/index.html">PHDays III CTF: An Inside Look (Part 2)</a></li>
<li><a href="../186804/index.html">Microsoft Smart Watch: Empire Strikes Back</a></li>
<li><a href="../186812/index.html">Moving beyond the boundaries of the Windows 8 Modern-Application container</a></li>
<li><a href="../186814/index.html">Elon Musk will soon present the project of a new system of passenger transport Hyperloop</a></li>
<li><a href="../186818/index.html">Migration of PROXMOX VE 3.0 to software RAID1</a></li>
<li><a href="../186820/index.html">Test the galaxy for strength</a></li>
<li><a href="../186822/index.html">Is Scalaxy dead yet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>