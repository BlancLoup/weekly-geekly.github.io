<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another Linq for C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 After a long break, I had to go back to C ++ programming. After C #, the var keyword and the linq query building capabilities were miss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another Linq for C ++</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  After a long break, I had to go back to C ++ programming.  After C #, the var keyword and the linq query building capabilities were missing.  However, as it turned out, progress does not stand still, and during my absence, a new version of C ++ 11 was released, which has new interesting features, and is also implemented in most compilers.  I was involved in a cross-platform project and I was interested in the GCC compilers for Linux, Visual Studio and mingw for the Windows world.  Attempting to find a linq-like library did not succeed, all I found was an unviable handicraft on my knee.  Having resigned myself, I gave up the search, however, in April 2012, there was an encouraging <a href="http://habrahabr.ru/post/142632/">LINQ to Objects</a> article <a href="http://habrahabr.ru/post/142632/">in C ++</a> that described a library that suited me.  Having tried it in business and having understood its device, I was disappointed by inefficiency, but I picked up some ideas.  There was only one thing left to write the same, only with blackjack, which I did at <a href="https://github.com/drbasic/CppLinq">github.com/drbasic/CppLinq</a> , at the same time having understood the automatic output of the type (auto) and lambda expressions. <br><br>  The library was designed so that using the fluent syntax and lambda expressions, the user could build a transformation graph.  These columns can be copied, completed, merged, i.e.  implement the behavior as close as possible to the pre-image of Linq to Objects from the world of C #.  The library functional, without thinking twice, I borrowed from C #, adding an explicit left join and full join.  An important limitation of the library is to move along the transformation graph not of copies, but of pointers to the elements of the original sequence.  This allows you to effectively deal with complex elements of collections, because now there is no overhead for copying, but the original sequence because of this should not be "virtual".  Those.  By the beginning of work, each element of the initial sequence must have a unique address and elements must not be moved in memory during the operation of linq transforms.  In general, arrays, Qt containers, all standard containers except std :: bitset are suitable for this.  Difficulties arose only with constant sequences that were never completed, as I did not really need them.  The library was tested and successfully compiled by Visual Studio 2010 and 2012, gcc 4.8, mingw 4.8.  The easiest way to cope was with the Microsoft compiler, to make happy gcc was much more difficult, and all the compilers with an internal error happened, sometimes even without intelligible screams. <br><a name="habracut"></a><br><h4>  To battle </h4><br>  So, for an example of using CppLinq, take a sequence of 10 elements, select those with an iVal&gt; 5 field, sort by the sVal field, and place the result in std :: vector: <br><br><pre><code class="cpp hljs">TestClass1 data[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t1 = Linq::from(data) .where([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.iVal &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; }) .orderBy([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.sVal; }) .toVector();</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this case, an adapter is first created for the source data from, then a graph is constructed from the where filtering operator, the orderBy sort operator.  At this point, no action on the data has yet occurred, but toVector finally starts the processing pipeline, which will work according to the following algorithm.  toVector will begin to query the last filter in the processing chain for all elements in turn and build std :: vector from them.  The last filter in the chain is orderBy, but since it needs all the elements at once for proper ordering, it will query all its pointers to the elements of the sequence from its overlaying where filter, put them in the buffer and sort them.  The where filter has the ability to select the necessary elements ‚Äúon the fly‚Äù, so for each request of a new element of the sequence below, it requests elements from its overlying filter from, until it finds a condition that satisfies the condition.  The adapter of the sequence from for each request from below returns the address of the next element, and when the elements end with a failure. <br><br>  Graphs can be built dynamically, for example, by adding the necessary filters to the chain at runtime: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> src = Linq::from(data) .where([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.iVal &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (order == ascending) src = src.orderBy([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.sVal; }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> src = src.orderByDesc([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.sVal; }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = src.toVector();</code> </pre><br><br>  When forming a graph, optimizations are made by combining several consecutive sorts into one sort operation, for this purpose all the function of comparing elements is combined together.  For example, for the case below, despite the task of the two sequence sorting filters, only one sort will be performed. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t4 = Linq::from(src1) .orderByDesc([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.sVal; }) .thenBy([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestClass1 &amp;a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.iVal; }) .toVector();</code> </pre> <br><br>  For purely academic purposes, optimization is implemented, when two consecutive reversals of the sequence annihilate and do not form a filter in the chain.  All filters are not greedy, if possible.  if it is possible not to request extra elements from the upper sequence, then the work will be carried out "from the wheels".  But if the data were received, and they will certainly be needed again, then the pointers are necessarily stored in their own cache in order to minimize access to the upper filter, since the cost of obtaining an element from the upper filter is unknown.  The balance is shifted to the use of excess memory, rather than additional passes through the filter chain for the next element.  In addition, pointers are stored in buffers, not the elements themselves, which should not lead to a large memory consumption with adequate sequence sizes. <br><br>  When implementing join, there was a dilemma how to implement a comparison of sequence elements for equality, through operator ==, or equivalence, through operator &lt;.  Both options have pros and cons.  In the case of a smaller operation, it would be possible to sort both input sequences and merge more efficiently, since there is no need to compare each element of the first sequence with each element of the second sequence.  However, in Linq to Objects, it is customary to implement a comparison exactly for equality through operator ==, so I also did this by getting the algorithmic complexity O (n * m). <br><br><h4>  How it works. </h4><br>  There is an interface class Linq, which describes all the methods of transformations.  Methods can be divided into two groups, those that lead to the further construction of the graph, they return Linq &lt;?&gt; For example, where: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; Linq&lt;T&gt; where(U f);</code> </pre> <br><br>  And "terminal", which start the execution of the graph, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; toVector();</code> </pre> <br><br>  The transformation graph is always given by value, but this is not a problem, as with the use of the semantics of the move, in most cases it was possible to do without full copying.  For example, in the first example, no deep copying occurs. <br><br>  Interestingly made additional ordering operations thenBy and thenByDesc.  Since they should be available only if the previous statement is orderBy or orderByDesc, then a Linq descendant is made for this, the LinqOrd class in which these operations are made, and the orderBy or orderByDesc methods are declared as returning LinqOrd: <br><br><pre> <code class="cpp hljs">LinqOrd&lt;T&gt; orderBy(); LinqOrd&lt;T&gt; orderByDesc();</code> </pre> <br><br>  Thus, after the orderBy operation, an object of type LinqOrd is returned, in which additional ordering operations already exist. <br><br>  Inside the Linq class there is a single data member, a pointer to the Range interface class.  This is the gear wheel of the transformation graph that performs all the work. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Range(){} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Range(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Range* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><br>  The interface is quite simple; it is, by and large, a unidirectional iterator.  The empty () method returns whether there are more elements.  The popFront () method retrieves the next element of the sequence, and front () returns the current element.  The rewind () method moves the pointer to the beginning of a sequence.  The clone () method creates a new object and makes a deep copy of the entire internal chain of filters. <br><br>  Conversion operations implement the Range interface.  For example, here‚Äôs the transformation code for the where operation: WhereRange &lt;T, F&gt;.  Where T is the type of the element, and F is the class of the object used for filtering.  In this case, F must have a method that accepts T or a reference to T and returns true if the element matches the filter conditions. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhereRange</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Range&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WhereRange(Range&lt;T&gt; *src, F f) : src_(src) , f_(f) , frontReady(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } ~WhereRange() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> src_; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frontReady) seekFront(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> src_-&gt;empty(); } <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frontReady) seekFront(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;result = src_-&gt;front(); frontReady = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; src_-&gt;popFront(); seekFront(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> src_-&gt;front(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ frontReady = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; src_-&gt;rewind(); } Range&lt;T&gt;* clone() override { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WhereRange(CloneRange(src_), f_); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Range&lt;T&gt; *src_; F f_; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> frontReady; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!src_-&gt;empty() &amp;&amp; !f_(src_-&gt;front())) src_-&gt;popFront(); frontReady = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><br>  To entrust even more work to the compiler, in lambda expressions, you can display the type of an element automatically, using the decltype keyword.  You can rewrite the first example as follows: <br><br><pre> <code class="cpp hljs">TestClass1 data[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> src = Linq::from(data); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = src .where([](<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(src.const_reference()) a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.iVal &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; }) .orderBy([](<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(src.const_reference()) a){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.sVal; }) .toVector();</code> </pre> <br><br>  As you can see, nowhere does the type of the element TestClass1 appear explicitly.  Sometimes it is convenient, and sometimes it is difficult to figure out what type we are dealing with. <br><br>  In the sequence merging example below, intermediate types are also output by the compiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data1 = testData1(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data2 = testData2(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> src1 = Linq::from(data1); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> src2 = Linq::from(data2); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = src1 .join( src2, [](<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(src1.const_reference()) a){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.iVal; }, [](<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(src2.const_reference()) b){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.iVal2; }, [] (<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(src1.const_reference()) a, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(src2.const_reference()) b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(b.dVal, a.sVal); } ) .toVector(); }</code> </pre> <br><br>  Here, the first and second lambdas return the keys by which sequences will be combined, and the third lambda returns the result formed from the matching elements of both sequences.  Then all received elements are saved in std :: vector. <br><br>  PS gcc 4.7 does not digest the override keyword, so for this you can set #define override </div><p>Source: <a href="https://habr.com/ru/post/180859/">https://habr.com/ru/post/180859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../180847/index.html">Django: JSON edit form widget</a></li>
<li><a href="../180849/index.html">The tool to control the behavior of robots on your site</a></li>
<li><a href="../180851/index.html">Advantages of placing in the Netherlands, EvoSwitch Data Center</a></li>
<li><a href="../180853/index.html">Optimize keywords for apps on the App Store</a></li>
<li><a href="../180857/index.html">How I Fought Sublime Text 2</a></li>
<li><a href="../180861/index.html">Google Glass and ridiculous view from the side</a></li>
<li><a href="../180863/index.html">Implementing ECB Encryption with the Marshall C # Library</a></li>
<li><a href="../180869/index.html">Scala rule-based inference engine</a></li>
<li><a href="../180873/index.html">DataEngine and Python2: Creating a new DataEngine</a></li>
<li><a href="../180875/index.html">And go to study at Harvard?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>