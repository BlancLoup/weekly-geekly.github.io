<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchrony 3: Subject model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 This article is a continuation of a series of articles about asynchrony: 



1. Asynchrony: back to the future. 
2. Asynchrony 2: teleport ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchrony 3: Subject model</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/59/ed/00/59ed00e49ed3c456596988.jpeg" alt="Two of the casket"><br><br><h2>  Foreword </h2><br>  This article is a continuation of a series of articles about asynchrony: <br><br><ol><li>  <a href="https://habrahabr.ru/post/201826/">Asynchrony: back to the future.</a> <br></li><li>  <a href="https://habrahabr.ru/company/yandex/blog/240525/">Asynchrony 2: teleport through portals.</a> <br></li></ol><br>  After 3 years, I decided to expand and summarize the existing range of asynchronous interaction using coroutines.  In addition to these articles, it is also recommended to familiarize yourself with the <em>universal adapter</em> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/340314/">Universal adapter</a> <br></li></ol><br><h2>  Introduction </h2><br>  Consider an electron.  What he really is?  A negatively charged elementary particle, a lepton with a certain mass.  This means that it can participate at least in electromagnetic and gravitational interactions. <br><a name="habracut"></a><br>  If we place a spherical electron in a vacuum, then all that it will be able to do is to move uniformly and straightforwardly.  3 degrees of freedom and spin, and only uniform rectilinear motion.  Nothing interesting and unusual. <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e44ba77011580638.png" alt="Electron"><br><br>  Everything changes in a completely surprising way if there are other particles nearby.  For example, a proton.  What do we know about him?  Many things.  We will be interested in the mass character and the presence of a positive charge, equal in absolute value to an electron, but with a different sign.  This means that the electron and proton will interact with each other in an electromagnetic manner. <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e43cf7b382205873.png" alt="Electron Proton"><br><br>  The result of this interaction will be a curvature of the rectilinear trajectory under the action of electromagnetic forces.  But this is half the trouble.  An electron flying near the proton will experience acceleration.  The electron-proton system will be a dipole, which suddenly begins to create <em>bremsstrahlung</em> .  Those.  generate electromagnetic waves propagating in a vacuum. <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e3eb7fd433905985.png" alt="Bremsstrahlung"><br><br>  But that's not all.  Under certain circumstances, the electron is captured into the orbit of the proton and it turns out the well-known system - the hydrogen atom.  What do we know about such a system?  Also a lot of things.  In particular, this system has a discrete set of energy levels and a line spectrum of radiation, which is formed during the transition between each pair of stationary states. <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e3f1a05808499217.png" alt="Hydrogen atom"><br><br>  And now let's take a look at this picture from a different angle.  Initially, we had two particles: a proton and an electron.  The particles themselves do not emit (they simply cannot), they do not manifest any discreteness, and generally behave calmly.  But the picture changes completely when they find each other.  There are new, completely unique properties - continuous and discrete spectrum, stationary states, the minimum energy level of the system.  In reality, of course, everything is much more complicated and interesting: <br><br><img src="https://habrastorage.org/webt/59/ed/03/59ed03258541f266948443.png" alt="Hydrogen H-beta"><br><br>  <sup><em>Asymmetry of the Stark broadening of the HŒ≤ spectral line of the hydrogen atom, <a href="https://www.researchgate.net/profile/Dragan_Nikolic2/publication/252317673_Experimental_and_Theoretical_Analysis_of_Central_Hb_Asymmetry/links/5658034308ae1ef9297bf662/Experimental-and-Theoretical-Analysis-of-Central-Hb-Asymmetry.pdf">Phys.</a></em></sup>  <sup><em><a href="https://www.researchgate.net/profile/Dragan_Nikolic2/publication/252317673_Experimental_and_Theoretical_Analysis_of_Central_Hb_Asymmetry/links/5658034308ae1ef9297bf662/Experimental-and-Theoretical-Analysis-of-Central-Hb-Asymmetry.pdf">Rev.</a></em></sup>  <sup><em><a href="https://www.researchgate.net/profile/Dragan_Nikolic2/publication/252317673_Experimental_and_Theoretical_Analysis_of_Central_Hb_Asymmetry/links/5658034308ae1ef9297bf662/Experimental-and-Theoretical-Analysis-of-Central-Hb-Asymmetry.pdf">E 79 (2009)</a></em></sup> <br><br>  This reasoning can go on and on.  For example, if you put two hydrogen atoms side by side, you get a stable configuration called <em>the hydrogen molecule</em> .  Here the electron-vibrational-rotational energy levels appear with a characteristic change in the spectrum, the appearance of the P, Q, R branches and many other things. <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e4a9a4f834825069.png" alt="Hydrogen Molecule"><br><br>  How so?  Is not the system described by its parts?  Not!  This is the essence of the fact that with the complication of the physical system, qualitative changes take place, which are not described by each part separately. <br><br>  Synergy of interaction manifests itself in many areas of scientific knowledge.  That is why chemistry is not reduced to physics, and biology to chemistry.  Despite the most powerful achievements of quantum mechanics, nevertheless chemistry as a section of scientific knowledge exists separately from physics.  It is interesting to note the fact that there are areas of knowledge at the interface of sciences, for example, <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B8%25D0%25BC%25D0%25B8%25D1%258F"><em>quantum chemistry</em></a> .  What does this mean?  That with the complication of the system there are new areas of research that were not at the previous level.  We have to take into account new circumstances, introduce additional qualitative factors, complicating each time the already difficult model of describing a quantum-mechanical system. <br><br>  The described metamorphosis can be reversed: if it is necessary to obtain a complex system of the simplest components, then these components should have a synergistic principle.  In particular, we all know that any problem can be solved by introducing an additional level of abstraction.  Except for the problem of the number of abstractions and the resulting complexity.  And only the synergy of abstractions reduces their number. <br><br>  Unfortunately, quite often our programs do not exhibit the described synergistic properties.  Is that in the bugs - there are new, hitherto unprecedented glitches that were not detected at the previous stage.  And how I wish that the application was not described by a set of parts and libraries of the program, but was something unique and ambitious. <br><br>  Let us now try to penetrate the essence of OOP and coroutines to obtain new and surprising properties of their synthesis in order to create a generalized model of interaction. <br><br><h2>  Object oriented programming </h2><br>  Consider OOP.  What do we know about him?  Encapsulation, inheritance, polymorphism?  <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID principles</a> ?  And let's ask Alan Kay, who introduced this concept: <br><blockquote>  When I talked about OOP, I did not mean C ++. <br><br>  <em>Alan Kay</em> . <br></blockquote><br>  This is a serious blow for C ++ programmers.  Even somehow it became insulting for the language.  But what did he mean?  Let's figure it out. <br><br>  The concept of objects was introduced in the mid-1960s with the advent of the Simula 67 language. This language introduced such concepts as object, virtual methods, and coroutines (!).  Then in the 1970s, the language Smalltalk, influenced by the language Simula 67, developed the idea of ‚Äã‚Äãobjects and introduced the term <em>object-oriented programming</em> .  It was there that the foundations of what we now call the PLO were laid.  Alan Kay himself commented on his sentence: <br><blockquote>  I regret having coined the term ‚Äúobjects‚Äù many years ago because it forces people to concentrate on small ideas.  A really big idea is messages. <br><br>  <em>Alan Kay</em> . <br></blockquote><br>  If you recall Smalltalk, it becomes clear what it means.  Sending messages was used in this language (see also ObjectiveC).  This mechanism worked, but was inhibitory.  Therefore, we went further along the path of the Simula language and replaced the sending of messages with regular function calls, as well as virtual function calls through the table of these virtual functions to support late binding. <br><br>  To return to the origins of OOP, let's take a fresh look at the classes and methods in C ++.  To do this, as an example, consider the <code>Reader</code> class, which reads the data from the source and returns an object of the <code>Buffer</code> type: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">Buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range range, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Options&amp; options)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ... };</span></span></code> </pre><br>  In this case, I will be interested only in the <code>read</code> method.  This method can be converted to the next, almost equivalent, call: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reader* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Range range, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Options&amp; options)</span></span></span></span>;</code> </pre><br>  Calling the object's method we simply turned into a stand-alone function.  This is exactly what the compiler does when it transforms our code into machine code.  However, such a path leads us away, or rather towards the language of S. Here the PLO does not even smell close, so let's go the other way. <br><br>  How do we call the <code>read</code> method?  For example: <br><br><pre> <code class="cpp hljs">Reader reader; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer = reader.read(range, options);</code> </pre><br>  Transform the <code>read</code> method call as follows: <br><br><pre> <code class="cpp hljs">reader &lt;- read(range, options) -&gt; buffer;</code> </pre><br>  This entry means the following.  An object named <code>reader</code> is given some kind of <code>read(range, options)</code> input, and the output is an object named <code>buffer</code> . <br><br>  What can <code>read(range, options)</code> ?  Some input message: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InReadMessage</span></span></span><span class="hljs-class"> {</span></span> Range range; Options options; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutReadMessage</span></span></span><span class="hljs-class"> {</span></span> Buffer buffer; }; reader &lt;- InReadMessage{range, options} -&gt; OutReadMessage;</code> </pre><br>  This transformation gives us a slightly different understanding of what is happening: instead of calling the function, we <em>synchronously</em> send the <code>InReadMessage</code> message and then wait for the OutReadMessage response message.  Why synchronous?  Because call semantics implies that we are waiting for a response.  However, generally speaking, the response message in the place of the call can not wait, then it will be <em>an asynchronous</em> message sending. <br><br>  Thus, all methods can be represented as handlers for various types of messages.  And our object automatically dispatches received messages, realizing the static pattern matching through the mechanism of the declaration of various methods and overloading the same methods with different types of input parameters. <br><br><h3>  Message Interception and Action Transformation </h3><br>  We are working on our messages.  How do we pack a message for later transformation?  For this we will use the adapter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderAdapter</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-function"><span class="hljs-function">Buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range range, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Options&amp; options)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> T_base::call([range, options](Reader&amp; reader) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reader.read(range, options); }); } };</code> </pre><br>  Now, when calling the <code>read</code> method, the call is wrapped in a lambda and <code>T_base::call</code> to the base method of the <code>T_base::call</code> method.  In this case, the lambda is a functional object that will transmit its closure to our heir object <code>T_base</code> , automatically dispatching it.  This lambda is our message, which we pass on to transform actions. <br><br>  The easiest way to transform is to synchronize access to an object: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_locker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseLocker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;T_locker&gt; _{lock_}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_base&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T_locker lock_; };</code> </pre><br>  Inside the <code>call</code> method, the <code>lock_</code> lock is <code>lock_</code> and the lambda is subsequently called on an instance of the <code>T_base</code> base class, which allows for further transformations if necessary. <br><br>  Let's try using this functionality: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ReaderAdapter&lt;BaseLocker&lt;Reader, std::mutex&gt;&gt; reader; auto buffer = reader.read(range, options);</span></span></code> </pre><br>  What's going on here?  Instead of using <code>Reader</code> directly, we now replace the object with a <code>ReaderAdapter</code> .  When the <code>read</code> method is called, this adapter creates a message in the form of a lambda and passes it on, where the lock is automatically taken and released strictly for the duration of this operation.  At the same time, we exactly keep the original interface of the <code>Reader</code> class! <br><br>  This approach can be easily generalized and use a universal adapter.  I <a href="https://www.youtube.com/watch%3Fv%3DmnH_-qFU5E0">told</a> about him <a href="https://www.youtube.com/watch%3Fv%3DmnH_-qFU5E0">at the C ++ conference</a> , which was held in Moscow in February 2017.  You can also read my recent article about the <a href="https://habrahabr.ru/post/340314/">universal adapter</a> . <br><br>  The corresponding code using the universal adapter will look like this: <br><br><pre> <code class="cpp hljs">DECL_ADAPTER(Reader, read) AdaptedLocked&lt;Reader, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; reader;</code> </pre><br>  Here, the adapter intercepts each method of the <code>Reader</code> class specified in the <code>DECL_ADAPTER</code> list, in this case <code>read</code> , and then <code>AdaptedLocked</code> already intercepted the message wraps in <code>std::mutex</code> .  This is described in more detail in the article just mentioned above, so here I will not dwell on this in detail. <br><br><h2>  Coroutines </h2><br>  With the PLO figured out a bit.  Now let's go on the other side and talk about coroutines. <br><br>  What are coroutines?  In short, these are functions that can be interrupted anywhere, and then continue from the same place, i.e.  freeze the execution and restore it from the interrupted point.  In this sense, they are very similar to threads: the operating system can freeze them at any time and switch to another thread.  For example, due to the fact that we ate too much CPU time. <br><br>  But then what is the difference from streams?  The difference is that we ourselves in the user space can switch our coroutines, our execution threads, without involving the core.  What allows, firstly, to improve performance, because  There is no need to switch protection rings, etc., and secondly, it adds more interesting ways of interaction, which will be discussed below. <br><br>  Some interesting ways of interaction can be read in <a href="https://habrahabr.ru/post/201826/">my previous</a> articles <a href="https://habrahabr.ru/company/yandex/blog/240525/">about asynchrony</a> . <br><br><h3>  Cospinlock </h3><br>  Consider the following piece of code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> synca { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spinlock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lock_.test_and_set(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_acquire)) { reschedule(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lock_.clear(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_release); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic_flag lock_ = ATOMIC_FLAG_INIT; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace synca</span></span></code> </pre><br>  The code above looks like a normal spinlock.  Indeed, inside the <code>lock</code> method we are trying to atomically set the flag value from <code>false</code> to <code>true</code> .  If we succeeded, the blocking was taken, and it was taken by us, and the necessary atomic actions can be performed.  When unblocking, simply reset the flag back to the initial value <code>false</code> . <br><br>  The whole difference lies in the implementation of the strategy of backtracking (backoff).  Often, either exponential randomized failures are used, or the transfer of control to the operating system via <code>std::this_thread::yield()</code> .  In this case, I'm acting smarter: instead of warming up the processor or transferring control to the operating system scheduler, I simply reschedule our coroutine for a later execution by calling <code>synca::reschedule</code> .  At the same time, the current execution is frozen, and the scheduler starts another, ready-to-run coroutine.  This is very similar to <code>std::this_thread::yield()</code> , except that instead of switching to kernel space, we always remain in user space and continue to do some meaningful work without an empty increase in the entropy of space. <br><br>  Apply adapter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CoSpinlock = AdaptedLocked&lt;T, synca::Spinlock&gt;; CoSpinlock&lt;Reader&gt; reader; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer = reader.read(range, options);</code> </pre><br>  As you can see, the use code and semantics have not changed, but the behavior has changed. <br><br><h3>  CoMutex </h3><br>  The same trick can also be done with a regular mutex, turning it asynchronous on coroutines.  To do this, you need to make a queue of waiting coroutines and launch them sequentially when the lock is released.  This can be illustrated by the following scheme: <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e4d2a8d296155107.png" alt="Mutex"><br><br>  I will not give the full implementation code here.  Those interested can familiarize themselves with it.  I will give only an example of use: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CoMutex = AdaptedLocked&lt;T, synca::Mutex&gt;; CoMutex&lt;Reader&gt; reader; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer = reader.read(range, options);</code> </pre><br>  Such a mutex has the semantics of a regular mutex, but it does not block the stream, forcing the coroutine planner to do useful work without switching to kernel space.  In this <code>CoMutex</code> , <code>CoMutex</code> , unlike <code>CoSpinlock</code> , gives a FIFO guarantee, i.e.  provides fair competitive access to the facility. <br><br><h3>  CoSerializedPortal </h3><br>  The <a href="https://habrahabr.ru/company/yandex/blog/240525/">Asynchrony 2: Teleportation through Portals</a> article examined in detail the issue of context switching between different planners through the use of teleportation and the portal.  Briefly describe this process. <br><br>  Consider an example when we need to switch a coroutine from one thread to another.  To do this, we can freeze the current state of our coroutine in the original thread, and then schedule the resumption of the coroutine in another thread: <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e504313997655649.png" alt="Teleport"><br><br>  This is exactly what will correspond to switching the performance from one thread to another.  Coroutine provides an additional level of abstraction between code and stream, allowing you to manipulate the current performance and perform various tricks and tricks.  Switching between different schedulers is teleportation. <br><br>  If we need to switch first to another scheduler, and then come back, then there is a portal, in the constructor of which there is a teleportation to another scheduler, and in the destructor - to the original one.  This guarantees a return to the source even when an exception is thrown. <br><br>  Accordingly, a simple idea arises.  Create a scheduler with one thread and reschedule our coroutines through the portals: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseSerializedPortal</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-comment"><span class="hljs-comment">//     1  BaseSerializedPortal() : tp_(1) {} protected: template &lt;typename F&gt; auto call(F&amp;&amp; f) { //        1  synca::Portal _{tp_}; return f(static_cast&lt;T_base&amp;&gt;(*this)); //        } private: mt::ThreadPool tp_; }; CoSerializedPortal&lt;Reader&gt; reader;</span></span></code> </pre><br>  It is clear that such a scheduler will serialize our actions, and therefore synchronize them with each other.  In this case, if the thread pool gives FIFO guarantees, then <code>CoSerializedPortal</code> will have a similar guarantee. <br><br><h3>  CoAlone </h3><br>  The previous approach with portals can be used somewhat differently.  To do this, use another scheduler: <code>synca::Alone</code> . <br><br>  This scheduler has the following wonderful property: at any given time, no more than one task of this scheduler can be executed.  Thus, <code>synca::Alone</code> guarantees that no handler will be launched in parallel with another.  There are tasks - only one of them will be performed.  No tasks - nothing is executed.  It is clear that with this approach, actions are serialized, which means that access through this scheduler will be synchronized.  Semantically, this is very similar to <code>CoSerializedPortal</code> .  However, it is worth noting that such a scheduler runs its tasks on a certain thread pool, i.e.  it does not create any new threads on its own, but works on existing ones. <br><br>  For more details, I send the reader to the original article <a href="https://habrahabr.ru/company/yandex/blog/240525/">Asynchrony 2: teleport through portals</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAlone</span></span></span><span class="hljs-class"> :</span></span> T_base { BaseAlone(mt::IScheduler&amp; scheduler) : alone_{scheduler} {} <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .. Alone - ,     synca::Portal _{alone_}; return f(static_cast&lt;T_base&amp;&gt;(*this)); } private: synca::Alone alone_; }; CoAlone&lt;Reader&gt; reader;</span></span></code> </pre><br>  The only difference in implementation compared to <code>CoSerializedPortal</code> is the replacement of the <code>mt::ThreadPool</code> <code>synca::Alone</code> with <code>synca::Alone</code> . <br><br><h3>  CoChannel </h3><br>  We introduce the concept of a channel on coroutines.  Ideologically, it is similar to <code>chan</code> channels in the Go language, i.e.  This is a queue (not necessarily, by the way, of limited size, as is done in Go), in which several data producers can simultaneously write and simultaneously read consumers without additional synchronization on their part.  Simply put, a channel is just a pipe into which you can add and take messages without fear of a race condition. <br><br>  The idea of ‚Äã‚Äãusing the channel is that users of our objects write messages to the channel, and the consumer is a specially created coroutine that reads messages in an infinite loop and dispatches them to the appropriate method. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseChannel</span></span></span><span class="hljs-class"> :</span></span> T_base { BaseChannel() { <span class="hljs-comment"><span class="hljs-comment">//        synca::go([&amp;] { loop(); }); } private: void loop() { //    //      for (auto&amp;&amp; action : channel_) { action(); } } synca::Channel&lt;Handler&gt; channel_; }; CoChannel&lt;Reader&gt; reader;</span></span></code> </pre><br>  Two questions immediately arise: the first and the second. <br><br><ol><li>  What is a <code>Handler</code> ? <br></li><li>  Where, actually, dispatching? <br></li></ol><br>  <code>Handler</code> is just <code>std::function&lt;void()&gt;</code> .  All the magic happens not here, but in how this <code>Handler</code> is created for automatic dispatch. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseChannel</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         fun auto fun = [&amp;] { return f(static_cast&lt;T_base&amp;&gt;(*this)); }; //      WrappedResult&lt;decltype(fun())&gt; result; channel_.put([&amp;] { try { //      -   result.set(wrap(fun)); } catch (std::exception&amp;) { //      result.setCurrentError(); } //       synca::done(); }); //       synca::wait(); //       return result.get().unwrap(); } };</span></span></code> </pre><br>  A fairly simple action takes place here: we intercept the intercepted method call inside the functor <code>f</code> in a <code>WrappedResult</code> , put this call inside the channel and <code>WrappedResult</code> .  We will call this deferred call inside the <code>BaseChannel::loop</code> method, thereby filling the result and resuming the fallen asleep source coroutine. <br><br>  It is worth saying a few words about the class <code>WrappedResult</code> .  This class serves several purposes: <br><br><ol><li>  It allows you to store either the result of a call or a caught exception. <br></li><li>  In addition, he solves the following problem.  The fact is that if the function does not return any values ‚Äã‚Äã(that is, returns the <code>void</code> type), then the construction of assigning the result without a wrapper would be incorrect.  Indeed, one cannot simply take the result <code>void</code> into a <code>void</code> type.  However, it is allowed to return, which is what the <code>WrappedResult&lt;void&gt;</code> specialization <code>WrappedResult&lt;void&gt;</code> through calls to <code>.get().unwrap()</code> . <br></li></ol><br>  As a result, we have synchronization of access to the object through a channel of method calls with captured parameters.  In this case, all methods are processed in a separate, isolated coroutine, which ensures the sequential execution of handlers to change our object. <br><br><h3>  Normal asynchrony </h3><br>  For the sake of interest, let's try to implement exactly the same behavior without an adapter and coroutines in order to most clearly demonstrate the power and strength of the abstractions used. <br><br>  To do this, consider the implementation of an asynchronous spinlock: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncSpinlock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; cb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lock_.test_and_set(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_acquire)) { <span class="hljs-comment"><span class="hljs-comment">//    =&gt;    currentScheduler().schedule( [this, cb = std::move(cb)]() mutable { lock(std::move(cb)); }); } else { cb(); } } void unlock() { lock_.clear(std::memory_order_release); } private: std::atomic_flag lock_ = ATOMIC_FLAG_INIT; };</span></span></code> </pre><br>  Here the standard interface of the spinlock has changed.  This interface has become more bulky and less enjoyable. <br><br>  Now let's implement the <code>AsyncSpinlockReader</code> class, which will use our asynchronous spinlock: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncSpinlockReader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range range, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Options&amp; options, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer&amp;)&gt; cbBuffer)</span></span></span><span class="hljs-function"> </span></span>{ spinlock_.lock( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, range, options, cbBuffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cbBuffer)] { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer = reader_.read(range, options); <span class="hljs-comment"><span class="hljs-comment">// ,  unlock , //         spinlock_.unlock(); cbBuffer(buffer); }); } private: AsyncSpinlock spinlock_; Reader reader_; }</span></span></code> </pre><br>  As we can see from the example of the <code>read</code> method, the <code>AsyncSpinlock</code> asynchronous spinlock <code>AsyncSpinlock</code> surely break the existing interfaces of our classes. <br><br>  And now consider the use of: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  // CoSpinlock&lt;Reader&gt; reader; // auto buffer = reader.read(range, options); AsyncSpinlockReader reader; reader.read(buffer, options, [](const Buffer&amp; buffer) { //       //         });</span></span></code> </pre><br>  Let's assume for a moment that <code>Spinlock::unlock</code> and the call to the <code>Reader::read</code> method are also asynchronous.  It's easy enough to believe, assuming that <code>Reader</code> pulls data across the network, and <code>Spinlock</code> are used instead of <code>Spinlock</code> , for example.  Then: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperAsyncSpinlockReader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     , //       void read(Range range, const Options&amp; options, std::function&lt;void(const Buffer&amp;)&gt; cb) { spinlock_.lock( [this, range, options, cb = std::move(cb)]() mutable { //  : read  reader_.read(range, options, [this, cb = std::move(cb)](const Buffer&amp; buffer) mutable { //  :   spinlock_.unlock( [buffer, cb = std::move(cb)] { //    cb(buffer); }); }); }); } private: AsyncSpinlock spinlock_; AsyncNetworkReader reader_; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e48c80b976902618.jpeg" alt="And so come down!"><br><br>  Such a frontal approach hints, as it were, that things will only get worse, because the working code tends to grow and become more complex. <br><br>  Naturally, the correct approach using coroutines makes such a synchronization scheme simple and straightforward. <br><br><h3>  Non-invasive asynchrony </h3><br>  All synchronization primitives considered are <em>implicitly asynchronous</em> .  The fact is that in the case of an already blocked resource with competitive access, our coroutine falls asleep to wake up at the time the lockout is released by the previous coroutine.  If we used the so-called <em>stackless coroutines</em> , which are still marinated in the new standard, we would have to use the keyword <code>co_await</code> .  And this, in turn, means that each (!) Call to any method wrapped through a sync adapter must add a call to <code>co_await</code> , changing the semantics and interfaces: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   Buffer baseRead() { Reader reader; return reader.read(range, options); } // callback-style //      void baseRead(std::function&lt;void(const Buffer&amp; buffer)&gt; cb) { AsyncReader reader; reader.read(range, options, cb); } // stackless coroutines //  ,    future_t&lt;Buffer&gt; standardPlannedRead() { CoMutex&lt;Reader&gt; reader; return co_await reader.read(range, options); } // stackful coroutines //    Buffer myRead() { CoMutex&lt;Reader&gt; reader; return reader.read(range, options); }</span></span></code> </pre><br>  Here, using the <em>stackless</em> approach, all interfaces in the call chain are scrapped.  In this case, there can be no transparency of speech, since  you can not just take and replace the <code>Reader</code> with <code>CoMutex&lt;Reader&gt;</code> .  Such an invasive approach significantly limits the scope of <em>stackless coroutines</em> . <br><br>  At the same time, this problem is completely absent from the <em>stackful-</em> based <em>coroutine</em> approach used in this article. <br><br>  You are given a unique choice: <br><br><ol><li>  Use an invasive breaking approach tomorrow (after 3 years, maybe). <br></li><li>  Use a non-invasive transparent approach today (more precisely, already yesterday). <br></li></ol><br><h3>  Hybrid approaches </h3><br>          .   ,         ,          . <br><br>    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasePortal</span></span></span><span class="hljs-class"> :</span></span> T_base, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> synca::SchedulerRef { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; BasePortal(mt::IScheduler&amp; scheduler, V&amp;&amp;... v) : T_base{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;V&gt;(v)...} , synca::SchedulerRef{scheduler} <span class="hljs-comment"><span class="hljs-comment">//   { } protected: template &lt;typename F&gt; auto call(F&amp;&amp; f) { //   f(...)    synca::Portal _{scheduler()}; return f(static_cast&lt;T_base&amp;&gt;(*this)); } using synca::SchedulerRef::scheduler; };</span></span></code> </pre><br>         <code>mt::IScheduler</code> ,      <code>f(static_cast&lt;T_base&amp;&gt;(*this))</code>    .          1    : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         mt::ThreadPool serialized{1}; CoPortal&lt;Reader&gt; reader1{serialized}; CoPortal&lt;Reader&gt; reader2{serialized};</span></span></code> </pre><br>      <code>Reader</code>        ,    <code>serialized</code> . <br><br>         <code>CoAlone</code>  <code>CoChannel</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// .. CoAlone  CoChannel   , //       mt::ThreadPool isolated{3}; //     //    isolated CoAlone&lt;Reader&gt; reader1{isolated}; //        //    isolated CoChannel&lt;Reader&gt; reader2{isolated};</span></span></code> </pre><br><h2>  </h2><br> ,    5            : <br><br><ol><li> <code>CoSpinlock</code> <br> </li><li> <code>CoMutex</code> <br> </li><li> <code>CoSerializedPortal</code> <br> </li><li> <code>CoAlone</code> <br> </li><li> <code>CoChannel</code> <br> </li></ol><br>         .       : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIND_SUBJECTOR(D_type, D_subjector, ...) \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; \ struct subjector::SubjectorPolicy&lt;D_type&gt; \ { \ using Type = D_subjector&lt;D_type, ##__VA_ARGS__&gt;; \ }; template &lt;typename T&gt; struct SubjectorPolicy { using Type = CoMutex&lt;T&gt;; }; template &lt;typename T&gt; using Subjector = typename SubjectorPolicy&lt;T&gt;::Type;</span></span></span></span></code> </pre><br>     <code>Subjector&lt;T&gt;</code> ,         5 .  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    Reader  3 : read, open, close //        DECL_ADAPTER(Reader, read, open, close) //  ,  Reader   CoChannel  . //    ,      CoMutex, // ..      BIND_SUBJECTOR(Reader, CoChannel) //      -    Subjector&lt;Reader&gt; reader;</span></span></code> </pre><br>       <code>Reader</code> , ,    ,        : <br><br><pre> <code class="cpp hljs">BIND_SUBJECTOR(Reader, CoSerializedPortal)</code> </pre><br>             ,        . <br><blockquote>       ,    ,     ,      .  -   . <br><br>  <em>Alan Kay</em> . <br></blockquote><br><h2>   </h2><br>         .  Those.          .       . ,         ,   ,   . <br><br>  Consider the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Network</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Packet&amp; packet)</span></span></span></span>; }; DECL_ADAPTER(Network, send) BIND_SUBJECTOR(Network, CoChannel)</code> </pre><br>     : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendPacket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Packet&amp; packet)</span></span></span><span class="hljs-function"> </span></span>{ Subjector&lt;Network&gt; network; network.send(myPacket); <span class="hljs-comment"><span class="hljs-comment">//    , //     doSomeOtherStuff(); }</span></span></code> </pre><br>   <code>doSomeOtherStuff()</code>  ,     <code>network.send()</code> .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendPacket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Packet&amp; packet)</span></span></span><span class="hljs-function"> </span></span>{ Subjector&lt;Network&gt; network; <span class="hljs-comment"><span class="hljs-comment">//   .async() network.async().send(myPacket); //    //    doSomeOtherStuff(); }</span></span></code> </pre><br>   ‚Äî     ! <br><br>  It works as follows.        <code>BaseAsyncWrapper</code>   <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B2%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD"><em>  </em></a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_derived&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAsyncWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_derived&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).asyncCall(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f)); } };</code> </pre><br>  Those.  <code>.async()</code>   <code>BaseAsyncWrapper</code> ,        <code>T_derived</code> ,      <code>asyncCall</code>  <code>call</code> .  ,   <code>Co</code> -    <code>asyncCall</code>    <code>call</code> ,     . <br><br>   <code>asyncCall</code>        : <br><br><ul><li>  <em> </em> : <code>CoSpinlock</code> , <code>CoMutex</code> , <code>CoSerializedPortal</code> , <code>CoAlone</code> .                . <br></li></ul><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Go</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> synca::go( [ f = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(f), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ]() { f(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_base&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }, T_base::scheduler()); } };</code> </pre><br><br><ul><li>  <em> </em> : <code>CoChannel</code> .          . <br></li></ul><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseChannel</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ channel_.put([ f = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(f), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ] { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { f(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_base&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp;) { <span class="hljs-comment"><span class="hljs-comment">// do nothing due to async call } }); } };</span></span></code> </pre><br><h2>  Specifications </h2><br>        : <br><br><img src="https://habrastorage.org/webt/59/ed/0c/59ed0cd95d125678708094.png" alt="Table"><br><br> <sup>1</sup> <em>       </em> . <br> <sup>2</sup> <em>   </em> . <br><br>     . <br><br><h3>  </h3><br>      ‚Äî , , <code>CoSpinlock</code> . ,            . <code>CoSpinlock</code>       , ..                 .          ,        . <br><br><h3> FIFO </h3><br> FIFO  first-in-first-out  ‚Äî   , ..    <code>.lock()</code> ,     .  ,            FIFO ,     <code>CoSpinlock</code>   FIFO-. <br><br><h3> Deadlock-free </h3><br>    ,        .       . <br><br><h3>  </h3><br>       ,       . ,       deadlock-free.           , ..            . <br><br><h3>  </h3><br>         <code>CoPortal</code> .  ‚Äî        .       <code>CoSerializedPortal</code> , ..            .   ,     ,      ,  : <code>CoAlone</code>  <code>CoChannel</code> .      .    ,           . <br><br><h3>  </h3><br>  ,   <code>CoChannel</code> ,       .   <code>CoChannel</code>       .  Those.        ‚Äî    .     : <br><br><ol><li> <em></em> :     . <br></li><li> <em>  </em> :      ,       ,  . <br></li></ol><br><h2>  ,   . </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I love to ask the following task. </font></font><br><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Suppose that all methods of our class are synchronized through a mutex. </font><font style="vertical-align: inherit;">Attention, question: is it possible to race? </font></font><br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e4d6c90848076223.jpeg" alt="Task race condition"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The obvious answer is no. </font><font style="vertical-align: inherit;">However, there is a trick here. </font><font style="vertical-align: inherit;">The thought begins to spin in the head, the brain begins to offer crazy options that do not correspond to the condition of the problem. </font><font style="vertical-align: inherit;">As a result, everything turns into ashes and hopelessness arises. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I advise you to think carefully before spying the answer. </font><font style="vertical-align: inherit;">But in order not to break the brain, below is the solution to this problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the class:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wrap up: </font></font><br><br><pre> <code class="cpp hljs">DECL_ADAPTER(Counter, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>, get) Subjector&lt;Counter&gt; counter;</code> </pre><br>  <code>get</code>  <code>set</code>    ,     .  . <br><br>     : <br><br> <em> 2</em> .     . <br><br>     : <br><br><pre> <code class="cpp hljs">counter.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(counter.get() + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>     ,   ,      ! <br><br>            . <br><br><h3>    . </h3><br>   data race,   : <br><blockquote> The execution of a program contains a data race if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other, except for the special case for signal handlers described below. Any such data race results in undefined behavior. <br><br> <em><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">C++17 Standard N4659, ¬ß4.7.1 (20.2)</a></em> <br></blockquote><br>     ‚Äî            - ,  <code>std::vector::push_back(value)</code> .     ,   ‚Äî    (,     ‚Äî ).        : <br><br><ol><li> <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a> :     runtime. <br></li><li> <a href="http://valgrind.org/docs/manual/hg-manual.html">Helgrind: a thread error detector</a> :  Valgrind    . <br></li><li> <a href="https://github.com/dvyukov/relacy">Relacy race detector</a> :   <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D1%2583%25D1%258E%25D1%2589%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">lock-free/wait-free</a>     . <br></li></ol><br><h3>    . </h3><br>    ,      .    ,       ,          .  ,      ,        <code>counter.set(counter.get() + 1)</code> .   - ,  <code>.get()</code>  <code>.set()</code>  . <br><br>              .       , ..       : <br><br><ol><li> <a href="https://people.cs.vt.edu/~dongyoon/papers/EUROSYS-17-NodeFz.pdf">Node.fz: fuzzing the server-side event-driven architecture</a> :   ,    ,   (!)  . <br></li><li> <a href="https://homes.cs.washington.edu/~pfonseca/papers/eurosys2017-dsbugs.pdf">An empirical study on the correctness of formally verified distributed systems</a> :     .  Those.    ,       ! <br></li></ol><br><h3>    </h3><br>         ,          .      <code>CoAlone</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> age)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; DECL_ADAPTER(User, setName, getName, setAge, getAge) BIND_SUBJECTOR(User, CoAlone) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increaseAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ user_.setAge(user_.getAge() + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Subjector&lt;User&gt; user_; }; UserManager manager; <span class="hljs-comment"><span class="hljs-comment">// race condition 2-  manager.increaseAge();</span></span></code> </pre><br>    <code>manager.increaseAge()</code>      2- ,          <code>increaseAge()</code>    . <br><br>     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increaseAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ user_.setAge(user_.getAge() + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Subjector&lt;User&gt; user_; }; DECL_ADAPTER(UserManager, increaseAge) BIND_SUBJECTOR(UserManager, CoAlone) Subjector&lt;UserManager&gt; manager; manager.increaseAge();</code> </pre><br>        <code>CoAlone</code> .  :       ? <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e46a130822017387.jpeg" alt=""><br><br> !   ,        2- . ,   <code>UserManager</code>      <code>Alone</code> .    <code>user_.getAge()</code>      <code>Alone</code> ,  <code>User</code> .  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another coroutine is now able to enter the method </font></font><code>increaseAge()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in parallel with the current one, which is currently inside </font></font><code>user_.getAge()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is possible because </font></font><code>Alone</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it guarantees only the absence of parallel execution in its scheduler. </font><font style="vertical-align: inherit;">In this case, parallel execution takes place in two different schedulers: </font></font><code>CoAlone&lt;User&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>CoAlone&lt;UserManager&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e3b73a1045995546.png" alt="Age with alone"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, there is a break of atomic execution in the case of synchronization based on the schedulers: </font></font><code>CoAlone</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>CoPortal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To remedy this situation, it is enough to replace:</font></font><br><br><pre> <code class="cpp hljs">BIND_SUBJECTOR(UserManager, CoMutex)</code> </pre><br><img src="https://habrastorage.org/webt/59/ed/95/59ed9530f0e28202059955.png" alt="Age with mutex"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This will prevent the race condition of the second kind. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Waiting for execution </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some cases, a sync break when executing code is extremely useful. </font><font style="vertical-align: inherit;">To do this, consider the following example:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UI</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,       void onRequestUser(const std::string&amp; userName); //       void updateUser(const User&amp; user); }; DECL_ADAPTER(UI, onRequestUser, updateUser) // UI     UI  BIND_SUBJECTOR(UI, CoPortal) struct UserManager { //     User getUser(const std::string&amp; userName); private: void addUser(const User&amp; user); User findUser(const std::string&amp; userName); }; DECL_ADAPTER(UserManager, getUser) BIND_SUBJECTOR(UserManager, CoAlone) struct NetworkManager { //       User getUser(const std::string&amp; userName); }; DECL_ADAPTER(NetworkManager, getUser) //        BIND_SUBJECTOR(NetworkManager, CoSerializedPortal) // ,     Subjector&lt;UserManager&gt;&amp; getUserManager(); Subjector&lt;NetworkManager&gt;&amp; getNetworkManager(); Subjector&lt;UI&gt;&amp; getUI(); void UI::onRequestUser(const std::string&amp; userName); { updateUser(getUserManager().getUser(userName)); } void UserManager::getUser(const std::string&amp; userName) { auto user = findUser(userName); if (user) { //   ,    return user; } //    , //      user = getNetworkManager().getUser(userName); //  ,     addUser(user); return user; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e501718414051029.png" alt="UI Interaction"><br><br>      <code>UI::onRequestUsername</code> .     UI    <code>UserManager::getUser</code>   .       UI     <code>Alone</code> ,      .   UI       .  ,   ,     UI,    . <br><br>  <code>UserManager</code>       ‚Äî   ,     .           <code>NetworkManager</code> .      <code>UserManager</code>       .       -    <code>UserManager</code> ,          !  Those.             .         ,        . ,   ! <br><br><h3>   </h3><br>    ,       ‚Äî    . : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// forward declaration struct User; DECL_ADAPTER(User, addFriend, getId, addFriendId) struct User { void addFriend(Subjector&lt;User&gt;&amp; myFriend) { auto friendId = myFriend.getId(); if (hasFriend(friendId)) { //     -     return; } addFriendId(friendId); auto myId = getId(); myFriend.addFriendId(myId); } Id getId() const; void addFriendId(Id id); private: bool hasFriend(Id id); }; //  void makeFriends(Subjector&lt;User&gt;&amp; u1, Subjector&lt;User&gt;&amp; u2) { u1.addFriend(u2); }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e41fad0333104336.png" alt="Deadlock"><br><br>  Since    <code>CoMutex</code> ,  <code>makeFriends</code>         .    ,      ?     : <br><br><pre> <code class="cpp hljs">BIND_SUBJECTOR(User, CoAlone)</code> </pre><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e41334b260303924.png" alt="Deadlock-Free"><br><br> ,       ,            ,       .    - ,    ? , . <br><br><h3>    </h3><br>          ,    :   <em></em> ,   <em>deadlock-free</em> ,  .  ,  ,           .   ,                .           . <br><br><h2>  Discussion </h2><br>   5     .    3               16              .   ,   - ,   ,     .        ,   ,        . <br><br>    16     ,     : <code>CoChannel&lt;T&gt;.async().someMethod(...)</code> .  ,     ,  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2"> </a> . ,   mailbox  ,     ,   ,      ++,      .  ,  ,      ,        , ,   ,    . <br><br>       ,             .     ,  ,   ,          .        ,       . <br><br><h2> :   </h2><br>    : <br><br><ol><li> <em> </em> .        ,          ‚Äî <strong></strong> . <br></li><li> <em>  </em> .          - .      ,   . <br></li><li> <em></em> .      ,         -  . <br></li><li> <em>    </em> .            .           ,       .        ,      ,      ,       . <br></li><li> <em> </em> .                      . <br></li><li> <em></em> .           ,          . <br></li><li> <em>,    </em> .             ,       <code>guard</code> , ,   ,   ..       ,       ,        . <br></li></ol><br>  ,    .  -   -        .  ,    ,  , , , , ,        ,     ,        <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D1%2583%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D1%258B">  </a> ,       :  <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258F%25D0%25B5%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C"> </a>   <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D0%25BC%25D0%25B5%25D0%25BD_%25D1%2581%25D0%25BE%25D0%25BE%25D0%25B1%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25D0%25BC%25D0%25B8"> </a> . <br><br>      : <strong> </strong> . <br><br> <a href="https://github.com/gridem/Subjector">https://github.com/gridem/Subjector</a> <br><br><img src="https://habrastorage.org/webt/59/ed/00/59ed00e4bb04f490106588.jpeg" alt="  !"><br><br><h2>  Literature </h2><br> [1] <a href="https://habrahabr.ru/post/201826/">:   </a> <br> [2] <a href="https://habrahabr.ru/company/yandex/blog/240525/"> 2:   </a> <br> [3] <a href="http://gridem.blogspot.com/2015/11/replicated-object-part-2-god-adapter.html">Blog: God Adapter</a> <br> [4] <a href="https://habrahabr.ru/post/340314/"> </a> <br> [5] <a href="http://www.cpp-russia.ru/talks/grigoriy-demchenko">:  </a> <br> [6] <a href="https://www.youtube.com/watch%3Fv%3DmnH_-qFU5E0">:  </a> <br> [7] <a href="https://www.researchgate.net/profile/Dragan_Nikolic2/publication/252317673_Experimental_and_Theoretical_Analysis_of_Central_Hb_Asymmetry/links/5658034308ae1ef9297bf662/Experimental-and-Theoretical-Analysis-of-Central-Hb-Asymmetry.pdf">S. Djuroviƒá, M. ƒÜiri≈°an, AV Demura, GV Demchenko, D. Nikoliƒá, MA Gigosos, et al., Measurements of HŒ≤ Stark central asymmetry and its analysis through standard theory and computer simulations, Phys. Rev. E 79 (2009) 46402.</a> <br> [8] <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B8%25D0%25BC%25D0%25B8%25D1%258F"> </a> <br> [9] <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">: SOLID</a> <br> [10] <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B2%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD">  </a> <br> [11] <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">C++17 Standard N4659</a> <br> [12] <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a> <br> [13] <a href="http://valgrind.org/docs/manual/hg-manual.html">Helgrind: a thread error detector</a> <br> [14] <a href="https://github.com/dvyukov/relacy">Relacy race detector</a> <br> [15] <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D1%2583%25D1%258E%25D1%2589%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F"> </a> <br> [16] <a href="https://people.cs.vt.edu/~dongyoon/papers/EUROSYS-17-NodeFz.pdf">J.Davis, A.Thekumparampil, D.Lee, Node.fz: fuzzing the server-side event-driven architecture. EuroSys '17 Proceedings of the Twelfth European Conference on Computer Systems, pp 145-160</a> <br> [17] <a href="https://homes.cs.washington.edu/~pfonseca/papers/eurosys2017-dsbugs.pdf">P.Fonseca, K.Zhang, X.Wang, A.Krishnamurthy, An empirical study on the correctness of formally verified distributed systems. EuroSys '17 Proceedings of the Twelfth European Conference on Computer Systems, pp 328-343</a> <br> [18] <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2"> </a> <br> [19] <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D1%2583%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D1%258B">  </a> <br> [20] <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258F%25D0%25B5%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C"> </a> <br> [21] <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D0%25BC%25D0%25B5%25D0%25BD_%25D1%2581%25D0%25BE%25D0%25BE%25D0%25B1%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25D0%25BC%25D0%25B8"> </a> <br></div><p>Source: <a href="https://habr.com/ru/post/340732/">https://habr.com/ru/post/340732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340718/index.html">Digmus - blockchain case: counterfeit check</a></li>
<li><a href="../340722/index.html">Currying and partial application in C ++ 14</a></li>
<li><a href="../340726/index.html">Code hiding and refactoring areas</a></li>
<li><a href="../340728/index.html">Monitoring with Prometheus at Kubernetes in 15 minutes</a></li>
<li><a href="../340730/index.html">Review of music software code defects. Part 3. Rosegarden</a></li>
<li><a href="../340734/index.html">Eleven project management mistakes on the example of the transatlantic yacht crossing</a></li>
<li><a href="../340736/index.html">Three bugs iOS developer, which can be costly</a></li>
<li><a href="../340738/index.html">DevOops 2017: Docker, Docker, Docker</a></li>
<li><a href="../340740/index.html">Vim after 15 years</a></li>
<li><a href="../340742/index.html">You can‚Äôt please everyone, or what we learn from the 2006 redesign of the Facebook feed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>