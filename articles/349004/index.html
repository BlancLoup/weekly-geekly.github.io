<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Linux API. Comprehensive Guide ¬ª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrozhiteli! Recently, we published the fundamental work of Michael Kerriska on the software interfaces of the Linux operating system. The book p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Linux API. Comprehensive Guide ¬ª</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/piter/blog/349004/"><img src="https://habrastorage.org/webt/qk/pj/rf/qkpjrftqtsq-bnryowiwf_v88us.jpeg" align="left" alt="image"></a>  Hi, Habrozhiteli!  Recently, we published the fundamental work of Michael Kerriska on the software interfaces of the Linux operating system.  The book provides almost a complete description of the system programming API running Linux. <br><br>  We will now look at the ‚ÄúExecution Flows: Introduction‚Äù section.  We will first take a look at the overview of how threads work, and then focus on how they are created and completed.  In the end, several factors will be considered that should be considered when choosing between two different approaches to designing applications - multi-threaded and multi-process. <br><br><a name="habracut"></a><br><h3>  29.1.  Short review </h3><br>  By analogy with processes, execution threads are a mechanism for simultaneous execution of several parallel tasks within a single application.  As shown in fig.  29.1, a single process may contain multiple threads.  All of them are executed within a single program independently of each other, sharing common global memory ‚Äî including initialized / uninitialized data and heap segments (the traditional UNIX process is just a special case of a multi-threaded process; it consists of a single thread). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fig.  29.1 some simplifications are allowed.  In particular, the location of stacks for each of the threads may intersect with shared libraries and shared memory locations;  this depends on the order in which the threads were created, the libraries were loaded, and the common chunks were added.  In addition, the location of the stacks for threads may vary depending on the Linux distribution. <br><br>  Threads in the process can run simultaneously.  In multiprocessor systems, parallel execution of threads is possible.  If one thread is blocked due to I / O, another can continue to work (sometimes it makes sense to create a separate thread that deals solely with I / O, although alternative I / O models are often more appropriate; for more details see chapter 59) . <br><br>  In some situations, threads have an advantage over processes.  Consider the traditional UNIX approach to ensuring competitive execution by creating multiple processes.  Take, for example, the network server model in which the parent process accepts incoming connections and creates separate child processes using the fork () call to communicate with each client (see section 56.3).  This allows you to simultaneously serve multiple connections.  Such an approach usually shows itself well, but in some situations it leads to the following limitations. <br><br><img src="https://habrastorage.org/webt/fj/s8/ml/fjs8mlh-a0a8d64xqpvkjcu9bpo.png" alt="image"><br><br><ul><li>  The exchange of information between processes has its own difficulties.  Since the parent and the child do not share the memory (in addition to the text segment, intended solely for reading), we are forced to use some form of interprocess communication to exchange data. </li><li>  Creating a process using fork () consumes relatively many resources.  Even if we use the copy-on-write method described in section 24.2.2, we still have to duplicate various process attributes, such as tables with memory pages and file descriptors;  this means that the fork () call still takes a significant amount of time.  Threads help get rid of both of these problems. </li><li>  The exchange of information between threads is simple and fast.  To do this, just need to copy the data to common variables (global or heap).  But in order to avoid problems that may arise in a situation where several threads try to update the same information at once, one has to apply the synchronization methods described in Chapter 30. </li><li>  Creating a stream takes less time than creating a process - usually we have at least a tenfold performance gain (in Linux, the threads are implemented using the clone () system call; the speed differences between it and the fork () call are shown in Table 28.3).  The process of creating a stream is faster because many attributes are simply separated instead of directly copied, as in the case of fork ().  In particular, there is no need to duplicate pages of memory (by copying while writing) and tables with pages. </li></ul><br>  In addition to global memory, threads also share a number of other attributes (this is when attributes are global for the whole process, and not for individual threads).  Among them are the attributes listed below. <br><br>  - Identifiers of the process and its parent. <br>  - Process group and session identifiers. <br>  - Managing terminal. <br>  - Process credentials (user and group identifiers). <br>  - Open file descriptors. <br>  - Record locks created by calling fcntl (). <br>  - Signal actions. <br>  - Information relating to the file system: umask, current and root directory. <br>  - Interval timers (setitimer ()) and POSIX timers (timer_create ()). <br>  - The semaphore cancellation values ‚Äã‚Äã(semadj) in System V. <br>  - Restrictions on resources. <br>  - CPU time consumed (derived from times ()). <br>  - consumed resources (obtained from getrusage ()). <br>  - The nice value (set with setpriority () and nice ()). <br><br>  The following are attributes that are unique to each individual stream: <br><br>  - Stream ID (see section 29.5). <br>  - Mask signal. <br>  - Data related to a specific flow (see section 31.3). <br>  - Alternative signal stack (sigaltstack ()). <br>  - Variable errno. <br>  - Floating point settings (see env (3)). <br>  - Policy and priority planning in real time (see sections 35.2 and 35.3). <br>  - Binding to the CPU (applies only to Linux, described in section 35.4). <br>  - Features (applies only to Linux, described in chapter 39). <br>  - Stack (local variables and function call layout information). <br><br>  As can be seen in fig.  29.1, all stacks related to individual threads are located within the same virtual address space.  This means that threads, having suitable pointers, can exchange data through each other's stacks.  This is convenient, but requires caution when writing code to resolve the dependency arising from the fact that a local variable remains valid only for the lifetime of the stack in which it is located (if the function returns a value, the memory used by its stack can be re-enabled during the subsequent function call; if the thread terminates, the section of memory in which its stack was located is formally available to another thread).  Incorrect work with this dependency can lead to errors that will be difficult to track. <br><br><h3>  29.2.  Pthreads API Overview </h3><br>  In the late 1980s and early 1990s, there were several different software interfaces for working with threads.  In 1995, the POSIX threads API was described in the POSIX.1 standard, which later became part of SUSv3.  The Pthreads software interface is based on several concepts.  We will get acquainted with them, considering in detail its implementation. <br><br>  <b>Pthreads data types</b> <br>  The Pthreads program interface defines a number of data types, some of which are listed in Table.  29.1.  Most of them will be described on the following pages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lu/yz/rt/luyzrtnwjnuqm9ixvsogi2x60cq.png" alt="image"></div><br>  The SUSv3 standard does not contain details on how exactly these types of data should be presented, so portable applications should consider them opaque.  This means that the program should not depend on the structure or contents of variables of any of these types.  In particular, we cannot compare such variables using the == operator. <br><br>  <b>Threads and errno</b> <br>  In the traditional UNIX programming interface, the errno variable is global and integer.  However, this is not enough for multi-threaded programs.  If a thread calls a function that writes an error to the global variable errno, this can be confusing to other threads, which also call functions and check the value of errno.  In other words, the result will be a race condition.  Thus, in multi-threaded programs, each thread has its own separate errno instance.  In Linux (and in most UNIX implementations), approximately one approach is used: errno is declared as a macro that expands into a function call that returns a variable value of the lvalue type that is unique to each individual thread (since the lvalue value is editable, we we can still write assignment operations like errno = value in multi-threaded programs. <br><br>  Summarizing the above: the errno mechanism was integrated into threads so that the error notification procedure is fully consistent with the traditional approach used in UNIX program interfaces. <br><br>  <b>The value returned by functions in pthreads</b> <br>  Traditionally, system calls and some functions return 0 if successful and ‚Äì1 if an error occurred.  To indicate the error itself, the variable errno is used.  Functions in the Pthreads API behave differently.  If successful, the return value is 0, but a positive value is used if an error occurs.  This is one of those values ‚Äã‚Äãthat can be assigned to the errno variable in traditional UNIX system calls. <br><br>  Since each reference to errno in a multi-threaded program incurs the overhead associated with calling a function, our program does not assign the value returned by a function from the Pthreads structure directly to this variable.  Instead, we use the intermediate variable and our diagnostic function errExitEN () (see subsection 3.5.2), as shown below: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">pthread_t</span></span> *thread; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> s; <span class="hljs-attribute"><span class="hljs-attribute">s</span></span> = pthread_create(&amp;thread, NULL, func, &amp;arg); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (s != <span class="hljs-number"><span class="hljs-number">0</span></span>) errExitEN(s, <span class="hljs-string"><span class="hljs-string">"pthread_create"</span></span>);</code> </pre> <br>  <b>Compiling Pthreads based programs</b> <br>  On Linux, programs that use the Pthreads API should be compiled with the cc -pthread parameter.  Among the actions of this parameter are the following. <br><br><ul><li>  The preprocessor macro _REENTRANT is declared.  This allows access to declarations of several reentrant (reintroduced) functions. </li><li>  The program is linked with the libpthread library (equivalent to the -lpthread parameter). </li></ul><br>  The specific compilation options for multi-threaded programs vary depending on the implementation (and compiler).  Some systems (such as Tru64) also use cc -pthread, although Solaris and HP-UX use the cc -mt option. <br><br><h3>  29.3.  Creating threads </h3><br>  Immediately after starting the program, the final process consists of one stream, which is called the source or main stream.  In this section, you will learn how to create additional threads. <br><br>  To create a new thread, use the pthread_create () function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ui/x-/touix-5yippjbh6kmz7gydfycya.png" alt="image"></div><br>  The new thread starts execution by calling the function specified as the start value and taking the arg argument (that is, start (arg)).  The thread that called pthread_create () continues to work by executing the instruction following this call (this corresponds to the behavior of the wrapper function around the clone () system call from the glibc library described in section 28.2). <br><br>  The arg argument is declared as void *.  This means that we can pass to the start function a pointer to an object of any type.  It usually points to a variable in global space or in a heap, but we can also use the value NULL.  If we need to pass several arguments to the start function, we can provide a pointer to the structure containing these arguments as separate fields as arg.  We can even specify arg as an integer (int) using the appropriate type conversion. <br><br>  Strictly speaking, C standards do not describe the results of casting int to void * and vice versa.  However, most compilers allow this operation and generate a predictable result ‚Äî that is, int j == (int) ((void *) j). <br><br>  The value returned by the start function is also of type void * and can be interpreted as the arg argument.  Below, when considering the pthread_join () function, you will learn how this value is used. <br><br>  Care should be taken when casting the value returned by the initial stream function to an integer.  The point is that the PTHREAD_CANCELED value returned when the stream is canceled (see Chapter 32) is usually implemented as an integer number converted to the void * type.  If the initial function returns this value, another thread executing pthread_join () will mistakenly take it as a cancellation notification.  In applications that allow cancellation of streams and use integers as values ‚Äã‚Äãreturned from the initial functions, it is necessary to ensure that in the streams ending normally, these values ‚Äã‚Äãdo not match the constant PTHREAD_CANCELED (whatever it is in the current implementation Pthreads).  Portable applications should do the same, but with all the implementations they can work with. <br><br>  The thread argument points to a buffer of type pthread_t, in which, before returning the function pthread_create (), writes the unique identifier of the thread created.  With this identifier you can refer to this thread in future calls to Pthreads. <br><br>  The SUSv3 standard states separately that the buffer pointed to by thread does not need to be initialized before starting a new thread.  That is, the new thread can start working before the pthread_create () function returns.  If a new thread needs to get its own identifier, it must use the pthread_self () function (described in section 29.5) for this. <br><br>  The attr argument is a pointer to the pthread_attr_t object, which contains the various attributes of the new thread (to which we will return in section 29.8).  If attr is set to NULL, the stream will be created with default attributes ‚Äî this is what we will do in most of the examples in this book. <br><br>  The program does not know to which thread the scheduler will allocate processor time after calling pthread_create () (in multiprocessor systems, both threads can run simultaneously on different CPUs).  Programs that explicitly rely on a specific planning procedure are subject to the same kinds of race conditions as described in section 24.4.  If we need to guarantee a particular order of execution, we must use one of the synchronization methods discussed in Chapter 30. <br><br><h3>  29.4.  Thread termination </h3><br>  Flow execution stops for one of the following reasons. <br><br><ul><li>  The initial function executes the return statement, specifying the return value for the stream. </li><li>  The thread calls the pthread_exit () function (described below). </li><li>  The thread is canceled using the pthread_cancel () function (described in section 32.1). </li><li>  Any of the threads calls exit () or the main thread executes a return statement (inside the main () function), which causes all threads in the process to terminate immediately. </li></ul><br>  The pthread_exit () function terminates the calling thread and specifies the return value that can be obtained from another thread using the pthread_join () function. <br><br><pre> <code class="hljs cs">include &lt;pthread.h&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *retval</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Calling pthread_exit () is equivalent to executing a return statement within the initial function of a thread, except that pthread_exit () can be called from any code that is started by the initial function. <br><br>  The retval argument stores the value returned by the stream.  The value pointed to by retval should not be on the stack of the thread itself, since after the end of the pthread_exit () call, its contents become undefined (this portion of the process‚Äôs virtual memory can be immediately allocated to the stack for the new thread).  The same applies to the value passed with the return statement in the initial function. <br><br>  If the main thread calls pthread_exit () instead of exit () or a return statement, the other threads will continue. <br><br><h3>  29.5.  Thread identifiers </h3><br>  Each thread within the process has its own unique identifier.  It is returned to the calling thread by the pthread_create () function.  In addition, using the pthread_self () function, a thread can get its own identifier. <br><br><pre> <code class="hljs cs">include &lt;pthread.h&gt; <span class="hljs-function"><span class="hljs-function">pthread_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_self</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Returns the ID of the calling thread. <br><br>  The thread identifiers inside the application can be used as follows. <br><br><ul><li>  Involved by various Pthreads functions to determine which thread they are running.  Examples include the functions pthread_join (), pthread_detach (), pthread_cancel () and pthread_kill ();  they are all described in this and subsequent chapters. </li><li>  In some applications, it may make sense to tag dynamic data structures with the identifier of a particular stream.  So we can determine the creator and "owner" of the structure;  it also allows you to define a stream that must perform some subsequent actions with the data structure. </li></ul><br>  The pthread_equal () function allows to check for two identities of threads for identity. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cz/b9/hs/czb9hszxw70ej-pxsgp0_dav5x8.png" alt="image"></div><br>  For example, to check whether the caller's identifier matches the value stored in the tid variable, you can write the following code: <br><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">pthread_equal</span></span>(<span class="hljs-name"><span class="hljs-name">tid</span></span>, pthread_self()) printf(<span class="hljs-string"><span class="hljs-string">"tid matches self\n"</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  The need for the pthread_equal () function arises from the fact that the pthread_t data type must be perceived as opaque.  In Linux, it is of type unsigned long, but on other systems it can be a pointer or a structure. <br><br>  In the NPTL library, pthread_t really is a pointer that is cast to an unsigned long type. <br><br>  The SUSv3 standard does not require the pthread_t type to be scalar.  It may be a structure.  Thus, the code for outputting the stream identifier presented above is not portable (although it works on many systems, including Linux, and can be useful during debugging): <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thr; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Thread ID = %ld\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) thr); <span class="hljs-comment"><span class="hljs-comment">/* ! */</span></span></code> </pre> <br>  In Linux, thread IDs are unique to all processes.  However, on other systems this may not be the case.  The SUSv3 standard states separately that portable applications cannot rely on these identifiers to define threads in other processes.  It also indicates that stream libraries can reuse these identifiers after attaching a completed stream with the pthread_join () function or after the disconnected thread has completed (the pthread_join () function will be discussed in the next section, and the disconnected streams in section 29.7). <br><br>  The POSIX and regular thread identifiers returned by the gettid () system call (available only on Linux) are not the same thing.  The POSIX flow identifier is assigned and maintained by the thread library implementation.  The regular thread identifier is returned by a call to gettid () and is a number (similar to the process identifier) ‚Äã‚Äãthat is assigned by the kernel.  And although the NPTL library implementation uses unique thread identifiers issued by the kernel, applications often do not need to be aware of them (besides, working with them makes it impossible for applications to be portable between different systems). <br><br><h3>  29.6.  Joining a completed stream </h3><br>  The pthread_join () function waits for the end of the thread indicated by the thread argument (if the thread has already terminated, it returns immediately).  This operation is called accession. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ly/n1/t3/lyn1t39cdfp28aukijdjzmgv8vo.png" alt="image"></div><br>  If the retval argument is a non-zero pointer, the function receives a copy of the return value of the completed stream, that is, the value specified when the thread executed a return statement or a call to pthread_exit (). <br><br>  A call to the pthread_join () function for the identifier of an already attached thread can lead to unpredictable consequences;  for example, we can join a thread that was created later and reuses the same identifier. <br><br>  If the thread is not disconnected (see section 29.7), we must join it with the pthread_join () function.  If we fail to do this, the completed stream will become an analogue of the ‚Äúzombie‚Äù process (see section 26.2).  In addition to the waste of resources, this can lead to the fact that we can no longer create new threads (in the event that a sufficient number of zombie flows accumulate). <br><br>  The procedure that the pthread_join () function performs on threads is similar to the action of calling waitpid () in the context of processes.  But there are noticeable differences between them. <br><br>  If the retval argument is a non-zero pointer, the function receives a copy of the return value of the completed stream, that is, the value specified when the thread executed a return statement or pthread_exit (). <br><br>  A call to the pthread_join () function for the identifier of an already attached thread can lead to unpredictable consequences;  for example, we can join a thread that was created later and reuses the same identifier. <br><br>  If the thread is not disconnected (see section 29.7), we must join it with the pthread_join () function.  If we fail to do this, the completed stream will become an analogue of the ‚Äúzombie‚Äù process (see section 26.2).  In addition to the waste of resources, this can lead to the fact that we can no longer create new threads (in the event that a sufficient number of zombie flows accumulate). <br><br>  The procedure that the pthread_join () function performs on threads is similar to the action of calling waitpid () in the context of processes.  But there are noticeable differences between them. <br><br><ul><li>  Threads do not have a hierarchy.  Any thread in the process can use the pthread_join () function to join another thread in the same process.  Imagine, for example, that flow A created flow B, which later created flow C;  in this case, flow A may join flow B and vice versa.  This is different from the hierarchical relationships between processes.  If the parent process created a descendant using fork (), he and he alone can wait for that descendant using the wait () call.  There is no such relationship between the thread that calls the pthread_create () function and the thread that is being created. </li><li>  It is impossible to join ‚Äúany thread‚Äù (in the case of processes, we can do this by calling waitpid (‚Äì1, &amp; status, options));  there is also no non-blocking join operation (similar to the waitpid () call with the WNOHANG flag).  Similar results can be achieved using conditional variables;  An example of this will be shown in subsection 30.2.4. </li></ul><br>  The restriction related to the fact that the pthread_join () function can attach threads only if there is a specific identifier was created intentionally.  The idea is that the program should only join those threads that it "knows" about.  The problem of ‚Äújoining an arbitrary stream‚Äù arises from the fact that streams do not have a hierarchy, so in this way we could really join any stream, including the private one created by the library function (using conditional variables described in section 30.2 .4, allows joining only to known streams).  As a result, the library would no longer be able to join this stream to gain its status, and attempts to join the already attached stream would lead to errors.  In other words, the operation of ‚Äújoining an arbitrary stream‚Äù is incompatible with the modular architecture of the application. <br><br>  <b>Sample program</b> <br>  The program shown in Listing 29.1 creates a new thread and joins it. <br><br>  Listing 29.1.  A simple program using the Pthreads library <br><br><pre> <code class="hljs markdown"><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">__threads/simple_thread c #include &lt;pthread.h&gt; #include "tlpi_hdr.h" static void * threadFunc(void *arg) { char *s = (char *) arg; printf("%s", s); return (void *) strlen(s); } int main(int argc, char *argv[]) { pthread_t t1; void *res; int s; s = pthread_create(&amp;t1, NULL, threadFunc, "Hello world\n"); if (s != 0) errExitEN(s, "pthread_create"); printf("Message from main()\n"); s = pthread_join(t1, &amp;res); if (s != 0) errExitEN(s, "pthread_join"); printf("Thread returned %ld\n", (long) res); exit(EXIT_SUCCESS); } __</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span>threads/simple_thread.c</code> </pre> <br>  Running this program, we will see the following: <br><br><pre> <code class="hljs cs">$ ./<span class="hljs-function"><span class="hljs-function">simple_thread Message </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">from</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) Hello world Thread returned 12</span></span></code> </pre> <br>  The order of output of the first two lines depends on how the scheduler uses two threads. <br><br><h3>  29.7.  Disconnect thread </h3><br>  By default, threads are joinable;  this means that after completion, their status can be obtained from another thread using the pthread_join () function.  Sometimes the status returned by the stream does not matter;  we just need the system to automatically free up resources and delete the stream when it is finished.  In this case, we can mark the thread as disconnected by using the pthread_detach () function and specifying the thread identifier in the thread argument. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2h/fv/h8/2hfvh8gd1grd-3vurelpus6zsii.png" alt="image"></div><br>  As an example of using the pthread_detach () function, we can use the following call, in which the thread disconnects itself: <br><br><pre> <code class="hljs lisp">pthread_detach(<span class="hljs-name"><span class="hljs-name">pthread_self</span></span>())<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  If the thread has already been disconnected, we can no longer get its return status using the pthread_join () function.  We also cannot make it rejoinable again. <br><br>  A disconnected thread does not become resistant to an exit () call made in another thread or to a return statement executed in the main program.  In any of these situations, all threads within the process are immediately terminated, regardless of whether they are attached or not.  In other words, the pthread_detach () function is simply responsible for the behavior of the thread after its completion, but not for the circumstances in which it terminates. <br><br><h3>  29.8.  Stream Attributes </h3><br>  As mentioned earlier, the attr argument of the pthread_create () function, which is of type pthread_attr_t, can be used to set attributes that are used when creating a new thread.  We will not go into the consideration of these attributes (for details, look for them in the links listed at the end of the chapter) or study the prototypes of various Pthreads functions that allow you to work with the pthread_attr_t object.  We simply note that these attributes contain information such as the location and size of the flow stack, its scheduling policy and priority (this is similar to real-time scheduling policies and process priorities described in sections 35.2 and 35.3), as well as information about , whether the stream is attached or disconnected. <br><br>  An example of using these attributes is shown in Listing 29.2, where a thread is created that is disconnected at the time of its appearance (and not as a result of a subsequent call to pthread_detach ()).  At the very beginning, this code initializes the structure with attributes using default values, then sets the attributes necessary to create the detached stream, and then creates a new stream using this structure.  At the end of the creation procedure, an object with attributes is deleted as unnecessary. <br><br>  Listing 29.2.  Creating a stream with a ‚Äúdisconnecting‚Äù attribute <br><br><pre> <code class="hljs pgsql">__________________________________________________   threads/detached_attrib.c #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;pthread.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "tlpi_hdr.h" static <span class="hljs-type"><span class="hljs-type">void</span></span> * threadFunc(<span class="hljs-type"><span class="hljs-type">void</span></span> *x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> *argv[]) { pthread_t thr; pthread_attr_t attr; <span class="hljs-type"><span class="hljs-type">int</span></span> s; s = pthread_attr_init(&amp;attr); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-number"><span class="hljs-number">0</span></span>) errExitEN(s, "pthread_attr_init"); s = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-number"><span class="hljs-number">0</span></span>) errExitEN(s, "pthread_attr_setdetachstate"); s = pthread_create(&amp;thr, &amp;attr, threadFunc, (<span class="hljs-type"><span class="hljs-type">void</span></span> *) <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-number"><span class="hljs-number">0</span></span>) errExitEN(s, "pthread_create"); s = pthread_attr_destroy(&amp;attr); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-number"><span class="hljs-number">0</span></span>) errExitEN(s, "pthread_attr_destroy"); s = pthread_join(thr, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-number"><span class="hljs-number">0</span></span>) errExitEN(s, "pthread_join failed as expected"); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(EXIT_SUCCESS); } __________________________________________________   threads/detached_attrib.c</code> </pre> <br><h3>  29.9.  Comparing threads and processes </h3><br>  In this section, we briefly consider several factors that should be considered when choosing between threads and processes as the basis for your application.  Let's start by discussing the benefits of a multi-threaded approach. <br><br><ul><li>  Sharing data between threads is easy.  The same data exchange, but between processes requires more costs (for example, creating a common memory segment or using a pipeline). </li><li>  Creating a thread takes less time than creating a process;  threads can also benefit in terms of context switching speeds.  However, threads have certain drawbacks compared to processes. </li><li>     ,     ,            (       31.1).       . </li><li>     (,     )      ,           .  ,       . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each thread competes for the ability to use the final address space of its process. </font><font style="vertical-align: inherit;">In particular, the stack and local storage of each thread consumes part of the process's virtual memory, which makes it inaccessible to other threads. </font><font style="vertical-align: inherit;">Although the address space is quite large (for example, 3 GB for the x86-32 architecture), this factor can be a significant limitation, which hinders the process of creating a large number of threads or threads that require a lot of memory. </font><font style="vertical-align: inherit;">Separate processes, on the other hand, can involve the entire range of free virtual memory, limited only by the size of the RAM and the paging space.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following are additional points that may affect the choice between threads and processes. </font></font><br><br><ul><li>          ( ,       ).          33.2. </li><li>             (,    ).         . </li><li>   ,      (,  ,  ,  ,  ()   ).     ,   ,    . </li></ul><br><h3> 29.10.  Summary </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In multithreaded processes in the same program simultaneously run different threads. </font><font style="vertical-align: inherit;">All of them have common global variables and a bunch, but each of them has its own separate stack for local variables. </font><font style="vertical-align: inherit;">Different threads of the same process also share a number of attributes, including the process ID, open file descriptor, signal actions, current directory, and resource limits.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A key feature of threads is the simpler exchange of information compared to processes; </font><font style="vertical-align: inherit;">for this reason, some software architectures are better placed on a multi-threaded approach than on a multiprocess one. </font><font style="vertical-align: inherit;">In addition, in some situations, threads may exhibit better performance (for example, a thread is created faster than a process), but this factor is usually secondary when choosing between threads and processes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads are created using the pthread_create () function. </font><font style="vertical-align: inherit;">Any thread can complete independently of the others, using the pthread_exit () function (if you call exit () on any of the threads, all of them will be completed immediately). </font><font style="vertical-align: inherit;">If a thread has not been marked as disconnected (for example, by calling pthread_detach ()), it must be connected by another thread through the pthread_join () function, which returns the exit code of the attached thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ªMore information about the book can be found </font></font><a href="https://www.piter.com/collection/new/product/linux-api-ischerpyvayuschee-rukovodstvo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the publisher's website.</font></font></a> <br>  ¬ª <a href="http://storage.piter.com/upload/contents/978549602689/978549602689_X.pdf">Table of Contents</a> <br>  ¬ª <a href="http://storage.piter.com/upload/contents/978549602689/978549602689_p.pdf">Excerpt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Habrozhiteley 20% discount coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></b> </div><p>Source: <a href="https://habr.com/ru/post/349004/">https://habr.com/ru/post/349004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348990/index.html">Autodial: Good and Evil</a></li>
<li><a href="../348994/index.html">Intellectual Innovation: New HPE Webinar Series</a></li>
<li><a href="../348996/index.html">Simple Stack Fragment</a></li>
<li><a href="../349000/index.html">Report of the Information Security Monitoring Center for the II half of 2017</a></li>
<li><a href="../349002/index.html">Win 100k on the hackathon of the Food Party and Touch Instinct in Petersburg</a></li>
<li><a href="../349006/index.html">Coding without a keyboard: creating a hands-free game</a></li>
<li><a href="../349010/index.html">Technical support: a technological approach to solving technical problems</a></li>
<li><a href="../349012/index.html">Why your application looks better in Sketch</a></li>
<li><a href="../349014/index.html">Learning KTX for Android</a></li>
<li><a href="../349016/index.html">Deep Learning in Natural Language Processing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>