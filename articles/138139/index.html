<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Knowledge reuse</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is not the first time that I come across discussions about who is studying new technologies and how and how to cope with the huge stream of ‚Äúinnova...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Knowledge reuse</h1><div class="post__text post__text-html js-mediator-article">  It is not the first time that I come across discussions about who is studying new technologies and how and how to cope with the huge stream of ‚Äúinnovations‚Äù that appear every year in the software industry.  Once I have already answered this <a href="http://rsdn.ru/forum/philosophy/3646599.1.aspx">question</a> on a qvt, and after the <a href="http://rsdn.ru/forum/dotnet/4576929.flat.aspx">next question</a> I decided to shape these thoughts in a more structured way. <br><br>  If you look around, you might get the impression that the software development industry is taking such huge strides that there is no way to keep up with it.  And if we consider the entire industry as a whole, then indeed it is.  Somehow I immediately recall old Brooks with his <a href="http://sergeyteplyakov.blogspot.com/2009/02/blog-post.html">‚ÄúMythical Man-Month‚Äù</a> , when he wrote in conclusion to his book about how the software industry changed in the mid-90s compared to the 50s.  In those early years (yes, the 90s are already far away too, so to speak of the era of the birth of the industry forty years earlier) you could read <b>all the magazines (!)</b> Of computer subjects that were published.  Now, dozens of books appear monthly on only one of the popular technologies, and the number of articles simply does not count. <br><br><a name="habracut"></a><br>  On the one hand, this makes it necessary to treat the choice of sources of information in a more conscious and prudent way.  And it was this thought that prompted me to form the list of the <a href="http://sergeyteplyakov.blogspot.com/2010/03/blog-post.html">most interesting books on programming</a> in general, and separately, the most <a href="http://sergeyteplyakov.blogspot.com/2011/04/cnet.html">significant books on the C # language and the .NET platform</a> .  But in addition to high-quality information sources (a list of books it would be good to add a list of blogs, podcasts and video tutorials) an important quality of any programmer is the structuring and ‚Äúreuse‚Äù of the knowledge gained. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      By the nature of our activities, we often face problems of complexity.  We are used to fighting it in a variety of ways;  we create small proven building blocks, on the basis of which we build large software solutions, we abstract from insignificant details, hiding implementation details behind the public interface of classes or entire modules, we create hierarchies of classes for summarizing and reusing knowledge and effort. <br><br>  But what if you try to draw parallels between generally accepted software design practitioners and our knowledge?  Here, for example, task decomposition is perfectly applicable, both in programming and in training.  We all know very well how easy it is to make everything difficult (sorry for the pun), if you mix in one method simple business logic and logic for working with C-lines.  If the method requires a dozen more or less simple operations with strings, then it will be very difficult to understand what is going on in it because of all these strlen, strcpy, strcmp, strcat and many other operations, each of which may contain an error. <br><br>  <font color="#526e66"><b>NOTE</b></font> <font color="#526e66"><br></font>  <font color="#526e66">It is considered that the main advantage of encapsulation is to <b>protect the internal implementation of the class from external clients</b> ;</font>  <font color="#526e66">they say, thanks to the encapsulation, the ‚Äúservice provider‚Äù can change the internal behavior (or presentation) without affecting the clients.</font>  <font color="#526e66">However, encapsulation is not a one gate game;</font>  <font color="#526e66">In addition to the fact that the class can change its implementation, <b>encapsulation allows unloading the client from unnecessary implementation details</b> , making his (client) life much easier.</font> <br><br>  Mixing fairly simple logic in one place along with a poorly designed abstraction, we get a combinatorial growth of complexity that will explode the brain even when writing code, not to mention its support.  The same can be noted, for example, when discussing a certain task within a team, when the interlocutor throws a huge amount of information at you, most of which could be dispensed by both interlocutors.  When learning something new, the same problem manifests itself even more acutely: <i>one</i> <i>step</i> <i>at</i> <i>a</i> <i>time</i> is <a href="http://sergeyteplyakov.blogspot.com/2012/01/18.html">John Skitt‚Äôs</a> favorite approach in describing the capabilities of the C # language, which he successfully uses in his book <a href="http://sergeyteplyakov.blogspot.com/2011/04/c-in-depth-2nd-edition.html">‚ÄúC # In Depth‚Äù</a> , and it‚Äôs this approach that makes him The book is easy to read and understand. <br><br><img src="https://habrastorage.org/storage2/d77/69e/c1b/d7769ec1b17bf83a82694c337eb241d0.jpg"><br>  Abstractions form a hierarchy (*) <br>  (*) This is a drawing from the book Grady Bucha <a href="http://sergeyteplyakov.blogspot.com/2009/09/blog-post_15.html">"Object-oriented analysis and design with examples of applications</a> . <a href="http://sergeyteplyakov.blogspot.com/2009/09/blog-post_15.html">"</a> <br><br>  Now let's look at another aspect of development that can be directly used in training.  According to Grady Bucha - any complex system is hierarchical.  It is the hierarchy and modularity that allow you to somehow cope with the incredible complexity of the simulated systems.  And if you consider any modern technology, you can see that the number of layers in it will be huge, and that each of them is based on well-tested layers of the lower level. <br><br><h5>  Reuse knowledge on the example of WCF </h5><br><br>  Let's take WCF as an example. <br><img src="https://habrastorage.org/storage2/c56/620/968/c56620968adb08a6d331689c10ba278d.jpg"><br><br>  No modern technology is a spherical horse built in a vacuum from basic concepts or other similar technologies.  In fact, most of them are just a <b>new combination</b> , well-proven and well-known concepts, and WCF is no exception here. <br><br>  Modern technologies for building distributed applications are quite similar.  All of them are built on the basis of proven patterns, use low-level transport protocols and, to some extent, struggle with misconceptions about distributed applications (Fallacies of Distributed Computing). <br><br>  So, for example, if you have experience with .NET Remoting, then you can reuse it when switching to WCF: each of these technologies is such a ‚Äúpuff‚Äù cake, with the ability to configure and customize various levels.  In both technologies, we can use different instantiations and concurrency methods, customize security, and manage serialization. <br><br>  You can also reuse knowledge of low-level communication protocols, because sooner or later problems will start in your system that cannot be solved without WireShark and packet analysis.  In addition, many problems or their solutions can be embedded in the very nature of the transport protocol, and without this knowledge you simply cannot make a reasonable decision whether to use binding based on the HTTP or TCP protocol in this situation. <br><br>  The same applies to the ‚Äúservice‚Äù component of WCF.  Service architecture is a separate aspect that can be explored outside of WCF (for example, using web services) and re-using it in the context of a new technology.  Of course, each of the building blocks on which the technology is built can be used in a specific way, but knowledge of the fundamental principles will make it easier to understand the new technology. <br><br>  <font color="#526e66"><b>NOTE</b></font> <font color="#526e66"><br></font>  <font color="#526e66">Once I tried to answer the question</font> <a href="http://sergeyteplyakov.blogspot.com/2011/02/wcf.html"><font color="#526e66">‚ÄúWhat is WCF?‚Äù</font></a> <font color="#526e66">, Trying to use the method of knowledge reuse described here and make the most of analogies with WCF receivers, such as .NET Remoting and web services.</font> <br><br><h5>  <b>Generalization of knowledge on the example of automatic memory management</b> </h5><br><br>  In addition to hierarchy and reuse of low-level basic blocks, we can use another OOP mechanism to deal with the complexity: generalization and specialization using inheritance. <br><br>  Inheritance is one of the main ‚Äúbusiness cards‚Äù of the PLO and one of the main mechanisms for reuse, so it is not surprising that they are often abused.  When designing software, there is often a problem called ‚Äú <b>premature generalization</b> ‚Äù (premature generalization), where base classes with a certain behavior are introduced at too early stages of development, although it is not yet clear what is ‚Äúcommon‚Äù in this particular case.  For example, quite often you can see a hierarchy of 5 base classes for a simple class <b>Customer</b> , although at the current stage it is not at all clear why this is needed. <br><br>  <font color="#526e66"><b>NOTE</b></font> <font color="#526e66"><br></font>  <font color="#526e66">Bertrand Meyer very well described the reasons for this state of affairs in software design: ‚ÄúArbitrarily or not, many training presentations create the impression that the structure of inheritance should be designed from the most general (upper part) to more specific parts (leaves).</font>  <font color="#526e66">In particular, this is because the best way to <i>describe the</i> existing structure is to go from the general to the particular, from figures to closed figures, then to polygons, rectangles, and squares.</font>  <font color="#526e66">But the best way to describe the structure does not mean that it is the best way to <i>create it</i> .</font> <font color="#526e66"><br></font>  <font color="#526e66">In an ideal world inhabited by perfect people, we would immediately discover the correct abstractions, derive categories from them, then their subcategories, and so on.</font>  <font color="#526e66"><i>In the real world, however, we often first discover a particular case and only then discover a common abstraction</i> . ‚Äù</font> <br><br>  Likewise, the situation is quite typical when the interlocutor summarizes his experience and knowledge gained in one project with one programming language to other projects and other programming languages.  In essence, he summarizes this knowledge into the ‚Äúbase‚Äù classes of his knowledge, although at the moment these classes have only one ‚Äúheir‚Äù: <br><br>  <i>I: I know that multiple inheritance is garbage!</i> <i><br></i>  <i>He: Why?</i> <i><br></i>  <i>I: Because it is not in</i> <i>Java</i> <i>, but I do not know other languages!</i> <br><br>  It is rather rash to draw such conclusions if the only language I know is Java.  Most likely, I can make more correct conclusions and structure my knowledge more consciously, having become acquainted with at least several languages ‚Äã‚Äãthat support multiple inheritance, such as C ++ and Eiffel. <br><br>  Let us, as an example, consider several ways of automatic memory management and present them in a hierarchical form. <br><br><img src="https://habrastorage.org/storage2/3a5/318/fe9/3a5318fe9be5bf9e423ccfe8586407cd.jpg"><br><br>  Automatic memory management is the most common concept, which falls under several special cases.  For example, two most typical solutions can be distinguished, based on (1) garbage collection (2) and reference counting;  at the same time, garbage collectors can use generations (generations) or not. <br><br>  Each solution has its own advantages and disadvantages.  Thus, memory management based on reference counting will suffer from ‚Äúring‚Äù dependencies (when object A contains a reference to object B, it contains a reference to object C, and it again refers to A), but it will ensure the determinism of resource cleanup.  The garbage collector will solve the problem with cyclical references, but it will have to pay for it by the lack of determinism of resource release. <br><br>  When studying different programming languages, you can try to remember exactly how automatic memory management is implemented in each of them, but after studying several languages, it will be more efficient to generalize this knowledge and reuse it.  Of course, each platform or programming language has its own characteristics, but knowledge of the basic mechanisms of memory management will significantly reduce the learning curve, because only differences will need to be understood and remembered, not the whole mechanism.  That is why ‚Äúpragmatists‚Äù Dave Thomas and Andy Hunt in their book <a href="http://sergeyteplyakov.blogspot.com/2009/09/blog-post.html">‚ÄúThe Programmer-Pragmatist.</a>  <a href="http://sergeyteplyakov.blogspot.com/2009/09/blog-post.html">The path from the apprentice to the master "</a> advised to learn one programming language each year and get acquainted with other platforms and operating systems.  Such a broadening of horizons will allow a wider view of new tasks, as well as allow generalizing and structuring existing knowledge. <br><br><h5>  Conclusion </h5><br><br><img src="https://habrastorage.org/storage2/6da/f14/95a/6daf1495adb7bf9b35b21cd4e6846daf.jpg"><br><br>  No matter how many ‚Äúnew‚Äù technologies would come out, no matter how many new levels of abstraction would be invented, knowledge of the ‚Äúfundamentals‚Äù would always be useful.  It is much easier to understand several fundamental principles, instead of learning hundreds of seemingly unrelated facts.  Knowledge of low-level concepts can be reused, which will significantly reduce the time to study "new technologies", because for the most part, they are not.  In addition, sooner or later <a href="http://russian.joelonsoftware.com/Articles/LeakyAbstractions.html">‚Äúabstractions will be allowed to flow‚Äù</a> and in order to eliminate it, you will have to understand how it is arranged inside. </div><p>Source: <a href="https://habr.com/ru/post/138139/">https://habr.com/ru/post/138139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138132/index.html">GCC Profile-guided optimization</a></li>
<li><a href="../138133/index.html">China began to withdraw iPad from sale</a></li>
<li><a href="../138135/index.html">Stroboscopic Valentine</a></li>
<li><a href="../138136/index.html">Twietry - write poems together</a></li>
<li><a href="../138137/index.html">Kazakhstan received the Cyrillic domain ".“ö–ê–ó"</a></li>
<li><a href="../138141/index.html">Competition for the best name of the project on video surveillance of the presidential elections in Russia</a></li>
<li><a href="../138144/index.html">Console Player .wav for pc-speaker in Linux</a></li>
<li><a href="../138145/index.html">Automate vacation</a></li>
<li><a href="../138146/index.html">Merge sort without using additional memory</a></li>
<li><a href="../138147/index.html">Firefox developers have published a roadmap for 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>