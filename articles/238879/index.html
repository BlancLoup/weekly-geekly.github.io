<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Curry on C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. 

 I sat one evening, waited for a fresh revision of the clang to gather, and looked at the code for one of my projects , in which not very ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Curry on C ++</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr. <br><br>  I sat one evening, waited for a fresh revision of the clang to gather, and looked at the code for <i>one of my projects</i> , in which not very beautiful things were encountered <br><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform (someContainer.begin (), someContainer.end (), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter (otherContainer), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeUglyAndLongType&amp; item) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandleItem (item); });</code> </pre> <br>  Why create a whole lambda so that the function of two arguments (if, as the classics say, <code>this</code> considered to be an implicit zero argument) fix one of them?  On some pseudochaskele one could just write something like <br><pre> <code class="hljs lisp">map (<span class="hljs-name"><span class="hljs-name">handleItem</span></span> this) someContainer</code> </pre> <br>  We'll do the maps, functors, and other monads sometime next time, but we can try to learn how to write things that resemble <code>(handleItem this)</code> . <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, what do you want to do?  I would like to learn to <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">curry</a> arbitrary functions, that is, to call them in "pieces" - they passed the first argument, got some new function of one argument, passed the second, got a new function, and so on until all the arguments for our original function are passed .  When the arguments are over, go to the person and call our original function with all the specified arguments. <br><br>  Or, if suddenly it will be more understandable to someone, it is necessary to make a sequence of functions T <sub>1</sub> ‚Üí (T <sub>2</sub> ‚Üí (... ‚Üí (T <sub>N</sub> ‚Üí R)) from the function N arguments T <sub>1</sub> √ó T <sub>2</sub> √ó‚Ä¶ √ó T <sub>N</sub> ‚Üí R.  Although, to whom it is so clear, he probably even knows what currying is without me. <br><br>  Immediately I warn you that the solution will be non-production-quality for several reasons, which we will discuss a little later. <br><br>  What do we need for this?  You need a fresh compiler with C ++ 14 support, for example, clang 3.4 and newer.  You also need a standard library from C ++ 14, on some Linux systems there may be problems with it, so you can play with code on online services like <a href="http://melpon.org/wandbox/">this</a> . <br><br>  What should look like the result of our attempts to make C ++ Haskel on, actually, pluses?  Well, for example, something like this: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 * t2 * t3 * str.size (); } <span class="hljs-comment"><span class="hljs-comment">// ... std::cout &lt;&lt; curry (test) (1) (2) (3.0) ("four") &lt;&lt; std::endl;</span></span></code> </pre><br>  Naturally, free <code>curry</code> functions should not be limited. <br><br>  What do we need to do?  Yes, nothing, write the curry function.  So let's write! <br><br>  Let <code>curry (f)</code> return some object (let's call it <code>CurryImpl</code> ), which obviously needs the function <code>f</code> that we passed to <code>curry</code> , and also <code>operator()</code> must be overloaded with it, and according to the condition of the problem it should take one The argument is not clear what type, and it is not clear what to return.  Naturally, <code>CurryImpl</code> template to be able to memorize any functions: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename F&gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CurryImpl { const F m_f; //  ,   curry <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: CurryImpl (F f) : m_f { f } { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; auto <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>() (const T&amp; arg) const { //   -  } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename F&gt; auto curry (F f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CurryImpl&lt;F&gt; { f }; }</code> </pre><br>  Let's now look at operator-parentheses.  So, this operator takes one argument <code>arg</code> and either calls the desired function <code>m_f</code> , if it is the last argument in the call chain, or returns another object that remembers this <code>arg</code> . <br><br>  First, let's figure out how to memorize arguments. <br><br>  Well, here everything is actually quite trivial: you just need to take them and store them in <code>CurryImpl</code> .  We do not know anything about these arguments, as well as about their types, so we‚Äôll have to add another argument to the template, and even with the variadic.  You can directly store the values ‚Äã‚Äãof the arguments, for example, in <code>std::tuple</code> .  You can tell our <code>CurryImpl</code> about these arguments directly in the constructor.  Total, the class declaration is modified something like this: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... PrevArgs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurryImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> F m_f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;PrevArgs...&gt; m_prevArgs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CurryImpl (F f, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } <span class="hljs-comment"><span class="hljs-comment">//      };</span></span></code> </pre><br>  So, well, with the storage figured out, now it remains to call the function.  Here everything becomes a little more interesting: how, in fact, determine when it is worth stopping to accumulate arguments and, in fact, call <code>m_f</code> ?  And just take and call, if possible - everything is fine! <br><br>  And one of the remarkable rules of C ++ - SFINAE, or Substitution Failure Is Not An Error will help us in this.  In short, [in this context] the point is that if the compiler, when selecting candidates for a function call among a number of overloaded functions, sees some incorrect expression in the function <i>declaration</i> , then it discards it and looks further instead of <code>error</code> in the console and compiling too early .  Actually, all these <code>std::enable_if</code> and company are based exactly on SFINAE. <br><br>  So, SFINAE.  We write a function that will call our original <code>m_f</code> only when such a call is well-formed.  This will help us a great template function <code>std::result_of</code> .  <code>std::result_of&lt;F (T1, T2, ...)&gt;</code> defines a nested <code>type</code> , equal to the type returned by object F, if it is called with arguments of type T1, T2, ... It is described in more detail, for example, <a href="http://en.cppreference.com/w/cpp/types/result_of">here</a> .  Actually, keywords by reference, for C ++ 14: <br><blockquote>  ArgTypes ... in an unevaluated context. <br></blockquote><br><br>  For C ++ 11, the wording is slightly different, but this is irrelevant. <br><br>  By the way, in C ++ 14 you can use the convenient synonym <code>std::result_of_t&lt;...&gt;</code> instead of <code>typename std::result_of&lt;...&gt;::type</code> . <br><br>  So, we write our function: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">result_of_t</span></span>&lt;F (PrevArgs..., T)&gt; invoke (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; arg) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">// PrevArgs ‚Äî  CurryImpl,    { //  -   m_f     }</span></span></code> </pre><br><br>  How it works?  If <code>m_f</code> , which is of type <code>F</code> , can be called with all previous arguments and the current one, then everything is fine, the function ‚Äúexists‚Äù, if it is impossible, the compiler does not consider it. <br><br>  If the function cannot be called, then there should be another <code>invoke</code> , which also takes one argument, remembers it and recursively returns a new object with the parent-brackets operator and all the rest.  Somehow, for example: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat (m_prevArgs, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T&gt; { arg }) }; }</code> </pre><br><br>  What did we do here?  Returned a new <code>CurryImpl</code> , which retains all previous arguments plus one new one.  At the level of types, this is reflected in the record <code>PrevArgs..., T</code> , if you want, adding <code>T</code> to the variadic-type list, and at the level of values, we simply connect two tuples, the old <code>m_prevArgs</code> and the new single-element tuple. <br><br>  Look again at our operator-parentheses.  Now it is clear that we should call one of our two <code>invoke</code> overloads in it, possibly the first one that calls the function, otherwise you can never stop saving arguments.  How to do it?  There are a lot of options here, my favorite in such cases is to use the fact that any overload is better than overloading with an ellipsis (aka ellipsis, aka C-style variadics).  That is, we add another parameter that we will not even use, for example, <code>int</code> to the first function and <code>...</code> to the second, and we get something like this: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invoke (arg, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">result_of_t</span></span>&lt;F (PrevArgs..., T)&gt; invoke (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; arg, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -   m_f     } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; }</span></span></code> </pre><br><br>  That is, if the first overload is available, it will always be selected: the <code>int</code> compiler likes a lot more than <code>...</code> <br><br>  It remains to deal with the function call from the first overload, and everything will be fine. <br><br>  What do you need to call a function whose arguments (up to <code>arg</code> ) are stored in a tuple?  We need to somehow unpack that tuple and pass the results of the unpacking to a function as usual arguments.  The problem is that at the call point we don‚Äôt know at the stage of writing the code how many arguments we have, so we can‚Äôt just pick up <code>std::get</code> our hands.  Well, it's nice, it's not good in 2014 to do work for the compiler.  If we had some way to make a variadic of numbers from 0 to N-1, we could write something like this: <br><pre> <code class="hljs lua"> //  Is    <span class="hljs-number"><span class="hljs-number">0</span></span>  (   m_prevArgs)<span class="hljs-number"><span class="hljs-number">-1</span></span> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> /*,   -,  Is   */) const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_f (std::get&lt;Is&gt; (m_prevArgs)..., <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>); }</code> </pre> <br>  Here, according to the rules for expanding variadic parameters, the expression <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <div class="spoiler"> <code><code><b class="spoiler_title"><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br>   <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</b></code></code> <div class="spoiler_text"> <pre> <code class="hljs django"><code><code><span class="xml"><span class="xml">std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</span></span></code><span class="xml"><span class="xml"> . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> , ,             C++11,   C++14   </span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="xml"></span></span></a><span class="xml"><span class="xml">  STL! ,     .   ,    </span></span><code><span class="xml"><span class="xml">std::index_sequence_for</span></span></code><span class="xml"><span class="xml"> ,      (      </span></span><code><span class="xml"><span class="xml">PrevArgs...</span></span></code><span class="xml"><span class="xml"> ),       </span></span><code><span class="xml"><span class="xml">invoke</span></span></code><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {});</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml">      </span></span><code><span class="xml"><span class="xml">std::index_sequence</span></span></code><span class="xml"><span class="xml"> ,         : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return m_f (std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> !  !    ,    ,  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">         :  </span></span><code><span class="xml"><span class="xml">m_f (arguments)</span></span></code><span class="xml"><span class="xml">   well-formed,  </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ‚Äî   - . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,    ,        ,     ,         .       ,    </span></span><code><span class="xml"><span class="xml">m_f</span></span></code><span class="xml"><span class="xml"> ,     --.    ,        : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  </span></span><code><span class="xml"><span class="xml">invokeIndexed</span></span></code><span class="xml"><span class="xml"> : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); }</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml">  ,      -  SFINAE  ,     </span></span><code><span class="xml"><span class="xml">Invoke</span></span></code><span class="xml"><span class="xml"> ,       </span></span><code><span class="xml"><span class="xml">Args...</span></span></code><span class="xml"><span class="xml">  ‚Äî       ,     .     ,         ,   ,      : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,     , , ,   :        </span></span><code><span class="xml"><span class="xml">c</span></span></code><span class="xml"><span class="xml"> ,        ,  ,     --  .  : </span></span><br><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</span></span></code><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> ,  -,  . </span></span><br><span class="xml"><span class="xml"> </span></span><br><span class="xml"><span class="xml"> </span></span><b class="spoiler_title"><span class="xml"><span class="xml"> </span></span></b><span class="xml"><span class="xml"> </span></span><code><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">type_traits</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">utility</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> class CurryImpl { const F m_f; const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> m_prevArgs; public: CurryImpl (F f, const std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&amp; prev) : m_f { f } , m_prevArgs { prev } { } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> std::result_of_t</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {}); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IF</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke { template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IArgs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> struct Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">R</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C::</span></span></span></span><span class="xml"><span class="hljs-tag">*) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Args...</span></span></span></span><span class="xml"><span class="hljs-tag">)&gt;</span></span></span><span class="xml"> { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::size_t...</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invokeIndexed (const T&amp; arg, std::index_sequence</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) const { return Invoke</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {} (m_f, std::get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Is</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> (m_prevArgs)..., arg); } template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto invoke (const T&amp; arg, ...) const { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PrevArgs...</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { m_f, std::tuple_cat (m_prevArgs, std::tuple</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { arg }) }; } }; template</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> auto curry (F f) { return CurryImpl</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag"> }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Foo::doFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (&amp;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fooRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.m_bar</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">42;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">[someFoo]</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mutable</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFoo.doFoo</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">baz</span></span></span></span><span class="xml"><span class="hljs-tag">); }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">curry</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambda</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">) (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">lambdaRes</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     </span></span></span></span><a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"></span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CurryImpl</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::function</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">erasure</span></span></span></span><span class="xml"><span class="hljs-tag">,        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> ,      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::tuple</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  ,        ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">11</span></span></span></span><span class="xml"><span class="hljs-tag">  ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">auto</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ,      </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">    ;    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">compile-time-</span></span></span></span><span class="xml"><span class="hljs-tag">  ( </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::index_sequence_for</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , </span></span></span></span><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">  </span></span></span></span></a><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> )</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> , ,      ,   ‚Äî         </span></span></span></span><code><span class="xml"><span class="hljs-tag"><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">decltype</span></span></span></span></span></span></code><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">,                 ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   ?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag">         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">   ,   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">  ,  ,     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">production-ready</span></span></span></span><span class="xml"><span class="hljs-tag">?</span></span></span></span></b><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag"> </span></span></span></span><br><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span></span></span><s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">     ,         </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span></span><span class="xml"><span class="hljs-tag">++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">14</span></span></span></span></span></span></s><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code></code> </pre> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> </div></div> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <ol><li> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> </li> <li> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> </li> </ol> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> <ol><li> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> </li> <li> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> </li> </ol> <code><code><code>std::get (m_prevArgs)...    std::get (m_prevArgs), std::get (m_prevArgs),       Is</code> . <br> <br> , ,             C++11,   C++14   <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"></a>  STL! ,     .   ,    <code>std::index_sequence_for</code> ,      (      <code>PrevArgs...</code> ),       <code>invoke</code>  <code>invokeIndexed</code> : <br> <code>return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {});</code> <br>  <code>invokeIndexed</code>      <code>std::index_sequence</code> ,         : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return m_f (std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br> <br> !  !    ,    ,  : <br> <code>struct Foo { auto doFoo (int baz, int qux) { return (m_bar + baz) / qux; } }; // ... Foo someFoo; const auto fooRes = Curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4);</code> <br>         :  <code>m_f (arguments)</code>   well-formed,  <code>m_f</code> ‚Äî   - . <br> <br> ,    ,        ,     ,         .       ,    <code>m_f</code> ,     --.    ,        : <br> <code> template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } };</code> <br>  <code>invokeIndexed</code> : <br> <code> template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); }</code> <br>  ,      -  SFINAE  ,     <code>Invoke</code> ,       <code>Args...</code>  ‚Äî       ,     .     ,         ,   ,      : <br> <code> template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } };</code> <br> ,     , , ,   :        <code>c</code> ,        ,  ,     --  .  : <br> <code>struct Foo { int m_state = 42; auto doFoo (int bar) { m_state += bar; return m_state; } }; Foo foo; curry (&amp;Foo::doFoo) (foo) (1); // foo.m_state   42 curry (&amp;Foo::doFoo) (&amp;foo) (1); // foo.m_state  43</code> <br> <br> ,  -,  . <br> <br> <b class="spoiler_title"> </b> <code>#include &lt;tuple&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;iostream&gt; #include &lt;string&gt; template&lt;typename F, typename... PrevArgs&gt; class CurryImpl { const F m_f; const std::tuple&lt;PrevArgs...&gt; m_prevArgs; public: CurryImpl (F f, const std::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } template&lt;typename T&gt; auto operator() (const T&amp; arg) const { return invoke (arg, 0); } private: template&lt;typename T&gt; std::result_of_t&lt;F (PrevArgs..., T)&gt; invoke (const T&amp; arg, int) const { return invokeIndexed (arg, std::index_sequence_for&lt;PrevArgs...&gt; {}); } template&lt;typename IF&gt; struct Invoke { template&lt;typename... IArgs&gt; auto operator() (IF fr, IArgs... args) { return fr (args...); } }; template&lt;typename R, typename C, typename... Args&gt; struct Invoke&lt;R (C::*) (Args...)&gt; { auto operator() (R (C::*ptr) (Args...), C c, Args... rest) { return (c.*ptr) (rest...); } auto operator() (R (C::*ptr) (Args...), C *c, Args... rest) { return (c-&gt;*ptr) (rest...); } }; template&lt;typename T, std::size_t... Is&gt; auto invokeIndexed (const T&amp; arg, std::index_sequence&lt;Is...&gt;) const { return Invoke&lt;F&gt; {} (m_f, std::get&lt;Is&gt; (m_prevArgs)..., arg); } template&lt;typename T&gt; auto invoke (const T&amp; arg, ...) const { return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; } }; template&lt;typename F&gt; auto curry (F f) { return CurryImpl&lt;F&gt; { f, {} }; } auto test (int t1, int t2, double t3, const std::string&amp; str) { return t1 * t2 * t3 * str.size (); } struct Foo { int m_bar; auto doFoo (int baz, int qux) { auto result = (m_bar + baz) / qux; ++m_bar; return result; } }; int main () { const auto res = curry (test) (1) (2) (3.0) ("four"); std::cout &lt;&lt; res &lt;&lt; std::endl; Foo someFoo { 42 }; const auto fooRes = curry (&amp;Foo::doFoo) (&amp;someFoo) (2) (4); std::cout &lt;&lt; fooRes &lt;&lt; " " &lt;&lt; someFoo.m_bar &lt;&lt; std::endl; someFoo.m_bar = 42; auto lambda = [someFoo] (int bar, int baz) mutable { return someFoo.doFoo (bar, baz); }; const auto lambdaRes = curry (lambda) (4) (2); std::cout &lt;&lt; lambdaRes &lt;&lt; std::endl; }</code> <br> <br>     <a href="http://melpon.org/wandbox/permlink/ThgIHjWv3KLgJSNu"></a> . <br> <br>      : <br> <br> <b>  <code>CurryImpl</code>  ,      <code>std::function</code> ?</b> <br>  <code>std::function</code>   type erasure,        . ,      . <br> <b> <code>std::tuple</code>   ?</b> <br> ,  ,        ,     . <br> <br> <b>  C++14,  C++11  ?</b> <br> ,  . C++14  ,  : <br>   <code>auto</code>    ,      <code>decltype</code>    ;    compile-time-  ( <code>std::index_sequence_for</code> , <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence">  </a> ). <br> , ,      ,   ‚Äî         <code>decltype</code> . <br> <br> <b>,                 ?</b> <br> . <br> <br> <b>   ?</b> <br>   :         -   ,   ,   .  ,  ,     . <br> <br> <b>   production-ready?</b> <br>   <s>     ,         C++14</s>   -    ,    .</code></code> </div><p>Source: <a href="https://habr.com/ru/post/238879/">https://habr.com/ru/post/238879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238865/index.html">Open lecture on the basics of Swift from MasterUp</a></li>
<li><a href="../238867/index.html">Work automation in nanoCAD using Visual Basic for Applications</a></li>
<li><a href="../238869/index.html">Happy Birthday, Nokia 3310</a></li>
<li><a href="../238875/index.html">What is the "understandable Russian language" in terms of technology. Let's look at the text readability metrics</a></li>
<li><a href="../238877/index.html">Polls on the site: How to interpret the results</a></li>
<li><a href="../238883/index.html">How to help software in the Russian Federation</a></li>
<li><a href="../238885/index.html">Windows 10 Technical Preview is available for download.</a></li>
<li><a href="../238887/index.html">Yujin: Fearless robot engineers, smart robot vacuum cleaners, empathetic robot teachers</a></li>
<li><a href="../238895/index.html">New opportunities to communicate with customers or as a Wi-Fi network with the functionality of client devices and interaction with them will help your business</a></li>
<li><a href="../238897/index.html">We test VoCore in hackspace - a micro computer with WiFi on Linux / OpenWrt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>