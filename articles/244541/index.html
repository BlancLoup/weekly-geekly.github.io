<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angle detectors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am interested in image processing, especially working with special points. Looking for information on angle detectors, I did not find a sufficiently...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angle detectors</h1><div class="post__text post__text-html js-mediator-article">  I am interested in image processing, especially working with special points.  Looking for information on angle detectors, I did not find a sufficiently large overview of these algorithms in Russian.  Therefore, I decided to correct the situation by writing this article.  The layout of the article is as follows: <br><br><ul><li>  Introduction </li><li>  Properties of special points </li><li>  Angle detectors <br><ul><li>  Moravec </li><li>  Harris </li><li>  Shi-tomasi </li><li>  Furstner </li><li>  Susan </li><li>  Trajkovic </li><li>  FAST </li><li>  CSS </li><li>  Detector based on global and local curvature properties </li><li>  CPDA </li></ul></li><li>  findings </li></ul><br><img src="https://habrastorage.org/files/223/0aa/554/2230aa5547674590b5410071da4bb24a.jpg"><br><br><a name="habracut"></a><br><h3>  Introduction </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to extract some interpreted information from an image, it is necessary to bind to local features of the image.  On the image it is possible to highlight particular points  <i>A particular point m</i> , or point feature (key point), an image is an image point whose neighborhood <i>o (m)</i> can be distinguished from the neighborhood of any other point of the image <i>o (n)</i> in some other neighborhood of the singular point <i>o <sub>2</sub> (m)</i> .  For the majority of algorithms, a rectangular window measuring 5x5 pixels is taken as the neighborhood of the image point.  The process of determining the singular points is achieved by using a detector and a descriptor. <br><br>  <i>A detector</i> is a method of extracting specific points from an image.  The detector ensures the invariance of finding the same singular points with respect to image transformations. <br><br>  <i>Descriptor</i> is an identifier of a singular point that distinguishes it from the rest of the set of singular points.  In turn, descriptors should ensure the invariance of finding a correspondence between specific points with respect to image transformations [1]. <br><br><br><h3>  Properties of special points </h3><br><br>  In 1992, Haralick and Shapir [10] identified the following requirements for particular points as the following properties: <br><ul><li>  <i>Distinctness</i> - a particular point should clearly stand out from the background and be distinguishable (unique) in its neighborhood. </li><li>  <i>Invariance</i> - the definition of a singular point must be independent of affine transformations. </li><li>  <i>Stability (stability)</i> - the definition of a particular point should be resistant to noise and errors. </li><li>  <i>Uniqueness</i> ‚Äî besides local distinctness, the singular point must have global uniqueness to improve the distinctiveness of repeating patterns. </li><li>  <i>Interpretability (interpretability)</i> - special points should be determined so that they can be used to analyze matches and identify interpretable information from an image. </li></ul><br>  Interestingly, in [5], Tuytelaars and Mikolajczyk (2006) identified the following properties that particular points should have: <br><ul><li>  <i>Repeatability (repeatability)</i> - a particular point is in the same place of the scene or image object, despite the changes in the point of view and illumination. </li><li>  <i>Distinctiveness / informativeness (distinctiveness / informativeness)</i> - the neighborhoods of singular points must be very different from each other, so that it is possible to identify and match particular points. </li><li>  <i>Locality</i> ‚Äî A particular point must occupy a small area of ‚Äã‚Äãthe image in order to reduce the probability of sensitivity to geometric and photometric distortions between two images taken at different points of view. </li><li>  <i>Quantity (quantity)</i> - the number of detected points should be large enough so that they are enough to detect even small objects.  However, the optimal number of singular points depends on the subject area.  Ideally, the number of detected points should be adaptively determined using a simple and intuitive threshold.  The density of the location of special points should reflect the information content of the image to ensure its compact representation. </li><li>  <i>Accuracy (accuracy)</i> - the detected special points must be precisely localized, both in the original image and taken on a different scale. </li><li>  <i>Efficiency (efficiency)</i> - the time of detection of specific points on the image should be valid in time-critical applications. </li></ul><br>  In general, these properties intersect with [10], but are interpreted differently. <br><br><br><h3>  Angle detectors </h3><br><br>  There are many algorithms for determining the special points, designed for different applications.  In this article, I pay attention to angle detectors (or how they are called corner detector). <br><br>  <i>Angles (corners)</i> are particular points that are formed from two or more faces, and faces usually define the boundary between different objects and / or parts of the same object.  [2] In another way, we can say that the angles are the point at which in the neighborhood the intensity varies relative to the center <i>(x, y)</i> .  Angles are determined by coordinates and changes in the brightness of the surrounding points of the image.  The main property of such points is that in the area around the corner of the image gradient two dominant directions prevail, which makes them distinguishable.  Gradient is a vector quantity that indicates the direction of the steepest increasing of the image intensity function <i>I (x, y)</i> .  Since the image is discrete, the gradient vector is determined through the partial derivatives along the <i>x</i> and <i>y</i> axes through changes in the intensities of the adjacent image points.  Most methods consider angularity depending on a derivative of the 2nd order, therefore, in general, methods are sensitive to noise. <br><br>  Depending on the number of intersected faces, there are different types of angles: L-, Y- (or T-), and X- connected [3] (some still have swept-connected angles [2]).  Different corner detectors react differently to each of these types of corners. <br><br><img src="https://habrastorage.org/files/c94/15d/2c5/c9415d2c51294b91b89be607b00f6507.jpg" alt="image"><br><br>  Approaches to the definition of singular points can be divided into 3 categories [10]: <br><ol><li>  Based on image intensity: feature points are calculated directly from image pixel intensity values. </li><li>  Using contours of the image: the methods extract contours and look for places with the maximum curvature value or make a polygonal approximation of the contours and determine the intersection.  These methods are sensitive to the vicinity of the intersections, as the extraction can often be wrong in places where 3 or more edges intersect. </li><li>  Based on the use of the model: models with intensity are used as parameters that adapt to the template images to sub-pixel accuracy.  Have limited use with special points of special types (for example, L-connected angles), depend on the patterns used. </li></ol><br>  In practice, methods based on image intensity are the most common for widespread use. <br>  Next, I will consider descriptions of the main detectors of singular points defining angles.  Then a comparative table of detectors will be presented with conclusions about their applicability to various situations and, finally, images with corner detectors applied to them. <br><br><br><h4>  Moravec </h4><br><br>  Work in the study of image binding using singular points began the Moravec detector (Moravec, 1977).  The Moravec detector is the simplest of all.  The author considers the change in the brightness of a square window <i>W</i> (usually 3x3, 5x5, 7x7 pixels) relative to the point of interest when the window <i>W is</i> shifted by 1 pixel in 8 directions (horizontal, vertical and diagonal) [4].  Algorithm: <br><br><ol><li>  For each pixel <i>(x, y)</i> in the image, calculate the change in intensity <br><img src="https://habrastorage.org/files/77c/edb/b9f/77cedbb9fc124704865a4bd69f984b9d.png"><br><img src="https://habrastorage.org/files/dab/018/c16/dab018c16dc94b6d8b3dbcade5107d3a.png"><br></li><li>  Build a map of the probability of finding the angles in each pixel <i>(x, y) of the</i> image by calculating the evaluation function <img src="https://habrastorage.org/files/2b3/161/1a1/2b31611a1f444ad4b410f901c2ea1cd3.png">  .  That is, the direction that corresponds to the smallest change in intensity is determined, since  the corner must have adjacent edges. </li><li>  Trim pixels in which <i>C (x, y)</i> values ‚Äã‚Äãare below threshold <i>T.</i> </li><li>  Remove duplicate corners by applying the local maxima of the response function (non-maximal suppression).  All obtained non-zero map elements correspond to the angles in the image. </li></ol><br>  Moravec detector has anisotropy property in 8 directions of window displacement.  The main disadvantages of the detector under consideration are the lack of rotation transformation invariance and the occurrence of detection errors in the presence of a large number of diagonal edges [2]. <br><br><br><h4>  Harris </h4><br><br>  Studies have shown that the most optimal detector of L-connected angles is the well-known Harris detector (also called the Plessey operator, the Harris and Stephens detector, Plessey operator, Harris and Stephens detector, 1988) [5] [6]. <br><br>  Harris and Stephens improved the Moravec detector by introducing anisotropy in all directions, i.e.  consider the derivatives of the brightness of the image to study changes in brightness in many directions.  They introduce derivatives in some principal directions. <br><br>  For this image <i>I,</i> consider the window <i>W</i> (usually the window size is 5x5 pixels, but may depend on the image size) in the center <i>(x, y)</i> , as well as its shift by <i>(u, v)</i> . <br><br><img src="https://habrastorage.org/files/d52/897/5ce/d528975cefa5498fb18957bba41cf0e8.png"><br><br>  Then the weighted sum of squared differences (sum of squared differences (SSD)) between the shifted and initial window (i.e., the change in the neighborhood of the point <i>(x, y)</i> when shifted by <i>(u, v)</i> ) is equal to: <br><br><img src="https://habrastorage.org/files/68b/9ce/118/68b9ce1189b34b698309a7d70414a913.png"><br>  where <i>w (x, y)</i> is a weight function (usually a Gaussian function or a binary window is used). <br><br><img src="https://habrastorage.org/files/b06/ae8/34c/b06ae834c0c34fa588961baa95fa8610.png"><br>  <i>M</i> - autocorrelation matrix: <br><br><img src="https://habrastorage.org/files/a29/58a/acb/a2958aacbe3b49feae98047cf8f9cd69.png"><br><br>  The angle is characterized by large changes in the function <i>E (x, y)</i> in all possible directions <i>(x, y)</i> , which is equivalent to the eigenvalues ‚Äã‚Äãof matrix <i>M</i> that are large in modulus.  The location of the eigenvalues ‚Äã‚Äãis shown in the following figure. <br><br><img src="https://habrastorage.org/files/487/859/f3d/487859f3d0e6455cb2b62baad30220c1.png"><br>  Since it is a laborious task to directly consider eigenvalues, Harris and Stephen proposed a measure of response [7]: <br><img src="https://habrastorage.org/files/fe8/119/9a8/fe81199a88d1413b98123860db3d37a9.png"><br>  where <i>k</i> is an empirical constant, <img src="https://habrastorage.org/files/0bb/4e2/9df/0bb4e29dfed948d6bab28aee61fc366a.png">  . <br>  Thus, the value of <i>R is</i> positive for angular singular points.  Then the points are cut off by the found threshold <i>R</i> (i.e., those points for which the value of <i>R is</i> less than a certain threshold are excluded from consideration).  Next are the local maxima of the response function (non-maximal suppression) over a neighborhood of a given radius and are selected as corner singular points. <br><br>  The Harris detector is invariant to rotations, partially invariant to affine changes in intensity.  The disadvantages include the sensitivity to noise and the dependence of the detector on the scale of the image (to eliminate this drawback, Harris's multi-scale detector is used). <br><br><br><h4>  Shi-tomasi </h4><br><br>  The Shih-Tomasi angular detector (Shi-Tomasi or Kanade-Tomasi, 1993) largely coincides with the Harris detector, but differs in the calculation of the response measure: the algorithm directly calculates the value <img src="https://habrastorage.org/files/193/961/072/193961072a124716ae6551f81288979c.png">  since the assumption is made that the search for angles will be more stable.  The authors use the same equation to analyze the optical flux of Lucas and Canada (Lucas and Kanade).  The details of the algorithm are given in [8] and [9]. <br><br><br><h4>  Furstner </h4><br><br>  F√∂rstner and G√∂lch (F√∂rstner and G√ºlch, 1987) were the first to describe a method that uses the same angularity measure as the Harris detector.  They used a more complex computational implementation [8].  Unlike the Harris detector, the eigenvalues ‚Äã‚Äãare computed explicitly.  The response function of the F√∂rstner angle is defined as follows: <br><br><img src="https://habrastorage.org/files/8f8/41d/afc/8f841dafcb5a4f0cb2fb1b697c93808f.png"><br><br>  Also for the correctness of the definition is considered a measure of the roundness of the angle, equal to: <img src="https://habrastorage.org/files/5dd/9fb/190/5dd9fb190c6b4d2c88c5c0a20e5fa41f.png">  . <br><br>  In practice, the F√∂rstner detector is often used to extend the capabilities of the Harris detector ‚Äî to find circular singular points along with the corners.  Also, the algorithm has the best localization property [2]. <br><br>  A more detailed description of the algorithm is presented in <a href="http://en.wikipedia.org/wiki/Corner_detection">Wikipedia</a> , as well as in [10], [11]. <br><br><br><h4>  Susan </h4><br><br>  The SUSAN (Smallest Univalue Segment Assimilation Nucleus) algorithm was proposed by Smith and Brady (Smith and Brady, 1997) [5]. <br><br><img src="https://habrastorage.org/files/71d/87d/d46/71d87dd464994ee58d18dae2f8293423.png"><br><br>  Angles are determined by segmentation of circular neighborhoods into similar (orange) and unlike (blue) areas.  Angles are located where the relative area of ‚Äã‚Äãsimilar areas (similar USAN) reaches a local minimum below a certain threshold. <br><br>  For each pixel, a circular area of ‚Äã‚Äãfixed radius is considered.  The center of the pixel is called the core, its intensity value is remembered.  All other pixels are divided into 2 categories: similar (orange) and unlike (blue) areas, depending on whether the intensity of the core is similar or not.  Where there is a section of the image under a circular area unchanged, similar areas occupy almost the entire area, on the edges this ratio drops to 50%, at the corners it decreases to about 25%.  Thus, the angles are located where the relative area of ‚Äã‚Äãsimilar areas (similar USAN) reaches a local minimum below a certain threshold.  To increase the stability of the algorithm, the authors assign higher weights to the pixels closest to the core.  The steps of the algorithm are as follows: <br><br><ol><li>  Place the center of the circular mask in the core. </li><li>  Inside the circular mask, calculate the number of pixels that have similar intensity with the core using the following formula (the found pixels determine the USAN): <br><img src="https://habrastorage.org/files/5e8/771/708/5e87717084824ebc8d405cc8a8067669.png"><br><img src="https://habrastorage.org/files/854/ac4/677/854ac46775254752bc7e707f1be737e4.png">  - a point inside the mask; <br><img src="https://habrastorage.org/files/8a5/3cc/800/8a53cc80019a4673b59260b279c7e657.png">  - core center; <br><img src="https://habrastorage.org/files/2c7/a55/340/2c7a55340ddb48f597fd2609c1c320a8.png">  - point intensity <img src="https://habrastorage.org/files/854/ac4/677/854ac46775254752bc7e707f1be737e4.png">  ; <br>  <i>t</i> is the difference threshold of intensities; <br><img src="https://habrastorage.org/files/688/248/90c/68824890c74f4c20bf0642a4f197dd52.png">  - the result of the comparison. <br></li><li>  Subtract the USAN size from the geometric threshold to obtain an image with angles, using the following formula: <br><img src="https://habrastorage.org/files/7bc/b60/3c4/7bcb603c4ccc4da392c7339e475d4518.png"><br><img src="https://habrastorage.org/files/672/f35/9da/672f359da0e24e4cb0a1f5b83955405d.png">  - the initial value of the edge response.  SUSAN principle: the smaller the USAN area, the greater the edge response. <br>  <i>g</i> is the geometric threshold. <br><img src="https://habrastorage.org/files/b80/138/528/b80138528a71433bb244473330e3522f.png">  - number of pixels in USAN, i.e.  USAN area. <br></li><li>  Find the centroids of the USAN areas and their proximity to each other and identify false positives. </li><li>  Select specific points by searching for local maxima of the response function (nonmaximum suppression). </li></ol><br>  The algorithm shows good accuracy for all kinds of angles, but is not susceptible to blurring on images.  Details are given in [12]. <br><br><br><h4>  Trajkovic </h4><br><br>  Tryakovits and Hedley (Miroslav Trajkovic and Mark Hedley, 1998) in the article ‚ÄúFast corner detection‚Äù introduced a new type of detector - the operator Tryakovits [8].  Initially, the authors made demands on him to become the most popular angle detector and have the minimum computational cost.  First, the 4-neighbor algorithm Trajkovic4 was developed. <br><br>  The detector checks the area around the pixel by examining nearby pixels: let <i>c</i> be the pixel to be considered, and <i>P</i> be the point on the circle <i>S <sub>N</sub></i> at the center at the point <i>N.</i>  Point <i>P '</i> is the point opposite to <i>P</i> in diameter. <br><br>  Response functions (authors call it CRN, Corner Request Function) are defined as: <br><br><img src="https://habrastorage.org/files/c5c/495/392/c5c49539271044e6bd23be5e0c439b57.png"><br><br>  where <i>N</i> is the center point; <br>  <i>P</i> and <i>P '</i> are two points opposite in diameter around point <i>N</i> ; <br>  <i>S <sub>N</sub></i> - sampled circle on an image with a radius of 3, 5, 7 pixels. <br><br><img src="https://habrastorage.org/files/46b/ca8/b18/46bca8b18cff4f7c82c1ea056bf4cdb0.png"><br><br>  The CRN value will be large when there is no direction in which the central pixel resembles two nearby pixels in diameter.  Since the calculation in any direction gives an upper limit of min, the horizontal and vertical directions are checked first to determine whether it makes sense to move on to the full calculation of <i>R <sub>N.</sub></i> <br><br>  In comparison with the Harris detector, the frequency of repeatability of the Trajkovic4 algorithm is worse, but localization is comparable with the definition of L-connected angles and is superior to other types of angles. <br><br>  Also, the disadvantages include the fact that this 4-neighbor operator falsely reacts to diagonal edges and is sensitive to noise [2].  Therefore, use the 8-connected version of this algorithm Trajkovic8.  Trajkovic8 differs from Trajkovic4 in the way it calculates angularity.  However, Trajkovic8 still finds false angles on some diagonal edges of the object (it does not show itself well on artificial images).  Detailed descriptions of the algorithms are given in [2] and [8]. <br><br><br><h4>  FAST </h4><br><br>  Rosten and Drummond (Edward Rosten and Tom Drummond, 2005) introduced a rather successful FAST algorithm (Features from Accelerated Segment Test) - features of the accelerated segment tests. <br><br>  The algorithm considers a circle of 16 pixels (drawn by the Bresenham algorithm) around candidate point <i>P.</i>  A point is angular if for the current considered point <i>P</i> there are <i>N</i> adjacent pixels on a circle whose intensities are greater than <i>I <sub>P</sub> + t</i> or the intensities of all are less than <i>I <sub>P</sub> -t</i> , where <i>I <sub>P</sub></i> is the intensity of point <i>P</i> , <i>t</i> is a threshold value.  Next, you need to compare the intensity at the vertical and horizontal points on the circle numbered 1, 5, 9 and 13 with the intensity at point <i>P</i> (in order to cut off the false candidates as quickly as possible).  If the condition <i>I <sub>Pi</sub> &gt; I <sub>P</sub> + t</i> or <i>I <sub>Pi</sub> &lt;I <sub>P</sub> + t, i = 1, .., 4</i> , is fulfilled for 3 of these points, then a complete test is performed for all 16 points [13].  Experiments have shown that the smallest value of <i>N</i> , at which singular points begin to be detected steadily, is <i>N = 9</i> . <br><br><img src="https://habrastorage.org/files/9bf/224/2c5/9bf2242c54704d3a8638dce396316b40.png"><br>  Initially, the original algorithm was <a href="http://www.edwardrosten.com/work/fast.html">FAST-12</a> .  There are modifications of the algorithm: tree-like FAST-9 and FAST-12 (the tree based FAST-9 and FAST-12). <br><br>  The original algorithm has several drawbacks, for example, several particular points can be found near a certain neighborhood, the efficiency of the algorithm depends on the order of image processing and the distribution of pixels. <br><br>  In [14], the authors Edward Rosten, Reid Porter, and Tom Drummond (2008) introduce improvements to the FAST algorithm, namely, that they use machine learning to determine specific points. <br><br>  This algorithm they called FAST-ER (ER - Enhanced Repeatability, improved repeatability).  The algorithm is stable to the property of repeatability: on the same scene, viewed from different angles, there are special points belonging to the same objects. <br><br>  This algorithm uses a ring of a circle of more than 1 pixel, rather than in FAST (48 pixels).  The authors use the ID3 algorithm to classify special points (whether the candidate point is special) using decision trees.  The ID3 algorithm optimizes the order in which pixels are processed, resulting in the most computationally efficient detector. <br><br><img src="https://habrastorage.org/files/e65/b47/481/e65b474814794eacb41220c563be2feb.png"><br><br>  The cost function of the decision tree is calculated as follows: <br><br><img src="https://habrastorage.org/files/c34/8d4/e1f/c348d4e1f40e426ab58d86c205421450.png"><br><br>  <i>R</i> is a measure of repeatability; <br>  <i>N</i> is the number of detected singular points; <br>  <i>S</i> is the number of nodes in the decision tree. <br><br>  Details are described in [14]. <br><br>  FAST-ER is better than FAST, but slower in execution speed.  The authors concluded that the FAST-ER detector is the best in relation to the repeatability property. <br><br><br><h4>  CSS </h4><br><br>  Rattarangsi and Chin (1992) [15] proposed an algorithm based on curvature scale space (CSS) that detects angles on flat curves.  CSS is suitable for extracting invariant geometric features on a flat curve at various scales. <br><br>  The algorithm determines singular points using several scales of the same image.  However, it is computationally complex and detects false angles in circular areas.  [sixteen] <br><br>  Farzin Mokhtarian and Riku Suomela (1998) [17] improved the algorithm in noise resistance.  This algorithm applies to a black and white image and includes the following steps: <br><br><ol><li>  Apply the Canny Boundary Detector (Canny) to the image and get a binary boundary map. </li><li>  Select border outlines from a binary map.  Check the ends of the contours for adjacency with others, if this is the case, then re-fill the boundary before connecting.  Mark this point as a T-connected angle if the end of the contour is connected to the border. </li><li>  Calculate the curvature values ‚Äã‚Äãof each contour on the largest <i>œÉ <sub>high</sub></i> scale.  The initial values ‚Äã‚Äãare the local maximums of curvature, provided that the value of the curvature is higher than the threshold <i>t</i> and twice as large as the neighboring local minima. </li><li>  Sort angles in descending order from the largest to the smallest scale in order to improve the localization property. </li><li>  Compare T-connected corners with the other corners and, if they are close to each other, remove one of the corners. </li></ol><br>  The image shows 2 cases of face spacing: the T-connected gap is marked as an angle (T-corner point), and the gap between the ends of the contours (gap) is filled. <br><br><img src="https://habrastorage.org/files/37f/582/ff8/37f582ff8b654d5dbc5f732fc028727b.png" width="437" height="250"><br><br>  This algorithm has the following disadvantages: the image at only one scale is used to determine the number of angles (step 3), and the images at several scales for localization.  As a result, the algorithm skips angles when <i>œÉ is</i> large, and detects false ones, when <i>œÉ is</i> small.  [sixteen] <br><br>  A number of improvements were made to the algorithm: in 2001 F. Mokhtarian and R. Suomela in the article ‚ÄúRobust image corner detection through curvature scale space‚Äù (suggested improved CSS) and in 2008 - He and Yung in the article ‚ÄúCorner detector on global and local curvature properties ‚Äù, as well as the CPDA detector. <br><br><br><h4>  Detector based on global and local curvature properties </h4><br><br>  He and Yung (2008) in the article ‚ÄúCorner detector based on global and local curvature properties‚Äù offer an improvement to the CSS algorithm.  They claim that traditional computational algorithms consider local properties of the image, often falsely determining the noise at specific points or missing small details of an object.  This algorithm balances the global and local properties of the curvature level of the faces to extract the corners. <br><br>  As a result, He and Yung offer the following solution: <br><br><ol><li>  Detect boundaries, for example, with a Canny Canny detector to get a binary boundary map. </li><li>  Select contours as in the CSS algorithm. </li><li>  Calculate the curvature values ‚Äã‚Äãfor a fixed small scale (so as not to miss the true angles), consider the local maxima of the absolute values ‚Äã‚Äãof curvature, which are noted as potential corner candidates. </li><li>  Calculate the threshold, based on the average value of the curvature in the considered area.  Remove circular angles by comparing the curvature values ‚Äã‚Äãof the corner candidates with an adaptive threshold. </li><li>  Calculate the angle values ‚Äã‚Äãof the remaining corner candidates using the adaptive considered area and remove the false candidates. </li><li>  Consider the ends of open contours and mark them as corners if they are not close to each other. </li></ol><br>  Thus, the image shows an example of determining the circular angle (round corner) (a) and the obtuse angle (obtuse corner) (b), which is not yet circular.  For their determination, the curvature values ‚Äã‚Äãare calculated, the graphs of which are shown in Figures (c) and (d). <br><br><img src="https://habrastorage.org/files/061/e23/4d4/061e234d433d47c78243906d6b2706a9.png"><br>  The details of the algorithm are explained in [16]. <br><br><br><h4>  CPDA </h4><br><br>  Awrangjeb and Lu introduced a new CPDA detector (Chord-to-Point Distance Accumulation, 2008) [18]. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, a Gaussian with a large </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">œÉ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reduces noise, but affects localization, on the other, a Gaussian with a small </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">œÉ is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sensitive to noise. </font><font style="vertical-align: inherit;">To solve these problems, Awrangjeb and Lu proposed a chord-to-point distance accumulation (CPDA) method using an adaptive threshold based on the ideas of Han and Poston. </font><font style="vertical-align: inherit;">The CPDA method uses a discrete curvature estimate that is resistant to local variations. </font><font style="vertical-align: inherit;">The authors use 3 chords of various lengths to estimate 3 normalized discrete values ‚Äã‚Äãof curvature at each point of the smoothed curve. </font><font style="vertical-align: inherit;">[19] </font></font><br><br><img src="https://habrastorage.org/files/d92/b0a/ed9/d92b0aed930c4dfa8ce442d142686d45.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the detector uses a larger neighborhood, it is less sensitive to noise and local variations on the curve. </font><font style="vertical-align: inherit;">The CPDA detector is a further development of the CSS detector.</font></font> Steps: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Find borders on the image using the Canny Boundary Detector. </font></font></li><li>      . <br><ol><li>       ,   ,     . </li><li>  T-      T- . </li><li>        . </li></ol></li><li>  ,     ,       . </li><li>       3  ,  3   . </li><li>  3            . </li><li>             ¬´¬ª    . </li><li>               . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Find the angles between the ends of the smoothed loops (if any) and the detected angles, if they are sufficiently distant from them. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each of the T-connected corners found add to the detected corners if it is sufficiently removed from them. </font><font style="vertical-align: inherit;">[18]</font></font></li></ol><br><br><h3>  findings </h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You may notice that modern algorithms have become more complex. </font><font style="vertical-align: inherit;">However, Harris and FAST detectors are the most frequently used and computationally fast algorithms for determining angles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article does not consider such detectors as Harris-Laplace, Hessian-Laplace, DoG, LoG, Harris-Affine, Hessian-Affine, Salient Regions, because although they allow you to determine angles, they should be more attributed to blobs detectors (drops blob)</font></font> [five] <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, this article does not exhaust the entire set of angle determination algorithms, due to their large number and specificity of application to subject areas. </font><font style="vertical-align: inherit;">Some of the algorithms are more of theoretical interest than practical. </font><font style="vertical-align: inherit;">The article describes the main algorithms for determining the angles that are most often found in the literature. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, there are also the following algorithms (with articles):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotary invariant operator DET (probably one of the first detectors). </font><font style="vertical-align: inherit;">PR Beaudet. </font><font style="vertical-align: inherit;">Rotationally invariant image operators. </font><font style="vertical-align: inherit;">In Proc. </font><font style="vertical-align: inherit;">IAPR1978, pages 579‚Äì583, 1978.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kitchen-Rosenfeld detector. </font><font style="vertical-align: inherit;">L. Kitchen and A. Rosenfeld. </font><font style="vertical-align: inherit;">Gray Level Corner Detection. </font><font style="vertical-align: inherit;">Pattern Recognition Letters, pp. </font><font style="vertical-align: inherit;">95-102, 1982.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detector Wang-Brady. </font><font style="vertical-align: inherit;">H. Wang and M. Brady. </font><font style="vertical-align: inherit;">Real-time corner detection algorithm for motion estimation. </font><font style="vertical-align: inherit;">Image and Vision Computing, vol. </font><font style="vertical-align: inherit;">13: 9, pp. </font><font style="vertical-align: inherit;">695-703, 1995.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCD detector (Structure-based corner detector). </font><font style="vertical-align: inherit;">Fei Shen, Han Wang. </font><font style="vertical-align: inherit;">Real Time Gray Level Corner Detector. </font><font style="vertical-align: inherit;">2000</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COP detector (Crosses as Oriented Pair). </font><font style="vertical-align: inherit;">SC Bae, IS Kweon and CD Yoo. </font><font style="vertical-align: inherit;">COP: a new corner detector. </font><font style="vertical-align: inherit;">Pattern Recogn.</font></font> Lett.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2002 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improved detector based on Harris-Stephen and Shi-Tomasi detectors. </font><font style="vertical-align: inherit;">Lidia Forlenza, Patrick Carton, Domenico Accardo, Giancarmine Fasano and Antonio Moccia. </font><font style="vertical-align: inherit;">Real Time Corner Detection for Miniaturized Electro-Optical Sensors Onboard Small Unmanned Aerial Systems. </font><font style="vertical-align: inherit;">2012</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zhang Detector. </font><font style="vertical-align: inherit;">Jun Zhang, Tingjin Luo, Gui Gao, and Lin Lian. </font><font style="vertical-align: inherit;">Junction Point Detection Algorithm for SAR Image, 2013.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is worth noting that this is not the whole list. </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text"> ,               . ,      ,     . , ,    ( )  2  . <br><img src="https://habrastorage.org/files/caa/4f0/c08/caa4f0c085be4259a7a27243c29f06fb.png" width="255" height="255"> [16] <img src="https://habrastorage.org/files/747/c24/b35/747c24b35dab4af28019c1cddd348a07.png">  [2] <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a comparative table of angle detectors taken from [2]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison of angle detectors (1 - Very bad, 2 - bad, 3 - satisfactory, 4 - good, 5 - excellent).</font></font><br><br><table border="1"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator (algorithm) </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Detection efficiency </font></font></th><th>  Localization </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frequency of occurrence </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Noise resistance </font></font></th><th>  Speed </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaudet </font></font></td><td>  3 </td><td>  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 for affine transformations, 2 for scaling </font></font></td><td>  2 </td><td>  four </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moravec </font></font></td><td>  3 </td><td>  four </td><td>  3 </td><td>  3 </td><td>  four </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kitchen &amp; Rosenfeld </font></font></td><td>  3 </td><td>  3 </td><td>  3 </td><td>  3 </td><td>  3 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Furstner </font></font></td><td>  four </td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 for affine transformations, 3 for scaling </font></font></td><td>  four </td><td>  2 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plessey </font></font></td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 for L-connected angles, 2 for other types </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 for affine transformations if an anisotropic gradient is calculated, 3 for scaling </font></font></td><td>  3 </td><td>  2 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deriche </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 (?) </font></font></td><td>  four </td><td>  four </td><td>  2 </td><td>  four </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wang &amp; brady </font></font><br></td><td>  four </td><td>  four </td><td>  four </td><td>  3 </td><td>  four </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Susan </font></font></td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 for blurry images, 4+ otherwise </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 for scaling, 2 for affine transformations </font></font></td><td>  five </td><td>  four </td></tr><tr><td>  CSS </td><td>  four </td><td>  four </td><td>  five </td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depends strongly on the border detector used </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trajkovic &amp; Hedley (4-neighbors) </font></font></td><td>  2 </td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 (not invariant to rotations) </font></font></td><td>  2 </td><td>  five </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trajkovic &amp; Hedley (8-neighbors) </font></font></td><td>  3 </td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3+ (not invariant to turns) </font></font></td><td>  four </td><td>  five </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zheng &amp; wang </font></font></td><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 for L-connected angles, 3 for other types </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 for affine transformations, 3 for scaling </font></font></td><td>  3 </td><td>  3 </td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The behavior of corner detectors on the artificial test pattern of Smith. </font></font><br><br><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator (algorithm) </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Work result </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moravec [2] </font></font></td><td><img src="https://habrastorage.org/files/1df/977/6b1/1df9776b1ba143fd999255f920eb4b9e.png"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plessey </font></font></td><td><img src="https://habrastorage.org/files/6a5/ef3/6a2/6a5ef36a24fb4382a898bcdb9b4ea9d3.png"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Susan </font></font></td><td><img src="https://habrastorage.org/files/a76/b88/950/a76b88950f90429b824f7d810c64007f.png"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√∂rstner [10] </font></font></td><td><img src="https://habrastorage.org/files/0a6/0c2/ccf/0a60c2ccff424146a51d252482bbb815.png"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trajkovic4 </font></font></td><td><img src="https://habrastorage.org/files/0f3/9f7/484/0f39f7484cc945afb93c2cfdac6aedb1.png"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trajkovic8 </font></font></td><td><img src="https://habrastorage.org/files/047/783/8dc/0477838dc05549749529f34c1f631f6b.png"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shi-Tomasi [20] </font></font></td><td><img src="https://habrastorage.org/files/b57/e21/46c/b57e2146cdc84fb38c88331bf7469d52.png"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The behavior of corner detectors on the test image of the house (House Test Image). </font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator (algorithm) </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Work result </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moravec </font></font></td><td><img src="https://habrastorage.org/files/3f2/97f/568/3f297f5686104e2da49a98249909f691.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plessey </font></font></td><td><img src="https://habrastorage.org/files/6a7/ff8/e6e/6a7ff8e6e10446daa211832e4ec71026.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SUSAN [16] </font></font></td><td><img src="https://habrastorage.org/files/9eb/fbc/b15/9ebfbcb153ef46d78464dc7f59cc8943.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Furstner </font></font></td><td><img src="https://habrastorage.org/files/970/c91/1d6/970c911d62a94010b308aec46a08f6e7.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FAST [21] </font></font></td><td><img src="https://habrastorage.org/files/7e2/e6f/299/7e2e6f29917b49ddb2885657bc078eff.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Original CSS [16] </font></font></td><td><img src="https://habrastorage.org/files/b07/88f/f10/b0788ff106d44f40b6f7ca7b8582d863.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enhanced CSS [16] </font></font></td><td><img src="https://habrastorage.org/files/61b/be1/a78/61bbe1a788764c4c86487798a849089e.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corner detector based </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on global and local </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properties 2008 [16]</font></font></td><td><img src="https://habrastorage.org/files/658/29f/b86/65829fb86fc44b5da82c49a68a0d6902.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kitchen-Rosenfeld [22] </font></font></td><td><img src="https://habrastorage.org/files/d20/b46/706/d20b467068db43449ef6cdc6bd76cf44.png" width="251"></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> COP [22] </font></font></td><td><img src="https://habrastorage.org/files/268/13c/71a/26813c71a81541b69e8b1d13de2067d6.png" width="251"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: I tried to review the main angle detectors. I hope that I did it. If the article has inaccuracies, please send messages to the PM. And, maybe, some algorithms are written too generalized, but if I wrote all the details, then the article would have grown to even larger sizes, if I had lost the thread of the story.</font></font><br><br><br><h3>  Bibliography </h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="http://cgm.computergraphics.ru/content/view/54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konushin A. Point feature tracking. Computer graphics and multimedia. Issue number 1 (5) / 2003</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Abhishak Yadav, Poonam Yadav. Digital Image Processing, 2009. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] </font></font><a href="https://hal.archives-ouvertes.fr/hal-00631609/document"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accurate Junction Detection and Characterization in Natural</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="http://www.racurs.ru/wiki/index.php/%25D0%259E%25D0%25B1%25D0%25B7%25D0%25BE%25D1%2580_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2_%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25B0%25D1%2580%25D1%2583%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D1%2585%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D1%2582%25D0%25B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An overview of characteristic point detection methods</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] Tinne Tuytelaars, Krystian Mikolajczyk. Local Invariant Feature Detectors: A Survey, 2008. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6] </font></font><a href="http://www2.it.lut.fi/kurssit/07-08/CT20A6100/seminars/2009-2010/Harris.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harris Corner Detector</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] </font></font><a href="http://www.cs.toronto.edu/~jepson/csc420/notes/imageFeaturesIIBinder.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.cs.toronto.edu/~jepson/csc420/notes/imageFeaturesIIBinder.pdf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[8] MH Miroslav Trajkovii. Fast corner detection, 1998.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[9] T. Shi. Good Features to Track, 1994. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] V. Rodehorst, A. Koschan. Comparison and evaluation of feature point detectors, 2006. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[11] </font></font><a href="https://cseweb.ucsd.edu/classes/sp04/cse252b/notes/lec13/lec13.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture 13. Interest Point Detection, 2004</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] B. Smith. SUSAN - A new approach to low level, 1997. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] ER a. T. Drummond. Fusing Points and Lines for High Performance Tracking, 2005. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14] RP a. TD Edward Rosten. Faster and better: a machine learning approach to corner detection, 2008. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15] A. Rattarangsi, WUMWU Dept. of Electr. &amp; Comput. Eng. and Analysis, Machine Analysis, IEEE Transactions on (Volume: 14, Issue: 4), 1992. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16]</font></font><a href="http://hdl.handle.net/10722/57246"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X. Chen He, N. Yung. </font><font style="vertical-align: inherit;">Corner detector based on global and local curvature, 2008</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17] RS Farzin Mokhtarian. </font><font style="vertical-align: inherit;">Robust Image Corner Detection Through Curvature Scale Space, 1998. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] </font></font><a href="http://www.mathworks.com/matlabcentral/fileexchange/22390-robust-image-corner-detection-based-on-the-chord-to-point-distance-accumulation-technique"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M. Awrangjeb. </font><font style="vertical-align: inherit;">CPDA, 2009</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[19] SMM Kahaki, 2014 Contour-Based Corner Detection and Classification. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[20] </font></font><a href="https://www.cs.auckland.ac.nz/courses/compsci773s1c/lectures/COMPSCI%2520773%2520feature%2520point%2520detection.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPSCI 773 feature point detection</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[21] Andres Solis Montero, Milos Stojmenoviƒá, Amiya Nayak. </font><font style="vertical-align: inherit;">Robust Detection of Corners and Corner-line links in images. </font><font style="vertical-align: inherit;">10th IEEE International Conference on Computer and Information Technology (CIT 2010), 2010. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[22] SC Bae, IS Kweon and CD Yoo. </font><font style="vertical-align: inherit;">COP: a new corner detector. </font><font style="vertical-align: inherit;">Pattern Recogn. </font><font style="vertical-align: inherit;">Lett., 2002.</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/244541/">https://habr.com/ru/post/244541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244529/index.html">The introduction of the software product. Features of the business consultant. Part III. Final</a></li>
<li><a href="../244531/index.html">Should Spring Boot be used in your next project?</a></li>
<li><a href="../244535/index.html">World Information Security Day</a></li>
<li><a href="../244537/index.html">Rust: abstraction and security, completely free (video from the Saratov Open-IT session)</a></li>
<li><a href="../244539/index.html">Adaptive learning, or a few words about Knewton</a></li>
<li><a href="../244545/index.html">Expressive javascript: drawing on canvas</a></li>
<li><a href="../244551/index.html">The digest of interesting materials for the mobile developer # 81 (November 24-30)</a></li>
<li><a href="../244553/index.html">How we select2 in helper wrapped</a></li>
<li><a href="../244557/index.html">A tale about how tech support Veeam introduced gamification</a></li>
<li><a href="../244559/index.html">Brief history of hacking. A story from the head of information security at Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>