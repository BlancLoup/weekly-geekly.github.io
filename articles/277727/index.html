<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another implementation of the is_function <T> metafunction for C ++ 98/03</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a small report on how I decided to write the is_function metafunction for C ++ 98/03 so that it would not be necessary to create a lot of spec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another implementation of the is_function <T> metafunction for C ++ 98/03</h1><div class="post__text post__text-html js-mediator-article">  This is a small report on how I decided to write the is_function metafunction for C ++ 98/03 so that it would not be necessary to create a lot of specializations for a different number of arguments. <br>  Why, you ask, in 2016 in general to do this kind of thing?  I will answer.  This is a challenge.  Among other things, this, at first purely theoretical work from the category of "possible or not," revealed some of the problems in modern compilers.  All who are not alien to such a mood, I invite you to look. <br><a name="habracut"></a><br>  <a href="https://habr.com/ru/post/277727/">Staging</a> <br>  <a href="https://habr.com/ru/post/277727/">Some theory</a> <br>  <a href="https://habr.com/ru/post/277727/">Implementation number 0</a> <br>  <a href="https://habr.com/ru/post/277727/">Implementation number 1</a> <br>  <a href="https://habr.com/ru/post/277727/">Implementation number 2</a> <br>  <a href="https://habr.com/ru/post/277727/">Instead of conclusion</a> <br><br><a name="intro"></a><h2>  <font color="#464646">Staging</font> </h2><br>  The <code>is_function&lt;T&gt;</code> returns <code>true</code> if type <code>T</code> is of type ‚Äúfunction‚Äù, and <code>false</code> if not.  So, we need to write a meta-function without using multiple specializations for a different number of argument types for the function type being examined.  You can look at an example implementation with specializations in <a href="">boost</a> .  At the moment there are 25 maximum arguments and it all takes up quite a lot of space. <br>  Why make specialization?  In C ++ 11, a wonderful tool appeared - <i>variadic templates</i> .  It appeared because it was overdue, one might say, sore.  This tool allows you to process such sequences of template arguments. <br><pre> <code class="cpp hljs"> some_template&lt;A1, A2, A3 <span class="hljs-comment"><span class="hljs-comment">/*, etc. */</span></span>&gt;</code> </pre>  as a single ‚Äúpackage‚Äù of parameters, parameter pack.  Parameter pack helps to make generalized specializations, overloads and substitutions in cases where the number of arguments is unknown.  It is through this tool in C ++ 11 that is_function is implemented.  In C ++ 98/03 there was no such tool.  This means that, in general, if we needed to provide a different number of arguments depending on the situation, we had to make overloads and specialization ‚Äúfor all occasions‚Äù.  If you look at the implementations of such libraries as <i>variant</i> or <i>mpl</i> in boost, then make sure that such code is abundant (sometimes it is generated by the preprocessor).  If we needed to determine whether type <code>T</code> function of <code>R(A1, A2)</code> , then the simplest and most obvious solution was to create an appropriate specialization: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* .... */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A2&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class">&lt;R(A1, A2)&gt; {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* .... */</span></span> };</code> </pre>  Often, it was simply impossible to do otherwise.  I don‚Äôt want you to think that I‚Äôm dissatisfied with the implementation in boost - their solution is the most portable, therefore, the most correct, especially in the context of such a library.  But I was interested in the task to do without it. <br>  In general, I am one of those unlucky (although this is how to look) on duty to still work with C ++ 03.  Therefore, my concern about compatibility with the old code should not surprise you.  Someone can say: ‚Äúyes this old stuff was given to you, it's 2016 in the yard!‚Äù.  One can agree with this, but, apart from the purely subjective feeling of competition, it turned out to derive some benefit from this.  And the spirit of C ++ 03, for the reasons outlined above, still has not had time to erode.  Therefore, just for fun. <br>  Before we move on to the description, I want to warn you that the reader will need an understanding of what <a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE is</a> and the basic principles of writing compile-time checks, and I will not translate the wording from the standard exactly.  I assume that the interested reader, if desired, is able to cope with this independently. <br><br><a name="theory"></a><h2>  <font color="#464646">Some theory</font> </h2><br>  If the classical approach with specializations does not suit us, then how to be?  Let's try to think a little differently.  What are the properties of a function type that others no longer have?  Referring to the standard (C ++ 03): <br><a name="4_3_1"></a>  <b>4.3 / 1</b> <br><blockquote>  An example of the <i>type of</i> a pointer to a pointer to a function. </blockquote>  So, a function can be implicitly converted to a function pointer.  Arrays have the same property: the array is implicitly converted to a pointer.  Let's see what else there is: <br><a name="8_3_5_3"></a>  <b>8.3.5 / 3</b> <br><blockquote>  <i>If you have an</i> ‚Äúarray of T‚Äù or <i>‚Äúfunction returning‚Äù, you‚Äôre adjusted for to</i> </blockquote>  This means that the ‚Äúfunction‚Äù type, when specified as a parameter of another function, implicitly acquires the properties of a pointer.  Based on this, in paragraph <b>13.1</b> , it is described that such a declaration <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ())</span></span></span></span>;</code> </pre>  corresponds to this (i.e., it is the same): <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*)())</span></span></span></span>;</code> </pre>  This is what we can already use.  We can write a check based on this and define a function in front of us or not.  But everything is not as simple as it seems, but more on that later.  In the meantime, let's see what else you can use, based on the type of "function": <br><a name="8_3_4_1"></a>  <b>8.3.4 / 1</b> <br><blockquote>  In the declaration TD where D has the form <br>  D1 [constant-expression <sub>opt</sub> ] <br>  D1 is the derived-declarator-type-list-T, ‚Äùthen it is the type of identifier of the identifier of the type.  T is called the array element type;  <i>This is a void, a function type or an abstract class.</i> </blockquote>  Yeah, that's interesting too.  Those.  we can not get an array of elements of type "function".  Along with this, we cannot get an array of references, a <code>void</code> array, and an array with elements of the abstract class type.  If we write a check that cuts out the remaining options, then we will be able to accurately determine the function in front of us or not. <br>  <i>We summarize.</i>  <i>We have two distinctive features of the functions.</i>  <i>Type "function"</i> <i><br></i> <ul><li>  <i>"Mutates" into a pointer if used as the argument type of another function.</i> </li><li>  <i>does not allow to create arrays with elements of your type</i> </li></ul>  <i>We will use these properties in the implementation of our plans.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="impl_0"></a><h2>  <font color="#464646">Implementation number 0, preliminary</font> </h2><br>  I want to start with the first feature of the ‚Äúfunction‚Äù type, which we outlined in the previous section.  It's about <a href="https://habr.com/ru/post/277727/">8.3.5 / 3</a> . <br>  It can be summarized as follows: the type <code>F</code> being checked is a function if equality holds <br>  <code>void( F ) == void( F * )</code> . <br>  It all sounds pretty simple.  And my first implementation was also pretty simple.  Simple but incorrect.  For this reason, I will not give it in full, but I want to tell separately about one property that I used in it.  Consider this code. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(* declfunc() )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( F )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(* gen( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (F *) ) )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( F )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(* gen( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (F ) ) )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( F * )</span></span></span></span>;</code> </pre>  Looking ahead, I will say that this code comes from erroneous assumptions.  But Clang compilers (up to version 3.4 inclusive), GCC compilers (up to version 4.9), compilers from VS (cl 19.x, maybe earlier ones) compiled it as I expected.  I'll tell you how it works and how I planned to use it.  First, let's write the function declaration that will help us with the checks: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; check_is_function( X ) )</span></span></span><span class="hljs-function"> [ is_same&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( F )</span></span></span><span class="hljs-function">, X&gt;::value + 1 ]</span></span>;</code> </pre>  If the type passed to check_is_function coincides with <code>void(*)( F )</code> , then the function returns a reference to an array of two <code>char</code> , if it does not match - from one <code>char</code> (the type of the return value we can then analyze using <code>sizeof</code> ).  Everywhere here we assume that <code>F</code> is a type that we examine for belonging to the type ‚Äúfunction‚Äù.  Now, if you put this into a simple template, <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; check_is_function( X ) )</span></span></span><span class="hljs-function"> [ is_same&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( F )</span></span></span><span class="hljs-function">, X&gt;::value + 1 ]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( check_is_function( gen( declfunc&lt;F&gt;() ) ) ) - <span class="hljs-number"><span class="hljs-number">1</span></span> }; };</code> </pre>  we can make sure that the compilers mentioned above to express the form <br><pre> <code class="cpp hljs"> is_function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>()&gt;::value; is_function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fcv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; is_function&lt;fcv&gt;::value;</code> </pre>  we will get the results of 1, 0 and 1, respectively (the full code can be found <a href="">here</a> , and run <a href="http://melpon.org/wandbox/permlink/fJkjJ4um9XWxFZFz">here</a> ).  Yes, this is not a fully working solution, here we do not distinguish function pointers from functions, there is a problem with references, <code>void</code> , etc.  But it all just costs and emphasize, I would not like that.  If we run the same example on the newer compilers (GCC&gt; = 4.9, Clang&gt; = 3.5, cl 19.x), then we will make sure that the output has changed.  Now we get the results 1, 0, 0, respectively.  This happens because the type of the function with <i>cv-qualifier-seq</i> (this is the same <code>const</code> or <code>volatile</code> at the end), which is substituted into the type of another function (acquiring the properties of a pointer), has ceased to be a valid argument substitution in the variant: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(* gen( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (F *) ) )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( F )</span></span></span></span>;</code> </pre>  Why?  Because with the introduction of a new standard in which it is clearly written (the last draft), <br><a name="8_3_1_4"></a>  <b>8.3.1 / 4</b> <br><blockquote>  Forming a function type cv-qualifiers or a ref-qualifier; </blockquote>  the compiler's approach to this code has changed.  Adding an asterisk to this type is a wrong substitution, so the code stopped working.  In C ++ 03 there was no equally clear rule (you can read about the changes <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html">here</a> ).  Which, of course, does not mean that it should have been allowed there.  However, the nebula of standard language left the opportunity to skip this point, which is written on the following link: <br><blockquote>  It is not clear that it has been established during the submission. </blockquote>  Therefore, many modern compilers still do not take this into account (for example, cl 18.x or icc 13.x and 14.x).  The attentive reader probably already wondered that if the explicit addition of an asterisk to the type of ‚Äúfunction with <i>cv-qualifier-seq</i> ‚Äù is not allowed, then an implicit one, if you specify this type as a parameter, should not be available either.  Yes, it probably is.  <i>However, at the moment, there is not a single compiler that explicitly prohibits this.</i> <br>  In the standard C ++ 03 there is this: <br><a name="8_3_5_4"></a>  <b>8.3.5 / 4</b> <br><blockquote>  It is a function of a function of determination of a function. </blockquote>  This tells us about a rather narrow context of using function types with <i>cv-qualifier-seq</i> .  And our case does not seem to fit there. <br>  <i>Therefore, we‚Äôll keep in mind that the code built on the basis of the ‚Äúmutation‚Äù of the function type in the pointer will not work for all cases, but since at the moment it is still working, I will show the complete solution.</i>  <i>I think this will serve as food for thought about the imperfection of the world.</i> <br><br><a name="impl_1"></a><h2>  <font color="#464646">Implementation number 1, working</font> </h2><br>  This implementation has been refined to meet the limitations described in the previous section.  Most likely (I'm not 100% sure, but this indicates a lot) this implementation does not fully comply with the standard, and the fact that it still works should be the reason for sending bug reports in support of at least three modern compilers. <br>  The main problem with the previous implementation is that in the case of a function with <i>cv-qualifier-seq, the</i> substitution with the pointer stopped working.  Fortunately, in this problem the key to its solution is hidden.  We can write an SFINAE check that determines whether it is possible to substitute a pointer to the type passed in.  This way we cut off options when this is not possible.  The check looks like this: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">may_add_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; may_add_ptr_check(P *) )</span></span></span><span class="hljs-function">[2]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; may_add_ptr_check(...) )</span></span></span><span class="hljs-function">[1]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( may_add_ptr_check&lt;F&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>) ) - <span class="hljs-number"><span class="hljs-number">1</span></span> }; };</code> </pre>  If the <code>P*</code> substitution is incorrect, then an overload with an ellipsis is selected.  Depending on the selected <code>sizeof</code> overload from the return value, returns either 1 or 2. By subtracting the unit we will get the value <code>value</code> 0 or 1, where 1 is obtained if it is possible to substitute a pointer to the type, and 0 if not (then I will use this reception in the same way).  Now we have the opportunity to form the type of function pointer based on this check.  We can do it in different ways - based on overload or specialization.  I will show the method based on overload, because  he is more portable. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; may_add_ptr&lt;F&gt;::value == <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_reference&lt;F&gt;::type *) &gt;::type declfunc(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; may_add_ptr&lt;F&gt;::value == <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_reference&lt;F&gt;::type ) &gt;::type declfunc();</code> </pre>  So, we have formed the type <code>type</code> - a pointer to a function whose parameter is another type.  This is the type that we are investigating for belonging to the type ‚Äúfunction‚Äù.  So if <br> <code>declfunc&lt;F&gt;() == void(*)( F )</code> <br>  then our type <code>F</code> is a function.  The removal of the link ( <code>remove_reference</code> ) is necessary, in this case we will automatically get the inequality in case <br>  <code>F = R(&amp;)(Args)</code> , or <code>F = T &amp;</code> <br>  because  after all substitutions, the following types will be compared: <br>  <code>void(*)( R(*)(Args) )</code> and <code>void(*)( R(&amp;)(Args) )</code> <br>  or <br>  <code>void(*)( T )</code> and <code>void(*)( T &amp; )</code> <br>  respectively.  These types obviously do not match, which is what we need. <br>  In the case, if the type <code>F</code> is a function of the form <code>R(Args)</code> , then they will be compared <br>  <code>void(*)( R(*)(Args) )</code> and <code>void(*)( R(Args) )</code> . <br>  These types are equal, based on the above provisions of the standard ( <a href="https://habr.com/ru/post/277727/">8.3.5 / 3</a> ). <br>  If <code>F</code> is a function of the form <code>R(Args) const</code> , then they will be compared <br>  <code>void(*)( R(Args) const )</code> and <code>void(*)( R(Args) const )</code> . <br>  These types are also equal, which is what we need. <br>  If <code>F = T</code> (not a function), then they will be compared <br>  <code>void(*)( T * )</code> and <code>void(*)( T )</code> . <br>  These types are not equal, which is what we need. <br>  Now we need to actually compare the types.  There is one thing, but we cannot use the usual <code>is_same</code> based <code>is_same</code> , since  The argument of our <code>is_function</code> can also be an abstract type, the use of which in this context will result in a compilation error.  Therefore, we will replace the <code>is_same</code> with an SFINAE check of the following sense: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; is_function_check( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">( F ) ) )</span></span></span><span class="hljs-function">[2]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; is_function_check( ... ) )</span></span></span><span class="hljs-function">[1]</span></span>;</code> </pre>  We use it like this: <br><pre> <code class="cpp hljs"> value = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( is_function_check&lt;Tp&gt;( declfunc&lt;Tp&gt;() ) ) - <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <div class="spoiler">  <b class="spoiler_title">The full code looks like this.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">may_add_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; may_add_ptr_check(X *) )</span></span></span><span class="hljs-function">[2]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; may_add_ptr_check(...) )</span></span></span><span class="hljs-function">[1]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( may_add_ptr_check&lt;F&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>) ) - <span class="hljs-number"><span class="hljs-number">1</span></span> }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; may_add_ptr&lt;F&gt;::value == <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_reference&lt;F&gt;::type *) &gt;::type declfunc(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> enable_if&lt; may_add_ptr&lt;F&gt;::value == <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_reference&lt;F&gt;::type ) &gt;::type declfunc(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; is_function_check( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">( F ) ) )</span></span></span><span class="hljs-function">[2]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; is_function_check( ... ) )</span></span></span><span class="hljs-function">[1]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( is_function_check&lt;Tp&gt;( declfunc&lt;Tp&gt;() ) ) - <span class="hljs-number"><span class="hljs-number">1</span></span> }; };</code> </pre><br></div></div>  To verify that this pattern really works, let's write a testing macro. <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEST_IS_FUNCTION(Type, R) \ std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; ((::is_function&lt;Type&gt;::value == R) ? "[SUCCESS]" : "[FAILED]") \ &lt;&lt; " Test is_function&lt;" #Type "&gt; (should be [" #R "]):" \ &lt;&lt; std::boolalpha \ &lt;&lt; (bool)::is_function&lt;Type&gt;::value &lt;&lt; std::endl</span></span></span></span></code> </pre>  And run on the following <div class="spoiler">  <b class="spoiler_title">test suite.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span></span>; TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); TEST_IS_FUNCTION(f1, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(*)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(&amp;)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(f2, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); TEST_IS_FUNCTION(f3, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(S::*)(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(S::*)() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(S, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> [], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *[], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(...), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S::*, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TEST_IS_FUNCTION(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre><br></div></div>  <a href="">Here</a> you can see the full code of the sample and test, and <a href="http://melpon.org/wandbox/permlink/LBmut1UsZuTzbNm2">here</a> run.  By the way, this code also works for C ++ 11.  It was tested on GCC 4.4.x - 6.0, Clang 3.0 - 3.9, VS 2013 and VS 2015. There are compilers that consider adding a pointer to <code>F</code> with <i>cv-qualifier-seq to be a</i> valid substitution (for example, icc 13.x).  On these compilers, verification will not work. <br><br><a name="impl_2"></a><h2>  <font color="#464646">Implementation ‚Ññ2, corresponding to the standard</font> </h2><br>  Recall <a href="https://habr.com/ru/post/277727/">8.3.4 / 1</a> .  It said that a function is one of the few types whose array cannot be created.  Since the previous method is not all clear, maybe there will be more luck here?  Let us once again list the types of arrays we cannot create: <br><ol><li>  links </li><li> <code>void</code> </li> <li>  abstract classes </li><li>  functions </li></ol>  So, our task can now be divided into two stages.  Weed out other types with a similar behavior and write an SFINAE check that determines whether it is possible to create an array of the specified type.  First, let's eliminate the abstract classes.  Although the easiest way to weed out all classes at once.  For this we need a meta-function: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class</span></span></span><span class="hljs-class">;</span></span></code> </pre>  Now we need to remove from consideration references and void.  Use the following two templates for this: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_lvalue_reference</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_void</span></span></span><span class="hljs-class">;</span></span></code> </pre>  It seems to be all, but something is missing.  In fact, there is another type that cannot be an element of an array ‚Äî it is an <i>array of unknown bound</i> (arrays of unknown size <code>T[]</code> ).  We also need to weed out.  In principle, you can not suffer and sift out all the arrays at once. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_array</span></span></span><span class="hljs-class">;</span></span></code> </pre>  Implementation of these metafunctions can be found <a href="">here</a> , or take, for example, from boost. <br>  Now it's time to create the main template: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; check_is_function( ... ) )</span></span></span><span class="hljs-function">[2]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp; check_is_function( F (*)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">] ) )</span></span></span><span class="hljs-function">[1]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = !is_class&lt;Tp&gt;::value &amp;&amp; !is_void&lt;Tp&gt;::value &amp;&amp; !is_lvalue_reference&lt;Tp&gt;::value &amp;&amp; !is_array&lt;Tp&gt;::value &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( check_is_function&lt;Tp&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>) ) - <span class="hljs-number"><span class="hljs-number">1</span></span>) }; };</code> </pre>  Checking whether a type can be an element of an array is organized through the definition of the type ‚Äúpointer to an array‚Äù, with elements of the type being tested as a parameter of the function <code>check_is_function</code> .  If the substitution is unsuccessful, then type <code>F</code> is a function. <br>  As a test, we take the previous set of <a href="https://habr.com/ru/post/277727/">implementation 1</a> .  The full code can be viewed <a href="">here</a> , and run <a href="http://melpon.org/wandbox/permlink/Ud8ffaSttt2kzxWy">here</a> .  This implementation is fully compliant with the standard and most likely will work on most compilers.  This code also works for C ++ 11, you only need to additionally filter out rvalue references. <br><br><a name="final"></a><h2>  <font color="#464646">Instead of conclusion</font> </h2><br>  1) I sent three bug reports about illegal promotion of the function from <i>cv-qualifier-seq</i> to the pointer: <br>  In <a href="https://llvm.org/bugs/show_bug.cgi%3Fid%3D26685">support of Clang</a> . <br>  In <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi%3Fid%3D69898">support of the GCC</a> . <br>  In <a href="https://connect.microsoft.com/VisualStudio/feedback/details/2389057">support of VS.</a> <br>  As already mentioned, I'm not 100% sure, but this is the only way to get the opinion of developers on this issue. <br><br>  2) The full code that is on my <a href="https://github.com/wanderhq/ct_examples">github</a> is a little different from the one given in the article for the better.  Here some details and good tone rules were intentionally omitted. <br><br><div class="spoiler">  <b class="spoiler_title">2.1) I was asked to describe in more detail the types of functions with cv-qialifier-seq.</b> <div class="spoiler_text">  It is quite clear that this type cannot be used to declare a free function, since  <i>cv-qialifier-seq</i> refers to this (see 9.3.1 / 3). <br>  So in what situations does it work?  The standard allows this for the following cases: <br>  <b>8.3.5 / 7</b> <br><blockquote>  A typedef of a function type declarant includes a cv-qualifier-seq shall be used <br>  only to declare a function, to declare a function <br>  pointer to member refers to a function typedef function. <br>  [Example: <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; FIC f; <span class="hljs-comment"><span class="hljs-comment">// ill-formed: does not declare a member function struct S { FIC f; // OK }; FIC S::*pm = &amp;S::f; // OK</span></span></code> </pre>  ‚ÄîEnd example] </blockquote>  Those.  You can use the typedef function type with <i>cv-qualifier-seq</i> : <ul><li>  declare member functions </li><li>  form a pointer to a member function and </li><li>  use it as the top level type in the typedef declaration of another type of function. </li></ul>  The latter case is rather vague (what is meant by another function?).  For comparison, I will quote from the last draft: <br>  <b>8.3.5 / 6</b> <br><blockquote>  A type qualifier-seq or a ref-qualifier (7.1.3, 14.1) shall appear only as: <br>  (6.1) - the function type for a non-static member function, <br>  (6.2) - this function refers to <br>  (6.3) - the function typedef declaration or alias-declaration, <br>  (6.4) - the type-id of the type-parameter (14.1), or <br>  (6.5) - the type-id of a template-argument for a type-parameter (14.3.1). <br>  [Example: <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; FIC f; <span class="hljs-comment"><span class="hljs-comment">// ill-formed: does not declare a member function struct S { FIC f; // OK }; FIC S::*pm = &amp;S::f; // OK</span></span></code> </pre>  - end example] </blockquote>  Agree, it is much more understandable (note 6.3, now it legalizes the use of <i>cv-qualifier-seq</i> in the <code>typedef</code> type declaration of the top-level function <i>and only</i> , no another function).  The fact that such a type can now be used as a parameter of a function is the subject of bug reports that I made.  In addition, in this case, these types will be promoted to the pointer, and this is also prohibited ( <a href="https://habr.com/ru/post/277727/">8.3.1 / 4</a> ). <br>  Compare changes <a href="http://wg21.cmeerw.net/cwg/issue1417">here</a> .  It is also possible that someone will be interested in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html">this material</a> . <br></div></div><br>  3) Thank you for your attention :) <br></div><p>Source: <a href="https://habr.com/ru/post/277727/">https://habr.com/ru/post/277727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277715/index.html">D std.ndslice as a replacement for Python Numpy</a></li>
<li><a href="../277717/index.html">LLVM: do-it-yourself compiler. Introduction</a></li>
<li><a href="../277721/index.html">Mesh router is easy</a></li>
<li><a href="../277723/index.html">Asymmetric solutions. ICS Information Security in Energy</a></li>
<li><a href="../277725/index.html">Microsoft Android emulator cooling beer with IoT and Windows 10 and The Maker Show for those who like to solder</a></li>
<li><a href="../277729/index.html">Build a hybrid Android application</a></li>
<li><a href="../277733/index.html">The history of one configuration "umbrella"</a></li>
<li><a href="../277737/index.html">Lazy list in C ++</a></li>
<li><a href="../277739/index.html">Zabbix 3.0: Encryption</a></li>
<li><a href="../277741/index.html">Backup and transfer of data in the browser Vivaldi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>