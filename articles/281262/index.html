<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why is database denormalization necessary, and when to use it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In our blog on Habr√©, we not only talk about the development of our product - billing for Hydra telecom operators , but also publish materials about w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why is database denormalization necessary, and when to use it</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/latera/blog/281262/"><img src="https://habrastorage.org/files/cde/c3e/7e9/cdec3e7e9a184dee98cf9b6c0be86c1e.jpg"></a> <br><br>  In our blog on Habr√©, we not only talk about the development of our product - <a href="http://www.hydra-billing.ru/">billing for Hydra telecom operators</a> , but also publish materials about working with infrastructure and using technologies. <br><br>  Recently, we wrote about the use of <a href="https://habrahabr.ru/company/latera/blog/280734/">Clojure</a> and <a href="https://habrahabr.ru/company/latera/blog/280196/">MongoDB</a> , and today we will talk about the pros and cons of denormalizing databases.  Database developer and financial analyst Emil Drku≈°iƒá wrote on Vertabelo's blog about why, how and when to use this approach.  We present to your attention the main points of this article. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What is denormalization? </h4><br>  Usually, this term is understood as a strategy applicable to an already normalized database in order to increase its performance.  The point of this action is to put redundant data where they can bring maximum benefit.  To do this, you can use additional fields in existing tables, add new tables, or even create new instances of existing tables.  The logic is to reduce the execution time of certain queries through the simplification of data access or through the creation of tables with the results of reports built on the basis of the initial data. <br><br>  An indispensable condition for the process of denormalization is the presence of a normalized base.  It is important to understand the difference between the situation when the database was not normalized at all, and the normalized base, which was then denormalized.  In the second case, everything is fine, but the first one speaks of errors in the design or lack of knowledge among the specialists who were engaged in this. <br><br>  Consider the normalized model for the simplest CRM system: <br><br> <a href=""><img src="https://habrastorage.org/files/919/f02/27a/919f0227afd840909414e06a3890454b.png"></a> <br><br>  Let's go over the tables available here: <br><br><ul><li> The <code>user_account</code> table stores data about users registered in the application (to simplify the role model and user rights are excluded from it). </li><li>  The <code>client</code> table contains some basic information about clients. </li><li>  The <code>product</code> table is a list of products offered. </li><li>  The <code>task</code> table contains all created tasks.  Each of them can be represented as a set of coordinated actions in relation to the client.  For each there is a list of calls, meetings, proposed and sold goods. </li><li>  The <code>call</code> and <code>meeting</code> tables store data about orders and customer meetings and link them to current tasks. </li><li>  The <code>task_outcome</code> , <code>meeting_outcome</code> and <code>call_outcome</code> contain all possible outcomes of calls, meetings, and tasks. </li><li>  <code>product_offered</code> stores a list of products that have been offered to customers; </li><li>  <code>product_sold</code> - products that managed to sell. </li><li>  The <code>supply_order</code> table stores information about all placed orders. </li><li>  The <code>writeoff</code> table contains a list of <code>writeoff</code> written off for any reason. </li></ul><br>  In this example, the database is greatly simplified for clarity.  But it is not difficult to see that it is perfectly normalized - there is no redundancy in it, and everything should work like a clock.  No performance problems arise until the database encounters a large amount of data. <br><br><h4>  When it is useful to use denormalization </h4><br>  Before we take on the normalization of what has already been normalized once, naturally, you need to clearly understand why this is necessary?  You should make sure that the benefits of applying the method outweigh the possible negative effects.  Here are some situations in which you should definitely think about denormalization. <br><br><ol><li>  <b>Preservation of historical data</b> .  The data changes over time, but it may be necessary to preserve the values ‚Äã‚Äãthat were entered at the time the record was created.  For example, the name and surname of a client or other information about his place of residence and occupation may change.  The task must contain the values ‚Äã‚Äãof the fields that were relevant at the time the task was created.  If this is not provided, then it will not be possible to recover past data correctly.  You can solve the problem by adding a table with a history of changes.  In this case, a SELECT query that returns the task and the actual name of the client will be more complicated.  Perhaps an additional table is not the best way out. </li><li>  <b>Increase query performance</b> .  Some queries may use multiple tables to access frequently requested data.  An example is a situation when it is necessary to combine up to 10 tables in order to obtain the name of the client and the name of the goods that were sold to him.  Some of them, in turn, may contain large amounts of data.  In this scenario, it would be wise to add the <code>client_id</code> field <code>client_id</code> to the <code>products_sold</code> table. </li><li>  <b>Accelerate report generation</b> .  Business often needs to upload certain statistics.  Creating reports on "live" data may require a lot of time, and the performance of the entire system may in this case drop.  For example, you want to track customer sales for a certain period for a given group or for all users at once.  The request that solves this task in the ‚Äúcombat‚Äù base will be shoveling it completely before such a report is formed.  It is not difficult to imagine how much slower everything will work if such reports are needed daily. </li><li>  <b>Preliminary calculations of frequently requested values</b> .  There is always a need to keep the most frequently requested values ‚Äã‚Äãat the ready for regular calculations, rather than creating them anew, generating them each time in real time. </li></ol><br>  The conclusion suggests itself: you should not turn to denormalization if there are no problems associated with the performance of the application.  But if it is felt that the system has slowed down or will soon slow down, it‚Äôs time to think about the use of this technique.  However, before referring to it, it is worthwhile to use other possibilities for improving performance: query optimization and proper indexing. <br><br><h4>  Not so smooth </h4><br>  The obvious goal of denormalization is to increase productivity.  But everything has its price.  In this case, it consists of the following items: <br><br><ul><li>  <b>Disk space</b> .  Expected, since data is duplicated. </li><li>  <b>Data anomalies</b> .  It is necessary to understand that from a certain moment the data can be changed in several places simultaneously.  Accordingly, it is necessary to correctly change their copies.  The same applies to reports and precomputed values.  You can solve the problem using triggers, transactions and stored procedures for combining operations. </li><li>  <b>Documentation</b>  Every use of denormalization should be documented in detail.  If in the future the structure of the base changes, then in the course of this process it will be necessary to take into account all past changes - it is possible that they will generally be abandoned by that moment as unnecessary.  (Example: a new attribute has been added to the client table, which makes it necessary to save past values. To solve this problem, you have to change the denormalization settings). </li><li>  <b>Slowing down other operations</b> .  It is possible that the use of denormalization will slow down the processes of insertion, modification and deletion of data.  If such actions are carried out relatively rarely, then this may be justified.  In this case, we break one slow SELECT query into a series of smaller queries for entering, updating, and deleting data.  If a complex query can seriously slow down the entire system, then slowing down many small operations will not affect the quality of the application‚Äôs work in such a dramatic way. </li><li>  <b>More code</b> .  Items 2 and 3 will require the addition of a code.  At the same time, they can significantly simplify some queries.  If the existing database is denormalized, then these queries will need to be modified to optimize the entire system.  You will also need to update existing entries by filling in the values ‚Äã‚Äãof the added attributes ‚Äî this will also require writing a certain amount of code. </li></ul><br><h4>  Denormalization by example </h4><br>  In the presented model, some of the aforementioned denormalization rules were applied.  Blue marked new blocks, pink - those that have been changed. <br><br> <a href=""><img src="https://habrastorage.org/files/097/246/7bd/0972467bdedd4893b8546b2429e1e116.png"></a> <br><br>  What has changed and why? <br><br><img src="https://habrastorage.org/files/e4d/3fe/575/e4d3fe575017409dab03fd7610408515.png"><br><br>  The only innovation in the <code>product</code> table is the string <code>units_in_stock</code> .  In the normalized model, we can calculate this value as follows: ordered title - sold - (proposed) - written off (units ordered - units sold - (units offered) - units written off).  The calculation is repeated every time a customer requests a product.  This is a fairly time consuming process.  Instead, it is possible to calculate the value in advance so that by the time the request is received from the buyer, everything will be ready.  On the other hand, the units_in_stock attribute must be updated after each entry, update, or delete operation in the <code>products_on_order</code> , <code>writeoff</code> , <code>product_offered</code> and <code>product_sold</code> tables. <br><br><img src="https://habrastorage.org/files/fb2/642/9d8/fb26429d831a4432ac617e76339bffa3.png"><br><br>  Two new attributes have been added to the <code>task</code> table: <code>client_name</code> and <code>user_first_last_name</code> .  Both of them store values ‚Äã‚Äãat the time the task is created ‚Äî this is necessary, because each of them can change over time.  You also need to save the foreign key that binds them to the original user and client IDs.  There are other values ‚Äã‚Äãthat need to be stored - for example, the client‚Äôs address or information on taxes included in the price, such as VAT. <br><br><img src="https://habrastorage.org/files/d73/fa8/972/d73fa89724ed4a54be54001b964af0ff.png"><br><br>  The denormalized <code>product_offered</code> table received two new attributes: <code>price_per_unit</code> and <code>price</code> .  The first of them is necessary to store the current price at the time of the offer of goods.  The normalized model will only show its current state.  Therefore, as soon as the price changes, the ‚Äúprice history‚Äù will change.  Innovation does not just speed up the base, it improves functionality.  The price string calculates the value of <i>units_sold * price_per_unit</i> .  Thus, it is not necessary to do the calculation every time you need to look at the list of proposed goods.  This is a small price per increase. <br><br>  Changes to the <code>product_sold</code> table are made for the same reasons.  With the only difference that in this case we are talking about the sold items of goods. <br><br><img src="https://habrastorage.org/files/133/99d/1b1/13399d1b1ac84f9a9a0c490b83770a12.png"><br><br>  The <code>statistics_per_year</code> table (annual statistics) in the test model is a completely new element.  In essence, this is a denormalized table, since all its data can be calculated from other tables.  Information about current tasks, successfully completed tasks, meetings, and calls for each given client is stored here.  This place also stores the total amount of accruals for each year.  After entering, updating, or deleting any data in the <code>task</code> , <code>meeting</code> , <code>call</code> and <code>product_sold</code> tables, you must recalculate this data for each client and the corresponding year.  Since the changes are most likely related only to the current year, reports for previous years can now remain unchanged.  The values ‚Äã‚Äãin this table are calculated in advance, so we will save time and resources when we need the results of the calculations. <br><br>  Denormalization is a powerful approach.  Not that it should be resorted to every time there is a task of increasing productivity.  But in some cases this may be the best or even the only solution. <br><br>  However, before making a final decision on the use of denormalization, you should make sure that it is really necessary.  It is necessary to analyze the current performance of the system - often denormalization is used after the system is started up.  Do not be afraid of this, but you should carefully monitor and document all changes, then problems and data anomalies should not arise. <br><br><h4>  Our experience </h4><br>  We in Latera do a lot of work on optimizing the performance of our Hydra billing system, which is not surprising given the size of our customers and the specifics of the telecom industry. <br><br>  One of the examples in the article assumes the creation of a table with interim results to speed up reports.  Of course, the most difficult thing in this approach is to maintain the current state of such a table.  Sometimes it is possible to shift this task to a DBMS ‚Äî for example, to use materialized views.  But, when business logic is slightly more complex to obtain intermediate results, the relevance of denormalized data has to be maintained manually. <br><br>  ‚ÄúHydra‚Äù has a deeply developed system of privileges for users, billing operators.  Rights are granted in several ways - you can allow certain actions to a specific user, you can prepare roles in advance and give them different sets of rights, you can give a certain department special privileges.  Just imagine how slow the calls to any entities of the system would be if every time you had to go through this whole chain to make sure: ‚Äúyes, this employee is allowed to enter into agreements with legal entities‚Äù or ‚Äúno, this operator does not have enough privileges to work with subscribers of the neighboring branch ".  Instead, we separately store the ready aggregated list of existing rights for users and update it when changes are made to the system that can affect this list.  Employees move from one department to another much less frequently than they open the next subscriber in the billing interface, which means we have to calculate the full set of their rights just as often. <br><br>  Of course, denormalizing the repository is only one of the measures taken.  Part of the data should be cached directly in the application, but if intermediate results on average live much longer than user sessions, it makes sense to seriously think about denormalization to speed up reading. <br><br><h4>  Other technical articles on our blog: </h4><br><ul><li>  <a href="https://habrahabr.ru/company/latera/blog/280196/">Pros and cons: When it is worth and not worth using MongoDB</a> </li><li>  <a href="https://habrahabr.ru/company/latera/blog/280734/">Opinion: Why you should learn and use Clojure</a> </li><li>  <a href="https://habrahabr.ru/company/latera/blog/277331/">DoS on your own: What causes the uncontrolled growth of tables in the database</a> </li><li>  <a href="https://habrahabr.ru/company/latera/blog/273283/">Open source application architecture: How nginx works</a> </li><li>  <a href="https://habrahabr.ru/company/latera/blog/267083/">How to improve resiliency of billing: The experience of "Hydra"</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/281262/">https://habr.com/ru/post/281262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281250/index.html">Security Week 14: a dangerous vulnerability in Adobe Flash, WhatsApp includes encryption, the Pentagon pays for bugs</a></li>
<li><a href="../281252/index.html">How to use Microsoft Wunderlist organizer in your 3CX call center</a></li>
<li><a href="../281254/index.html">An almost complete guide to flexbox (without the flexbox itself)</a></li>
<li><a href="../281256/index.html">eToken lived, eToken alive, eToken will live</a></li>
<li><a href="../281260/index.html">30% discount on 3CX Phone System and 3CX WebMeeting</a></li>
<li><a href="../281264/index.html">How buyers behave with Habra</a></li>
<li><a href="../281270/index.html">Lookbehind assertions in V8 regular expressions</a></li>
<li><a href="../281272/index.html">Tracert vs traceroute</a></li>
<li><a href="../281274/index.html">The dangers of not looking ahead</a></li>
<li><a href="../281276/index.html">Testing audio conferencing with Pandora online radio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>