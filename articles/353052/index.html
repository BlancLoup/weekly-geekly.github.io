<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android Lifecycle-aware Architecture Components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="November 6, 2017, Google has published information about the announcement of a stable version 
 architectural components . Google developers provided ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android Lifecycle-aware Architecture Components</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ce/cu/fb/cecufb4avcrt8gbd15dvf9f53va.jpeg"><br><br>  November 6, 2017, Google has published information about the announcement of a stable version <br>  <a href="https://android-developers.googleblog.com/2017/11/announcing-architecture-components-10.html">architectural components</a> .  Google developers provided an <a href="https://developer.android.com/topic/libraries/architecture/index.html">application architecture</a> guide and introduced a number of classes and interfaces that simplify building applications with built architecture, ease new programmers from joining the project, and reduce the threshold for entry into the world of adult development for people who have just started programming for Android. <br><br>  The presented components for working with the life cycle of Android can be compared with a clockwork hidden from the eyes.  Just a couple of lines of code and everything works.  But how does everything work?  And in general, is it worth using architectural components in your home projects or even in projects with hundreds of thousands of active installations? <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text">  Developer code is provided in the Kotlin development language.  Excerpts from Google‚Äôs source code are provided in Java.  In the excerpts of the code may be omitted. </div></div><br><h3>  Lifecycle, lifecycle-aware components and activities </h3><br>  The life cycle is a very important point in the world of android development, which is often not given enough attention.  For this reason, users may experience errors in the application.  For example, during a phone call, the application may terminate with a critical error.  This is due to the re-creation of activations and unprocessed state preservation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Part of the problem of rebuilding activit can be avoided.  For example, to prohibit the re-creation - put in the manifest the <i>activation</i> setting <i>android: screenOrientation = ‚Äúportrait‚Äù</i> .  But this will only solve problems with the re-creation of activations during configuration changes (for example, changing the orientation of the screen).  The problem that at some point the operating system does not have enough memory and it will destroy the process with executable activation, this method does not solve.  Returning to working with the application, the first thing that the user sees is a critical error. <br><br>  One way or another, the developer needs to take care of handling the life cycle states.  Lifecycle-aware components come to the rescue.  The architectural components have a stable version 1.0 and can be used in the production-development of applications. <br><br><h3>  Pros and cons of using lifecycle-aware components </h3><br>  Consider the practical advantages and disadvantages of using components. <br><br>  Plus certainly more <br><br><ol><li>  Connecting a new employee to the application development team.  All android developers know and know how to use official libraries from Google.  No need to spend time learning local solutions to maintain the architecture; </li><li>  less code when developing features; </li><li>  component stability; </li><li>  improving the stability of the application after the introduction of components. </li></ol><br>  Minuses <br><br><ol><li>  time to familiarize with the components and adding to the project; </li><li>  code was added to support the architecture when developing a new function, but this minus is easily solved by generating code.  Good articles on this topic <a href="https://habrahabr.ru/post/274959/">here</a> and <a href="https://habrahabr.ru/company/redmadrobot/blog/274897/">here</a> . </li></ol><br><h3>  How to work with lifecycle-aware components? </h3><br>  Starting with the Support Library version 26.1.0, fragments and activations out of the box implement the LifecycleOwner interface.  This interface has only one method - <i>getLifecycle ()</i> . <br>  To add a life cycle event observer, all you need is to implement the LifecycleObserver interface in the class observer and write it in the activation / fragment <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addLifecycleObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { lifecycle.addObserver(observer) }</code> </pre> <br>  And all?  Yes, for a developer, this is where the work ends.  It is enough to mark the necessary methods with annotations in the observer code and react to life cycle events. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre><br>  An interesting fact is that with the same annotation you can mark several methods and all of them will be called when the state of the life cycle changes. <br><br>  What is behind the pair of lines, how does everything work, what are the nuances? <br>  Let's find the answers to the questions listed below on the example of the fragment. <br><br><h3>  What does the fragment return by implementing the LifecycleOwner interface in the getLifecycle () method?  Description of the main methods </h3><br>  The fragment implements the LifecycleOwner interface, implementing the <i>getLifecycle ()</i> method <i>: Lifecycle</i> . <br><br>  Lifecycle is an abstract class that defines an object as an object that has an Android life cycle. <br><br>  Implementing this class LifecycleRegistry takes over all the work of monitoring the addition, removal of observers, handling life cycle events, reporting life cycle changes to all observers. <br><br>  Adding an observer. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span></span></span>;</code> </pre><br>  An important nuance is that when LifecycleObserver is added to the list of observers, the observer will receive events about the change of all the states that precede the current one. <br><br>  That is, if LifecycleOwner is in the <i>Lifecycle.State.STARTED</i> state when adding LifecycleObserver, the latter will receive two <i>Lifecycle.Event.ON_CREATE</i> and <i>Lifecycle.Event.ON_START</i> events. <br><br>  So, we have a guarantee that our observer will go through all the steps of initialization, relying on life cycle events, and will not miss any configuration stage. <br><br>  Removing an observer from the list of observers occurs in the method. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span></span></span>;</code> </pre><br>  If the observer is removed during a life cycle state change and the sending of a state change event is triggered after deletion, the observer will not receive this event. <br><br>  If the observer has several methods waiting for one event and at least one of the methods was called when the observer was removed from the list of observers, then all other methods will also be called and only after that the deletion will occur. <br><br>  Return current status on request. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  At any time, you can query the current state of the life cycle and, based on the answer, take any action.  The method will return an instance of the State enumeration. <br><br>  <b>There are the following types of State</b> <br><br>  <i>INITIALIZED</i> - this state corresponds to the time when the entity implementing the LifecycleOwner interface was created, but the onCreate () method was not called anymore. <br><br>  <i>CREATED</i> - this state is active after calling the onCreate () method and before calling onStop (). <br><br>  <i>STARTED</i> - this state is active after calling the onStart () method and before calling onPause (). <br><br>  <i>RESUMED</i> - this state occurs after calling the onResume () method. <br><br>  <i>DESTROYED</i> - this state occurs immediately before the onDestroy () call.  When this state occurs, LifecycleOwner no longer sends state change events. <br><br><h3>  What happens when you add an observer to the watch list? </h3><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span></span><span class="hljs-function"> </span></span>{ State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObserverWithState(observer, initialState); &lt;...&gt; }</code> </pre><br>  When the <i>lifecycle.addObserver (observer)</i> method is called, the observer is placed in the instance constructor of the wrapper class ObserverWithState.  As is clear from the class name, this class stores observer with the last processed life cycle state.  Initially sets the status to DESTROYED or INITIALIZED. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span></span><span class="hljs-function"> </span></span>{ &lt;...&gt; ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previous != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lifecycleOwner == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// it is null we should be destroyed. Fallback quickly return; } &lt;...&gt; }</span></span></code> </pre><br>  After creating an instance of the observer with the last processed state of the life cycle - we try to add an observer to the FastSafeIterableMap collection using the putIfAbsent () method. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putIfAbsent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull K key, @NonNull V v)</span></span></span><span class="hljs-function"> </span></span>{ Entry&lt;K, V&gt; current = get(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current.mValue; } mHashMap.put(key, put(key, v)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br>  If the method returns an element, then it already exists in the collection and you do not need to add it again.  What happens next in the code.  The <i>addObserver ()</i> method <i>stops</i> if there is an existing observer in the list.  Also, work is terminated if <i>lifecycleOwner == null</i> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span></span><span class="hljs-function"> </span></span>{ &lt;...&gt; State targetState = calculateTargetState(observer); mAddingObserverCounter++; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; mObserverMap.contains(observer))) { pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); <span class="hljs-comment"><span class="hljs-comment">// mState / subling may have been changed recalculate targetState = calculateTargetState(observer); } &lt;...&gt; }</span></span></code> </pre><br>  The current state of the life cycle is calculated and events begin to be sent until the state stored in the observer is less than the current one. <br><br>  What is upEvent (state: State)?  Note also that there is a downEvent (state: State).  Depending on what is happening now with the life cycle, based on the current state, you can determine which event should be sent to the observer. <br><br>  It is easy to deal with this by looking at the body of the methods and the diagram below. <br><br><img src="https://habrastorage.org/webt/rk/a6/t9/rka6t9qn02zkyb0m-oj1snxh3do.png"><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Event </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INITIALIZED: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ON_DESTROY; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STARTED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ON_STOP; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESUMED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ON_PAUSE; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DESTROYED: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Unexpected state value "</span></span> + state); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Event </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INITIALIZED: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DESTROYED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ON_CREATE; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ON_START; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STARTED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ON_RESUME; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESUMED: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Unexpected state value "</span></span> + state); }</code> </pre><br><h3>  How does LifecycleOwner report to LifecycleObserver about events occurring in a fragment's life cycle? </h3><br>  The snippet that implements the LifecycleOwner interface contains a number of methods available to call that correspond to lifecycle events: such as <i>performCreate (savedInstanceState: Bundle)</i> , <i>performStart ()</i> , <i>performStop (),</i> and others. <br><br>  The FragmentManagerImpl class calls these methods, and the corresponding onStart, onStop, and other methods are called in the fragment in turn.  And also the methods of the LifecycleRegistry class are called. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ &lt;...&gt; onStart(); mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); }</code> </pre><br>  In the LifecycleRegistry class, the state is calculated, about which the next event should be sent based on the received event. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleLifecycleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Lifecycle.Event event)</span></span></span><span class="hljs-function"> </span></span>{ State next = getStateAfter(event); moveToState(next); }</code> </pre><br>  And after that, it is calculated what type of event should be sent to the observer - upEvent (state: State) or downEvent (state: State) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LifecycleOwner owner, Event event)</span></span></span><span class="hljs-function"> </span></span>{ State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; }</code> </pre><br><h3>  Conclusion </h3><br>  In fact, only some of the classes and interfaces created by Google are described.  But for the presentation of how everything happens and what lies behind a couple of lines of code this is enough. <br>  Google developers have provided a truly powerful tool for developing applications with supporting architecture.  In conjunction with other components, the developer has the opportunity to develop reliable applications and not to write their own, not always ideal solutions. </div><p>Source: <a href="https://habr.com/ru/post/353052/">https://habr.com/ru/post/353052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353040/index.html">Evaluating human capital of an IT company using SFIA criteria</a></li>
<li><a href="../353044/index.html">The digest of interesting materials for the mobile developer # 248 (April 2 - April 8)</a></li>
<li><a href="../353046/index.html">Briefly about the formats of fiscal documents: shoals version 1.0 and the transition to version 1.05 and 1.1</a></li>
<li><a href="../353048/index.html">Windows virtual server with video card on board</a></li>
<li><a href="../353050/index.html">Data Analysis Using Python</a></li>
<li><a href="../353054/index.html">Learn OpenGL. Lesson 5.1 - Advanced Lighting. Model Blinna-Fong</a></li>
<li><a href="../353056/index.html">PHP Digest 128 (March 25 - April 8, 2018)</a></li>
<li><a href="../353058/index.html">Is there any powder in the old dog? Hackathon Radio Canada 2018 (Part Three - Start! Attention! March!)</a></li>
<li><a href="../353060/index.html">Application of convolutional neural networks for NLP problems</a></li>
<li><a href="../353064/index.html">Kubernetes 1.10: we stabilize data storage, security and networking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>