<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python memory usage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How many memory takes 1 million integers? 
 I have often been bothered by the thought of how efficiently Python uses memory as compared to other progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python memory usage</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage3/2f5/bbd/ad5/2f5bbdad55405645e515e0e79631cb64.jpg" alt="image"><br><h4>  How many memory takes 1 million integers? </h4><br>  I have often been bothered by the thought of how efficiently Python uses memory as compared to other programming languages.  For example, how much memory does it take to work with 1 million integers?  And with the same number of lines of arbitrary length? <br>  As it turned out, in Python there is an opportunity to get the necessary information directly from the interactive console, without referring to the source code in C (although, to be sure, we still look there). <br>  Having satisfied the curiosity, we crawled inside the data types and find out what exactly the memory is spent on. <br><a name="habracut"></a><br>  All examples were made in CPython version 2.7.4 on a 32 bit machine.  At the end there is a table for the memory requirement on a 64 bit machine. <br><br><h4>  Required Tools </h4><br><h5>  sys.getsizeof and __sizeof __ () method </h5><br>  The first tool we need is in the standard sys library.  We quote the official documentation: <br><br><blockquote>  <b>sys.getsizeof (object [, default_value])</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Returns the size of the object in bytes. <br>  If a default value is specified, it will return if the object does not provide a way to get the size.  Otherwise, a TypeError exception will be thrown. <br>  Getsizeof () calls the object method __sizeof__ and adds the size of additional information that is stored for the garbage collector, if used. <br></blockquote><br><br>  The algorithm for working with a getsizeof () rewritten in Python might look like this: <br><pre><code class="python hljs">Py_TPFLAGS_HAVE_GC = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-comment"><span class="hljs-comment"># .     0b100000000000000 def sys_getsizeof(obj, default = None)     if obj.hasattr('__sizeof__'):         size = obj.__sizeof__()     elif default is not None:         return default     else:         raise TypeError('    __sizeof__')     #       HAVE_GC     if type(obj).__flags__ &amp; Py_TPFLAGS_HAVE_GC:         size = size +  PyGC_Head     return size</span></span></code> </pre> <br><br>  Where PyGC_Head is a double linked list item that is used by the garbage collector to detect ring references.  In the source code, it is represented by the following structure: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _gc_head { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _gc_head *gc_next; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _gc_head *gc_sourcev; Py_ssize_t gc_refs; } gc; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dummy; } PyGC_Head;</code> </pre><br><br>  The size of PyGC_Head will be 12 bytes on a 32 bit and 24 bytes on a 64 bit machine. <br><br>  Let's try to call getsizeof () in the console and see what happens: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys &gt;&gt;&gt; GC_FLAG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">14</span></span> &gt;&gt;&gt; sys.getsizeof(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">12</span></span> &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span>).__sizeof__() <span class="hljs-number"><span class="hljs-number">12</span></span> &gt;&gt;&gt; bool(type(<span class="hljs-number"><span class="hljs-number">1</span></span>).__flags__ &amp; GC_FLAG) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; sys.getsizeof(<span class="hljs-number"><span class="hljs-number">1.1</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span> &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">1.1</span></span>).__sizeof__() <span class="hljs-number"><span class="hljs-number">16</span></span> &gt;&gt;&gt; bool(type(<span class="hljs-number"><span class="hljs-number">1.1</span></span>).__flags__ &amp; GC_FLAG) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; sys.getsizeof(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-number"><span class="hljs-number">21</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span>.__sizeof__() <span class="hljs-number"><span class="hljs-number">21</span></span> &gt;&gt;&gt; bool(type(<span class="hljs-string"><span class="hljs-string">''</span></span>).__flags__ &amp; GC_FLAG) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; sys.getsizeof(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-number"><span class="hljs-number">26</span></span> &gt;&gt;&gt; sys.getsizeof(tuple()) <span class="hljs-number"><span class="hljs-number">24</span></span> &gt;&gt;&gt; tuple().__sizeof__() <span class="hljs-number"><span class="hljs-number">12</span></span> &gt;&gt;&gt; bool(type(tuple()).__flags__ &amp; GC_FLAG) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; sys.getsizeof(tuple((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))) <span class="hljs-number"><span class="hljs-number">36</span></span></code> </pre><br><br>  With the exception of flag-checking magic, everything is very simple. <br>  As you can see from the example, int and float occupy 12 and 16 bytes, respectively.  Str takes 21 bytes and one more byte for each character of content.  An empty tuple is 12 bytes, and an additional 4 bytes for each element.  For simple data types (which do not contain references to other objects and, accordingly, are not tracked by the garbage collector), the sys.getsizeof value is equal to the value returned by the __sizeof __ () method. <br><br><h5>  id () and ctypes.string_at </h5><br>  Now we‚Äôll find out what exactly the memory is spent on. <br>  To do this, we need two things: first, to find out exactly where the object is stored, and second, to get direct read access from the memory.  Despite the fact that Python carefully protects us from direct memory access, it is still possible to do this.  You need to be careful as this can lead to a segmentation error. <br><br>  The built-in function id () returns the address of the memory where the beginning of the object is stored (the object itself is a C structure) <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj = <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; id(obj) <span class="hljs-number"><span class="hljs-number">158020320</span></span></code> </pre><br><br>  To read data from a memory address, you need to use the string_at function from the ctypes module.  Its official description is not very detailed: <br><blockquote>  <b>ctypes.string_at (address [, length])</b> <br>  This function returns a string, with the beginning in the memory cell "address".  If "length" is not specified, then the string is considered to be zero-terminated, </blockquote><br><br>  Now let's try to read the data at the address that returned us id (): <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; obj = <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; sys.getsizeof(obj) <span class="hljs-number"><span class="hljs-number">12</span></span> &gt;&gt;&gt; ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-string"><span class="hljs-string">'u\x01\x00\x00 \xf2&amp;\x08\x01\x00\x00\x003\x01\x00\x00 \xf2&amp;\x08\x00\x00\x00\x001\x00\x00\x00'</span></span></code> </pre><br><br>  The view of the hexadecimal code is not very impressive, but we are close to the truth. <br><br><h5>  Struct model </h5><br>  In order to present the output to values ‚Äã‚Äãthat are convenient for perception, we will use another module.  Here we can use the unpack () function from the struct module. <br><br><blockquote>  <b>struct</b> <br>  This module converts between Python values ‚Äã‚Äãand C structures, represented as strings. <br><br>  <b>struct.unpack (format, string)</b> <br>  Parses the string according to the given formats.  Always returns a tuple, even if the string contains only one element.  The string must contain exactly the amount of information as described by the format. </blockquote><br><br>  The data formats that we need. <br><table><tbody><tr><td>  symbol </td><td>  C value </td><td>  Python value </td><td>  Length on a 32bit machine </td></tr><tr><td>  c </td><td>  char </td><td>  Single character string </td><td>  one </td></tr><tr><td>  i </td><td>  int </td><td>  int </td><td>  four </td></tr><tr><td>  l </td><td>  long </td><td>  int </td><td>  four </td></tr><tr><td>  L </td><td>  unsigned long </td><td>  int </td><td>  four </td></tr><tr><td>  d </td><td>  double </td><td>  float </td><td>  eight </td></tr></tbody></table><br><br>  Now we collect everything together and look at the internal structure of some data types. <br><br><h5>  Int </h5><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj = <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; sys.getsizeof(obj), obj.__sizeof__() (<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLl'</span></span>, ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">12</span></span>)) (<span class="hljs-number"><span class="hljs-number">373</span></span>, <span class="hljs-number"><span class="hljs-number">136770080</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><br>  The format of the values ‚Äã‚Äãis easy to guess. <br><br>  The first number (373) is the number of pointers to the object. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj2 = obj &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLl'</span></span>, ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">12</span></span>)) (<span class="hljs-number"><span class="hljs-number">374</span></span>, <span class="hljs-number"><span class="hljs-number">136770080</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  As you can see, the number has increased by one, after we have created another link to the object. <br><br>  The second number (136770080) is a pointer (id) to the object type: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>type(obj) &lt;type <span class="hljs-string"><span class="hljs-string">'int'</span></span>&gt; &gt;&gt;&gt; id(type(obj) ) <span class="hljs-number"><span class="hljs-number">136770080</span></span></code> </pre><br><br>  The third number (1) is the contents of the object itself. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj = <span class="hljs-number"><span class="hljs-number">1234567</span></span> &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLl'</span></span>, ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">12</span></span>)) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">136770080</span></span>, <span class="hljs-number"><span class="hljs-number">1234567</span></span>)</code> </pre><br>  Our guesses can be confirmed by looking into the CPython source code. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_HEAD <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ob_ival; } PyIntObject;</code> </pre><br>  Here, PyObject_HEAD is a macro common to all embedded objects, and ob_ival is a long value.  The PyObject_HEAD macro adds a count of the number of pointers to an object and a pointer to the parent type of the object ‚Äî just what we saw. <br><br><h5>  Float </h5><br>  A floating point number is very similar to int, but is represented in memory C by a double. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_HEAD <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ob_fval; } PyFloatObject;</code> </pre><br><br>  This is easily seen: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj = <span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt;&gt;&gt; sys.getsizeof(obj), obj.__sizeof__() (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLd'</span></span>, ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">16</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">136763968</span></span>, <span class="hljs-number"><span class="hljs-number">1.1</span></span>)</code> </pre><br><br><h5>  String (Str) </h5><br>  The string is represented as an array of characters ending in a zero byte.  Also in the structure of a separate line, its length is stored, a hash of its content and a flag that determines whether it is stored in the interned cache. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_VAR_HEAD <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ob_shash; #    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ob_sstate; #    ? <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ob_sval[<span class="hljs-number"><span class="hljs-number">1</span></span>]; #   +   } PyStringObject;</code> </pre><br>  The PyObject_VAR_HEAD macro includes PyObject_HEAD and adds a long ob_ival value that stores the length of the string. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj = <span class="hljs-string"><span class="hljs-string">'hello world'</span></span> &gt;&gt;&gt; sys.getsizeof(obj), obj.__sizeof__() (<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>) &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLLli'</span></span> + <span class="hljs-string"><span class="hljs-string">'c'</span></span> * (len(obj) + <span class="hljs-number"><span class="hljs-number">1</span></span>), ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">5</span></span> + len(obj) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">136790112</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">-1500746465</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'\x00'</span></span>)</code> </pre><br><br>  The fourth value corresponds to the hash of the string, which is not difficult to verify. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>hash(obj) <span class="hljs-number"><span class="hljs-number">-1500746465</span></span></code> </pre><br><br>  As you can see, the sstate value is 0, so the string is not cached right now.  Let's try to add it to the cache: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>intern(obj) <span class="hljs-string"><span class="hljs-string">'hello world'</span></span> &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLLli'</span></span> + <span class="hljs-string"><span class="hljs-string">'c'</span></span> * (len(obj) + <span class="hljs-number"><span class="hljs-number">1</span></span>), ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">5</span></span> + len(obj) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">136790112</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">-1500746465</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'h'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'\x00'</span></span>)</code> </pre> <br><br><h5>  Tuple </h5><br>  The tuple is represented as an array of pointers.  Since its use can lead to ring references, it is monitored by the garbage collector, which consumes additional memory (the sys.getsizeof () call reminds us of this) <br><br>  The tuple structure is similar to a string, only there are no special fields except length. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_VAR_HEAD PyObject *ob_item[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } PyTupleObject;</code> </pre><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>obj = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; sys.getsizeof(obj), obj.__sizeof__() (<span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>) &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'LLL'</span></span>+<span class="hljs-string"><span class="hljs-string">'L'</span></span>*len(obj), ctypes.string_at(id(obj), <span class="hljs-number"><span class="hljs-number">12</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*len(obj))) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">136532800</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">146763112</span></span>, <span class="hljs-number"><span class="hljs-number">146763100</span></span>, <span class="hljs-number"><span class="hljs-number">146763088</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> i, id(i) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">146763112</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">146763100</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">146763088</span></span></code> </pre><br>  As we see from the example, the last three elements of a tuple are pointers to its contents. <br><br>  The remaining basic data types (unicode, list, dict, set, frozenset) can be explored in the same way. <br><br><h4>  What is the result? </h4><br><table><tbody><tr><td>  Type of </td><td>  CPython name </td><td>  format </td><td>  Format, for nested objects </td><td>  32bit length </td><td>  64bit length </td><td>  Memory for GC * </td></tr><tr><td>  Int </td><td>  PyIntObject </td><td>  Lll </td><td></td><td>  12 </td><td>  24 </td><td></td></tr><tr><td>  float </td><td>  PyFloatObject </td><td>  Lld </td><td></td><td>  sixteen </td><td>  24 </td><td></td></tr><tr><td>  str </td><td>  PyStringObject </td><td>  LLLli + c * (length + 1) </td><td></td><td>  21 + length </td><td>  37 + length </td><td></td></tr><tr><td>  unicode </td><td>  PyUnicodeObject </td><td>  Llllll </td><td>  L * (length + 1) </td><td>  28 + 4 * length </td><td>  52 + 4 * length </td><td></td></tr><tr><td>  tuple </td><td>  PyTupleObject </td><td>  LLL + L * length </td><td></td><td>  12 + 4 * length </td><td>  24 + 8 * length </td><td>  there is </td></tr><tr><td>  list </td><td>  PyListObject </td><td>  L * 5 </td><td>  L * length </td><td>  20 + 4 * length </td><td>  40 + 8 * length </td><td>  there is </td></tr><tr><td>  Set / <br>  frozenset </td><td>  PySetObject </td><td>  L * 7 + (lL) * 8 + lL </td><td>  LL * length </td><td>  (&lt;= 5 items) 100 <br>  (&gt; 5 items) 100 + 8 * length </td><td>  (&lt;= 5 items) 200 <br>  (&gt; 5 items) 200 + 16 * length </td><td>  there is </td></tr><tr><td>  dict </td><td>  PyDictObject </td><td>  L * 7 + (lLL) * 8 </td><td>  lLL * length </td><td>  (&lt;= 5 items) 124 <br>  (&gt; 5 items) 124 + 12 * length </td><td>  (&lt;= 5 items) 248 <br>  (&gt; 5 items) 248 + 24 * length </td><td>  there is </td></tr></tbody></table>  * Adds 12 bytes on a 32 bit machine and 32 bytes on a 64 bit machine <br><br>  We see that simple data types in Python are two to three times more than their prototypes in C. The difference is due to the need to store the number of references to an object and a pointer to its type (the contents of the PyObject_HEAD macro).  This is partially compensated by internal caching, which allows you to reuse previously created objects (this is possible only for immutable types). <br><br>  For strings and tuples, the difference is not so significant - some constant value is added. <br><br>  And lists, dictionaries and sets, as a rule, take up more by 1/3 than necessary.  This is due to the implementation of the algorithm for adding new elements, which sacrifices memory in order to save processor time. <br><br>  So, we answer the question at the beginning of the article: to save 1 million integers we need 11.4 megabytes (12 * 10 ^ 6 bytes) for the numbers themselves and an additional 3.8 megabytes (12 + 4 + 4 * 10 ^ 6 bytes) for the tuple, which will keep links to them. <br><br>  UPD: Typos. <br>  UPD: In the subtitle "1 million integers", instead of "1 million prime numbers" </div><p>Source: <a href="https://habr.com/ru/post/193890/">https://habr.com/ru/post/193890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193878/index.html">Where dreams lead</a></li>
<li><a href="../193880/index.html">A passion for programming. Chapter 4. Be the worst</a></li>
<li><a href="../193882/index.html">Infection on the site - history by example</a></li>
<li><a href="../193886/index.html">The birth of magic from the spirit of the torrent protocol (scheme of the organization of a free uncensored indestructible information network)</a></li>
<li><a href="../193888/index.html">Writing a platformer in Python using pygame</a></li>
<li><a href="../193892/index.html">A car dial tachometer for a beginner or some fixed-point shamanism on the AVR</a></li>
<li><a href="../193894/index.html">Review of modern heuristic optimization methods</a></li>
<li><a href="../193898/index.html">Cut off the finger does not help unlock the iPhone 5S</a></li>
<li><a href="../193900/index.html">Making your flying robot</a></li>
<li><a href="../193902/index.html">QA Test Assignment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>