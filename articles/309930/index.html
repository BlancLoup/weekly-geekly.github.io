<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arguments for function tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will talk about writing good code and the problems that we face. Understandable, declarative, composable, and testable ‚Äî these term...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arguments for function tree</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article we will talk about writing good code and the problems that we face.  Understandable, declarative, composable, and testable ‚Äî these terms are used when it comes to writing good code.  Solving problems is often called pure functions.  But writing web applications is mainly related to side effects and complex asynchronous workflows, concepts that are not inherently clean.  The following describes an approach that allows you to cover work with side effects and complex asynchronous flows, while retaining the benefits of pure functions. </p><br><h2 id="napisanie-horoshego-koda">  Good code writing </h2><br><p>  <strong>Pure functions</strong> - the holy grail of writing good code.  A pure function is a function that, with the same arguments, always returns the same values ‚Äã‚Äãand has no visible side effects. </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">numA, numB</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> numA + numB }</code> </pre> <br><p>  A useful feature of pure functions is that they are easy to test. </p><br><pre> <code class="javascript hljs">test.equals(add(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><p>  Composability is also their strength. </p><br><pre> <code class="javascript hljs">test.equals(multiply(add(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br><p>  In addition, they are very easy to use declaratively. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> totalPoints = users .map(takePoints) .reduce(sum, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  But let's take a look at your application.  What part of it can really be expressed by pure functions?  How often is it about converting values ‚Äã‚Äãthat traditionally perform pure functions?  I can assume that most of your code works with side effects.  You perform network requests, DOM manipulations, use web-sites, local storage, change the state of the application, and so on.  This all describes the development of the application, at least on the Internet. <a name="habracut"></a></p><br><h2 id="pobochnye-effekty">  Side effects </h2><br><p>  As a rule, we are talking about side effects, in this case: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">users</span></span>: response.data})) }</code> </pre> <br><p>  The <code>getUsers</code> function points to something "outside itself" - <code>axios</code> .  The return value does not always match, as this is the server response.  However, we can still use this function declaratively and put it together in many different chains: </p><br><pre> <code class="javascript hljs">doSomething() .then(getUsers) .then(doSomethingElse)</code> </pre> <br><p>  But testing will be difficult for us, since <em>axios</em> is out of our control.  Rewrite the function so that it <code>axios</code> as an argument: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">axios</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">users</span></span>: response.data})) }</code> </pre> <br><p>  Now it is easy to test: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [<span class="hljs-string"><span class="hljs-string">'userA'</span></span>, <span class="hljs-string"><span class="hljs-string">'userB'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axiosMock = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({<span class="hljs-attr"><span class="hljs-attr">data</span></span>: users}) getUsers(axiosMock).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { assert.deepEqual(result, {<span class="hljs-attr"><span class="hljs-attr">users</span></span>: users}) })</code> </pre> <br><p>  But we will have problems linking the function to different chains, since <em>axios</em> must be explicitly passed to the input. </p><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//   axios .then(getUsers) //    .then(doSomethingElse)</span></span></code> </pre> <br><p>  Functions that work with side effects are actually problematic. </p><br><p>  A popular tip in projects like <a href="http://elm-lang.org/">Elm</a> , <a href="http://cycle.js.org/">Cycle</a> , and implementations in <a href="https://github.com/redux-loop/redux-loop">redux (redux-loop)</a> : "slide side effects to the edge of your application."  This basically means that the business logic of your application is kept clean.  Whenever you need to produce a side effect, you must separate it.  The problem with this approach is probably that it does not help improve readability.  You cannot express a holistically complex workflow.  Your application will have several unrelated cycles that hide the relationship of one side effect, which may cause another side effect, and so on.  It does not matter for simple applications, because you rarely deal with more than one additional cycle.  But in large applications, in the end, you will encounter a large number of cycles, and it will be difficult to understand how they relate to each other. <br>  Let me explain this in more detail with examples. </p><br><h2 id="tipichnyy-potok-prilozheniya">  Typical application flow </h2><br><p>  Let's say you have an application.  When it gets started, you want to get user data to check if the user is logged in or not.  Then you want to get a list of tasks.  They are associated with other users.  Therefore, based on the received list of tasks, you need to dynamically obtain information about these users too.  What are we going to do to describe this workflow in a clear, declarative, composable, and testable form? </p><br><p>  Consider a simple implementation using <a href="https://github.com/reactjs/redux">redux</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: AUTHENTICATING }) axios.get(<span class="hljs-string"><span class="hljs-string">'/user'</span></span>) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: AUTHENTICATION_SUCCESS, <span class="hljs-attr"><span class="hljs-attr">user</span></span>: response.data }) dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ASSIGNMENTS_LOADING }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'/assignments'</span></span>) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ASSIGNMENTS_LOADED_SUCCESS, <span class="hljs-attr"><span class="hljs-attr">assignments</span></span>: response.data }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> missingUsers = response.data.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentMissingUsers, assignment</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!getState().users[assigment.userId]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentMissingUsers.concat(assignment.userId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentMissingUsers }, []) dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: USERS_LOADING, <span class="hljs-attr"><span class="hljs-attr">users</span></span>: users }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( missingUsers.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userId</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'/users/'</span></span> + userId) }) ) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">responses</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = responses.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.data) dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: USERS_LOADED, <span class="hljs-attr"><span class="hljs-attr">users</span></span>: users }) }) }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ASSIGNMENTS_LOADED_ERROR, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: error.response.data }) }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: AUTHENTICATION_ERROR }) } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: LOAD_DATA_ERROR }) }) } }</code> </pre> <br><p>  Everything is just wrong here.  This code is incomprehensible, non-declarative, uncomplicated and not tested.  However, there is one advantage.  Everything that happens when the <strong>loadData</strong> function is <strong>called is</strong> defined as it is executed, orderly and in one file. </p><br><p>  If we separate the side effects "to the edge of the application", it will look more like a demonstration of some parts of the stream: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: AUTHENTICATING_LOAD_DATA }) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadDataAuthenticated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">axios</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'/user'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: AUTHENTICATION_SUCCESS, <span class="hljs-attr"><span class="hljs-attr">user</span></span>: response.data }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: AUTHENTICATION_ERROR }) } }) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAssignments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ type: ASSIGNMENTS_LOADING }</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">axios</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'/assignments'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">then</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ASSIGNMENTS_LOADED_SUCCESS, <span class="hljs-attr"><span class="hljs-attr">assignments</span></span>: response.data }) }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ASSIGNMENTS_LOADED_ERROR, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: error.response.data }) }) } }</code> </pre> <br><p>  Each part reads better than the previous example.  And they are easier to link into other chains.  However, fragmentation becomes a problem.  It is difficult to understand how these parts are related to each other, because you cannot see which functions lead to a call to another function.  Moving between files, we have to recreate in our head as sending (dispatch) one action (action) generates a side effect, which causes sending a new action, generating another side effect, which, in turn, again leads to sending a new action. </p><br><p>  By bringing side effects to the edge of your application, you really get the benefits.  But it also has a negative effect: it becomes harder to talk about flow.  About this, of course, it is possible and even necessary to argue.  I hope I was able to convey my point of view through the examples and arguments above. </p><br><h2 id="na-puti-k-deklarativnosti">  Towards declarativeness </h2><br><p>  Imagine that we can describe this stream as follows: </p><br><pre> <code class="javascript hljs">[ dispatch(AUTHENTICATING), authenticateUser, { <span class="hljs-attr"><span class="hljs-attr">error</span></span>: [ dispatch(AUTHENTICATED_ERROR) ], <span class="hljs-attr"><span class="hljs-attr">success</span></span>: [ dispatch(AUTHENTICATED_SUCCESS), dispatch(ASSIGNMENTS_LOADING), getAssignments, { <span class="hljs-attr"><span class="hljs-attr">error</span></span>: [ dispatch(ASSIGNMENTS_LOADED_ERROR) ], <span class="hljs-attr"><span class="hljs-attr">success</span></span>: [ dispatch(ASSIGNMENTS_LOADED_SUCCESS), dispatch(MISSING_USERS_LOADING), getMissingUsers, { <span class="hljs-attr"><span class="hljs-attr">error</span></span>: [ dispatch(MISSING_USERS_LOADED_ERROR) ], <span class="hljs-attr"><span class="hljs-attr">success</span></span>: [ dispatch(MISSING_USERS_LOADED_SUCCESS) ] } ] } ] } ]</code> </pre> <br><p>  Please note that this is a valid code, which we will now examine in more detail.  And also, that we do not use any magic API here, it‚Äôs just arrays, objects and functions.  But most importantly, we took full advantage of the declarative form of writing code to create a consistent and readable description of a complex application flow. </p><br><h2 id="function-tree">  Function tree </h2><br><p>  We have just defined (declared) the function tree.  As I mentioned, we did not use any special APIs to define it.  These are just functions <strong>defined</strong> in the tree ..., in the function tree.  Any of the functions used here, as well as function factories (dispatch) can be reused in any other tree definition.  This shows the simplicity of the <strong>composition</strong> .  Not only each function can be in other trees.  You can include whole trees in other trees, which makes them particularly interesting in terms of composition. </p><br><pre> <code class="javascript hljs">[ dispatch(AUTHENTICATING), authenticateUser, { <span class="hljs-attr"><span class="hljs-attr">error</span></span>: [ dispatch(AUTHENTICATED_ERROR) ], <span class="hljs-attr"><span class="hljs-attr">success</span></span>: [ dispatch(AUTHENTICATED_SUCCESS), ...getAssignments ] } ]</code> </pre> <br><p>  In this example, we created a new tree, <em>getAssignments</em> , which is also an array.  We can compose one tree into another using the spread operator. </p><br><p>  Let's take a look at how function trees work before moving on to <strong>testability</strong> .  Let's run it! </p><br><h2 id="vypolnenie-dereva-funkciy">  Execution of the function tree </h2><br><p>  A compressed example of how to run a function tree is as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FunctionTree <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execute = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionTree() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} execute([ foo ])</code> </pre> <br><p>  The created instance of FunctionTree is a function that allows you to execute trees.  In the example above, the function <strong>foo</strong> will be executed.  If we add more functions, they will be executed in order: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } function bar() { //   } execute([ foo, bar ])</span></span></code> </pre> <br><h3 id="asinhronnost">  Asynchrony </h3><br><p>  <code>function-tree</code> can work with promises (promises).  When a function returns a promise, or you define a function as asynchronous, using the <code>async</code> , the execute function will wait until the promise is fulfilled (resolve) or rejected before moving on. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    1  } execute([ foo, bar ])</span></span></code> </pre> <br><p>  Often, asynchronous code has more varied results.  We examine the <strong>context</strong> of the function tree in order to understand how these results can be defined declaratively. </p><br><h3 id="kontekst">  Context </h3><br><p>  All functions performed using <code>function-tree</code> take one argument.  <strong>context</strong> is the only argument with which functions defined in the tree should work.  By default, the context has two properties: <strong>input</strong> and <strong>path</strong> . </p><br><p>  The input property contains the payload (load), transmitted at the start of the tree. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     function foo({input}) { input.foo // "bar" } execute([ foo ], { foo: 'bar' })</span></span></code> </pre> <br><p>  When a function wants to transfer a new payload down the tree, it will need to return an object that will be merged with the current payload. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{input}</span></span></span><span class="hljs-function">) </span></span>{ input.foo <span class="hljs-comment"><span class="hljs-comment">// "bar" return { foo2: 'bar2' } } function bar({input}) { input.foo // "bar" input.foo2 // "bar2" } execute([ foo, bar ], { foo: 'bar' })</span></span></code> </pre> <br><p>  It does not matter whether a synchronous function or asynchronous, you just have to return the object or the fulfilled promise with the object. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  function foo() { return { foo: 'bar' } } //  function foo() { return new Promise(resolve =&gt; { resolve({ foo: 'bar' }) }) }</span></span></code> </pre> <br><p>  Let us turn to the study of the mechanism for choosing the paths for implementation. </p><br><h3 id="puti">  Paths </h3><br><p>  The result returned from the function can determine the further execution path in the tree.  Thanks to static analysis, the <strong>path</strong> property of the context already knows which paths can be continued.  This means that only execution paths that are defined in the tree are available. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{path}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.pathA() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } execute([ foo, { pathA: [ bar ], pathB: [] } ])</span></span></code> </pre> <br><p>  You can pass the payload by passing the object to the path method. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{path}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.pathA({<span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{input}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input.foo) <span class="hljs-comment"><span class="hljs-comment">// 'foo' } execute([ foo, { pathA: [ bar ], pathB: [] } ])</span></span></code> </pre> <br><p>  What is the good mechanism of the ways?  First of all, it is declarative.  There are no <strong>if</strong> or <strong>switch</strong> expressions.  This improves readability. </p><br><p>  More importantly, paths do not deal with throwing errors.  Often flows are thought of as: "do it or drop everything if an error occurs."  But not the case with web applications.  There are many reasons why you decide to go down the various execution paths.  The solution may be based on the user's role, the server response returned, some state of the application, the value transferred, and so on.  The fact is that the <code>function-tree</code> does not catch errors, does not make mistakes, and similar techniques.  It simply performs the functions and allows them to return the paths where the execution should diverge. </p><br><p>  There are a few small hidden features.  For example, you can define a function tree without implementing anything.  This means that all possible execution paths are defined in advance.  It makes you think about which cases need to be handled.  And it greatly reduces the likelihood that you will ignore or forget about scenarios that may occur. </p><br><h3 id="provaydery">  Providers </h3><br><p>  You cannot build a complex application on <strong>input</strong> and <strong>path</strong> alone.  Therefore, the <code>function-tree</code> built on the concept of <strong>providers</strong> .  In fact, <code>input</code> and <code>path</code> also providers.  The set of <code>function-tree</code> comes with several ready-made ones.  And of course you can create them yourself.  Suppose you want to use Redux: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FunctionTree <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReduxProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/providers/Redux'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execute = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionTree([ ReduxProvider(store) ]) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> execute</code> </pre> <br><p>  Now you have access to the <strong>dispatch</strong> and <strong>getState methods</strong> in your functions: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{dispatch, getState}</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: SOME_CONSTANT }) getState() <span class="hljs-comment"><span class="hljs-comment">// {} }</span></span></code> </pre> <br><p>  You can add any other tools using <strong>ContextProvider</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FunctionTree <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReduxProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/providers/Redux'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ContextProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/providers/Context'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execute = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionTree([ ReduxProvider(store), ContextProvider({ axios }) ]) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> execute</code> </pre> <br><p>  You will most likely want to use <strong>DebuggerProvider</strong> .  In conjunction with the extension for Google Chrome, you can debug your current work.  Add a debugger provider to the example above: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FunctionTree <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DebuggerProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/providers/Debugger'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReduxProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/providers/Redux'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ContextProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/providers/Context'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> axios <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'axios'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execute = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionTree([ DebuggerProvider(), ReduxProvider(store), ContextProvider({ axios }) ]) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> execute</code> </pre> <br><p>  This allows you to see everything that happens when you run these trees in your application.  The debugger provider will automatically wrap up and track everything that you put in context: </p><br><p><img src="https://habrastorage.org/files/3a5/a55/9aa/3a5a559aa9694298935663e73f6710d9.png" alt="Chrome extension debugger"></p><br><p>  If you decide to use <code>function-tree</code> on the server side, you can connect <strong>NodeDebuggerProvider</strong> : </p><br><p><img src="https://habrastorage.org/files/a7f/2ff/0fb/a7f2ff0fb7284ef3b3d03e05c464f48c.png" alt="Node debugger"></p><br><h2 id="testiruemost">  Testability </h2><br><p>  But, most likely the most important thing is the ability to check the function tree.  As it turns out, it is very easy to do.  To test individual functions in the tree, simply call them with a specially prepared context.  Consider testing the function that creates a side effect: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{window, input}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.app.data = input.result }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = { <span class="hljs-attr"><span class="hljs-attr">input</span></span>: {<span class="hljs-attr"><span class="hljs-attr">result</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>}, <span class="hljs-attr"><span class="hljs-attr">window</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: {}} } setData(context) test.deepEqual(context.window, {<span class="hljs-attr"><span class="hljs-attr">app</span></span>: {<span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>}})</code> </pre> <br><h3 id="testirovanie-asinhronnyh-funkciy">  Asynchronous Function Testing </h3><br><p>  Many testing libraries allow you to create stubs for global dependencies.  But there is no reason to do this for <code>function-tree</code> , because functions use only what is available through the context argument.  For example, the following function, using <a href="https://github.com/mzabriskie/axios">axios</a> to get data, can be tested as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{axios, path}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'/data'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> path.success({<span class="hljs-attr"><span class="hljs-attr">data</span></span>: response.data})) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> path.error({<span class="hljs-attr"><span class="hljs-attr">error</span></span>: error.response.data})) }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = { <span class="hljs-attr"><span class="hljs-attr">axios</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: {<span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>} }) } } getData(context) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { test.equal(result.path, <span class="hljs-string"><span class="hljs-string">'success'</span></span>) test.deepEqual(result.payload, {<span class="hljs-attr"><span class="hljs-attr">data</span></span>: {<span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>}}) })</code> </pre> <br><h3 id="testirovanie-vsego-dereva">  Testing the whole tree </h3><br><p>  Here it gets even more interesting.  We can test the whole tree in the same way as we tested the functions separately. </p><br><p>  Let's imagine a simple tree: </p><br><pre> <code class="javascript hljs">[ getData, { <span class="hljs-attr"><span class="hljs-attr">success</span></span>: [ setData ], <span class="hljs-attr"><span class="hljs-attr">error</span></span>: [ setError ] } ]</code> </pre> <br><p>  These functions use <code>axios</code> to get data, and then store them in a property of the <code>window</code> object.  We will test the tree by creating a new execution function with stubs for passing to context.  Then we run the tree and check the changes after the end of execution. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FunctionTree = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'function-tree'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ContextProvider = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'function-tree/providers/Context'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadData = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/trees/loadData'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = { <span class="hljs-attr"><span class="hljs-attr">window</span></span>: {<span class="hljs-attr"><span class="hljs-attr">app</span></span>: {}}, <span class="hljs-attr"><span class="hljs-attr">axios</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({<span class="hljs-attr"><span class="hljs-attr">data</span></span>: {<span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>}}) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execute = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionTree([ ContextProvider(context) ]) execute(loadData, () =&gt; { test.deepEquals(context.window, {<span class="hljs-attr"><span class="hljs-attr">app</span></span>: {<span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>}}) })</code> </pre> <br><p>  It does not matter which libraries you use.  You can easily test function trees while you are placing libraries in the context of a tree. </p><br><h2 id="fabriki">  Factories </h2><br><p>  Since the tree is functional, you can create factories that will speed up your development.  You have already seen the use of the <strong>dispatch</strong> factory in the Redux example.  She was declared as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{input, dispatch}</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ type, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: input }) } <span class="hljs-comment"><span class="hljs-comment">//  `displayName`   , //    . dispatchFunction.displayName = `dispatch - ${type}` return dispatchFunction } export default dispatchFactory</span></span></code> </pre> <br><p>  Create factories for your application to avoid creating specific functions for everything.  Suppose you decide to use <a href="https://github.com/Yomguithereal/baobab">baobab</a> , a single state tree, to store the state of your application. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{baobab}</span></span></span><span class="hljs-function">) </span></span>{ baobab.set(path.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>), value) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> set</code> </pre> <br><p>  This factory will allow you to express state changes right in the tree: </p><br><pre> <code class="javascript hljs">[ set(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>), set(<span class="hljs-string"><span class="hljs-string">'admin.isLoading'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ]</code> </pre> <br><p>  You can use factories to build your application's own <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">DSL</a> .  Some factories are so generalized that we decided to make them part of the <code>function-tree</code> . </p><br><h3 id="debounce"> <code>debounce</code> </h3> <br><p>  The <code>debounce</code> factory allows you to keep running for a specified time.  If new performances of the same tree are triggered, the existing one will go along the path <em>discarded</em> .  If during the specified time there are no new positives, the latter will follow the path <em>accepted</em> .  Typically, this approach is used when searching as you type. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> debounce <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'function-tree/factories/debounce'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ updateSearchQuery, debounce(<span class="hljs-number"><span class="hljs-number">500</span></span>), { <span class="hljs-attr"><span class="hljs-attr">accepted</span></span>: [ getData, { <span class="hljs-attr"><span class="hljs-attr">success</span></span>: [ setData, ], <span class="hljs-attr"><span class="hljs-attr">error</span></span>: [ setError ] } ], <span class="hljs-attr"><span class="hljs-attr">discarded</span></span>: [] } ]</code> </pre> <br><h2 id="v-chyom-otlichie-ot-rxjs-i-cepochek-obeschaniy">  What is the difference from Rxjs and promise chains? </h2><br><p>  Both Rxjs and Promises control the execution control.  But none of them has a declarative conditional definition of the ways of execution.  You will have to push threads, write <em>if</em> and <em>switch</em> expressions, or throw errors.  In the examples above, we were able to separate the execution paths of <code>success</code> and <code>error</code> as declaratively as our functions.  This improves readability.  But these paths can be absolutely any.  For example: </p><br><pre> <code class="hljs pgsql">[ withUserRole, { <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: [], <span class="hljs-keyword"><span class="hljs-keyword">superuser</span></span>: [], <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: [] } ]</code> </pre> <br><p>  Paths have nothing to do with error handling.  <code>function-tree</code> allows you to choose a path at any step of execution, unlike promises and Rxjs, where throwing errors is the only way to stop executing the current path. </p><br><p>  Rxjs and promises are based on value conversion.  This means that the next function is only available values ‚Äã‚Äãtransmitted as a result of the previous one.  This works great when you really need to convert values.  But the events in your application are not the case.  They work with side effects and go through one or many ways of performing.  This is the main difference <code>function-tree</code> . </p><br><h2 id="gde-mozhno-primenyat">  Where can I apply? </h2><br><p>  <strong>A function tree</strong> can help if you create an application that works with side effects in complex asynchronous chains.  The advantages of the "forced" splitting of your application logic into "lego" blocks and their testability can be quite weighty reasons.  This basically allows you to write more readable and supported code. </p><br><p>  The project is available in the <a href="https://github.com/cerebral/function-tree">repository on Github</a> , and the debugger extension for Google Chrome can be found in the <a href="https://chrome.google.com/webstore/detail/function-tree-debugger/ppfbmcnapdgakfiocieggdgbhmlalgjp">Chrome Web Store</a> .  Be sure to look at the sample application <a href="https://github.com/cerebral/function-tree/tree/master/referenceApp">in the repository</a> . </p><br><p>  The primary source of the <code>function-tree</code> project can be considered <a href="http://www.cerebraljs.com/">cerebral</a> .  You can consider the implementation of <a href="http://www.cerebraljs.com/documentation/signals">signals</a> in Cerebral an abstraction with your own representation over <code>function-tree</code> .  Currently, Cerebral uses its own implementation, but in Cerebral 2.0, the <code>function-tree</code> will be used as the basis for the signal factory.  I thank Alexey <a href="https://habrahabr.ru/users/guria/" class="user_link">Guria</a> for processing and honing the ideas of Cerebral signals, which led to the creation of an independent and common approach. </p><br><p>  Tell us what you think about this approach in the comments below.  Share if you have links to other patterns and methods for solving the problems discussed in this article.  Thanks for reading! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/309930/">https://habr.com/ru/post/309930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309914/index.html">The history of programming languages: how Fortran allowed users to communicate with the computer on "you"</a></li>
<li><a href="../309918/index.html">How to stop being afraid and fall in love with mbed [Part 2]</a></li>
<li><a href="../309920/index.html">Fax in the City (T.38)</a></li>
<li><a href="../309922/index.html">Writing Hello World on FASM</a></li>
<li><a href="../309928/index.html">Customize Windows Store for Business</a></li>
<li><a href="../309934/index.html">How to get a lot of server for little money: options for the earth and the cloud</a></li>
<li><a href="../309936/index.html">Overview of Node.js packages for parsing command line options</a></li>
<li><a href="../309938/index.html">We get rid of binary dependencies with composite assembly in Gradle 3.1</a></li>
<li><a href="../309940/index.html">Azure Active Directory now in the new ARM portal</a></li>
<li><a href="../309942/index.html">Presenter Template in Laravel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>