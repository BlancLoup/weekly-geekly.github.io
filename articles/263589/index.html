<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Small, and not so, reflections on SOA, or life in the MVC-beyond world (part 0)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone, my name is Yura. 
 Today I would like to share with you my experience and ideas in the field of software design and development, dispe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Small, and not so, reflections on SOA, or life in the MVC-beyond world (part 0)</h1><div class="post__text post__text-html js-mediator-article">  Hello everyone, my name is Yura. <br>  Today I would like to share with you my experience and ideas in the field of software design and development, dispel some prejudices and shed light on the current state of SOA solutions in our, not quite " <i>reactive</i> ", world.  How to write less code, get less unhappy customers, gray hair, and more profit.  Implement fully reusable solutions without side effects, and why so far nobody has done this ‚äô.‚òâ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b2b/335/689/b2b335689af844b69d60e41ff4ffb305.png"></div><br><br><br><a name="habracut"></a><br>  (‡∏á Ô∏° '-' Ô∏†) ‡∏á And so, Greetings.  Thank you for deciding to give me a little free time, <i>and not much</i> . <br>  I will try to present everything briefly and clearly, although I usually get the last sucks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Estimated content</b> <div class="spoiler_text"><pre>   0 Introduction<font></font>
<font></font>
 0.1 What is a Service Oriented Architecture?<font></font>
<font></font>
 0.2 What are the advantages and disadvantages of existing solutions?<font></font>
<font></font>
 0.3 What are the requirements of the current market?<font></font>
<font></font>
 0.4 Why has nobody done this yet?<font></font>
<font></font>
   1 Service<font></font>
<font></font>
 1.1 Domains and relational model<font></font>
<font></font>
 1.2 Solving the problem of consensus<font></font>
<font></font>
 1.3 Scaling and sharding<font></font>
<font></font>
 1.4 Fault tolerance<font></font>
<font></font>
 1.5 Logging and monitoring<font></font>
<font></font>
 1.6 Search and registration<font></font>
<font></font>
 1.7 AAA<font></font>
<font></font>
   2 Submission<font></font>
<font></font>
 2.1 Hypermedia types and scaffolding<font></font>
<font></font>
 2.2 CQRS-ES all the things<font></font>
<font></font>
 2.3 Templates<font></font>
<font></font>
 2.4 Protocols and gateways<font></font>
<font></font>
 2.5 Counters, reports and statistics<font></font>
<font></font>
   3. Support <font></font>
<font></font>
 3.1 Documentation<font></font>
<font></font>
 3.2 Backward Compatibility<font></font>
<font></font>
 3.3 Migrations<font></font>
<font></font>
 3.4 Correctness<font></font>
<font></font>
 3.5 Solution Life Cycle
</pre></div></div><br><h2>  Introduction </h2><br>  A couple of years ago, I ran into the problem of lack of tools for implementing backend and front-end solutions (web, desktop, mobile).  Since that time a lot of liquid has flowed under the bridge, I got acquainted with a large number of existing approaches and I had ideas how to do everything a little better than it is now.  After examining the current market position, I realized that existing solutions do not specifically give full control over applications and are either empty-cases, which in themselves are only a small part of the entire project architecture;  their goal is to maintain customer interest and expert audience, which has a positive effect on the cost of the office, or a support drug - multilayered horror with various mutants of <a href="https://en.wikipedia.org/wiki/OASIS_(organization)">OASIS</a> 'a specifications, where support and training of personnel should be robust.  The most prominent example of the latter is the <a href="http://wso2.com/">WSO2</a> stack.  I consider it the most complete <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">SOA</a> solution on the market, albeit monstrous, curved and very redundant.  Such things are difficult to compare Agile methodologies, since they all revolve around papers and business processes, and not around the needs of living people (the first paragraph of the <a href="http://agilemanifesto.org/iso/ru/">Agile manifesto</a> ).  In these articles, I want to share my vision of designing SOA, how to adapt it to the requirements of modern markets and RAD, to describe the main advantages of such approaches. <br><br>  It is now very fashionable to discuss various reactive trends - that the systems should be: <br><ul><li>  Responsive </li><li>  Fault tolerant </li><li>  Scalable </li><li>  Managed streams of events (messages) </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/00d/27d/be3/00d27dbe306b4798a7d49ba79a91cac8.png"></div><br>  The picture is <s>stolen</s> from the <a href="http://www.reactivemanifesto.org/">reactive manifest</a> .  There, Elastic and Resilient, probably because Scalable and Fault tolerant are concepts that are too popular and do not already represent such marketing value as in the days of MongoDB.  Especially brightly it all appears in the context of the so-called "functional reactive programming" (FRP). <br><br>  In practice, it turns out that all of this is a solid marketing murmur to attract the attention of investors, and, in general, most of the solutions do not represent any practical value, since developers must implement all this ‚Äúreactivity‚Äù on their own, without any ready-made solutions or developments according to existing requirements.  Even a full <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB_AAA">AAA is</a> nowhere to be found. <br><br>  Another thing is <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">SOA</a> - there it should all work right from the box, but no matter how. <br>  It turns out that each vendor has its own SOA with chess and poetess, and they are not friends with each other, although everything is fine with OpenSource solutions, more on this later.  All this quickly becomes obsolete, somehow new communities are not formed at all, and projects are developed only by the efforts of their owners.  If this is SOA, and any service can be used at least 100,500 times in a whole bundle of projects, then why do we still not have a standardized repository of reusable services and <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">domains</a> ?  The owners of existing solutions are simply not interested in this - after all, they need to suck out the money from support. <br><br>  Especially fun discussing the last year microservices.  I think this is a pretty stupid name, and they are not at all ‚Äúmicro‚Äù, as they imply deep encapsulation of several protocols.  For this, run ‚Äúmicroservices‚Äù within a single server, or virtual machines, only increase delays and scale vacuum.  In general, in classic SOA, it makes no difference whether the service is part of a single system process, or it should be launched as a separate set of processes with its queues and protocols on different machines - all this is just a matter of registering the service and its dependencies.  So I consider ‚Äúmicroservices‚Äù, too, to be nothing more than a marketing ploy - an attempt to ‚Äúrethink‚Äù obvious old ideas, in order to extract more money. <br><br>  ‚ÄúOk, what's wrong with MVC?‚Äù - you will probably think ... but nothing, it exists, it is for simple graphical interfaces, without frills, and in inept hands even the banal CRUD is a ton of save-paste.  MVC poorly controls the subject area, encourages state storage and code duplication, it badly separates the responsibilities of logic (segregation of commands and requests), denormalizes the model.  Bicycles are another matter: <a href="http://pmjones.io/adr/">ADR</a> , any <a href="http://www.cs.sjsu.edu/~pearce/modules/patterns/enterprise/ecb/ecb.htm">ECB</a> , <a href="http://www.whitewashing.de/2012/08/13/oop_business_applications_entity_boundary_interactor.html">EBI</a> with <a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a> and other variations on <a href="http://fideloper.com/hexagonal-architecture">Hexagonal Architecture</a> - they are an attempt to rework MVC, of ‚Äã‚Äãcourse, not without their individual flaws and, of course, not everyone has enough experience and skills to implement such things, but they solved quite a lot of problems inherent in MVC.  All this has been created, for the most part, over the past 3 years by PHP adherents and, respectively, one way or another, the features of this platform are reflected.  Not that I really disliked PHP, but modern variations, combined with Python and Ruby, do not fully meet the demands of modern markets. <br><br>  I understand that I can hurt the feelings of adherents of the cult of the ‚Äú <a href="https://sourcemaking.com/antipatterns/golden-hammer">Golden Hammer,</a> ‚Äù but then it will be clear why everything is not so optimistic at all, and I will show what I have invented on this subject. <br><br>  And then there is <a href="https://facebook.github.io/flux/">Flux</a> , but this is also another marketing trick. <br>  Flux in the common people is nothing more than the more complex abbreviation <abbr title="Command-Query Responsibility Segregation with Event Sourcing">CQRS-ES</abbr> , because Facebook wanted to simplify it so that it would be possible to attract attention and produce <s>hamsters of</s> fans, to develop rather mediocre communities, and this is nothing more than PR.  The goal of Facebook is not to provide a quality tool for the implementation of your projects, but to convey the idea to the user community so that they can make as many crutches as possible on GitHub. <br><br>  It is the <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> - <a href="http://martinfowler.com/eaaDev/EventSourcing.html">ES</a> patterns that is the basis of all ‚Äúreactivities‚Äù and is best suited for the implementation of ‚Äúreactive‚Äù applications, but in its pure form it is useless.  I believe that the problems of use and the benefits of CQRS-ES are most well revealed in the context of SOA design. <br><br>  The main problem of modern SOA, and indeed of all existing architectures, is a rather poor abstraction of the domain and the definition of a domain model.  I will consider this question from the point of view of synchronized discrete <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">FSM</a> finite automata and show you to define domains as accurately as possible (without redundancy), taking into account modern requirements for applications. <br><br>  As Evans said: <blockquote>  Difficulties are not there where all these frameworks, databases, queues, and other things from which engineers are so dragged, difficulties are always hidden in the description and modeling of the subject area - the creation of domains. </blockquote>  Not that I would like to turn your ideas about the architecture of applications so dramatically, but this is necessary in view of the fact that ~ 80% consist, a little more than completely, with crutches, with polished ivory, encrusted with diamonds, because the budget allows and ‚Äúwhy and no: we are paid money, and it works ‚Äî why learn something new? ‚Äù <br><div class="spoiler">  <b class="spoiler_title">Why do I feel this way?</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b57/531/5a8/b575315a8de444dfb47ebca46deb6e40.png"><br>  Killjoys S01E06 </div></div><br><h3>  ‚ÄúOk, I'm tired of reading, what is your idea?‚Äù </h3><br>  At the end, the life cycle of developing the backend and frontend should look like this: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/eee/ac9/993/eeeac999346143dcba4bb1932ed8ee53.png"></div><br><br>  It remains only to design (optional) and the implementation of the missing functionality, by adding their services and domains to the system. <br><br>  It‚Äôs as if you would have your own Pocket <a href="https://www.firebase.com/">Firebase</a> , which besides automatically inserting all edits and migrations into the database, would also do Scaffolding for your mobile, desktop and web applications: automatically generated all views, templates, validation and API clients with push notifications, and asynchronous UI. <br><br>  Due to the fact that most of any modern functionality is very stereotypical, there is no sense to rewrite everything from scratch from project to project.  We need a platform so that people can share their work and standardize quality control and interaction between them.  In this way, you can get a community of users who are implicitly motivated to improve the quality of products and the qualifications of its members, add gami cation with higher levels, achivka and comic stats ... well, you understand - there are some fantasies where to roam. <br><br>  When developing such a solution, it is necessary to prevent the occurrence of two problem situations - this is ‚Äúdevelopment by the committee‚Äù and ‚Äúdevelopment by specifications,‚Äù which actually led to a terrifying inflation of the J2EE stack. <br><br>  Now, almost no one is interested in automating the work of developers, although most of the code of existing applications can be generated automatically or abstracted by means of dynamic programming. <br><br>  Yes ... speaking very roughly and simplistic: according to the database scheme, you can immediately generate REST endpoints, an API client and templates for your front on your favorite Angular / React / Ember, etc.  Although I do not really digest the approaches of modern browser frameworks, more on that later.  It remains to register user groups and their rights, to stretch the existing design.  If you think this is a <a href="https://django-tastypie.readthedocs.org/en/latest/">mystery</a> - well, <a href="https://django-tastypie.readthedocs.org/en/latest/">Tastypie</a> already knows how to generate REST endpoints from the model, although there are not enough features and the performance is rather mediocre, even for Python, because of a bad design, but you can use it as an example. <br><br><h3>  What is Service Oriented Architecture? </h3><br>  <i>This is an idea</i> .  It consists in the fact that applications should consist of reusable interchangeable "black boxes" - services that communicate over standardized protocols and intfeses among themselves. <br><br>  There are several important conditions, services: <br><ul><li>  <i>Must be</i> run under any conditions and scale on demand. </li><li>  <i>Must</i> be orthogonal (loosely coupled) and fault tolerant </li><li>  <i>Must</i> Have Reusability </li><li>  <i>Should not</i> store states </li><li>  <i>Should</i> be as abstract as possible. </li><li>  <i>Must</i> be able to be used in several business processes at the same time, without side effects </li><li>  <i>Should</i> be able to dynamically register and implement on the fly </li></ul><br>  In principle, the first three conditions should be more or less clear.  Services do not depend on each other, do not share common resources, and can migrate between processes of both local and remote machines.  Can be reused and simultaneously used in several projects. <br><br>  As for the states, everything is simple: the server does not have to store data about the user session, this is done so that the request can be processed by any instance of the running service, which is usually the least loaded at any given time.  This is done by incorporating encrypted, salted session information into a user request.  In order not to transfer this payload with each request - they usually create a separate short-term registration service for user sessions that temporarily caches them.  Creating a global service for storing user sessions will lead to the appearance of a ‚Äúbottleneck‚Äù in which it will still be necessary to solve the problem of <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2581%25D0%25B5%25D0%25BD%25D1%2581%25D1%2583%25D1%2581">consensus,</a> which will have a <s>very</s> negative impact on the speed of processing requests. <br><br>  With abstractions, everything is rather tight - some domains or other (base scheme and logic) should be dynamically expandable depending on the specific needs of the dependent services and domains.  Suppose there is an Accounting service (Accounting) and various services are registered in it ‚Äî for some, only postpay is provided for billing, while others require prepayment.  Add here more different discount and savings systems and get a quality headache for many months, because the whole logic of the work of these components is constantly changing.  The <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">normalization of the relational model</a> plays an important role here - please note that there are <i><b>six</b></i> normal forms for a long time.  Good abstraction and detailed elaboration of the subject area makes it possible to reduce the complexity of introducing a new, or changing the existing logic, but this will be discussed in the next part. <br><br>  The possibility of separating access to services between several ‚Äúsubordinate‚Äù and ‚Äúmanagers‚Äù follows from the requirement for weak connectivity and the absence of shared states.  Everything is straightforward as with multi-threaded programming and methods of preventing the states of "race".  We should also mention the case of domain expansion: there is a compatibility problem when sharing an extended domain with several services.  In general, roughly speaking, when one service needs a label with one number of fields and states (well, there is an enumeration value), and another with a completely different one, and how to ‚Äúmake friends‚Äù of them so that there would be no problems when using this label together, or some other resource. <br><br>  There are many system ‚Äúroot‚Äù services that are responsible for the work of all the others, and for their behavior in case of errors.  One of them is the <i>Registrar</i> which allows you to register a <s>cap</s> and launch new instances of services, run implementation and correctness tests, roll back to previous versions in case of errors.  Just like in <a href="https://ru.wikipedia.org/wiki/Erlang">Erlang</a> 'e: 3 In general, SOA is in many ways very similar to the <a href="https://ru.wikipedia.org/wiki/Open_Telecom_Platform">OTP</a> model, although there is also a lot missing. <br><br>  I think on this note you can complete a review of the objectives and requirements of SOA. <br>  For the needs of something else to add. <br><br>  Here is a diagram of how I generally represent the structure of a service-oriented architecture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b02/792/bf2/b02792bf2ae44715b113dd294863935b.png"></div><br>  Let's look at the purpose of root services. <br><ul><li>  Registrar - as mentioned above, is engaged in registration and start / stop services.  It also stores addresses and descriptions of protocols for connection, checks the correct operation of services after updates, and can roll back to a previous working version automatically, without pausing work. </li><li>  The resource manager is one of the most important services, it coordinates the use of existing resources: the allocation of physical resources for the operation of services, and their monitoring for load distribution.  It can be implemented based on Provisioning and DevOps solutions such as <a href="https://www.openstack.org/">OpenStack</a> .  Resource managers are often referred to as <a href="https://en.wikipedia.org/wiki/Service-oriented_infrastructure">SOI</a> . </li><li>  Archivist - a service for logging events and collecting statistics, preparing reports. </li><li>  Courier - is engaged in the delivery and routing of messages. </li><li>  The warden - monitors the performance of all existing services, makes a restart on demand and blocking malicious users. </li><li>  AAA is 3 services responsible for <br><ul><li>  Authentication (Authentication) - confirmation of the user's identity. <br>  These are logins / passwords, biometrics, OAuth, sending SMS for login, etc. </li><li>  Authorization (Authorization) - the separation of user rights. <br>  These are usually different named groups for which different actions are available. </li><li>  Accounting (Accounting) - purchase / sale of various services through payment services, the history of flow accounts, discount and savings systems.  Often, methods are implemented to account for the various goods in storage areas, their reservation and availability. </li></ul></li></ul><br>  Each of these services has its own design features (software) and I will try to describe all the details in the following articles, I hope I will not miss anything. <br><br>  Any project should contain, at a minimum, the <i>Registrar</i> , the <i>Archivist</i> , the <i>Resource Manager</i> and the <i>AAA</i> , although you can certainly come up with better names.  The latter two are missing for a number of reasons related to the complexity of the implementation of expandable domains (hi <a href="https://tech.yandex.ru/cocaine/">cocaine</a> ). <br><br><h3>  What are the advantages and disadvantages of existing solutions? </h3><br>  Now there is no full-fledged SOA - everywhere somewhere something is missing. <br>  On the code generation of hypermedia types, history is generally silent. <br><br>  I worked with <br><ul><li>  <a href="https://tech.yandex.ru/cocaine/">Cocaine</a> </li><li>  <a href="http://www.ibm.com/cloud-computing/bluemix/">Bluemix</a> </li><li>  <a href="http://www.jboss.org/">Jboss</a> </li><li>  <a href="http://www.oracle.com/technetwork/middleware/soasuite/overview/index-101779.html">Oracle SOA suite</a> </li><li>  <a href="http://wso2.com/">WSO2</a> </li></ul><br>  Of course, in the case of the J2EE stack, there is terrifying redundancy and neither WSO nor JBoss are suitable for high loads.  And in general, ‚Äúweak binding‚Äù <a href="http://www.theserverside.com/feature/When-loose-coupling-and-SOA-style-software-laying-doesnt-make-sense%3Futm_medium%3DEM%26asrc%3DEM_NLN_45881393%26utm_campaign%3D20150731_Know%2520when%2520loose%2520coupling%2520and%2520SOA%2520style%2520software%2520layering%2520doesn%27t%2520make%2520sense_msargent%26utm_source%3DNLN%26track%3DNL-1806%26ad%3D902126%26src%3D902126">does not fit very well</a> with modern j2ee EJB puffs. <br><br>  Cocaine and Bluemix I, personally, attribute to SOA solutions only partially - there is no ready-made system for the implementation and standardization of the interaction of existing servers, complete DIY.  In the case of cocaine, there is a <a href="https://tech.yandex.ru/cocaine/doc/services_and_plugins/locator-docpage/">locator</a> , albeit rather rudimentary, but it‚Äôs good that at least something.  In bluemix, you can implement a good SOI, but you also need to play a bit.  From a SOI point of view, Amazon‚Äôs services are the most flexible solution. <br><br>  All vendors offer to deploy infrastructure only on their PaaS'ah, this is especially noticeable in the case of Oracle and its Integration Cloud Service.  It is necessary to understand that most users of SOA solutions need to have all the servers within the same data center, and communication delays are minimal - it is often necessary to organize CDNs and other distributed junk on my own, and an extra vendor lockin only links hands when choosing a data center.  Both Amazon and Azure have already fallen off - it is better for serious and responsible customers to do risk management themselves, and for ordinary people it‚Äôs enough to ‚Äústart up, work - go <s>drink some</s> rest and wait until it falls off, calls start at 4 am ...‚Äù, usually at 95% cases so it happens.  Yes, and cheaper to shoot a dozen bald dedikov with homemade SOI on the room digital ocean, linode, online.net or ovh and juggle them as needed. <br><br>  <a href="https://ru.wikipedia.org/wiki/BPEL">BPEL</a> / <a href="https://ru.wikipedia.org/wiki/BPMN">BPMN</a> is a separate topic: they tried to write a language for describing business processes for secretaries, but they got a many-sided, incomprehensible something that is not envisaged by the standard to implement without editing the language specification itself is almost impossible.  To do this, you need to contact OASIS, join the consortium, issue RFCs ... well, you understand that there is nothing in common with solving the tasks set, but only payment for the existence of many-sided monolithic standards that cannot be adapted to modern market requirements within an acceptable time frame.  Easier, much easier, to take and write everything with your hands ... in any favorite language.  The description of business processes can be very simplified if we consider it from the point of view of finite automata (FSM). <br><br>  The main advantage of the existing solutions is the guarantee from the vendors, which are sufficient for use in honey.  sector and partly in the foreign state.  and the automotive sector - there are no such stringent market requirements and there is no need to follow the ‚Äúlatest fashion trends‚Äù.  Consequently, for the implementation of new projects, or even, I will not be afraid of this word, <i>startups</i> - these solutions and platforms are not suitable. <br><br>  Also, old-kind SAP can be considered as a full-fledged SOA. <br>  But, given the support policy, cost, continuous obsolescence, poor performance, and a rather mediocre attitude to security ‚Äî I would not consider this solution at all. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/313/b39/827/313b39827df144cba25a1a223e905a45.png"></div><br><br><h3>  What are the requirements of the modern market? </h3><br>  Basically, they want to: <br><ul><li>  The application could withstand very large load jumps. </li><li>  Content was updated in real time and <i>used</i> on various devices. </li><li>  There was no need to bother with long-term support </li><li>  It was not necessary to often purchase new equipment </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25B1%25D1%2583%25D1%2581%25D0%25B0">BusFactor</a> was over 30% </li></ul><br>  In the case of SOA in this case is almost the ideal solution, and sooner or later, starting development with some popular MVC framework, adding various message queues and tasks, implementing interprocess communication, developers from their bikes roll into SOA with CQRS-ES ' ,         . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In practice, it turns out that there is no quality control at all, there is no evolutionary refactoring and the risk assessment is rather mediocre. </font><font style="vertical-align: inherit;">They do "just to work" and especially no one has any understanding in six months - problems are solved as they are received and, of course, this negatively affects the service itself and the developers themselves. </font><font style="vertical-align: inherit;">In this case, SOA is a dandy because delicious reusable ‚Äúblack cubes‚Äù allow you to forget about many sample tasks and focus on the business logic of the application, and most of the risk management goes directly to the developer community.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why has nobody done this yet? </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because it is difficult.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To drive into this all is not enough to just read a couple of books about DDD and Corporate Application Templates, you need to put it all into practice and fill a bunch of cones ... understand that not everything is ‚Äútrue‚Äù that they write in books, and even that ‚Äútruth‚Äù "In most existing OpenSource projects is not implemented and therefore can not be taken as the basis of their own.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key feature of any SOA is the presence of an IPC bus, a modularity system, and a discovery service (registrar). Symfony2 and Meteor.js are a good example of how things might look like - their modularity allows you to directly introduce new views and the domain model, plug-ins of other frameworks most often simply extend the functionality of the framework itself, add some scaffolding, but directly to the implementation and logic Your applications have no direct relationship. In principle, if you add a bus here on some thread Gearmand / Beanstalk / RabbitMQ etc you can even get some more or less SOA. Although, IMHO, AMQP is a wild overkill for the legs grow with OASIS, and redundancy is the worst. I really like protobuf's approaches, although its performance could be better.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App Data over Avian Carriers with Quality of Service</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I often saw people trying to implement XMPP as a transport protocol for their mobile applications, sometimes even BOSH was used for websites with an exclamation ‚Äúthis is ejabberd! Well this is erlang! Well this highold! It is not common for humans to measure the overhead of communication and serialization-deserialization of objects, although it so happens that this is about 20% of the entire time the application runs under load. Even a banal change of the network IP socket to a file UNIX socket can save quite a lot of processor time due to working off the IP stack, and since all the application traffic still passes through the OS firewall and other obscenities. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling / dev / null</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Often noticed enthusiastic posts like " </font></font><a href="http://www.iron.io/blog/2013/03/how-we-went-from-30-servers-to-2-go.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we switched from the rails to Go and greatly reduced the server park. ‚ÄùI liked the phrase‚Äú And we've never had another colossal clusterf ** k since. ‚ÄùYes, it is true: if you cannot load your equipment by 100% when processing requests - you scale the vacuum. The situation with C # / Java is actually not very different. The banal datemappers are nothing more than bytecode enhancing which additionally hides a few holes in abstractions in the form of multi-level caches and entity managers. If you rewrite everything with your hands many times faster, compare at least </font></font><a href="http://www.datanucleus.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataNucleus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and old-ext first </font></font><a href="http://hibernate.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hibernate</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Why this is happening - the topic of a separate article, but if there were good source code preprocessors, such as sishnyh ones, such crutches would not be needed, and you wouldn‚Äôt have to dig into byte code, bothering with compatibility. </font><font style="vertical-align: inherit;">I personally have so far focused on Rust'e - a good balance of security and performance, and there are not so many implicit obscurities in Go (I'm talking about interfaces and ‚Äúduck typing‚Äù). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are quite a few examples of indecency and unsuccessful attempts, but they crawled in the right direction, although they usually did not crawl.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ok, what do we do with our MV-something? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80% of the projects I had to deal with do not have a normal normalized relational model. </font><font style="vertical-align: inherit;">The first step is to normalize your modelku right up to the </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B5%25D1%2581%25D1%2582%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6th form</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and adopt readable rules for naming tablets and columns. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because it</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allow to speed up most queries. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prevents redundancy and reduces the size of your base. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplify support and documentation of your solution. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplify implementation of existing CRUD logic </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For complex and large queries, it is worth using materialized views - this will save a little time for the profiler. </font><font style="vertical-align: inherit;">Before you think about denormalizing a model, think about storing intermediate results in temporal representations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With a normalized database, you can issue such a router for your CRUDs:</font></font><br><pre><code class="php hljs">GET /plural($tableName) <span class="hljs-comment"><span class="hljs-comment">//     GET /plural($tableName)/page/$pageNumber //     GET /plural($tableName)/page/$pageNumber/size/$pageSize //       GET /plural($tableName)/where/$fieldName/$value //         GET /$tableName/$id //    $id GET /$tableName/$id/plural($referencedTableName) //         $id POST /$tableName/$id //    ID PUT /$tableName //    PUT /$tableName/$id/$referencedTableName/$referenced_id //      ManyToMany  DELETE /$tableName/$id //    $id DELETE /$tableName/$id/$referencedTableName/$referenced_id //      ManyToMany </span></span></code> </pre> <br>  In the case of folded keys, you can come up with something like $ id1_id2_id3 (at your discretion), and, for example, take the key columns in alphabetical order.  Of course, you will first need to read the database schema, and use it to validate the router, otherwise you will get a bunch of blind SQL injections. <br><br>  Well, test, test, profile, reduce test execution time, refactor and test again. <br><br>  By the same principle, the aforementioned TastyPie works. <br><br><h3>  Ok, and what about the JS frontend? </h3><br>  With JS frontend, I personally, for the time being, also do not understand what and where. <br>  On the one hand, we have quite a lot of all sorts of standards, preprocessors, postprocessors, on the other hand, they do not simplify development at all.  Most of the existing solutions require duplication and transfer of your templates to the browser, after which you still have to arrange EventSourcing with your hands, partially duplicate your model in JS and get rid of validation ... and nothing works ‚Äúfrom the box‚Äù. <br><br>  Often, watching the development of existing tools from the outside, I got the impression that the farther we go - the more difficult they become, and less and less they are aimed at solving our practical tasks.  At the same time, all existing frontend projects collect quite large investments, we are talking about tens of millions of U.Dmurdsk e., And try to attract and sharpen attention. <br><br>  I stayed on React.js with ‚Äúisomorphic‚Äù renderers in the node, even though I am already pretty nauseated by this.  The problem is that you need to render simultaneously on the server and on the client for a normal UX, in any case, and various webkit surrogates like <a href="https://prerender.io/">prerender.io</a> do not have any <a href="https://prerender.io/">reasonable</a> performance. <br><br>  I‚Äôm one of those who don‚Äôt really understand why I need to sculpt node.js where I‚Äôm not hitting, simply because modern JS frontends aren‚Äôt particularly rendered in other environments.  In principle, nothing prevents you from overtaking html in json - transfer templates and changes on pages on web sockets and longpolling and when clicking on links.  After that, apply a ‚Äúpatch‚Äù to the current DOM tree - then you will not have to bother with routing and models on the pages, and the rules for form validation can be described in terms of data- * attributes and regular expressions.  Immediately, there is no need for any VirtualDOMs, since all changes in collections and templates can be traced already on the server side and send rendered patches. <br><br>  Well, in general, you wrote your templates on the usual jinja / twig'ah and other ctpp, added one JS to the page and a specialized controller for collection management, that's all.  True, such a thing will work fully (with push notifications) only if there is an EventSourcing.  Thus, you don‚Äôt need to duplicate the model and view from the browser side, and this is a rather large piece of work.  I hope the idea is clear. <br><br>  You can transfer HTML pages from the template engine in the form of a similar JSON <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"append|remove|replace"</span></span>, <span class="hljs-string"><span class="hljs-string">"selector"</span></span>: <span class="hljs-string"><span class="hljs-string">"#HaveANiceDay"</span></span>, <span class="hljs-string"><span class="hljs-string">"tagName"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// optional "attrs": [ { "name": "value" }, "name", ], "content": { {"otherTagName": { ... }}, }, }, }</span></span></code> </pre><br>  I do not know of any existing tool for the JS-frontend, as part of modern MVC frameworks, that would perform browser templating and collection management in a similar way.  Although the management of collections and ES already exists in Meteor.js, but this is rather an exception, and Yandex had something similar somewhere ... <br><br><h4>  OK.  Quite so more than enough for the introduction. </h4><br>  I hope it was not too boring, I was able to tell something new, and push you to think. <br>  I wish you a pleasant time of day. <br><br>  If necessary, I will add something here, correct errors and clarify. <br>  Send all comments to the PM, do not litter the comments. </div><p>Source: <a href="https://habr.com/ru/post/263589/">https://habr.com/ru/post/263589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../26357/index.html">Articles in English.</a></li>
<li><a href="../263571/index.html">SoC: we write framebuffer implementation for controller in FPGA</a></li>
<li><a href="../263575/index.html">An example of solving a typical OOP problem in the Haskell language</a></li>
<li><a href="../263577/index.html">Competition of the user design from the Roketbank or how to order a bank card with the Habr logo</a></li>
<li><a href="../263581/index.html">Welcome to FPConf.ru</a></li>
<li><a href="../263591/index.html">Review and video of reports on information security from the conference SECR-2014</a></li>
<li><a href="../263595/index.html">When Chef and Puppet are not the solution. Part 1</a></li>
<li><a href="../263597/index.html">The finite element method on the example of the Poisson equation</a></li>
<li><a href="../263599/index.html">Convenient data serialization with Variadic Templates</a></li>
<li><a href="../2636/index.html">PalmOS renamed to GarnetOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>