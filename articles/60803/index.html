<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Push mi, boom boom, touch mi ... Ajax Push Engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about Comet and server push in general. 

 Regular web applications, like sites, work according to the traditional request-response...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Push mi, boom boom, touch mi ... Ajax Push Engine</h1><div class="post__text post__text-html js-mediator-article"><img align="left" title="logo" src="http://abrdev.com/wp-content/uploads/2009/05/logo.jpg" alt="logo" width="308" height="113">  Today we will talk about <a href="http://en.wikipedia.org/wiki/Comet_%2528programming%2529">Comet</a> and <a href="http://en.wikipedia.org/wiki/Push_technology">server push</a> in general. <br><br>  Regular web applications, like sites, work according to the traditional request-response-request model, while, due to the peculiarities of the HTTP protocol and some server implementations of handlers, the application does not store information between requests, so each call is independent, and the identification or sessionality is provided by higher-level tools (for example, the well-known implementation of sessions in PHP).  In addition, a request for a new information is always sent by a client who is interested in obtaining the most current version of the data.  In applications that are critical to updating, this often becomes a bottleneck.  In one of our previous projects, there were several periodic AJAX requests for updating data.  Although for such a case there are options and calling several handlers on the server side with a single request from the client. <a name="habracut"></a><br><br><div style="text-align:center;"><img title="ape-cross-browser1" src="http://abrdev.com/wp-content/uploads/2009/05/ape-cross-browser1.png" alt="ape-cross-browser1" width="500" height="130"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But there is another approach, when the server independently determines that there is new data (and he finds out about it the very first) and delivers it to the client program, which does not waste time on requests, but receives it itself when something new has appeared.  To do this, however, it is necessary to keep a constant connection to the server, for example, via a bidirectional socket.  And if in traditional software with this particular difficulty is not observed, that to implement long-standing connections for web applications is quite difficult.  In the most primitive way they do it through IFrame, however this is not the only possibility, and the developers of top libraries and plugins have tried to do so, so look in your favorite framework, the Comet implementation should be there (it definitely is in the Dojo Toolkit, there are jQuery plugins built-in feature in GWT).  You can also read about the various methods of implementation <a href="http://javascript.ru/ajax/server-push">in this set of materials</a> . <br><br>  But how to make a server?  The usual version of Apache + PHP is not very suitable, although, of course, it is possible on it, but the solution will be far from optimal and will not withstand the typical load.  By the way, about the load.  For Comet applications, the load is the number of clients that can be served at the same time, meaning the number of open connections with clients, and not data transfer.  And the number of such connections for ordinary servers should reach tens of thousands, typical figures - 20-50 thousand connections in parallel.  And here a bunch of Apache / PHP does not help.  Something else is needed. <br><br>  For the Java world, there are implementations for application servers, for example, Jetty (probably the most well-known and standard implementation of Comet, here is a <a href="http://www.ibm.com/developerworks/ru/library/j-jettydwr/index.html">good article in Russian</a> from IBM), a server framework based on <a href="https://grizzly.dev.java.net/">the Grizzle platform</a> , <a href="https://atmosphere.dev.java.net/">Atmosphere</a> , appeared not so long ago, so implement your own logic and Your server for a specific application is not difficult. <br><br>  What else to do?  I can recommend them <a href="http://www.ape-project.org/">open project APE or Ajax Push Engine</a> .  This is a small server written in C, which is compiled as a daemon and listens to its port, by default, 6969, but it can be configured to work together with Apache.  Unlike other solutions, APE is a specialized HTTP server that supports GET / POST requests, that is, you can connect to the server from any language and system, as long as HTTP requests are understood.  And this is a self-sufficient solution, in principle, it can be limited to APE alone, without additional servers (in Jetty, the implementation still requires an application server and a web server).  According to the developers, APE works well under load and can hold up to 100 thousand connections at the same time, in the future horizontal scaling will be added. <br><br><div style="text-align:center;"><img title="ape-how-it-works" src="http://abrdev.com/wp-content/uploads/2009/05/ape-how-it-works.png" alt="ape-how-it-works" width="500" height="137"></div><br><br>  It should be noted that by its architecture, the APE project consists of three parts: <br><ul><li>  <strong>The epoll-driven HTTP server</strong> is the very foundation, the server that handles connections and holds connections, allowing Server Push to be implemented in any way suitable for the client, be it <strong>XHR long-polling</strong> or via an iframe, and in the future, native browser capabilities will be utilized ( web sockets) </li><li>  <strong>The APE JavaScript Framework</strong> is an equally important part of the project, a MooTools-based client script that can integrate server capabilities into any AJAX client applications.  It also implements a modular system and extensions, so that on top you can write any wrapper for another library or embed it transparently in your solution.  The library implements the imitation of sockets and pipe, so that the developer gets a high-level abstraction, and if you get even higher, then the event model is available to him and you can just forget about the implementation details. </li><li>  <strong>Plugin system</strong> - the server can be expanded by <a href="http://www.ape-project.org/wiki/index.php/How_to_create_a_server_Module">adding its own functionality</a> through plug-ins.  Now available only through C-modules, however, they are extremely simple, server-side JavaScript is expected in the future, which will truly be an excellent solution (oh, I would have to screw PHP there, although, of course, you can use a simple C-plugin, but still). </li></ul><br>  On the server side, APE uses the epoll mechanism, as well as a hash-table implementation (DJB Hash Algorithm).  This turns out, in addition to maximum performance, also difficulties in porting - the server wants to build the Linux kernel 2.6.19+ and libc6-dev, and so far I have failed to force it to build under Cygwin (the stopper is precisely in terms of the epoll mechanism built into the kernel ). <br><br>  For the exchange of information between the server and the client, as well as between clients (through the server), APE implements several methods.  The first is the Channels, when users subscribe to certain channels, and when a new information associated with this channel appears on the server, it is transmitted to all clients who listen to the channel.  Thus, you can immediately send out new data to all customers, which can be an unlimited number.  You can also use APE as a queue of messages stored in memory ‚Äî each connected user has one or more queues.  The recipient of the message can be either a channel, then everyone will receive the message, either directly another user, or an external service.  Channels can be both interactive and read-only. <br><br>  APE takes on the role of a proxy server, allowing you to exchange messages with external services (for example, your application server), as well as receive data from them and send them to channels or specific users.  Thus, it is possible to build a system in which the APE will be the front-end for users, which handles connections, and then the back-end server is already running, delivering and receiving data in the form of messages using the internal APE protocol, but not knowing anything about the number of connected clients , he only needs to be able to communicate with the APE server. <br><br><div style="text-align:center;"><img title="ape-communication-system" src="http://abrdev.com/wp-content/uploads/2009/05/ape-communication-system.png" alt="ape-communication-system" width="500" height="300"></div><br><br>  The interaction between the client and the server is made through a <a href="http://www.ape-project.org/wiki/index.php/Protocol_Basics">special protocol</a> .  Users can initiate commands, for example, send a message or create a connection, in response to which the server sends RAW data, usually JSON.  However, server modules can extend the built-in command set, so you can describe your own set of actions, depending on your needs. <br><br>  Although the <a href="http://www.ape-project.org/en/docs/">official documentation</a> is still in development (of course, this is a wiki), and does not report on the available modules, several basic modules are available in the source repository, which can be useful both as a reference tool for developing your solutions and for embedding them into the already existing infrastructure.  For example, libape-mysql allows you to connect to the database and receive new information from there (however, note that the module version is 0.01), and libape-chat will show a demo version of a simple chat system.  The most interesting promises to be libape-spidermonkey, although so far there is no information about it, except for the source. <br><br>  The project is very young, but already shows its potential, so if you plan to start any serious applications that require simultaneous work with multiple users (chat or gaming system), or data delivery is critical, I advise you to pay attention to APE. <br><br>  <b>PS</b> If anyone can build this server under the Win32 system - please share the solution! </div><p>Source: <a href="https://habr.com/ru/post/60803/">https://habr.com/ru/post/60803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../60790/index.html">We program Windows 7: Taskbar. Part 8 - IconicThumbnail</a></li>
<li><a href="../60791/index.html">We program Windows 7: Taskbar. Part 9 - PeekBitmap</a></li>
<li><a href="../60792/index.html">We program Windows 7: Taskbar. Part 10 (final) - JumpLists</a></li>
<li><a href="../60793/index.html">Reflections on the mobile phone market</a></li>
<li><a href="../60796/index.html">Google Wave - watch video</a></li>
<li><a href="../60806/index.html">Majesty 2 interview with KRI 2009</a></li>
<li><a href="../60809/index.html">Blowing hot air from laptops</a></li>
<li><a href="../60811/index.html">Autodesk DragonFly - interior design in a web browser</a></li>
<li><a href="../60813/index.html">Coloring Calendar List</a></li>
<li><a href="../60815/index.html">Windows Azure SDK May CTP with Visual Studio 2010 support released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>