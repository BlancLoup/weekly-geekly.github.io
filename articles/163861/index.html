<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Minicomputer from router with OpenWRT: write USB class-driver under Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. In the last article, you and I developed a simple USB video card based on the STM32F103 and the Chinese display modu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Minicomputer from router with OpenWRT: write USB class-driver under Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0ed/e35/601/0ede35601e373f3619887597572f96ad.jpg"><br>  Good afternoon, dear habrovchane.  In the <a href="http://habrahabr.ru/post/163689/">last article,</a> you and I developed a simple USB video card based on the STM32F103 and the Chinese display module on the ILI9325 controller. <br>  We checked it from yuzerspeysa, with the help of LibUSB.  Well, the time has come for us to write our own driver, which will allow us to do everything the same, but from under Linux and without additional libraries.  We will add this driver to the source tree of OpenWRT and it will settle there on a par with everyone else. <br>  Let's start. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Since the iron from the previous article we have not changed, we begin with consideration of what we need to achieve.  But before that, as always, I would recommend to get acquainted with the following materials: first of all, this is the <a href="http://free-electrons.com/doc/books/ldd3.pdf">book Linux Device Drivers</a> , which outlines everything necessary for the developer of drivers for Linux.  Secondly, I recommend once again to get acquainted with my <a href="http://habrahabr.ru/post/158127/">article</a> about setting up and finishing OpenWRT of our router, since  we have to mess around a lot with the build system and configs.  And finally - a <a href="http://free-electrons.com/">very, very useful resource</a> , presentations from their training seminars are freely available. <br>  Yes, we will develop, of course, from under Linux, so you need to attend to the presence of some distribution kit in advance.  I work under Linux Mint, but little will depend on the distribution kit, the only commands specific to it are installation commands from the repository of additional utilities. <br>  Now consider the approach to, in fact, the driver.  Anyone who is even slightly familiar with device drivers in Linux immediately comes to mind two well-known types of these same devices - symbolic and block.  This is perhaps the first thing that is told in any article about drivers.  Usually, after this, there is still a phrase that the network interface drivers stand separately. <br>  However, the full picture is presented far from everywhere.  Many drivers are not registered directly as character or block, despite the fact that the system displays as such.  Instead, they are registered through a specialized <i>framework of the</i> appropriate type - for example, framebuffer, input, tty, etc.  The framework defines a common interface for drivers and provides a standardized interface to the system. <br><br><img src="https://habrastorage.org/storage2/02f/13c/593/02f13c593ca121dac8c49eab0328af25.jpg"><br>  Thus, having defined the necessary structures with our driver and registering it through the framework of the same framebuffer, we no longer need to worry about telling the system ‚Äúsee, we have a display‚Äù - this is the task of the framework, and all applications (and drivers) who use the framebuffer in their work will immediately see our device.  For example, these include the console driver (fbcon), which uses a framebuffer for output, which can output a picture and colored text to the console when it is loaded. <br>  But let's not hurry and dive into this jungle, let's leave the framebuffer driver for the next article.  In the same article, we will write a character device driver, which, when writing to it from a user space, will create a package for our video card (calculating the position on the screen based on the position of the recording in the file) and send it via USB. <br><br><h4>  Preparing the workspace </h4><br>  The driver itself will be fairly simple, but we will consider important questions about adding it to the source tree.  Let's start with the helical frame driver. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Hellowworld kernel module</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; /* Needed by all modules */ #include &lt;linux/kernel.h&gt; /* Needed for KERN_INFO */ #include &lt;linux/init.h&gt; /* Needed for the macros */ #define DRIVER_AUTHOR "Amon-Ra" #define DRIVER_DESC "USB STM32-based LCD module driver" static int __init lcddriver_init(void) { printk(KERN_INFO "Hello, world!\n"); return 0; } static void __exit lcddriver_exit(void) { printk(KERN_INFO "Goodbye, world!\n"); } module_init(lcddriver_init); module_exit(lcddriver_exit); MODULE_LICENSE("GPL"); MODULE_AUTHOR(DRIVER_AUTHOR); MODULE_DESCRIPTION(DRIVER_DESC);</span></span></span></span></code> </pre> <br></div></div><br>  This code does not need explanations, it is the most hello worldly - we describe two callbacks and register them as functions that are called during module initialization and during its unloading.  In them, we simply display messages. <br>  Save this code as usblcd.c. <br>  Now let's remember how the system, which generates the output of our firmware, works in general.  This is a very complex product called BuildRoot, which, in fact, takes care of everything: it pumps out and compiles the toolchain for cross-assembling the code, downloads the source code and patches for the kernel and third-party utilities, generates configuration files for all of this in accordance with high-level settings, compiles, compiles the compiled into the package, generates the file system, puts it all together and packs it into the final image. <br>  It follows from this that configs for assembling, for example, the kernels (and generally for everything that is possible) are dynamically generated each time, and there is no sense to edit the gene config or even the makefile, they will be overwritten. <br>  In the standard image configuration menu, which we call make menuconfig, we also will not find the kernel settings.  So how to be? <br>  It turns out that the config for the kernel is generated from the base one, which we can change.  To do this, just call <b>make kernel_menuconfig</b> .  Here you have to be careful, this is the base for generating the target-specificity of the config, and you will not be able to roll back through make clean just by downloading the source code from the repository again.  Therefore, in it we act carefully and remember what is turned on and what is turned off! <br>  True, this is not what we need now, because in order to compile our driver, we have to make edits not only to the config, but also to the Makefile files (determining which modules will be compiled) and Kconfig (on the basis of which the menu is generated from <b>make kernel_menuconfig</b> and which contains options for the Makefile) - without this, in the menu we will not even find any mention of our driver. <br>  In addition, we need our usblcd.c to appear in the directory with the Linux sources, in the <b>/ drivers / video</b> subdirectory. <br>  And the first thing we need to understand at the moment is the <b>generation of the target-specificity of the source tree using the files in target / linux / &lt;target&gt; /</b> <br>  Buildroot takes clean kernel sources and puts them into <b>build_dir / &lt;target architecture&gt; / &lt;target platform&gt; / linux- &lt;kernel version&gt;</b> <br>  After that, additional source files from <b>target / linux / &lt;target&gt; / files</b> are copied there - usually, there are drivers that are specific to the target platform and other platform-specific code. <br>  After that, the patch set in <b>target / linux / &lt;target&gt; / patches</b> is applied.  These patches usually contain an addition to the Makefile and Kconfig, which adds the appropriate drivers to the build process.  In addition to the platform-specific patches, patches from <b>target / linux / genegic</b> are also applied, more general, not sharpened for a specific device. <br>  After this, the config for the kernel build is generated and, in fact, the build of what lies in build_dir is launched. <br>  Now let's go successively and point by point, as in the previous article, and begin by placing usblcd.c. <br><ol><li>  Go to <b>target / linux / ar71xx / files / drivers</b> and execute <b>mkdir video there</b> , creating a directory for our driver.  Buildroot scatters the contents of files in the appropriate directories of the source tree.  We place the file usblcd.c in the newly created folder. </li><li>  In target / linux / ar71xx / modules.mk we add an entry for the new kernel-packet.  <b>Here it should be remembered that the kernel packet is not the same as the kernel modules.</b>  Kernel packs are packages designed for the opkg utility in OpenWRT, they can be inserted into an image, or compiled as a single-sided package, but this will not affect in any way how the corresponding kernel module will be built. <br>  Simply put, if we have some binary, we can either push it into the package anymore (option M in <b>make menuconfig</b> ), leaving it in the directory with crashed packages or inserting it into the file system of the image under construction, that is, preset its default.  At the same time, if this binary is a kernel module, then, when compiling the kernel, of course, it will be brought down exactly as a separate module, so that it can be packed into a package.  You can embed a kernel module into the kernel itself only via <b>make kernel_menuconfig</b> (or via a patch for these very kernels of configs). <br>  This may at first cause some confusion and finding out why the packet, which is explicitly listed as built-in, generates separate kernel-modules.  However, if you comprehend this mechanism, everything becomes clear and logical. <br>  We will build the driver as a separate module, and it will be possible to solve it every time in FS or not by reconfiguring the build via make menuconfig. <br><br><div class="spoiler">  <b class="spoiler_title">Entry in modules.mk</b> <div class="spoiler_text"><pre> <code class="perl hljs">define KernelPackage/usb-lcd SUBMENU:=$(USB_MENU) TITLE:=USB STM32-based LCD module DEPENDS:=@TARGET_ar71xx KCONFIG:=CONFIG_STM32_USB_LCD FILES:=$(LINUX_DIR)/drivers/video/usblcd.ko endef define KernelPackage/usb-lcd/description Kernel module <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> USB STM32-based LCD module. endef $(<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span> $(call KernelPackage,usb-lcd))</code> </pre><br></div></div><br>  Here we set the rules for the new entry, called make menuconfig - we say that the package will be in the USB submenu, with the title given to us relating to the platform based on the AR71xx. <br>  Next, we inform you which kernel option it activates - call it CONFIG_STM32_USB_LCD. <br>  Then comes the name of the file that the system will load into the package - after compilation, our module will become usblcd.ko, and indicate it.  Then we set the description and do not forget the last line pulling the script processing of all this. <br></li><li>  From the root of OpenWRT, we run make menuconfig and search for our package in Kernel modules / USB, and say that we want to include it in the resulting image. <br></li><li>  This is still not enough for the module to be assembled; the choice of this package will only determine the <b>CONFIG_STM32_USB_LCD</b> option when building the kernel.  In order for this option to mean anything, you need to edit the Kconfig and Makefile files from the <b>&lt;kernel source directory&gt; / drivers / video</b> .  However, if we go to build_dir for this, we will not get anything good, we have already found out that the content is generated anew each time.  The correct way is to create a board-specific patch for the kernel files and place it in <b>/ target / linux / ar71xx / patches</b> .  For this we need quilt - a system for working with patches.  You can read more about this in the <a href="http://wiki.openwrt.org/doc/devel/patches">article with Wiki.OpenWRT</a> . <br>  Install quilt (sudo apt-get install quilt) and configure it for an article from the wiki: <br><br><pre> <code class="bash hljs">cat &gt; ~/.quiltrc &lt;&lt;EOF QUILT_DIFF_ARGS=<span class="hljs-string"><span class="hljs-string">"--no-timestamps --no-index -pab --color=auto"</span></span> QUILT_REFRESH_ARGS=<span class="hljs-string"><span class="hljs-string">"--no-timestamps --no-index -pab"</span></span> QUILT_PATCH_OPTS=<span class="hljs-string"><span class="hljs-string">"--unified"</span></span> QUILT_DIFF_OPTS=<span class="hljs-string"><span class="hljs-string">"-p"</span></span> EDITOR=<span class="hljs-string"><span class="hljs-string">"nano"</span></span> EOF</code> </pre><br></li><li>  We execute the command <br><br><pre> <code class="bash hljs">make target/linux/{clean,prepare} V=s QUILT=1</code> </pre><br>  It will prepare us the source tree in build_dir for further use. <br></li><li>  Go to the directory with the kernel source in build_dir.  The version may differ, so you will need to adjust the path according to the kernel version number. <br>  After that, apply all the patches that are intended for our assembly. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build_dir/target-mips_r2_uClibc-0.9.33.2/linux-ar71xx_generic/linux-3.6.9/ quilt push ‚Äìa</code> </pre><br></li><li>  Next, you need to create a patch with a name that matches a specific rule - it must begin with a digit that is larger than that of any of the existing patches - this affects the order in which the patches are applied and avoids conflicts.  To find out what patches are applied to this version of the kernel, use the <b>quilt serries command</b> and get a large-large list containing generic and platform-specific patches.  Since  we will have a patch specific for the platform, look at the <b>Platform / xxx- &lt;name&gt; .patch</b> .  For the revision that I have, the last one was <b>platform / a06-rb750_nand-add-buffer-verification.patch</b> so the number will be b00. <br>  We perform <br><br><pre> <code class="bash hljs">quilt new platform/b00-usb-lcd.patch</code> </pre><br></li><li>  We tell Kilt what files we will patch: <br><br><pre> <code class="bash hljs">quilt add drivers/video/Kconfig quilt add drivers/video/Makefile</code> </pre><br></li><li>  Editing files than convenient.  Let's start with Kconfig, which contains definitions for the kernel configuration menu.  Our driver will not be an ‚Äúhonest‚Äù framebuffer driver yet, so we will add it to the root, that is, before the lines <br>  <i>menuconfig FB</i> <i><br></i>  <i>tristate "Support for frame buffer devices"</i> <i><br></i> <br>  We write: <br><br><pre> <code class="bash hljs">config STM32_USB_LCD tristate <span class="hljs-string"><span class="hljs-string">"USB STM32-based LCD module support"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Simple USB STM32-based LCD module driver</code> </pre><br>  This will add a new item to the kernel configuration menu, located in the Drivers menu - Graphics Support. <br>  Now edit the Makefile, adding to it somewhere after <i># Hardware specific drivers go first</i> string <br><br><pre> <code class="bash hljs">obj-$(CONFIG_STM32_USB_LCD) += usblcd.o</code> </pre><br>  This will add our module to the list of compiled ones, if, of course, it is selected in the config. <br></li><li>  Make sure that everything is fine by issuing the <b>quilt diff command</b> , which should output the resulting patch file. <br>  After we say <b>quilt refresh</b> , saving the resulting patch. <br></li><li>  Go back to the build root and say <b>make target / linux / update V = s</b> <br>  check that the last lines of the command output will be approximately <br>  <i>`/home/ra/openwrt/trunk/build_dir/target-mips_r2_uClibc-0.9.33.2/linux-ar71xx_generic/linux-3.6.9/patches/platform/b00-usb-lcd '-&gt;` ./patches-3.6/b00 -usb-lcd '</i> <br></li><li>  We issue the command <b>make clean &amp;&amp; make</b> , generating an image for the firmware, upload it to the router (in / tmp, for example) and reflash.  It is possible through mtd, it is possible through sysupgrade - in the second case, you can save your / etc settings, which may be useful (switch -c): <br><br><pre> <code class="bash hljs">scp bin/openwrt-ar71xx-generic-tl-mr3020-v1-squashfs-sy supgrade.bin root@192.168.0.48:/tmp sysupgrade -c openwrt-ar71xx-generic-tl-mr3020-v1-squashfs-sy supgrade.bin</code> </pre><br></li><li>  We go to the SSH router, see what we have in <b>/ lib / modules</b> - if everything was done correctly, among other kernel modules there will be our usblcd.ko <br>  Run <b>insmod usblcd &amp;&amp; rmmod usblcd</b> <br>  Nothing should fall and generally respond. <br>  We write dmesg - and this is what we should see in recent posts: <br><br>  <i>[291.630000] Hello, world!</i> <i><br></i>  <i>[291.640000] Goodbye, world!</i> </li></ol><br>  Congratulations, the module is successfully assembled and implemented.  It is not necessary to rebuild the whole image each time and rewrite the router, just say <b>make clean &amp;&amp; make target / compile</b> , which rebuilds only the kernel with the modules, after which the necessary modules can be transferred to the router via SCP.  Now you can proceed to the actual writing of the driver. <br><br><h4>  Driver </h4><br>  Here, the source code of the driver called usb-skeleton will help us a lot, which can be viewed online <a href="">here</a> . <br>  In addition, when googling found a <a href="http://matthias.vallentin.net/blog/2007/04/writing-a-linux-kernel-driver-for-an-unknown-usb-device/">good article</a> in which just describes the process of developing a USB-driver for your device. <br><br><ol><li>  First of all, we must declare a structure by which the core will know which devices we can serve.  We declare the usb_device_id table: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lcd_table</span></span></span><span class="hljs-class">[]={</span></span> {USB_DEVICE(DEVICE_VENDOR_ID, DEVICE_PRODUCT_ID)}, { } };</code> </pre><br>  Here, DEVICE_VENDOR_ID and DEVICE_PRODUCT_ID, the defined VID and PID are equal, respectively, 0xDEAD and 0xF00D - the same as our video card. <br></li><li>  Immediately after the ad call the macro <br>  <b>MODULE_DEVICE_TABLE (usb, lcd_table);</b> <br>  telling userspace that we are processing the devices listed in the table. <br></li><li>  We declare callbacks <br>  <b>void LCDProbe (struct usb_interface * interface, const struct usb_device_id * id)</b> <br>  and <br>  <b>void LCDDisconnect (struct usb_interface * interface)</b> <br>  They will be called upon connecting and disconnecting the device.  For now, leave them empty. <br></li><li>  We declare an important structure in which we combine all of the above: <br><br><div class="spoiler">  <b class="spoiler_title">Usb_driver structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd_driver</span></span></span><span class="hljs-class">={</span></span> .owner = THIS_MODULE, .name = <span class="hljs-string"><span class="hljs-string">"usblcd"</span></span>, .probe = LCDProbe, .disconnect = LCDDisconnect, .id_table = lcd_table, };</code> </pre><br></div></div><br></li><li>  Usually, registration of a new USB driver is performed in <b>module_init</b> , and deregistration is in <b>module_exit</b> , but instead of describing these two callbacks, there is a convenient macro that eliminates the need to manually describe the initialization and deinitialization functions of the module, they will be included in the code when using a macro and will contain calls to <b>usb_register (...)</b> and <b>usb_deregister (...)</b> , registering / deregistering our driver, and nothing more is required of them: <br><br><pre> <code class="cpp hljs">module_usb_driver(usblcd_driver);</code> </pre><br></li></ol><br>  The time has come to check the driver - we save what we have written, give the command <b>make clean &amp;&amp; make target / compile V = s</b> , carefully watching that there are no errors during the compilation process, then we transfer the resulting usblcd.ko to the device, replacing the old version. <br>  Now we do <b>insmod usblcd.ko</b> on the router, connect the display, wait a second or two, disable it and do <b>rmmod usblcd</b> .  Then we call <b>dmesg</b> . <br>  It should get something like this: <br><br><pre> <code class="bash hljs">[ 6002.060000] usbcore: registered new interface driver usblcd [ 6010.850000] usb 1-1: new full-speed USB device number 2 using ehci-platform [ 6011.010000] USB STM32-based LCD module connected [ 6015.140000] usb 1-1: USB disconnect, device number 2 [ 6015.140000] USB STM32-based LCD module disconnected [ 6024.240000] usbcore: deregistering interface driver usblcd</code> </pre><br><br>  Remember that printk is not flush if \ n is not at the end of the line, so if we want to see information from the driver in chronological order and without delay, do not forget to end our debug messages with the newline character. <br>  It's time to write something useful in the driver.  Since we are not going to write a real framebuffer driver yet, let's register the so-called USB device driver class.  When registering it, we, just like with a character device, specify callbacks for file operations through the file_operations descriptor structure for normal file operations ‚Äî opening, closing, reading, writing, etc.  In this case, the system will not care that dangles at the other end of the cord - the display, sound, or mouse.  You can use them in this quality only through your user-space applications that work with devices reading / writing to device files in the required format. <br>  Start X, for example, on this display does not work - X needs a framebuffer, providing a standardized interface. <br>  Such a driver is registered using the structure <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_class_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd_class</span></span></span><span class="hljs-class"> = {</span></span> .name = <span class="hljs-string"><span class="hljs-string">"lcd%d"</span></span>, .fops = &amp;LCD_fops, .minor_base = LCD_MINOR_BASE, };</code> </pre><br>  Here, the first field specifies the device name (% d is used to substitute the device number after the name), the second is a pointer to the file operation structure, the third is the number from which the minors for the device will be displayed. <br><br>  The order is as follows: <br><ol><li>  We declare callbacks (for a start, you can leave them without a code, only with return 0) <br><br><div class="spoiler">  <b class="spoiler_title">Kolbeki</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, struct file *filp)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDrelease</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, struct file *file)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDwrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct file *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *user_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ppos)</span></span></span></span>;</code> </pre><br></div></div><br></li><li>  <b>We declare the file_operations</b> structure: <br><br><div class="spoiler">  <b class="spoiler_title">File_operations structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_operations</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LCD_fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .write = LCDwrite, .open = LCDOpen, .release = LCDrelease, };</code> </pre><br></div></div><br>  The absence of a .read callback means write-only access (you can do the same without adding write. The absence of open or release will not mean that the device file cannot be opened or closed, but, on the contrary, it means that these operations are always successful). <br></li><li>  Almost always there is a need to store some global data associated with the device and transfer them to all these callbacks, so usually get their own custom structure, one of the fields of which will be a pointer to usb_device, given to us by the system when calling the probe callback (or rather, received from the interface transmitted into the probe), the remaining fields can be set at your discretion.  So, we describe the structure-descriptor of the device: <br><br><div class="spoiler">  <b class="spoiler_title">Structure descriptor device usblcd</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_interface</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> minor; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_endpoint_descriptor</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bulk_out_ep</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bulk_out_packet_size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *videobuffer; };</code> </pre><br></div></div><br></li><li>  We describe the Probe callback.  In it, we initialize the device structure and perform all initialization of the device-related buffers.  If we have buffers that are individual for each open instance of the device file, then they need to be <b>initialized</b> in <b>LCD_fops.open</b> <br><br><div class="spoiler">  <b class="spoiler_title">Probe Callback Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDProbe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct usb_interface *interface, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct usb_device_id *id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_host_interface</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iface_desc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_endpoint_descriptor</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">endpoint</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*dev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dev) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Out of memory\n"</span></span>); retval = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } dev-&gt;udev=interface_to_usbdev(interface); mutex_init(&amp;dev-&gt;io_mutex); dev-&gt;interface = interface; iface_desc = interface-&gt;cur_altsetting; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) { endpoint = &amp;iface_desc-&gt;endpoint[i].desc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(usb_endpoint_is_bulk_out(endpoint)) { dev-&gt;bulk_out_ep=endpoint; dev-&gt;bulk_out_packet_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dev-&gt;bulk_out_ep) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Can not find bulk-out endpoint!\n"</span></span>); retval = -EIO; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_dev; } dev-&gt;videobuffer=kmalloc(TOTAL_BUFFER_SIZE, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dev-&gt;videobuffer) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Out of memory\n"</span></span>); retval = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_dev; } usb_set_intfdata(interface, dev); retval = usb_register_dev(interface, &amp;usblcd_class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retval) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Not able to get a minor for this device."</span></span>); usb_set_intfdata(interface, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_buff; } dev-&gt;minor = interface-&gt;minor; dev_info(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"USB STM32-based LCD module connected as lcd%d\n"</span></span>,dev-&gt;minor-LCD_MINOR_BASE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_buff: kfree(dev-&gt;videobuffer); error_dev: kfree(dev); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br>  Pointer to <b>usb_device * udev is</b> obtained from the pointer passed to the kernel by usb_interface <b>* usb_interface</b> via <b>interface_to_usbdev (interface)</b> .  Since there can be several multiple interfaces within one device, we get the current interface descriptor ( <b>usb_host_interface</b> ) from the field of the same structure ( <b>interface-&gt; cur_altsetting ();</b> ) <br>  Next we go through all the interface endpoints, checking whether there are any needed ones, saving pointers to them and acceptable packet size for further quick access to our device descriptor structure.  For bulk endpoints, the size of the buffer when sending can be specified more than this value, the kernel itself will break your data into packets of a suitable size, so, in principle, this value is not used anywhere in the code, I saved it just for my own peace of mind, making sure that there are exactly those 0x40 bytes that I indicated in the descriptor.  Checking whether a point belongs to a particular type is performed by macros of the form <b>usb_endpoint_is_bulk_out (endpoint)</b> .  Do not forget that to correctly get the value of numeric fields, you need to bring their byte order in accordance with the processor used by means of functions like <b>le16_to_cpu</b> (little endian 16-bit in order cpu).  When everything is initialized, the pointer to the handle is stored in the kernel structure itself, which it passes into callbacks, via the call <b>usb_set_intfdata (interface, dev);</b>  The final step in the Probe function is to register the USB class driver.  From this point on, the file / dev / lcd [n] appears in / dev, and the callback functions from LCD_fops can be called at any time (when accessing the device file).  Successful completion of the registration will bring the <b>minor</b> assigned to us into <b>interface-&gt; minor</b> .  Subtracting from it LCD_MINOR_BASE we get the number under which the device will be visible in / dev / - because  we have one display, then the minor will be LCD_MINOR_BASE, respectively / dev / lcd0 will appear in / dev. </li><li>  Immediately symmetrically write the code of the Disconnect callback, getting a pointer to our usblcd descriptor via the call <b>dev = usb_get_intfdata (interface);</b> <br><br><div class="spoiler">  <b class="spoiler_title">Disconnect Callback Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDDisconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct usb_interface *interface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minor; dev = usb_get_intfdata(interface); minor=dev-&gt;minor; usb_set_intfdata(interface, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); usb_deregister_dev(interface, &amp;usblcd_class); dev-&gt;interface = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; kfree(dev-&gt;videobuffer); kfree(dev); dev_info(&amp;interface-&gt;dev,<span class="hljs-string"><span class="hljs-string">"USB STM32-based LCD module lcd%d disconnected\n"</span></span>,minor-LCD_MINOR_BASE); }</code> </pre><br></div></div><br>  Set the pointer to the data in the interface to NULL and deregister the driver class.  From this moment on, no one will pull us out of the user space.  After that, we clean all our allocated buffers and the last step is to clear the memory from under the dev structure itself.  It is important to remember that any callback from LCD_fops can be called at any time, that is, if you suddenly pull out the device, any other process can currently be in the middle of an opening, reading or writing procedure.           ,       ,     .      ¬´ ,     Disconnect  Open?   Write?¬ª <br>     ,     ,    write. </li><li>      ,         . <br>             ,     . <br>      , ,     . , ,      ,         ,      : <b>static atomic_t DeviceFree=ATOMIC_INIT(1);</b> <br>    Open  ,   Linux Device Drivers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!atomic_dec_and_test(&amp;DeviceFree)) { atomic_inc(&amp;DeviceFree); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br> <b>atomic_dec_and_test</b>    ,  ,     (DeviceFree = 1),   (DeviceFree = 0),    true, ..  true          . <br>      (DeviceFree = 0),   DeviceFree = -1   false.          (..    ) ‚Äî        (EBUSY,  ).  ,   ,         ,        ‚Äî      , ..     DeviceFree  -2     false. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately add to Release </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atomic_inc (&amp; DeviceFree); </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telling that the device is free.</font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can test the performance of the code by compiling it and transferring it to the router. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After running insmod usblcd.ko and connecting the device, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dmesg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should say something like:</font></font><br><br><pre> <code class="bash hljs">[ 9323.880000] usbcore: registered new interface driver usblcd [ 9334.640000] usb 1-1: new full-speed USB device number 4 using ehci-platform [ 9334.800000] usblcd 1-1:1.0: USB STM32-based LCD module connected as lcd0</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The / dev / lcd0 device should appear in / dev /, which cannot be read from </font></font><br><br><pre> <code class="bash hljs">root@OpenWrt:~<span class="hljs-comment"><span class="hljs-comment"># cat /dev/lcd0 cat: read error: Invalid argument</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the record is possible only when someone else does not write to the device (we execute the same command in two instances of ssh): </font></font><br><br><pre> <code class="hljs ruby">root@OpenWrt<span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># cat /dev/urandom &gt; /dev/lcd0 -ash: cannot create /dev/lcd0: Device or resource busy</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We continue the implementation. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We include the header file </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;linux / mutex.h&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , add the </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct mutex</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> field </font><b><font style="vertical-align: inherit;">io_mutex to the</font></b><font style="vertical-align: inherit;"> descriptor structure </font><b><font style="vertical-align: inherit;">; </font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in callback Probe - its initialization by calling </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutex_init (&amp; dev-&gt; io_mutex);</font></font></b> </li><li>    Disconnect,     -: <br><br><div class="spoiler"> <b class="spoiler_title">  Disconnect</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDDisconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct usb_interface *interface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minor; dev = usb_get_intfdata(interface); minor=dev-&gt;minor; usb_set_intfdata(interface, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); usb_deregister_dev(interface, &amp;usblcd_class); mutex_lock(&amp;dev-&gt;io_mutex); dev-&gt;interface = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; mutex_unlock(&amp;dev-&gt;io_mutex); kfree(dev-&gt;videobuffer); kfree(dev); dev_info(&amp;interface-&gt;dev,<span class="hljs-string"><span class="hljs-string">"USB STM32-based LCD module lcd%d disconnected\n"</span></span>,minor-LCD_MINOR_BASE); }</code> </pre><br></div></div><br> ,  ,   -            dev-&gt;interface   .  ,        io_mutex,   ,       ( dev-&gt;interface            ),     (   NULL). <br></li><li>    Open: <br>    ,     ,      <br> <b>subminor = iminor(inode);</b> <br>   usb_interface  <b>interface = usb_find_interface(&amp;usblcd_driver, subminor);</b> <br>         <b>dev = usb_get_intfdata(interface);</b>         .    , <b>mutex_lock(&amp;dev-&gt;io_mutex);</b>  ,     ,     . <br> ,       ,        LCD_fops: <br> <b>filp-&gt;private_data = dev;</b> <br><br><div class="spoiler"> <b class="spoiler_title">  Open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, struct file *filp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_interface</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> subminor; filp-&gt;private_data=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!atomic_dec_and_test(&amp;DeviceFree)) { atomic_inc(&amp;DeviceFree); retval = -EBUSY; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } subminor = iminor(inode); interface = usb_find_interface(&amp;usblcd_driver, subminor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!interface) { printk(KERN_ERR <span class="hljs-string"><span class="hljs-string">"usblcd driver error, can't find device for minor %d\n"</span></span>, subminor); retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } dev = usb_get_intfdata(interface); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dev) { retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } mutex_lock(&amp;dev-&gt;io_mutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dev-&gt;interface) { retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> unlock_exit; } filp-&gt;private_data = dev; dev_info(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"usblcd: opened successfuly"</span></span>); unlock_exit: mutex_unlock(&amp;dev-&gt;io_mutex); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br></li><li>   , ,         ( )   X (unsigned short), Y (unsigned short),    (unsgned long).       Little Endian. <br><br><div class="spoiler"> <b class="spoiler_title"> Write</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDwrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct file *filp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *user_buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ppos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_interface</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> usbSent; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> writtenCount=count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ppos&gt;=VB_SIZE*<span class="hljs-number"><span class="hljs-number">2</span></span>) { retval = -ENOSPC; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ppos+count&gt;VB_SIZE*<span class="hljs-number"><span class="hljs-number">2</span></span>) writtenCount=VB_SIZE*<span class="hljs-number"><span class="hljs-number">2</span></span>-*ppos; dev = filp-&gt;private_data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dev) { printk(KERN_ERR <span class="hljs-string"><span class="hljs-string">"usblcd driver error, no device found\n"</span></span>); retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } mutex_lock(&amp;dev-&gt;io_mutex); interface = dev-&gt;interface; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!interface) { printk(KERN_ERR <span class="hljs-string"><span class="hljs-string">"usblcd driver error, no device found\n"</span></span>); retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (copy_from_user(dev-&gt;videobuffer+<span class="hljs-number"><span class="hljs-number">8</span></span>, user_buf, writtenCount)) { retval = -EFAULT; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> unlock_exit; } y=((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((*ppos)&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)WIDTH); x=((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((*ppos)&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>))-y*WIDTH; *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>*)(dev-&gt;videobuffer)=cpu_to_le16(x); *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>*)(dev-&gt;videobuffer+<span class="hljs-number"><span class="hljs-number">2</span></span>)=cpu_to_le16(y); *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(dev-&gt;videobuffer+<span class="hljs-number"><span class="hljs-number">4</span></span>)=cpu_to_le32(writtenCount&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>); retval = usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, <span class="hljs-number"><span class="hljs-number">1</span></span>),dev-&gt;videobuffer, <span class="hljs-number"><span class="hljs-number">8</span></span>+writtenCount, &amp;usbSent, HZ*<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!retval) { retval = writtenCount; *ppos+=writtenCount; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { retval=-EIO; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> unlock_exit; } unlock_exit: mutex_unlock(&amp;dev-&gt;io_mutex); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br>       ,     ‚Äî          320*240*2 .      ‚Äî    .         *ppos,           .    ,     ,    ,     dev-&gt;interface ‚Äî  NULL .       ,      ,     (  Endian       )       <b>usb_bulk_msg</b> . <br>   ,    ,           ,     ,    . <br> ,   ,    ,                 , ..         .     . <br></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have just a little bit left: we compile the driver (we already know how to do this, having trained on the hello world), fill it in with the router, perform </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insmod usblcd.ko</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We make sure that the system does not crash, the device is detected upon connection, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / lcd0 is created</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's check how it went! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We display random on the screen:</font></font><br><br><pre> <code class="bash hljs">cat /dev/urandom &gt; /dev/lcd0</code> </pre><br><img src="https://habrastorage.org/storage2/412/635/72b/41263572bfb1d29918d150fe2023bedf.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's see how the system's main binary looks like - busybox: </font></font><br><br><pre> <code class="bash hljs">cat /bin/busybox &gt; /dev/lcd0</code> </pre><br><img src="https://habrastorage.org/storage2/bd3/cf6/5e2/bd3cf65e25b256369d5943740495a4e5.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isn't it true, the difference between the executable file and the pure random file is visible? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we will display some image:</font></font><br><br><pre> <code class="bash hljs">cat hobgoblin.raw &gt; /dev/lcd0</code> </pre><br><img src="https://habrastorage.org/storage2/6b1/f96/ead/6b1f96eade51c754cf12e38811363bd7.jpg"><br><br><h4>  Conclusion </h4><br> ,    -     ,      linux       OpenWRT. <br>         ‚Äî   ,      -  ,    ,            .         . <br>     ! <br><br> <i>Hail to the speaker, <br> Hail to the knower, <br> Joy to him who has understood, <br> Delight to those who have listened.</i> </div><p>Source: <a href="https://habr.com/ru/post/163861/">https://habr.com/ru/post/163861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../163849/index.html">What is wrong with the work on the result</a></li>
<li><a href="../163853/index.html">Git internals: data storage and merge</a></li>
<li><a href="../163855/index.html">Creating a Django web application in Visual Studio 2012 and publishing it to the Windows Azure cloud</a></li>
<li><a href="../163857/index.html">EBS RAID for faster performance and cost effectiveness</a></li>
<li><a href="../163859/index.html">Multithreaded web server for 1C: Enterprise using .Net Framework</a></li>
<li><a href="../163865/index.html">Started collecting pre-orders for virt2real (Virtuirlka)</a></li>
<li><a href="../163869/index.html">Atari Portfolio - John Connor's laptop</a></li>
<li><a href="../163871/index.html">Cheat Sheet by layout for large and small</a></li>
<li><a href="../163877/index.html">Is progressive improvement so expensive?</a></li>
<li><a href="../163881/index.html">CORE Design Technique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>