<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Custom Video Recorder for iOS applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Camera application for iPhone / iPad is very convenient to use. The user can easily switch from photographing mode to video. In the video mode, the sh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Custom Video Recorder for iOS applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/1b5/9bc/499/1b59bc4994c84620b2fa3bd4a6132fb7.jpg" align="left">  Camera application for iPhone / iPad is very convenient to use.  The user can easily switch from photographing mode to video.  In the video mode, the shooting time and only one button (Start / Stop) is shown.  Unfortunately, when using the standard UIImagePickerController, there is no way to control the number of frames per second and some other parameters.  I will show how to use the AVFoundation framework to access more advanced camera settings, such as frames per second, video quality, recording duration, video file size.  The user will immediately see the video on the screen in the quality in which it will be saved. <br><a name="habracut"></a><br>  The main object that will allow me to record video: <br><br><pre><code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">AVCaptureSession</span></span> <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br>  In addition, I will need: <br><br><pre> <code class="hljs ruby">AVCaptureVideoPreviewLayer /<span class="hljs-regexp"><span class="hljs-regexp">/ ,           AVCaptureDevice /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span>  AVCaptureDeviceInput /<span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span>   AVCaptureSession AVCaptureMovieFileOutput /<span class="hljs-regexp"><span class="hljs-regexp">/  AVCaptureSession      </span></span></code> </pre> <br>  Design can be stored in a xib file or storyboard.  Using Autolayout and Constraints in the designer, you can ensure that all panels are automatically stretched, the buttons are centered (left or right).  Our VideoRecorderController will have three modes of operation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <b>Ready to shoot:</b> AVCaptureSession is running, on-screen video from the camera in real time, but recording does not go. <br><br>  On the bottom panel, the Cancel button is active - canceling a shot, the Start button is also active - the start of the recording, the Use Video button is hidden. <br><br>  The top panel shows the recording time - 00:00.  After clicking the Cancel button, the delegate of the video shoot triggers the method - (void) videoRecorderDidCancelRecordingVideo.  After pressing the Start button, go to the next mode. <br><br></li><li>  <b>Shooting:</b> AVCaptureSession is running, on the screen is a video from the camera in real time, while recording video to a file.  Instead of the Start button, the Stop button appears on the bottom panel - the end of the recording, the Cancel button is hidden, the Use Video button is also hidden.  The top panel shows the current recording time - 00:22.  After pressing the Stop button, recording stops, go to the next mode. <br><br></li><li>  <b>Shooting is complete:</b> AVCaptureSession is stopped, the last frame of the captured video is displayed on the screen, video recording to the file is completed.  A Play Video button appears in the center of the screen. <br>  On the bottom panel, instead of the Cancel button, the Retake button appears - reshoot the video, the Use Video button appears, the Start button is hidden. <br><br>  The top panel shows the video recording duration - 00:25. <br>  After clicking the Play Video button, the footage is viewed through AVPlayer. <br>  After clicking Retake, we return to the first mode. <br>  After clicking the Use Video button, the delegate of the video shoot triggers the method - (void) videoRecorderDidFinishRecording VideoWithOutputURL: (NSURL *) outputURL. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Three modes of operation - screens</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/files/728/7da/e72/7287dae720ce417194a13f2a79102230.PNG"></td><td><img src="https://habrastorage.org/files/046/139/7c7/0461397c7e344e30a3bc0fa1b903b3c3.PNG"></td><td><img src="https://habrastorage.org/files/5f1/a34/2c3/5f1a342c329e41f7b3c802c321d6d71f.PNG"></td></tr></tbody></table><br></div></div><br>  In the header file, I need to describe the video delegate protocol to handle the cancellation of the video and the successful completion of the video. <br><br><div class="spoiler">  <b class="spoiler_title">This is how the VideoRecorderController.h header file will look</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;CoreMedia/CoreMedia.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AudioToolbox/AudioToolbox.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AVKit/AVKit.h&gt;</span></span></span><span class="hljs-meta"> @protocol VideoRecorderDelegate </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSObject&gt;</span></span></span><span class="hljs-meta"> //  ,      - (void)videoRecorderDidFinishRecordingVideoWithOutputPath:(NSString *)outputPath; //  ,     - (void)videoRecorderDidCancelRecordingVideo; @end @interface VideoRecorderController : UIViewController @property (nonatomic, retain) NSString *outputPath; //     @property (nonatomic, assign) id</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;VideoRecorderDelegate&gt;</span></span></span><span class="hljs-meta"> delegate; @end</span></span></code> </pre><br></div></div><br>  In the implementation file VideoRecorderController.m, I set several constants for video recording and describe the properties and methods that need to be bound in the interface designer.  I will also need: <br><br><ul><li>  AVCaptureSession video capture session </li><li>  video output file AVCaptureMovieFileOutput </li><li>  AVCaptureDeviceInput video input device </li><li>  layer to display live video AVCaptureVideoPreviewLayer </li><li>  timer and time for the recording time indicator </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementation file VideoRecorderController.m - variable declaration</b> <div class="spoiler_text"><pre> <code class="hljs ruby"><span class="hljs-comment"><span class="hljs-comment">#import "VideoRecorderController.h" #define TOTAL_RECORDING_TIME 60*20 //      #define FRAMES_PER_SECOND 30 //     #define FREE_DISK_SPACE_LIMIT 1024 * 1024 //     () #define MAX_VIDEO_FILE_SIZE 160 * 1024 * 1024 //    () #define CAPTURE_SESSION_PRESET AVCaptureSessionPreset352x288 //   #define BeginVideoRecording 1117 //     #define EndVideoRecording 1118 //     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@interface</span></span></span><span class="hljs-comment"> VideoRecorderController () &lt;AVCaptureFileOutputRecordingDelegate&gt; { BOOL WeAreRecording; // ,      AVCaptureSession *CaptureSession; AVCaptureMovieFileOutput *MovieFileOutput; AVCaptureDeviceInput *VideoInputDevice; } //          </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UILabel *timeLabel; //       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UIButton *startButton; //  Start / Stop </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UIImageView *circleImage; //    Start </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UIButton *cancelButton; //  Cancel </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UIButton *useVideoButton; //  Use Video </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UIView *bottomView; //   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) IBOutlet UIButton *playVideoButton; //  Play Video - (IBAction)startStopButtonPressed:(id)sender; //    Start / Stop - (IBAction)cancel:(id)sender; //    Cancel - (IBAction)useVideo:(id)sender; //    Use Video - (IBAction)playVideo:(id)sender; //    Play Video </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) AVCaptureVideoPreviewLayer *PreviewLayer; //        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (retain) NSTimer *videoTimer; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@property</span></span></span><span class="hljs-comment"> (assign) NSTimeInterval elapsedTime; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@end</span></span></span></span></code> </pre><br></div></div><br>  After you have completed the viewDidLoad method, you must perform the following steps: <br><br><ul><li>  set the path to the outputPath video file and delete the previous entry </li><li>  add a handler to the output of the application in the background UIApplicationDidEnterBackgroundNotification </li><li>  initialize AVCapture session </li><li>  find the default AVCaptureDevice video device and create an AVCaptureDeviceInput video input device </li><li>  Before you add a video input device, you must call <br>  [CaptureSession beginConfiguration] method </li><li>  then add a video entry device to the AVCaptureSession </li><li>  after adding a video input device, be sure to call the [CaptureSession commitConfiguration] method </li><li>  find the default AVCaptureDevice audio device, create an AVCaptureDeviceInput audio input device and add this device to the AVCaptureSession session </li><li>  create a layer AVCaptureVideoPreviewLayer, which will display the video in real time, bind it to the session AVCaptureSession, stretch this layer, full screen while maintaining the proportions (the edges of the frame do not fall on the screen) </li><li>  recalculate the size of the AVCaptureVideoPreviewLayer layer depending on the orientation of the device and send this layer to the background so that all the panels and control buttons are displayed on top of it </li><li>  initialize video output to the AVCaptureMovieFileOutput file </li><li>  set the frame rate per second, the maximum length of the video in seconds </li><li>  set the maximum video length in bytes </li><li>  set the minimum free disk space in bytes </li><li>  add video output to file in AVCaptureSession </li><li>  set video quality for AVCaptureSession </li><li>  finally set the correct orientation of the AVCaptureMovieFileOutput video output file and the AVCaptureVideoPreviewLayer video viewing layer </li></ul><br>  When you switch to another application, if the video is on, it will stop.  After you have completed the viewWillAppear method, you have to start the AVCaptureSession session, the live video starts to be displayed on the screen.  But if there was a transition to this screen after watching the video, then there is no need to run AVCaptureSession - there should be a check that there is no video file. <br><br><div class="spoiler">  <b class="spoiler_title">VideoRecorderController.m implementation file - loading View Controller</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoRecorderController</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath = [[<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> alloc] initWithFormat:<span class="hljs-string"><span class="hljs-string">@"%@%@"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSTemporaryDirectory</span></span>(), <span class="hljs-string"><span class="hljs-string">@"output.mov"</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> deleteVideoFile]; [[<span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span> defaultCenter] addObserver: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selector: <span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(applicationDidEnterBackground:) name: <span class="hljs-built_in"><span class="hljs-built_in">UIApplicationDidEnterBackgroundNotification</span></span> object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; CaptureSession = [[<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureSession</span></span> alloc] init]; <span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDevice</span></span> *VideoDevice = [<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDevice</span></span> defaultDeviceWithMediaType:<span class="hljs-built_in"><span class="hljs-built_in">AVMediaTypeVideo</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (VideoDevice) { <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; VideoInputDevice = [<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDeviceInput</span></span> deviceInputWithDevice:VideoDevice error:&amp;error]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) { [CaptureSession beginConfiguration]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([CaptureSession canAddInput:VideoInputDevice]) { [CaptureSession addInput:VideoInputDevice]; } [CaptureSession commitConfiguration]; } } <span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDevice</span></span> *audioDevice = [<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDevice</span></span> defaultDeviceWithMediaType:<span class="hljs-built_in"><span class="hljs-built_in">AVMediaTypeAudio</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDeviceInput</span></span> *audioInput = [<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureDeviceInput</span></span> deviceInputWithDevice:audioDevice error:&amp;error]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (audioInput) { [CaptureSession addInput:audioInput]; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setPreviewLayer:[[<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureVideoPreviewLayer</span></span> alloc] initWithSession:CaptureSession]]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.PreviewLayer setVideoGravity:<span class="hljs-built_in"><span class="hljs-built_in">AVLayerVideoGravityResizeAspectFill</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setupLayoutInRect:[[[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view] layer] bounds]]; <span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> *CameraView = [[<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> alloc] init]; [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view] addSubview:CameraView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view sendSubviewToBack:CameraView]; [[CameraView layer] addSublayer:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.PreviewLayer]; MovieFileOutput = [[<span class="hljs-built_in"><span class="hljs-built_in">AVCaptureMovieFileOutput</span></span> alloc] init]; <span class="hljs-built_in"><span class="hljs-built_in">CMTime</span></span> maxDuration = <span class="hljs-built_in"><span class="hljs-built_in">CMTimeMakeWithSeconds</span></span>(TOTAL_RECORDING_TIME, FRAMES_PER_SECOND); MovieFileOutput.maxRecordedDuration = maxDuration; MovieFileOutput.maxRecordedFileSize = MAX_VIDEO_FILE_SIZE; MovieFileOutput.minFreeDiskSpaceLimit = FREE_DISK_SPACE_LIMIT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([CaptureSession canAddOutput:MovieFileOutput]) { [CaptureSession addOutput:MovieFileOutput]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([CaptureSession canSetSessionPreset:<span class="hljs-built_in"><span class="hljs-built_in">CAPTURE_SESSION_PRESET</span></span>]) { [CaptureSession setSessionPreset:<span class="hljs-built_in"><span class="hljs-built_in">CAPTURE_SESSION_PRESET</span></span>]; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> cameraSetOutputProperties]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)applicationDidEnterBackground:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> *)application { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WeAreRecording) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> stopRecording]; } } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewWillAppear:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewWillAppear:animated]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![[<span class="hljs-built_in"><span class="hljs-built_in">NSFileManager</span></span> defaultManager] fileExistsAtPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath]) { WeAreRecording = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; [CaptureSession startRunning]; } }</code> </pre><br></div></div><br>  Screen rotation is allowed only if the session is running and recording is not yet in progress.  Before turning the screen, it is necessary to recalculate the screen size depending on the orientation.  After rotation, you need to set the correct orientation of the AVCaptureMovieFileOutput video output file and the AVCaptureVideoPreviewLayer video viewing layer. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation file VideoRecorderController.m - cornering</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">- (<span class="hljs-type"><span class="hljs-type">BOOL</span></span>)shouldAutorotate { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (CaptureSession.isRunning &amp;&amp; !WeAreRecording); } - (UIInterfaceOrientationMask)supportedInterfaceOrientations { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscape | UIInterfaceOrientationMaskPortraitUpsideDown); } - (<span class="hljs-type"><span class="hljs-type">void</span></span>)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator { [self setupLayoutInRect:CGRectMake(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, size.width, size.height)]; [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator]; [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) { } completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) { [self cameraSetOutputProperties]; }]; } //            //   viewWillTransitionToSize,     iOS <span class="hljs-number"><span class="hljs-number">7</span></span>    - (<span class="hljs-type"><span class="hljs-type">void</span></span>)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation { [self setupLayoutInRect:[[[self <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>] layer] bounds]]; [self cameraSetOutputProperties]; } //          - (<span class="hljs-type"><span class="hljs-type">void</span></span>)setupLayoutInRect:(CGRect)layoutRect { [self.PreviewLayer setBounds:layoutRect]; [self.PreviewLayer setPosition:CGPointMake(CGRectGetMidX(layoutRect), CGRectGetMidY(layoutRect))]; } //          - (<span class="hljs-type"><span class="hljs-type">void</span></span>)cameraSetOutputProperties { AVCaptureConnection *videoConnection = nil; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( AVCaptureConnection *<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [MovieFileOutput connections] ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( AVCaptureInputPort *port <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> inputPorts] ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( [[port mediaType] isEqual:AVMediaTypeVideo] ) { videoConnection = <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([videoConnection isVideoOrientationSupported]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([UIApplication sharedApplication].statusBarOrientation == UIInterfaceOrientationPortrait) { self.PreviewLayer.<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>.videoOrientation = AVCaptureVideoOrientationPortrait; [videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([UIApplication sharedApplication].statusBarOrientation == UIInterfaceOrientationPortraitUpsideDown) { self.PreviewLayer.<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>.videoOrientation = AVCaptureVideoOrientationPortraitUpsideDown; [videoConnection setVideoOrientation:AVCaptureVideoOrientationPortraitUpsideDown]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([UIApplication sharedApplication].statusBarOrientation == UIInterfaceOrientationLandscapeLeft) { self.PreviewLayer.<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>.videoOrientation = AVCaptureVideoOrientationLandscapeLeft; [videoConnection setVideoOrientation:AVCaptureVideoOrientationLandscapeLeft]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { self.PreviewLayer.<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>.videoOrientation = AVCaptureVideoOrientationLandscapeRight; [videoConnection setVideoOrientation:AVCaptureVideoOrientationLandscapeRight]; } } }</code> </pre><br></div></div><br>  By pressing the Start / Stop button, the recording will start if the recording is not yet in progress.  If the recording is already in progress, the recording will be stopped.  By pressing the Cancel button, the video delegate method VideoRecorderDidCancelRecordingVideo is triggered.  By pressing the Retake button, the timer is reset, the names of the buttons change, the Use Video button is hidden, the video capture session starts again.  By pressing the Use Video button, the video delegate method videoRecorderDidFinishRecordingVideoWithOutputPath is triggered, to which you must transfer the path to the video file.  When you click the Play Video button, the footage is shown using AVPlayer.  When the video timer is activated, the time indicator on the top panel is updated.  The delegate method of the video recording file is triggered if the file size has reached the maximum allowed value or the recording time has reached the maximum set.  At this point, recording stops. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation file VideoRecorderController.m - handling of button presses, delegate method AVCaptureFileOutputRecordingDelegate</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">- (<span class="hljs-type"><span class="hljs-type">IBAction</span></span>)startStopButtonPressed:(id)sender { if (!<span class="hljs-type"><span class="hljs-type">WeAreRecording</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> startRecording]; } else { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> stopRecording]; } } - (<span class="hljs-type"><span class="hljs-type">IBAction</span></span>)cancel:(id)sender { if ([<span class="hljs-type"><span class="hljs-type">CaptureSession</span></span> isRunning]) { if (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate videoRecorderDidCancelRecordingVideo]; } } else { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.circleImage.hidden = <span class="hljs-type"><span class="hljs-type">NO</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.startButton.hidden = <span class="hljs-type"><span class="hljs-type">NO</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.useVideoButton.hidden = <span class="hljs-type"><span class="hljs-type">YES</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelButton setTitle:@<span class="hljs-comment"><span class="hljs-comment">"Cancel"</span></span> forState:<span class="hljs-type"><span class="hljs-type">UIControlStateNormal</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.timeLabel.text = @<span class="hljs-comment"><span class="hljs-comment">"00:00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.elapsedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; [<span class="hljs-type"><span class="hljs-type">CaptureSession</span></span> startRunning]; } } - (<span class="hljs-type"><span class="hljs-type">IBAction</span></span>)useVideo:(id)sender { if (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate videoRecorderDidFinishRecordingVideoWithOutputPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath]; } } - (<span class="hljs-type"><span class="hljs-type">IBAction</span></span>)playVideo:(id)sender { if ([[<span class="hljs-type"><span class="hljs-type">NSFileManager</span></span> defaultManager] fileExistsAtPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath]) { <span class="hljs-type"><span class="hljs-type">NSURL</span></span> *outputFileURL = [[<span class="hljs-type"><span class="hljs-type">NSURL</span></span> alloc] initFileURLWithPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath]; <span class="hljs-type"><span class="hljs-type">AVPlayer</span></span> *player = [<span class="hljs-type"><span class="hljs-type">AVPlayer</span></span> playerWithURL:outputFileURL]; <span class="hljs-type"><span class="hljs-type">AVPlayerViewController</span></span> *controller = [[<span class="hljs-type"><span class="hljs-type">AVPlayerViewController</span></span> alloc] init]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> presentViewController:controller animated:<span class="hljs-type"><span class="hljs-type">YES</span></span> completion:<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>]; controller.player = player; controller.allowsPictureInPicturePlayback = <span class="hljs-type"><span class="hljs-type">NO</span></span>; [player play]; } } //     - (void)startRecording { //      <span class="hljs-type"><span class="hljs-type">AudioServicesPlaySystemSound</span></span>(<span class="hljs-type"><span class="hljs-type">BeginVideoRecording</span></span>); <span class="hljs-type"><span class="hljs-type">WeAreRecording</span></span> = <span class="hljs-type"><span class="hljs-type">YES</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelButton setHidden:<span class="hljs-type"><span class="hljs-type">YES</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bottomView setHidden:<span class="hljs-type"><span class="hljs-type">YES</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.startButton setImage:[<span class="hljs-type"><span class="hljs-type">UIImage</span></span> imageNamed:@<span class="hljs-comment"><span class="hljs-comment">"StopVideo"</span></span>] forState:<span class="hljs-type"><span class="hljs-type">UIControlStateNormal</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.timeLabel.text = @<span class="hljs-comment"><span class="hljs-comment">"00:00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.elapsedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoTimer = [<span class="hljs-type"><span class="hljs-type">NSTimer</span></span> scheduledTimerWithTimeInterval:<span class="hljs-number"><span class="hljs-number">1</span></span> target:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selector:@selector(updateTime) userInfo:<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> repeats:<span class="hljs-type"><span class="hljs-type">YES</span></span>]; //   ,   ,      [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> deleteVideoFile]; //      <span class="hljs-type"><span class="hljs-type">NSURL</span></span> *outputURL = [[<span class="hljs-type"><span class="hljs-type">NSURL</span></span> alloc] initFileURLWithPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath]; [<span class="hljs-type"><span class="hljs-type">MovieFileOutput</span></span> startRecordingToOutputFileURL:outputURL recordingDelegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; } - (void)deleteVideoFile { <span class="hljs-type"><span class="hljs-type">NSFileManager</span></span> *fileManager = [<span class="hljs-type"><span class="hljs-type">NSFileManager</span></span> defaultManager]; if ([fileManager fileExistsAtPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath]) { <span class="hljs-type"><span class="hljs-type">NSError</span></span> *error = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; if ([fileManager removeItemAtPath:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.outputPath error:&amp;error] == <span class="hljs-type"><span class="hljs-type">NO</span></span>) { //     } } } //     - (void)stopRecording { //      <span class="hljs-type"><span class="hljs-type">AudioServicesPlaySystemSound</span></span>(<span class="hljs-type"><span class="hljs-type">EndVideoRecording</span></span>); <span class="hljs-type"><span class="hljs-type">WeAreRecording</span></span> = <span class="hljs-type"><span class="hljs-type">NO</span></span>; [<span class="hljs-type"><span class="hljs-type">CaptureSession</span></span> stopRunning]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.circleImage.hidden = <span class="hljs-type"><span class="hljs-type">YES</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.startButton.hidden = <span class="hljs-type"><span class="hljs-type">YES</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelButton setTitle:@<span class="hljs-comment"><span class="hljs-comment">"Retake"</span></span> forState:<span class="hljs-type"><span class="hljs-type">UIControlStateNormal</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelButton setHidden:<span class="hljs-type"><span class="hljs-type">NO</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bottomView setHidden:<span class="hljs-type"><span class="hljs-type">NO</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.startButton setImage:[<span class="hljs-type"><span class="hljs-type">UIImage</span></span> imageNamed:@<span class="hljs-comment"><span class="hljs-comment">"StartVideo"</span></span>] forState:<span class="hljs-type"><span class="hljs-type">UIControlStateNormal</span></span>]; //    [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoTimer invalidate]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoTimer = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; //      [<span class="hljs-type"><span class="hljs-type">MovieFileOutput</span></span> stopRecording]; } - (void)updateTime { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.elapsedTime += <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoTimer.timeInterval; <span class="hljs-type"><span class="hljs-type">NSInteger</span></span> seconds = (<span class="hljs-type"><span class="hljs-type">NSInteger</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.elapsedTime % <span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-type"><span class="hljs-type">NSInteger</span></span> minutes = ((<span class="hljs-type"><span class="hljs-type">NSInteger</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.elapsedTime / <span class="hljs-number"><span class="hljs-number">60</span></span>) % <span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.timeLabel.text = [<span class="hljs-type"><span class="hljs-type">NSString</span></span> stringWithFormat:@<span class="hljs-comment"><span class="hljs-comment">"%02ld:%02ld"</span></span>, (long)minutes, (long)seconds]; } - (void)captureOutput:(<span class="hljs-type"><span class="hljs-type">AVCaptureFileOutput</span></span> *)captureOutput didFinishRecordingToOutputFileAtURL:(<span class="hljs-type"><span class="hljs-type">NSURL</span></span> *)outputFileURL fromConnections:(<span class="hljs-type"><span class="hljs-type">NSArray</span></span> *)connections error:(<span class="hljs-type"><span class="hljs-type">NSError</span></span> *)error { if (<span class="hljs-type"><span class="hljs-type">WeAreRecording</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> stopRecording]; } <span class="hljs-type"><span class="hljs-type">BOOL</span></span> <span class="hljs-type"><span class="hljs-type">RecordedSuccessfully</span></span> = <span class="hljs-type"><span class="hljs-type">YES</span></span>; if ([error code] != noErr) { //      ,     , //    ,     id value = [[error userInfo] objectForKey:<span class="hljs-type"><span class="hljs-type">AVErrorRecordingSuccessfullyFinishedKey</span></span>]; if (value != <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) { <span class="hljs-type"><span class="hljs-type">RecordedSuccessfully</span></span> = [value boolValue]; } } if (<span class="hljs-type"><span class="hljs-type">RecordedSuccessfully</span></span>) { //    ,   <span class="hljs-type"><span class="hljs-type">Use</span></span> <span class="hljs-type"><span class="hljs-type">Video</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.useVideoButton.hidden = <span class="hljs-type"><span class="hljs-type">NO</span></span>; } } - (void)viewDidUnload { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidUnload]; <span class="hljs-type"><span class="hljs-type">CaptureSession</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-type"><span class="hljs-type">MovieFileOutput</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-type"><span class="hljs-type">VideoInputDevice</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; } @end</code> </pre><br></div></div><br>  <a href="https://github.com/ValentinStrazdin/VideoRecorder">Here</a> you can find the source code of my project and try how the application works. <br><br>  References to sources: <br><br><ul><li>  <a href="https://developer.apple.com/reference/uikit/uiimagepickercontroller">UIImagePickerController</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation">AVFoundation</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation/avcapturesession">AVCaptureSession</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation/avcapturedevice">AVCaptureDevice</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation/avcapturedeviceinput">AVCaptureDeviceInput</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation/avcapturemoviefileoutput">AVCaptureMovieFileOutput</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation/avcapturevideopreviewlayer">AVCaptureVideoPreviewLayer</a> </li><li>  <a href="https://developer.apple.com/reference/avfoundation/avcapturesession/1669314-video_input_presets">Full list of Video Input Presets</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/316862/">https://habr.com/ru/post/316862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316848/index.html">10 unique Internet entrepreneurs of Russia</a></li>
<li><a href="../316850/index.html">Veeam Availability Suite 9.5 - about updates to Veeam ONE, as well as free NFR keys</a></li>
<li><a href="../316854/index.html">"Performance is a feature." Interview with Marco Cecconi, Stack Overflow</a></li>
<li><a href="../316856/index.html">FIAS addresses in the PostgreSQL environment. Part 4. EPILOGUE</a></li>
<li><a href="../316858/index.html">Testing UWP applications using Appium</a></li>
<li><a href="../316864/index.html">Dive into the blockchain technology: Decentralized password-free security system</a></li>
<li><a href="../316866/index.html">Discuss? Gartner: Virtualization Market Reaches Saturation</a></li>
<li><a href="../316868/index.html">Telegram-bot: my story. Part one</a></li>
<li><a href="../316872/index.html">Testing 15+ virtual hosting for Wordpress or how not to disappear from the Yandex index</a></li>
<li><a href="../316874/index.html">We cover the project with smoke tests until it burns out</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>