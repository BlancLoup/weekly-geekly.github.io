<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparison of logging libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are a lot of Q & A sites in the network where questions from the category are asked: 



- Offer a C ++ logger? (C ++ logging framework suggesti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparison of logging libraries</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/1ea/0fa/f6c/1ea0faf6c174496fa75d81c0f11a00ae.png"><br><br>  There are a lot of Q &amp; A sites in the network where questions from the category are asked: <br><br><ul><li>  Offer a C ++ logger?  (C ++ logging framework suggestions) </li><li>  What is the most efficient thread safe C ++ logger?  (What is the most efficient thread-safe C ++ logger) </li><li>  Logging library for c games </li><li>  Asynchronous thread-safe C ++ logger?  (Asynchronous thread-safe logging in C ++) </li></ul><br>  People share their experience and knowledge, but the format of such sites allows only to show the personal preferences of the respondent.  For example, one of the most productive loggers is most often called Pantheios, which even the manufacturer‚Äôs tests spend more than 100 seconds to write 1M log lines, on modern hardware this is about 30 seconds, is it fast? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I will compare the most famous and well-deserved loggers of recent years and several relatively young loggers by more than 25 criteria. <br><a name="habracut"></a><br><h2>  Motivation </h2><br>  In almost every project I know, logging appeared sooner or later, and the engineers asked themselves ‚Äúhow to solve this problem?‚Äù, Someone rummaged in Q &amp; A sites and got answers ‚ÄúI got a logger X, like normal flight‚Äù (1), someone then he wrote his logger (2), and someone had reserved patience and studied a whole bunch of loggers about their interests and a week later another made his choice (3). <br><br>  This article is for all 3 groups: <br><br><ol><li>  For the first group, this article will give a more extensive comparison of loggers than the recommendation ‚Äúlogger X is the best for me‚Äù </li><li>  For the second group, the article will give an idea of ‚Äã‚Äãthe current level of technology and may tip the scales in the direction of ‚Äúeasier to use ready-made‚Äù or ‚Äúoh, a lot of work, but I can do better‚Äù and who knows, maybe another year we will see a breakthrough in this area. </li><li>  For the third and most pedantic group, I hope this article will save at least one of the 3 weeks of research, across the industry it can be an impressive number of man-hours </li></ol><br>  <b>NB The</b> article is quite voluminous, so if you decide to read, please be patient! <br><br><h2>  Loggers and their basic parameters </h2><br>  The choice of loggers for comparison is a troublesome and not simple matter, in any case the questions will arise: ‚ÄúWhy hasn‚Äôt logger X been considered?‚Äù What can I say, the logic was simple - take 4 well-known loggers and 4 relatively young and ‚Äúhungry.‚Äù <br><br>  But even comparing these 8 candidates took more than 3 weeks of smoking docks, issues, reading forums, writing tests and collecting results. <br><br>  One way or another, if a very important logger was missed, you can update the article.  The review got: <br><br><ol><li>  <a href="http://www.pantheios.org/">Pantheios</a> </li><li>  <a href="https://github.com/google/glog">Glog</a> </li><li>  <a href="http://log4cpp.sourceforge.net/">log4cpp</a> </li><li>  <a href="http://baical.net/p7.html">P7</a> </li><li>  <a href="https://github.com/KjellKod/g3log">G3log</a> </li><li>  <a href="https://github.com/gabime/spdlog">Spdlog</a> </li><li>  <a href="https://github.com/easylogging/easyloggingpp">Easylogging</a> </li><li>  <a href="http://www.boost.org/">Boost.Log (part of the huge Boost library)</a> </li></ol><br>  General characteristics of selected loggers <br><table><tbody><tr><th></th><th>  Persons </th><th>  Languages </th><th>  Update </th><th>  Platf. </th><th>  Comp. </th></tr><tr><th>  Pantheios </th><td>  BSD </td><td>  C ++ </td><td>  <i>2010</i> </td><td>  Windows, * nix, OS-X </td><td>  VC ++, GCC, Intel, Borland, Comeau, Digital Mars, Metrowerks </td></tr><tr><th>  Glog </th><td>  <i>3-clause BSD</i> </td><td>  C ++ </td><td>  2018 </td><td>  Windows, * nix, QNX </td><td>  VC ++, GCC, clang, intel </td></tr><tr><th>  log4cpp </th><td>  LGPL </td><td>  C ++ </td><td>  2017 </td><td>  Windows * nix Solaris </td><td>  VC ++, GCC, Sun CC, OpenVMS </td></tr><tr><th>  P7 </th><td>  LGPL </td><td>  C ++, C, C #, Python </td><td>  2018 </td><td>  Windows * nix </td><td>  VC ++, GCC, clang, MinGW </td></tr><tr><th>  G3log </th><td>  Public Domain </td><td>  C ++ 11 </td><td>  2018 </td><td>  Windows * nix </td><td>  VC ++, GCC, clang </td></tr><tr><th>  Spdlog </th><td>  MIT </td><td>  C ++ 11 </td><td>  2018 </td><td>  Windows, Linux, Solaris, OS-X, Android </td><td>  VC ++, GCC, Clang </td></tr><tr><th>  Easylogging </th><td>  MIT </td><td>  C ++ 11 </td><td>  2018 </td><td>  Windows, Linux, Solaris, OS-X, Android </td><td>  VC ++, GCC, Clang, Intel </td></tr><tr><th>  Boost.Log </th><td>  Boost ( <u>1</u> ) </td><td>  C ++ </td><td>  2016 </td><td>  Windows Linux ( <u>2</u> ) </td><td>  VC ++, GCC, Clang ( <u>3</u> ) </td></tr></tbody></table><br><ol><li>  Own license <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_62_0/libs/log/doc/html/log/installation.html">www.boost.org/doc/libs/1_62_0/libs/log/doc/html/log/installation.html</a> </li><li>  There are a number of other platforms and compilers on which Boost can be compiled, but they are not officially supported and will probably require additional effort. </li></ol><br><h2>  Documentation and dependencies </h2><br>  It is difficult to dispute the importance of documentation for complex projects, modern loggers with simple projects can be called a big stretch and the availability of good documentation sometimes significantly speeds up the introduction and correction of errors: <br><table><tbody><tr><th></th><th>  Documentation </th><th>  Dependencies </th></tr><tr><th>  Pantheios </th><td>  Full (API + usage) </td><td>  STLSoft </td></tr><tr><th>  Glog </th><td>  Rudimentary, almost absent </td><td>  Google gflags, weak dependency ( <u>1</u> ) </td></tr><tr><th>  log4cpp </th><td>  Generated (Doxygen) (API only) </td><td>  Boost, weak dependency ( <u>1</u> ) </td></tr><tr><th>  P7 </th><td>  Full (API + usage) </td><td>  Not </td></tr><tr><th>  G3log </th><td>  Basic (common usage methods) </td><td>  Not </td></tr><tr><th>  Spdlog </th><td>  Basic (common usage methods) </td><td>  No, header file only ( <u>2</u> ) </td></tr><tr><th>  Easylogging </th><td>  Basic (common usage methods) </td><td>  No, header file only ( <u>2</u> ) </td></tr><tr><th>  Boost.Log </th><td>  Basic (common methods of use) plus a basic description of some classes and their methods </td><td>  Boost </td></tr></tbody></table><br><ol><li>  Low dependency - part of the code depends on third-party solutions, but does not prevent compilation, and only partially restricts the functionality. <br><br></li><li>  Header file only - the library is distributed as one or more header files that must be included in each source file of your program; in the case of Easylogging, the compilation speed is significantly reduced.  But there is a way out of this situation - to compile these projects in the form of a library and connect it already, though this will require additional time to create a project. </li></ol><br><h2>  Logger type, memory control and thread safety </h2><br>  At the moment, there are widespread 2 approaches in logging: <br><br><ul><li>  Synchronous - calling Log (..) functions and writing to a file occurs synchronously from one thread </li><li>  Asynchronous - a call to the Log (..) function only updates the message queue, and another thread is writing, thus reducing the call time of the Log (..) function from the user stream, and as a result, the maximum performance of the user stream is reached and the log call delays are minimized (..) functions. </li></ul><br>  However, there are nuances of understanding asynchrony by different manufacturers of logging libraries. <br><br><ol><li>  Type number 1: Some believe that the call to the Log (..) function must be atomic, and thus the order of the log messages in the file will be consistent in time 00:00 -&gt; 00:01 -&gt; 00:02 and so on. <br><br></li><li>  Type # 2: Others believe that in order to achieve maximum performance, you can sacrifice the atomicity of the call to the Log (..) function and accept the fact that the log messages in the file will be intermittent, for example 00:00 -&gt; 00:05 -&gt; 00 : 01. </li></ol><br>  Personally, I adhere to the point of view of the first group on asynchronous logging, since the analysis of mixed logs cannot be pleasantly called, especially if it is a large log file and not single logs are mixed but groups of logs of several hundreds or thousands of elements. <br><br>  Another important aspect of asynchronous logging is control over memory allocation, since in order for your logger to be asynchronous, you must save data in a buffer and write from another thread.  And here the important trifle is hidden - what size of buffers will be optimal and can the user influence this parameter?  The question is not at all idle, as some of the tested loggers allocated hundreds of megabytes for their needs. <br><table><tbody><tr><th></th><th>  Type of </th><th>  Memory control </th><th>  Flow safety </th></tr><tr><th>  Pantheios </th><td>  Synchronous </td><td>  not </td><td>  Yes </td></tr><tr><th>  Glog </th><td>  Synchronous </td><td>  not </td><td>  Yes </td></tr><tr><th>  log4cpp </th><td>  Synchronous </td><td>  not </td><td>  Yes </td></tr><tr><th>  P7 </th><td>  Asynchronous, (type 1) ( <u>2</u> ) </td><td>  exact (in 1Kb increments) </td><td>  Yes </td></tr><tr><th>  G3log </th><td>  Asynchronous, (type 2) ( <u>3</u> ) </td><td>  no ( <u>5</u> ) </td><td>  Yes </td></tr><tr><th>  Spdlog </th><td>  Asynchronous, (type 2) ( <u>3</u> ) </td><td>  partial ( <u>6</u> ) </td><td>  Yes </td></tr><tr><th>  Easylogging </th><td>  Synchronous ( <u>1</u> ) </td><td>  not </td><td>  no ( <u>4</u> ) </td></tr><tr><th>  Boost.Log </th><td>  Synchronous, Asynchronous, (type 2) ( <u>7</u> ) </td><td>  no default ( <u>8</u> ) </td><td>  Yes </td></tr></tbody></table><br><ol><li>  Asynchronous mode is in experimental state. </li><li>  Timestamps and messages are not mixed. </li><li>  Timestamps and messages may be shuffled. </li><li>  The default is not available, you must activate the macro ELPP_THREAD_SAFE </li><li> Uncontrolled memory allocation, with high loads can allocate hundreds of megabytes, author's comment: <a href="https://kjellkod.wordpress.com/2014/08/16/presenting-g3log-the-next-version-of-the-next-generation-of-loggers/">kjellkod.wordpress.com/2014/08/16/presenting-g3log-the-next-version-of-the-next-generation-of-loggers</a> <br><blockquote>  This is a std :: queue is used internally that is a std :: deque.  It is unbounded but much more memory tolerant than a std :: vector.  Internally the queue is wrapped inside the shared_queue.hpp. <br></blockquote><br></li><li>  You can set the queue length in the elements, the size of the element in the initial form - 88 bytes + text message (30-160 bytes).  The author recommends setting the queue size to 1 million messages for optimal performance, which translates into memory consumption from 120 megabytes to 250 megabytes only for the logging library. </li><li>  The order of messages is not guaranteed by the library by default, time stamps can be mixed in the final file when logging from different streams: <a href="http://www.boost.org/doc/libs/1_62_0/libs/log/doc/html/log/rationale/why_weak_record_ordering.html">‚ÄúWhy does the log record have a multithreaded application?‚Äù</a> The author of the library suggests using ‚Äúunbounded_ordering_queue‚Äù to overcome this problem using special .  attribute "RecordID" which will be sorted </li><li>  By default, the library uses ‚Äúunbounded_fifo_queue‚Äù which results in an uncontrollable increase in memory consumption during intensive logging.  It is possible to use with the additional setting ‚Äúbounded_fifo_queue‚Äù.  In this case, you can set the queue length in the elements.  Each element (record in library terminology) occupies about 1KB </li></ol><br><h2>  Process Failure Handling </h2><br>  Proper handling of process failures (crash handling) is primarily important for asynchronous loggers, since  part of the data is stored in buffers and if they are not stored in time, perhaps the most valuable data will be lost right before the failure. <br><br>  Three approaches are common in intercepting falls: <br><br><ul><li>  Automatic, the library itself adjusts all vectors and will do everything itself, a big disadvantage of such a solution is the paucity of intercepted signals, as well as interference for an application that perhaps would like to handle the crash itself in order to save a crash dump file or flush buffers. </li><li>  Manual ‚Äî the library provides primitives for intercepting crashes and flushing buffers, and the application itself decides when and how to install an interceptor and what to do in the event of a crash. </li><li>  Let him fall, everyday life </li></ul><br><table><tbody><tr><th>  Pantheios </th><td>  Not </td></tr><tr><th>  Glog </th><td>  automatic, only under Linux ( <u>1</u> ) </td></tr><tr><th>  log4cpp </th><td>  Not </td></tr><tr><th>  P7 </th><td>  manual and automatic ( <u>2</u> ) </td></tr><tr><th>  G3log </th><td>  automatic, Linux only ( <u>3</u> ) </td></tr><tr><th>  Spdlog </th><td>  No ( <u>4</u> ) </td></tr><tr><th>  Easylogging </th><td>  automatic, only under Linux ( <u>5</u> ) </td></tr><tr><th>  Boost.Log </th><td>  No ( <u>6</u> ) </td></tr></tbody></table><br><ol><li>  The following signals are intercepted: SIGSEGV, SIGILL, SIGFPE, SIGABRT, SIGBUS, SIGTERM. </li><li>  Intercepted following signals: SIGSEGV, SIGILL, SIGFPE, SIGINT, SIGABRT, SIGBUS, SIGTERM, SIGBUS, PureVirtualCall, VectoredException, Newhandler, InvalidParameterHandler, status_access_, exception_array_bounds_exceeded, exception_datatype_misalignment, exception_flt_divide_by_zero, exception_flt_stack_check, exception_illegal_instruction, exception_int_divide_by_zero, exception_noncontinuable_exception, exception_priv_instruction, exception_stack_overflow </li><li>  The following signals are intercepted: SIGSEGV, SIGILL, SIGFPE, SIGABRT, SIGBUS, SIGTERM, Div by zero, illegal printf, out of bounds, access violation, std :: future_error </li><li>  <a href="https://github.com/gabime/spdlog/issues/55">github.com/gabime/spdlog/issues/55</a> - The defect was ‚Äúclosed‚Äù in 2015, i.e.  No work is foreseen in this area. </li><li>  The following signals are intercepted: SIGABRT, SIGFPE, SIGILL, SIGSEGV, SIGINT </li><li>  Even for synchronous mode, there is a risk of data loss in the event of a process failure; in the case of asynchronous mode, the risk of data loss is extremely high. </li></ol><br><h2>  Logging style and output (sink) </h2><br>  The bulk of the libraries supports 2 well-established logging styles: <br><br><ul><li>  Functions with variable argument list (prinf style) </li><li>  Overload of the operator ‚Äú&lt;&lt;‚Äù </li></ul><br><table><tbody><tr><th></th><th>  Style </th><th>  Conclusion (Sink) </th></tr><tr><th width="100">  Pantheios </th><td>  Template + overloaded functions <br>  F (A), F (A, A), F (A, A, A), ... F (A, &lt;-64-&gt;, A) <br>  Printf <br></td><td>  File, syslog, console, speech, ACE, COMerror, WinEventLog <br></td></tr><tr><th>  Glog </th><td>  Log () &lt;&lt; Message </td><td>  File, syslog, console </td></tr><tr><th>  log4cpp </th><td>  Printf, Log () &lt;&lt; Message </td><td>  File, syslog, console, NT log, IDS / A, OsStream, StringQueue, Win32Debug </td></tr><tr><th>  P7 ( <u>6</u> ) </th><td>  Printf </td><td>  Binary file, console, syslog, text file (Linux: UTF8, Windows: UTF-16) network (own protocol and server ( <u>2</u> )), null </td></tr><tr><th>  G3log </th><td>  Printf, Log () &lt;&lt; Message </td><td>  File ( <u>3</u> ) </td></tr><tr><th>  Spdlog </th><td>  Printf ( <u>4</u> ) </td><td>  File, syslog, console </td></tr><tr><th>  Easylogging </th><td>  Printf ( <u>1</u> ), Log () &lt;&lt; Message </td><td>  File, syslog, console </td></tr><tr><th>  Boost.Log </th><td>  Log () &lt;&lt; Message ( <u>5</u> ) </td><td>  File, syslog, console, Win32Debug, WinEventLog, IPC </td></tr></tbody></table><br><ol><li>  In the case of the use of "Printf" generated an exception, this is probably a temporary problem. </li><li>  Own server is used for maximum performance.  The server is free, but unfortunately only supports Windows, apparently based on Qt, a request for Linux support was sent to the author.  The speed of sending logs over the network in the test configuration was about 3.5 million per second when the CPU was loaded - 13%.  Performance tests are discussed in detail in the following chapters. </li><li>  The official delivery does not include Sink with support for file rotation and the console, but these extensions can be downloaded <a href="https://github.com/KjellKod/g3sinks">github.com/KjellKod/g3sinks</a> </li><li>  <a href="https://github.com/fmtlib/fmt">Format string</a> for Printf library functions is not compatible with the canonical format, which significantly complicates the painless replacement of one logger with another </li><li>  Passing a nullptr string as an argument to the logger causes a segmentation fault / access violation </li><li>  Most productive Sink: Binary file, Baical </li></ol><br><h2>  Initialization of logger </h2><br>  Initialization or transfer of parameters is quite an important point because  adds flexibility to the logger and eliminates the need to recompile if you decide to change the logging level for example. <br><table><tbody><tr><th>  Pantheios </th><td>  Manual (code only) </td></tr><tr><th>  Glog </th><td>  Command line, manual, environment variables </td></tr><tr><th>  log4cpp </th><td>  Manual configuration file ( <u>1</u> ) </td></tr><tr><th>  P7 </th><td>  Command line ( <u>2</u> ), manual </td></tr><tr><th>  G3log </th><td>  Manual (code only) </td></tr><tr><th>  Spdlog </th><td>  Manual (code only) </td></tr><tr><th>  Easylogging </th><td>  Configuration file, command line, manual </td></tr><tr><th>  Boost.Log </th><td>  Manual configuration file ( <u>3</u> ) </td></tr></tbody></table><br><ol><li>  Detailed and well-organized setting of the parameters of the logger, perhaps the most extensive of all. </li><li>  In all other loggers, in order for the command line parameters to be processed, you must transfer them to the logger by hand from the int main (int argc, char * argv []) functions.  In this logger, these parameters can be intercepted automatically from any part of the program / module (dll, so). </li><li>  The library provides only the most basic primitives for configuration via the configuration <a href="http://www.boost.org/doc/libs/1_62_0/libs/log/doc/html/log/detailed/utilities.html">file</a> .  A more complete discussion of this issue can be found at the <a href="http://stackoverflow.com/questions/25845154/boost-log-configuration-files">link.</a>  And as a conclusion <blockquote>  This is a list of  <i>It is impossible to give an explicit configuration format description.</i> </blockquote></li></ol><br><h2>  Filtering setup </h2><br>  The most common filtering technique is by logging levels, say if the filter is set to ERROR level - then anything that is less than ERROR (TRACE, DEBUG, INFO, WARNING ...) will not be included in the log.  This method is very useful for screening out a large amount of unnecessary information at the moment and saving the CPU and disk space. <br><table><tbody><tr><th>  Pantheios </th><td>  No ( <u>1</u> ) </td></tr><tr><th>  Glog </th><td>  Command line, manual, environment variables </td></tr><tr><th>  log4cpp </th><td>  Configuration file ( <u>4</u> ), manual </td></tr><tr><th>  P7 </th><td>  Command line, remotely over the network in real time ( <u>2</u> ) ( <u>3</u> ), manual </td></tr><tr><th>  G3log </th><td>  No ( <u>5</u> ) </td></tr><tr><th>  Spdlog </th><td>  Manual </td></tr><tr><th>  Easylogging </th><td>  Manual ( <u>6</u> ) </td></tr><tr><th>  Boost.Log </th><td>  Manual configuration file </td></tr></tbody></table><br><ol><li>  To organize the filter you need to develop your FrontEnd </li><li>  Supported only if the data is sent over the network, in the case of recording to a local file, the server does not have access to the Verbosity level </li><li>  In addition to the global level, you can set the levels for each module. </li><li>  Hierarchical logging and setting of levels individually for each logger </li><li>  By default it is disabled, it is activated by the macro G3_DYNAMIC_LOGGING, then you can manually set the level for all loggers.  Significantly reduces performance. </li><li>  The support is declared by the manufacturer, but it was not possible to get it to work, during use, the impression was that the function was under development or abandoned. </li></ol><br><h2>  Unicode support </h2><br>  This part of the testing was one of the saddest, in 2016 the support of unicode in such well-known libraries is still at the level ‚Äú <a href="https://github.com/gabime/spdlog/issues/100">not officially</a> ‚Äù. <br><br>  The library is needed in order to save important application data (the user's last name, file path, domain name), and most of the existing ones simply will not allow you to do this if the data does not fit into the trivial char. <br><table><tbody><tr><th>  Pantheios </th><td>  Utf-16 ( <u>1</u> ) ( <u>4</u> ), Utf-8 </td></tr><tr><th>  Glog </th><td>  Not </td></tr><tr><th>  log4cpp </th><td>  Not </td></tr><tr><th>  P7 </th><td>  Windows - UTF-16, * nix - UTF-8, UTF-32 </td></tr><tr><th>  G3log </th><td>  Not </td></tr><tr><th>  Spdlog </th><td>  Not </td></tr><tr><th>  Easylogging </th><td>  Windows Utf-16 ( <u>2</u> ), Utf-8 ( <u>3</u> ) </td></tr><tr><th>  Boost.Log </th><td>  UTF-8 partially ( <u>5</u> ) </td></tr></tbody></table><br><ol><li>  Almost perfect, except that the final log file does not have a Unicode marker and the encoding in the viewer will need to be selected by yourself. </li><li>  Support is stated, but not implemented, unicode characters do not fall into the log file. </li><li>  The macro START_EASYLOGGINGPP does not support unicode </li><li>  In a single message, you cannot combine an ANSI string, say with UTF-16 </li><li>  Unicode support is carried out using the Boost.Locale library, impressively wide support is provided for various UTF-8/16/32 formats and other national locales, unfortunately, Boost.Log was only able to get to work with the UTF-8 file format and only using the initialization function synchronous logger "logging :: add_file_log", all other attempts failed and unicode characters did not reach the file, perhaps with enough time, this functionality can be made to work </li></ol><br><h2>  Access to the logger </h2><br>  In modern libraries, the question ‚Äúwho owns the logger‚Äù remains behind the scenes, most often you can write LOG (ERROR) &lt;&lt; ‚ÄúMy message‚Äù and the library takes care of everything itself.  This simplicity is achieved using global variables.  I will leave ethical use of global variables behind the scenes, after all this is a special case, but the simplicity of using a global variable in the case of a simple application turns against the developer of a complex application consisting of many dynamic or static modules. <br><br>  Another option to gain access to the logger is to create the object yourself and control its life cycle. <br><br>  And the last option is a hybrid one, the logger objects are created in manual mode, and then global variables (registry) or shared memory are used, which is common to the whole process including dynamic modules. <br><table><tbody><tr><th>  Pantheios </th><td>  Global variables, automatic initialization </td></tr><tr><th>  Glog </th><td>  Global variables, automatic initialization </td></tr><tr><th>  log4cpp </th><td>  Global variables, automatic and manual initialization </td></tr><tr><th>  P7 </th><td>  Shared memory, manual initialization </td></tr><tr><th>  G3log </th><td>  Global variables, automatic and manual initialization </td></tr><tr><th>  Spdlog </th><td>  Global variables, manual initialization </td></tr><tr><th>  Easylogging </th><td>  Global variables, automatic initialization </td></tr><tr><th>  Boost.Log </th><td>  Global variables, automatic and manual initialization </td></tr></tbody></table><br><h2>  File rotation </h2><br><table><tbody><tr><th>  Pantheios </th><td>  Not </td></tr><tr><th>  Glog </th><td>  The size </td></tr><tr><th>  log4cpp </th><td>  Size ( <u>2</u> ) </td></tr><tr><th>  P7 </th><td>  Time, size ( <u>1</u> ) ( <u>2</u> ) </td></tr><tr><th>  G3log </th><td>  Size, not available by default ( <u>1</u> ) </td></tr><tr><th>  Spdlog </th><td>  Size, time (day) ( <u>1</u> ) </td></tr><tr><th>  Easylogging </th><td>  The size </td></tr><tr><th>  Boost.Log </th><td>  Time, size ( <u>1</u> ) ( <u>2</u> ) </td></tr></tbody></table><br><ol><li>  Each file in the title contains the date and time. </li><li>  Supported option is ‚Äúmax.  number of files "allowing you to store only the last N files </li></ol><br><h2>  Time accuracy </h2><br>  Many of the loggers considered in this article were developed with an eye to high performance, with a potential of millions of messages per second.  But in addition to high speeds, accurate high resolution time stamps are needed, since  If you have a couple of tens or even hundreds of messages in the log file with the same time stamp, this means that some of the information about the execution time has already been lost. <br><table><tbody><tr><th>  Pantheios </th><td>  Windows: 10ms ( <u>1</u> ), custom back-end can help increase accuracy <br>  Linux: theor.  minimum value of 1ns, depending on the hardware <br></td></tr><tr><th>  Glog </th><td>  Windows: 10ms ( <u>1</u> ) <br>  Linux: theor.  minimum value of 1ns, depending on the hardware <br></td></tr><tr><th>  log4cpp </th><td>  Windows: 10ms ( <u>1</u> ) <br>  Linux: theor.  minimum value of 1ns, depending on the hardware <br></td></tr><tr><th>  P7 </th><td>  Windows: 100ns <br>  Linux: theor.  minimum value of 1ns, depending on the hardware <br></td></tr><tr><th>  G3log </th><td>  Windows: 1ms <br>  Linux: 1us <br></td></tr><tr><th>  Spdlog </th><td>  Windows: 1ms <br>  Linux: theor.  minimum value of 1ns, depending on the hardware <br></td></tr><tr><th>  Easylogging </th><td>  Windows: 1ms <br>  Linux: 1us <br></td></tr><tr><th>  Boost.Log </th><td>  Windows: 10ms ( <u>1</u> ) <br>  Linux: theor.  minimum value of 1ns, depending on the hardware <br></td></tr></tbody></table><br><ol><li>  Sometimes you can get a granularity of 1 millisecond, but much more often a quantum is 10 milliseconds. </li></ol><br><h2>  Performance </h2><br>  Many loggers from the list in this article state that performance is one of their top priorities. <br><br>  I took this statement more than seriously and conducted a series of tests: <br><br><ul><li>  in default configuration </li><li>  in terms of equal memory usage </li><li>  in single stream mode </li><li>  in multi-thread mode </li></ul><br>  <i>For each test, the time and CPU spent by the logger on saving 1 million messages to a file are measured.</i>  3 measurements are taken and average values ‚Äã‚Äãare calculated. <br><br>  We also conducted tests in debug (optimization disabled) and release (optimization O2) assembly.  The following configuration was used for the tests: <br><br><ul><li>  Window 7x64 (6.1.7601 Service Pack 1 Build 7601) </li><li>  Visual studio 2015, update 2 </li><li>  RAM: 16Gb (DDR3-1600 / PC3-12800) </li><li>  CPU: Intel Core i7-870 </li><li>  HDD: Samsung EVO SSD 850 256GB (SATA3) </li></ul><br>  In order to bring the tests closer to actual use, the following information was saved for each log message: <br><br><ul><li>  Message number </li><li>  Source file name </li><li>  Code line number </li><li>  Source function name </li><li>  Logger / Module Name </li><li>  Level (error, warning, ...) </li><li>  Time </li><li>  Current thread ID (thread Id) </li><li>  CPU core number </li><li>  Text message </li></ul><br>  The code that was executed for each logger (requires C ++ 11 support for compilation): <br><br><div class="spoiler">  <b class="spoiler_title">Source text</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include &lt;vector&gt; //Include specific logger headers #include "Logger headers ..." using namespace std; using namespace std::chrono; //Use this macro to switch on multi-threading mode //#define MULTI_THREAD int main(int argc, char* argv[]) { //Logger initialization //.. unsigned int thread_count = 4; unsigned int howmany = 1'000'000; vector&lt;thread&gt; threads; auto start = system_clock::now(); #if !defined(MULTI_THREAD) for(unsigned int i=0; i &lt; howmany; i++) { //Has to be customized for every logger LOG(INFO) &lt;&lt; " Message + all required information, #" &lt;&lt; i; } #else howmany /= thread_count; for (int t = 0; t &lt; thread_count; ++t) { threads.push_back(std::thread([&amp;] { for(unsigned int i=0; i &lt; howmany; i++) { //Has to be customized for every logger LOG(INFO) &lt;&lt; " Message + all required information, #" &lt;&lt; i; } })); } for(auto &amp;t:threads) { t.join(); }; howmany *= thread_count; #endif auto delta = system_clock::now() - start; auto delta_d = duration_cast&lt;duration&lt;double&gt;&gt; (delta).count(); LOG(INFO) &lt;&lt; "Time = " &lt;&lt; (double)howmany / delta_d &lt;&lt; " per second, total time = " &lt;&lt; delta_d; //Logger uninitialization if necessary return 0; }</span></span></span></span></code> </pre> <br></div></div><br><h3>  <u>One thread</u> </h3><br>  One thread should save 1 million messages to a file, filtering is disabled, file rotation is disabled.  Runtime and average CPU utilization are measured. <br><table><tbody><tr><th></th><th>  Debug <br>  Time (ms) </th><th>  Debug <br>  CPU (%) </th><th>  Release <br>  Time (ms) </th><th>  Release <br>  CPU (%) </th></tr><tr><th>  Pantheios </th><td>  140 300 </td><td>  13% </td><td>  28,400 </td><td>  13% </td></tr><tr><th>  Glog </th><td>  52 500 </td><td>  13% </td><td>  8,270 </td><td>  13% </td></tr><tr><th>  log4cpp </th><td>  130 570 </td><td>  13% </td><td>  13,806 </td><td>  13% </td></tr><tr><th>  P7 ( <u>1</u> ) ( <u>2</u> ) ( <u>6</u> ) </th><td>  520 </td><td>  14% </td><td>  100 </td><td>  14% </td></tr><tr><th>  G3log ( <u>1</u> ) ( <u>3</u> ) </th><td>  102 990 </td><td>  38% </td><td>  3,660 </td><td>  37% </td></tr><tr><th>  Spdlog ( <u>1</u> ) ( <u>4</u> ) </th><td>  64,250 </td><td>  13% </td><td>  869 </td><td>  13% </td></tr><tr><th>  Spdlog ( <u>1</u> ) ( <u>5</u> ) </th><td>  65,660 </td><td>  13% </td><td>  885 </td><td>  13% </td></tr><tr><th>  Easylogging </th><td>  271,060 </td><td>  13% </td><td>  9,100 </td><td>  13% </td></tr><tr><th>  Boost.Log ( <u>1</u> ) ( <u>7</u> ) </th><td>  2 310 200 </td><td>  17% </td><td>  44 300 </td><td>  9% </td></tr><tr><th>  Boost.Log ( <u>1</u> ) ( <u>8</u> ) </th><td>  649 480 </td><td>  25% </td><td>  12,680 </td><td>  25% </td></tr></tbody></table><br><ol><li>  Asynchronous logging </li><li>  Compiled with the option ‚Äú/P7.Pool=1024‚Äù - the total amount of available memory is 1 megabyte. </li><li>  Measurements can be considered synthetic, since most of the time the logger adds the data to the buffers, and recording occurs upon exiting the application and this work takes time exceeding the logging time by an order of magnitude, 1 second logging and 10 seconds of saving data. </li><li>  Logging under the conditions recommended by the manufacturer ‚Äúspdlog :: set_async_mode (1048576)‚Äù while the logger consumes about 250 megabytes of memory </li><li>  Logging in conditions of equal memory consumption ‚Äúspdlog :: set_async_mode (4096)‚Äù - in this case, the logger has a buffer of 4k elements, each element takes about 250 bytes, which ultimately results in a memory consumption of about 1 megabyte. </li><li>  Recording was carried out in a binary file, text in UTF-16 format </li><li>  Logging in conditions of equal memory consumption (asynchronous_sink + text_file_backend + bounded_ordering_queue + block_on_overflow), the queue length is 1024 elements, each element takes about 1100 bytes, which ultimately results in a memory consumption of just over 1 megabyte </li><li>  Synthetic test.  Logging in the most comfortable conditions, default logger configuration (asynchronous_sink + text_file_backend + unbounded_fifo_queue).  There are no restrictions in memory consumption, there is no sorting of messages in the order of receipt, the <i>memory consumption was fixed at 1.8GB</i> </li></ol><br><h3>  <u>4 threads</u> </h3><br>  4 threads should save 1 million messages to a file in total, filtering is disabled, file rotation is disabled. <br><br>  Runtime and average CPU utilization are measured. <br><table><tbody><tr><th></th><th>  Debug <br>  Time (ms) </th><th>  Debug <br>  CPU (%) </th><th>  Release <br>  Time (ms) </th><th>  Release <br>  CPU (%) </th></tr><tr><th>  Pantheios </th><td>  10,600 </td><td>  48% </td><td>  9 500 </td><td>  48% </td></tr><tr><th>  Glog </th><td>  30,200 </td><td>  93% </td><td>  5,900 </td><td>  93% </td></tr><tr><th>  log4cpp </th><td>  149 600 </td><td>  18% </td><td>  16 900 </td><td>  nineteen% </td></tr><tr><th>  P7 ( <u>1</u> ) ( <u>2</u> ) ( <u>6</u> ) </th><td>  790 </td><td>  nineteen% </td><td>  230 </td><td>  nineteen% </td></tr><tr><th>  G3log ( <u>1</u> ) ( <u>3</u> ) </th><td>  39,700 </td><td>  75% </td><td>  2,300 </td><td>  75% </td></tr><tr><th>  Spdlog ( <u>1</u> ) ( <u>4</u> ) </th><td>  11,510 </td><td>  13% </td><td>  270 </td><td>  25% </td></tr><tr><th>  Spdlog ( <u>1</u> ) ( <u>5</u> ) </th><td>  73,240 </td><td>  25% </td><td>  4,653 </td><td>  25% </td></tr><tr><th>  Easylogging </th><td>  328 230 </td><td>  nineteen% </td><td>  8 575 </td><td>  25% </td></tr><tr><th>  Boost.Log ( <u>1</u> ) ( <u>7</u> ) </th><td>  2 645 120 </td><td>  14% </td><td>  48,290 </td><td>  14% </td></tr><tr><th>  Boost.Log ( <u>1</u> ) ( <u>8</u> ) </th><td>  655 470 </td><td>  65% </td><td>  13,560 </td><td>  65% </td></tr></tbody></table><br><ol><li>  Asynchronous logging </li><li>  Compiled with the option ‚Äú/P7.Pool=1024‚Äù - the total amount of available memory is 1 megabyte. </li><li>  Measurements can be considered synthetic, since most of the time the logger adds the data to the buffers, and recording occurs upon exiting the application and this work takes time exceeding the logging time by an order of magnitude, 1 second logging and 10 seconds of saving data. </li><li>  Logging under the conditions recommended by the manufacturer ‚Äúspdlog :: set_async_mode (1048576)‚Äù while the logger consumes about 250 megabytes of memory </li><li>  Logging in conditions of equal memory consumption ‚Äúspdlog :: set_async_mode (4096)‚Äù - in this case, the logger has a buffer of 4k elements, each element takes about 250 bytes, which ultimately results in a memory consumption of about 1 megabyte. </li><li>  Recording was carried out in a binary file, text in UTF-16 format </li><li>  Logging in conditions of equal memory consumption (asynchronous_sink + text_file_backend + bounded_ordering_queue + block_on_overflow), the queue length is 1024 elements, each element takes about 1100 bytes, which ultimately results in a memory consumption of just over 1 megabyte </li><li>  Synthetic test.  Logging in the most comfortable conditions, default logger configuration (asynchronous_sink + text_file_backend + unbounded_fifo_queue).  There are no restrictions in memory consumption, there is no sorting of messages in the order of receipt, the <i>memory consumption was fixed at 1.8GB</i> </li></ol><br><h3>  <u>Filtration</u> </h3><br>  The logger should process 1 million messages and filter them, i.e.  In the final file will not get any 1 message. <br><br>  Measurement time is measured. <br><table><tbody><tr><th></th><th>  Debug <br>  1 thread, time (ms) </th><th>  Debug <br>  4 threads, time (ms) </th><th>  Release <br>  1 thread, time (ms) </th><th>  Release <br>  4 threads, time (ms) </th></tr><tr><th>  Pantheios ( <u>1</u> ) </th><td>  - </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><th>  Glog </th><td>  55 520 </td><td>  28,240 </td><td>  6,840 </td><td>  4,790 </td></tr><tr><th>  log4cpp </th><td>  200 </td><td>  70 </td><td>  80 </td><td>  45 </td></tr><tr><th>  P7 </th><td>  84 </td><td>  102 </td><td>  23 </td><td>  42 </td></tr><tr><th>  G3log </th><td>  5 530 </td><td>  1950 </td><td>  24 </td><td>  9 </td></tr><tr><th>  Spdlog </th><td>  269 </td><td>  134 </td><td>  6 </td><td>  32 </td></tr><tr><th>  Easylogging ( <u>2</u> ) </th><td>  - </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><th>  Boost.Log </th><td>  26,407 </td><td>  8,554 </td><td>  699 </td><td>  389 </td></tr></tbody></table><br><ol><li>  Filtering is not available by default. </li><li>  Couldn't make filtering work </li></ol><br><h3>  <u>Performance review</u> </h3><br>  The performance of many loggers was very good. <br>  Unfortunately, almost all loggers except P7 have a huge performance gap between the debug and release builds, sometimes the coefficient reaches 74 (Spdlog: 65660/885).  This can complicate debugging projects due to increased logging delays. <br><br>  The tests performed in a certain sense can be called synthetic, since not one developer who implements a logging library into her application does not want it to allocate 250 megabytes of memory for its needs or consume 75% of CPU or more. <br><br>  Typically, an integrator developer wants the library to be invisible and do its job with minimal hardware requirements, especially when it comes to small embedded systems. <br><br>  Therefore, I recalculated the best performance of each logger ( <u>tests with equal memory consumption</u> ) in order to determine how many message logs can be written using only 1% CPU and a reasonable but still large amount of memory equal to 1mb <br><br>  The formula for calculating: <br><blockquote>  ((1,000 ms / test time in ms) * 1,000,000 messages) / use CPU in the test </blockquote><br><table><tbody><tr><th></th><th>  Number of messages per second with 1% CPU </th></tr><tr><th>  P7 </th><td>  714,285 messages (1,000,000 * (1,000 / 100 ms) / 14%) </td></tr><tr><th>  Spdlog </th><td>  86,918 messages (1,000,000 * (1,000 / 885 ms) / 13%) </td></tr><tr><th>  Glog </th><td>  9 301 messages (1000000 * (1000/8270 ms) / 13%) </td></tr><tr><th>  Easylogging </th><td>  8,453 messages (1,000,000 * (1,000 / 9,100 ms) / 13%) </td></tr><tr><th>  G3log </th><td>  7,384 messages (1,000,000 * (1,000 / 3,660 ms) / 37%) </td></tr><tr><th>  log4cpp </th><td>  5,571 messages (1,000,000 * (1,000 / 13,806 ms) / 13%) </td></tr><tr><th>  Pantheios </th><td>  2,708 messages (1,000,000 * (1,000 / 28,400 ms) / 13%) </td></tr><tr><th>  Boost.Log </th><td>  2 508 messages (1000000 * (1000/44300 ms) / 9%) </td></tr></tbody></table><br><br><h2>  findings </h2><br><h3>  <u>Pantheios</u> </h3><br>  This library made quite mixed impressions, on the one hand, the author approached the project thoroughly and thoughtfully, good functional reviews, documentation, on the other hand poor performance (although the author notes the opposite (1)), the lack of file rotation and other trifles spoil the overall impression. <br><br>  So, the advantages of the library: <br><ul><li>  Type-safe pattern-based calls </li><li>  Good and complete documentation. </li><li>  One of the few loggers that supports unicode, but with some limitations </li><li>  Low memory consumption </li><li>  A large number of supported Sink </li><li>  A large number of supported compilers </li></ul><br>  Minuses: <br><ul><li>  Development seems to be stopped </li><li>  Static linking during compilation of the logger and sink (file, network, etc.) </li><li>  Incredibly long compilation even on powerful computers and as a mediated result - the size of binary files </li><li>  One of the lowest performance indicators of all loggers reviewed. </li><li>  Logger configuration in code only (no configuration file support, command line ...) </li><li>  No file rotation support </li><li>  Synchronous execution, i.e.  all delays Sink (write to the file for example) will affect the speed of execution of your code. </li><li>  It is not possible to combine unicode and ANSI strings within a single message. </li><li>  High threshold of entry (difficult enough to learn and confusing) </li></ul><br><ol><li>  C ++ <a href="http://www.pantheios.org/essentials.html">Diagnostic Logging Critical Diagnostic Logging Cards</a> (up to two orders of magnitude) <a href="http://www.pantheios.org/essentials.html">www.pantheios.org/essentials.html</a> </li></ol><br>  <b>NB: The</b> library is one of the largest and most complex of all compared, so it is likely that many of its features have not been considered. <br><br><h3>  <u>Glog</u> </h3><br>  Despite the fact that the library is rather poor in functionality and does not shine with performance, but this library has inspired a number of other projects that have outgrown its ‚Äúfather‚Äù count to the head.  Only this is already a fat plus in the karma of the authors. <br><br>  Advantages of the library: <br><ul><li>  Easy-to-understand library </li><li>  Process failure support </li><li>  Ability to configure via the command line </li><li>  Low memory consumption </li></ul><br>  Minuses: <br><ul><li>  Very weak documentation </li><li>  Weak support for process failures - limited signals, only Linux </li><li>  High overhead when filtering messages </li><li>  Repeated gap (up to 9 times) in performance of Debug and Release code </li><li>  Synchronous execution, i.e.  all delays Sink (write to the file for example) will affect the speed of execution of your code. </li><li>  Active development suspended </li><li>  No unicode support </li><li>  Timestamp accuracy is insufficient </li><li>  Highest CPU consumption in multi-threading tests with a very modest logger performance gain compared to thread 1 </li></ul><br><br><h3>  <u>log4cpp</u> </h3><br>  Another well-deserved logger made a pretty good impression, no big disappointments, no high-profile promotions, no unfulfilled promises. <br><br>  Advantages of the library: <br><ul><li>  Generated documentation </li><li>  A large number of supported Sink </li><li>  Low memory consumption </li><li>  Configuration file support </li><li>  Good message filtering performance </li></ul><br>  Minuses: <br><ul><li>  Synchronous execution, i.e.  all delays Sink (write to the file for example) will affect the speed of execution of your code. </li><li>  No unicode support </li><li>  Repeated gap (up to 10 times) in performance of Debug and Release code </li><li>  Low performance (last place) </li><li>  Line size should not exceed 1024 characters - otherwise assertion </li><li>  If the path to the log files does not exist, an exception is generated. </li></ul><br><br><h3>  <u>P7</u> </h3><br>  One of the most unusual loggers among those considered in this article, the package includes not only a logger, but also a server for receiving messages over the network, viewing log files, filtering, exporting, verbosity remotely and many other functions.  As in the case of SpdLog, the sight was on performance and the ability to use on embedded devices, as the project is sharpened on the network and precise memory management. <br>  It should also be noted that in the case of using Sink = FileBin or Sink = Baical, the project provides free software for network reception, viewing, filtering, etc.: <div class="spoiler">  <b class="spoiler_title">soft</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/695/1e5/389/6951e53894e4018c2769e222394d4fd4.png" alt="image"></div></div><br><br>  Advantages of the library: <br><ul><li>  Complete documentation </li><li>  High performance + high precision timestamps, a large lead over the closest competitor SpdLog </li><li>  Unicode support </li><li>  Full control over memory consumption </li><li>  Asynchronous - the call to the Log function is independent of the data record, thus delaying the call to the function. </li><li>  Using Shared memory (instead of ‚Äúglobal‚Äù variables) to access loggers and Sink, which allows you to access the logger from any parts of the process code, even from dynamic modules written in other languages ‚Äã‚Äãsupported by the library, such as C # or C </li><li>  The kit includes wrappers for C, C #, Python </li><li>  In addition to logs, the library supports recording and monitoring in real time. <br><div class="spoiler">  <b class="spoiler_title">telemetry</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/32f/9ef/e04/32f9efe046e5de0738f195e1452228c6.png" alt="image"></div></div></li><li>  The ability to control remotely (via the network) the logging level on each device, process or module, enable / disable telemetry counters </li><li>  Of all the considered loggers, there is a minimum processor requirement in terms of performance. </li><li>  Available for several languages ‚Äã‚Äãand if different parts of the application are written in C #, C ++, C, they can all use the same logger </li><li>  Easy to connect your own Text Sink </li><li>  Wide selection of Sink </li><li>  The Baical server core is an open source project and can be compiled under Windows, Linux 32/64 </li></ul><br>  Minuses: <br><ul><li>  Highly intensive use of a multi-stream logger reduces (by a factor of 2.3) the performance of the logger (charge for a sequence of log messages and timestamps) </li><li>  Developing your own binary binary data Sink </li><li>  Due to the serialization of the log messages, it is not possible to load all the processor cores evenly </li></ul><br><br><h3>  <u>G3log</u> </h3><br>  The heir to G2Log which in turn was the result of a rethinking of Glog.  The author pursued first of all the performance and conducts a rather active educational work on this subject ( <u>1</u> ) ( <u>2</u> ).  Unfortunately, the performance tests turned out to be synthetic, and the result was far from expectations. <br><br>  Advantages of the library: <br><ul><li>  Good filtration rate </li><li>  Handling process failures (generation of stack trace when information is available), unfortunately only under Linux </li><li>  Overall satisfactory documentation </li><li>  Asynchronous - the call to the Log function is independent of the data record, thus delaying the call to the function. </li></ul><br>  Minuses: <br><ul><li>  No unicode support </li><li>  Poor performance, with high CPU consumption </li><li>  Performance measurements can be considered synthetic, since most of the time the logger puts the data into buffers, and the recording occurs upon exiting the application and this work takes time exceeding the logging time by an order of magnitude </li><li>  Full asynchrony - timestamps and messages can be mixed in groups or one at a time with intensive logging </li><li>  Uncontrolled memory allocation reaching hundreds of megabytes, sometimes gigabytes with intensive logging </li><li>  Logger configuration by code only </li><li>  Timestamp accuracy is insufficient </li><li>  Repeated gap (up to 30 times) in performance of Debug and Release code </li><li>  High CPU consumption </li><li>  Compilers with C ++ 11 or higher </li></ul><br><br><ol><li>  <a href="https://kjellkod.wordpress.com/2014/08/16/presenting-g3log-the-next-version-of-the-next-generation-of-loggers/">kjellkod.wordpress.com/2014/08/16/presenting-g3log-the-next-version-of-the-next-generation-of-loggers</a> </li><li>  <a href="https://kjellkod.wordpress.com/2015/06/30/the-worlds-fastest-logger-vs-g3log/">kjellkod.wordpress.com/2015/06/30/the-worlds-fastest-logger-vs-g3log</a> </li></ol><br><br><h3>  <u>Spdlog</u> </h3><br>  Another logger written with an eye to performance, unfortunately good performance can only be obtained when using hundreds of megabytes of RAM.  The functionality is standard for many other loggers, the main focus is speed. <br><br>  Advantages of the library: <br><ul><li>  Overall satisfactory documentation </li><li>  Not exacting to the processor </li><li>  Asynchronous - the call to the Log function is independent of the data record, thus delaying the call to the function. </li><li>  Partial control of memory consumption </li><li>  Good set of helper macros </li><li>  Speed, second place in the overall standings, but the backlog from the first place is a colossal </li></ul><br>  Minuses: <br><ul><li>  No process failure handling </li><li>  <a href="https://github.com/fmtlib/fmt">The format string</a> for Printf library functions is incompatible with the canonical format, which makes it difficult to painlessly replace one logger with another, in fact it‚Äôs a one-way ticket </li><li>  Full asynchrony - timestamps and messages can be mixed in groups or one at a time with intensive logging in the final file </li><li>  For optimal performance, it consumes about 250-300 megabytes of RAM, while reducing the amount of memory, performance decreases by almost 18 times. </li><li>  No unicode support </li><li>  Only header files that I attribute to minus, since the inclusion of these files in each file of your project significantly slows down the compilation, it is possible to use precompiled headers </li><li>  Logger configuration in code only </li><li>  Accuracy of timestamps is insufficient, especially in the light of achieved performance (tens and hundreds of thousands of messages per second with a timestamp resolution of 1ms) </li><li>  Compilers with C ++ 11 or higher </li><li>  Multiple break (up to 74 times) in performance of Debug and Release code </li></ul><br><br><h3>  <u>Easylogging</u> </h3><br>  Logger with a light-weight target, single header file (about 6700 lines of code).  The functionality is standard for many other loggers. <br><br>  Advantages of the library: <br><ul><li>  Overall satisfactory documentation </li><li>  Not exacting to the processor </li><li>  Moderate memory consumption </li><li>  Good set of helper macros </li><li>  Support configuration file command line </li><li>  Declared a large number of supported platforms </li></ul><br>  Minuses: <br><ul><li>  Synchronous execution, i.e.  all delays Sink (write to the file for example) will affect the speed of execution of your code. </li><li>  Poor performance </li><li>  Failed to start filtering, perhaps the option is under development </li><li>  Unicode support is declared, but in fact Unicode characters do not reach the file and are lost on the way. </li><li>  Only the header file, which I attribute to the minus, since including it in each file of your project slows down the compilation significantly, it is possible to use precompiled headers </li><li>  Timestamp accuracy is insufficient </li><li>  Compilers with C ++ 11 or higher </li><li>  Multiple break (up to 40 times) in performance of Debug and Release code </li><li>  It is necessary to enable thread-safety with a special macro (ELPP_THREAD_SAFE), disabled by default </li></ul><br><br><h3>  <u>Boost.Log</u> </h3><br>  Logger with an eye on functionality, simplicity, as well as performance, such priorities and goals are pursued by the author: <a href="http://www.boost.org/doc/libs/1_62_0/libs/log/doc/html/index.html">motivation.</a> <br>  We must pay tribute, the project has been developing for almost 9 years and is present in such a large project as Boost. <br><br>  Advantages of the library: <br><ul><li>  Support for synchronous and asynchronous logging (calling the Log function is independent of writing data, thus delaying the call to the function) </li><li>  Good enough documentation covering basic needs. </li><li>  Log record attributes (stream number, source file, counters, etc.) simplify logging </li><li>  Supported per sink formatting </li><li>  Ability to use predicates to filter </li><li>  Declared a large number of supported Sink </li><li>  Unicode support </li><li>  Configuration file support </li></ul><br>  Minuses: <br><ul><li>  One of the most complex and confusing logging libraries presented in this article.  Entirely built on a mixture of complex macros and templates.  The study was spent the most time.  Even more time is spent on learning "under the hood", perhaps therefore one of the main participants is only one <a href="https://github.com/boostorg/log/graphs/contributors">person.</a> </li><li>  Lowest performance of all loggers reviewed </li><li>  Segmentation fault / access violation when executing code <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pStr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶. BOOST_LOG_SEV(lg, trace) &lt;&lt; pStr;</span></span></code> </pre></li><li>  Accuracy of time marks is not enough, although with such a performance it is not so critical (up to a dozen messages in one time period) </li><li>  Repeated gap (up to 54 times) in the performance of the Debug and Release code, it should be noted that in Debug mode, the execution time becomes completely unacceptable (tens of minutes for logging) </li><li>  Unicode support does not appear to be well-tested functionality (could not be started for asynchronous logging to a file with sorting and fixed-size FIFO) </li><li>  There is no handling of process failures, in the light of the fact that storing data buffers is important even for a synchronous logger ‚Äî represents a significant risk of losing important data. </li><li>  Log record attributes are not trivial - for example, the name of the source function, file, line number.  Creating your own attributes is also not a trivial task. </li><li>  Tangled compilation with its utilities, but it should be noted that the same compiled binaries are supplied, the problem is common to the whole Boost </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Including a library into your project significantly slows down compilation and linking (even when using precompiled headers) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All parts of the library code are covered by the generation of exceptions, however, you can set your own interceptor, which reduces inconvenience for people who prefer not to catch exceptions from the logger during each call. </font></font></li></ul><br><br><h2>  Total </h2><br>  Attention! <div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subjective opinion of the author.</font></font></b> <div class="spoiler_text"><ul><li> Pantheios ‚Äî      ,   ,   ,                </li><li> Glog ‚Äî     ,          ,        .               ‚Äî    ,    . </li><li> Log4cpp ‚Äî    ,  -   ( ,   )           ,   /. </li><li> P7 ‚Äî  ,            embedded   .   ,      ,  ,           (      home ).  ‚Äì  ,   .    ,     ( Sink     )          (5-7) </li><li> G3Log, SpdLog ‚Äî             ,       ,   ‚Äì               </li><li> Easylogging ‚Äî           ,       ,           </li><li> Boost.Log ‚Äî    ,                 ,           -  , ,       nullptr  .      ,                -           . </li></ul><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thank you very much for your attention and your time, I hope this article has helped you in drawing up a general idea of ‚Äã‚Äãthe realities of modern loggers. </font></font></div><p>Source: <a href="https://habr.com/ru/post/313686/">https://habr.com/ru/post/313686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313676/index.html">Determine the user's location by IP and create a hit counter</a></li>
<li><a href="../313678/index.html">Cyber-grouping Sednit activities under a microscope - Part 2</a></li>
<li><a href="../313680/index.html">We control the standard Sailfish OS player using voice commands</a></li>
<li><a href="../313682/index.html">As I wrote the game for the contest, or the wonderful transformation of "Lines" into "Sea battle"</a></li>
<li><a href="../313684/index.html">Selection of useful materials on DevOps</a></li>
<li><a href="../313688/index.html">Two-factor authentication and open doors</a></li>
<li><a href="../313690/index.html">The cellars of the Tower of Babel, or the internationalization of databases with access through ORM</a></li>
<li><a href="../313692/index.html">Connecting the ADC to the FPGA. Features, complexity, implementation</a></li>
<li><a href="../313694/index.html">History of programming languages: C # - ahead of the rest</a></li>
<li><a href="../313696/index.html">[Bookmark] Zoo neural network architectures. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>