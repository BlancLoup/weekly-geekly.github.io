<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multifunctional GPSLogger do it yourself. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am the owner of a wonderful device - Holux M-241 GPS logger. Stuck very comfortable and useful in traveling. With the help of the logger, I write a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multifunctional GPSLogger do it yourself. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/geektimes/post_images/65a/f4c/1c8/65af4c1c8bd4dd394b6a6d2939c6d211.jpg" alt="image"><br><br>  I am the owner of a wonderful device - Holux M-241 GPS logger.  Stuck very comfortable and useful in traveling.  With the help of the logger, I write a GPS track of the trip, on which you can then look at your path in detail, as well as attach the captured photos to GPS coordinates.  And he has a small screen that shows additional information - the clock, current speed, altitude and direction, odometer and more.  <a href="http://grafalexphoto.livejournal.com/10901.html">Here</a> I once wrote a small review. <br><br>  With all the virtues of a piece of iron, I began to grow out of it.  I miss a few small but useful buns: a few odometers, showing vertical speed, measuring the parameters of the section of the path.  It seems a trifle, but the Holux company considered this not sufficiently useful for implementation in the firmware.  I also do not like some of the parameters of the piece of iron, and some things have become morally obsolete in 10 years ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At some point, I realized that I can make a logger myself with such features as I need.  Fortunately, all the necessary components are cheap and affordable.  I began to make my implementation based on Arduino.  Under the cut diary built where I tried to paint my technical solutions. <br><a name="habracut"></a><br><h1>  We are determined with features </h1><br>  Many will ask why I need to build my own logger, if for certain there is something ready from famous manufacturers.  Maybe.  To be honest, not particularly looking for.  But for sure there will be something missing.  In any case, this project is a fan for me.  Why don't we go about building our dream device? <br><br>  So, for what I appreciate my Holux M-241. <br><br><ul><li>  <b>The screen</b> makes of ‚Äúblack box‚Äù, the results of which are available only after the trip, a very convenient tool, the readings of which are available here and now.  The presence of the screen makes possible almost all the features in this list. </li><li>  <b>The clock</b> is useful in itself.  When traveling by GPS, a logger dangling on a string around its neck often turns out to be closer than a mobile phone in a pocket or backpack.  The watch supports all time zones (albeit with manual switching) </li><li>  <b>The POI button</b> allows you to mark the current coordinate on the track.  For example, to note a landmark that shed outside the bus, about which you want to google later. </li><li>  Using the <b>odometer,</b> you can measure the distance traveled from a point.  For example, the distance traveled per day, or the length of a track. </li><li>  <b>Current speed, height and direction</b> help you find yourself in space. </li><li>  <b>The vitality of 12-14 hours</b> from one AA battery in most cases makes it possible not to think about power supply issues.  Those.  almost always enough charge for a full day of travel. </li><li>  <b>Compactness and ease of use</b> - things in the modern world are very pleasant </li></ul><br>  However, some things could be done a little better: <br><br><ul><li>  The power supply system on <b>AA batteries is</b> recorded by many as a definite plus ‚Äî one battery lasts a long time, and you can stock up in any wilderness.  You can even for a month of autonomous campaign stock up. <br><br>  But for me, battery life is hemorrhoids.  We have to carry a handful of batteries and who knows how good they are (all of a sudden they were 5 years old on the shelf and were already self-discharged).  With batteries hemorrhoids even more.  My charger can only charge in pairs.  You have to discharge the batteries so that they are of the same degree of discharge.  As a result, you never remember where already discharged, and where not yet. <br><br>  For 6 years of using the logger, I only found myself in the wilderness a couple of times without electricity.  As a rule, I have access to the outlet at least once a day.  In this case, the built-in lithium battery would be much more convenient.  Well, in extreme cases, I have a paverbank. <br><br></li><li>  <b>Indication of the degree of discharge is</b> made very stupidly - the indicator starts to flash when the battery is about to run out.  With that, after 5 minutes it can already die, and maybe another hour to work.  It is very easy to miss this moment and lose part of the log. <br><br></li><li>  As a person interested in aviation, it would be very interesting for me to observe the <b>current vertical speed</b> . <br><br></li><li>  <b>Multiple odometers</b> - it is often interesting to measure more than one distance.  For example, the distance traveled per day and for the entire trip. <br><br></li><li>  The odometer is reset when the device is turned off or when the battery is replaced.  This is terribly uncomfortable.  If you stop at a cafe to eat, then the GPS logger can not be turned off because the value will be reset.  We have to leave it on, and he continues to wind kilometers and eat the battery.  It would be much more convenient to be able to <b>pause the</b> odometer and <b>save the values</b> between inclusions. <br><br></li><li>  <b>Measurement of parameters of the site</b> .  While skiing, for example, I am interested in the length of the descent, the elevation difference, the average and maximum speed on the site, and the elapsed time.  At what you want to know it right away, and not at home when you download the track. <br><br></li><li>  <b>Accuracy</b> leaves much to be desired.  When you move quickly - nothing yet.  But when the speed is small, the ‚Äúnoises‚Äù + - 50m are clearly visible on the track.  And for an hour of standing you can ‚Äúinsist‚Äù almost a kilometer.  The benefit of technology for 10 years has gone far ahead and modern receivers provide much greater accuracy. <br><br></li><li>  <b>The speed of merging</b> tracks is only 38400. No, well, it is not serious in 2017 to use the COM port for transferring large amounts of data.  Merging 2 megabytes of internal flash takes more than 20 minutes. <br><br>  In addition, not every program can gobble up the format of the merged tracks.  The native utility is very poor.  The benefit is BT747, which can adequately merge the track and convert it to some kind of digestible format. <br><br></li><li>  <b>The size of the stick is</b> only 2Mb.  On the one hand, this is enough for a two-week trip with points saved every 5 s.  But first, the internal packed format <br>  requires conversion, and secondly it does not allow to increase the volume </li><li>  <b>Mass storage device</b> for some reason is not in fashion now.  Modern interfaces are trying to hide the fact of files.  I‚Äôve been with computers for 25 years, and working with files directly is much more convenient for me than any other way. </li></ul><br>  There is nothing that can not be realized without significant effort. <br><br>  Any different.  I do not use it myself, but suddenly it is useful for someone: <br><br><ul><li>  Shows current coordinates (latitude, longitude) </li><li>  On the left side of the screen various icons are drawn whose essence without a manual I can‚Äôt remember. </li><li>  There are switching meters / km - feet / miles. </li><li>  Bluetooth - logger can be connected to mobile phones without GPS. </li><li>  Absolute distance to the point. </li><li>  Logging by time (every N seconds) or by distance (every X meters). </li><li>  Multi-language support. </li></ul><br><h1>  Choosing iron </h1><br>  With the requirements more or less decided.  It's time to understand what all this can be implemented.  The main components I will have are: <br><br><ul><li> <b>Microcontroller</b> - I do not plan any sophisticated computational algorithms, so the computational power of the core is not particularly important.  I also have no special filling requirements - a set of standard peripherals will do. <br><br>  At hand, there was a scattering of various-sized arduinok, as well as a couple of stm32f103c8t6.  I decided to start with AVR, which I know well at the controller / registers / periphery level.  If you rest on the restrictions - it will be an occasion to feel the STM32. <br><br></li><li>  <b>The GPS receiver was</b> chosen from the NEO6MV2, Beitan BN-800 and Beitan BN-880 modules.  Some time googled on forums.  Experienced people said that the first receiver is already the last century.  The other two differ from each other only in the location of the antenna - in the BN-800 it hangs on the wire, and in the BN-880 it is glued with a sandwich on the main module.  Took the <a href="http://www.banggood.com/ru/UBLOX-NEO-M8N-BN-880-Flight-Control-GPS-Module-Dual-Module-Compass-p-971082.html">BN-880</a> . <br><br></li><li>  <b>Screen</b> - the original is used LCD display 128x32 with backlight.  I did not find the same.  I bought an <a href="https://www.aliexpress.com/item/1pcs-0-91-inch-OLED-module-0-91-blue-OLED-128X32-OLED-LCD-LED-Display-Module/32777216785.html">OLED 0.91 ‚Äùon the SSD1306 controller</a> and a <a href="http://www.ebay.com/itm/291035862427">1.2‚Äù LCD screen on the ST7565R controller</a> .  I decided to start with the first, because  Its easier to connect a standard comb for I2C or SPI.  But it is slightly smaller compared to the original, and also it will not be able to constantly display an image for reasons of fuel efficiency.  The second display should be less voracious, but under it you need to unsolder the tricky connector and think of how to power the backlight. </li></ul><br>  From the little things: <br><br><ul><li>  Buttons once bought a whole bag; </li><li>  Shield with for SD card - also lay at hand; </li><li>  Lithium battery charge controllers bought a couple of different things, but have not yet figured out. </li></ul><br>  I decided to design the board at the very end, when the firmware will be ready.  By this time, I will finally determine the main components and the scheme of their inclusion.  At the first stage, I decided to do debugging on a breadboard by connecting components using patch cords. <br><br>  But first you need to decide on a very important issue - the power components.  It seemed to me reasonable to power everything from 3.3V: GPS and the screen only on it and know how to work.  This is also the native voltage for USB and SD.  In addition, the circuit can be powered from a single lithium can <br><br>  The choice fell on the Arduino Pro Mini, which can be found in the 8MHz / 3.3V version.  But she didn‚Äôt have USB on board - I had to use a USB-UART adapter. <br><br><h1>  The first steps </h1><br>  Initially, the project created in the Arduino IDE.  But honestly, my language doesn‚Äôt turn to call it IDE - so, a text editor with a compiler.  In any case, after Visual Studio, in which I have been working for the last 13 years, I cannot do anything serious in the Arduino IDE without tears and swearing. <br><br>  Fortunately, there is a free Atmel Studio, in which even Visual Assist is out of the box !!!  The program is able all that is needed, everything is familiar and in its place.  Well, almost everything (I did not find only how to compile only one file, for example, to check the syntax) <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/bfc/b08/98f/bfcb0898f136628896be3b6769eda34f.png" alt="image"><br><br>  I started from the screen - this is needed to debug the skeleton of the firmware, and then fill it with functionality.  I stopped at the <a href="https://github.com/adafruit/Adafruit_SSD1306">first library for SSD1306 from Adafruit</a> .  She knows everything she needs and provides a very simple interface. <br><br>  Played fonts.  It turned out that one font can take up to 8kb (24pt letter size) - you don‚Äôt have much fun in a 32kb controller.  Large fonts are needed, for example, to display time. <br><br><div class="spoiler">  <b class="spoiler_title">Font selection code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #include &lt;gfxfont.h&gt; #include &lt;fonts/FreeMono12pt7b.h&gt; #include &lt;fonts/FreeMono18pt7b.h&gt; ... #include &lt;fonts/FreeSerifItalic24pt7b.h&gt; #include &lt;fonts/FreeSerifItalic9pt7b.h&gt; #include &lt;fonts/TomThumb.h&gt; struct font_and_name { const char * PROGMEM name; GFXfont * font; }; #define FONT(name) {#name, &amp;name} const font_and_name fonts[] = { // FONT(FreeMono12pt7b), FONT(FreeMono18pt7b), /* FONT(FreeMono24pt7b), FONT(FreeMono9pt7b), FONT(FreeMonoBold12pt7b), ... FONT(FreeSerifItalic9pt7b), FONT(TomThumb)*/ }; const unsigned int fonts_count = sizeof(fonts) / sizeof(font_and_name); unsigned int current_font = 0; extern Adafruit_SSD1306 display; void RunFontTest() { display.clearDisplay(); display.setCursor(0,30); display.setFont(fonts[current_font].font); display.print("12:34:56"); display.setCursor(0,6); display.setFont(&amp;TomThumb); display.print(fonts[current_font].name); display.display(); } void SwitchToNextFont() { current_font = ++current_font % fonts_count; }</span></span></span></span></code> </pre> <br></div></div><br>  Fonts bundled with the library are very clumsy.  The monospace font turned out to be very wide - the line ‚Äú12:34:56‚Äù doesn‚Äôt fit, Serif - all the figures are of different weights.  Is that the standard font 5x7 in the library looks edible. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b7a/67f/676/b7a67f676d061bdb4920985b0c46692a.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9de/e19/69f/9dee1969f16ad50138756b9dab906d4d.jpg" alt="image"><br><br>  It turned out that these fonts were converted from some open-source ttf fonts that are simply not optimized for fine resolutions. <br><br>  I had to draw my own fonts.  More precisely, first vykolupyvat from the finished individual characters.  The symbol ':' in the ASCII table is very appropriately located immediately after the numbers and can be broken out in one block.  It is also convenient that you can not do the font for all characters, but only for the range, for example, from 0x30 ('0') to 0x3a (':').  So  From FreeSans18pt7b it turned out to make a very compact font only for the necessary characters.  I had to truthfully bit down the width so that the text would fit the width of the screen. <br><br><div class="spoiler">  <b class="spoiler_title">Patchwork font FreeSans18pt7b</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// This font consists only of digits and ':' to display current time. // The font is very based on FreeSans18pt7b.h //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> 25 pixel height is too much for displaying time. Create another 22px font const uint8_t TimeFontBitmaps[] PROGMEM = { /* 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0x20, 0x3F, 0xFC, 0xE3, 0xF1, 0xF8, 0xFC, 0x7E, 0x3F, 0x1F, 0x8E, 0x82, 0x41, 0x00, 0x01, 0xC3, 0x80, ... 0x03, 0x00, 0xC0, 0x60, 0x18, 0x06, 0x03, 0x00, 0xC0, 0x30, 0x18, 0x06, 0x01, 0x80, 0xC0, 0x30, 0x00, */0x07, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x3C, 0x78, 0x1E, 0x70, 0x0E, 0x70, 0x0E, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0E, 0x70, 0x0E, 0x78, 0x1E, 0x3C, 0x3C, 0x1F, 0xF8, 0x1F, 0xF0, 0x07, 0xE0, 0x03, 0x03, 0x07, 0x0F, 0x3F, 0xFF, 0xFF, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3E, 0x70, 0x0F, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1E, 0x00, 0x3C, 0x00, 0xF8, 0x03, 0xF0, 0x07, 0xC0, 0x1F, 0x00, 0x3C, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xF0, 0x07, 0xFE, 0x07, 0xFF, 0x87, 0x83, 0xC3, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x7F, 0x00, 0x3F, 0x00, 0x1F, 0xE0, 0x00, 0x78, 0x00, 0x1E, 0x00, 0x07, 0x00, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFE, 0x00, 0x77, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x00, 0x38, 0x00, 0x38, 0x00, 0x78, 0x00, 0xF8, 0x00, 0xF8, 0x01, 0xF8, 0x03, 0xB8, 0x03, 0x38, 0x07, 0x38, 0x0E, 0x38, 0x1C, 0x38, 0x18, 0x38, 0x38, 0x38, 0x70, 0x38, 0x60, 0x38, 0xE0, 0x38, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x1F, 0xFF, 0x0F, 0xFF, 0x8F, 0xFF, 0xC7, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00, 0x39, 0xF0, 0x3F, 0xFE, 0x1F, 0xFF, 0x8F, 0x83, 0xE7, 0x00, 0xF0, 0x00, 0x3C, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xFC, 0x00, 0xEF, 0x00, 0x73, 0xC0, 0xF0, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xE0, 0x00, 0x03, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x1E, 0x38, 0x0E, 0x70, 0x0E, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xE3, 0xE0, 0xEF, 0xF8, 0xFF, 0xFC, 0xFC, 0x3E, 0xF0, 0x0E, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0x60, 0x07, 0x70, 0x0F, 0x70, 0x0E, 0x3C, 0x3E, 0x3F, 0xFC, 0x1F, 0xF8, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x18, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xC0, 0x01, 0xC0, 0x01, 0x80, 0x03, 0x80, 0x03, 0x80, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x07, 0xF0, 0x0F, 0xFE, 0x0F, 0xFF, 0x87, 0x83, 0xC7, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x78, 0x0F, 0x1E, 0x0F, 0x07, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xE3, 0xE0, 0xF9, 0xC0, 0x1D, 0xC0, 0x0F, 0xE0, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFC, 0x00, 0xF7, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3C, 0x70, 0x0E, 0xF0, 0x0E, 0xE0, 0x06, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0F, 0x78, 0x3F, 0x3F, 0xFF, 0x1F, 0xF7, 0x07, 0xC7, 0x00, 0x07, 0x00, 0x06, 0x00, 0x0E, 0x70, 0x0E, 0x70, 0x1C, 0x78, 0x3C, 0x3F, 0xF8, 0x1F, 0xF0, 0x07, 0xC0, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0x80 /*, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xB6, 0xD6, 0x00, 0x00, 0x80, 0x03, 0xC0, 0x07, 0xE0, 0x0F, 0xC0, 0x3F, 0x80, 0x7E, 0x00, 0xFC, 0x01, 0xF0, 0x00, 0xE0, 0x00, ... 0x38, 0x38, 0xF8, 0xF0, 0xE0, 0x38, 0x00, 0xFC, 0x03, 0xFC, 0x1F, 0x3E, 0x3C, 0x1F, 0xE0, 0x1F, 0x80, 0x1E, 0x00 */ }; //TODO Recalc offset numbers const GFXglyph TimeFontGlyphs[] PROGMEM = { { 449-449, 16, 25, 19, 2, -24 }, // 0x30 '0' { 499-449, 8, 25, 19, 4, -24 }, // 0x31 '1' { 524-449, 16, 25, 19, 2, -24 }, // 0x32 '2' { 574-449, 17, 25, 19, 1, -24 }, // 0x33 '3' { 628-449, 16, 25, 19, 1, -24 }, // 0x34 '4' { 678-449, 17, 25, 19, 1, -24 }, // 0x35 '5' { 732-449, 16, 25, 19, 2, -24 }, // 0x36 '6' { 782-449, 16, 25, 19, 2, -24 }, // 0x37 '7' { 832-449, 17, 25, 19, 1, -24 }, // 0x38 '8' { 886-449, 16, 25, 19, 1, -24 }, // 0x39 '9' { 936-449, 3, 19, 7, 2, -20 }, // 0x3A ':' }; const GFXfont TimeFont PROGMEM = { (uint8_t *)TimeFontBitmaps, (GFXglyph *)TimeFontGlyphs, 0x30, 0x3A, 20 };</span></span></code> </pre> </div></div><br>  It turned out that the 18pt font is actually 25 pixels high.  Because of this, he slightly clings to another inscription <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/543/aee/2e5/543aee2e5c6515307a4c969a3bfff374.jpg" alt="image"><br><br>  An inverted display, by the way, helps to understand where the boundaries of the drawing area actually are and how the line lies relative to this border - the display has quite large frames. <br><br>  Long googled ready-made fonts, but they did not fit either in size, or in shape, or in content.  For example, on the Internet with a shaft of 8x12 fonts (dumps of character generators of VGA cards).  But in fact these fonts are 6x8, i.e.  walking a lot of places - in the case of such a small resolution and size as I have it is critical. <br><br>  I had to draw my own fonts, since the Adafruit library's font format is very simple.  I prepared the picture in Paint.net - I just drew the letters with the right font, then adjusted it with a pencil.  He saved the picture as png, and then sent a Python script written on his knee to a quick search.  This script generated a semifinished code that has already dotted the rules in the IDE right in hex codes. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/618/78f/f7e/61878ff7eff21be033fdbc56183a4f5e.png" alt="image"><br><br>  For example, this is how the process of creating an 8x12 monospace font with small letter and line spacing looks.  Each character in the end turned out about 7x10, and the default occupied 10 bytes.  It would be possible to pack each character in 8-9 bytes (the library allows it), but I did not bother.  In addition, in this form, you can edit individual pixels directly in the code. <br><br><div class="spoiler">  <b class="spoiler_title">Font 8x12</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A simple 8x12 font (slightly modifier Courier New) const uint8_t Monospace8x12Bitmaps[] PROGMEM = { 0x1e, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1e, //0 0x18, 0x68, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, //1 0x3e, 0x41, 0x41, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x41, 0x7f, //2 0x3e, 0x41, 0x01, 0x01, 0x0e, 0x02, 0x01, 0x01, 0x41, 0x3e, //3 0x02, 0x06, 0x0a, 0x12, 0x12, 0x22, 0x3f, 0x02, 0x02, 0x0f, //4 0x7f, 0x41, 0x40, 0x40, 0x7e, 0x01, 0x01, 0x01, 0x41, 0x3e, //5 0x1e, 0x21, 0x40, 0x40, 0x5e, 0x61, 0x41, 0x41, 0x41, 0x3e, //6 0x7f, 0x41, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, //7 0x1e, 0x21, 0x21, 0x21, 0x1e, 0x21, 0x21, 0x21, 0x21, 0x1e, //8 0x1e, 0x21, 0x21, 0x21, 0x23, 0x1d, 0x01, 0x01, 0x22, 0x1c, //9 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, //: }; const GFXglyph Monospace8x12Glyphs[] PROGMEM = { { 0, 8, 10, 8, 0, -11 }, // 0x30 '0' { 10, 8, 10, 8, 0, -11 }, // 0x31 '1' { 20, 8, 10, 8, 0, -11 }, // 0x32 '2' { 30, 8, 10, 8, 0, -11 }, // 0x33 '3' { 40, 8, 10, 8, 0, -11 }, // 0x34 '4' { 50, 8, 10, 8, 0, -11 }, // 0x35 '5' { 60, 8, 10, 8, 0, -11 }, // 0x36 '6' { 70, 8, 10, 8, 0, -11 }, // 0x37 '7' { 80, 8, 10, 8, 0, -11 }, // 0x38 '8' { 90, 8, 10, 8, 0, -11 }, // 0x39 '9' { 100, 8, 10, 8, 0, -11 }, // 0x3A ':' }; const GFXfont Monospace8x12Font PROGMEM = { (uint8_t *)Monospace8x12Bitmaps, (GFXglyph *)Monospace8x12Glyphs, 0x30, 0x3A, 12 };</span></span></code> </pre><br></div></div><br><h1>  Frame </h1><br>  The original device provides a very simple and convenient interface.  Information is grouped into categories, which are shown from individual pages (screens).  Using the button, you can cycle through the pages, and use the second button to select the current item or perform the action indicated in the label under the button.  This approach seems to me to be very convenient and I don‚Äôt need to change anything. <br><br>  I like the beauty of OOP, because I immediately blinded a small interface, each page implements the interface as it needs.  The page knows how to draw itself and realizes the reaction to the buttons. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Screen(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Screen() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSelButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOkButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOkButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span></span>; };</code> </pre> <br>  Depending on the current screen, the buttons can perform various actions.  Therefore, I took the top of the screen 8 pixels high to the captions for the buttons.  Text for captions depends on the current screen and is returned by the virtual functions getSelButtonText () and getOkButtonText ().  Also in the header will be displayed service items such as the level of the GPS signal and battery charge.  The remaining ¬æ screens are available for useful information. <br><br>  As I said, screenshots can turn over, which means that somewhere there should be a list of objects for different pages.  What is more than one - screens can be nested as a submenu.  I even started a ScreenManager class, which was supposed to manage these lists, but then I found the solution easier. <br><br>  So each screen just has a pointer to the next one.  If the screen allows you to enter the submenu, then it adds another pointer to the screen of this submenu. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; ‚Ä¶ }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentScreen</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Screen { Screen * childScreen; ‚Ä¶ };</code> </pre> <br>  By default, the button handler simply calls the screen change function, passing it the desired pointer.  The function turned out to be trivial - it just switched the pointer to the current screen.  To make the screens nesting, I made a small stack.  So the whole screen manager I fit in 25 lines and 4 small functions. <br><br><pre> <code class="cpp hljs">Screen * screenStack[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> screenIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenStack[screenIdx] = screen; } <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> screenStack[screenIdx]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enterChildScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenIdx++; <span class="hljs-comment"><span class="hljs-comment">//TODO limit this screenStack[screenIdx] = screen; } void backToParentScreen() { if(screenIdx) screenIdx--; }</span></span></code> </pre> <br>  True, the code for filling these structures does not look very nice, but so far has not been invented better. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCurrentTimeScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TimeZoneScreen * tzScreen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>)); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// TODO Add real timezones here CurrentTimeScreen * screen = new CurrentTimeScreen(); screen-&gt;addChildScreen(tzScreen); return screen; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Think</b> <div class="spoiler_text">  The structure, of course, turned out to be beautiful, but I fear it eats a lot of memory.  We'll have to go against ourselves and zafigachit large static table with pointers. <br></div></div><br>  Go ahead.  In my implementation of the interface, I wanted to do something like a message box, a short message that would show for a second or two, and then disappear.  For example, if you press the POI (Point Of Interest) button on the screen with current coordinates, then in addition to recording a point in the track, it would be nice to show the user the message ‚ÄúWaypoint Saved‚Äù (an additional icon is shown in the original device for a second).  Or when discharging the battery, ‚Äúcheer up‚Äù the user with the appropriate message. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/aa5/dec/17b/aa5dec17b1b4b298b764fce33b8441db.jpg" alt="image"><br><br>  Since the data from the GPS will come all the time, there can be no talk of any blocking functions.  Therefore, we had to invent a simple state machine (state machine), which, in the loop () function, would choose what to do ‚Äî show the current screen or message box. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { IDLE_DISPLAY_OFF, IDLE, MESSAGE_BOX, BUTTON_PRESSED, };</code> </pre> <br>  Also, using the state machine it is convenient to handle button presses.  Perhaps it would be correct through interruptions, but it also turned out well.  It works like this: if the button was pressed in the IDLE state, we will remember the time it was pressed and go to the BUTTON_PRESSED state.  In this state, wait until the user releases the button.  Here we can calculate the duration when the button was pressed.  Short triggers (&lt;30ms) are simply ignored - most likely it is contact bounce.  Long operations can already be interpreted as pressing a button. <br><br>  I plan to use both short button presses for normal actions and long ones (&gt; 1c) for special functions.  For example, a short press starts / stops the odometer, a long press resets the counter value to 0. <br><br>  Perhaps other states will be added.  So, for example, in the original logger, after switching to the next page, the values ‚Äã‚Äãon the screen change frequently, and after a couple of seconds less often - once a second.  This can be done by adding another state. <br><br>  When the frame was ready, I already, it was, began to connect the GPS.  But then there are nuances that made me postpone this task. <br><br><h1>  Firmware optimization </h1><br>  Before moving on, I need to get away with some technical details.  The fact is that around this place I began to butt with a growing memory consumption.  It turned out that the line was recklessly declared without the PROGMEM modifier at the start of the firmware is copied into the RAM and takes place there during the entire execution time. <br><br><div class="spoiler">  <b class="spoiler_title">Various architectures</b> <div class="spoiler_text">  In a nutshell.  On large computers, <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D1%2584%25D0%25BE%25D0%25BD_%25D0%259D%25D0%25B5%25D0%25B9%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Von Neumann architecture is used</a> where code and data are located in the same address space.  Those.  data from both RAM and ROM will be read in the same way. <br><br>  Microcontrollers typically use the <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2580%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">Harvard architecture</a> , where code and data are separated.  So  You have to use various functions for reading memory and flash.  From the point of view of the C / C ++ language, the pointers look the same, but when writing a program we need to know exactly where our pointer points to which memory and call the corresponding functions. </div></div><br>  Benefit library developers have, in part, taken care of this.  The main display library class, Adafruit_SSD1306, is inherited from the Print class from the Arduinov standard library. <br><br>  This provides us with a whole series of different modifications of the print method ‚Äî for printing lines, individual characters, numbers, and something else.  So there are 2 separate functions for printing lines: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __FlashStringHelper *); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[]);</code> </pre><br>  The first knows that you need to print a string from a flash drive and loads it by character.  The second prints characters from RAM.  In fact, both of these functions take a pointer to a string, only from different address spaces. <br><br>  I have been looking for this very __FlashStringHelper in the Arduino code to learn how to call the desired print () function.  It turned out the guys acted slyly: they simply declared this type with the help of a forward declaration (without the type itself) and wrote a macro that casts pointers to strings in a flash to the type __FlashStringHelper.  Just for the compiler to select the desired overloaded function. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashStringHelper</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F(string_literal) (reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(PSTR(string_literal)))</span></span></span></span></code> </pre><br>  This allows you to write like this: <br><br><pre> <code class="cpp hljs">display.print(F(‚ÄúString in flash memory‚Äù));</code> </pre> <br><br>  But does not allow to write like that <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> text[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"String in flash memory"</span></span>; display.print(F(text));</code> </pre> <br>  And, apparently, the library does not provide anything that could be done that way.  I know that it‚Äôs not good to use private libraries in my code, but what could I do?  I drew my macro, which did what I needed. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USE_PGM_STRING(x) reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(x)</span></span></span></span></code> </pre><br>  So the cap drawing function began to look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Screen::drawHeader() { display.setFont(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); display.setCursor(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getSelButtonText())); display.setCursor(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getOkButtonText())); }</code> </pre> <br>  Well, since I already got into the low-level pieces of the firmware, I decided to study more deeply how it was all arranged inside. <br><br>  In general, the guys who came up with Arduino need to erect a monument.  They made a simple and convenient platform for prototyping and crafts.  A huge number of people with minimal knowledge of electronics and programming were able to enter the world of Arduino.  But all this is smooth and beautiful while doing bullshit-type garbage with light-emitting diodes or reading thermometer readings.  As soon as you threaten something serious, you immediately have to understand more deeply than you would like from the very beginning. <br><br>  So, after each added library or even class, I noted how quickly memory consumption grows.  At this point, I had more than 14 KB of 32 KB of flash and 1300 bytes of RAM (of 2k).  Each careless movement added another 10 percent to the already used one.  But I still didn‚Äôt really connect the GPS and SD / FAT32 libraries, but the cat itself was crying for the functionality itself.  I had to take the disassembler into my hand and study what the compiler of such a compiler had to do there. <br><br>  I was secretly hoping that the linker throws out unused functions.  But it turned out that the linker inserts some of them almost entirely.  In the firmware, I found the functions of drawing lines and some others from the screen library, although in the code I did not explicitly call them at that time.  Implicitly, they also should not be called - why do I need the function of drawing a line, if I only draw letters from the batmapock?  More than 5.2kb out of the blue (and that's not counting fonts). <br><br>  In addition to the display management library, I also found: <br><br><ul><li>  2.6 KB - on SoftwareSerial (I pulled it into the project at some point) </li><li>  1.6 kb - I2C </li><li>  1.3 kb - HardwareSerial </li><li>  2 Kb - TinyGPS </li><li>  2.5 kb on arduino itself (initialization, pins, various tables, main timer for millis () and delay () functions), </li></ul><br>  The figures are very approximate, because  The optimizer seriously mixes the code.  In one place some function can begin, and then immediately after it another from another library, which is called from the first, can follow.  Moreover, individual branches of these functions can be located at the other end of the flush. <br><br>  Also in the code I found: <br><br><ul><li>  Screen control by SPI (although I have it connected via I2C) </li><li>  Methods of base classes that are not called themselves, since  redefined as heirs </li><li>  Destructors that are never called by design. </li><li>  Drawing functions (and not all - part of the functions the linker all the same threw up) </li><li>  malloc / free while in my code all objects are essentially static </li></ul><br>  But leaps and bounds increase not only the consumption of flash memory, but also SRAM: <br><br><ul><li>  130 bytes - I2C </li><li>  100 bytes - SoftwareSerial </li><li>  157 bytes - Serial </li><li>  558 bytes - Display (of which 512 is a frame buffer) </li></ul><br>  No less entertaining was the .data section.  There are about 700 bytes and this thing is loaded from a flash to RAM at the start.  It turned out that space for variables in the memory was reserved there, along with initialization values.  Here live those variables and constants that are forgotten to declare as const PROGMEM. <br><br>  Among this, there was a hefty array with a splashscreen of the screen ‚Äî the initial values ‚Äã‚Äãof the frame buffer.  Theoretically, if you make the display () right after the start, you can see the flower and the Adafruit inscription, but in my case it is pointless to spend on this flash memory. <br><br>  The .data section also contains vtables.  They are copied into memory from a flash drive, apparently for efficiency reasons in runtime.  But you have to sacrifice a fairly large piece of RAM - a dozen classes more than 150 bytes.  And it seems that there is no compiler key, which, sacrificing performance, will leave virtual tables in flash memory. <br><br>  What to do with it?  I don't know yet.  It will depend on how consumption grows further.  For good found shoals need to be mercilessly repaired.  Apparently, I will have to draw all the libraries into my project explicitly, and then you can poke them thoroughly.  And you may also have to rewrite some of the pieces differently in order to optimize the memory.  Or switch to more powerful hardware.  In any case, now I know about the problem and there is a strategy how to fix it. <br><br>  <b>UPDATE:</b> <br>  Little progress in resource efficiency.  I make an update to this part, because  next I want to focus on completely different things. <br><br>  In comments, there is some confusion about using C ++.  In particular, why is he so bad and vtable stores in precious RAM?  And in general, virtual functions, constructors and destructors are overhead.  What for?  Let's figure it out! <br><br>  Here are statistics on memory at some stage of the project. <br>  Program size: 15,458 bytes (used 50% of a 30,720 byte maximum) (2.45 secs) <br>  Minimum Memory Usage: 1258 bytes (61% of a 2048 byte maximum) <br><br>  Experiment number 1 - rewritten in C. <br><br>  I threw out classes, rewrote everything on tables with function pointers.         ,        . <br><br>    <br> Program size: 14 568 bytes (used 47% of a 30 720 byte maximum) (2,35 secs) <br> Minimum Memory Usage: 1176 bytes (57% of a 2048 byte maximum) <br><br>  Total  900    80  .       . 80       vtable'.    ( )    . <br><br>  ,      ‚Äî      ,      .    ‚Äú‚Äù  .       . <br><br>       ,   ,     .        .       ¬´ ¬ª,       .     . <br><br>  ‚Ññ2 ‚Äî    ++ <br><br>     ,    .          .      .         new/delete. <br><br> Program size: 15 408 bytes (used 50% of a 30 720 byte maximum) (2,60 secs) <br> Minimum Memory Usage: 1273 bytes (62% of a 2048 byte maximum) <br><br>    .  ,   ,  .             .  Those.      ,      .      . <br><br>        .       ,      .  Those.     ‚Äú‚Äù         .        ,    ,      . <br><br>            ,        .    ,        vtable.     : <br><br> Program size: 14 704 bytes (used 48% of a 30 720 byte maximum) (2,94 secs) <br> Minimum Memory Usage: 1211 bytes (59% of a 2048 byte maximum) <br><br>   vtable'     ,    2.     .     (    ),     free,      (-12  ).        (8 )   ,      (Screen, ParentScreen ‚Äî 40 ) <br><br>     ‚Äî  700 .     ,    malloc/free/new/delete. 700     ! 700 , ! <br><br>     -,       <br><br><table><tbody><tr><th></th><th>  It was </th><th>  C </th><th>  C ++ </th></tr><tr><td>  Flash </td><td> 15 458 </td><td> 14 568 </td><td> 14 704 </td></tr><tr><td>  Ram </td><td>  1258 </td><td>  1176 </td><td>  1211 </td></tr></tbody></table><br><br> :   ++        .    ,     .        .         ,  ,       ++? <br><br><h1>  Afterword </h1><br>           .          ,      .         .        :      ,  ,   . <br><br>            ‚Äî   GPS.       ,     . <br><br>   10      . ,              ATMega32.      ,             .           ‚Äî ATMega64      STM32. <br><br>     -   .       ‚Äî      .      <a href="https://github.com/grafalex82/GPSLogger">  </a> . <br><br>   . <br><br>  <a href="https://geektimes.ru/post/287666/">The second part of</a> </div><p>Source: <a href="https://habr.com/ru/post/401899/">https://habr.com/ru/post/401899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../401889/index.html">The legendary amplifiers of the 80s - 90s: the Lamma paradoxes, the Johnson monster, the ‚Äúwarm lamps‚Äù integral killer</a></li>
<li><a href="../401891/index.html">3D scanning and 3D printing in action (dedicated to motorcyclists)</a></li>
<li><a href="../401893/index.html">Where do water and oxygen come from on the ISS?</a></li>
<li><a href="../401895/index.html">The attackers are becoming more ingenious in creating skimmers</a></li>
<li><a href="../401897/index.html">Newsletter on SLS and Orion ship</a></li>
<li><a href="../401901/index.html">Moon vent to the universe</a></li>
<li><a href="../401903/index.html">How sounds affect our sleep and productivity</a></li>
<li><a href="../401905/index.html">Apple Power Mac G4 Cube and its contemporaries in a small photo review</a></li>
<li><a href="../401907/index.html">Robotic cars must learn to understand people.</a></li>
<li><a href="../401909/index.html">Homemade security system based on products for smart home from Nootehnika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>