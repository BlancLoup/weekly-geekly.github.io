<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part 4: Database (edition 2018)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="blog.miguelgrinberg.com 
 Miguel grinberg 



 <<< previous next >>> 


 This article is a translation of the fourth part of the new edition of the Mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part 4: Database (edition 2018)</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="http://blog.miguelgrinberg.com/" title="blog.miguelgrinberg.com">blog.miguelgrinberg.com</a> </p><br><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p>  <a href="https://habrahabr.ru/post/346342/">&lt;&lt;&lt; previous</a> <a href="https://habrahabr.ru/post/346346/">next &gt;&gt;&gt;</a> </p><br><p>  This article is a translation of the fourth part of the new edition of the Miguel Greenberg textbook.  <a href="https://habrahabr.ru/post/193242/" title="Previous translation">The old translation</a> has long lost its relevance. </p><a name="habracut"></a><br><p>  This is the fourth edition of the Flask Mega-Tutorial series, in which I will tell you how to work with databases. </p><br><p>  For reference, below is a list of articles in this series. </p><br><div class="spoiler">  <b class="spoiler_title">TABLE OF CONTENTS</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database (This article)</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346346/"><strong>Chapter 5: User Logins</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  <a href="https://habrahabr.ru/post/354322/"><strong>Chapter 21: User Notifications</strong></a> </li><li>  <a href="https://habrahabr.ru/post/354752/"><strong>Chapter 22: Background Tasks</strong></a> </li><li>  <a href="https://habrahabr.ru/post/358152/"><strong>Chapter 23: Application Programming Interfaces (APIs)</strong></a> </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  <em>Note 2: If suddenly you would like to speak in support of my (Miguel) work on this blog, or simply do not have the patience to wait for a week of the article, I (Miguel Greenberg) offer a full version of this guide a packed e-book or video.</em>  <em>For more information, visit <a href="http://learn.miguelgrinberg.com/" title="learn.miguelgrinberg.com">learn.miguelgrinberg.com</a> .</em> </p><br><p>  The topic of this chapter is extremely important.  For most applications, it is necessary to maintain persistent data that can be efficiently extracted, and this is exactly what databases are created for. </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="bazy-dannyh-v-flask">  Databases in Flask </h2><br><p>  Since I am sure that you have already heard, Flask does not support databases initially.  This is one of the many areas in which Flask is intentionally not self-sufficient, which is great because you have the freedom to choose the database that best suits your application, instead of being forced to adapt to one. </p><br><p>  Python has a large selection for databases, many of which integrate with the Flask application.  Databases can be divided into two large groups: those that correspond to the relational model, and those that do not.  The latter group is often called NoSQL, which indicates that they do not implement the popular relational query language <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> .  Although there are excellent database products in both groups, I believe that relational databases are better suited for applications that have structured data, such as user lists, blog posts, etc., while NoSQL databases have tends to be better for data that has a less defined structure.  This application, like most others, can be implemented using any type of database, but for the reasons stated above, I am going to work with a relational database. </p><br><p>  In <strong>chapter 3,</strong> I showed you the first Flask extension.  In this chapter, I'm going to use two more.  The first is <a href="http://packages.python.org/Flask-SQLAlchemy">Flask-SQLAlchemy</a> , an extension that provides a Flask-friendly wrapper to the popular <a href="http://www.sqlalchemy.org/">SQLAlchemy</a> package, which is an <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object Relational Mapper</a> or ORM.  ORMs allow applications to manage a database using high-level objects such as classes, objects, and methods, rather than tables and SQL.  The ORM task is to translate high-level operations into database commands. </p><br><p>  The most pleasant thing about SQLAlchemy is that this ORM is not for one, but for many relational databases.  SQLAlchemy maintains a long list of database engines, including the popular <a href="https://www.mysql.com/">MySQL</a> , <a href="https://www.postgresql.org/">PostgreSQL</a> and <a href="https://www.sqlite.org/">SQLite</a> .  This is very strong, because you can do your development with a simple SQLite database that does not require a server, and then when the time comes to deploy the application to the production server, you can choose a more reliable MySQL or PostgreSQL server without changing your application. </p><br><p>  To install Flask-SQLAlchemy in a virtual environment, make sure that you activate it first, and then run: </p><br><pre><code class="hljs sql">(venv) $ pip <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> flask-sqlalchemy</code> </pre> <br><h2 id="migraciya-baz-dannyh">  Database migration </h2><br><p>  Most of the database tutorials that I've seen cover creating and using a database, but do not adequately solve the problem of creating updates to an existing database as the application needs to be modified or enlarged.  This is difficult because the relational databases are centered around structured data, so when the structure changes, the data that is already in the database must be transferred to the modified structure. </p><br><p>  The second extension that I am going to present in this chapter is <a href="https://github.com/miguelgrinberg/flask-migrate">Flask-Migrate</a> , which is actually created by yours truly.  This extension is a Flask wrapper for <a href="https://bitbucket.org/zzzeek/alembic">Alembic</a> , the basis for migrating the SQLAlchemy database.  Working with database migrations adds a bit of work at the beginning, but this is a small price to pay for a reliable way to make changes to your database in the future. </p><br><p>  The installation process for Flask-Migrate is similar to other extensions you have seen: </p><br><pre> <code class="hljs sql">(venv) $ pip <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> flask-migrate</code> </pre> <br><h2 id="konfiguraciya-flask-sqlalchemy">  Flask-SQLAlchemy configuration </h2><br><p>  During development, I'm going to use a SQLite database.  SQLite databases are the most convenient choice for developing small applications, sometimes not even very small ones, since each database is stored in one file on disk and there is no need to run a database server like MySQL and PostgreSQL. </p><br><p>  We have two new configuration items to add to the configuration file: </p><br><blockquote>  config.py </blockquote><br><pre> <code class="hljs lua">import <span class="hljs-built_in"><span class="hljs-built_in">os</span></span> basedir = <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.abspath(<span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.dirname(__file__)) class Config(object): # ... SQLALCHEMY_DATABASE_URI = <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.environ.get(<span class="hljs-string"><span class="hljs-string">'DATABASE_URL'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> \ <span class="hljs-string"><span class="hljs-string">'sqlite:///'</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">os</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.join(basedir, <span class="hljs-string"><span class="hljs-string">'app.db'</span></span>) SQLALCHEMY_TRACK_MODIFICATIONS = False</code> </pre> <br><p>  The Flask-SQLAlchemy extension takes the location of the application database from the <code>SQLALCHEMY_DATABASE_URI</code> configuration <code>SQLALCHEMY_DATABASE_URI</code> .  As you remember from <strong>Chapter 3</strong> , it is generally recommended to set the configuration from environment variables and provide a fallback value when the environment does not define a variable.  In this case, I take the database URL from the <code>DATABASE_URL</code> environment variable, and if it is not defined, I set up a database called <em>app.db</em> located in the main application directory, which is stored in the <code>basedir</code> variable. </p><br><p>  The <code>SQLALCHEMY_TRACK_MODIFICATIONS</code> configuration <code>SQLALCHEMY_TRACK_MODIFICATIONS</code> set to False to disable the Flask-SQLAlchemy function, which I do not need, which should signal the application every time a change is made to the database. </p><br><p>  The database will be presented in the application as <em>database instance</em> .  The database migration mechanism will also have an instance.  These are the objects that need to be created after the application in the file <code>app/__ init__.py</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask from config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Config from flask_sqlalchemy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SQLAlchemy from flask_migrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Migrate app = Flask(<span class="hljs-title"><span class="hljs-title">__name__</span></span>) app.config.from_object(<span class="hljs-type"><span class="hljs-type">Config</span></span>) db = SQLAlchemy(<span class="hljs-title"><span class="hljs-title">app</span></span>) migrate = Migrate(<span class="hljs-title"><span class="hljs-title">app</span></span>, <span class="hljs-title"><span class="hljs-title">db</span></span>) from app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> routes, models</code> </pre> <br><p>  I made three changes to the init script.  First, I added a <code>db</code> object that represents the database.  Then I added another object that represents the migration mechanism.  I hope you will see a sample of work with Flask extensions.  Most extensions are initialized as these two.  Finally, I import a new module called <code>models</code> below.  This module will define the database structure. </p><br><h2 id="modeli-baz-dannyh">  Database models </h2><br><p>  The data that will be stored in the database will be represented by a set of classes, commonly called database models.  The ORM level in SQLAlchemy will perform the translations necessary to match the objects created from these classes into rows in the corresponding database tables. </p><br><p>  Start by creating a model that represents the users.  Using the <a href="http://ondras.zarovi.cz/sql/demo">WWW SQL Designer</a> tool, I made the following diagram to represent the data we want to use in the users table: </p><br><p> <a href="http://ondras.zarovi.cz/sql/demo"><img src="https://habrastorage.org/getpro/habr/post_images/735/51e/366/73551e366bcbb81e973580ae02dfd83d.png"></a> </p><br><p>  The <code>id</code> field is usually used in all models and is used as the primary key.  Each user in the database will be assigned a unique identifier value stored in this field.  Primary keys are in most cases automatically assigned by the database, so I just need to specify the <code>id</code> field marked as the primary key. </p><br><p>  The <code>username</code> , <code>email</code> and <code>password_hash</code> fields are defined as strings (or <code>VARCHAR</code> in database jargon), and their maximum length is specified so that the database can optimize space utilization.  Although the <code>username</code> and <code>email</code> fields do not require explanation, the <code>password_hash</code> fields are noteworthy.  I want to make sure that the application I create uses the best security recommendations, and for this reason I will not store user passwords in the database.  The problem with storing passwords is that if a database ever becomes compromised, attackers will have access to passwords, and this can be destructive to users.  Instead of writing passwords directly, I'm going to write <em>password hashes</em> , which greatly improve security.  This will be the topic of another chapter, so don't worry about it now. </p><br><p>  So, now that I know what I need for the table of my users, I can translate it into code in the new <em>app / models.py module</em> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(db.Model): id = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) username = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) email = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">120</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) password_hash = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">128</span></span>)) def __repr__(self): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;User {}&gt;'</span></span>.format(self.username)</code> </pre> <br><p>  The <code>User</code> class created above inherits from <code>db.Model</code> , the base class for all models from Flask-SQLAlchemy.  This class defines several fields as class variables.  Fields are created as instances of the <code>db.Column</code> class, which takes a field type as an argument, plus other optional arguments that, for example, allow me to specify which fields are unique and indexed, which is important for efficient database search, </p><br><p>  The <code>__repr__</code> method tells Python how to print objects of this class, which will be useful for debugging.  You can see the <code>__repr __()</code> method in action in the Python interpreter session below: </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> &gt;&gt;&gt; u = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(username=<span class="hljs-string"><span class="hljs-string">'susan'</span></span>, email=<span class="hljs-string"><span class="hljs-string">'susan@example.com'</span></span>) &gt;&gt;&gt; u &lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> susan&gt;</code> </pre> <br><h2 id="sozdanie-migracii-repozitoriya">  Creating a repository migration </h2><br><p>  The model class created in the previous section defines the initial structure (or <em>schema</em> ) of the database for this application.  But as the application continues to grow, you will need to change the structure, which will most likely add new entities, but sometimes can also change or delete elements.  Alembic (the migration infrastructure used by Flask-Migrate) will make these schema changes in such a way that it is not necessary to recreate the database from scratch. </p><br><p>  To accomplish this seemingly complex task, Alembic maintains a <em>migration</em> repository, which is the directory in which its migration scripts are stored.  Each time a change is made to the database schema, a migration script is added to the repository with the details of the change.  To apply migrations to the database, these migration scripts are executed in the order in which they were created. </p><br><p>  Flask-Migrate issues its commands via the <code>flask</code> command.  You have already seen the <code>flask run</code> , which is a subordinate command that is native to Flask.  Flask-Migrate is added to the <code>flask db</code> subcommand to manage everything related to database migration.  So let's create a migration repository for microblog by running <code>flask db init</code> : </p><br><pre> <code class="hljs bash">(venv) $ flask db init Creating directory /home/miguel/microblog/migrations ... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Creating directory /home/miguel/microblog/migrations/versions ... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Generating /home/miguel/microblog/migrations/alembic.ini ... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Generating /home/miguel/microblog/migrations/env.py ... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Generating /home/miguel/microblog/migrations/README ... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Generating /home/miguel/microblog/migrations/script.py.mako ... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Please edit configuration/connection/logging settings <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'/home/miguel/microblog/migrations/alembic.ini'</span></span> before proceeding.</code> </pre> <br><p>  Remember that the <code>flask</code> command relies on the <code>FLASK_APP</code> environment variable to know where the Flask application is located.  For this application, you want to set <code>FLASK_APP=microblog.py</code> , as described in <strong>chapter 1</strong> . </p><br><p>  After running this command, you will find a new <em>migrations</em> directory, which has several files and a subdirectory of <em>versions</em> .  All of these files should now be considered as part of your project and need to be added to the version control system. </p><br><h2 id="pervaya-migraciya-bazy-dannyh">  First database migration </h2><br><p>  With the migration repository, it is time to create the first database migration, which will include the <code>Users</code> table mapped to the user database model.  There are two ways to create a database migration: manually or automatically.  To automatically create a migration, Alembic compares the database schema defined by the database models with the actual database schema currently used in the database.  It then fills the migration script with the changes necessary for the database schema to fit the application models.  In this case, since there is no previous database, the automatic transfer will add the entire <code>User</code> model to the transfer script.  <code>flask db migrate</code> DB migration subcommand generates these automatic migrations: </p><br><pre> <code class="hljs cs">(venv) $ flask db migrate -m <span class="hljs-string"><span class="hljs-string">"users table"</span></span> INFO [alembic.runtime.migration] Context impl SQLiteImpl. INFO [alembic.runtime.migration] Will assume non-transactional DDL. INFO [alembic.autogenerate.compare] Detected added table <span class="hljs-string"><span class="hljs-string">'user'</span></span> INFO [alembic.autogenerate.compare] Detected added index <span class="hljs-string"><span class="hljs-string">'ix_user_email'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>email<span class="hljs-string"><span class="hljs-string">']'</span></span> INFO [alembic.autogenerate.compare] Detected added index <span class="hljs-string"><span class="hljs-string">'ix_user_username'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>username<span class="hljs-string"><span class="hljs-string">']'</span></span> Generating /home/miguel/microblog/migrations/versions/e517276bb1c2_users_table.py ... done</code> </pre> <br><p>  The command output gives you an idea that Alembic is included in the migration.  The first two lines are informational and can usually be ignored.  Then he says that he found the table <code>'user'</code> and two indexes <code>'['email']'</code> and '[' username ']'.  Then he tells you where he wrote the migration script.  The code e517276bb1c2 is an automatically generated unique code for migration (it will be different for you).  The comment given with the <code>-m</code> option is optional; it adds a short descriptive text to the hyphen. </p><br><p>  The generated migration script is now part of your project and must be included in the version control system.  You can view the script if you are interested to see what it looks like.  You will find that it has two functions: <code>upgrade()</code> and <code>downgrade()</code> .  The <code>upgrade()</code> function applies the migration, and the <code>downgrade()</code> function removes it.  This allows Alembic to transfer the database to any point in the story, even to older versions, using a slide path. </p><br><p>  The <code>flask db migrate</code> command does not make any changes to the database, it simply creates a migration script.  To apply changes to the database, you must use the <code>flask db upgrade</code> command. </p><br><pre> <code class="hljs pgsql">(venv) $ flask db upgrade <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Context impl SQLiteImpl. <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Will assume non-transactional DDL. <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Running upgrade -&gt; e517276bb1c2, users <span class="hljs-keyword"><span class="hljs-keyword">table</span></span></code> </pre> <br><p>  Since this application uses SQLite, the Upgrade command will detect that the database does not exist and will create it (you will notice that a file named <code>app.db</code> will be added after the completion of this command, that is, the SQLite database).  When working with database servers such as MySQL and PostgreSQL, you must create a database on the database server before starting the update. </p><br><h2 id="process-obnovleniya-bazy-dannyh-i-otkatka-izmeneniy-upgrade-i-downgrade">  The process of updating the database and rolling back the changes Upgrade and Downgrade </h2><br><p>  At the moment, the application is in its infancy, but it does not hurt to discuss what will be in the database migration strategy in the future.  Imagine that you have an application on your development machine, and also have a copy deployed to a production server that is online and in use. </p><br><p>  Suppose that for the next version of your application you need to make changes to your models, for example, you need to add a new table.  Without migration, you will need to figure out how to change the layout of your database, both on the local host and on your server, and this can be a big problem. </p><br><p>  But with database migration support, after modifying the models in the application, you create a new migration script (flask db migrate), you will probably look at it to make sure the automatic creation did the right thing, and then apply the changes to the development database (flask db upgrade).  You will add the migration script to the version control system and fix it. </p><br><p>  When you are ready to release the new version of the application on your <em>production</em> server, all you need to do is grab the updated version of the application, which will include the new migration script and run <code>flask db upgrade</code> .  <em>Alembic will</em> detect that the database has not been updated to the latest edition, and will perform all the new migration scenarios created since the previous release. </p><br><p>  As I mentioned earlier, you also have the <code>downgrade flask db</code> command, which cancels the last migration.  Although you will hardly need this option at the time of operation, you may find it very useful during development.  You may have generated the migration script and applied it only to find that the changes you made are not exactly what you need.  In this case, you can lower the database rating, delete the migration script, and then create a new one to replace it. </p><br><h2 id="svyazi-bazy-dannyh">  Database links </h2><br><p>  Relational databases are good at storing links between data items.  Consider the case when a user writes a blog post.  The user will have an entry in the user table, and the message will have an entry in the message table.  The most effective way to write down who wrote this message is to link two records. </p><br><p>  After the connection is established between the user and the post, there are two types of requests that we may need.  The most trivial is when you have a post and you need to know which user wrote it.  A slightly more complicated question is the opposite of this.  If you have a user, then you may need to get all the entries written by him.  Flask-SQLAlchemy will help us with both types of queries. </p><br><p>  Expand our base for storing posts so that we can see the connections in action.  To do this, we will return to our database design tool and create a table of records: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a40/e5e/a48/a40e5ea48c8c6544d3e82f0d7c6e16d4.png"></p><br><p>  The Message table will have the required ID, message text and time stamp.  But in addition to these expected fields, I add a <code>user_id</code> field that links the message to its author.  You have seen that all users have a primary key <code>id</code> , which is unique.  The way to associate a blog entry with the user who created it is to add a link to the user ID, and this is exactly what the <code>user_id</code> field <code>user_id</code> .  This <code>user_id</code> field is called a foreign key.  In the above database diagram, foreign keys are displayed as a link between the field and the <code>id</code> field of the table to which it refers.  This kind of relationship is called one-to-many, because "one" user writes "many" messages. </p><br><p>  A modified <em>app / models.py is</em> shown below: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(db.Model): id = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) username = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) email = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">120</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) password_hash = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">128</span></span>)) posts = db.relationship(<span class="hljs-string"><span class="hljs-string">'Post'</span></span>, backref=<span class="hljs-string"><span class="hljs-string">'author'</span></span>, lazy=<span class="hljs-string"><span class="hljs-string">'dynamic'</span></span>) def __repr__(self): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;User {}&gt;'</span></span>.format(self.username) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Post(db.Model): id = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) body = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">140</span></span>)) <span class="hljs-type"><span class="hljs-type">timestamp</span></span> = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.DateTime, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, default=datetime.utcnow) user_id = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.Integer, db.ForeignKey(<span class="hljs-string"><span class="hljs-string">'user.id'</span></span>)) def __repr__(self): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;Post {}&gt;'</span></span>.format(self.body)</code> </pre> <br><p>  The new <code>Post</code> class will submit blog posts written by users.  The <code>timestamp</code> field will be indexed, which is useful if you want to receive messages in chronological order.  I also added a default argument and passed the <code>datetime.utcnow</code> function.  When you pass the default function, SQLAlchemy will set the value of the call to this function for the field (note that I did not include <code>()</code> after <code>utcnow</code> , so I pass this function myself, and not the result of calling it).  In general, this will allow working with UTC dates and times in the server application.  This ensures that you use uniform time stamps regardless of where the users are located.  These timestamps will be converted to user local time when they are displayed. </p><br><p>  The <code>user_id</code> field was initialized as a foreign key for <code>user.id</code> , which means that it refers to the <code>id</code> value from the <code>users</code> table.  In this link, user is the name of the database table that Flask-SQLAlchemy automatically sets as the name of the model class converted to lowercase.  The User class has a new message field that is initialized by <code>db.relationship</code> .  This is not the actual database field, but a high-level view of the relationship between users and posts, and for this reason it is not in the database diagram.  For a one-to-many relationship, the db.relationship field is usually defined on the ‚Äúone‚Äù side and is used as a convenient way to access ‚Äúmany‚Äù.  So, for example, if I have a user stored in <code>u</code> , the expression <code>u.posts</code> will run a database query that returns all the entries written by this user.  The first argument <code>db.relationship</code> specifies the class that represents the side of the "many" relationship.  The <code>backref</code> argument specifies the name of the field that will be added to objects of the class "many", which points to the object "one".  This will add a <code>post.author</code> expression that will return the author of the message.  The lazy argument determines how the database query will be performed for the link, which I will discuss later.  Do not worry if these details do not make sense to you, I will show examples at the end of this article. </p><br><p>  Since I have updates for application models, I need to create a new database migration: </p><br><pre> <code class="hljs vhdl">(venv) $ flask db migrate -m <span class="hljs-string"><span class="hljs-string">"posts table"</span></span> INFO [alembic.runtime.migration] <span class="hljs-keyword"><span class="hljs-keyword">Context</span></span> impl SQLiteImpl. INFO [alembic.runtime.migration] Will <span class="hljs-keyword"><span class="hljs-keyword">assume</span></span> non-transactional DDL. INFO [alembic.autogenerate.compare] Detected added table <span class="hljs-symbol"><span class="hljs-symbol">'post</span></span>' INFO [alembic.autogenerate.compare] Detected added index <span class="hljs-symbol"><span class="hljs-symbol">'ix_post_timestamp</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> '[<span class="hljs-symbol"><span class="hljs-symbol">'timestamp</span></span>']' Generating /home/miguel/microblog/migrations/versions/<span class="hljs-number"><span class="hljs-number">780739</span></span>b227a7_posts_table.py ... done</code> </pre> <br><p>  And the migration should be applied to the database: </p><br><pre> <code class="hljs pgsql">(venv) $ flask db upgrade <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Context impl SQLiteImpl. <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Will assume non-transactional DDL. <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Running upgrade e517276bb1c2 -&gt; <span class="hljs-number"><span class="hljs-number">780739</span></span>b227a7, posts <span class="hljs-keyword"><span class="hljs-keyword">table</span></span></code> </pre> <br><p>  If the project is stored in a version control system, do not forget to add a new migration script to it. </p><br><h2 id="vremya-zapuska">  Start time </h2><br><p>  I made you go through the long process of creating a database, but I have not shown you how everything works.  Since the application does not yet have database logic, let's play around with the database in the Python interpreter to familiarize yourself with it.  So go ahead and run Python.  Before starting the interpreter, make sure that your virtual environment is activated. </p><br><p>  On the Python command line, let's import the database instance and models: </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> db &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, Post</code> </pre> <br><p>  Start by creating a new user: </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; u = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(username=<span class="hljs-string"><span class="hljs-string">'john'</span></span>, email=<span class="hljs-string"><span class="hljs-string">'john@example.com'</span></span>) &gt;&gt;&gt; db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(u) &gt;&gt;&gt; db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>()</code> </pre> <br><p>        ,       <code>db.session</code> .      ,       ,      <code>db.session.commit()</code> ,     .           ,  <code>db.session.rollback()</code>      ,   .  ,          <code>db.session.commit()</code> .  ,         . </p><br><p>    : </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; u = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(username=<span class="hljs-string"><span class="hljs-string">'susan'</span></span>, email=<span class="hljs-string"><span class="hljs-string">'susan@example.com'</span></span>) &gt;&gt;&gt; db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(u) &gt;&gt;&gt; db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>()</code> </pre> <br><p>      ,   : </p><br><pre> <code class="hljs python"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>users = User.query.all() &gt;&gt;&gt; users [&lt;User john&gt;, &lt;User susan&gt;] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> users: ... print(u.id, u.username) ... <span class="hljs-number"><span class="hljs-number">1</span></span> john <span class="hljs-number"><span class="hljs-number">2</span></span> susan</code> </pre> <br><p>     ,          .    ‚Äî ,      ,   <code>all()</code> .  ,       <code>id</code>    1  2. </p><br><p>    .     ,      : </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; u = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.query.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt;&gt; u &lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> john&gt;</code> </pre> <br><p>     : </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; u = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.query.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt;&gt; p = Post(body=<span class="hljs-string"><span class="hljs-string">'my first post!'</span></span>, author=u) &gt;&gt;&gt; db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(p) &gt;&gt;&gt; db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>()</code> </pre> <br><p>         <code>timestamp</code> ,        ,       .     user_id? ,   <code>db.relationship</code> ,      <code>User</code> ,   <code>posts</code>  ,      .    ,    ,  ,      . SQLAlchemy     ,          . </p><br><p>  ,        : </p><br><pre> <code class="hljs vhdl">&gt;&gt;&gt; # get <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> posts written by a user &gt;&gt;&gt; u = User.query.get(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt;&gt; u &lt;User john&gt; &gt;&gt;&gt; posts = u.posts.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>() &gt;&gt;&gt; posts [&lt;Post my first post!&gt;] &gt;&gt;&gt; # same, but <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a user that has no posts &gt;&gt;&gt; u = User.query.get(<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; u &lt;User susan&gt; &gt;&gt;&gt; u.posts.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>() [] &gt;&gt;&gt; # print post author <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">body</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> posts &gt;&gt;&gt; posts = Post.query.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> posts: ... print(p.id, p.author.username, p.<span class="hljs-keyword"><span class="hljs-keyword">body</span></span>) ... <span class="hljs-number"><span class="hljs-number">1</span></span> john my first post! # get <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reverse alphabetical order &gt;&gt;&gt; User.query.order_by(User.username.desc()).<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>() [&lt;User susan&gt;, &lt;User john&gt;]</code> </pre> <br><p>   Flask-SQLAlchemy-  ,     ,      . </p><br><p>    ,      ,  ,            : </p><br><pre> <code class="hljs mel">&gt;&gt;&gt; users = User.query.all() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> users: ... db.session.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(u) ... &gt;&gt;&gt; posts = Post.query.all() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> posts: ... db.session.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(p) ... &gt;&gt;&gt; db.session.commit()</code> </pre> <br><h2 id="shell-context-ili-lekarstvo-ot-gemorroya"> shell context     </h2><br><p> ,       ,     Python? ,   ,     : </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> db &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, Post</code> </pre> <br><p>         ,          Python,        .  <code>flask shell</code> ‚Äî         . <code>shell</code> ‚Äî   "",  <code>flask</code> ,  .   -  Python   .  What does it mean?  Consider the following example: </p><br><pre> <code class="hljs pgsql">(venv) $ python &gt;&gt;&gt; app Traceback (most recent <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> last): File "&lt;stdin&gt;", <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; NameError: <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-string"><span class="hljs-string">'app'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined &gt;&gt;&gt; (venv) $ flask shell &gt;&gt;&gt; app &lt;Flask <span class="hljs-string"><span class="hljs-string">'app'</span></span>&gt;</code> </pre> <br><p>      <code>app</code> ,    ,    <code>flask shell</code>     .  <code>flask shell</code>    ,    ,   ,     ¬´shell context¬ª,         . </p><br><p>    <em>microblog.py</em>   ,          : </p><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> app, db <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User, Post @app.shell_context_processor <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_shell_context</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'db'</span></span>: db, <span class="hljs-string"><span class="hljs-string">'User'</span></span>: User, <span class="hljs-string"><span class="hljs-string">'Post'</span></span>: Post}</code> </pre> <br><p>  <code>app.shell_context_processor</code>      .    <code>flask shell</code> ,        ,     . ,     ,   ,   ,         ,       ,    . </p><br><p>  ,      <code>flask shell</code> ,       ,   : </p><br><pre> <code class="hljs ruby">(venv) $ flask shell <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>db &lt;SQLAlchemy engine=<span class="hljs-symbol"><span class="hljs-symbol">sqlite:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/Users/migu</span></span>7781/Documents/dev/flask/microblog2/app.db&gt; &gt;&gt;&gt; User &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">models</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">'&gt; &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> &lt;class '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">models</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><p>  <a href="https://habrahabr.ru/post/346342/">&lt;&lt;&lt; previous</a> <a href="https://habrahabr.ru/post/346346/">next &gt;&gt;&gt;</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346344/">https://habr.com/ru/post/346344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346334/index.html">Unlimited speech recognition. Or how I translate voice messages into text in a bot</a></li>
<li><a href="../346336/index.html">Rust: ‚ÄúUnsafe Abstractions‚Äù</a></li>
<li><a href="../346338/index.html">Using the inverse Laplace transform to analyze the dynamic links of control systems</a></li>
<li><a href="../346340/index.html">Flask Mega-Tutorial, Part 2: Patterns (Edition 2018)</a></li>
<li><a href="../346342/index.html">Flask Mega-Tutorial, Part 3: Web Forms (Edition 2018)</a></li>
<li><a href="../346346/index.html">Flask Mega-Tutorial, Part 5: Custom Logins (Edition 2018)</a></li>
<li><a href="../346348/index.html">Flask Mega-Tutorial, Part 6: Profile page and avatars (edition 2018)</a></li>
<li><a href="../346350/index.html">As a researcher hacked his own computer and became convinced of the reality of the most serious vulnerability in the history of processors</a></li>
<li><a href="../346352/index.html">Useful materials on SAN</a></li>
<li><a href="../346354/index.html">Touch or not: What are the cash registers of stores today?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>