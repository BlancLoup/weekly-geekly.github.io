<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We pump over NES Classic Mini - continuation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In February, I wrote an article about how Russian enthusiasts ‚Äúhacked‚Äù the NES Classic Mini console , how we did its reverse engineering, and how I wr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We pump over NES Classic Mini - continuation</h1><div class="post__text post__text-html js-mediator-article">  In February, I wrote <a href="https://habrahabr.ru/post/321064/">an article about how Russian enthusiasts ‚Äúhacked‚Äù the NES Classic Mini console</a> , how we did its reverse engineering, and how I wrote the application so that everyone can easily download their games into it in just a few clicks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a59/48a/d97/a5948ad975988e16c883e71835d4adda.png" alt="image"><br><br>  Today I will write a continuation of this story, because in six months we have made much more substantial progress in this matter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As usual, my story is under the cut both in the modern video form and in the form of a traditional article. <br><a name="habracut"></a><br><br><h2>  Video </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZJRx289keQ4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Article </h2><br><h3>  More emulators </h3><br>  The first turning point came when a person under the pseudonym <b>madmonkey</b> (if someone does not remember, it was he who was the author of the hacking) was able to compile the emulator <a href="http://www.retroarch.com/"><b>RetroArch</b></a> for NES Mini.  More precisely, it is not an emulator, but a multiplatform shell based on Libretro for launching other emulators, which are installed as modules.  Thanks to this, now on the NES Mini you can now run not only any games for NES, regardless of mappers, but also games from other consoles: SNES, Sega Mega Drive, Gameboy, Gameboy Advance and even simple games with Nintendo 64. Even the emulation of the cartridge works. <a href="https://www.youtube.com/watch%3Fv%3DVihgDVlgBY0">I developed it myself</a> if I compiled the fceux emulator module with my additions.  Open Source Magic. <br><br>  Of course, the emergence of such opportunities was accompanied by a bunch of new problems and challenges.  For example, I really wanted the emulation through RetroArch to run not from its own menu, but also from the NES Mini shell. <br><br><img src="https://habrastorage.org/web/f3d/198/195/f3d1981950c14235aacd005cceea9c01.jpg"><br><br>  I have already said that for each game in the config simply indicates the executable file that you want to run, and the command line parameters.  But besides this, the native NES Mini emulator interacts with the shell, namely, it allows you to exit the menu, save and change settings.  I wanted all these features to be maintained when using RetroArch.  So that the user could not even understand that a third-party emulator is used. <br>  This required some study of how the shell is arranged in the NES Mini.  However, everything turned out to be trite and simple.  In fact, when you press a button during a game to display a menu, the emulation does not pause.  The shell kills the emulator process, and the emulator saves the game to a temporary file when exiting and makes a screenshot.  The shell picks up these temporary files and shows this as a suspended game that can be saved.  In this case, the temporary files are simply copied to the permanent memory. <br>  As for the settings, they are all simply passed in the command line parameters. <br><br>  It turns out that the task is quite simple: you need to write a script to start RetroArch, which will parse the parameters from the NES Mini shell, start the emulation, kill the emulator by the signal from the shell, while keeping the game in the right place and making a screenshot. <br>  However, it was not without crutches.  If RetroArch is able to make automatic saves, then with the creation of a screenshot at exit, everything is not so simple.  Yes, RetroArch has an option to create screenshots for saving.  But it does not apply to automatic saves.  I decided to get a screenshot using an alternative method.  In Linux, the framebuffer, which contains the image from the screen, is accessible via the pseudo file " <i>/ dev / fb0</i> ".  It is only necessary to somehow read the data from it and save it as a PNG file.  Fortunately, I quickly found a ready-made utility for this, which is called ‚Äú <a href="https://fbgrab.monells.se/"><b>fbgrab</b></a> ‚Äù.  To my great surprise, I was able to compile it under the NES Mini on my own, but the screenshots obtained with its help were strange.  For some reason, in the NES Mini framebuffer, almost all useful pixels have an absolute transparency level.  I had to refine this utility so that it ignores transparency: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ALPHA */</span></span> outbuffer[(i&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>)+Alpha] = <span class="hljs-comment"><span class="hljs-comment">/*srcAlpha &gt;= 0 ? inbuffer[i*4+srcAlpha] :*/</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><br>  And where can there be transparency in the screenshot?  I hope someone will explain it to me in the comments. <br><br>  Soon everything worked, although the aspect ratio of the screenshots was a bit wrong, because the shell is designed to receive a screenshot in a ratio of four to three, not sixteen to nine, but this was again decided by a simple refinement of the utility.  Well, or not very simple.  I did an automatic aspect ratio determination. <br><br>  Alas, I could not find a full-fledged replacement for the retro-filter, which is in the original emulator, and which very realistically creates an imitation of a CRT-TV.  I do not like these filters, but in this case it looks really amazing and very realistic, I have never seen anything like it anywhere else.  Therefore, if possible, I still give priority to the original NES Mini emulator, but it does not start all the games. <br><br>  Let me remind you that inside each ".nes" file with the game contains a header, it describes the iron that was inside the original cartridge.  The emulator must emulate not only the console itself, but also this hardware.  The original NES Mini emulator emulates only the most popular cartridge options, RetroArch, thanks to modules, can run almost everything.  I added a code to the RetroArch startup script that reads the header of the NES file through the hexdump utility, parses it and automatically decides which emulator to run - the original one or RetroArch: <br><br><pre> <code class="bash hljs">supported_mappers=<span class="hljs-string"><span class="hljs-string">"0 1 2 3 4 5 7 9 10 86 87 184"</span></span> emulator=retroarch args=<span class="hljs-variable"><span class="hljs-variable">$@</span></span> filename=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> extension=<span class="hljs-variable"><span class="hljs-variable">${filename##*.}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$extension</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"nes"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> header=$(hexdump -v -n 8 -e <span class="hljs-string"><span class="hljs-string">'1/1 "%02X"'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$filename</span></span></span><span class="hljs-string">"</span></span>) mapper=$((0x<span class="hljs-variable"><span class="hljs-variable">${header:14:1}</span></span><span class="hljs-variable"><span class="hljs-variable">${header:12:1}</span></span>)) fourscreen=$(expr $((0x<span class="hljs-variable"><span class="hljs-variable">${header:13:1}</span></span>)) / 8) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> mapper: <span class="hljs-variable"><span class="hljs-variable">$mapper</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> four-screen: <span class="hljs-variable"><span class="hljs-variable">$fourscreen</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$supported_mappers</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$m</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$mapper</span></span></span><span class="hljs-string">"</span></span> ] &amp;&amp; emulator=kachikachi <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$fourscreen</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"1"</span></span> ] &amp;&amp; emulator=retroarch <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br><br>  As a result, the user generally does not need to bathe about the compatibility of NES games.  If the native NES Mini emulator does not support the game, RetroArch will start automatically.  If necessary, you can forcibly select the emulator via a special command line parameter. <br><br><h3>  Mod system </h3><br><br>  However, there were more serious tasks ahead.  How to allow users to install emulator and modules as easily as possible?  madmonkey proposed to develop a universal mod system that would be compatible with both his hakchi and my hakchi2, and at the same time would make it possible to install a variety of hacks on the NES Mini in the form of plug-ins: from banal skins to emulators and alternative shells. <br>  It was a series of sleepless nights when madmonkey and I sat in IRC and discussed how best to do everything.  At the same time, he wrote a very beautiful code, and I tested it, found errors and corrected them with the help of my terrible code.  Then he replaced my curve code with his own, after which everything was repeated anew.  This went on for a week, in the end the mod system was ready. <br><br>  We agreed that modules should have the extension ‚Äú.hmod‚Äù, while being in fact ‚Äú.tar.gz‚Äù archives that contain the necessary files and scripts that are executed during installation and removal.  At the same time, hakchi itself implemented a set of functions for copying and replacing files.  Later, I wrote a detailed guide on how to create mods with examples, starting with a banal interface editing and even before putting a password on your NES Mini, you can read it on GitHub: <br>  <a href="https://github.com/ClusterM/hakchi2/wiki/Modifications-and-modules-guide">github.com/ClusterM/hakchi2/wiki/Modifications-and-modules-guide</a> (in English). <br><br>  All this allowed the community to participate in the creation and distribution of various modifications.  So, skins and modules for the Famikom translation into English, and much more, soon began to appear on the network.  By the way, madmonkey made the process of turning the NES Mini into a Famicom Mini very easy, as well as vice versa.  I transferred to the modules a part of the hakchi2 functional like extended fonts and a controller driver.  And of course, the very first mod presented to the public was the RetroArch emulator described above and plug-ins to it for emulating different consoles.  We must pay tribute to the person with the nickname <b>pcm720</b> , who took the responsibility to develop the mod project further, I even gave him full rights to GitHub.  It's great when there are such people, because it's difficult to follow several projects at once, but I wanted to continue working on hakchi2. <br>  RetroArch mod on GitHub: <a href="https://github.com/ClusterM/retroarch-clover">github.com/ClusterM/retroarch-clover</a> <br><br>  By the way, hakchi2 of course had to be finalized too.  And if everything is clear with the installation and removal of modules, it was not entirely clear with the games.  I really didn‚Äôt want to add support for games from platforms other than NES directly to hakchi2.  Still, this is a non-standard chip added by a separate mod, which is not included.  However, a huge community of users really wanted it, and even with icons, covers and other features.  So I gave up.  Made for each console a separate class with its own features.  and the person under the name <b>NeoRame</b> drew a bunch of cool pictures for each console, for which he thanks a lot. <br><br><h3>  It could be easier </h3><br><br>  And then it was the most interesting.  When people began to record hundreds of different games from different platforms, constantly adding or deleting something, they were faced with the problem that every time, even with the addition of just one game, it was necessary to download all the games again.  After all, as I told in the last article, we have no feedback from the console.  We just take a bunch of games, a script to install them and run this case on the NES Mini, assuming that the games already installed should be removed and the new ones installed.  We have no way of knowing which games are already installed. <br><br>  Similarly, without a UART cable, there is no way to get any files from the system.  You can not even banal save their save from there.  You can‚Äôt even see how your system was dubbed, that there is not enough space there, which is really bad. <br><br>  In general, we began to think how to solve this problem.  madmonkey, for example, offered to write the necessary information into separate areas of flash memory, and then read them from there through the FEL mode, but I considered this option as the most extreme. <br><br>  Reflecting on this task, I gradually continued to study the device of the NES Mini system and noticed that the startup of the USB gadget called ‚Äúclover‚Äù was in startup.  Obviously, this is something developed by Nintendo itself.  Under the GPL license, the source code of the module must be publicly available.  That's right, I found it among the Linux kernel sources <a href="https://www.nintendo.co.jp/support/oss/">on the Nintendo website</a> .  Just one small file ... <br><br><img src="https://habrastorage.org/web/f22/67b/d35/f2267bd35c1f4ccba3b06a3d962a06b8.PNG"><br><br>  Judging by the comments, its main goal is a request for high current consumption from USB.  Logically, this is so that the console can be powered not only from the mobile charge, but also from the computer.  Actually, therefore, the computer defines the NES Mini as a device.  What else is there? <br><br><img src="https://habrastorage.org/web/1a2/2ff/87a/1a22ff87a5f944c998d76e6d587b929d.PNG"><br><br>  Suddenly, a USB input / output code.  And the code to work with the pseudo file.  I checked - this pseudo file really is on the NES Mini. <br><br>  At this moment, I was torn apart by contradiction and misunderstanding.  On the one hand, I see that this should work.  In theory.  On the other hand, I cannot believe that no one had thought of this before me.  And if this is true, have we really used such crutches for so long?  I quickly sketched a program for a computer that writes data to USB.  And successfully read them from this pseudo file.  As well as vice versa.  It works. <br><br>  For the next few days, I remembered my long-forgotten programming skills under Linux and wrote a daemon that runs on the NES Mini and allows me to directly access the console and execute commands via USB, redirecting I / O streams via USB.  For the computer, the client wrote: <br>  <a href="https://github.com/ClusterM/clovershell-client">github.com/ClusterM/clovershell-client</a> <br><br>  With it, you can dump all the original firmware with one simple command: <br><pre> <code class="bash hljs">clovershell <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> <span class="hljs-string"><span class="hljs-string">"dd if=/dev/mapper/root-crypt | gzip"</span></span> &gt; dump.img.gz</code> </pre> <br><br>  Later, I completely adapted hakchi2 for a new data transfer method.  As a result, to download games, you no longer need to clamp the reset, and the transfer occurs very, very quickly.  Literally in a minute all memory will be filled.  Previously, it took half an hour, and it was necessary to break the process into several visits, while large files could not be transferred at all.  I don‚Äôt know why Nintendo left this functionality, but it really helped us. <br><br>  Soon, based on all of this, hakchi2 introduced a game saving manager, the ability to take screenshots, and even an FTP server.  Yes, I took a ready-made FTP server library, where the work with the file system was implemented as a separate abstraction, and simply wrote a class that redirects all file operations via USB.  As a result, we connect via FTP to localhost and see the files that are inside the NES Mini.  Needless to say, as far as this facilitated the work of the creators of mods.  UART-cable, even I stopped using without much need. <br><br>  The moral of this story is that - if no one has yet done what seems easy and obvious to you, do not stop.  You are very likely to do this.  There are millions of people in the world who can do amazing things, but don‚Äôt do it just because they don‚Äôt believe in themselves.  They do not believe that others would not have done it if they could.  And sometimes it's enough just to start. <br><br>  In the future, there were still a lot of minor fixes and improvements, about which there is no point in telling.  I'll tell you about the most interesting. <br><br><h3>  Improved support for third-party controllers </h3><br><br>  I was able to figure out why many third-party controllers designed for the Wii did not work with the NES Mini, despite the same connector and protocol.  I did not have such, but often complained about the problem. <br>  First, it turns out that Classic Controller has two data transfer formats.  And they can choose.  On the Internet, only one is described everywhere: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/119/0ab/8871190ab05da519bf8cfeb7d2ea15ab.png" alt="image"><br><br>  And in many third-party controllers, only he is implemented.  The driver of the clovercon-controllers (I remind you that its sources are also publicly available) uses a different format, which has more capacity and accuracy of analog sticks.  Very ironic, because the NES Mini does not initially use analogs. <br><br>  Secondly, in the clovercon driver code on the NES Mini, there is protection from power interference, which is typical when powering is not from batteries.  He checks that all unused data in the memory of the controller is zero, although many Chinese controllers, on the contrary, are clogged with FFs. <br><br>  All this was decided by the driver.  But still there were very, very Chinese controllers who did not want to work.  And the problem was the hardware, apparently.  To solve this riddle, immediately two people sent me their controllers for testing.  Thanks for this to Vladimir Kondratenko and keithelmcity from the GBATemp website.  The answer turned out to be simple - just pull up the SDA and SCL lines with two resistors to the power supply.  This is required by the I¬≤C protocol, which is used in these controllers.  The Chinese saved on a couple of resistors.  Alas, to fix this is not as easy as updating the program, but many users without any problems were able to do it themselves.  Fortunately, even the one who holds the soldering iron for the first time can probably solder two resistors. <br><br><h3>  Other </h3><br><br>  When I was already bored with this project, and the plans for further development were almost over, I finally shared a table with lines from the program for people, and almost two dozen people from different parts of the world translated it into their languages.  You know, this is a very strange feeling when you work on a program for a long time, and then you see it in French, German, Spanish, Italian, Greek, and a bunch of different languages: <br><br><img src="https://habrastorage.org/web/352/0c3/51e/3520c351e3b040f29c087ac41ba2bdc1.png"><br><br>  Perceived as something native, and someone else at the same time. <br><br>  I still had some ideas and plans.  For example, connect the SD card to the free contacts that are inside the NES Mini.  But I really do not like for a long time to engage in any one project, and the people have already lost interest.  So I‚Äôll probably make further changes only after the release of the SNES Mini, if it is hacked. <br><br>  hakchi2 on github: <a href="https://github.com/ClusterM/hakchi2">github.com/ClusterM/hakchi2</a> </div><p>Source: <a href="https://habr.com/ru/post/333418/">https://habr.com/ru/post/333418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333404/index.html">Was there a hacking of "Gosuslug"? Yandex Hypothesis</a></li>
<li><a href="../333406/index.html">How Angry Birds 2 increased revenue several times over the year</a></li>
<li><a href="../333410/index.html">Developing wrapper scripts using the Sparrow tool</a></li>
<li><a href="../333412/index.html">Creating a schedule for SCADA systems based on cron</a></li>
<li><a href="../333414/index.html">The road to C ++ 20</a></li>
<li><a href="../333420/index.html">Comodo Internet Security Local Update Server</a></li>
<li><a href="../333422/index.html">Unity on Linux? No problem</a></li>
<li><a href="../333424/index.html">Creating a directory of address information with blackjack and API</a></li>
<li><a href="../333426/index.html">Exact calculation of averages and covariances by the Welford method</a></li>
<li><a href="../333428/index.html">Is it possible to leave Klintsy? (data mining of blablacar.ru)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>