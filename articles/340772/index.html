<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Evolutionary Computing: Learning to Walk a Stool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This tutorial is dedicated to evolutionary computing, how they work and how to implement them in their projects and games. After reading the article, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Evolutionary Computing: Learning to Walk a Stool</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a4/b34/faa/4a4b34faaa59bd09b785abdf42713afd.png" alt="image"></div><br><br>  This tutorial is dedicated to evolutionary computing, how they work and how to implement them in their projects and games.  After reading the article, you will be able to master the power of evolution to find solutions to problems that you are unable to solve.  As an example, this tutorial will show how evolutionary computing can be used to teach a simple creature to walk.  If you want to experience the power of evolutionary computing in the browser, check out <a href="http://rednuht.org/genetic_walkers/">Genetic Algorithm Walkers</a> . <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/5e1/dbb/4c65e1dbbdf0445a17f41c1dd4cc64cd.gif" alt="evolution"></div><br><br><h2>  Part 1. Theory </h2><br><h4>  Introduction </h4><br>  As a programmer, you are probably familiar with the concept of the algorithm.  If you have a problem, then you write a clear set of instructions for solving it.  But what happens when the task is too complicated, or you do not understand how to solve it?  There is a very clear strategy for an optimal sudoku game, but not for face recognition.  How to code a solution to a problem, if you have no idea how to solve it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this case, artificial intelligence is usually used.  One of the simplest techniques that can be used to solve this class of problems is <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258E%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B">evolutionary computation</a> .  In short, they are based on the idea of ‚Äã‚Äãapplying Darwinian evolution to a computer program.  The goal of evolution is to improve the quality of a bad solution with random mutations until the problem is solved with the necessary accuracy.  In this tutorial, we will look at how evolutionary computations can be applied to teach optimal walking strategies.  A more complex implementation can be seen in the video below (article: <a href="http://www.goatstream.com/research/papers/SA2013/">Flexible Muscle-Based Locomotion for Bipedal Creatures</a> ). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pgaEE27nsQw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h4>  <s>Natural</s> artificial selection </h4><br>  There is a possibility that you have heard the Darwinian concept of <strong>survival of the fittest</strong> .  The basic idea is simple: survival is a difficult task, and surviving creatures have a higher chance of reproduction.  The environment <strong>naturally selects the</strong> creatures that are most suited to it, killing those who do not cope with this task.  This is often demonstrated on an overly simplistic (and misleading) example of giraffes: a longer neck helped giraffes to reach the upper branches.  Over time, giraffes were picked with longer and longer necks.  There has never been a direct force ‚Äúlengthening‚Äù the neck of a giraffe: the environment itself gradually selected individuals with longer necks. <br><br>  The same mechanism can be applied to computer programs.  If we have an approximate solution to the problem, then we can randomly change it and check whether it has improved its results.  If we continue to repeat this process, then as a result we will always get the best (or the same) solution.  Natural selection does not depend on the task, in essence it is controlled by random mutations. <br><br><h4>  Phenotype and genotype </h4><br>  To understand how calculations can be combined with evolution, we first need to understand the role of evolution in biology.  In nature, every creature has a body and a set of behaviors.  They are known as its <strong>phenotype</strong> , that is, how the creature looks and behaves.  Hair, eyes, skin color are all part of your phenotype.  The appearance of a creature is mainly determined by a set of instructions written inside its cells.  This is called a <strong>genotype</strong> and refers to information transmitted mainly through DNA.  The phenotype is what a house looks like after construction, the genotype is the original drawing that controlled its creation.  The first reason we share the phenotype and the genotype is very simple - the environment plays a huge role in the final appearance of the creature.  The same house, built with a different budget, can be very different. <br><br>  In most cases, it is the environment that will determine the success of the genotype.  From the point of view of biology, success is quite a long survival.  Successful creatures have greater chances of reproduction, the transfer of their genotype to their descendants.  Information about the creation of the body and the behaviors of each creature is stored in its DNA.  When a creature multiplies, its DNA is copied and transmitted to the descendant.  In the process of replication, there are random mutations that make changes in DNA.  These changes can potentially lead to changes in the phenotype. <br><br><h4>  Evolutionary programming </h4><br>  <em>Evolutionary computing</em> is a rather broad and vague ‚Äúumbrella‚Äù term, combining many different, albeit similar, techniques.  More specifically, we will focus on <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258E%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">evolutionary programming</a> : the repeatable algorithm will be constant, but its parameters are open for optimization.  From a biological point of view, we use natural selection only for the creature's brain, but not for its body. <br><br>  Evolutionary programming is a simple imitation of the mechanism of natural selection: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/26a/f84/9e726af84c708c82bcc9c318a85ef4f5.png"></div><br><br><ul><li>  <strong>Initialisation.</strong>  Evolution should start from the initial decision.  Choosing a good starting point is important because it can lead to completely different results. </li><li>  <strong>Duplication (duplication).</strong>  Many copies of the current solution are created. </li><li>  <strong>Mutation (mutation).</strong>  Each copy randomly mutates.  The magnitude of the mutation is critical because it controls the speed of the evolutionary process. </li><li>  <strong>Evaluation.</strong>  The gene score is changed, depending on the performance shown by the generated creature.  In many cases, it requires an intensive simulation stage. </li><li>  <strong>Selection.</strong>  After evaluating the creatures, the best of them is allowed replication, allowing it to become the basis of the next generation. </li><li>  <strong>Output.</strong>  Evolution is an iterative process, at any stage it can be stopped to get an improved (or the same) version of the previous generation. </li></ul><br><h4>  Local maxima </h4><br>  The goal of evolution is to maximize the adaptation of the genome, the best fit to a particular environment.  Despite a deep connection with biology, it can be considered as a pure optimization problem.  We have a function of fitness and we need to find the point of its maximum.  The problem is that we do not know what the function looks like and can only make guesses by choosing (simulating) points around the current solution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/bb3/24d/7b0bb324dfbf419c75217cf949a5905c.png"></div><br><br>  This graph shows how various mutations (on the X axis) lead to different assessments of fitness (the Y axis).  Evolution deals with sampling random points in a local neighborhood. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/340772/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgZFiMSeQQbkiE3P5nKi-eVRspbHw#MJMATHI-78" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> x </script> trying to increase fitness.  If we consider the size of the neighborhood, then it will take many generations to reach the maximum.  And at this stage, everything becomes difficult.  If the neighborhood is too small, the evolution can get stuck in <strong>local maxima</strong> .  These are solutions that are optimal locally, but not globally.  Very often, local maxima are found in the middle of the pits of fitness.  When this happens, evolution may not find a better solution nearby, and then get stuck.  It is often said that cockroaches are stuck in evolutionary local maxima ( <a href="http://www.bbc.co.uk/earth/story/20150413-can-an-animal-stop-evolving">Can An Animal Stop Evolving?</a> ): They are incredibly successful in their lifestyles, and any long-term improvements require a too high short-term retribution by reducing their fitness. <br><br><h4>  Conclusion </h4><br>  In this part, we became acquainted with the concept of evolution and its role in artificial intelligence and machine learning. <br><br>  In the next part, we will begin to create an implementation of evolutionary computing.  The first necessary step is the creation of the body of a being that can evolve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/aa0/6c9/a7baa06c912a2c12c59ee24d41483984.gif"></div><br><br><h2>  Part 2. Phenotype. </h2><br>  In the first part of the tutorial, we learned what evolutionary computations are and how they work.  In the remainder, we will explain how to create a practical example and how to use evolution to solve a real problem.  In our case, it consists in teaching the two-legged creature to maintain balance and to walk effectively.  Instead of an evolutionary change in the body of a creature, we are interested in finding a strategy that allows it to move as quickly as possible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/85a/daf/d7785adafdc991f4173c0851400909b1.gif"></div><br><br><h4>  Body </h4><br>  The first step is to create the creature we use.  It is important to remember that evolution is a rather slow process.  If we start with a humanoid ragdoll, then achieving a sustainable and effective walking strategy may be too long.  If we want to test our evolutionary software, then we need to start with something simpler. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a4/b34/faa/4a4b34faaa59bd09b785abdf42713afd.png"></div><br><br>  The object of our experiment will be a very simple two-legged creature.  It has two legs, L and R, which are attached to the body by hinges.  Thanks to two springs, they can be rotated.  When the springs expand and contract, they retract and pull the legs, forcing them to turn.  The creature does not know how to directly turn its legs, but can control the length of the springs, passing them a value in the range from -1 (compressed) to +1 (stretched). <br><br>  <strong>Note:</strong> Moving complex bodies is a serious task.  For the final project, I replaced Unity <code>SpringJoint2D</code> with <code>DistanceJoint2D</code> because they are more predictable.  But I will still call them springs.  For the more complex ragdoll shown in the animation, body parts will be rotated directly from the code. <br><br><h4>  Brain </h4><br>  Walking is not only a matter of finding the right angles for L and R. This is a long-term task that requires equally continuous leg movements.  If we want to walk, then we need to provide a substantially compact and meaningful way to move our legs.  The list of possible ways here is endless.  For the sake of simplicity, the relaxation and compression of the springs will be controlled by two sinusoids. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0e/4d9/2c7/f0e4d92c792ac1710fe89ec624b0fe18.gif"></div><br><br>  The evolutionary process will adjust the L and R sinusoids so that the creature can walk.  An example is shown in the animation above: the green and red sine waves control the legs L and R respectively. <br><br>  Springs are creature-driven entities, they will be the target of our evolutionary computation.  Each sinusoid has a period <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> p </script>  in the range of <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> m </script>  before <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">M</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> M </script>  and shifted along the x axis by <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">o</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> o </script>  .  This means that the goal of evolution is to find two sets for these four parameters, which as a result give the best walking strategy. <br><br><h4>  Controller </h4><br>  In the existing system, we have several entities: legs, springs and sinusoids.  To simplify the way of solving the problem, let's create the class <code>LegController</code> , which allows controlling the compression of the springs using values ‚Äã‚Äãfrom -1 to +1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/e84/29e/dd9e8429e9f87e6be78e6dcdde55797e.png"></div><br><br>  We rotate the legs by changing the length of the spring in <code>FixedUpdate</code> .  This causes the connection to tighten or push the foot until it reaches the desired destination. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LegController</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DistanceJoint2D spring; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> contracted; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> relaxed; [Range(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position = +<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = spring.distance; relaxed = distance * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>; contracted = distance / <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { spring.distance = linearInterpolation(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>, contracted, relaxed, position); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linearInterpolation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = x1 - x0; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (y0 + y1) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y0 + (x - x0) * (y1 - y0) / d; } }</code> </pre> <br>  Two foot controllers are constantly updated with the <code>Creature</code> class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Creature</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LegController left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LegController right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { left.position = <span class="hljs-comment"><span class="hljs-comment">// ... right.position = // ... } }</span></span></code> </pre> <br>  In the next part of the tutorial, we will see how the <code>Creature</code> class evolves to include the creature's genome. <br><br><h4>  Fitness score </h4><br>  Evolution requires the assessment of the fitness of a being.  This stage, although it seems rather trivial, is in fact incredibly complex.  The reason is that the score we assign to each creature at the end of the simulation must correctly display exactly what we want to learn.  If we fail to do this, then we will inevitably get poor results, and evolution will be stuck in local maxima. <br><br>  My first attempt was to assess the fitness of the creature depending on the distance traveled from the starting point: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 initialPosition; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { initialPosition = transform.position; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetScore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position.x - initialPosition.x; }</code> </pre> <br>  This led to the least-effort walk strategy ‚Äî dragging yourself across the floor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/298/5fc/10a2985fc40b1f623a0da37402b21c13.gif" alt="image"></div><br><br>  I was not satisfied with this decision, because it did not seize one of the most important aspects of walking: maintaining balance.  In the second attempt, I added a very serious bonus to all creatures who managed to stay on their feet: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetScore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   float walkingScore = position.x - initialPosition.x; //   bool headUp = head.transform.eulerAngles.z &lt; 0+30 || head.transform.eulerAngles.z &gt; 360-30; bool headDown = head.transform.eulerAngles.z &gt; 180-45 &amp;&amp; head.transform.eulerAngles.z &lt; 180+45; return walkingScore * (headUp ? 2f : 1f) //  ,  UP * (headDown ? 0.5f : 1f) //     ,  DOWN ; }</span></span></code> </pre> <br>  Since falling is incredibly simple, this function of fitness encouraged beings capable of maintaining good balance.  However, she did not really encourage them to walk.  The fall was estimated too strictly, and evolution did not feel bold enough to risk it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/e04/aeb/0a2e04aebbf33286001d1f29cbcf2ba1.gif" alt="image"></div><br><br>  To compensate for this, I tried to give impetus to the fact that maintaining balance was evaluated independently of walking. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walkingScore * (headDown ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">1f</span></span>) + (headUp ? <span class="hljs-number"><span class="hljs-number">2f</span></span> : <span class="hljs-number"><span class="hljs-number">0f</span></span>) ;</code> </pre> <br>  In all my attempts, creatures came to an awkward, but very functional solution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/094/4ab/ec4/0944abec40cb4a1451f697d223b2500c.gif" alt="image"></div><br><br><h4>  Conclusion </h4><br>  In this part, we became acquainted with the body of the creature that will be used in the simulation.  If you choose the design meaningfully, then evolution will work regardless of body type.  It is worth noting that in my first attempt a much more complex body was used, in which four interconnected springs were used.  It did not work very well because evolution was abusing the instability of the Box2D constraints, forcing the creature to fly at high speed.  Yes, evolution likes to cheat, and very much. <br><br>  <b>In the third part of the tutorial, we will focus on the correct presentation and mutations of the creature's genome.</b>  <b>The basis of this technique is the use of a form that is amenable to evolutionary computing.</b> <br><br><h2>  Part 3. Genotype. </h2><br>  When we consider a task through the lens of evolution, we always need to take into account two sides of the coin: the <strong>phenotype</strong> and the <strong>genotype</strong> .  In the previous section, we looked at the creation of the body of a being and its brain.  Now it's time to focus on its genotype, that is, the method of presentation, transmission and mutation of such information. <br><br><h4>  Genome </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0e/4d9/2c7/f0e4d92c792ac1710fe89ec624b0fe18.gif"></div><br><br>  As stated above, each leg is controlled by a sine wave. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">s</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> s </script>  set by four parameters: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> m </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">M</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> M </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> p </script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">o</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> o </script>  , i.e: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">s</span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-24">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">c</span><span class="MJXp-mrow" id="MJXp-Span-29"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">M</span><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">m</span></span><span class="MJXp-mrow" id="MJXp-Span-33"><span class="MJXp-mn" id="MJXp-Span-34">2</span></span><span class="MJXp-mtext" id="MJXp-Span-35">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">t</span><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-41">1</span><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">n</span><span class="MJXp-mtext" id="MJXp-Span-46">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">t</span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mtext" id="MJXp-Span-52">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">t</span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58">t</span><span class="MJXp-mo" id="MJXp-Span-59" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60">o</span><span class="MJXp-mtext" id="MJXp-Span-61">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">t</span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mtext" id="MJXp-Span-68">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">c</span><span class="MJXp-mrow" id="MJXp-Span-73"><span class="MJXp-mn" id="MJXp-Span-74">2</span><span class="MJXp-mtext" id="MJXp-Span-75">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">i</span></span><span class="MJXp-mrow" id="MJXp-Span-78"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">p</span></span><span class="MJXp-mtext" id="MJXp-Span-80">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">t</span><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mtext" id="MJXp-Span-87">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">t</span><span class="MJXp-mo" id="MJXp-Span-93" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-94" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">m</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-11"> s = \ frac {M-m} {2} \ left (1 + sin \ left (\ left (t + o \ right) \ frac {2 \ pi} {p} \ right) \ right) + m </script></p><br>  This is just an ordinary sinusoid with a period <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> p </script>  in the range of <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> m </script>  before <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">M</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> M </script>  and offset along the x axis by <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">o</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> o </script>  . <br><br>  The task of learning to walk has now become the task of finding a point in space with 8 dimensions (4 for each foot).  Let's start creating the genome for one leg.  It will be stored in a structure called <code>GenomeLeg</code> .  It wraps four necessary parameters and provides an opportunity to evaluate the sinusoid it represents: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> GenomeLeg { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> M; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> p; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvaluateAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (M - m) / <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> + Mathf.Sin((time+o) * Mathf.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / p)) + m; } }</code> </pre> <br>  Now we need to wrap the two <code>GenomeLeg</code> into a single structure that will store the entire genome: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Genome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GenomeLeg left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GenomeLeg right; }</code> </pre> <br>  At this stage, we have a complete structure defining the creature‚Äôs walking strategy.  This allows us to complete the <code>Creature</code> class, which we left in the previous section: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Creature</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Genome genome; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LegController left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LegController right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { left.position = genome.left.EvaluateAt(Time.time); right.position = genome.right.EvaluateAt(Time.time); } }</code> </pre> <br><h4>  Cloning </h4><br>  The very basis of evolution is the concept of genome transmission and mutation.  For evolution to work, we need to create copies of the genome and apply random mutations to them.  Let's start by adding the <code>Clone</code> method to the <code>GenomeLeg</code> structure: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GenomeLeg </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GenomeLeg leg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenomeLeg(); leg.m = m; leg.M = M; leg.o = o; leg.p = p; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> leg; }</code> </pre> <br>  And also to the <code>Genome</code> structure: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Genome </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Genome genome = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Genome(); genome.left = left.Clone(); genome.right = right.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> genome; }</code> </pre> <br>  It is worth noting that since they are <em>small structures (shallow structs)</em> , the <code>Clone</code> method is not required.  Structures are treated as primitive types: they are always copied when they are transmitted or assigned. <br><br><h4>  Mutation </h4><br>  The most interesting part of this tutorial is obviously the mutations.  Let's start with a simple one: mutate the <code>Genome</code> structure.  We randomly select a leg and apply a mutation to it: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>,<span class="hljs-number"><span class="hljs-number">1f</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ) left.Mutate(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> right.Mutate(); }</code> </pre> <br>  Now we need to take the leg's genome and apply a random mutation that could potentially improve its fitness.  This can be done in an infinite number of ways.  The one I chose for the tutorial simply selects a random parameter and changes it by a small amount: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: m += Random.Range(<span class="hljs-number"><span class="hljs-number">-0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); m = Mathf.Clamp(m, <span class="hljs-number"><span class="hljs-number">-1f</span></span>, +<span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: M += Random.Range(<span class="hljs-number"><span class="hljs-number">-0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); M = Mathf.Clamp(M, <span class="hljs-number"><span class="hljs-number">-1f</span></span>, +<span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: p +=Random.Range(<span class="hljs-number"><span class="hljs-number">-0.25f</span></span>, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); p = Mathf.Clamp(p, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: o += Random.Range(<span class="hljs-number"><span class="hljs-number">-0.25f</span></span>, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); o = Mathf.Clamp(o, <span class="hljs-number"><span class="hljs-number">-2f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  The <code>Mutate</code> method contains a lot of <em>magic numbers</em> - constants that appear from nowhere.  Although it would be logical to limit the values ‚Äã‚Äãof our parameters, setting the mutation volumes, but here it is rather inefficient.  A more sensible way would be to fine tune the parameters according to how close we are to the solution.  When we are close to the goal, we need to slow down so as not to jump over the right solution and not to miss it.  This aspect, often called <em>adaptive learning rate</em> , is an important stage of optimization that will not be considered in the tutorial. <br><br>  It is also worth noting that changing values ‚Äã‚Äãby small values ‚Äã‚Äãcan also prevent a better solution from being found.  It is better to choose an approach in which one of the parameters is randomly replaced. <br><br><h4>  Conclusion </h4><br>  In this section, we explained how to present the behavior of a previously created creature in such a way that it can be controlled through evolutionary computing techniques. <br><br>  <strong>In the next part, we will complete the evolution tutorial, showing the last necessary fragment: the evolution cycle itself.</strong> <br><br><h2>  Part 4. Cycle. </h2><br>  Our adventure of mastering the power of evolution comes to an end.  In the previous three parts of the tutorial, we created a bipedal body and a mutated genome that determines its behavior.  It remains for us to implement the evolutionary computation itself in order to find a successful walking strategy. <br><br><h4>  Evolution cycle </h4><br>  Evolution is an iterative process.  We use korutina to ensure the continuation of such a cycle.  In short, we will start with a certain genome and create several mutated copies.  For each copy, we will create an instance of the creature and test its operation in the simulation.  Then we take the genome of the most successful creature and repeat the iteration. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> generations = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simulationTime = <span class="hljs-number"><span class="hljs-number">15f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Simulation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; generations; i ++) { CreateCreatures(); StartSimulation(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">simulationTime</span></span></span><span class="hljs-function">)</span></span>; StopSimulation(); EvaluateScore(); DestroyCreatures(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre> <br><h4>  Simulation </h4><br>  To test the success of the creature‚Äôs walk, we need to create its body and give it enough time to move.  To simplify the work, let's imagine that there is a fairly long floor in the game scene.  We will create instances of creatures on top of it, at a considerable distance so that they do not affect each other.  The code below performs exactly this task, placing creatures (stored in prefabs) at a certain <code>distance</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variations = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Genome bestGenome; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 distance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject prefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Creature&gt; creatures = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Creature&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCreatures</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; variations; i ++) { <span class="hljs-comment"><span class="hljs-comment">//    Genome genome = bestGenome.Clone().Mutate(); //    Vector3 position = Vector3.zero + distance * i; Creature creature = Instantiate&lt;Creature&gt;(prefab, position, Quaternion.identity); creature.genome = genome; creatures.Add(creature); } }</span></span></code> </pre> <br>  The <code>CreateCreatures</code> feature <code>CreateCreatures</code> track of all created creatures so that they can be manipulated more easily.  To improve management, we will disable the Creature script in the creature prefab.  Because of this, the creature will not move.  Then we can start and stop the simulation using the following functions. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartSimulation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Creature creature <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> creatures) creature.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopSimulation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Creature creature <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> creatures) creature.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyCreatures</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Creature creature <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> creatures) Destroy(creature.gameObject); creatures.Clear(); }</code> </pre> <br><h4>  Fitness score </h4><br>  Evolution is about assessing fitness.  After the simulation is completed, we cycle around all the creatures and get their final estimate.  We are tracking the best creature so that you can mutate it in the next iteration. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bestScore = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvaluateScore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Creature creature <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> creatures) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> score = creature.GetScore(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (score &gt; bestScore) { bestScore = score; bestGenome = creature.genome.Clone(); } } }</code> </pre> <br><h4>  Improvements </h4><br>  The attentive reader may have noticed that the technique described in this article depends on several parameters.  Namely: <code>generations</code> , <code>simulationTime</code> and <code>variations</code> .  They represent, respectively, the number of simulated generations, the duration of each simulation and the number of variations created in each generation.  However, an even more attentive reader might also notice that the strategy used is poisoned by implied assumptions.  They are the result of too simplified selected characteristics of the structure, which are now becoming hard constraints.  Therefore, the results of a one-hour program and a month-running program will differ.  In this section, I will try to solve problems with some of these limitations by creating more reasonable alternatives that you can implement yourself. <br><br><ul><li>  <strong>Top K genomes.</strong>  Genomes starting the next generation are the best of all generations.  This means that if the current generation cannot improve fitness, then the next generation will start from the same genome.  The obvious trap here is that we can get stuck in a cycle in which the same genome is simulated again and again, without any reasonable improvement.  A possible solution would be to always take the best genome from the current run.  The disadvantage of this approach is that fitness can decrease if none of the mutations bring any improvements.  A more reasonable approach would be to select the best <code>k</code> genomes from each generation, and use them as the basis for the next iteration.  You can add the unmutated best genome of the previous generation, so that the fitness does not deteriorate, but you can also find the best solutions. </li><li>  <strong>Adaptive learning speed.</strong>  With each mutation of the genome, we change only one parameter of the leg and by a certain amount.  Only mutations move us in the parameter space in which our solution lies.  The speed with which we are moving is very important: if we move too far, we can jump over the decision, but if we move too slowly, then we can not get out of local maxima.  The number of mutations performed ( <em>learning rate</em> ) of the genome must be related to the speed with which the score improves.  The animation below shows how significant the effect of various strategies on the speed of convergence can be. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d5/166/a3d/5d5166a3d3712e7c03af74b1ccacbeac.gif"></div><br><br><ul><li>  <strong>Early completion.</strong>  It is easy to see that some simulations lead us to a dead end.  Every time a creature rolls onto its back, it will never be able to get back on its feet.  A good algorithm should recognize them and interrupt such simulations to save resources. </li><li>  <strong>Changing the function of fitness.</strong>  If what you want to learn is difficult enough, then perhaps it is worth doing it in stages.  This can be realized by gradually changing the function of fitness.  This way we can focus our training efforts on a simple task. </li><li>  <strong>A few checks.</strong>  When it comes to physics simulation, there is a chance that you will never get one result twice.  There is a good way to create several instances of a creature with the same genome under the same conditions, and then average their scores in order to get a more reliable estimate. </li></ul><br><h4>  Conclusion </h4><br>  In this tutorial we got acquainted with evolutionary calculations and dealt with their work.  This topic is incredibly broad, so take this article as a general introduction. <br><br>  <strong>The full Unity package for this project can be downloaded <a href="https://drive.google.com/open%3Fid%3D0B4nCcaMlgxV2bk9wRVhtQkRrRUE">here</a> .</strong> </div><p>Source: <a href="https://habr.com/ru/post/340772/">https://habr.com/ru/post/340772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340758/index.html">Asynchronous modes of gRPC framework and principles of their work in C ++</a></li>
<li><a href="../340760/index.html">Meeting in St. Petersburg November 16: Delivery-infrastructure for companies and individual projects</a></li>
<li><a href="../340764/index.html">Co-Laboratory: Atlassian User Group mitap</a></li>
<li><a href="../340768/index.html">Monitoring git clone and git push events on a local GitLab server</a></li>
<li><a href="../340770/index.html">Introduction to Beautiful Capi, C ++ wrapper creation tool for C ++ libraries</a></li>
<li><a href="../340774/index.html">My rules are a good design system. Components and interface architecture in Figma</a></li>
<li><a href="../340776/index.html">Isomorphic React JS + Spring Boot application</a></li>
<li><a href="../340778/index.html">Method of formalized models as an alternative to neural networks</a></li>
<li><a href="../340780/index.html">Programming for 3CX in C #: use the 3CX Call Control API in the Call Flow Designer development environment</a></li>
<li><a href="../340782/index.html">Fake cryptocurrency trading applications from Google Play were stolen by data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>