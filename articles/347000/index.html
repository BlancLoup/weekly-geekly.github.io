<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>McSema and decompiling into LLVM source code: is it real?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine that there is some very useful program, but it, for example, exists only in the Windows version and only 64 bits. And you need, for example, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>McSema and decompiling into LLVM source code: is it real?</h1><div class="post__text post__text-html js-mediator-article">  Imagine that there is some very useful program, but it, for example, exists only in the Windows version and only 64 bits.  And you need, for example, under ARM64 and under another OS, respectively.  And you do not have the source code, and it is impossible to get them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/ld/bm/ngldbmbqmbmqlz9w8wwrzhsb03e.jpeg" alt="image"></div><br>  What to do?  There is a project MCSema (a post on Habr√© about mcsema: <a href="https://habrahabr.ru/post/232871/">https://habrahabr.ru/post/232871/</a> ).  Its creators (and they are financed by DARPA, by the way) promise fabulous things: translation of binaries to LLVM IR, optimization, semantic code analysis, etc.  And of course, recompilation to any architectures that LLVM supports.  Open Source Project (link to github: <a href="https://github.com/trailofbits/mcsema">https://github.com/trailofbits/mcsema</a> ) <br><br>  And now let's see what really happens. <br><a name="habracut"></a><br>  First, you need to immediately clarify that MCSema does not know how to disassemble binaries by itself.  This requires IDA Pro, an expensive product in itself.  But this business is solved, in principle, you can replace IDA Pro with something else if you really want to. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But how does the magic of converting assembler to IR happen? <br><br>  (If someone does not know: IR is an intermediate language LLVM, a kind of generalized assembler, higher level than processor assemblers.) <br><br>  Very simple.  The entire set of x86-64 registers can be represented as a structure called SimulatedCPU, which, with some abbreviations, you can see here: <br><br><div class="spoiler">  <b class="spoiler_title">x86 registers</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimulatedCPU</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CPUFlags <span class="hljs-comment"><span class="hljs-comment">// See: https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture { CF = (1 &lt;&lt; 0), // 1 is 1 PF = (1 &lt;&lt; 2), // 3 is 0 AF = (1 &lt;&lt; 4), // 5 is 0 ZF = (1 &lt;&lt; 6), SF = (1 &lt;&lt; 7), TF = (1 &lt;&lt; 8), IF = (1 &lt;&lt; 9), DF = (1 &lt;&lt; 10), OF = (1 &lt;&lt; 11), // 12-13 is IOPL // 14 is NT // 15 is 0 // 16 is RF // 17 is VM // 18 is AC // 19 is VIF // 20 is VIP ID = (1 &lt;&lt; 11), // ID flag // rest is 0 }; enum FPUControl // See: http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/RealArithmetic.html { // Exception masks FPUC_InvalidOpMask = (1 &lt;&lt; 0), FPUC_DenormalMask = (1 &lt;&lt; 1), FPUC_ZeroDivideMask = (1 &lt;&lt; 2), FPUC_OverflowMask = (1 &lt;&lt; 3), FPUC_UnderflowMask = (1 &lt;&lt; 4), FPUC_PrecisionMask = (1 &lt;&lt; 5), // 6 is 1 (no idea why) // 7 is 0 FPUC_PrecisionControlMask = (3 &lt;&lt; 8), // 2 bits, 00 - 24 bits (float) , 01 - reserved, 10 - 53 bits (double), 11 - 64 bits (FP80), default 11 FPUC_RoundingMask = (3 &lt;&lt; 10), // 2 bits, 00 - to nearest or even, 01 - down, 10 - up, 11 - truncate, default 00 FPUC_Infinity = (1 &lt;&lt; 12), // rest is 0 }; enum FPUStatus // 16 bits { FPUS_InvalidOpFlag = (1 &lt;&lt; 0), FPUS_DenormalFlag = (1 &lt;&lt; 1), FPUS_ZeroDivideFlag = (1 &lt;&lt; 2), FPUS_OverflowFlag = (1 &lt;&lt; 3), FPUS_UnderflowFlag = (1 &lt;&lt; 4), FPUS_PrecisionFlag = (1 &lt;&lt; 5), FPUS_StackFaultFlag = (1 &lt;&lt; 6), // that's for FPU stack (8 regs) FPUS_ExceptionFlag = (1 &lt;&lt; 7), // set if any previous is set FPUS_C0 = (1 &lt;&lt; 8), // Condition bit 0 FPUS_C1 = (1 &lt;&lt; 9), // Condition bit 1 FPUS_C2 = (1 &lt;&lt; 10), // Condition bit 2 FPUS_TOP_Mask = (7 &lt;&lt; 11), // top-of-stack pointer (3 bits) FPUS_C3 = (1 &lt;&lt; 14), // Condition bit 3 FPUS_Busy = (1 &lt;&lt; 15), // 1 is FPU is busy. I don't expcet any code to ever use it. }; enum SSE_MXCSR { MXCSR_InvalidOp = (1 &lt;&lt; 0), MXCSR_Denormal = (1 &lt;&lt; 1), MXCSR_DivideByZero = (1 &lt;&lt; 2), MXCSR_Overflow = (1 &lt;&lt; 3), MXCSR_Underflow = (1 &lt;&lt; 4), MXCSR_Precision = (1 &lt;&lt; 5), MXCSR_DenormalsAreZero = (1 &lt;&lt; 6), MXCSR_InvalidOpExceptionMask = (1 &lt;&lt; 7), MXCSR_DenormalExceptionMask = (1 &lt;&lt; 8), MXCSR_DivideByZeroExceptionMask = (1 &lt;&lt; 9), MXCSR_OverflowExceptionMask = (1 &lt;&lt; 10), MXCSR_UnderflowExceptionMask = (1 &lt;&lt; 11), MXCSR_PrecisionExceptionMask = (1 &lt;&lt; 12), MXCSR_RoundingModeMask = (3 &lt;&lt; 13), // 2-bit, so it's a mask MXCSR_FlushToZero = (1 &lt;&lt; 15), }; // General Purpose Registers (32-bit in 32-bit mode, 64-bit in 64-bit mode) UINT_PTR RegAX; // 0x00 (0) UINT_PTR RegBX; // 0x04 (4) UINT_PTR RegCX; // 0x08 (8) UINT_PTR RegDX; // 0x0C (12) UINT_PTR RegSI; // 0x10 (16) UINT_PTR RegDI; // 0x14 (20) UINT_PTR RegSP; // 0x18 (24) UINT_PTR RegBP; // 0x1C (28) #ifdef EON_WIN64 UINT_PTR Reg08; UINT_PTR Reg09; UINT_PTR Reg10; UINT_PTR Reg11; UINT_PTR Reg12; UINT_PTR Reg13; UINT_PTR Reg14; UINT_PTR Reg15; UINT_PTR RegRIP; // possibly it won't be needed, if we fold all RIP-relative instructions on conversion. If you remove it, see about padding below. #endif // Various often used flags - close to other registers to improve caching if possible // EFLAGS (some) BYTE FlagCF; // 0x20 (32) BYTE FlagPF; // 0x21 (33) BYTE FlagAF; // 0x22 (34) BYTE FlagZF; // 0x23 (35) BYTE FlagSF; // 0x24 (36) BYTE FlagDF; // 0x25 (37) BYTE FlagOF; // 0x26 (38) // FPU Status Word (some) BYTE FlagFPU_C0; // 0x27 (39) BYTE FlagFPU_C1; // 0x28 (40) BYTE FlagFPU_C2; // 0x29 (41) BYTE FlagFPU_C3; // 0x2A (42) BYTE FlagFPU_TOP; // 0x2B (43) // FPU Control Word (some) BYTE FlagFPU_PC; // 0x2C (44) BYTE FlagFPU_RC; // 0x2D (45) // Rarely used flags, serving as paddding // FPU Control Word (some) BYTE FlagFPU_IM; // 0x2E (46) BYTE FlagFPU_DM; // 0x2F (47) BYTE FlagFPU_ZM; // 0x30 (48) BYTE FlagFPU_OM; // 0x31 (49) BYTE FlagFPU_UM; // 0x32 (50) BYTE FlagFPU_PM; // 0x33 (51) BYTE FlagFPU_X; // 0x34 (52) // FPU Status Word (some) BYTE FlagFPU_ES; // 0x35 (53) // Tag Word WORD FPUTagWord; // 0x36 (54) UINT_PTR ThreadEnvironmentBlock; // 0x38 (56) UINT_PTR ZeroRegister; // 0x3C (60) zero-filled dummy to give as CS,ES or SS register // XMM registers (aligned on 64-bit alignment) #ifdef EON_WIN64 BYTE XMMRegs[16*16]; // 16 128-bit (16-byte) registers #else BYTE XMMRegs[8*16]; // 0x40 (64) 8 128-bit (16-byte) registers #endif // x87 FPU registers (aligned on 64-bit alignment) DOUBLE FPURegs[8]; // 0xC0 (192) // Rarely used flags and other rarely used members // FPU Status Word (some) BYTE FlagFPU_IE; // 0x100 (256) BYTE FlagFPU_DE; // 0x101 (257) BYTE FlagFPU_ZE; // 0x102 (258) BYTE FlagFPU_OE; // 0x103 (259) BYTE FlagFPU_UE; // 0x104 (260) BYTE FlagFPU_PE; // 0x105 (261) BYTE FlagFPU_SF; // 0x106 (262) BYTE FlagFPU_B; // 0x107 (263) // MXCSR BYTE SSEFlag_InvalidOperation; // 0x108 (264) BYTE SSEFlag_Denormal; // 0x109 (265) BYTE SSEFlag_DivideByZero; // 0x10A (266) BYTE SSEFlag_Overflow; // 0x10B (267) BYTE SSEFlag_Underflow; // 0x10C (268) BYTE SSEFlag_Precision; // 0x10D (269) BYTE SSEFlag_DenormalsAreZero; // 0x10E (270) BYTE SSEFlag_InvalidOperationMask; // 0x10F (271) BYTE SSEFlag_DenormalMask; // 0x110 (272) BYTE SSEFlag_DivideByZeroMask; // 0x111 (273) BYTE SSEFlag_OverflowMask; // 0x112 (274) BYTE SSEFlag_UnderflowMask; // 0x113 (275) BYTE SSEFlag_PrecisionMask; // 0x114 (276) BYTE SSE_RoundingMode; // 0x115 (277) BYTE SSEFlag_FlushToZero; // 0x116 (278) BYTE FlagID; // 0x117 (279) - EFLAGS' ID flag // FPU debugging, currently unused but reserved UINT_PTR LastInstructionPtrOffset; // 0x118 (280) UINT_PTR LastDataPtrOffset; // 0x11A (281) WORD FPUFopcode; // 0x11E (282) WORD LastInstructionPtrSeg; // 0x120 (283) WORD LastDataPtrSeg; // 0x122 (284) #ifdef EON_WIN64 UINT_PTR StackValueAtLastNativeCodeEntry; // 0x124 (286), this is used to unwind simulated stack when part of it was used by native code #endif //... };</span></span></code> </pre> </div></div><br>  In the LLVM assembler, this structure is reflected very simply: <br><br><pre> <code class="cpp hljs">%SimulatedCPU = type &lt;{ i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i3, i2, i2, i1, i1, i1, i1, i1, i1, i1, i1, i16, i64, i64, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, [<span class="hljs-number"><span class="hljs-number">8</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>], i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i2, i1, i1, i64, i64, i16, i16, i16 }&gt;</code> </pre> <br>  (i64, i1, etc. are integer types in LLVM IR, having, respectively, 64 bits, 1 bits, etc.) That is, general-purpose registers are of type i64, flags are of type i1, followed by 128 -bit registers XMM, registers FPU (type double), flags FPU and various service registers. <br>  Suppose we have some function of the source program, which begins, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d40 mov rax, rsp <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d43 push rbp <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d44 push rbx <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d45 push rsi <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d46 push rdi <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d47 push r12 <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d49 push r13 <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d4b push r14 <span class="hljs-number"><span class="hljs-number">0000000140820</span></span>d4d push r15</code> </pre> <br>  Nothing unusual, in the function prologue, we copy the RSP value into RAX and save some registers onto the stack, according to the Calling Convention.  That is, it is not even the content part of the function itself, it is only part of the prologue. <br><br>  What makes this MCSema code (with abbreviations): <br><br><pre> <code class="cpp hljs">%<span class="hljs-number"><span class="hljs-number">0</span></span> = type opaque %SimulatedCPU = type &lt;{ i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i3, i2, i2, i1, i1, i1, i1, i1, i1, i1, i1, i16, i64, i64, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, [<span class="hljs-number"><span class="hljs-number">8</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>], i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i2, i1, i1, i64, i64, i16, i16, i16 }&gt; define hidden fastcc <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @Foo(%SimulatedCPU* noalias nocapture align <span class="hljs-number"><span class="hljs-number">16</span></span> dereferenceable(<span class="hljs-number"><span class="hljs-number">542</span></span>)) entry: %R15_val = alloca i64 %XMM9_val = alloca i128 %XMM8_val = alloca i128 ... %RSP_val = alloca i64 %RBP_val = alloca i64 ... %RAX_val = alloca i64 ... %<span class="hljs-number"><span class="hljs-number">1</span></span> = getelementptr inbounds %SimulatedCPU, %SimulatedCPU* %<span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">1</span></span> store i64 %<span class="hljs-number"><span class="hljs-number">2</span></span>, i64* %RAX_val ... %<span class="hljs-number"><span class="hljs-number">13</span></span> = getelementptr inbounds %SimulatedCPU, %SimulatedCPU* %<span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">6</span></span> %<span class="hljs-number"><span class="hljs-number">14</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">13</span></span> store i64 %<span class="hljs-number"><span class="hljs-number">14</span></span>, i64* %RSP_val %<span class="hljs-number"><span class="hljs-number">15</span></span> = getelementptr inbounds %SimulatedCPU, %SimulatedCPU* %<span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">7</span></span> %<span class="hljs-number"><span class="hljs-number">16</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">15</span></span> store i64 %<span class="hljs-number"><span class="hljs-number">16</span></span>, i64* %RBP_val ... block_0x10820d40: ; preds = %entry %<span class="hljs-number"><span class="hljs-number">165</span></span> = load i64, i64* %RSP_val store i64 %<span class="hljs-number"><span class="hljs-number">165</span></span>, i64* %RAX_val %<span class="hljs-number"><span class="hljs-number">166</span></span> = load i64, i64* %RBP_val %<span class="hljs-number"><span class="hljs-number">167</span></span> = load i64, i64* %RSP_val %<span class="hljs-number"><span class="hljs-number">168</span></span> = sub i64 %<span class="hljs-number"><span class="hljs-number">167</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">169</span></span> = inttoptr i64 %<span class="hljs-number"><span class="hljs-number">168</span></span> to i64* store <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> i64 %<span class="hljs-number"><span class="hljs-number">166</span></span>, i64* %<span class="hljs-number"><span class="hljs-number">169</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  For those who do not know LLVM IR, some explanations: <br><br>  1. A single argument is always passed to the function - a pointer to the global structure of SimulatedCPU.  The function always returns void. <br><br>  2. We allocate on a stack memory for a variable 64 bits: <br>  % RSP_val = alloca i64 <br><br>  3. Get the address of the 6th element in the SimulatedCPU structure (i.e. the RSP register) <br>  % 13 = getelementptr inbounds% SimulatedCPU,% SimulatedCPU *% 0, i64 0, i32 6 <br><br>  4. Get the RSP value: <br>  % 14 = load i64, i64 *% 13 <br><br>  5. Save it in a pre-allocated memory under the name RSP_val: <br>  store i64% 14, i64 *% RSP_val <br><br>  6. Load the RSP value into the variable again. <br>  % 165 = load i64, i64 *% RSP_val <br><br>  7. Copy to RAX (memory for RAX was allocated in the same way): <br>  store i64% 165, i64 *% RAX_val <br><br>  8. Get the RBP value: <br>  % 166 = load i64, i64 *% RBP_val <br><br>  9. Get RSP value <br>  % 167 = load i64, i64 *% RSP_val <br><br>  10. Subtract 8 from the RSP value (i.e., increment the stack by 8 bytes) <br>  % 168 = sub i64% 167, 8 <br><br>  11. Convert the resulting value into an index. <br>  % 169 = inttoptr i64% 168 to i64 * <br><br>  12. Save the RBP value to the received address. <br>  store volatile i64% 166, i64 *% 169, align 4 <br><br>  These are the commands into which MCSema has converted <i>one</i> command of the source program: push rbp. <br><br>  But this is a non-optimized code, maybe the opt optimizer will make it efficient? <br><br>  We'll see: <br><br><pre> <code class="cpp hljs">%<span class="hljs-number"><span class="hljs-number">0</span></span> = type opaque %SimulatedCPU = type &lt;{ i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i3, i2, i2, i1, i1, i1, i1, i1, i1, i1, i1, i16, i64, i64, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, i128, [<span class="hljs-number"><span class="hljs-number">8</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>], i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i2, i1, i1, i64, i64, i16, i16, i16 }&gt; define hidden fastcc <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @Foo(%SimulatedCPU* noalias nocapture align <span class="hljs-number"><span class="hljs-number">16</span></span> dereferenceable(<span class="hljs-number"><span class="hljs-number">542</span></span>)) { entry: ... %<span class="hljs-number"><span class="hljs-number">12</span></span> = getelementptr inbounds %SimulatedCPU, %SimulatedCPU* %<span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">6</span></span> %<span class="hljs-number"><span class="hljs-number">13</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">12</span></span>, align <span class="hljs-number"><span class="hljs-number">16</span></span> %<span class="hljs-number"><span class="hljs-number">14</span></span> = getelementptr inbounds %SimulatedCPU, %SimulatedCPU* %<span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">7</span></span> %<span class="hljs-number"><span class="hljs-number">15</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">14</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> ... %<span class="hljs-number"><span class="hljs-number">56</span></span> = add i64 %<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">-8</span></span> %<span class="hljs-number"><span class="hljs-number">57</span></span> = inttoptr i64 %<span class="hljs-number"><span class="hljs-number">56</span></span> to i64* store <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> i64 %<span class="hljs-number"><span class="hljs-number">15</span></span>, i64* %<span class="hljs-number"><span class="hljs-number">57</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  So, the optimizer has removed the placement on the stack of copies of the registers of the simulated processor, replacing them with direct read / write operations into the global structure of SimulatedCPU.  Has the program made it more effective?  Definitely not.  The optimizer cannot do anything else: the volatile qualifier is an insurmountable obstacle for it. <br><br>  If you compile the resulting code and run it on ARM64, it will be approximately two orders of magnitude slower than the source code on x86-64. <br><br>  MCSema does not see any variables on the function stack: it stupidly turns elementary operations with registers not even into operations with registers of the target processor (target), but into operations with the SimulatedCPU structure, which is located in memory (if the program is multi-threaded, then each thread has its own copy this structure). <br><br>  Conclusions that can be drawn from the above: it is too early to talk about transferring binary files from one architecture to another.  Instead of the promised semantic analysis, we simply have a very inefficient processor emulation.  Such an approach, in principle, does not allow achieving an effective program operation on a processor with a different architecture. <br><br>  Related Links: <br><br>  1. <a href="https://tilde.town/~awruef/binaries.pdf">Andrew Ruef.</a>  <a href="https://tilde.town/~awruef/binaries.pdf">There and back again.</a>  <a href="https://tilde.town/~awruef/binaries.pdf">Binary Analysis with mcsema.</a> <br>  2. <a href="https://sslab.gtisc.gatech.edu/2017/win-lift.html">Lifting Windows Driver Binaries into LLVM IR.</a> </div><p>Source: <a href="https://habr.com/ru/post/347000/">https://habr.com/ru/post/347000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346984/index.html">Java conference with English roots. Continuing mega review</a></li>
<li><a href="../346990/index.html">Disable DHT blocking in popular torrent clients</a></li>
<li><a href="../346992/index.html">Super-complete guide to publishing in Microsoft Store</a></li>
<li><a href="../346994/index.html">Conference C ++ Russia 2018</a></li>
<li><a href="../346998/index.html">Javascript and horror mutations</a></li>
<li><a href="../347002/index.html">Studying MBR and GPT structures</a></li>
<li><a href="../347004/index.html">Ukrainian startups are back from Las Vegas. And so</a></li>
<li><a href="../347008/index.html">Platforms for learning experiments with reinforcement and not only</a></li>
<li><a href="../347014/index.html">Learning to manage Kubernetes securely</a></li>
<li><a href="../347016/index.html">We increase our premium twice, or how to hack documents signed with a reinforced qualified signature</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>