<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Custom CSS Filters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Getting Started with Custom CSS Filters ( C ustom C ascading S tyle S heets F ilters) 

 Introduction 
 Custom CSS filters (hereinafter referred to as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Custom CSS Filters</h1><div class="post__text post__text-html js-mediator-article"><h4>  Getting Started with Custom CSS Filters ( <b>C</b> ustom <b>C</b> ascading <b>S</b> tyle <b>S</b> heets <b>F</b> ilters) </h4><br><br><h4>  Introduction </h4><br>  Custom CSS filters (hereinafter referred to as CCSSF) (formerly known as CSS shaders) is a new browser feature that superimposes visual effects created by hands on the elements of an HTML document. <br>  Custom filters are part of the <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">Filter Effects 1.0 specification</a> .  They complement another part of this specification, defining some common CSS filters already embedded in browsers (blur, sepia, contrast, grayscale). <br><a name="habracut"></a><br><h5>  Built-in CSS filters </h5><br>  Built-in CSS filters offer functionality that is similar to filters in image editors ‚Äî you have a set of pre-installed, commonly used effects in which you can only <a href="http://html5-demos.appspot.com/static/css/filters/index.html">control the parameters</a> . <br>  For example, this image was converted to grayscale and then blur was applied: <br><br> <a href="http://html5-demos.appspot.com/static/css/filters/index.html"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/361/a1b/6f3361a1b791b16214815093e8f6e915.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/e76/b37/348/e76b3734832b606282dfdb0e7a2f1832.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      (you can click on the pictures and <a href="http://html5-demos.appspot.com/static/css/filters/index.html">see for yourself</a> , the built-in CSS filters should work in a stable version of Chrome) <br><br><h5>  Custom CSS filters </h5><br>  Custom filters, on the other hand, allow you to create completely new types of effects, in which you can control not only the parameters of the effect itself, but also determine the essence of the applied effect using <a href="https://habr.com/ru/post/155447/">shaders</a> . <br>  For example, this map embedded in the document has been transformed into a real textured sphere: <br><br> <a href="http://alteredqualia.com/css-shaders/sphere2.html"><img src="https://habrastorage.org/getpro/habr/post_images/f4e/aad/195/f4eaad19570db7a97f6b422fb15d232d.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/763/3e8/70f/7633e870fbdb43a68c7d17b94e88210c.jpg" alt="image"></a> <br><br>  (you can click on the pictures and <a href="http://alteredqualia.com/css-shaders/sphere2.html">see for yourself</a> , see the section <a href="https://habr.com/ru/post/155447/">How to make CSS filters work</a> ) <br><br>  Built-in filters have access to functionality not available for custom ones.  They can achieve more than what was originally intended by the creators of browsers. <br>  The most noticeable built-in filters can read pixels from the specified DOM content, which means that they can do, for example, blur (See in the <a href="https://habr.com/ru/post/155447/">Restrictions section for custom filters</a> ). <br><br><a name="shaders"></a><h4>  What are shaders? </h4><br>  The effects of custom filters are set by small programs called shaders. <br>  Shaders define the 3D form and type of graphic elements (shaders operate with <a href="http://en.wikipedia.org/wiki/Polygon_mesh">polygonal grids</a> ). <br>  Shaders work directly on the video card hardware.  They can process large amounts of data in parallel, which means that they can be very fast, but often unnecessary compared to the typical cycle of programs running on a CPU. <br>  CCSSF uses <a href="http://en.wikipedia.org/wiki/GLSL">GLSL</a> as a <a href="http://en.wikipedia.org/wiki/GLSL">shader</a> language. <br>  If you are familiar with graphics programming <a href="http://en.wikipedia.org/wiki/Shader">shaders</a> that use shader languages ‚Äã‚Äã( <a href="http://en.wikipedia.org/wiki/OpenGL">OpenGL</a> , <a href="http://en.wikipedia.org/wiki/Opengl_es">OpenGL ES</a> , <a href="http://www.khronos.org/webgl/wiki/Main_Page">WebGL</a> , <a href="http://en.wikipedia.org/wiki/Directx">DirectX</a> ), then everything seems to be the same - the shaders used in custom CSS filters work the same way. <br><br><h5>  Shader Types </h5><br>  The shaders used in the CCSSF are of two types: vertex shaders (Vertex Shader) and fragmentary shaders (Fragment Shader) (they are also called pixel shaders). <br>  Vertex shaders say where things are.  They allow you to move the vertices of the grid in 3D space, deforming and rearranging objects. <br>  Fragment shaders say what the surfaces of objects look like.  They allow you to draw on objects or change the belonging of existing pixels to the exterior of objects. <br>  In general, to be able to create a valid GPU program, you need those and other shaders.  However, for custom CSS filters, only one of these types is needed, and for the missing one, the browser uses the <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">default pass-through shader</a> . <br><br><h4>  How do custom CSS filters work? </h4><br>  Modern browsers now themselves implement the use of graphic acceleration. <br>  HTML pages are rendered by browsers as collections of textured rectangles corresponding to <a href="http://en.wikipedia.org/wiki/Document_Object_Model">DOM elements</a> . <br>  With custom CSS filters, you cling to the browser render information stream, getting the opportunity to change the shape and appearance of these rectangles before they are drawn on the screen. <br>  This is similar to how <a href="http://www.w3.org/TR/2012/WD-css3-transforms-20120911/">CSS 3D transforms work</a> , only instead of being able to play with parameters with already defined functionality, you can run your own code for processing DOM content. <br><br><h5>  Content grid </h5><br>  Each DOM element with CCSSF will be transformed into a <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">triangular grid with a mosaic defined by the user</a> : <br>  &lt;img src = " <a href="">cs317217.userapi.com/v317217705/37a5/ghtCCVl9SeM.jpg</a> " alt = "image" /&gt; <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  Note  translator - I didn‚Äôt find a way to insert an svg object, so I took a screenshot </div></div><br>  By default, the grid contains only two triangles (the minimum necessary to create a rectangle). <br>  This grid will receive the texture created for the content of the DOM element (which is usually drawn on the screen), and then your custom shaders will be applied to it. <br><br><h5>  Mesh connectivity </h5><br>  A grid of triangles can be created in two ways (controlled by CSS): <br><ol><li>  attached triangles </li><li>  loose triangles </li></ol><br><br>  A grid with <b>attached triangles</b> is one unified object where adjacent triangles have common vertices.  If you move a vertex, all the triangles associated with it will deform (like a sheet of cloth).  This option is used by default. <br>  A grid with <b>detached triangles is</b> made up of many individual triangles.  Each vertex belongs to only one triangle.  You can divide the grid into separate components.  The mesh can contain holes, or even be completely re-modeled in the vertex shader. <br>  The grid mosaic and connectivity must remain the same in all CSS transitions. <br><br><h5>  Shader Input Parameters </h5><br>  Vertex and fragment shaders can accept three types of parameters as input: <br><ol><li>  <i>forms</i> (uniforms) </li><li>  <i>attributes</i> </li><li>  <i>differences</i> </li></ol><br><br>  <b><i>Forms</i></b> are parameters with a single value for all vertices and pixels of the grid (for example, the color of an object). <br>  <b><i>Attributes</i></b> are individual parameters of the vertices, each vertex of the grid gets its value for each <i>attribute</i> (for example, the position of the vertex). <br>  <b><i>Differences</i></b> are the parameters passed to the vertices of the fragments.  They are specified for each vertex of the triangle and their values ‚Äã‚Äãfor points inside the triangle interpolate the GPU (for example, lighting). <br><br>  Filter Effects specification also allows for a different type of input: <b>textures</b> .  However, they are not yet implemented (and attempts to use them will silently break the shaders). <br>  Browsers provide some default <b>built-in parameters</b> created and initialized for all elements to which custom CSS filters are applied. <br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_position</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_texCoord</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_meshCoord</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_triangleCoord</span></span>;</code> </pre> <br>  Built-in <i>attributes</i> allow you to identify and find individual vertices and triangles in the grid. <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mat4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_projectionMatrix</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_textureSize</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_meshBox</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_tileSize</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_meshSize</span></span>;</code> </pre> <br>  Embedded <i>forms</i> provide information about DOM element data that is common to the entire grid. <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">varying</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">v_texCoord</span></span>;</code> </pre> <br>  Built-in <i>differences</i> provide texture coordinates in case the effect uses default shaders. <br>  Exact definitions of these parameters can be found in the Filter Effects specialization ( <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">attributes</a> , <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">forms</a> , <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">differences</a> ). <br><br>  <b>Caution</b> : at the moment, not all built-in parameters from this specialization are implemented. <br><br>  For example, there are no <b>u_textureSize</b> and <b>u_meshSize forms</b> .  You can solve this problem by personally identifying them in CSS. <br>  Also, the <i>difference</i> <b>v_texCoord</b> does not work yet, so you will need to create your <b>own</b> <i>difference</i> to transfer the texture coordinates from <i>the</i> <b>a_texCoord</b> <i>attribute</i> to the vertex shader. <br>  You can follow the progress of implementation of custom CSS filters in this edition of the <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D71392">WebKit ‚Äúmaster‚Äù issue</a> . <br>  In addition to the built-in parameters, you can also describe your <i>forms</i> for effect through <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">CSS styles</a> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.shaded</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-webkit-filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">custom</span></span>(url(distort.vs) <span class="hljs-built_in"><span class="hljs-built_in">mix</span></span>(url(tint.fs) normal source-atop), distortAmount <span class="hljs-number"><span class="hljs-number">0.5</span></span>, lightVector <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br><br><pre> <code class="css hljs">//  (  ) ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">distortAmount</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightVector</span></span>; ...</code> </pre> <br><br>  All this allows you to control the effects from the outside.  In particular, the values ‚Äã‚Äãfor the <i>forms</i> described in CSS will be interpolated when using <a href="http://www.w3.org/TR/css3-transitions/">CSS transitions</a> . <br>  <b>Caution</b> : the number of available slots for <i>forms</i> and <i>differences is limited and depends on the specific GPUs (the same applies to <i>attributes</i> , but for CSS filters they cannot be used).</i> <i><br><br></i>  <i><a href="http://alteredqualia.com/tmp/webgl-maxparams-test/">Here</a> you can see how many shader parameters are available on your system for WebGL (these numbers should be the same for CCSSF; some slots are assigned to the built-in parameters).</i> <i><br><br></i> <h4>  <i>How to use custom CSS filters on my site?</i> </h4> <i><br></i>  <i>CCSSF is applied in the same way as other CSS styles using <b>style</b> .</i>  <i>It looks like this:</i> <i><br></i> <pre> <i><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-class"><span class="css"><span class="hljs-selector-class">.shader</span></span></span><span class="css"> { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">-webkit-filter</span></span></span><span class="css">: </span><span class="hljs-built_in"><span class="css"><span class="hljs-built_in">custom</span></span></span><span class="css">(url(shaders/crumple.vs) </span><span class="hljs-built_in"><span class="css"><span class="hljs-built_in">mix</span></span></span><span class="css">(url(shaders/crumple.fs) normal source-atop), </span><span class="hljs-number"><span class="css"><span class="hljs-number">50</span></span></span><span class="css"> </span><span class="hljs-number"><span class="css"><span class="hljs-number">50</span></span></span><span class="css">, amount </span><span class="hljs-number"><span class="css"><span class="hljs-number">0</span></span></span><span class="css">, strength </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.2</span></span></span><span class="css">, lightIntensity </span><span class="hljs-number"><span class="css"><span class="hljs-number">1.05</span></span></span><span class="css">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code></i> </pre> <i><br></i>  <i>Or so, if you use only the fragment shader:</i> <i><br></i> <pre> <i><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-class"><span class="css"><span class="hljs-selector-class">.shader</span></span></span><span class="css"> { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">-webkit-filter</span></span></span><span class="css">: </span><span class="hljs-built_in"><span class="css"><span class="hljs-built_in">custom</span></span></span><span class="css">(none mix(url(shaders/tint.fs) normal source-atop), amount </span><span class="hljs-number"><span class="css"><span class="hljs-number">0</span></span></span><span class="css">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code></i> </pre> <i><br></i>  <i>Similarly, using <b>none</b> instead of a fragment shader will not work (for now).</i>  <i>In this situation, the solution is to substitute an empty fragment shader.</i> <i><br></i>  <i>You give the browser a link to the GLSL shaders source code and specify their parameters via CSS styles.</i>  <i>The browser will take care to compile the shaders into binaries and apply them to the HTML content.</i> <i><br><br></i>  <i>When you already have shaders, applying them to HTML is easy - you just work with them as you would with regular CSS styles.</i> <i><br></i> <pre> <i><code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>"&gt;</code></i> </pre> <i><br></i>  <i>You can use <a href="http://www.w3.org/TR/css3-transitions/">CSS transitions</a> with custom CSS filters, for example, to dynamically change the effect when you hover over an element of the page.</i> <i><br></i> <pre> <i><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-webkit-transition</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-webkit-filter</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ease-in-out</span></span> 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>;</code></i> </pre> <i><br></i>  <i>CCSSF parameters will be interpolated the same way as inline CSS properties.</i> <i><br><br><a name="compatibility"></a></i> <h4>  <i>How to get working CCSSF?</i> </h4> <i><br></i>  <i><b>Caution</b> : this technology is very new and can be roughly implemented.</i>  <i>Details may change, some features may not work, and there may be bugs in the implementation.</i> <i><br><br></i>  <i>This post reflects the state of affairs in September 2012.</i>  <i>If since then something is not working as described, it will be useful to google to be aware of the exact syntax and behavior.</i> <i><br></i>  <i>At the moment, custom CSS filters are working in the current Chrome Canary build (the exact version at the time of creating the record is 24.0.1278.0).</i> <i><br></i>  <i>Download Chrome Canary here:</i> <i><br> <a href="https://tools.google.com/dlpage/chromesxs"><img src="http://alteredqualia.com/css-shaders/article/img/chrome-canary.png" alt="image"></a> <br></i>  <i><a href="https://tools.google.com/dlpage/chromesxs">tools.google.com/dlpage/chromesxs</a></i> <i><br><br></i>  <i>CCSSF should work in Windows and OSX (I use Windows 7).</i> <i><br><br></i>  <i>Even if your OS and browser support them, everything can rest against an old or weak GPU or into improper drivers (System requirements are roughly the same as specified here - <a href="http://get.webgl.org/">WebGL compatibility check</a> )</i> <i><br></i>  <i>Custom CSS filters are not enabled by default, so Chrome must be run from the console with the following key:</i> <i><br></i> <pre> <i><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">chrome</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--enable-css-shaders</span></span></code></i> </pre> <i><br></i>  <i>An easy way to get the included CSS shaders in Chrome on Windows is to create a shortcut on Chrome Canary and add the <b>--enable-css-shaders</b> parameter to the "target" field.</i> <i><br></i>  <i>The alternative is to make a batch file with the command specified above.</i> <i><br><br></i>  <i>In the new versions of Chrome Canary there is a special flag in the interface, in the special tab ‚ÄúFlags‚Äù (Search ‚ÄúEnable CSS Shaders‚Äù):</i> <i><br></i> <pre> <i><code class="bash hljs">chrome://flags/</code></i> </pre> <i><br><br></i> <h4>  <i>How to make sure CCSSF work?</i> </h4> <i><br></i>  <i>See <a href="http://alteredqualia.com/css-shaders/sphere.html">this example</a> .</i> <i><br><br></i>  <i>If you see spherical planets, congratulations, they work;).</i> <i><br><br> <a href="http://alteredqualia.com/css-shaders/sphere.html"><img src="http://alteredqualia.com/css-shaders/article/img/img_sphere_ok.jpg" alt="image"></a> <br><br></i>  <i>If you see only rectangular pictures, then something went wrong; S.</i> <i><br> <a href="http://alteredqualia.com/css-shaders/sphere.html"><img src="http://alteredqualia.com/css-shaders/article/img/img_sphere_fail.jpg" alt="image"></a> <br><br></i>  <i>Please note that some of the examples are randomly found on the Internet and may break over time.</i>  <i>For example, effects that work in <a href="https://github.com/adobe/webkit/downloads">Chromium‚Äôs</a> early <a href="https://github.com/adobe/webkit/downloads">custom builds of May 2012</a> do not work in the latest Chrome Canary.</i> <i><br></i>  <i><b>Caution</b> : for some reason, the implementation is not stable now.</i>  <i>It may happen that at one moment CCSSF is working, and at another - it is already broken, even during page reload or cyclic transitions on the same page.</i> <i><br><br></i>  <i>In such cases:</i> <i><br></i> <ol><li>  <i>reload page</i> </li><li>  <i>close tab and open page in new tab</i> </li><li>  <i>restart browser</i> </li></ol> <i><br></i>  <i>Shaders broken in one tab can kill shaders in all other tabs (and shaders will remain broken even if the pages are reloaded).</i> <i><br><br></i>  <i>During the first page load, shaders may also work on partially rendered DOM elements.</i>  <i>In this case, close the tab and open the page again, reload does not help.</i> <i><br><br><a name="limitations"></a><br></i> <h4>  <i>Limitations of custom filters</i> </h4> <i><br></i> <h5>  <i>Access to content</i> </h5> <i><br></i>  <i>The shaders used in CCSSF <b>cannot read the pixels of the textures of the DOM content</b> in any <b>way,</b> and yet they <b>cannot directly draw pixels on the screen</b> .</i> <i><br></i>  <i>These restrictions appeared as a reaction to <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a> , when the robber 3rd party shader, built into the site, could be used to read the site content (depending on the source of the pixel color, different shader code was used).</i> <i><br></i>  <i>The only way you can interact with the pixels of a DOM element is to switch to your calculated colors from the original ones using the following parameters built-in fragment shaders <a href="https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">css_ColorMatrix</a> , <a href="https://dvcs.w3.org/hg/FXTF/rawfile/tip/compositing/index.html">css_MixColor</a></i> <i><br><img src="http://alteredqualia.com/css-shaders/article/img/mix-fragment-shader.png" alt="image"><br><br></i>  <i><b>Caution</b> : the spec says that you can also use <b>gl_FragColor</b> to create solid color values.</i> <i><br></i>  <i>This is not working yet.</i> <i><br></i>  <i>WebGL solves this problem in a different way, by <a href="http://www.khronos.org/registry/webgl/specs/latest/">providing access only to ‚Äúclean‚Äù content</a> (created on the same server or directly allowed by <a href="http://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">cross-domain access</a> for 3rd party servers).</i> <i><br><br></i>  <i>The negative side of the shader approach is that it is not compatible with many interesting types of applications, and the positive one is that CSS shaders can be applied to any content.</i> <i><br><br></i> <h5>  <i>Mesh size</i> </h5> <i><br></i>  <i>Another limitation, at least in the current implementation, is a fixed number of triangles per mosaic grid.</i> <i><br></i>  <i>You cannot have a grid of more than 20,000 odd triangles.</i>  <i>Therefore, it is recommended to render using indexed triangles with 16-bit numbers, limiting the number of vertices to 65.536.</i> <i><br><br></i> <h4>  <i>How to create your own CSS effects?</i> </h4> <i><br></i>  <i>All you need is a browser and a text editor.</i>  <i>The shaders used in the CCSSF are plain text files.</i> <i><br><br></i>  <i>Workflow is the same as with HTML + CSS layout: you make changes, refresh the page in the browser and see if it worked out or not.</i> <i><br></i>  <i>There is a tool from Adobe called <a href="http://html.adobe.com/webstandards/csscustomfilters/cssfilterlab/">CSS FilterLab</a> , which makes it easier to edit the effect parameters.</i> <i><br><br></i>  <i><b>Caution</b> : compiling a shader into a binary is a relatively slow operation.</i>  <i>If you have a lot of shaders, they can significantly slow down the loading of the page.</i> <i><br><br></i>  <i>For WebGL, Chrome has implemented <a href="http://code.google.com/p/chromium/issues/detail%3Fid%3D88572">caching of already used shader binaries</a> , this can help.</i> <i><br><br></i> <h4>  <i>What are the shaders used in custom CSS filters?</i> </h4> <i><br></i>  <i>A simple <b>vertex shader</b> looks like this:</i> <i><br></i> <pre> <i><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">precision</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mediump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_position</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mat4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_projectionMatrix</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>() { gl_Position = u_projectionMatrix * a_position; }</code></i> </pre> <i><br></i>  <i>A simple fragment shader looks like this:</i> <i><br></i> <pre> <i><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">precision</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mediump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>() { float r = 1.0; float g = 1.0; float b = 1.0; float a = 1.0; css_ColorMatrix = mat4( r, 0.0, 0.0, 0.0, 0.0, g, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, a ); }</code></i> </pre> <i><br></i>  <i>Writing precision <a href="http://www.opengl.org/wiki/GLSL_Type_Qualifiers">has no effect on desktop OpenGL</a> , but works on mobile devices using OpenGL ES.</i>  <i>However, they must be specified in order for the current implementation to work.</i> <i><br></i>  <i>For HTML content, shaders are applied as follows:</i> <i><br></i> <pre> <i><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-class"><span class="css"><span class="hljs-selector-class">.shader</span></span></span><span class="css"> { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">-webkit-filter</span></span></span><span class="css">: </span><span class="hljs-built_in"><span class="css"><span class="hljs-built_in">custom</span></span></span><span class="css">(url(simple.vs) </span><span class="hljs-built_in"><span class="css"><span class="hljs-built_in">mix</span></span></span><span class="css">(url(simple.fs) normal source-atop), </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css"> </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css">) } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"shader"</span></span></span><span class="hljs-tag">&gt;</span></span> Hello world! <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span></code></i> </pre> <i><br></i>  <i>This is a minimal CSS style using both fragmentary and vertex shaders applied on a simple mosaic grid with two attached triangles (1 column x 1 row).</i> <i><br><br></i> <h4>  <i>How to create a custom effect?</i> </h4> <i><br></i>  <i>Now let's see how to create a slightly simplified version of the spherical effect, similar to the one <a href="http://alteredqualia.com/css-shaders/sphere.html">used here</a> .</i> <i><br></i>  <i>We'll start with a flat texture with DOM content (first image).</i>  <i>We want to wrap it in a sphere and attach shadows, as if it were a 3D object lit with direct light (second picture).</i> <i><br> <a href="http://alteredqualia.com/css-shaders/sphere_simple.html"><img src="http://alteredqualia.com/css-shaders/article/img/grid.png" alt="image"><br><img src="http://alteredqualia.com/css-shaders/article/img/example_sphere.jpg" alt="image"><br></a> <br></i>  <i>See <a href="http://alteredqualia.com/css-shaders/sphere_simple.html">here for a working example</a> .</i> <i><br><br></i> <h5>  <i>Mesh deformation</i> </h5> <i><br></i>  <i>All mesh deformations occur in the vertex shaders.</i> <i><br></i>  <i>First, we need to find a way to wrap a rectangular plane in the shape of a sphere, and then apply a shadow later.</i> <i><br></i>  <i>We will start with a simple rectangular grid lying in 2D space with uniformly distributed vertex positions.</i>  <i>We need to pick up some kind of mapping of these 2D positions in the 3D sphere.</i> <i><br></i>  <i>We can get the coordinates of the vertices of the original plane through the built-in <i>attribute</i> <b>a_position</b> provided by the browser.</i>  <i>We need to declare a variable before we can use it:</i> <i><br></i> <pre> <i><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_position</span></span>;</code></i> </pre> <i><br></i>  <i>We will remember this <i>attribute</i> in a local variable, which we will later modify (because the <i>attributes</i> are read-only):</i> <i><br></i> <pre> <i><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">position</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_position</span></span>;</code></i> </pre> <i><br></i>  <i>A common operation in computer graphics is texturing with a href = " <a href="http://en.wikipedia.org/wiki/UV_mapping">en.wikipedia.org/wiki/UV_mapping</a> "&gt; UV mapping</i> , when a rectangular pattern is wrapped around a grid using 2D texture coordinates.  It sounds very similar to what we need. <br><br>  One of the built-in grid <i>attributes</i> provided by the browser is a two-component vector <b>a_texCoord</b> with vertex texture coordinates. <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">attribute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_texCoord</span></span>;</code> </pre> <br>  The texture coordinates are called U and V, they are in the interval <b>0 ... 1</b> for each axis and they draw the grid vertices along the length and height of the picture. <br><br>  To obtain the coordinates X, Y, Z corresponding to our U and V coordinates, we will use the transformation between the <a href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">spherical coordinate system</a> (it is also called polar) and the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">rectangular coordinate system</a> : <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">sin</span></span>( Œ∏ ) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">cos</span></span>( œÜ ) <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">sin</span></span>( Œ∏ ) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">sin</span></span>( œÜ ) <span class="hljs-selector-tag"><span class="hljs-selector-tag">z</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">cos</span></span>( Œ∏ )</code> </pre> <br>  The spherical coordinate system uses the following coordinates: <br><ul><li>  radius <b>r</b> </li><li>  zenith (inclination) <b>Œ∏</b> (span [0 ... œÄ]) </li><li>  azimuth (azimuth) <b>œÜ</b> (span [0 ... 2œÄ]) </li></ul><br><br>  Let the user determine the radius via the CSS <i>form</i> : <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sphereRadius</span></span>;</code> </pre> <br>  And we will map the U and V coordinates to the azimuth and zenith: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">computeSpherePosition</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uv</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> ) { vec3 p; float fi = uv.x * PI * 2.0; float th = uv.y * PI; px = r * sin( th ) * cos( fi ); py = r * sin( th ) * sin( fi ); pz = r * cos( th ); }</code> </pre> <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sphere</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">computeSpherePosition</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">a_texCoord</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">sphereRadius</span></span> );</code> </pre> <br>  Now we can move between the original flat position and the new spherical position, which we have just calculated using the built-in GLSL function (linear interpolation between two values). <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">amount</span></span>;</code> </pre> <br>  We will use the user-provided <i>form</i> parameters to control the transition (the <i>form</i> parameter from CSS can be interpolated by the browser using CSS transitions). <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">position</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">position</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">sphere</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">amount</span></span> );</code> </pre> <br>  Finally, we can replace the vertices of the grid by writing to the built-in GLSL variable that transforms our calculated position according to the <a href="">gl_Position</a> matrix provided by the browser: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">gl_Position</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">u_projectionMatrix</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">position</span></span>;</code> </pre> <br><br><h5>  Surface shading </h5><br>  Shading is calculated by combining vertex and fragment shaders. <br><br><h6>  Shading: Vertex Shaders </h6><br>  In the vertex shader, we will calculate the lighting for each vertex and pass it as a <i>difference</i> to the fragment shader, where we will use it to change the color of the DOM texture. <br><br>  For shading, we will use a simple <a href="http://en.wikipedia.org/wiki/Lambertian_reflectance">Lambert scatter model</a> . <br>  Reflection light is considered as the scalar product of the normal vector of the surface and the normalized vector of the direction of light. <br>  We need the position of the light and the <a href="http://en.wikipedia.org/wiki/Surface_normal">surface normal</a> for each vertex. <br>  We will allow the user to define the position of the light source as a three-component <b>lightPosition</b> vector <i>form</i> , passed through CSS: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">uniform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightPosition</span></span>;</code> </pre> <br>  We will normalize using the normalize function built into GLSL: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightPositionNormalized</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">normalize</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightPosition</span></span> );</code> </pre> <br>  Next, we need to calculate the normal for a flat and spherical surface. <br>  The surface normal is usually considered on the CPU side, since you need to work with a connected mesh and have access to all the triangle vertices at the same time (the shader sees only one vertex at a time). <br>  However, here we are dealing with simple geometric shapes, so we can calculate normals analytically. <br>  For the normal plane, we cheat a little bit: the correct normal plane must be directed from the monitor, perpendicular to the XY plane. <br>  But such a normal will give us an unmodified DOM element, in some places a little shaded, and this will be unnatural compared to the rest of the page elements that do not have shaders superimposed. <br>  Therefore, we use a vector directed to the light source as the normal to the surface. <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">planeNormal</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightPositionNormalized</span></span>;</code> </pre> <br>  This will allow the undeformed element to always be fully lit. <br><br>  For the sphere normal, we will use a simple analytic formula.  The normal of a sphere on a surface is the normalized vectors from the center of the sphere to its surface: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sphereNormal</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">normalize</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">position</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span> );</code> </pre> <br>  To obtain an adequate normal for our transition state, we will simply go from the normal to the sphere normal and normalize this transition vector: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vec3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">normal</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">normalize</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">planeNormal</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">sphereNormal</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">amount</span></span> ) );</code> </pre> <br>  Finally, we can calculate the illumination according to the Lambert formula using the <a href="">dot</a> function built into GLSL and fix the negative values ‚Äã‚Äãwith the <a href="">max</a> formula: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">max</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">dot</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">normal</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightPositionNormalized</span></span> ), 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> );</code> </pre> <br>  With the last action of the vector shader, we will transmit the light intensity to the fragment shader through the <i>difference</i> : <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">varying</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">v_light</span></span>;</code> </pre> <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">v_light</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>;</code> </pre> <br><br><h6>  Shading: Fragment Shader </h6><br>  The fragment shader will be very simple, everything heavy was mastered in the vertex shader. <br>  Take the light intensity from the <i>difference</i> : <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">varying</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">v_light</span></span>;</code> </pre> <br><br>  And use it to modulate color coefficients (we will not change transparency): <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">v_light</span></span>;</code> </pre> <br>  And we use them to get the <a href="https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">css_ColorMatrix</a> transition <a href="https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">matrix</a> : <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">css_ColorMatrix</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">mat4</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> );</code> </pre><br>  In our case, we get a color equivalent to this: <br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">gl_FragColor</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">vec4</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> ) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">sourceColor</span></span>;</code> </pre> <br><br><h6>  Final Vertex Shader </h6><br>  <a href="">Download</a> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  precision mediump float; <br><br>  // Inline Attributes <br><br>  attribute vec4 a_position; <br>  attribute vec2 a_texCoord; <br><br>  // Embedded Forms <br><br>  uniform mat4 u_projectionMatrix; <br><br>  // Forms submitted via CSS <br><br>  uniform float amount; <br>  uniform float sphereRadius; <br>  uniform vec3 lightPosition; <br><br>  // Differences <br><br>  varying float v_light; <br><br>  // Constants <br><br>  const float PI = 3.1415; <br><br>  // Create the perspective matrix <br><br>  vec3 computeSpherePosition (vec2 uv, float r) { <br><br>  vec3 p; <br><br>  float fi = uv.x * PI * 2.0; <br>  float th = uv.y * PI; <br><br>  px = r * sin (th) * cos (fi); <br>  py = r * sin (th) * sin (fi); <br>  pz = r * cos (th); <br><br>  return p; <br><br>  } <br><br>  // Main <br><br>  void main () { <br><br>  vec4 position = a_position; <br><br>  // Mapim Plane To Sphere Using UV Coordinates <br><br>  vec3 sphere = computeSpherePosition (a_texCoord, sphereRadius); <br><br>  // Transition from plane to sphere <br><br>  position.xyz = mix (position.xyz, sphere, amount); <br><br>  // Set the position of the vertex <br><br>  gl_Position = u_projectionMatrix * position; <br><br>  // Calculate the light <br><br>  vec3 lightPositionNormalized = normalize (lightPosition); <br><br>  vec3 planeNormal = lightPositionNormalized; <br>  vec3 sphereNormal = normalize (position.xyz); <br><br>  vec3 normal = normalize (mix (planeNormal, sphereNormal, amount)); <br><br>  float light = max (dot (normal, lightPositionNormalized), 0.0); <br><br>  // Pass in the difference <br><br>  v_light = light; <br><br>  } </div></div><br><br><h6>  Final Fragment Shader </h6><br>  <a href="">Download</a> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  precision mediump float; <br><br>  varying float v_light; <br><br>  void main () { <br><br>  float r, g, b; <br>  r = g = b = v_light; <br><br>  css_ColorMatrix = mat4 (r, 0.0, 0.0, 0.0, <br>  0.0, g, 0.0, 0.0, <br>  0.0, 0.0, b, 0.0, <br>  0.0, 0.0, 0.0, 1.0); <br><br>  } </div></div><br><br><h6>  CSS style </h6><br>  <a href="http://alteredqualia.com/css-shaders/sphere_simple.html">Download</a> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  .shader { <br>  -webkit-filter: custom (url (sphere.vs) mix (url (sphere.fs) normal source-atop), <br>  16 32, amount 1, sphereRadius 0.35, lightPosition 0.0 0.0 1.0); <br>  -webkit-transition: -webkit-filter ease-in-out 1s; <br>  } <br><br>  .shader: hover { <br>  -webkit-filter: custom (url (sphere.vs) mix (url (sphere.fs) normal source-atop), <br>  16 32, amount 0, sphereRadius 0.35, lightPosition 0.0 0.0 1.0); <br>  } </div></div><br><br><h5>  Some more examples of custom effects. </h5><br><ul><li>  <a href="http://alteredqualia.com/css-shaders/burn.html">Burn shader</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/dissolve.html">Dissolve shader</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/crumple.html">Crumple shader</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/dots.html">Dots shader</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/flip.html">Flip shader (variant 1)</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/flip2.html">Flip shader (variant 2)</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/sphere.html">Sphere shader (planets)</a> </li><li>  <a href="http://alteredqualia.com/css-shaders/sphere2.html">Sphere shader (map)</a> </li></ul><br><h5>  Shader Debugging </h5><br>  Debugging shaders used in CCSSF is a tricky business.  At least, now there is no error log in the Chrome console (as opposed to WebGL, where you can get the results of the shader compilation and, possibly, find an error or typo). <br><br>  On a Mac, you can get the <a href="http://blattchat.com/2012/06/19/a-little-help-debugging-css-shaders/">error output</a> displayed in the console window from which you started Chrome, but this is not written to Windows in the console. <br><br>  A possible solution is to use the <a href="https://github.com/WebGLTools/GL-Shader-Validator">GL shader validation plugin</a> for the <a href="http://www.sublimetext.com/">Sublime text editor</a> recently created by the guys <a href="http://twitter.com/aerotwist">@aerotwist</a> and <a href="http://twitter.com/brendankenny">@brendankenny</a> . <br><h5>  Shader Profiling </h5><br>  Unfortunately, just like in WebGL, there is no way to see what happens on the GPU side: S. <br>  Nevertheless, there are a couple of tricks that can be used to get some inside information about the work of shaders. <br>  For example, if you want to find out if the effect of your effect is tied to a fragment shader, try resizing the DOM element to see if it works better on smaller elements. <br>  Try to avoid the effects applied to full-screen items.  This will be unproductive and may be a bottleneck when building a page. <br>  If you want to see if the effect of your effect is tied to vertex shaders, try it on a grid with a different mosaic. <br><br>  Remember that if you apply the effect to many elements with large mosaics on the same page, you can very quickly increase the total counter of triangles. <br><br><h4>  useful links </h4><br><ul><li>  <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">Filter Effects specification</a> </li><li>  <a href="http://www.khronos.org/files/opengles_shading_language.pdf">GLSL specification</a> </li><li>  <a href="https://dvcs.w3.org/hg/FXTF/rawfile/tip/compositing/index.html">Compositing and Blending specification</a> </li><li>  <a href="http://www.w3.org/TR/css3-transitions/">CSS transitions specification</a> </li><li>  <a href="http://www.w3.org/TR/2012/WD-css3-transforms-20120911/">CSS transforms specification</a> </li><li>  <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D71392">Umbrella WebKit issue tracking CSS Shaders implementation progress</a> </li><li>  <a href="http://adobe.github.com/web-platform/samples/css-customfilters/">Adobe custom CSS filter effects examples</a> </li><li>  <a href="http://www.adobe.com/devnet/html5/articles/css-shaders.html">Introducing CSS shaders: Cinematic effects for the web</a> </li><li>  <a href="http://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf">WebGL quick reference card</a> (includes useful GLSL reference) </li><li>  <a href="http://glsl.heroku.com/">GLSL Sandbox</a> </li><li>  <a href="http://experiments.hertzen.com/css-shaders/">CSS Shaders implemented with WebGL</a> </li></ul><br><h5>  Material </h5><br><ul><li>  <a href="http://en.wikipedia.org/wiki/File:Jupiter_from_Voyager_1.jpg">Jupiter close-up by Voyager 1</a> </li><li>  <a href="http://textures.forrest.cz/index.php%3FspgmGal%3Dmaps%26spgmPic%3D14">Jupiter texture</a> </li><li>  <a href="http://maps.google.com/">Earth from Google Maps</a> </li><li>  <a href="http://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html">Diagrams from Filter Effects spec</a> </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  PS Translated at the request of <a href="https://habrahabr.ru/users/keyten/" class="user_link">Keyten</a> did not try anything described above =) <br></div></div><br></div><p>Source: <a href="https://habr.com/ru/post/155447/">https://habr.com/ru/post/155447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155435/index.html">Development of Unity3d-plugin for working with Facebook</a></li>
<li><a href="../155437/index.html">Calculated fields for any LINQ provider</a></li>
<li><a href="../155439/index.html">Add some virtuality to C</a></li>
<li><a href="../155443/index.html">Microsoft refuses to install Verizon rootkit, Windows Phone 8 sales may be postponed</a></li>
<li><a href="../155445/index.html">An example of the development of simple casual games for Windows 8</a></li>
<li><a href="../155449/index.html">Curiosity sent the first soil sample for internal research</a></li>
<li><a href="../155451/index.html">A scientific journal in mathematics accepted an article from the text generator Mathgen</a></li>
<li><a href="../155459/index.html">A look from Google on site optimization</a></li>
<li><a href="../155461/index.html">There's More Than One Way To Do It</a></li>
<li><a href="../155465/index.html">Easy way to create Unity Lens for Ubuntu (translation)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>