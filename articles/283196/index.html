<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We present data and code in order: data and markup, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This series of two articles on performance and memory describes the basic principles and provides tips for developers on how to improve software perfo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We present data and code in order: data and markup, part 2</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/83f/2a7/1f3/83f2a71f3488477f8b4e0dbbd043e30a.jpg"></div><br><br>  This series of two articles on performance and memory describes the basic principles and provides tips for developers on how to improve software performance.  These articles address, in particular, memory performance and composition.  In the <a href="https://habrahabr.ru/company/intel/blog/282738/">first part,</a> we talked about the use of registers and the use of blocking algorithms to increase data reuse.  This part of the article first describes the layout of data for regular parallelization ‚Äî programming for shared memory with threads, and then distributed computing over MPI networks.  The article describes the concepts related to parallelization: vectorization (SIMD instructions) and working with shared memory (multi-threaded architecture), as well as calculations with distributed memory.  Finally, this article compares the ‚Äúarray of structures‚Äù (AOS) and ‚Äúarray structures‚Äù (SOA) data layouts. <br><a name="habracut"></a><br>  The basic principle of performance is described in the first part: reuse of data in registers or in the cache before they are crowded out.  The principles of performance described in this article are as follows: place the data as close as possible to the place where they are most often used;  post data for sequential access;  Avoid data conflicts. <br><br><h2>  <font color="#0071c5">Programming shared memory with threads</font> </h2><br>  Let's start with programming shared memory with threads.  All threads together access the same memory within the process.  There are many models of flow control.  The most famous among them are Posix * threads and Windows * threads.  In the work associated with the proper creation of threads and their management, errors may occur.  In modern programs, consisting of many modules and created by large teams of developers, errors in parallel programming with the use of multi-threaded calculations often occur.  Several packages have been developed to simplify the creation of threads, their management and the most efficient use of parallel threads.  The two most popular packages are OpenMP * and Intel Threading Building Blocks.  The third flow control model, Intel Cilk Plus, is not as widely used as OpenMP and Threading Building blocks.  All these flow control models create a thread pool that is reused for each of the parallel operations and parallel domains.  OpenMP has the advantage of stepwise parallelization using directives.  At the same time, OpenMP directives can often be added to existing programs in a step-by-step process and with minimal code changes.  If you allow the runtime library to manage the maintenance of threads, this greatly simplifies the development of multi-threaded programs.  It also provides a unified flow control model that all code developers must adhere to, which reduces the likelihood of some common errors.  An optimized flow control library is used by all developers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The principles of parallel programming mentioned in the introductory part are to place data as close as possible to the place where they will be used and to avoid data movement.  In multithreaded programming in the default model, the data is common to the entire process; all threads can access it.  The introductory flow management articles emphasize how easy it is to apply OpenMP to do (Fortran *) loops or for ¬© loops.  Such methods are usually significantly accelerated when executing code on two or four cores.  Often, these methods are scaled to 64 threads or more.  However, additional flows are not less often used, and in some such cases this is due to improper data composition.  The point is to create an architecture suitable for parallel code. <br><br>  It is important to explore the possibility of parallelization at a higher level in the code call stack than originally intended by the developer or development tools.  If the developer believes that any tasks or data can be processed in parallel, then try to answer the following questions (in the light of Amdal‚Äôs law): ‚ÄúCan I start using parallel operations higher in the call stack before going to this place?‚Äù, ‚ÄúIf I‚Äôm I‚Äôll do this, will the parallel area of ‚Äã‚Äãthe code increase, which will speed up the work when more threads are involved? ‚Äù <br><br>  Consideration should be given to the placement of the data, and to what data can be shared through messages.  The data layout should include the placement of data where it is most used, and from there it can be sent to other systems.  For applications represented in a table or in a physical domain with specified partitions, MPI programs often add a row of ‚Äúphantom‚Äù cells around the subordinate table or subordinate domain.  In the "phantom" cells, the data values ‚Äã‚Äãsent by the MPI process updating these cells are stored.  In multi-threaded programs, ‚Äúphantom‚Äù cells are usually not used, but if the length of the interface is reduced for sending messages, it is desirable to reduce the boundaries of partitions using shared memory.  This reduces the need for blocking threads (or important sections) and the likelihood of cache conflicts associated with cache ownership. <br><br>  In large multiprocessor systems, a common global address memory space is used, but the non-uniform memory architecture is also used.  Retrieving data located in a memory module closest to another processor takes longer (delay increases) than retrieving data from a memory module closest to the processor that processes the code.  The closer the memory to which the call is located, the less delay. <br><br><img src="https://habrastorage.org/files/c99/a43/9ba/c99a439baa15415bb26b99ddf7be350e.png"><br>  <font color="#999999"><i>Figure 1. Memory access speed, relative delays in accessing data</i></font> <br><br>  If one thread allocates and initializes data, then this data is usually placed in memory closest to the processor in which the thread allocates and initializes the memory (Fig. 1).  You can improve performance by forcing each thread to allocate and give the first reference to the memory that will be used to the greatest extent by this thread.  Usually this is enough for the thread to run in the memory area closest to the processor.  If the thread is created and active, then the OS usually leaves it in the same processor.  Sometimes it is beneficial to explicitly bind a thread to a specific core in order to avoid transferring the flow between the cores.  If the data has a specific layout, it may be beneficial to assign or bind the threads to specific cores in accordance with this layout.  The Intel OpenMP Execution Library (as part of <a href="https://software.intel.com/en-us/intel-parallel-studio-xe">Intel Parallel Studio XE 2016</a> ) contains explicit mapping attributes that work effectively on Intel Xeon Phi co-processors. <br><br>  These attributes are Compact, Scatter and Balanced. <br><br><ol><li>  The Compact attribute matches sequential or neighboring threads with symmetric multithreaded sets (SMT) on one core before assigning threads to other cores.  This is the ideal solution for situations where streams access data that is common to streams with sequential numbering (i.e., neighboring streams). <br><br></li><li>  The Scatter attribute assigns one thread to each core, then returns to the original core to plan other threads in the SMT. <br><br></li><li>  The Balanced attribute uniformly assigns threads with consecutive or adjacent identifiers to the same core.  This is the recommended starting attribute for optimizing stream mapping in the Intel 16.0 C ++ compiler documentation.  The Balanced option is available only for the Intel Xeon Phi product family.  For ordinary CPUs, it is invalid.  When all SMTs on the Xeon Phi platform are enabled, the Balanced and Compact attributes work in the same way.  If only some SMTs are involved on the Xeon Phi platform, the Compact method will fill all SMTs on the first cores, and some cores will remain free (ideally). </li></ol><br>  When working with dozens of streams, it is important to place the stream data as close as possible to the place where it will be used.  Data layout is important both for programs using MPI networks and for multi-threaded programs. <br><br>  With regard to memory and data composition, two factors should be considered.  They are fairly simple, and can have a significant impact on the work.  The first is false sharing, the second is data alignment.  False sharing is one of the interesting performance factors in multi-threaded programs.  All streams working with data are independent.  There is no shared access, but the cache line containing both pieces of data is shared.  Therefore, the name ‚Äúfalse shared data access‚Äù is used: as such, there is no shared data access, but the performance is the same as if shared access was used. <br><br>  Imagine a situation where each stream increases the value of its own counter, but the counter itself is a one-dimensional array.  Each thread increases the value of its counter.  To increase the counter value, the kernel must own a cache line.  For example, thread A of processor 0 becomes the owner of the cache line and increases the value of the iCount [A] counter.  At the same time, the stream A + 1 of processor 1 increases the value of the iCount [A + 1] counter.  To do this, processor core 1 takes ownership of the cache line and thread A + 1 updates the value of the counter.  Since the value in the cache line changes, this line is invalidated for processor 0. In the next iteration, processor 0 takes ownership of the cache line and changes the value of iCount [A], which, in turn, cancels this cache line for processor 1. When the thread is in processor 1 will be ready to record, the cycle repeats.  A significant amount of processor cycles is spent on maintaining cache consistency, since invalidating cache lines, regaining control, and synchronizing with memory affects performance. <br><br>  The best solution is not to cancel the cache.  For example, when entering a loop, each thread can read its counter and store it in a local variable in its stack (the cache is not canceled when reading).  When the work is completed, the stream can copy its local value back to a permanent location (see Figure 2).  Another alternative solution is to use data padding so that the data is preferably used by one specific stream in its own cache line. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iCount[nThreads] ; . . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (some interval){ <span class="hljs-comment"><span class="hljs-comment">//some work . . . iCount[myThreadId]++ // may result in false sharing }</span></span></code> </pre> <br><img src="https://habrastorage.org/files/efb/51b/808/efb51b80871e4148b7dc9736da17666b.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iCount[nThreads*<span class="hljs-number"><span class="hljs-number">16</span></span>] ;<span class="hljs-comment"><span class="hljs-comment">// memory padding to avoid false sharing . . . for (some interval){ //some work . . . iCount[myThreadId*16]++ //no false sharing, unused memory }</span></span></code> </pre><br><img src="https://habrastorage.org/files/f4c/3b2/8d1/f4c3b28d1bbc42ed8a2f3c2031361f84.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iCount[nThreads] ; <span class="hljs-comment"><span class="hljs-comment">// make temporary local copy . . . // every thread creates its own local variable local_count int local_Count = iCount[myThreadID] ; for (some interval){ //some work . . . local_Count++ ; //no false sharing } iCount[myThreadId] = local_Count ; //preserve values // potential false sharing at the end, // but outside of inner work loop much improved // better just preserve local_Count for each thread</span></span></code> </pre><br>  <font color="#999999"><i>Figure 2</i></font> <br><br>  False sharing can also occur when assigning scalar values ‚Äã‚Äãto adjacent memory areas.  This case is shown in the code snippet below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data1, data2 ; <span class="hljs-comment"><span class="hljs-comment">// data1 and data2 may be placed in memory //such that false sharing could occur declspec(align(64)) int data3; // data3 and data4 will be declspec(align(64)) int data4; // on separate cache lines, // no false sharing</span></span></code> </pre><br>  When a developer creates parallel code from the start and minimizes the use of shared data, it is usually possible to avoid false sharing.  If your multithreaded program does not have sufficient scalability (i.e. it does not start working faster when additional streams are used), although there are many independent procedures and few obstacles (mutual exclusions, important sections), then it makes sense to check if a false common access. <br><br><h2>  <font color="#0071c5">Data alignment</font> </h2><br>  Program performance is optimal when data processed by SIMD instructions (AVX512, AVX, SSE4) are aligned to the cache line boundaries.  The loss of performance when accessing unaligned data differs depending on the processor family.  The work of the Intel Xeon Phi coprocessors is particularly affected by data alignment.  On the Intel Xeon Phi platform, data alignment is of paramount importance.  This difference is not so great on other Intel Xeon platforms, but performance still noticeably increases when the data is aligned with the cache line boundaries.  Therefore, program developers are encouraged to always align data on 64-byte boundaries.  On Linux * and Mac OS X * systems, you don‚Äôt even need to change the code, you just need to use the corresponding parameter in the command line of the Intel compiler: <i>/ align: rec64byte</i> . <br><br>  For dynamically allocated memory in C, you can replace <i>malloc ()</i> with <i>_mm_alloc (datasize, 64)</i> .  If <i>_mm_alloc () is used</i> , then <i>_mm_free ()</i> should be used instead of <i>free ()</i> .  A detailed article on data alignment is <a href="https://software.intel.com/en-us/articles/data-alignment-to-assist-vectorization">here</a> . <br><br>  Also read the compiler documentation.  To show the effect of data alignment on two matrices of the same size, we created and launched the block matrix multiplication code used in the first part of this article.  In the first case, the matrix A was aligned.  In the second case, the matrix A was intentionally shifted by 24 bytes (three Double values).  At the same time, the performance (the Intel 16.0 compiler was used) fell by 56‚Äì63% for matrices ranging in size from 1200 x 1200 to 4000 x 4000. In the first part, I gave a table with the cycle ordering performance in different compilers.  When one matrix was shifted, the Intel compiler stopped producing a performance boost.  Developers are advised to read the compiler documentation to learn about data alignment and the options available, so that the compiler can use the aligned data as efficiently as possible.  The code for measuring the performance of a matrix that is shifted relative to the cache line is included in <a href="https://github.com/drmackay/samplematrixcode">the code for the first part of the article</a> . <br><br>  For more information, see the compiler documentation. <br><br>  To show the effect of data alignment on two matrices of the same size, we created and launched the block matrix multiplication code used in the first part of this article.  The first matrix was aligned.  The second matrix was intentionally offset by 24 bytes (three Double values).  At the same time, the performance (the Intel 16.0 compiler was used) fell by 56‚Äì63% for matrices ranging in size from 1200 x 1200 to 4000 x 4000. <br><br><h2>  <font color="#0071c5">Array of structures or array structure</font> </h2><br>  Processors work very efficiently with sequential memory access.  It is very good if each element of the cache line is moved to SIMD registers.  If the cache lines are also loaded sequentially, then the preemptive sampling of the processors works in an orderly manner.  In an array of structures, the data layout may be approximately the same. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> uint r, g, b, w ; <span class="hljs-comment"><span class="hljs-comment">// a possible 2D color rgb pixel layout } MyAoS[N] ;</span></span></code> </pre><br>  In this arrangement, the rgb values ‚Äã‚Äãare arranged sequentially.  If the program works with color plane data, then with high probability the entire structure will be placed in the cache, but only one value will be used each time, for example, g.  If the data is stored in an array structure, the layout may be something like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> uint r[N] ; uint g[N] ; uint b[N] ; uint w[N] ; } MySoA ;</code> </pre><br>  If the data is stored in an array structure and the program works with all values ‚Äã‚Äãof g (or r, or b), then the entire cache will be used with high probability when working in the cache of one cache line.  Data is more efficiently loaded into SIMD registers, thereby increasing efficiency and productivity.  In many cases, program developers temporarily move data into an array structure for processing, and then copy it back when it becomes necessary.  In all possible cases, it is better to avoid this additional copying, because it takes longer to complete. <br><br>  Intel's Memory Access Pattern (MAP) analysis (Vectorization) Advisor 2016 identifies loops with sequential, non-sequential, and irregular access. <br><br><img src="https://habrastorage.org/files/ed5/7f3/48a/ed57f348ace148b993627f778406e59d.jpg"><br><br>  The Strides Distribution column provides cumulative statistics on how often each model is used in a given cycle.  In the figure above, two-thirds of the horizontal bar is shaded in blue (this is sequential memory access), and the right third is shaded in red (this is non-sequential access).  For code with an ‚Äúarray of structures‚Äù layout, Advisor can also receive a ‚Äúrecommendation‚Äù for converting an array of structures into an array structure. <br><br>  Analyzes of access models and memory locality are simplified in the Advisor MAP, they additionally provide a memory usage metric and match the diagnostics of each ‚Äústep‚Äù (i.e. access model) with certain names of objects and arrays of C ++ or Fortran *.  For more information about Intel Advisor, see the sites <a href="https://software.intel.com/en-us/get-started-with-advisor">here</a> and <a href="https://software.intel.com/en-us/intel-advisor-xe">here</a> . <br><br>  Arrays ‚Äúarray structure‚Äù and ‚Äúarray of structures‚Äù are used in many graphic programs, in programs for calculating particle dynamics (for example, molecular dynamics), for instantaneous data and properties (mass, location, velocity, charge) that can be associated with a point or with a specific body.  As a rule, the array structure works more efficiently and faster. <br><br>  In the Intel compiler, starting from version 2016 Update 1, the transformation ‚Äúarray of structures‚Äù -&gt; ‚Äústructure of arrays‚Äù is simplified due to the use of Intel SIMD (Intel SDLT) data composition templates.  Using the SDLT templates, you can simply override the container of an array of structures as follows. <br><br><pre> <code class="cpp hljs">SDLT_PRIMITIVE(Point3s, x, y, z) sdlt::soa1d_container&lt;Point3s&gt; inputDataSet(count);</code> </pre> <br>  This will allow access to Point3s instances by the array structure model.  Read more about SDLT <a href="https://software.intel.com/en-us/node/600110">here</a> . <br><br>  There are several articles on the use of arrays of structures and structures of arrays.  In particular, it is recommended to read the following articles (English): <br><br><ul><li>  <a href="https://software.intel.com/en-us/articles/a-case-study-comparing-aos-arrays-of-structures-and-soa-structures-of-arrays-data-layouts">Comparing-Intensive Loop</a> </li><li>  <a href="https://software.intel.com/en-us/articles/how-to-manipulate-data-structure-to-optimize-memory-use-on-32-bit-intel-architecture">How to Manipulate Data Architecture to 32-Bit Intel Architecture</a> </li><li>  <a href="http://stackoverflow.com/questions/17924705/structure-of-arrays-vs-array-of-structures-in-cuda">Structure of Arrays vs Array of Structures in cuda</a> </li></ul><br>  In most cases, the structure of arrays is faster, but in some cases, the layout and use of data is closer to an array of structures, which at the same time provides higher performance. <br><br><h2>  <font color="#0071c5">Conclusion</font> </h2><br>  Let's sum up.  Here are the basic principles to follow in terms of performance and data composition.  Structure the code to minimize data movement.  Reuse data as long as it is in the registers and in the cache (this also allows you to move less).  You can limit the movement of data by locking loops.  This is especially important for programs with two-dimensional or three-dimensional layout.  Analyze the layout for parallelization: how tasks and data are distributed for parallel computing.  Proper domain demarcation techniques improve the efficiency of both messaging (MPI) and shared memory programming.  In the structure of arrays, less data is usually moved than in an array of structures, and the speed is higher.  Avoid spurious sharing, create truly local variables, or use padding so that multiple threads do not reference values ‚Äã‚Äãin the same cache line.  Finally, adjust the alignment of the data so that it starts in the cache line. <br><br>  The full code can be downloaded <a href="https://github.com/drmackay/samplematrixcode">here</a> . <br><br>  If you have not read the first part of this article, then it is <a href="https://habrahabr.ru/company/intel/blog/282738/">here</a> . <br><br>  Apply the described techniques and estimate how much the code performance will improve. </div><p>Source: <a href="https://habr.com/ru/post/283196/">https://habr.com/ru/post/283196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283184/index.html">Windows 10 IoT Core: GPIO, Lightning and RemoteClient</a></li>
<li><a href="../283186/index.html">An example of creating a simple 2D game for Android using the Unity game engine</a></li>
<li><a href="../283190/index.html">Another extraordinary version of the standard PCI DSS v3.2</a></li>
<li><a href="../283192/index.html">IT in modern architectural and interior lighting: different engineering buns</a></li>
<li><a href="../283194/index.html">Azure-IaaS-Digest number 6 (April-May)</a></li>
<li><a href="../283198/index.html">About the 1C: Enterprise Mobile Platform</a></li>
<li><a href="../283202/index.html">Laboratory: Rust - let's talk about Rust in Kaspersky Lab on May 17</a></li>
<li><a href="../283204/index.html">We build a pre-built dylib into the application.</a></li>
<li><a href="../283208/index.html">Using Matalysis in computer games (part 3)</a></li>
<li><a href="../283210/index.html">We are looking for vulnerabilities using google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>