<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>J-sort</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pyramid sorting (a sort of a bunch ) is a classic algorithm that any programmer should probably know. The good old ‚Äúpyramid‚Äù is remarkable in that, re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>J-sort</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/post/221095/"><img src="https://habrastorage.org/getpro/habr/post_images/772/47e/7d9/77247e7d9f1ee87a59f4c29ba35ae331.jpg" align="left"></a> <br clear="right">  <strong>Pyramid sorting</strong> (a <strong>sort of a bunch</strong> ) is a classic algorithm that any programmer should probably know.  The good old ‚Äúpyramid‚Äù is remarkable in that, regardless of the data set, it has the same complexity in time (and very decent) - <strong>O</strong> ( <strong>n</strong> log <strong>n</strong> ).  There are no better or degenerate cases for it. <br><br>  Since the invention of the method (and this year the algorithm is celebrating its half-century anniversary) there have been many eagerly drastically optimizing the process of laying the sorting heaps.  Ternary pyramidal sorting, smooth sorting, Cartesian sorting - this is an incomplete list of innovations.  The listed algorithms, while testing, are ahead of the original in absolute speed, who is 12 and 25% ahead, still revolve around <strong>O</strong> ( <strong>n</strong> log <strong>n</strong> ) in the assessment of time complexity.  Moreover, these methods are very sophisticatedly implemented. <br><br>  A humble laborer of the University of Manitoba, <strong>Jason Morrison,</strong> also suggested his vision of a pyramidal sorting.  In this case, the method in some cases approaches the speed <strong>O</strong> ( <strong>n</strong> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h1>  Heapsort </h1><br>  For those who are not in the subject, briefly outline how the pyramidal sorting works. <br><br> <a href=""><img align="right" src="https://habrastorage.org/getpro/habr/post_images/fe2/4d0/5fd/fe24d05fd0dc07ff8fa39effefa84e2c.gif"><br clear="left"></a>  An array can be sorted by building and rebuilding a <strong>sorting tree</strong> based on it, known as a <strong>binary heap</strong> or simply a <strong>pyramid</strong> . <br><br>  What is a sorting tree?  This is a tree that has any parent more (or less, depending on which way it is sorting) than its descendants. <br><br>  How to make a sorting tree out of ordinary wood?  It is very simple - you need to move from descendants up to the parents, and if the descendant is larger than the parent, then switch places.  If such an exchange has occurred, a parent descended one level must be compared with the descendants below - maybe there will also be a reason for the exchange there. <br><br>  Transforming the unsorted part of the array into a sorting tree, as a result, the largest element ‚Äúpops up‚Äù to the root.  We swap the maximum with the last key of the unsorted subarray.  The structure will cease to be a sorting tree, but as moral compensation, its unsorted part will become less by one node.  The whole procedure is again applicable to this unsorted part, that is, we transform it into a sorting tree with subsequent rearrangement of the found maximum to the end.  And so we act until the unsorted part shrinks down to a single element. <br><br>  The approach, to be sure, is witty, but at the same time specialists at the algorithms note a whole bunch of flaws in sorting, such as: instability, randomness of sampling, insensitivity to almost ordered arrays, etc. The unimprovable speed <strong>O</strong> ( <strong>n</strong> log <strong>n</strong> ) confuses everyone shown by sorting absolutely with any sets of input data. <br><br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/fc3/022/f70/fc3022f70adb9d429175b4d96ffa6417.jpg"><br clear="right">  Outstanding <em>computer science</em> minds offer various brain-bearing ideas ( <em>ternary pyramids</em> , <em>Leonardo numbers</em> , <em>Cartesian trees</em> ) with which you can improve the algorithm.  Jason Morrison ( <strong>J</strong> ason Morrison, the sort is named after the author) suggested the opposite - to optimize, you need not to complicate, but <em>simplify</em> as much as possible. <br><br><h1>  Jsort </h1><br>  A Canadian scientist came to the conclusion that rebuilding a pile for each element is expensive.  So is it necessary to array an array of <strong>n</strong> elements to radically shovel <strong>n</strong> times? <br><br>  If for the array to build only a couple of heaps (descending and ascending), then it will significantly order it in both directions. <br><br> <a href=""><img align="right" src="https://habrastorage.org/getpro/habr/post_images/8d6/1ac/ebc/8d61acebcaaa36ad47fe0489f14b2a18.gif"><br clear="left"></a>  First you need to build a <strong>non-increasing heap</strong> .  As a result, smaller elements float to the upper nodes of the pyramid (which will correspond to the left half of the array), the smallest element will generally be at the root.  The higher the elements are in the sorting tree, the more ordered the corresponding part of the array will be.  Elements closer to the leaves of the tree (they will correspond to the second half of the array) will have a less orderly appearance, since they did not compare with each other, but were simply pushed aside by the movement of their parents. <br><br>  To restore relative order on the right side of the array, you should build a bunch again, in the opposite of the first one.  First, this heap should be <strong>non-decreasing</strong> (we now want to deal with large-value keys).  Secondly, it should be ‚Äúmirrored‚Äù to the array, that is, its root should correspond not to the first, but to the last element and build a tree, going through the array from the end to the beginning. <br><br>  Having built such a twin pyramid, we get a largely ordered array.  Completes the <strong>sorting inserts</strong> .  This algorithm has a very modest average time complexity <strong>O</strong> ( <strong>n <sup>2</sup></strong> ), but it works wonders on arrays that are already almost sorted.  Their sorting inserts click as nuts. <br><br><h1>  Time complexity </h1><br>  Let's try to evaluate with the most favorable scenario.  A single pyramid building is <strong>O</strong> ( <strong>n</strong> ).  Heap we have imposed two, so we get <strong>O</strong> ( <strong>2n</strong> ).  An almost ordered array sorting inserts can sort for record <strong>O</strong> ( <strong>n</strong> ).  The overall complexity is <strong>O</strong> ( <strong>3n</strong> ), which is the same as <strong>O</strong> ( <strong>n</strong> ). <br><br>  However, in practice, everything looks more modest.  Take, for example, an unsorted array containing numbers from <em>1</em> to <em>30</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b56/488/a30/b56488a309ecee6a2294f21131e2c7ca.jpg"></div><br>  Construct the usual non-increasing heap: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/c4b/113/486c4b113cb255850cbce269e1840646.jpg"></div><br>  The first third of the massif took a quite nice form, in the middle - who is in the forest for firewood, the end of the array is not impressive either. <br><br>  We now build a ‚Äúmirror‚Äù non-decreasing heap: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5e/374/122/d5e3741227937fc0663c39b2fb5da474.jpg"></div><br>  The end of the array noticeably prettier.  In the middle, there are some rudiments of orderliness, but it doesn‚Äôt look as glamorous as the left and right sectors.  In principle, the array is quite ripe to feed it sorting inserts. <br><br>  Notice the key with a value of <em>20.</em> Why is this item stuck in the first third of the array?  Tritely unlucky - before building a ‚Äúmirror‚Äù non-decreasing heap, all parents went upward along the branch by value (at the root is now <em>17</em> , but this key will sink in the left half of the tree and give way to <em>30</em> ).  Therefore, in the pyramid he was not destined to rise at least a step. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec1/928/c66/ec1928c6634bc65db2932158ffd684cf.jpg"></div><br>  The longer the array, the more often such degenerate nodes will arise.  So, in the middle lane of long arrays sorting inserts will have to work hard.  The array for processing supplied to it will not be nearly sorted, but rather <em>almost</em> almost sorted.  On very long lists, the time complexity of the <strong>Insertion Sort</strong> will, of course, not be its average / worst <strong>O</strong> ( <strong>n <sup>2</sup></strong> ), but it will be far to <strong>O</strong> ( <strong>n</strong> ). <br><br><h1>  By the way </h1><br>  There is another sorting algorithm with a very similar name - <strong>J sort</strong> , which was developed by <strong>J</strong> Cohn ( <strong>J</strong> ohn Cohen).  This is also a hybrid algorithm, used to handle doubly linked lists.  Combines <strong>thread-like sorting</strong> ( <strong>Strand sort</strong> ) and <strong>sorting by shuffling</strong> ( <strong>Shuffle sort</strong> ).  But that's another story. <br><br><h1>  Algorithm Characteristics </h1><table><tbody><tr><th>  Title </th><td colspan="2">  Jsort (J-sort) </td></tr><tr><th>  Author </th><td colspan="2">  Jason Morrison </td></tr><tr><th>  Class </th><td colspan="2">  Hybrid sorting (heap + inserts) </td></tr><tr><th>  Resilience </th><td colspan="2">  Unstable </td></tr><tr><th>  Comparisons </th><td colspan="2">  there is </td></tr><tr><th rowspan="3">  Time complexity </th><th>  the best </th><td>  O (n) </td></tr><tr><th>  average </th><td>  ? </td></tr><tr><th>  the worst </th><td>  O (n <sup>2</sup> ) </td></tr><tr><th rowspan="2">  Memory difficulty </th><th>  Total </th><td>  O (n) </td></tr><tr><th>  additional data </th><td>  O (1) </td></tr></tbody></table><br><br><h1>  Additionally </h1><div class="spoiler">  <b class="spoiler_title">Heap sort in java</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** *      *   - JWJ Williams  RW Floyd * * SortAlgorithm.java, Thu Oct 27 10:32:35 1994 * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Jason Harrison@cs.ubc.ca * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@version</span></span></span><span class="hljs-comment"> 1.0, 23 Jun 1995 */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapSortAlgorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SortAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  void sort(int a[]) throws Exception { int N = a.length; //     //    . for (int k = N / 2; k &gt; 0; k--) downheap(a, k, N); //   //    do { //    ... int T = a[0]; a[0] = a[N - 1]; a[N - 1] = T; //...     //    N = N - 1; downheap(a, 1, N); } while (N &gt; 1); //   } //         void downheap(int a[], int k, int N) throws Exception { //   //  int T = a[k - 1]; //     while (k &lt;= N / 2) { int j = k + k;//  //   , //     //     if ((j &lt; N) &amp;&amp; (a[j - 1] &lt; a[j])) j++; //   ( )  ... if (T &gt;= a[j - 1]) { //...         break; } else { //    ... //...       a[k - 1] = a[j - 1]; k = j; } } //         //(    ,     ) a[k - 1] = T; } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">YouTube version of Heap sort animation</b> <div class="spoiler_text"><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/R6x7OuF_dYM%3Ffeature%3Doembed&amp;xid=17259,1500003,15700023,15700186,15700190,15700253&amp;usg=ALkJrhiAq9S8kDth0fvY2o5UrQJYiV7Vsw" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Jsort java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** *    J- (JSort). *   -   (Jason Morrison) * &lt;http://www.scs.carleton.ca/~morrison&gt; * * JSortAlgorithm.java * *   -   * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Patrick Morin */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JSortAlgorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SortAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     //       void reheap (int a[], int length, int i) throws Exception { //      boolean done = false; //   //      int T = a[i]; int parent = i; int child = 2 * (i + 1) - 1; // ,     //     (  -   ) //        //    -   . while ((child &lt; length) &amp;&amp; (!done)) { //      if (child &lt; length - 1) { //        if (a[child] &gt;= a[child + 1]) { child += 1; } } //  ? if (T &lt; a[child]) { //        done = true; //       . //     //          } else { a[parent] = a[child]; parent = child; child = 2 * (parent + 1) - 1; } } //,     //     //(      ) a[parent] = T; } //     //       void invreheap (int a[], int length, int i) throws Exception { //      boolean done = false; //   //      int T = a[length - 1 - i]; int parent = i; int child = 2 * (i + 1) - 1; // ,     //     (  -  ) //        //    -   . while ((child &lt; length) &amp;&amp; (!done)) { //      if (child &lt; length - 1) { //        if (a[length - 1 - child] &lt;= a[length - 1 - (child + 1)]) { child += 1; } } //  ? if (T &gt; a[length - 1 - child]) { //        done = true; } else { //       . //     //          a[length - 1 - parent] = a[length - 1 - child]; parent = child; child = 2 * (parent + 1) - 1; } } //,     //     //(      ) a[length - 1 - parent] = T; } //   void sort(int a[]) throws Exception { //   //     //    for (int i = a.length-1; i &gt;= 0; i--) reheap (a, a.length, i); //   //     //    for (int i = a.length - 1; i &gt;= 0; i--) invreheap (a, a.length, i); //   //  for (int j = 1; j &lt; a.length; j++) { int T = a[j]; int i = j - 1; while (i &gt;= 0 &amp;&amp; a[i] &gt; T) { a[i + 1] = a[i]; i -= 1; } a[i + 1] = T; } } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">YouTube version of Jsort animation</b> <div class="spoiler_text"><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/3m-6u2fMBxE%3Ffeature%3Doembed&amp;xid=17259,1500003,15700023,15700186,15700190,15700253&amp;usg=ALkJrhgirKZbroKkyI9_fltGcHAQZZhe5A" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><h1>  Links </h1><br>  <a href="http://en.wikipedia.org/wiki/JSort">Jsort on Wikipedia</a> <br>  <a href="http://home.cc.umanitoba.ca/~morrisoj/">Jason Morrison Page at the University of Manitoba</a> <br>  <a href="http://ca.linkedin.com/pub/jason-morrison/55/70a/752">Jason Morrison's LinkedIn page</a> </div><p>Source: <a href="https://habr.com/ru/post/221095/">https://habr.com/ru/post/221095/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221087/index.html">Habra Analytics Tools: Compare Hubs</a></li>
<li><a href="../221091/index.html">We realize video calls in an iOS application (by the example of a children's monitor and without WebRTC)</a></li>
<li><a href="../221097/index.html">Samsung Galaxy Tab Pro 10.1: tested in humans</a></li>
<li><a href="../221105/index.html">About cutting corners</a></li>
<li><a href="../221107/index.html">‚ÄúCars instead of people!‚Äù</a></li>
<li><a href="../221111/index.html">Proper use of promise in angular.js</a></li>
<li><a href="../221113/index.html">Free Webinar "Preparation for the exam 70412: Configuring additional services Windows Server 2012"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>