<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The SOLID principle in the Go language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings to you, habrovchane, I decided to share with the community quite often (according to personal observations) the mentioned SOLID Go Design po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The SOLID principle in the Go language</h1><div class="post__text post__text-html js-mediator-article"><p>  Greetings to you, habrovchane, I decided to share with the community quite often (according to personal observations) the mentioned <a href="https://dave.cheney.net/2016/08/20/solid-go-design">SOLID Go Design</a> post from the blog of Dave Cheney, which I did for my own needs, but someone said that you need to share.  Perhaps for someone it will be useful. </p><br><h1 id="solid-dizayn-go">  SOLID go design </h1><br><p>  This post is based on text from the main GolangUK report of August 18th, 2016. <br>  Recording performances <a href="https://www.youtube.com/watch%3Fv%3DzzAdEt3xZ1M">available on YouTube</a> . </p><a name="habracut"></a><br><h2 id="kak-mnogo-programmistov-na-go-v-mire">  How many go programmers in the world? </h2><br><p>  How many go programmers in the world?  Think of the number and keep it in your head, <br>  we will return to this issue at the end of the conversation. </p><br><h2 id="recenzirovanie-koda">  Code Review </h2><br><p>  Who reviews the code here as part of their work?  (a large part of the audience raises their hands, which is encouraging).  Well, why are you doing code review?  (someone shouts "to make the code better") </p><br><p>  If code review is needed to catch bad code, then how do you know if the code you are reviewing is good or bad? </p><br><p>  Now it's okay to say "this code is terrible" or "wow, this code is beautiful," just as if you said "this painting is beautiful" or "this room is beautiful", but these are subjective concepts, and I am looking for objective ways, to talk about the properties of good or bad code. </p><br><h2 id="plohoy-kod">  Bad code </h2><br><p>  What could be bad code properties that you can use when reviewing? </p><br><ul><li>  <em>Inflexible</em> .  Is the code inflexible?  Does it contain a rigid set of types and parameters, making it difficult to modify. </li><li>  <em>Fragile</em> .  Is the code fragile?  Does chaos cause the slightest code base change? </li><li>  <em>Motionless</em> .  Is the code difficult to refactor?  Is it at the touch of a key on a cyclic import? </li><li>  <em>Complicated</em> .  Does this code exist only for the sake of code and is it not over complicated? </li><li>  <em>Verbose</em> .  Is using code exhausting?  Can you look at the code to say what it is trying to do? </li></ul><br><p>  Are these words positive?  Would you like to hear these words when reviewing your code? </p><br><p>  Perhaps not. </p><br><h2 id="horoshiy-dizayn">  Good design </h2><br><p>  But this is an improvement, now we can say something like ‚ÄúI don‚Äôt like it because it‚Äôs too hard to modify‚Äù, or ‚ÄúI don‚Äôt like it because I can't say what this code is trying to do‚Äù, but what about to lead the discussion positively? </p><br><p>  Wouldn't it be great if there was a way to describe the properties of a good design, not just bad, and to be able to reason in objective terms? </p><br><h2 id="solid">  SOLID </h2><br><p>  In 2002, Robert Martin published his book <a href="https://www.amazon.co.uk/dp/0135974445/ref%3Dpd_lpo_sbs_dp_ss_2/253-1946330-6751666%3Fpf_rd_m%3DA3P5ROKL5A1OLE%26pf_rd_s%3Dlpo-top-stripe%26pf_rd_r%3D23C4AHYV7EXGYHKD6G8Q%26pf_rd_t%3D201%26pf_rd_p%3D569136327%26pf_rd_i%3D0132760584">Agile Software Development, Principles, Patterns, and Practices</a> .  In it, he described the five principles of reusable software design, which he called SOLID principles, an abbreviation of their names. </p><br><ul><li>  Principle of sole responsibility </li><li>  Principle of openness / closeness </li><li>  Barbara Liskov substitution principle </li><li>  Interface separation principle </li><li>  Dependency Inversion Principle </li></ul><br><p>  This book is slightly outdated, the languages ‚Äã‚Äãin which the conversation is being conducted were used about 10 years ago.  But perhaps there are some aspects of the SOLID principle that can give us a clue as to how to talk about well-developed Go programs. </p><br><p>  This is exactly what I would like to discuss with you this morning. </p><br><h2 id="princip-edinstvennoy-otvetstvennosti">  Principle of sole responsibility </h2><br><p>  The first principle of SOLID, this is S - the principle of common responsibility. </p><br>  <i>The class must have one and only one reason for the change.</i> <i><br></i>  <i>-Robert S. Martin</i> <br><p>  Go does not contain classes at all, instead we have a much more powerful concept of composition, but if you look at the history of using the concept of a class, I think there is a certain meaning here. </p><br><p>  Why is it so important that one piece of code has only one reason to change?  Well, the idea that your code can change is painful, but it is much less painful than the code on which your code depends, can also change.  And when your code needs to change, it should do so in accordance with a specific requirement, and not be a victim of collateral damage. </p><br><p>  So code that is responsible for a single task will have fewer reasons for making changes. </p><br><h3 id="svyazannost--edinstvo">  Connectedness &amp; Unity </h3><br><p>  Two words that describe how easy it is to make changes to your program are connectedness and unity. </p><br><p>  Connectivity is simply a concept that describes a simultaneous change in two code points, when a change in one place means a mandatory change in another. </p><br><p>  A related but separate concept, this unity is the force of mutual attraction. </p><br><p>  In the context of software, unity is a property that describes parts of code that are naturally interconnected. </p><br><p>  To describe the implementation of the principles of connectedness and unity in the Go program, we could talk about functions and methods, as is often the case when discussing SRP (the principle of common responsibility), but I believe that everything starts with the package system in Go. </p><br><h3 id="imena-paketov">  Package Names </h3><br><p>  In Go, all code exists inside packages, and a good package design starts with its name.  A package name is both a description of its destination and a namespace prefix.  An example of good package names from the standard Go library is: </p><br><ul><li>  <em>net / http</em> , which provides an http client and server. </li><li>  <em>os / exec</em> that runs external commands. </li><li>  <em>encoding / json</em> , which implements the encoding and decoding of JSON documents. </li></ul><br><p> When you use the characters of another package within your own, this is accomplished using the <code>import</code> keyword, which establishes a connection at source level between the two packages.  Now they know about the existence of each other. </p><br><h3 id="plohie-imena-paketov">  Bad package names </h3><br><p>  Such a focus on naming is not just pedantry.  Badly named packages miss the opportunity to describe their task, even if they had one. </p><br><p>  What possibility does the <code>package server</code> provide? .. perhaps this is the server, but with what protocol does it implement? </p><br><p>  What opportunity does <code>package private</code> offer?  Pieces I Shouldn't See?  Should he even have any public symbols? </p><br><p>  And <code>package common</code> , exactly like his partner <code>package utils</code> are often found next to other hard-core violators. </p><br><p>  Attracting such packages turns the code into a dump because they have many responsibilities and often change for no reason. </p><br><h3 id="filisofiya-unix-v-go">  Philisophia UNIX in Go </h3><br><p>  In my view, no discussion of split design would be complete without mentioning Douglas Maclroy's work "Philisophia UNIX";  small, sharp tools that are combined to solve larger problems, often those that were not provided for by the original authors.  I think Go packages embody the spirit of UNIX philosophy.  In reality, each Go package by itself is a small Go program, the only point of change with sole responsibility. </p><br><h2 id="princip-otkrytostizakrytosti">  Principle of openness / closeness </h2><br><p>  The second principle O is the principle of openness / closeness of Bertrand Meyer, who in 1988 wrote: </p><br>  <i>Software objects must be open for expansion and closed for modification.</i> <i><br></i>  <i>- Bertrand Meyer, Building Object-Oriented Software</i> <br><p>  How was this advice applied to languages ‚Äã‚Äãcreated 21 years ago? </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { year <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Hello GolangUK"</span></span>, a.year) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Welcome to GolangUK"</span></span>, b.year) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a A a.year = <span class="hljs-number"><span class="hljs-number">2016</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b B b.year = <span class="hljs-number"><span class="hljs-number">2016</span></span> a.Greet() <span class="hljs-comment"><span class="hljs-comment">// Hello GolangUK 2016 b.Greet() // Welcome to GolangUK 2016 }</span></span></code> </pre> <br><p>  We have type <code>A</code> , with a <code>year</code> field and a <code>Greet</code> method.  We have the second type <code>B</code> in which <code>A</code> is embedded, the calls to <code>B</code> methods overlap the calls to <code>A</code> methods, since <code>A</code> is embedded, as the field in <code>B</code> and <code>B</code> suggests its own <code>Greet</code> method hiding the similar method in <code>A</code> </p><br><p>  But embedding exists not only for methods, it also provides access to the built-in type fields.  As you can see, since both <code>A</code> and <code>B</code> defined in one package, <code>B</code> can access the <code>year</code> 's private field in <code>A</code> , as if it was definitely inside <code>B</code> </p><br><p>  So embedding is a powerful tool that allows types in Go to be open for expansion. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Cat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Cat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Legs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Cat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintLegs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"I have %d legs\n"</span></span>, c.Legs()) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> OctoCat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Cat } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o OctoCat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Legs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> octo OctoCat fmt.Println(octo.Legs()) <span class="hljs-comment"><span class="hljs-comment">// 5 octo.PrintLegs() // I have 4 legs }</span></span></code> </pre> <br><p>  In this example, we have a <code>Cat</code> type that can count the number of legs using its <code>Legs</code> method.  We embed this type of <code>Cat</code> in a new type of <code>OctoCat</code> and declare that <code>OctocatS</code> has five legs.  In doing so, <code>OctoCat</code> defines its own <code>Legs</code> method, which is returned 5, when the <code>PrintLegs</code> method is <code>PrintLegs</code> , it returns 4. </p><br><p>  This is because <code>PrintLegs</code> defined inside the <code>Cat</code> type.  It takes <code>Cat</code> as a receiver and refers to the <code>Cat</code> <code>Legs</code> method.  <code>Cat</code> needs to know about the type in which it was embedded, so its method cannot be changed by embedding. </p><br><p>  From here we can say that the types in Go <em>are open for expansion</em> and <em>closed for modification</em> . </p><br><p>  In fact, the methods in Go are somewhat more than just syntactic sugar around a function with predominantly formal parameters, they are receivers. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Cat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintLegs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"I have %d legs\n"</span></span>, c.Legs()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintLegs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Cat)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"I have %d legs\n"</span></span>, c.Legs()) }</code> </pre> <br><p>  The receiver is exactly what you pass to it, the first parameter of the function, and since Go does not support function overload, <code>OctoCat</code> not interchangeable with the usual type of <code>Cats</code> .  Which brings me to the following principle. </p><br><h2 id="princip-podstanovki-barbary-liskov">  Barbara Liskov substitution principle </h2><br><p>  Invented by Barbara Liskov, the Liskov substitution principle states that two types are interchangeable if they exhibit a behavior in which the caller cannot determine the difference. </p><br><p>  In a class-based language, the Liskov substitution principle is often interpreted as a specification for an abstract class with various specific subtypes.  But there are no classes or inheritance in Go, so the substitution cannot be implemented in terms of the hierarchy of the abstract class. </p><br><h3 id="interfeysy">  Interfaces </h3><br><p>  Instead, substitution is the Go interface's competency.  In Go, types are not required to implement a specific interface; instead, any type of implementation interface simply contains a method whose signature corresponds to the interface declaration. </p><br><p>  We say that in Go, interfaces are implicitly satisfied instead of explicit matching, and this has a profound effect on how they are used in the language. </p><br><p>  A well-designed interface, this is most likely a small interface;  The prevailing idiom is that the interface contains only a single method.  It is logical that the small interface contains a simple implementation, since it is difficult to do otherwise.  From which it follows that packages are a compromise solution of simple implementations connected by <em>ordinary behavior</em> . </p><br><h3 id="ioreader">  io.Reader </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Read reads up to len(buf) bytes into buf. Read(buf []byte) (n int, err error) }</span></span></code> </pre> <br><p>  Which brings me to <code>io.Reader</code> my favorite interface in Go. </p><br><p>  The <code>io.Reader</code> interface <code>io.Reader</code> very simple;  <code>Read</code> reads the data into the specified buffer and returns to the calling code the number of bytes that were read, and any error that may occur during the reading process.  It looks simple, but it is very powerful. </p><br><p>  Because <code>io.Reader</code> deals with anything that can be expressed as a stream of bytes, we can construct objects from literally anything;  a constant string, byte array, standard input stream, network stream, gzip tar archive, standard output stream, or a command executed remotely via ssh. </p><br><p>  And all these implementations are interchangeable, since they satisfy one simple contract. </p><br><p>  So, the Liskov substitution principle is applicable in Go and what has been said can be summed up with the beautiful aphorism of the late Jim Weirich: </p><br>  <i>Require no more, promise no less.</i> <i><br></i>  <i>- Jim Weirich</i> <br><p>  And this is a great transition to the fourth principle of SOLID. </p><br><h2 id="princip-razdeleniya-interfeysa">  Interface separation principle </h2><br><p>  The fourth principle is the interface separation principle, which reads: </p><br>  <i>Clients should not be forced to depend on methods that they do not use.</i> <i><br></i>  <i>-Robert S. Martin</i> <br><p>  In Go, the application of the principle of interface separation can be understood as the process of isolating the behavior of a necessary function to perform its work.  As a concrete example, let's say I have a task to write a function that saves the <code>Document</code> structure to disk. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save writes the contents of doc to the file f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><p>  I can define such a function.  let's call it <code>Save</code> , it accepts <code>*os.File</code> as the source for recording the provided <code>Document</code> .  But here there are several problems. </p><br><p>  The <code>Save</code> signature prevents the ability to write data to any address on the network.  Suppose that the network storage is likely to become a requirement in the future and the signature of this function may change, which will affect everyone who calls it. </p><br><p>  Since <code>Save</code> operates directly on disk files, testing it is rather unpleasant.  To verify operations, tests must read the contents of the file after recording.  In addition, tests must make sure that <code>f</code> was recorded in temporary storage and is always deleted afterwards. </p><br><p>  <code>*os.File</code> also defines many methods that are not relevant to <code>Save</code> , like reading directories and checking whether the path is a symbolic link.  It would be useful if the signature of our <code>Save</code> function was described only by those parts of <code>*os.File</code> that are relevant to its task. </p><br><p>  What can we do with these problems? </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save writes the contents of doc to the supplied ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><p>  Using <code>io.ReadWriteCloser</code> we can apply the interface separation principle to override <code>Save</code> so that it accepts an interface that describes the more common file operations tasks. </p><br><p>  With these changes, any type that implements the <code>io.ReadWriteCloser</code> interface can be replaced with the previous <code>*os.File</code> .  This makes the application of <code>Save</code> wider and explains to the caller of <code>Save</code> , which method of the <code>*os.File</code> type is relevant to the desired operation. </p><br><p>  As the author of <code>Save</code> I should no longer be able to call all irrelevant methods from the <code>*os.File</code> , since they are hidden behind the <code>io.ReadWriteCloser</code> interface.  But we can go a little further with the interface sharing method. </p><br><p>  First, it is unlikely that <code>Save</code> follows the principle of sole responsibility, it will read the file that just recorded to check the contents, which should be the responsibility of another part of the code.  Therefore, we can narrow the interface specification, which we pass to <code>Save</code> only before opening and closing the file. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save writes the contents of doc to the supplied WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><p>  Secondly, by providing <code>Save</code> with the stream closing mechanism that we inherited with the desire to make it look like the usual file handling mechanism, the question arises under what circumstances <code>wc</code> will be closed.  Perhaps <code>Save</code> will call <code>Close</code> without any conditions, or <code>Close</code> will be called if successful. </p><br><p>  All of this represents a problem for the caller <code>Save</code> , since it may wish to add additional information to the stream after the document is already written. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NopCloser <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer } <span class="hljs-comment"><span class="hljs-comment">// Close has no effect on the underlying writer. func (c *NopCloser) Close() error { return nil }</span></span></code> </pre> <br><p>  A rough solution would be to define a new type that embeds <code>io.Writer</code> and overrides the <code>Close</code> method, preventing <code>Save</code> from being called from a closed main thread. </p><br><p>  But this is most likely a violation of Barbara Liskov‚Äôs principle of substitution, since <code>NopCloser</code> doesn‚Äôt really close anything. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save writes the contents of doc to the supplied Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><p>  Much better would be the decision to override <code>Save</code> , accepting only <code>io.Writer</code> , completely preventing it from doing anything other than writing data to the stream. </p><br><p>  But applying the principle of interface separation to our <code>Save</code> function, the result simultaneously becomes a function that is most specific in terms of its requirements, the only thing it needs is something to write to and the most important thing in this function is that we can use <code>Save</code> for saving our data to any place where the <code>io.Writer</code> interface is <code>io.Writer</code> . </p><br>  <i>An important rule of thumb for Go, is <strong>to accept interfaces, and return structures</strong> .</i> <i><br></i>  <i>-Jack Lindamud</i> <br><p>  The above quote is an interesting meme that has leaked into the spirit of Go over the past few years. </p><br><p>  In this version, in the framework of the standard tweet, one nuance is missing and this is not Jack‚Äôs fault, but I think that it represents one of the main reasons for the appearance of dictionaries about Go language design. </p><br><h2 id="princip-inversii-zavisimostey">  Dependency Inversion Principle </h2><br><p>  The final principle of SOLID is the dependency inversion principle, which states: </p><br>  <i>Top level modules should not be dependent on lower level modules.</i>  <i>Both levels should depend on abstractions.</i> <i><br></i>  <i>Abstractions should not depend on their details.</i>  <i>Details must depend on abstractions.</i> <i><br></i>  <i>-Robert S. Martin</i> <br><p>  But what does inversion in practice mean for a Go programmer? </p><br><p>  If you apply all the principles we talked about up to this point, then your code should already be placed in discrete packages, each with a single and well-defined dependency or goal.  Your code should describe its dependencies in terms of interfaces and these interfaces should be aimed at describing exclusively the behavior that is required by these functions.  In other words, there should be a lot of work left. </p><br><p>  So, as I imagine what Martin is talking about here, mainly in the context of Go, this is the structure of your import graph. </p><br><p>  In Go, your import graph should be acyclic.  Attempting to ignore acyclicity will result in a compilation error, but a much more serious error may be in the architecture.  Other things being equal, the import graph of a well-designed Go program should be wide and relatively flat instead of being high and narrow.  If you have a package whose functions cannot be performed without the help of another package, this may be a signal that the boundaries of the package are not well defined. </p><br><p>  The principle of dependency inversion encourages you to transfer the specific responsibility as high as possible in the import column to your <code>main</code> package or to the upper level of the processor, leaving the lower level of the code to work with abstractions and interfaces. </p><br><h2 id="solid-dizayn-go-1">  SOLID go design </h2><br><p>  As a summary, when each of the SOLID principles applies to Go, they are a powerful design tool, but used together, they are the main theme. </p><br><p>  The principle of common responsibility encourages you to structure the functions, types and methods into packages that are naturally interconnected;  Types and functions together serve a single purpose. </p><br><p>  The principle of openness / closeness encourages you to compromise simple types and more complex ones by using paste. </p><br><p>  Barbara Liskov's principle of substitution encourages you to express the dependencies between your packages in terms of interfaces, rather than specific types.  By defining small interfaces, we can be more confident that the implementations will satisfy their contracts. </p><br><p>  The principle of interface separation continues this idea and encourages you to define functions and methods that depend only on the behavior that they need.  If your functions need only an interface type parameter with a single method, then most likely these functions have sole responsibility. </p><br><p>  The principle of inversion of dependencies encourages you to move knowledge about the dependencies of your package from the compilation stage; in Go we see this with a reduction in the number of imports used by a particular package to the code execution stage. </p><br><p>  If you want to summarize this conversation, then most likely it will be: the <em>interfaces allow you to apply the SOLID principles in Go programs</em> . </p><br><p>  Because interfaces allow Go programmers to describe the capabilities of their packages, rather than a specific implementation.  All of this is just another way of saying "disconnecting", which is the goal, since loosely coupled code is easier to change. </p><br><p>  As Sandi Metz noted: </p><br>  <i>Design is the art of organizing code that should work <strong>today</strong> and is <strong>always</strong> easy to change.</i> <i><br></i>  <i>-Sandi Metz</i> <br><p>  Because if Go plans to be the language in which companies invest in the long term, the key factor in their decision will be how easy it is to maintain the code on Go and how easy it is to change. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In conclusion, let's return to the question with which I opened this conversation.  How many go programmers around the world?  Here is my guess: </p><br>  <i>In 2020 there will be 500,000 developers on Go.</i> <i><br></i>  <i>-Dave Cheney</i> <br><p>  What will half a million Go programmers do with their time?  Well, obviously, they will write a lot of code on Go, and if we are honest, not all the code will be good, some of the code will be bad. </p><br><p>  Please understand that I am not trying to be cruel, but each of you in this room with experience in other languages, the languages ‚Äã‚Äãfrom which you came to Go knows from your own experience that there is some truth in this prediction. </p><br>  <i>In C ++, there is a much cleaner and evolutionary language that is trying to exit.</i> <i><br></i>  <i>Byorn Straustrup, Design and Evolution C ++</i> <br><p>  The ability to help our language succeed for every programmer is not to create such a mess that people start talking about when they joke about C ++ today. </p><br><p>  Stories that make fun of other languages ‚Äã‚Äãfor being bloated, wordy, and overloaded once can be applied to Go and I don‚Äôt want this to happen and therefore I have a request. </p><br><p>  Go programmers need to stop talking about frameworks and start talking more about design.  We must stop focusing on performance at all costs and focus instead on reuse at all costs. </p><br><p>  I would like to see today how people talk about how to use the language that we have, regardless of their choice and limitations, to create solutions and solve real problems. </p><br><p>  I would like to hear today how people talk about program design on Go in such a way that they are well designed, disconnected, re-usable and responsive to change. </p><br><h2 id="-i-esche-odna-detal">  ... and one more detail </h2><br><p>  Now it‚Äôs great that so many people today came to listen to such an excellent composition of speakers, but the reality is that no matter how much this conference grows, compared to the total number of people who use Go throughout his life, we are only small part. </p><br><p>  Therefore, our task is to tell the rest of the world how good software should be written.  Good software, compatible, changeable and show them how to do it using Go.  And it starts with you. </p><br><p>  I want you to start talking about design, maybe use some of the ideas that I presented here, I hope you will conduct your own research and apply these ideas to your project.  Then I want you to: </p><br><p>  -Wrote a blog post about it. <br>  -Tell at the workshop what you have done. <br>  -Write a book about what you have learned. <br>  And come back to this conference next year and tell us about what you have achieved. </p><br><p>  By doing all this we will be able to form an ecosystem of Go developers who take care of their programs designed to keep working. </p><br><p>  Thank. </p><br><hr><br><p>  <a href="https://dave.cheney.net/2016/08/20/solid-go-design">Original post by Dave Cheney</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348852/">https://habr.com/ru/post/348852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348842/index.html">Information architecture and technology DITA. Based on a lecture in Yandex</a></li>
<li><a href="../348844/index.html">Release 3CX v15.5 Update 3 with new features and important changes.</a></li>
<li><a href="../348846/index.html">Nutanix Flow - Virtual Network Microsegmentation</a></li>
<li><a href="../348848/index.html">Machine learning content manager</a></li>
<li><a href="../348850/index.html">And Spring will come to JavaFX too</a></li>
<li><a href="../348854/index.html">Advanced work with JSON in MySQL</a></li>
<li><a href="../348856/index.html">Digital events in Moscow from February 12 to 18</a></li>
<li><a href="../348858/index.html">PHP Digest 125 (January 29 - February 11, 2018)</a></li>
<li><a href="../348860/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ 301 (February 5 - 11, 2018)</a></li>
<li><a href="../348862/index.html">Innovations React 16.3 (.0-alpha)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>