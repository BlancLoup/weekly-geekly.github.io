<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>microcontroller console with micro readline</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the microrl library ( on github ), intended for organizing the console interface in various embedded glands on microcontrollers. 

 W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>microcontroller console with micro readline</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/4d5d27a3/b9d0bd1d/3f4f4ee2/e91cb976.png">  I present to you the <b>microrl</b> library ( <a href="https://github.com/Helius/microrl">on github</a> ), intended for organizing the console interface in various embedded glands on microcontrollers. <br><br><h4>  Why do we need a console in MK? </h4><br>  Text console interface has several advantages for embedded systems, with all its power and simplicity (because the text, unlike the LED, speaks for itself!): <br><ul><li>  It requires relatively few MK resources, and minimal hardware costs ‚Äî a serial interface like UART or any other MK available, it can be a built-in USB or an external USB-Com adapter or even TCP if your microcontroller is serious enough. </li><li>  It is convenient to connect - just a terminal supporting Com-port (putty for Windows or minicom for linux) is enough. </li><li>  It is convenient to use - color output to the terminal, support for auto-add-ons, hot keys and input history. </li></ul><a name="habracut"></a><br>  So, what the library supports at the moment: <br><ul><li>  basic functions of the vt100 terminal (it is supported by most terminal emulators) </li><li>  configuration file that allows you to enable and disable features to save memory (for MK is very important); </li><li>  understands HOME, END, cursor keys, backspace; </li><li>  understands hotkeys ^ U ^ K ^ E ^ A ^ N ^ P etc. </li><li>  input history with up and down navigation and hotkeys </li><li>  auto-add-ons (auto substitution?) </li></ul>  I decided to write a library that is analogous to <a href="http://ru.wikipedia.org/wiki/GNU_readline">gnu readline</a> for linux, i.e.  the part that is responsible for the terminal input, processing the string and the control sequences of the terminal, etc.  The main goals are compactness, ease of use, the minimum necessary functionality for comfortable work (this is not about large PCs, but small MKs with tens or hundreds of KB of memory). <br><br><h4>  A bit of theory </h4><br>  A small insight into the history and features of the terminal economy were well described in <a href="http://habrahabr.ru/company/selectel/blog/120852/">this topic</a> , I will not repeat, I will describe only in brief the principle of operation. <br><img src="https://habrastorage.org/getpro/geektimes/post_images/7d6/a18/ad2/7d6a18ad2338591976a4b2a352e820f7.jpg" alt="image" align="right"><br>  From the user's point of view, everything starts in the terminal and ends there, because as Wikipedia says: <i>‚ÄúThe terminal is an I / O device, its main functions are to display and enter data‚Äù</i> .  There are a lot of terminal emulators for all platforms and with different functionalities, for example, gnome-terminal, rxvt, putty, minicom, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The user presses the buttons on the keyboard, the terminal sends them through any channel to the device or system, and it returns the characters to be printed on the screen.  In addition to simple text characters, ESC-sequences are sent to both sides for transmitting control codes and service information, for example, special codes are sent from the keyboard.  keys (Enter, cursor, ESC, Backspace, etc.).  The sequences go back to the screen to control the cursor position, clear the screen, line feed, delete a character, control color, type of font, and so on. <br><br>  An ESC sequence, in general, is a sequence of bytes starting with an ESC character with a code of 27, followed by sequence codes consisting of a certain number of printed or non-typed characters.  For the vt100 terminal codes can be viewed for example <a href="http://ascii-table.com/ansi-escape-sequences-vt-100.php">here</a> .  Control codes are non-printable characters with codes from 0 to 31 (32 is the code of the first ascii-character - space). <br><br>  The program in the device (that part of it that is responsible for the command line), taking characters and sequences, forms in its command line buffer what the user enters and outputs this line back to the terminal (the local terminal echo should be turned off).  The device prints text and ESC-sequences to control the cursor, color, position of the cursor, as well as commands like "Delete text from the cursor to the end of the line."  In essence, this is the main task of the library - to form a string in memory and on the terminal screen, allow the user to edit it (delete arbitrary characters of the string, move through it, etc.) and, at the right time, give it to the higher-level interpreter. <br><br>  A good console should have a history of input, well, and, perhaps, more auto-add-ons, without which the terminal would not be so comfortable. <br><br><h4>  Internal organization </h4><br>  Consider the architecture of the application using the library: <br><br><img src="https://habrastorage.org/storage1/84a3a81f/b3353f4b/73c5bcac/6a56d118.png"><br>  The figure shows a block diagram of the interaction of the microrl and the user application.  Blue arrows indicate callback functions caused by the occurrence of events, a green arrow shows a library function call, in which, in fact, all the work takes place. <br><br>  Before using, you need to install 3 callbac-functions (blue): <br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> print (<span class="hljs-type"><span class="hljs-type">char</span></span> * str); //      <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> * argv[]); //     ENTER <span class="hljs-type"><span class="hljs-type">char</span></span> ** complete (<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> * argv[]); //     TAB</code> </pre> <br>  The <b>complete</b> function is optional, to save resources, you can disable auto-add-ons in the configuration file at all. <br><br><h5>  Input stream </h5><br>  The user application receives characters from the terminal (via the serial interface: UART, usb-cdc, tcp-socket, etc.) and sends them to the library by calling a function (green arrow): <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">microrl_insert_char</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch</span></span></span><span class="hljs-function">)</span></span>;</code> </pre>  ESC-sequences and control characters responsible for moving the cursor, pressing Tab, Enter, Backspace and so on ... are selected and processed from the input stream. The rest of the characters entered from the keyboard are placed into the command line buffer. <br><br><h5>  Execute </h5><br>  When the user presses Enter (in the input sequence, the code <b>0x10</b> or <b>0x13 is encountered</b> ), the command line buffer is sliced ‚Äã‚Äãinto "tokens" (words separated by spaces) and the <b>execute</b> function is called with the number of these words in <b>argc</b> and an array of pointers <b>argv</b> . <br><br>  The words in the <b>argv []</b> array are NULL-terminated, which means you can use ordinary string functions, so command processing is as simple and convenient as handling the parameters of the <b>main</b> function of the desktop application.  Many, if not all, are familiar with this technology, or you can easily find <a href="http://lord-n.narod.ru/download/books/walla/programming/Spr_po_C/06/0604.htm">information</a> . <br><br>  To save RAM, all entered spaces are replaced with the ' <b>\ 0</b> ' character, and when output to the terminal, they are replaced back with spaces.  Because of this, you can use a single buffer to enter and store the command line and process it, because it is enough to ‚Äúcollect‚Äù pointers to the tokens, and all of them will be automatically NULL-terminated. <br><br><img src="https://habrastorage.org/storage1/290cb23d/76eff518/01854741/be814cf1.png"><br><br>  Command processing is done by the library user in the <b>execute</b> function, in fact, this is the command interpreter, but do not be intimidated by this phrase: D, the usual if - else if - else is the simplest command interpreter: <br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/*    "help", "mem clear"  "mem dump"*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (argv[i], <span class="hljs-string"><span class="hljs-string">"mem"</span></span>)) { i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i &lt; argc) &amp;&amp; (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (argv[i], <span class="hljs-string"><span class="hljs-string">"dump"</span></span>))) { mem_dump (); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i &lt; argc) &amp;&amp; (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(argv[i], <span class="hljs-string"><span class="hljs-string">"clear"</span></span>))) { mem_clear(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\"mem\" needs argument {dump|clear}\n"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (argv[i], <span class="hljs-string"><span class="hljs-string">"help"</span></span>)) { print_help (); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"%s: cmd not found\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><h5>  Auto add-ons with Complete </h5><br>  When a user wants auto-addons, he presses Tab - this is a persistent habit for everyone who works with the console.  Here we do the same when the tabulation code is captured - again we cut the line with pointers to argv, but not for the entire line, but only for the section from the beginning to the cursor (do we usually add the word under the cursor?).  The same <b>int argc</b> and <b>char * argv []</b> are transferred to callback <b>complete</b> , and there is one trick: if the cursor is followed by a space, then we are starting a new word, i.e.  we do not, as it were, add anything concrete, in this case in the last element of argv [argc-1] there will be an empty string. <br>  Why do you need it?  In order for the auto-add-in callback-function to be clear which commands the user has already entered, and whether it complements something specific, or simply clicks Tab to view available commands.  As you can see, you have everything to make really "smart" add-ons, no worse than in adult consoles. <br><br>  <u><b>Important!!</b></u>  <u>The last element of the array must always be NULL!</u> <br>  If you return NULL in the very first element ([NULL]), this means that there are no add-on options. <br>  If there is one element in the array before NULL (["help"] [NULL]), then there is only one option for the add-on, it will be simply substituted in its entirety. <br>  If there are several elements in the array ([‚Äúclean‚Äù] [‚Äúclear‚Äù] [NULL]), then only the common part of the words will be added, if there is one, in general everything is as usual in bash: D! <br><br><h5>  Input history </h5><br>  If you have enough RAM, feel free to include in the config support for input history - improves the usability!  For saving, a ring buffer is used, so we cannot say how many last command lines we can remember, it depends on their length.  Search in history is carried out as usual, using up / down arrows or hotkeys Ctrl + n Ctrl + p (try bash!).  It works simply: the messages are copied to the buffer one by one, if there is no space, delete the old ones until it appears, then the line is copied into memory, and the pointer to the last message is moved after it.  When the end of the buffer is reached, we jump over 0 and so on in a circle. <br><br><h4>  Resources </h4><br>  All that is needed to implement the console in the application is a bit of memory and a serial two-way interface, you can use the UART (including through the USB-RS232 converter), usb-cdc, wireless <a href="http://habrahabr.ru/blogs/DIY/125214/">bluetooth serial</a> modules with Serial com-port profile, tcp sockets, etc. , everything that can connect a PC and a controller, and through what terminal emulators can work. <br><br>  As for memory, I collected everything with GCC with optimization of -0s for the Atmega8 (8-bit) controller (an example is in the source) and for the AT91SAM7S64 (16/32-bit) controller on the ARM7 core.  For comparison, I collected it in two versions: in trimmed - without auto-add-ons, without history of input and processing of cursor arrows and full, here is the result <br><pre> <code class="hljs objectivec"> ARM <span class="hljs-built_in"><span class="hljs-built_in">AVR</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br><br>  Notice how the 16/32 bit ARM kernel does the AVR! <br>  It must be said that the measurements were carried out only for the library itself, neither the USART processing (USB-CDC for ARM), nor the interpreter were taken into account, since  this is the shell. <br>  I can only say that the example in the source for the AVR takes about 6 KB of Flash (out of 8), but there is an ‚Äúall-inclusive‚Äù of the library's capabilities, you can hang out to 4. Obviously, for very small controllers (with 8 KB) this is already expensive, but the amount of memory in the controllers is growing by leaps and bounds, now you will not surprise anyone MK from ST or NXP with 128, 512Kb Flash. <br><br>  As for RAM, everything is simple, the library needs internal bytes ~ 30 for internal variables, plus a buffer for the command line - you define its length in the config, plus a buffer for the input history - set how much does not mean (but not more than 256 bytes in this implementation) . <br><br><h5>  Use options: </h5><br>  <b>Debugging software</b> .  You can debug logic and algorithms, emulating events from other devices / systems / protocols, change parameters, select empirical values. <br><pre> <code class="hljs swift">#   &gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> status state machine: receive #    &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> low_value <span class="hljs-number"><span class="hljs-number">23</span></span> #   &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> speed <span class="hljs-number"><span class="hljs-number">9200</span></span> &gt; send_msg <span class="hljs-number"><span class="hljs-number">23409823</span></span> #   &gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> <span class="hljs-built_in"><span class="hljs-built_in">dump</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">0x40</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x34</span></span> <span class="hljs-number"><span class="hljs-number">0x12</span></span> <span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-number"><span class="hljs-number">0xFF</span></span> #     &gt; rise_event alarm #   &gt; calc_crc16 <span class="hljs-number"><span class="hljs-number">0x92A1</span></span></code> </pre> <br><br>  <b>Device configuration</b>  Setting parameters through the CLI is easier than writing binary data: it does not require additional utilities, it does not require special interfaces.  It is performed on any PC with a terminal and a COM port (virtual through the adapter as well).  Users (many) themselves are able to use the CLI if necessary. <br><pre> <code class="hljs pgsql">#   &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> phone_0 <span class="hljs-number"><span class="hljs-number">8952920</span></span>xxxx &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> dial_delay <span class="hljs-number"><span class="hljs-number">150</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> alarm_level low &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> user_name Eugene &gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> temperature <span class="hljs-number"><span class="hljs-number">36</span></span> &gt; print config <span class="hljs-number"><span class="hljs-number">0</span></span> phone: <span class="hljs-number"><span class="hljs-number">8952920</span></span>xxxx dial delay: <span class="hljs-number"><span class="hljs-number">150</span></span> ms alarm <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>: low <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>: Eugene temperature: <span class="hljs-number"><span class="hljs-number">36</span></span></code> </pre><br><br>  <b>Monitoring</b>  Upon request, you can print any data of any subsystem, buffers or counters. <br><pre> <code class="hljs swift">#     <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   &gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> <span class="hljs-type"><span class="hljs-type">ADC_val</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">121</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> #    &gt; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> operation_count <span class="hljs-number"><span class="hljs-number">87</span></span> #   &gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> stat statistics: counted <span class="hljs-number"><span class="hljs-number">299</span></span> pulse, smaller <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> ms, longer <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">119</span></span> ms</code> </pre> <br><br>  <b>Interactive device management</b> .  Turn on the relay, turn your head 30 degrees, turn on the camera, take a step to the left.  Using the bluetooth serial modules, you can steer the mobile robot through the console!  I think the idea is clear. <br><br>  <b>Additionally,</b> you can organize the authorization with a password or one-time / N-time access. <br>  And of course, pseudo graphics in the terminal!  Game console in the literal sense of the word "console"!  : D <br><br>  As you can see, sometimes such an interface can really be very relevant, not necessarily basic, but debugging, configuration, or duplicating. <br><br><h4>  Lyrical digression </h4><br><img src="http://habrastorage.org/storage1/fa5131b2/8b66a933/ba69ef3d/a48345a8.png"><br><br>  The idea to write a library was born when I was doing a USB <a href="http://helius.github.com/IRin/index_ru.html">IRin</a> IR receiver, as a replacement for lirc with its complex infrastructure.  My USB dongle is defined without special drivers in the system as <b>/ dev / ACM0</b> , which is essentially a virtual com port.  When I press the remote control button, the dongle sends the Ascii a string like " <b>NEC 23442</b> " - the code of the pressed button to the port.  Button handling is very simple, a regular bash script that reads / dev / ACM0 with a large switch based on button codes. <br>  Fine!  what else is needed?  Simple, convenient, no complicated configs, no lirc.  But somehow I wanted to see the line " <b>VOLUME_UP</b> " come from the port instead of " <b>NEC D12C0A</b> " ... But how to set matches, if there is only one button on the device, and then it is not used yet?  Very simple!  Open the virtual com-port " <b>/ dev / ACM0</b> " through the minicom terminal emulator <br><pre> <code class="hljs perl">$minicom -D /dev/ACM<span class="hljs-number"><span class="hljs-number">0</span></span> -b <span class="hljs-number"><span class="hljs-number">115200</span></span></code> </pre>  and get a console!  Next, enter the command: <br><pre> <code class="hljs 1c">&gt; set_name VOLUME_UP <span class="hljs-meta"><span class="hljs-meta">#  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">    .</span></span></code> </pre> <br>  Button aliases are saved in the AT24C16 2KB EEPROM.  In addition, there is a parameter such as the speed of re-pressing when you hold down the button on the remote.  It can be installed with the command: <br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; repeat_speed 500</span></span></code> </pre> <br>  You can still do <pre> <code class="hljs 1c">&gt; eeprom print <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-meta"><span class="hljs-meta">#  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">      1 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> 60</span></span></code> </pre> <br>  well, fun team <pre> <code class="hljs perl">&gt; eeprom <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> <span class="hljs-comment"><span class="hljs-comment">#     </span></span></code> </pre> <br><br><h4>  Conclusion </h4><br>  In the near future I will make a library for the Arduino SDK. <br>  For examples, see the source, there is an example for unix * and for AVR.  For AVR, you can simply download the hex file, flash it and try it!  The application allows you to enable / disable the I / O port ports PORTB and PORTD. <br><br>  I hope it was interesting: D <br>  <b>Thanks for attention!</b> <br><br>  Link to github <a href="https://github.com/Helius/microrl">github.com/Helius/microrl</a> </div><p>Source: <a href="https://habr.com/ru/post/127890/">https://habr.com/ru/post/127890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127881/index.html">Damage to the optical highway in Germany</a></li>
<li><a href="../127886/index.html">Adobe Flash 11 and AIR 3 Release Candidate</a></li>
<li><a href="../127887/index.html">Interview with Linus Torvalds</a></li>
<li><a href="../127888/index.html">Bash RSS parser for LostFilm.TV: Transmission + SQLite + mkvtools</a></li>
<li><a href="../127889/index.html">Tuning and optimizing Ubuntu after installation</a></li>
<li><a href="../127892/index.html">A way to connect different computers to the same network</a></li>
<li><a href="../127893/index.html">Work with electronic money</a></li>
<li><a href="../127894/index.html">Announced next key speakers Tech Tech Ed Russia 2011</a></li>
<li><a href="../127895/index.html">2GIS expands the search capabilities in the desktop version</a></li>
<li><a href="../127896/index.html">Android: Evolution of the manufacturer of robots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>