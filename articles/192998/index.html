<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Responsive Android application or 1001 ways to upload a picture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Much has already been written about the implementation of multithreading in the development of Android applications. In the same article, I would like...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Responsive Android application or 1001 ways to upload a picture</h1><div class="post__text post__text-html js-mediator-article">  Much has already been written about the implementation of multithreading in the development of Android applications.  In the same article, I would like to make a comparison of several ways to download / read / save / calculate common today, while not giving the user a reason for irritation.  Try to understand when this or that decision will be appropriate, and what better not to do at all.  Let's try to show why the usual things, such as the Thread class and the java.util.concurrent package, are not enough when it comes to an Android application. <br><br><a name="habracut"></a>  The article does not have a task to highlight all the details of the implementation of each approach, but it is impossible to compare them without telling the basics.  And therefore ... <br><br><h5>  Thread </h5><br>  The class Thread migrated from Java to the Android API is probably the easiest way to launch a new thread.  Here are a couple of examples of how this is done: you can create a heir from Thread or pass into an instance of the Thread class an object that implements the Runnable interface. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Example 1. Expansion Thread.</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkingThread</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><br></div></div><br><br><br><div class="spoiler">  <b class="spoiler_title">Example 2. Runnable.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkingClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  } } WorkingClass workingClass = new WorkingClass(); Thread thread = new Thread(workingClass); thread.start();</span></span></code> </pre><br></div></div><br>  As a rule, after performing the required operations there is a need to provide the result to the user.  But you can't just take and access UI elements from another thread.  By virtue of the Android multithreading model, changing the state of interface elements is allowed only from the stream in which these elements were created, otherwise a CalledFromWrongThreadException will be thrown.  In this case, the Android API provides several solutions at once. <br><br><div class="spoiler">  <b class="spoiler_title">Example 1. View # post (Runnable action).</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ TextView textView; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.hello); WorkingClass workingClass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WorkingClass(); Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(workingClass); thread.start(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkingClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  //  UI   Runnable textView.post(new Runnable() { @Override public void run() { textView.setText("The job is done!"); } }); } } }</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Example 2. Activity # runOnUiThread (Runnable action).</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ TextView textView; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.hello); WorkingClass workingClass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WorkingClass(); Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(workingClass); thread.start(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkingClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  //  UI   Runnable MainActivity.this.runOnUiThread(new Runnable() { @Override public void run() { textView.setText("The job is done!"); } }); } } }</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Example 3. Handler.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ TextView textView; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.hello); WorkingClass workingClass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WorkingClass(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(workingClass); thread.start(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkingClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SUCCESS = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FAIL = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> dummyResult; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkingClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dummyResult)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dummyResult = dummyResult; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  //    if (dummyResult){ //      uiHandler.sendEmptyMessage(SUCCESS); } else { //       Message msg = Message.obtain(); msg.what = FAIL; msg.obj = "An error occurred"; uiHandler.sendMessage(msg); } } } Handler uiHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { switch (msg.what) { case WorkingClass.SUCCESS: textView.setText("Success"); return true; case WorkingClass.FAIL: textView.setText((String)msg.obj); return true; } return false; } }); }</span></span></code> </pre><br></div></div><br>  In general, simple, but when it comes to active interaction with interface elements, the code can turn into a jumble of Runnable interfaces or a considerable size Handler class.  To simplify the work of synchronizing the main and background threads, the AsyncTask class was already proposed in Android 1.5 <br><br><h6>  AsyncTask </h6><br>  To use AsyncTask, you need to create its descendant class with parameterized types and override the necessary methods.  After launch, AsyncTask will call its methods in the following order: onPreExecute (), doInBackground (Params ...), onPostExecute (Result), the first and the last of them will be called in the UI thread, and the second one, as is easy to guess, in a separate one.  Moreover, the AsyncTask class allows the background process to inform the UI thread about its progress using the publishProgress (Progress ...) method, which in turn will call onProgressUpdate (Progress ...) in the UI thread. <br><br><div class="spoiler">  <b class="spoiler_title">AsyncTask example</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String IMAGE_URL = <span class="hljs-string"><span class="hljs-string">"http://eastbancgroup.com/images/ebtLogo.gif"</span></span>; TextView textView; ImageView imageView; ProgressDialog progressDialog; DownloadTask downloadTask; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.hello); imageView = (ImageView)findViewById(R.id.imageView); downloadTask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DownloadTask(); <span class="hljs-comment"><span class="hljs-comment">// ,      downloadTask.execute(IMAGE_URL); } @Override protected void onStop() { //   , //  Activity downloadTask.cancel(true); super.onStop(); } /* *    AsyncTask&lt;Params, Progress, Result&gt; *  ,     generic-. * Params -   .     String, .. *   url  * Progress -  ,      . *    Integer. * Result -  .    Drawable. */ class DownloadTask extends AsyncTask&lt;String, Integer, Drawable&gt;{ @Override protected void onPreExecute() { //    progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setIndeterminate(false); progressDialog.setMax(100); progressDialog.setProgress(0); progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); progressDialog.setMessage("Downloading Image"); progressDialog.show(); } @Override protected Drawable doInBackground(String... params) { //       //  URLConnection int count; try { URL url = new URL(params[0]); URLConnection conection = url.openConnection(); conection.connect(); int lenghtOfFile = conection.getContentLength(); InputStream input = new BufferedInputStream(url.openStream(), 8192); OutputStream output = new FileOutputStream("/sdcard/downloadedfile.jpg"); byte data[] = new byte[256]; long total = 0; while ((count = input.read(data)) != -1) { //,     if (isCancelled()){ return null; } total += count; output.write(data, 0, count); //  . // ,     //       //onProgressUpdate    publishProgress((int)((total*100)/lenghtOfFile)); } output.flush(); output.close(); input.close(); } catch (Exception e) { Log.e("Error: ", e.getMessage()); } String imagePath = Environment.getExternalStorageDirectory().toString() + "/downloadedfile.jpg"; return Drawable.createFromPath(imagePath); } @Override protected void onProgressUpdate(Integer... progress) { progressDialog.setProgress(progress[0]); } //     @Override protected void onPostExecute(Drawable result) { imageView.setImageDrawable(result); progressDialog.dismiss(); } //     onPostExecute, //      //AsyncTask#cancel(boolean mayInterruptIfRunning) @Override protected void onCancelled() { } } }</span></span></code> </pre><br></div></div><br><br>  This example of loading a picture shows all the possibilities provided by the AsyncTask class: preparation, background operations, progress update, final actions, and work stoppage.  And at each of these stages, the developer does not need to worry about synchronization of the background thread and the main one. <br><br>  Although AsyncTask is often easier to create threads with the Thread class, there are cases in which the first way to implement multithreading will be more advantageous.  Here are important, in our opinion, differences, taking into account which can help when choosing how to implement multithreading: <br><ul><li>  Using AsyncTask, it is impossible to set the priority of a new thread, as it could be done with the Thread # setPriority (int priority) <a href="https://developer.android.com/reference/java/lang/Thread.html">https://developer.android.com/reference/java/lang/Thread.html#setPriority(int)</a> method </li><li>  Starting with Android, HONEYCOMB defaults to <b>only one thread</b> for all background operations of AsyncTask instance operations. </li></ul><br>  The second point is especially important.  The fact is that because of this model of work of tasks on their basis, it is impossible to make a long-lived background process (such as a timer).  Such an AsyncTask instance will block the queue and prevent any subsequent tasks from running.  But using a bunch of Thread and Handler, on the contrary, it is enough just to achieve the execution of the code at intervals. <br><br><div class="spoiler">  <b class="spoiler_title">Timer example.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ TextView textView; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; textView = (TextView)findViewById(R.id.hello); <span class="hljs-comment"><span class="hljs-comment">//  new Thread(new WorkingClass()).start(); } class WorkingClass implements Runnable{ public static final int RELAUNCH = 1; private static final int DELAY = 1000; @Override public void run() { //  //      1000ms uiHandler.sendEmptyMessageDelayed(RELAUNCH, DELAY); } } Handler uiHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { //  if (msg.what == WorkingClass.RELAUNCH){ textView.setText("Times: "+counter); counter++; new Thread(new WorkingClass()).start(); return true; } return false; } }); }</span></span></code> </pre><br></div></div><br>  <i>Note: in fact, you can run several AsyncTask in parallel, using the AsyncTask # executeOnExecutor method (Executor exec, Params ... params) <a href="https://developer.android.com/reference/android/os/AsyncTask.html">https://developer.android.com/reference/android/os/AsyncTask.html</a> if you really need it .</i> <br><br>  In previous examples, both Thread and AsyncTask are used in the context of some Activity.  In most cases, this is normal, but such a model can bring certain problems.  It is necessary to understand that those working, although in the background, AsyncTask or Thread will not allow the garbage collector to delete an instance of our Activity when it is no longer needed.  And it can happen very simply, for example, when turning the screen of the device.  Each time the screen orientation changes, a new Activity will be created, and each time AsyncTask will be called.  The larger the size of the loaded image, the faster the application closes with an <a href="https://developer.android.com/reference/java/lang/OutOfMemoryError.html">OutOfMemoryError</a> error.  Worse than such an example can be, perhaps, the use of anonymous classes, as it is shown in many educational articles.  By not keeping a link to a new task or flow, you are depriving yourself of the ability to control the progress of the process, for example, to stop it when you close the same Activity. <br><br><h5>  Total: </h5><br>  From the comparison of the Thread and AsyncTask classes, several conclusions can be drawn. <br>  Tasks for which the use of Thread is justified: <br><ul><li>  Operations requiring installation priority of execution.  Operations actively consuming CPU resources. </li><li>  Performing an operation many times, at any time interval. </li><li>  Parallel execution of multiple background threads. </li></ul><br>  Tasks for which the use of AsyncTask is justified: <br><ul><li>  Operations that are expected to take no more than a few seconds.  Download a small amount of data, simple file system operations. </li><li>  Active management of interface elements from background threads. </li></ul><br>  The main condition imposed on work with Thread and AsyncTask: if the work was launched in the context of Activity / Fragment, then it should end as soon as possible, after stopping Activity / Fragment. <br><br><h5>  Loaders </h5><br>  There are types of data operations that, although it is possible to execute in the main application thread, can significantly slow down the interface or even trigger an <a href="https://developer.android.com/training/articles/perf-anr.html">ANR message</a> .  An illustrative example of such an operation is reading from a database / files.  Until recently, a good practice of working with the database was to use the already reviewed Thread and AsyncTask, but in Android 3.0 classes such as Loader and LoaderManager were added, the purpose of which is to simplify asynchronous data loading into Activity or Fragment.  For older versions of platforms, the same classes are available in the <a href="https://developer.android.com/tools/support-library/index.html">android support library</a> . <br><br>  The principle of working with Loaders is: <br><br>  1. You need to create your own class that extends the Loader class or one of its standard heirs. <br>  2. Implement loading generic-type D data in it <br>  3. In Activity, get a link to LoaderManager and initialize your Loader, passing it and callback LoaderManager.LoaderCallbacks to the manager. <br><br>  We give an example of how using the standard CursorLoader class you can display a list of phone contacts. <br><br><div class="spoiler">  <b class="spoiler_title">Loader example.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoaderCallbacks</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cursor</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] { Contacts._ID, Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS, }; private static final int LOADER_ID = 1; private SimpleCursorAdapter adapter; TextView textview; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //,      textview = (TextView)findViewById(R.id.loading); //  ,     getListView().setVisibility(View.GONE); //  ListView adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, null, new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS }, new int[] { android.R.id.text1, android.R.id.text2 }, 0); setListAdapter(adapter); // Loader' //  id Loader'  callback LoaderManager lm = getLoaderManager(); lm.initLoader(LOADER_ID, null, this); } //    Loader,   //      @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { Uri baseUri = Contacts.CONTENT_URI; String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND (" + Contacts.HAS_PHONE_NUMBER + "=1) AND (" + Contacts.DISPLAY_NAME + " != '' ))"; return new CursorLoader(this, baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC"); } //  ,     //  ,      @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor cursor) { switch (loader.getId()) { case LOADER_ID: adapter.swapCursor(cursor); textview.setVisibility(View.GONE); getListView().setVisibility(View.VISIBLE); break; } } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { adapter.swapCursor(null); } }</span></span></code> </pre><br></div></div><br>  Do not forget to specify the appropriate permission to read contacts in the application manifest. <br><br><h5>  Total: </h5><br>  The use of the Loaders template is closely related to the application components responsible for the mapping (Activity, Fragment) and therefore the execution time for data loading operations must be comparable to the lifetime of these components. <br><br><h5>  Service and IntentService </h5><br>  Service is one of the components of the Android application.  The service itself is not a separate process or a separate thread.  However, the service has its own life cycle, and it is just suitable for performing time-consuming operations in it.  Additional threads running in the service context can run without interfering with user navigation through the application.  For communication between the service and other components of the application, there are usually two methods used: ServiceConnection / IBinder interfaces or broadcast messages.  The essence of the first method is to get a link to the running instance of the service.  This is not to say that such a method somehow solves the problems of multitasking, it is rather suitable for managing the service.  Communication with broadcast messages is thread-safe and will therefore be considered in the example. <br><br><div class="spoiler">  <b class="spoiler_title">Sample service.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BackgroundService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CHANNEL = BackgroundService.class.getSimpleName()+<span class="hljs-string"><span class="hljs-string">".broadcast"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     , //     Intent @Override public int onStartCommand(Intent intent, int flags, int startId) { //        sendResult(); return Service.START_NOT_STICKY; } //     , // Broadcast private void sendResult() { Intent intent = new Intent(CHANNEL); sendBroadcast(intent); } @Override public IBinder onBind(Intent intent) { return null; } }</span></span></code> </pre><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ TextView textView; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.hello); <span class="hljs-comment"><span class="hljs-comment">//     registerReceiver(receiver, new IntentFilter(BackgroundService.CHANNEL)); // ,    Intent Intent intent = new Intent(this, BackgroundService.class); startService(intent); } @Override protected void onStop() { //    unregisterReceiver(receiver); super.onStop(); } private BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { textView.setText("Message from Service"); } }; }</span></span></code> </pre><br></div></div><br>  Do not forget that the service, as well as Activity, must be declared in the project manifest. <br><br>  In addition, the Android API provides the IntentService class, which extends the standard Service, but performs the processing of the data passed to it in a separate stream.  When a new request is received, IntentService will create a new stream and call the IntentService # onHandleIntent (Intent intent) method <a href="https://developer.android.com/reference/android/app/IntentService.html">https://developer.android.com/reference/android/app/IntentService.html#onHandleIntent(android.content.Intent) in it</a> , which you just have to override.  If upon receipt of a new request, the processing of the previous one has not yet ended, it will be queued. <br><br><div class="spoiler">  <b class="spoiler_title">Example IntentService.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DownloadService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"DownloadService"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CHANNEL = DownloadService.class.getSimpleName()+<span class="hljs-string"><span class="hljs-string">".broadcast"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(CHANNEL); sendBroadcast(intent); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IBinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//        @Override protected void onHandleIntent(Intent intent) { //  //     sendResult(); } }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ TextView textView; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.hello); <span class="hljs-comment"><span class="hljs-comment">//     registerReceiver(receiver, new IntentFilter(DownloadService.CHANNEL)); // ,    Intent Intent intent = new Intent(this, DownloadService.class); startService(intent); } @Override protected void onStop() { //    unregisterReceiver(receiver); super.onStop(); } private BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { textView.setText("Message from Service"); } }; }</span></span></code> </pre><br></div></div><br><br><h5>  Total: </h5><br>  The life cycle of services is usually longer than an Activity.  Having started once, the service will be alive until it has completed its work, after which it will stop on its own.  The developer basically needs only to organize the desired processing of incoming messages (intents): compare, construct a queue, etc., and send messages about the completion of each operation. <br>  As you can see from the examples, it does not matter where the broadcast message will be sent from, the main thing is that it will be received in the main stream. <br><br>  DownloadManager <br>  Starting with the Android API version 9, the task of downloading and saving files over the network becomes even easier, thanks to the DowloadManager system service.  All that remains to be done is to transfer this service to Uri, if you wish, specify the text that will be shown in the notification area during and after the download and subscribe to events that DownloadManager can send. This service will be set up to connect, respond to errors, resuming downloads, creating notifications in the Notification bar and, of course, downloading files in the background stream. <br><br><h5>  DownloadManager example. </h5><br><div class="spoiler">  <b class="spoiler_title">DownloadManager Example</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String IMAGE_URL = <span class="hljs-string"><span class="hljs-string">"http://eastbancgroup.com/images/ebtLogo.gif"</span></span>; ImageView imageView; DownloadManager downloadManager; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = (ImageView)findViewById(R.id.imageView); <span class="hljs-comment"><span class="hljs-comment">//   DownloadManager  downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); //   Request request = new Request(Uri.parse(IMAGE_URL)); request.setTitle("Title"); //   request.setDescription("My description"); //   request.setMimeType("application/my-mime"); //mine type   //  ,  , //-      request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); //    downloadManager.enqueue(request); } @Override protected void onResume() { super.onResume(); //     registerReceiver(receiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)); registerReceiver(receiver, new IntentFilter(DownloadManager.ACTION_NOTIFICATION_CLICKED)); }; @Override protected void onPause() { super.onPause(); //    unregisterReceiver(receiver); }; BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); //  ,    if (DownloadManager.ACTION_DOWNLOAD_COMPLETE.equals(action)){ long downloadId = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, 0); DownloadManager dm = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); DownloadManager.Query query = new DownloadManager.Query(); query.setFilterById(downloadId); Cursor cursor = dm.query(query); if (cursor.moveToFirst()){ int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS); if (DownloadManager.STATUS_SUCCESSFUL == cursor.getInt(columnIndex)) { String uriString = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)); imageView.setImageURI(Uri.parse(uriString)); } } //     } else if (DownloadManager.ACTION_NOTIFICATION_CLICKED.equals(action)){ DownloadManager dm = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); //        , //       ,   //  long[] ids = intent.getLongArrayExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS); DownloadManager.Query query = new DownloadManager.Query(); query.setFilterById(ids); Cursor cursor = dm.query(query); int idIndex = cursor.getColumnIndex(DownloadManager.COLUMN_ID); if (cursor.moveToFirst()){ do { //    id   //   long downloadId = cursor.getLong(idIndex); } while (cursor.moveToNext()); } } } }; }</span></span></code> </pre><br></div></div><br>  DownloadManager has one feature.  The fact is that when you click on a notification that a file has been successfully downloaded, contrary to expectations, a broadcast message like DownloadManager.ACTION_NOTIFICATION_CLICKED will not be sent.  But instead, the service will try to find an Activity that can handle this click.  So, if you want to react to this event, then add a new intent filter of the following content to the desired activity in the project manifest: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.VIEW"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:mimeType</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"application/my-mime"</span></span></span><span class="hljs-tag"> /&gt;</span></span> (mime type,   ) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  In this case, when you click on the notification, your activity will be launched, to which the Intent with the download identifier will already be transferred.  You can get it, for example, like this: <br><br>  Intent intent = getIntent (); <br>  String data = intent.getDataString (); <br><br><h5>  Total: </h5><br>  DownloadManager service is convenient to use for downloading large files that may be of interest to the user separately from your application, for example, images, media files, archives and much more.  Keep in mind that other applications can also access files uploaded by you. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It‚Äôs not to say that we covered all the patterns of the implementation of the background work of the android-application, but with a high degree of confidence we can say that the considered methods are widely distributed. </font><font style="vertical-align: inherit;">We hope this article will help you design the background-work most correctly and conveniently.</font></font></div><p>Source: <a href="https://habr.com/ru/post/192998/">https://habr.com/ru/post/192998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../192984/index.html">Horizontal scaling of a real project database using SQL Azure Federations</a></li>
<li><a href="../192986/index.html">Update windows 8.1 in RTM and to any "side", with any language and version</a></li>
<li><a href="../192990/index.html">Another "Boilers 2.0", an option with KickStarter`a</a></li>
<li><a href="../192994/index.html">Installing Os X Mountain Lion 10.8.3 on ESXi</a></li>
<li><a href="../192996/index.html">We go for mushrooms after Cppcheck</a></li>
<li><a href="../193000/index.html">Artificial Intelligence and Why My Computer Doesn't Understand Me?</a></li>
<li><a href="../193004/index.html">Alternative .sortable - a new solution for sorting the list on jQuery</a></li>
<li><a href="../193008/index.html">Happy Tester!</a></li>
<li><a href="../193016/index.html">New cloud storage feature: creating links to download files</a></li>
<li><a href="../193018/index.html">Why is the majority not always right?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>