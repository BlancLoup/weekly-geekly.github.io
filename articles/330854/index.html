<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize memory usage in Xamarin applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of the article by Samuel Debruyn . I liked the article so much that a spontaneous desire appeared to share with the habr communi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize memory usage in Xamarin applications</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  This is a translation of the <a href="https://www.chipsncookies.com/2017/optimize-memory-usage-in-xamarin-apps/">article</a> by <a href="https://twitter.com/samueldebruyn">Samuel Debruyn</a> .  I liked the article so much that a spontaneous desire appeared to share with the habr community :) </blockquote><p>  Xamarin is amazing because it allows .NET developers to write applications for Android, iOS, macOS on ... C #.  But this amazing opportunity has its price, and even the simplest application can easily consume an indecent amount of memory.  Let's see how this happens and what we can do with it.  Most of my examples are based on Xamarin.Android, but you will quickly notice that this also applies to Xamarin.iOS. </p><br><h3 id="kak-rabotaet-sborschik-musora-v-xamarin-prilozheniyah">  How does garbage collector work in Xamarin applications </h3><br><p>  In fact, Xamarin applications use several types of objects.  Each Xamarin application has objects that live in two separate worlds: </p><br><ul><li> Managed, Mono world with objects inherited from <code>System.Object</code> </li><li>  Unmanaged, native world with objects inherited from <code>NSObject</code> (iOS) or <code>Java.Lang.Object</code> (Android) </li></ul><br><p>  From this it also follows that 2 garbage collectors exist and operate: </p><br><ul><li>  Mono's garbage collector, called SGEN </li><li>  Garbage collectors from the native worlds of Android or iOS </li></ul><br><p><a name="habracut"></a>  Let's first consider SGEN.  In fact, <a href="https://university.xamarin.com/classes/track/csharp">Xamarin University</a> has some very interesting lectures on this topic, and official <a href="https://developer.xamarin.com/guides/android/advanced_topics/garbage_collection/">documentation</a> explains this very well. </p><br><p>  I will not go into the details of how SGEN works.  Leave this topic for my next post.  All we need to know now is that we can try to call the full garbage collection with the <code>GC.Collect()</code> command, as well as garbage collection for zero-generation (freshest) <code>CG.Collect(0)</code> with the <code>CG.Collect(0)</code> command.  Most of the remaining commands are not implemented in Mono at the time of this writing.  Alternatively, you can use the snapshot function in the Xamarin Profiler to speed up garbage collection. </p><br><p>  Completing garbage collection with SGEN also starts garbage collection in a different, native world. </p><br><h3 id="peer-obekty">  Peer objects </h3><br><p>  Did I mention two types of objects in Xamarin?  Yes and no.  All our objects live in each of two worlds, but in fact we use the third type of objects: </p><br><ul><li>  Managed Objects (Mono World) </li><li>  Unmanaged objects (native world) </li><li>  Peer objects (Mono world, bridging objects between the controlled and the uncontrolled worlds) </li></ul><br><p>  Next, we can divide the peer objects into two categories: </p><br><ul><li>  Framework peers: instances of classes that are part of Xamarin.Android or Xamarin.iOS SDKs </li><li>  User peers: instances of classes that you yourself create and that are inherited from native objects </li></ul><br><p>  So, as a Xamarin developer, you have the right to create managed objects or user peers. </p><br><p>  A few examples: </p><br><ul><li>  Framework peers: <em>android.content.Context, UIViewController ...</em> </li><li>  User peers: <em>MyCustomActivity, MyCustomViewHolder, MyCustomViewController ...</em> </li></ul><br><p>  What is the difference between them?  Let's take a look at this from the Android side (similarly for iOS). </p><br><p>  Framework peer is often called Managed Callable Wrapper (MCW).  This name tells us that: </p><br><ul><li>  Managed Callable: an object exists, and it is called from the Mono world. </li><li>  Wrapper: this is a wrapper over a native Android object in a Mono object </li></ul><br><p>  If you were engaged in the creation of Android binding projects in Xamarin / Visual Studio, then know that you created MCW.  Under the hood, Xamarin generates code that calls native methods from the Android world.  To achieve this, they use the JNI (Java Native Interface).  If you want to call a method that exists in the Android world, but for which you have not yet done a wrapper in Xamarin, you can use JNI to call this method. </p><br><p>  User peer is often called Android Callable Wrapper (ACW).  In turn, this name tells us that: </p><br><ul><li>  Android callable: the object exists and it is called from the Android world </li><li>  Wrapper: this is nothing more than a wrapper capable of invoking native methods from the Mono world. </li></ul><br><p>  So, in fact, we can say that each peer object actually consists of two objects living in memory: a real (native or Mono) and a wrapper object. </p><br><p>  This structure allows Xamarin to work on completely different platforms and this is why Xamarin is so cool.  All this allows Xamarin developers to write applications quite simply, but the lack of understanding of how this works is often a source of memory problems in Xamarin applications. </p><br><h3 id="vnimanie-klassicheskiy-primer-s-bitmap">  Attention!  Classic Bitmap Example </h3><br><p>  The most common "big" objects in Xamarin applications are bitmaps (pictures).  Almost every application contains at least a few pictures in order to look more attractive.  But this one has its price, these pictures are most often the largest objects in the memory of your application. </p><br><p>  However, if you allow the android to load a bitmap and see how much it weighs in memory in any way convenient for you, you will most likely notice that the size will be insignificant.  Even a 5 MB picture will occupy several bytes. </p><br><p>  How is this possible?  Where are the 5 MB?  For the world of Mono, this picture is nothing more than a wrapper for a native object.  This native object takes 5 MB in memory. </p><br><p>  Well, let's say, but how can this be a source of any problems and how does this generally relate to the topic of a post?  Let's take a look at the Activity code below: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Activity(Label = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"App1"</span></span></span><span class="hljs-meta">, MainLauncher = true, Icon = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"@drawable/icon"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainActivity</span></span> : <span class="hljs-title"><span class="hljs-title">Activity</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bundle bundle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnCreate(bundle); SetContentView(Resource.Layout.Main); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hugeBitmap = Android.Graphics.BitmapFactory.DecodeFile(<span class="hljs-string"><span class="hljs-string">$"path/to/bitmaps/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i}</span></span></span><span class="hljs-string">.png"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ImageContainsUnicorn(hugeBitmap)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageView = FindViewById&lt;ImageView&gt;(Resource.Id.SomeImageView); imageView.SetImageBitmap(hugeBitmap); } } }</code> </pre> <br><p>  This code loads 100 bitmaps and checks whether the image contains a unicorn, if so, it displays it in an ImageView.  We use only one bitmap at the end, so there shouldn't be any memory problems, because as soon as the selected bitmaps go out of sight, they will be collected by the garbage collector, right? </p><br><p>  Wrong.  The application will <code>OutOfMemoryException</code> in a few milliseconds due to an <code>OutOfMemoryException</code> .  In order to understand why this is happening, let's see how Xamarin works in this situation. </p><br><p>  The hugeBitmap variable is MCW, and the size of this object in Mono will be negligible.  The code above should not normally run garbage collection (in the Mono world). </p><br><p>  On the other hand, the android will go crazy, and the garbage collector will work at a crazy pace.  However, he will not be able to find the objects to be assembled.  The garbage collector cannot collect bitmaps, because they will still refer to wrapper objects in the controlled (Mono) world.  Until the managed wrapper objects are collected by SGEN, the native garbage collector cannot do anything.  As a result, in the native world, your application will catch an <code>OutOfMemoryException</code> . </p><br><h3 id="chto-my-mozhem-sdelat">  What we can do? </h3><br><p>  Each peer object implements an IDisposable interface.  Let's quickly see how this is implemented: </p><br><ul><li>  <a href="">NSObject in Foundation</a> </li><li>  <a href="">Object in Java.Lang</a> </li></ul><br><p>  <em>I note that the implementation above for Xamarin.Android is no longer used in the latest version because they switched to using Java.Interop.</em>  <em>Although the implementation of this in itself is completely different, the way of working is very similar to the old way.</em> </p><br><p>  As we see, the call to <code>Dispose()</code> breaks the bridge between the wrapper object and the object being wrapped (native).  This removes the links and after disposing of the wrapper object, the native object can be collected by the garbage collector, of course, if this object does not have any references in the native world. </p><br><blockquote>  Wonderful!  So I just need to always call <code>Dispose()</code> on all objects? </blockquote><p>  Almost, but not quite.  In fact, we can improve the code above using the using construct.  As we know, using immediately calls <code>Dispose()</code> after the end of the using block.  In 99% of cases, it is committed to properly dispose of the framework peers immediately after calling the method / property you need.  A native object will continue to live as long as it is needed and you do not break anything except a link to this object. </p><br><p>  An enhanced version of the code above would look like this: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bundle bundle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnCreate(bundle); SetContentView(Resource.Layout.Main); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hugeBitmap = Android.Graphics.BitmapFactory.DecodeFile(<span class="hljs-string"><span class="hljs-string">$"path/to/bitmaps/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i}</span></span></span><span class="hljs-string">.png"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ImageContainsUnicorn(hugeBitmap)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageView = FindViewById&lt;ImageView&gt;(Resource.Id.SomeImageView)) { imageView.SetImageBitmap(hugeBitmap); } } } }</code> </pre> <br><p>  However, if you need to use the ImageView in another method, for example, in <code>OnResume()</code> , the best place to dispose of the ImageView might be <code>OnDestroy()</code> or <code>Dispose()</code> itself.  You can argue and say that you can simply call <code>FindViewById()</code> as many times as necessary, but this is a very expensive operation and should be avoided.  I usually use this method at the very end of the object's life cycle, or I override the <code>Dispose()</code> method.  This is not something you have to do, but it would certainly help reduce memory usage in your application. </p><br><h3 id="nebolshaya-zametka-o-sobytiyah">  A brief note about the events </h3><br><p>  You probably already guessed that everything described above applies to events.  Never forget to unsubscribe from your events in the last method of the life cycle of an activity, view controller, etc.  or SGEN will never collect your object.  If your object has a link to peer objects, then these peer objects will live forever. </p><br><h3 id="pochemu-stoit-izbegat-vyzova-dispose-u-user-peer-obektov">  Why you should avoid calling Dispose () on user peer objects </h3><br><p>  When the time comes, be sure Xamarin will call <code>Dispose()</code> for any user peer object.  But for us, application developers, it is not so easy to understand when this time should come.  In general, the documentation tells us that you should never call <code>Dispose()</code> manually for user peer objects.  Just make sure that nothing refers to the object and then the framework will do the work for you. </p><br><h4 id="konstruktor-s-intptr-i-jnihandleownership">  Constructor with IntPtr and JNIHandleOwnership </h4><br><p>  If you called <code>Dispose()</code> user peer of the object manually, and the Android OS needs this object, Mono will call the constructor shown below: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr javaRef, JniHandleOwnership transfer</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">javaRef, transfer</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><p>  A similar constructor is in Xamarin.iOS only without JNIHandleOwnership.  In this case, Mono tries to re-create the disappeared object. </p><br><p>  If such a constructor is not implemented, your application will instantly <code>NotSupportedException</code> with a <code>NotSupportedException</code> .  If Google decides to change the life cycle of an object and you call <code>Dispose()</code> before the end of this cycle, the application will also crash. </p><br><h3 id="kak-weakreference-mogut-vam-pomoch">  How WeakReference can help you </h3><br><p>  Use WeakReference instead of normal (strong) links in order to avoid placing a reference to native objects.  It is a bit costly in searching these objects, but the native garbage collector can collect these objects at any time.  Therefore, choose the type of links carefully!  Bitmaps that cannot instantly disappear may be good candidates for weak links, but for small objects like UILabel this does not matter much. </p><br><h3 id="chto-na-schet-xamarinforms">  What about Xamarin.Forms? </h3><br><p>  Each element from Xamarin.Forms has its own render on mobile platforms, either custom or supplied as part of the NuGet package.  These renders are user peers and are treated as such.  Here is <a href="">an example</a> of how <code>Dispose()</code> implemented in the built-in Android renderer.  I would recommend sticking to a similar template when implementing your render and always dispose of native objects inside (see the code by reference). </p><br><h3 id="pozvolte-android-i-ios-pomoch-vam">  Let Android and iOS help you. </h3><br><p>  Android and iOS have mechanisms that can alert you to an imminent lack of memory.  In iOS, this <a href="https://developer.apple.com/reference/uikit/uiviewcontroller/1621409-didreceivememorywarning">DidReceiveMemoryWarning () in a UIViewController</a> .  On Android, this is more hidden and less documented: <a href="https://developer.android.com/reference/android/app/Application.html">OnTrimMemory () in Application</a> .  It is logical to assume that you need to call <code>GC.Collect()</code> inside these methods.  This will clear some objects, run several finalizers and call <code>Dispose()</code> on peer objects that are not used.  This will allow the native garbage collector to clean up unused objects and free up more space on the native side. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  I think that this post gives some useful recommendations on how to increase memory efficiency in your Xamarin applications, but pay attention, there is a lot more to tell about.  I will talk about this in the next posts, and in the meantime, you can read the documentation, view the Xamarin sources on GitHub, or experiment with Xamarin or native profilers. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330854/">https://habr.com/ru/post/330854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330844/index.html">We write a simple driver under Windows to lock USB devices.</a></li>
<li><a href="../330846/index.html">May the Code Review with you</a></li>
<li><a href="../330848/index.html">Top 15 Free Unity Assets for a Beginner 2D Developer</a></li>
<li><a href="../330850/index.html">Microsoft at CodeFest 2017 - report, slides and video reports</a></li>
<li><a href="../330852/index.html">What is missing Gmail. 4 free deskun features</a></li>
<li><a href="../330856/index.html">Bench press: compare HPE StoreOnce and EMC Data Domain</a></li>
<li><a href="../330858/index.html">We collect data in CRM: steroids for the company</a></li>
<li><a href="../330860/index.html">Transition from ASP.NET to Angular2 with features (personal experience)</a></li>
<li><a href="../330862/index.html">Publisher Peter. Summer Sale</a></li>
<li><a href="../330864/index.html">Open Data Board: Transport Disclosure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>