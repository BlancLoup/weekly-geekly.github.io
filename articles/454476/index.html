<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js Best Practices - Project Structure Tips</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the adapted translation of the first chapter of " Node.js Best Practices " by Yoni Goldberg. A selection of recommendations...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js Best Practices - Project Structure Tips</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/1s/eu/vv/1seuvv9zdxaimyzdcixzoolp1li.png"><br>  Hi, Habr!  I present to you the adapted translation of the first chapter of " <a href="https://github.com/i0natan/nodebestpractices">Node.js Best Practices</a> " by Yoni Goldberg.  A selection of recommendations for Node.js is available on github, it has almost 30 tons of stars, but has not been mentioned on Habr√© until now.  I assume that this information will be useful, at least, for beginners. <br><a name="habracut"></a><br><h2>  1. Project Structure Tips </h2><br><h3>  1.1 Structure your project by component </h3><br>  The worst mistake of large applications is the monolith architecture in the form of a huge code base with a large number of dependencies (spaghetti code), such a structure slows down the development of especially the introduction of new functions.  Council - separate your code into separate components, for each component, select your own folder for the modules of the component.  It is important that each module remains small and simple.  In the "Details" section you can see examples of the correct structure of projects. <br><br>  <b>Otherwise: it</b> will be difficult for developers to develop a product - adding new functionality and making changes to the code will be made slowly and have a high chance of breaking other dependent components.  It is believed that if business units are not divided, then problems with scaling the application may occur. <br><br><div class="spoiler">  <b class="spoiler_title">detailed information</b> <div class="spoiler_text">  <b>Single paragraph explanation</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For applications of medium size and above, monoliths are really bad - one big program with many dependencies is just hard to understand, and often leads to spaghetti code.  Even experienced programmers who know how to properly ‚Äúprepare modules‚Äù spend a lot of effort on architecture design and try to carefully evaluate the consequences of each change in the connections between objects.  The best option is an architecture based on a set of small component programs: divide the program into separate components that do not share their files with anyone, each component should consist of a small number of modules (for example, modules: API, service, database access, testing etc.) so that the structure and composition of the components are obvious.  Some may call this architecture ‚Äúmicroservice‚Äù, but it is important to understand that microservices are not a specification that you should follow, but rather a set of some principles.  At your request, you can adopt both individual of these principles and all the principles of microservice architecture.  Both methods are good if you keep code complexity low. <br><br>  The least you have to do is define the boundaries between the components: assign a folder in the root of your project to each of them and make them autonomous.  Access to the functional components should be implemented only through a public interface or API.  This is the foundation for keeping your components simple, avoiding dependency hell and letting your application grow to full-fledged microservices. <br><br>  <b>Quote of the blog: "Scaling requires scaling the entire application"</b> <br>  From the blog MartinFowler.com <br><blockquote>  Monolithic applications can be successful, but people are increasingly frustrated with them, especially when they are thinking about deploying to the cloud.  Any, even small, changes in the application require the assembly and re-laying of the entire monolith.  It is often difficult to constantly maintain a good modular structure, in which changes in one module do not affect others.  Scaling requires scaling the entire application, and not just its individual parts, of course, this approach requires more effort. </blockquote><br>  <b>Quote of the blog: "What does the architecture of your application say?"</b> <br>  From blog <a href="https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html">uncle-bob</a> <br><blockquote>  ... if you have been to the library, then you can imagine its architecture: the main entrance, reception desks, reading rooms, conference rooms and many rooms with bookshelves.  The architecture itself will say: this building is a library. </blockquote><br>  So what is the architecture of your application talking about?  When you look at the structure of top-level directories and the file modules in them, they say: I am an online store, I am bookkeeping, I am a production management system?  Or do they shout: I'm Rails, I'm Spring / Hibernate, I'm ASP. <br>  (Translator's Note, Rails, Spring / Hibernate, ASP are frameworks and web technologies). <br><br>  <b>Proper project structure with stand-alone components</b> <br><br><img src="https://habrastorage.org/webt/mp/g5/q8/mpg5q82ipd9tnobr96aq8_smbte.png"><br><br>  <b>Incorrect project structure with grouping files according to their purpose.</b> <br><br><img src="https://habrastorage.org/webt/3p/sd/e-/3psde-16jcizpuabedn_afgpfsg.png"><br></div></div><br><h3>  1.2 Separate the layers of your components and do not mix them with the Express data structure. </h3><br>  Each of your components must have ‚Äúlayers‚Äù, for example, to work with the web, business logic, access to the database, these layers must have their own data format not mixed with the data format of third-party libraries.  This not only clearly separates the problems, but also greatly facilitates the verification and testing of the system.  Often, API developers mix layers by passing Express web layer objects (for example, req, res) into business logic and data layer ‚Äî this makes your application dependent and strongly related to Express. <br><br>  <b>Otherwise:</b> for an application in which the objects of the layers are mixed, it is more difficult to ensure the testing of the code, the organization of CRON tasks and other non-Express calls. <br><br><div class="spoiler">  <b class="spoiler_title">detailed information</b> <div class="spoiler_text">  <b>Split component code into layers: web, services, and <abbr title="Data Access Layer - Data Access Layer">DAL</abbr></b> <br><br><img src="https://habrastorage.org/webt/mp/g5/q8/mpg5q82ipd9tnobr96aq8_smbte.png"><br><br>  <b>The reverse side of the mixture of layers in one gif-animation</b> <br><br><img src="https://habrastorage.org/webt/ma/to/2e/mato2eau6nrt3dr0kcqi9fawmee.gif"><br></div></div><br><h3>  1.3 Wrap your basic utilities in npm packages </h3><br>  In a large application consisting of various services with their own repositories, such universal utilities as logger, encryption, etc., should be wrapped with your own code and presented as private npm packages.  This allows you to share them between multiple code bases and projects. <br><br>  <b>Otherwise:</b> you will have to invent your own bike to share this code between separate code bases. <br><br><div class="spoiler">  <b class="spoiler_title">detailed information</b> <div class="spoiler_text">  <b>Single paragraph explanation</b> <br><br>  As soon as the project starts to grow and you have different components on different servers using the same utilities, you should start managing dependencies.  How can you allow multiple components to use it without duplicating your utility code between repositories?  For this there is a special tool, and it is called - npm ....  Start by wrapping third-party utility packages with your own code so that it can be easily replaced in the future, and publish this code as a private npm package.  Now your entire codebase can import utility code and use all the npm dependency management features.  Remember that there are the following ways to publish npm packages for personal use without opening them for public access: <a href="https://docs.npmjs.com/private-modules/intro">private modules</a> , <a href="https://npme.npmjs.com/docs/tutorials/npm-enterprise-with-nexus.html">private registry</a> or <a href="https://medium.com/%40arnaudrinquin/build-modular-application-with-npm-local-modules-dfc5ff047bcc">local npm packages</a> . <br><br>  <b>Sharing your own common utilities in different environments</b> <br><img src="https://habrastorage.org/webt/ll/yp/zt/llypztuehnlrksisayzdto91jzq.png"><br></div></div><br><h3>  1.4 Split Express into ‚Äúapplication‚Äù and ‚Äúserver‚Äù </h3><br>  Avoid the unpleasant habit of defining the entire Express application in one huge file, divide your 'Express' code into at least two files: the API declaration (app.js) and the www server code.  For even better structure, place the API declaration in component modules. <br><br>  <b>Otherwise:</b> your API will be available for testing only via HTTP calls (which is slower and much more difficult to create coverage reports).  Still, I suppose it's not too much fun to work with hundreds of lines of code in one file. <br><br><div class="spoiler">  <b class="spoiler_title">detailed information</b> <div class="spoiler_text">  <b>Single paragraph explanation</b> <br><br>  We recommend using the Express application generator and its approach to building an application database: the API declaration is separated from the server configuration (port data, protocol, etc.).  This allows you to test the API without making network calls, which speeds up testing and makes it easier to get code coverage metrics.  It also allows you to flexibly deploy the same API for different server network settings.  Bonus you also get a better division of responsibility and a cleaner code. <br><br>  <b>Example code: API declaration, must be in app.js</b> <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = express(); app.use(bodyParser.json()); app.use(<span class="hljs-string"><span class="hljs-string">"/api/events"</span></span>, events.API); app.use(<span class="hljs-string"><span class="hljs-string">"/api/forms"</span></span>, forms);</code> </pre> <br>  <b>Example code: server network settings, must be in / bin / www</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../app'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** *          Express. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> port = normalizePort(process.env.PORT || <span class="hljs-string"><span class="hljs-string">'3000'</span></span>); app.set(<span class="hljs-string"><span class="hljs-string">'port'</span></span>, port); <span class="hljs-comment"><span class="hljs-comment">/** *  HTTP-. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = http.createServer(app);</code> </pre> <br><br>  <b>Example: test your API using supertest (popular testing package)</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/user'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.status(<span class="hljs-number"><span class="hljs-number">200</span></span>).json({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'tobi'</span></span> }); }); request(app) .get(<span class="hljs-string"><span class="hljs-string">'/user'</span></span>) .expect(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, /json/) .expect(<span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>, <span class="hljs-string"><span class="hljs-string">'15'</span></span>) .expect(<span class="hljs-number"><span class="hljs-number">200</span></span>) .end(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; });</code> </pre> <br></div></div><br><h3>  1.5 Use secure hierarchical configuration with environment variables </h3><br>  The ideal configuration setting should provide: <br><br>  (1) reading keys from both the configuration file and environment variables, <br>  (2) storing secrets outside the repository code, <br>  (3) a hierarchical (rather than a flat) data structure of the configuration file to facilitate the work with the settings. <br><br>  There are several packages that can help with the implementation of these items, such as: rc, nconf and config. <br><br>  <b>Otherwise:</b> failure to comply with these configuration requirements will lead to a breakdown in the work of both the individual developer and the entire team. <br><br><div class="spoiler">  <b class="spoiler_title">detailed information</b> <div class="spoiler_text">  <b>Single paragraph explanation</b> <br><br>  When you deal with configuration settings, many things can annoy and slow down your work: <br><br>  1. Setting all parameters using environment variables becomes very tedious if you need to enter 100+ keys (instead of simply storing them in the configuration file), however, if the configuration is specified only in the configuration files, this can be inconvenient for DevOps.  A reliable configuration solution should combine both ways: both configuration files and parameter overrides from environment variables. <br><br>  2. If the configuration file is ‚Äúflat‚Äù JSON (i.e., all keys are written as a single list), then increasing the number of settings will make it difficult to work with it.  This problem can be solved by forming nested structures containing groups of keys according to settings sections, i.e.  organize a hierarchical JSON data structure (see example below).  There are libraries that allow you to store such a configuration in several files and merge data from them at runtime. <br><br>  3. It is not recommended to store confidential information (such as the database password) in configuration files, but there is no definitive, convenient solution where and how to store such information.  Some configuration libraries allow you to encrypt configuration files, others encrypt these records during git commits, and you can not save secret parameters in files at all and set their values ‚Äã‚Äãduring deployment through environment variables. <br><br>  4. Some advanced configuration scenarios require entering keys via the command line (vargs) or synchronizing configuration data through a centralized cache, such as Redis, so that multiple servers use the same data. <br><br>  There are npm libraries that will help you with the implementation of most of these recommendations, we advise you to look at the following libraries: <a href="https://www.npmjs.com/package/rc">rc</a> , <a href="https://www.npmjs.com/package/nconf">nconf</a> and <a href="https://www.npmjs.com/package/config">config</a> . <br><br>  <b>Example code: a hierarchical structure helps to find records and work with large configuration files</b> <b><br></b> <br><pre> <code class="json hljs">{ // Customer module configs <span class="hljs-attr"><span class="hljs-attr">"Customer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"dbConfig"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">5984</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dbName"</span></span>: <span class="hljs-string"><span class="hljs-string">"customers"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"credit"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"initialLimit"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, // Set low for development <span class="hljs-attr"><span class="hljs-attr">"initialDays"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } }</code> </pre><br>  (Translator's note, comments cannot be used in a classic JSON file. The above example is taken from the documentation of the config library, which added the functionality of pre-clearing JSON files from comments. Therefore, the example is quite working, but linters, such as ESLint, with default settings can "Swear" on a similar format). <br></div></div><br>  Afterword from the translator: <br><br><ol><li>  In the project description it is written that the Russian translation has already been launched, but I did not find this translation there, so I took up the article. </li><li>  If the translation seems very brief to you, then try to expand the detailed information in each section. </li><li>  Sorry that the illustrations are left without translation. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/454476/">https://habr.com/ru/post/454476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454464/index.html">Development of visual tests based on Gemini and Storybook</a></li>
<li><a href="../45447/index.html">Google search on Odnoklassniki</a></li>
<li><a href="../454470/index.html">Life to runtime. Yandex report</a></li>
<li><a href="../454472/index.html">What you need to know about the latest Cisco patch for routers</a></li>
<li><a href="../454474/index.html">Digital events in Moscow from 3 to 9 June</a></li>
<li><a href="../45448/index.html">I.UA search is based on Yandex.XML</a></li>
<li><a href="../454480/index.html">The history of assembling a ‚Äúvillage supercomputer‚Äù from spare parts from eBay, Aliexpress and a computer store. Part 3</a></li>
<li><a href="../454482/index.html">Bitter AI Industry Lesson</a></li>
<li><a href="../454486/index.html">Common Lisp tragedy: why popular languages ‚Äã‚Äãswell in complexity</a></li>
<li><a href="../454488/index.html">Electronic state of the future</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>