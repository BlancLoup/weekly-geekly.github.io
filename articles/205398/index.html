<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for cropped duplicate images using perceptual hashes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss how a small task of finding duplicates by fragment or crop of a picture was solved. 





 Foreword 
 I have one place where...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for cropped duplicate images using perceptual hashes</h1><div class="post__text post__text-html js-mediator-article">  This article will discuss how a small task of finding duplicates by fragment or crop of a picture was solved. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/048/a53/44f/048a5344fcd76e4e48904688126d5b53.png"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Foreword </h4><br>  I have one place where users sometimes add, in their opinion, beautiful pictures. <br>  Which are then moderated by the users themselves. <br>  And there are cases when one and the same picture is added several times.  What was usually solved with postmoderation. <br>  But the time came when it became difficult every time to check whether a similar or the same picture was already loaded. <br>  And there was an idea that it was time to look at the automatic search for duplicates. <br><br><h4>  Investigation </h4><br>  Initially, the gaze fell on <a href="http://en.wikipedia.org/wiki/SURF">SURF</a> descriptors, which gave very good results. <br>  But due to the complexity of checking for coincidences with the collection of pictures, I decided not to hurry and look at other solutions. <br><br>  Intuitively, I would like to highlight some signs of the image, like SIFT / SURF descriptors, but with the ability to quickly check for a match. <br><br>  After some effort, I ran into the idea of <a href="http://habrahabr.ru/post/120562/">perceptual hashes</a> . <br>  They seemed simple enough to create and search the database. <br><br>  In short, a perceptual hash is a convolution of some signs that describe a picture. <br><br>  The main advantage of such hashes is that they are easy to compare with other hashes using <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D1%258D%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">Hamming distance</a> . <br><br>  Ideally, the hash distance of two images is zero.  Then it means that these pictures are (most likely) identical. <br>  Especially bribed that this distance could be considered using a not very complex SQL query: <br><br> <code>SELECT * FROM image_hash WHERE BIT_COUNT( 0x2f1f76767e5e7f33 ^ hash ) &lt;= 10</code> <br> <br>  It remains to figure out how to get such hashes. <br><br>  In a subsequent <a href="http://www.hackerfactor.com/blog/index.php%3F/archives/529-Kind-of-Like-That.html">article</a> , descriptions were given of three ways to isolate this type of hash. <br><br>  In addition to the simplest algorithm for checking for the average value, which was called aHash (Average Hash) and the most relevant variant implemented in the open source project <a href="http://phash.org/">pHash</a> (Perceptual Hash), another description was given - dHash (Difference Hash), proposed by <a href="http://01101001.net/">David Oftedal</a> , namely, the comparison is not with the average pixel value, but with the previous one. <br><br>  After some tests, it turned out that <br>  <i>aHash is</i> inoperative and gives a huge number of false positives, <br>  <i>dHash</i> works much better, but still a lot of unsatisfactory mistakes, <br>  <i>pHash</i> showed itself best with the most current results, but is more sensitive to image modifications. <br><br>  In general, pHash is able to verify the identity of the image, even if a small copyright label was applied to it.  Insensitive to color, contrast, brightness, size and even weak geometric changes. <br><br>  With all these advantages, there is a completely legitimate restriction: the hash describes the whole picture and is more intended to search for a complete duplicate. <br><br>  In other words, such hashes are irrelevant when searching for duplicate pictures with crop, modifications with scale, size of the sides of the pictures, or directly partial or serious interference with the content of the picture. <br><br><h4>  Attempt to solve </h4><br>  After a brief analysis of the situation, I came to the conclusion that users are unlikely to add pictures with content modifications. <br>  For example, to draw a flower, a huge wet tag, or to change a photo somehow differently. <br><br>  But adding pictures with Crop is quite real.  For example, cut an important part, change the aspect ratio, increase something, and so on. <br>  Therefore, besides checking for complete or partial coincidence, it was necessary to check for a crop, at least a small one. <br><br>  One hash for one image is expediently unable to solve a similar problem. <br><br>  But, due to the ease of implementation of such hashes, I wanted to think a little about how to get around this limitation and find the cropping of the image with their help. <br><br>  Since one hash is no good, you should get a list of hashes.  Where each hash describes only its part of the image. <br><br>  But how do we know where and how to cut the picture? <br>  This is where getting local features using SURF came in handy. <br><br>  In other words, it was necessary to somehow cut the images by the points found. <br><br><img src="http://habrastorage.org/storage3/802/521/10b/80252110b4ad9b7cbf1b6c22d07842e6.png"><br>  <i>Figure 1. Found points from the requested image</i> <br><br><img src="http://habrastorage.org/storage3/379/a6b/081/379a6b0819c1b4e0320724925094f95b.png"><br>  <i>Figure 2. Found points from the saved image</i> <br><br>  Since we need to cut the picture in such a way that similar areas coincide (at least a little), <a href="http://ru.wikipedia.org/wiki/K-means">k-means</a> clustering of key points (features) has been tried. <br><br>  It seemed that if the picture did not change much in content and the local signs found remained almost unchanged, then probably the centroids after clustering these local points should also be approximately the same. <br><br>  This is the main idea of ‚Äã‚Äãthis approach. <br><br><img src="http://habrastorage.org/storage3/cff/c59/c04/cffc59c04678951f7d468108aa8f1f28.png"><br>  <i>Figure 3. The dot shows the center of a single cluster.</i> <br><br><img src="http://habrastorage.org/storage3/517/544/1e8/5175441e8463c69a3f9af0bdd52637b0.png"><br>  <i>Figure 4. Points describe the centers of the three clusters.</i>  <i>If you look closely, the upper centroid almost coincides with the center from Fig. 3.</i> <br><br>  In order to find such centroids that will roughly converge, it was necessary to perform clustering, for example, 20 times, changing the number of clusters. <br><br>  And it was possible to cut at the extreme points of each cluster. <br><br>  With a limit of 20 clusters, 21 * 20/2 = 210 centroids are obtained.  And just hashes for one image 210 + full image hash = 211 hashes. <br>  But we discard the slices less than 32 pixels and as a result we get, for example, 191 hashes. <br><br>  This approach showed better results than just comparing hashes of full images, but it still turned out to be unsatisfactory due to obvious misses.  It seems to be visually cutting coincide, but checking their hashes fails. <br><br>  Here the idea has already crept up to throw this venture and dig in another direction. <br>  But, finally, I decided to check what role the fixed format of the sides or coordinates plays.  And it turned out that this made it possible to increase the number of matches. <br><br>  I picked it up with a spear method so that the coordinate of the cut out image was a multiple of eight. <br><br><img src="http://habrastorage.org/storage3/5e7/a4e/994/5e7a4e99447b8ad9f5e4d085eb19c6c6.png"><br>  <i>Figure 5. Cut out matching images using clustering</i> <br><br><h4>  Prototype </h4><br>  Next, it was necessary to test the performance of such a model in practice. <br>  Quickly everything was transferred to the mogilnichok with pictures and the entire base was indexed. <br>  It turned out 1,235 pictures and 194,710 hashes in the database. <br><br>  And it turned out that BIT_COUNT (hash1 ^ hash2) is a rather expensive operation and requires additional attention. <br>  And it takes more time to execute 200 requests than to fulfill one large request with all 200 hashes at once. <br><br>  On my weak server, such a large request is executed for at least 2 seconds. <br><br>  A total of 200 * 194,710 = 38,942,000 operations for calculating the Hamming distance are required to search for one image. <br><br>  Therefore, I decided to check what the difference would be if I <a href="http://docs.oracle.com/cd/E19078-01/mysql/mysql-refman-5.0/extending-mysql.html">wrote</a> my own implementation of calculating the distance in MySQL. <br>  The difference was insignificant and, moreover, not in favor of user functions. <br><br>  For the sake of interest, I tried to implement a search on a collection of hashes in C ++. <br>  Where the idea is impossible is simple: get the entire list of hashes from the database and walk through them, calculating the distance manually. <br><br><div class="spoiler">  <b class="spoiler_title">An example of calculating the Hamming distance in C ++</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> longlong; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> longlong </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hamming_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( longlong hash1, longlong hash2 )</span></span></span><span class="hljs-function"> </span></span>{ longlong x = hash1 ^ hash2; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> longlong m1 = <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>ULL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> longlong m2 = <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>ULL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> longlong h01 = <span class="hljs-number"><span class="hljs-number">0x0101010101010101</span></span>ULL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> longlong m4 = <span class="hljs-number"><span class="hljs-number">0x0f0f0f0f0f0f0f0f</span></span>ULL; x -= (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; m1; x = (x &amp; m2) + ((x &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; m2); x = (x + (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)) &amp; m4; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x * h01)&gt;&gt;<span class="hljs-number"><span class="hljs-number">56</span></span>; }</code> </pre><br></div></div><br><br>  And this idea works out twice as fast as through a SQL query. <br><br>  Further, due to the large number of hashes, it was necessary to formulate the rules for determining duplicates. <br><br>  For example, if one of two hundred hashs matched, consider the image a duplicate?  Probably not. <br>  Also, there were cases when more than 20% of the hashes coincided, but the picture is definitely not a duplicate. <br>  And there are 10% of matches, but is a duplicate. <br>  So the number of only hashes found to the total number is not a guarantee of verification. <br><br>  To filter out obviously incorrect matches, we used the SURF calculation of the descriptors of the images found and counting the number of matches with the requested one. <br>  That allowed to show current results, but requires additional processing time.  Most likely there are more optimal options. <br><br><h4>  Epilogue </h4><br>  Such an approach made it possible to find pictures that were reasonably well within reasonable limits in a satisfactory time. <br>  Although it is far from optimal and leaves a lot of room for maneuvers or optimizations (for example, it is reasonable to check the hashes after clustering and discard duplicates, which will reduce the number of hashes by two, and maybe even more times). <br>  But, I hope, interesting for simple curiosity, albeit non-academic. <br><br><h5>  Links </h5><br>  <a href="http://habrahabr.ru/post/120562/">habrahabr.ru/post/120562</a> - Description of hashes, translation <br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D1%258D%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">ru.wikipedia.org/wiki/Hamming</a> distance - Hamming distance <br>  <a href="http://en.wikipedia.org/wiki/SURF">en.wikipedia.org/wiki/SURF</a> - SURF key points <br>  <a href="http://ru.wikipedia.org/wiki/K-means">ru.wikipedia.org/wiki/K-means</a> - Clustering <br>  <a href="http://phash.org/">phash.org</a> - pHash project <br>  <a href="http://www.hackerfactor.com/blog/index.php%3F/archives/529-Kind-of-Like-That.html">www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html</a> - Comparing Hash Types <br>  <a href="http://01101001.net/differencehash.php">01101001.net/differencehash.php</a> - Difference Hash <br>  <a href="https://github.com/valbok/img.chk/blob/master/bin/example.py">github.com/valbok/img.chk/blob/master/bin/example.py</a> - My version of the implementation of the selection of hashes from the image <br>  <a href="https://github.com/valbok/leie/blob/master/classes/image/leieImage.php">github.com/valbok/leie/blob/master/classes/image/leieImage.php</a> - Another version of my hash, but in PHP </div><p>Source: <a href="https://habr.com/ru/post/205398/">https://habr.com/ru/post/205398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205386/index.html">Cross-platform development on Xamarin</a></li>
<li><a href="../205388/index.html">Share the secret</a></li>
<li><a href="../205390/index.html">Global Government Observation Reform</a></li>
<li><a href="../205394/index.html">Map of Russian science: resonant or resonant project?</a></li>
<li><a href="../205396/index.html">IT quest marathon for the habr</a></li>
<li><a href="../205402/index.html">TeamCity setup for newbies</a></li>
<li><a href="../205404/index.html">WebRTC Expo 2013 and new features of the VoxImplant platform</a></li>
<li><a href="../205406/index.html">Ball pen to create conductive drawings on Kickstarter collected 477 thousand dollars instead of 85 thousand</a></li>
<li><a href="../205410/index.html">The first part of 1,500,000 pages of ancient manuscripts is digitized.</a></li>
<li><a href="../205412/index.html">Google Analytics. Caution bots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>