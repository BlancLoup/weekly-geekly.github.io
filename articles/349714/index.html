<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using ReSwift: Writing the Memory Game Application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note. This article uses Xcode 8 and Swift 3 . 

 As iOS applications continue to grow in size, the MVC pattern gradually loses its role as an ‚Äúappropr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using ReSwift: Writing the Memory Game Application</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/hv/fq/qohvfqomkko3vxhibj70mq_yvle.png" alt="ReSwift"></div><br>  <b>Note.</b>  <i>This article uses <b>Xcode 8</b> and <b>Swift 3</b> .</i> <br><br>  As iOS applications continue to grow in size, the <b>MVC</b> pattern gradually loses its role as an ‚Äúappropriate‚Äù architectural solution. <br><br>  For iOS developers, more efficient architectural patterns are available, such as MVVM, VIPER, and <a href="https://eng.uber.com/new-rider-app/">Riblets</a> .  They are very different, but they have a common goal: to break the code into blocks according to the principle of common responsibility with a multidirectional data stream.  In a multidirectional stream, data moves in different directions between different modules. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes you don‚Äôt want (or you don‚Äôt need to) use a multidirectional data stream - instead you want the data to be sent in one direction: this is a unidirectional data stream.  In this article about ReSwift, you will turn off the beaten path and learn how to use the <a href="https://github.com/ReSwift/ReSwift">ReSwift</a> framework to implement a unidirectional data flow when creating a <a href="https://en.wikipedia.org/wiki/Concentration_(game)">Memory Game</a> application called <b>MemoryTunes</b> . <br><a name="habracut"></a><br>  But first - what is ReSwift? <br><br><h3>  Introduction to ReSwift </h3><br>  <a href="https://github.com/ReSwift/ReSwift">ReSwift</a> is a small framework that helps you implement the <a href="https://github.com/reactjs/redux">Redux</a> architecture using Swift. <br><br>  ReSwift has four main components: <br><br><ul><li>  <b>Views</b> : Reacts to changes in the <b>Store</b> and displays them on the screen.  <b>Views</b> sends Actions. </li><li>  <b>Actions</b> : Initiates a state change in the application.  <b>Actions are</b> processed by the Reducer. </li><li>  <b>Reducers</b> : Directly changes the state of the application stored in the <b>Store</b> . </li><li>  <b>Store</b> : Stores the current state of the application.  Other modules, such as <b>Views</b> , can connect and respond to changes. </li></ul><br>  ReSwift has a number of interesting advantages: <br><br><ul><li>  <b>Very strong limitations</b> : it is tempting to place small code fragments in a convenient place, where in reality it should not be.  ReSwift prevents this by placing very strong limits on what is happening and where it is happening. </li><li>  <b>Unidirectional data flow</b> : Applications that implement a multidirectional data flow can be very difficult to read and debug.  One change can lead to a chain of events that send data across the entire application.  Unidirectional flow is more predictable and significantly reduces the cognitive load required to read the code. </li><li>  <b>Ease of testing</b> : most of the business logic is contained in Reducers, which are pure functions. </li><li>  <b>Platform</b> Independence: All ReSwift elements ‚Äî Stores, Reducers, and Actions ‚Äî are platform independent.  They can be easily reused for iOS, macOS or tvOS. </li></ul><br><h3>  Multidirectional or unidirectional flow </h3><br>  To clarify what I mean when I talk about data flow, I‚Äôll give the following example.  An application created using VIPER supports multidirectional data flow between modules: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2df/95f/5a9/2df95f5a9fafa9adf70eb5b62804ef0c.png" alt="VIPER" width="454"></div><br>  <i>VIPER - Multidirectional Data Stream</i> <br><br>  Let's compare it with unidirectional data flow in an application built on the basis of ReSwift: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b1/c33/f0b/1b1c33f0b24b4a274d0e12c7d898a1da.png" alt="ReSwift" width="384"></div><br>  <i>ReSwift - unidirectional data flow</i> <br><br>  Since data can only be transferred in one direction, it is much easier to visually follow the code and identify any problems in the application. <br><br><h3>  Getting started </h3><br>  Start by <a href="">downloading the project</a> , which currently contains some source code and a set of frameworks, including ReSwift, which you will learn more about as you read this article. <br><br>  First, you will need to configure work with ReSwift.  Start by building the application kernel: its states. <br><br>  Open <b>AppState.swift</b> and create an AppState structure that matches the StateType: <br><br><pre><code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AppState: StateType { }</code> </pre> <br>  This structure defines the state of the application. <br><br>  Before creating the <b>Store</b> , which will contain the value of AppState, you need to create a main <b>Reducer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/d38/a51/87ad38a51ae421f84afcd3c3633914a1.png" alt="Reducer" width="480" height="196"></div><br>  Reducer directly changes the current <b>AppState</b> value stored in the <b>Store</b> .  Only Action can run a Reducer to change the current state of the application.  Reducer generates the current <b>AppState</b> value depending on the Action it receives. <br><br>  <b>Note.</b>  <i>There is only one Store in the application and it has only one main Reducer.</i> <br><br>  Create the main reducer function of the application in <b>AppReducer.swift</b> <br><br><pre> <code class="objectivec hljs">import ReSwift func appReducer(action: Action, state: AppState?) -&gt; AppState { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AppState() }</code> </pre><br>  <b>appReducer</b> is a function that takes an Action and returns a modified AppState.  The state parameter is the current state of the application.  This function should change state accordingly, depending on the action received.  Now just create a new AppState value - you will return to it as soon as you configure the Store. <br><br>  It's time to create a Store that stores the state of the application, and the reducer, in turn, could change it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/ecb/391/345ecb391b981d548d055773e1ca80bd.png" alt="Store" width="480" height="196"></div><br>  Store stores the current state of the entire application: this is the value of your AppState structure.  Open <b>AppDelegate.swift</b> and replace the <i>import UIKit with the</i> following: <br><br><pre> <code class="objectivec hljs">import ReSwift var store = Store&lt;AppState&gt;(reducer: appReducer, state: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre><br>  This creates a global store variable initialized by the appReducer.  appReducer is the main Reducer of the Store block, which contains instructions on how the store should change when an Action is received.  Since this is the initial creation, not an iterative change, you are passing an empty state. <br><br>  Compile and run the application to make sure we did everything right: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/271/0b1/ce12710b13bf6bdad56090ce8f8114cd.png" alt="image" width="281"></div><br>  <i>This is not very interesting ... But at least it works:]</i> <br><br><h3>  Interface Navigation </h3><br>  It's time to create the first real state of the application.  You will begin by navigating the interface (routing). <br><br>  Navigating to an application (or routing) is a challenge for every architecture, not just for ReSwift.  You have to use a simple approach in MemoryTunes, where you define the entire list of screens in enum and the AppState will contain the current value.  AppRouter will respond to changes in this value and show the current status on the screen. <br><br>  Open <b>AppRouter.swift</b> and replace <i>import UIKit with the</i> following: <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RoutingDestination: String { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> menu = <span class="hljs-string"><span class="hljs-string">"MenuTableViewController"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> categories = <span class="hljs-string"><span class="hljs-string">"CategoriesTableViewController"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> game = <span class="hljs-string"><span class="hljs-string">"GameViewController"</span></span> }</code> </pre><br>  This <b>enum</b> defines all the controllers presented in the application. <br><br>  Now you have what to store in the State application.  In this case, there is only one basic state structure (AppState), but you can divide the state of the application into sub-states specified in the main state. <br><br>  Since this is a good practice, you will group state variables into sub-state structures.  Open <b>RoutingState.swift</b> and add the following sub-state structure for navigation: <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> RoutingState: StateType { var navigationState: RoutingDestination init(navigationState: RoutingDestination = .menu) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationState = navigationState } }</code> </pre><br>  <b>RoutingState</b> contains <b>navigationState</b> , which represents the current destination on the screen. <br><br>  <b>Note:</b> <i>menu is the default value for navigationState.</i>  <i>This value is indirectly set by default when the application is started, unless you specify another one during RoutingState initialization.</i> <br><br>  In <b>AppState.swift,</b> add the following inside the structure: <br><br><pre> <code class="objectivec hljs">let routingState: RoutingState</code> </pre><br>  AppState now contains the RoutingState sub-state. <br><br>  Run the application and you will see the problem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/514/7ce/ab2/5147ceab28a1a65be2a7a8158501f4f5.png" alt="Oops ..." width="1462"></div><br>  The appReducer function is no longer compiled!  This is due to the fact that you added routingState to the AppState, but did not pass anything to the default initializer call.  To create a RoutingState you need a reducer. <br><br>  There is only one main function in Reducer, but, like the state, reducers must be divided into sub-reducers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11e/304/7e4/11e3047e4f222521068f0fe4a80aa263.png" alt="Sub-State and Sub-Reducers" width="436" height="320"></div><br>  Add the following Reducer to navigate to <b>RoutingReducer.swift</b> : <br><br><pre> <code class="objectivec hljs">import ReSwift func routingReducer(action: Action, state: RoutingState?) -&gt; RoutingState { let state = state ?? RoutingState() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre><br>  Like the main Reducer, the routingReducer changes state depending on the action it receives, and then returns it.  You have no actions yet, so a new RoutingState is created if state is nil and this value is returned. <br><br>  Sub-reducers are responsible for initializing the initial values ‚Äã‚Äãof the corresponding sub-states. <br>  Return to <b>AppReducer.swift</b> to correct the compiler warning.  Modify the appReducer function to match this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AppState(routingState: routingReducer(action: action, state: state?.routingState))</code> </pre><br>  We have added the routingState argument to the AppState initializer.  action and state from the main reduser are passed to the routingReducer to determine the new state.  Get used to this routine, because you have to repeat it for each sub-state and sub-reducer you create. <br><br><h3>  Subscribing / Subscription </h3><br>  Remember that the default menu value is set for RoutingState?  In fact, this is the current state of the application!  You just never subscribed to it. <br><br>  Any class can subscribe to the Store, not just Views.  When a class subscribes to the Store, it receives information about all changes that occur in the current state or sub-state.  You need to do this in the AppRouter so that it can change the current screen for the UINavigationController when changing the routingState. <br><br>  Open the <b>AppRouter.swift</b> file and replace the AppRouter with the following: <br><br><pre> <code class="objectivec hljs">final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppRouter { let navigationController: <span class="hljs-built_in"><span class="hljs-built_in">UINavigationController</span></span> init(window: <span class="hljs-built_in"><span class="hljs-built_in">UIWindow</span></span>) { navigationController = <span class="hljs-built_in"><span class="hljs-built_in">UINavigationController</span></span>() window.rootViewController = navigationController <span class="hljs-comment"><span class="hljs-comment">// 1 store.subscribe(self) { $0.select { $0.routingState } } } // 2 fileprivate func pushViewController(identifier: String, animated: Bool) { let viewController = instantiateViewController(identifier: identifier) navigationController.pushViewController(viewController, animated: animated) } private func instantiateViewController(identifier: String) -&gt; UIViewController { let storyboard = UIStoryboard(name: "Main", bundle: nil) return storyboard.instantiateViewController(withIdentifier: identifier) } } // MARK: - StoreSubscriber // 3 extension AppRouter: StoreSubscriber { func newState(state: RoutingState) { // 4 let shouldAnimate = navigationController.topViewController != nil // 5 pushViewController(identifier: state.navigationState.rawValue, animated: shouldAnimate) } }</span></span></code> </pre><br>  In the above code, you updated the AppRouter class and added an extension.  Let's take a closer look at what we did: <br><br><ol><li>  <b>AppState is</b> now subscribed to the global store.  In a closure expression, select indicates that you have subscribed to changes in routingState. </li><li>  <b>pushViewController</b> will be used to create an instance and add it to the navigation stack.  It uses the instantiateViewController method, which loads the controller based on the passed identifier. </li><li>  Create an <b>AppRouter</b> that matches the StoreSubscriber so that newState gets callbacks as soon as the routingState changes. </li><li>  You do not want to activate the root view controller, so check if the current destination is the root. </li><li>  When the state changes, you add a new destination to the UINavigationController using rawValue for state.navigationState, which is the name of the view controller. </li></ol><br>  AppRouter will now respond to the initial menu value and display the MenuTableViewController. <br><br>  Compile and run the application to make sure the error has disappeared: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/d33/c62/e49d33c6208bd259c282fdf130928ece.png" alt="image" width="281"></div><br><br>  At the moment, MenuTableViewController is displayed, which is empty.  You will display a menu in it that will redirect the user to other screens. <br><br><h3>  View </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae1/16c/8da/ae116c8dadfc9d65e3051794939cf6d1.png" alt="View" width="480" height="196"></div><br>  Anything can be a StoreSubscriber, but most of the time it will be a view that responds to state changes.  Your task is to make MenuTableViewControleller display two options of a submenu (or menu).  It's time for the State / Reducer procedure! <br><br>  Go to <b>MenuState.swift</b> and create a state for the menu as follows: <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MenuState: StateType { var menuTitles: [String] init() { menuTitles = [<span class="hljs-string"><span class="hljs-string">"New Game"</span></span>, <span class="hljs-string"><span class="hljs-string">"Choose Category"</span></span>] } }</code> </pre><br>  The MenuState structure consists of a menuTitles array, which you initialize with headings that will be displayed as a table. <br><br>  In <b>MenuReducer.swift,</b> create a Reducer for this state with the following code: <br><br><pre> <code class="objectivec hljs">import ReSwift func menuReducer(action: Action, state: MenuState?) -&gt; MenuState { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MenuState() }</code> </pre><br>  Since MenuState is static, you do not need to worry about handling state changes.  Thus, it simply returns the new MenuState. <br><br>  Return to <b>AppState.swift</b> .  Add a MenuState to the end of the AppState. <br><br><pre> <code class="objectivec hljs">let menuState: MenuState</code> </pre><br>  It will not compile because you changed the default initializer again.  In <b>AppReducer.swift,</b> modify the <b>AppState</b> initializer as follows: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AppState( routingState: routingReducer(action: action, state: state?.routingState), menuState: menuReducer(action: action, state: state?.menuState))</code> </pre><br>  Now that you have a MenuState, it's time to subscribe to it and use it when rendering the menu. <br><br>  Open <b>MenuTableViewController.swift</b> and replace the code with the following: <br><br><pre> <code class="objectivec hljs">import ReSwift final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MenuTableViewController: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewController</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 var tableDataSource: TableDataSource&lt;UITableViewCell, String&gt;? override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) // 2 store.subscribe(self) { $0.select { $0.menuState } } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) // 3 store.unsubscribe(self) } } // MARK: - StoreSubscriber extension MenuTableViewController: StoreSubscriber { func newState(state: MenuState) { // 4 tableDataSource = TableDataSource(cellIdentifier:"TitleCell", models: state.menuTitles) {cell, model in cell.textLabel?.text = model cell.textLabel?.textAlignment = .center return cell } tableView.dataSource = tableDataSource tableView.reloadData() } }</span></span></code> </pre><br>  The controller is now subscribed to the MenuState changes and declaratively displays the status on the user interface. <br><br><ol><li>  TableDataSource is included in the launch system and acts as a declarative data source for the UITableView. </li><li>  Subscribe to the menuState in viewWillAppear.  You will now receive callbacks in newState each time the menuState changes. </li><li>  If necessary, unsubscribe. </li><li>  This is the declarative part.  Here you fill in the UITableView.  You can clearly see in the code how the state is converted to a view. </li></ol><br>  <b>Note.</b>  <i>As you can see, ReSwift supports immutability - it actively uses structures (values), not objects.</i>  <i>It also encourages you to create declarative user interface code.</i>  <i>What for?</i> <i><br><br></i>  <i>The newState callback, defined in StoreSubscriber, sends state changes.</i>  <i>You may be tempted to fix the state value in a parameter, for example,</i> <i><br><br></i> <pre> <i><code class="objectivec hljs">final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MenuTableViewController: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewController</span></span> { var currentMenuTitlesState: [String] ...</code></i> </pre> <i><br></i>  <i>But writing declarative UI code, which clearly shows how a state is transformed into a view, is more comprehensible and much easier to use.</i>  <i>The problem with this example is that UITableView does not have a declarative API.</i>  <i>That's why I created the TableDataSource to eliminate the difference.</i>  <i>If you are interested in the details, take a look at <b>TableDataSource.swift</b> .</i> <br><br>  Compile and run the application and you will see the menu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/55d/53d/e6a55d53d36817827ff2183384947348.png" alt="image" width="281"></div><br><h3>  Actions / Actions </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/088/573/470088573033b1c26f5b71b8fa842887.png" alt="Actions" width="480" height="196"></div><br><br>  Now that you have a ready-made menu, it would be great if we could go over / open new screens with it.  It's time to write your first Action. <br><br>  Actions trigger a change in the Store.  An action is a simple structure that can contain variables: Action parameters.  Reducer processes the generated Action and changes the state of the application depending on the type of action and its parameters. <br><br>  Create an action in <b>RoutingAction.swift</b> : <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> RoutingAction: Action { let destination: RoutingDestination }</code> </pre><br>  RoutingAction changes the current destination. <br><br>  Now you are going to execute RoutingAction when you select a menu item. <br><br>  Open <b>MenuTableViewController.swift</b> and add the following to MenuTableViewController: <br><br><pre> <code class="objectivec hljs">override func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, didSelectRowAt indexPath: IndexPath) { var routeDestination: RoutingDestination = .categories <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(indexPath.row) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: routeDestination = .game <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: routeDestination = .categories <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } store.dispatch(RoutingAction(destination: routeDestination)) }</code> </pre><br>  This will set the routeDestination value based on the row you selected.  Then dispatch is used to transfer the RoutingAction to the Store. <br><br>  The action is ready to be executed, but is not supported by any reducer.  Open <b>RoutingReducer.swift</b> and replace the contents of the routingReducer with the following code, which updates the status: <br><br><pre> <code class="objectivec hljs">var state = state ?? RoutingState() <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> action { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let routingAction as RoutingAction: state.navigationState = routingAction.destination <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state</code> </pre><br>  <b>switch</b> checks if the action passed is an RoutingAction action.  If so, use your destination to change the RoutingState, which is then returned. <br><br>  Compile and run the application.  Now, when you select a menu item, the corresponding view controller will appear on top of the menu controller. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/86b/3f7/1e486b3f7dac1400b5a43f30b633c50c.gif" alt="image" width="371" height="665"></div><br><h3>  Status update </h3><br>  You may have noticed an error in the current navigation implementation.  When you click on the New Game menu item, the navigationState in RoutingState changes in the menu to game.  But when you click the return button to return to the menu, the navigationState does not update anything! <br><br>  In ReSwift, it is important to keep the state synchronized with the current state of the user interface.  It's easy to forget about this when something is completely controlled by UIKit, for example, navigating a return or filling a text field by a user in a UITextField. <br><br>  We can fix this if we update the navigationState when the MenuTableViewController appears. <br><br>  In <b>MenuTableViewController.swift,</b> add this line at the bottom of viewWillAppear: <br><br><pre> <code class="objectivec hljs">store.dispatch(RoutingAction(destination: .menu))</code> </pre><br>  If the user pushes the user‚Äôs button, this code will update the store. <br><br>  Run the application and check the navigation again.  Iiiii ... now navigation is completely faulty.  Nothing is displayed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd0/eb5/27c/bd0eb527cb2106a6f8a215f6545cd187.gif" alt="image" width="368" height="665"></div><br>  Open <b>AppRouter.swift</b> .  Remember that pushViewController is called every time a new navigationState is received.  This means that you are updating the RoutingDestination menu by clicking on it again! <br><br>  You must perform an additional check if the MenuViewController is not displayed.  Replace the contents of pushViewController with: <br><br><pre> <code class="objectivec hljs">let viewController = instantiateViewController(identifier: identifier) let newViewControllerType = type(of: viewController) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let currentVc = navigationController.topViewController { let currentViewControllerType = type(of: currentVc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentViewControllerType == newViewControllerType { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } navigationController.pushViewController(viewController, animated: animated)</code> </pre><br>  You call the <i>type</i> function <i>(of :)</i> for the last view controller and compare it with the new one that appears when you click.  If they match, then return two values. <br><br>  Compile and run the application and the navigation should work fine if the menu is properly configured when you change the stack. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/86b/3f7/1e486b3f7dac1400b5a43f30b633c50c.gif" alt="navigation" width="371" height="665"></div><br>  State updates using the user interface and dynamic checking of the current state are usually complex.  This is one of the problems that you have to overcome when working with ReSwift.  Fortunately, this should not happen very often. <br><br><h3>  Categories </h3><br>  Now you take a step forward and implement a more complex screen: CategoriesTableViewController.  You must allow users to select a category of music so that they can enjoy playing in Memory while listening to their favorite artists.  Start by adding states to <b>CategoriesState.swift</b> : <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Category: String { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> pop = <span class="hljs-string"><span class="hljs-string">"Pop"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> electronic = <span class="hljs-string"><span class="hljs-string">"Electronic"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> rock = <span class="hljs-string"><span class="hljs-string">"Rock"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> metal = <span class="hljs-string"><span class="hljs-string">"Metal"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> rap = <span class="hljs-string"><span class="hljs-string">"Rap"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> CategoriesState: StateType { let categories: [Category] var currentCategorySelected: Category init(currentCategory: Category) { categories = [ .pop, .electronic, .rock, .metal, .rap] currentCategorySelected = currentCategory } }</code> </pre><br>  <b>enum</b> defines several categories of music.  CategoriesState contains an array of available categories, as well as currentCategorySelected for status tracking. <br><br>  In <b>ChangeCategoryAction.swift,</b> add the following: <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ChangeCategoryAction: Action { let categoryIndex: Int }</code> </pre><br>  This triggers an action that CategoryState can modify using categoryIndex to refer to music categories. <br><br>  Now you need to implement a Reducer that accepts the ChangeCategoryAction and saves the updated state.  Open CategoriesReducer.swift and add the following: <br><br><pre> <code class="objectivec hljs">import ReSwift private <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> CategoriesReducerConstants { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> let userDefaultsCategoryKey = <span class="hljs-string"><span class="hljs-string">"currentCategoryKey"</span></span> } private typealias C = CategoriesReducerConstants func categoriesReducer(action: Action, state: CategoriesState?) -&gt; CategoriesState { var currentCategory: Category = .pop <span class="hljs-comment"><span class="hljs-comment">// 1 if let loadedCategory = getCurrentCategoryStateFromUserDefaults() { currentCategory = loadedCategory } var state = state ?? CategoriesState(currentCategory: currentCategory) switch action { case let changeCategoryAction as ChangeCategoryAction: // 2 let newCategory = state.categories[changeCategoryAction.categoryIndex] state.currentCategorySelected = newCategory saveCurrentCategoryStateToUserDefaults(category: newCategory) default: break } return state } // 3 private func getCurrentCategoryStateFromUserDefaults() -&gt; Category? { let userDefaults = UserDefaults.standard let rawValue = userDefaults.string(forKey: C.userDefaultsCategoryKey) if let rawValue = rawValue { return Category(rawValue: rawValue) } else { return nil } } // 4 private func saveCurrentCategoryStateToUserDefaults(category: Category) { let userDefaults = UserDefaults.standard userDefaults.set(category.rawValue, forKey: C.userDefaultsCategoryKey) userDefaults.synchronize() }</span></span></code> </pre><br>  As in the case of other reducers, a method of full state update through actions is formed.  In this case, you also save the selected category in <b>UserDefaults</b> .  For more details on how this happens: <br><br><ol><li>  The current category is loaded from UserDefaults if it is available and used to create a CategoriesState image if it has not yet been created. </li><li>  Responding to a ChangeCategoryAction by updating the state and saving a new category in UserDefaults. </li><li>  getCurrentCategoryStateFromUserDefaults is a helper function that loads a category from UserDefaults. </li><li>  saveCurrentCategoryStateToUserDefaults is a helper function that saves a category in UserDefaults. </li></ol><br>  Helper functions are also pure global functions.  You can put them in a class or structure, but they must always remain clean. <br><br>  Naturally, you need to update the AppState with the new state.  Open <b>AppState.swift</b> and add the following to the end of the structure: <br><br><pre> <code class="objectivec hljs">let categoriesState: CategoriesState</code> </pre><br>  <b>categoryState is</b> now part of AppState.  You have already mastered it! <br><br>  Open <b>AppReducer.swift</b> and change the return value to match this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AppState( routingState: routingReducer(action: action, state: state?.routingState), menuState: menuReducer(action: action, state: state?.menuState), categoriesState: categoriesReducer(action:action, state: state?.categoriesState))</code> </pre><br>  Here you added a categoryState to the appReducer, passing action and categoriesState. <br><br>  Now you need to create a categories screen, similar to MenuTableViewController.  You will sign it to the Store and use a TableDataSource. <br><br>  Open <b>CategoriesTableViewController.swift</b> and replace the contents with the following: <br><br><pre> <code class="objectivec hljs">import ReSwift final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CategoriesTableViewController: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewController</span></span> { var tableDataSource: TableDataSource&lt;<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>, Category&gt;? override func viewWillAppear(_ animated: Bool) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillAppear(animated) <span class="hljs-comment"><span class="hljs-comment">// 1 store.subscribe(self) { $0.select { $0.categoriesState } } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) store.unsubscribe(self) } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { // 2 store.dispatch(ChangeCategoryAction(categoryIndex: indexPath.row)) } } // MARK: - StoreSubscriber extension CategoriesTableViewController: StoreSubscriber { func newState(state: CategoriesState) { tableDataSource = TableDataSource(cellIdentifier:"CategoryCell", models: state.categories) {cell, model in cell.textLabel?.text = model.rawValue // 3 cell.accessoryType = (state.currentCategorySelected == model) ? .checkmark : .none return cell } self.tableView.dataSource = tableDataSource self.tableView.reloadData() } }</span></span></code> </pre><br>  This is quite similar to MenuTableViewController.  Here are some highlights: <br><br><ol><li>  In viewWillAppear, subscribe to the categoriesState changes and post in viewWillDisappear. </li><li>  Called ChangeCategoryAction when the user selects a cell. </li><li>  In newState, tick a box for the currently selected category. </li></ol><br>  Everything is set up.  Now you can choose a category.  Compile and run the application and select the Choose Category to verify that it works correctly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eae/49f/d41/eae49fd41b0eccf723a5d3ebed94e080.png" width="281" alt="image"></div><br><h3>  Asynchronous tasks </h3><br>  Is <a href="https://ashfurrow.com/blog/comparative-asynchronous-programming/">asynchronous programming</a> a difficult task?  Yes!  But not for ReSwift. <br><br>  You get images for the Memory card from the iTunes API.  But first you need to create a game state, a reducer and an action related to it. <br><br>  Open GameState.swift, and you will see a MemoryCard structure representing the game card.  It includes imageUrl, which will be displayed on the map.  isFlipped indicates whether the face of the card is visible, and isAlreadyGuessed indicates whether the card has been guessed. <br><br>  You will add game status to this file.  Start by importing ReSwift at the top of the file: <br><br><pre> <code class="objectivec hljs">import ReSwift</code> </pre><br>  Now add the following code to the end of the file: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> GameState: StateType { var memoryCards: [MemoryCard] <span class="hljs-comment"><span class="hljs-comment">// 1 var showLoading: Bool // 2 var gameFinished: Bool }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This determines the state of the game. </font><font style="vertical-align: inherit;">In addition to the contents of the array of available memoryCards, specify the parameters:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Load indicator, visible or not. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game over. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a game Reducer to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameReducer.swift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="objectivec hljs">import ReSwift func gameReducer(action: Action, state: GameState?) -&gt; GameState { let state = state ?? GameState(memoryCards: [], showLoading: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, gameFinished: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment, just creating a new GameState. </font><font style="vertical-align: inherit;">You will come back to this later. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppState.swift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> add a gameState to the end of the AppState:</font></font><br><br><pre> <code class="objectivec hljs">let gameState: GameState</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppReducer.swift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , update the initializer for the last time:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AppState( routingState: routingReducer(action: action, state: state?.routingState), menuState: menuReducer(action: action, state: state?.menuState), categoriesState: categoriesReducer(action:action, state: state?.categoriesState), gameState: gameReducer(action: action, state: state?.gameState))</code> </pre><br>  <b>Note.</b> <i>   ,        Action / Reducer / State.     ,    ReSwift   ,      .     Reducers   Store     Actions    .   ,        .</i> <br><br>      ,   <b>SetCardsAction.swift</b>  : <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SetCardsAction: Action { let cardImageUrls: [String] }</code> </pre><br> Action  URL     GameState. <br><br>       .  <b>FetchTunesAction.swift</b>  : <br><br><pre> <code class="objectivec hljs">import ReSwift func fetchTunes(state: AppState, store: Store&lt;AppState&gt;) -&gt; FetchTunesAction { iTunesAPI.searchFor(category: state.categoriesState.currentCategorySelected.rawValue) { imageUrls <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> store.dispatch(SetCardsAction(cardImageUrls: imageUrls)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FetchTunesAction() } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FetchTunesAction: Action { }</code> </pre><br>  fetchTunes     iTunesAPI (   ).      SetCardsAction  .    ReSwift  :     ,  .  That's all. <br><br>  fetchTunes  FetchTunesAction,       . <br><br>  <b>GameReducer.swift</b>      .   gameReducer  : <br><br><pre> <code class="objectivec hljs">var state = state ?? GameState(memoryCards: [], showLoading: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, gameFinished: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(action) { <span class="hljs-comment"><span class="hljs-comment">// 1 case _ as FetchTunesAction: state = GameState(memoryCards: [], showLoading: true, gameFinished: false) // 2 case let setCardsAction as SetCardsAction: state.memoryCards = generateNewCards(with: setCardsAction.cardImageUrls) state.showLoading = false default: break } return state</span></span></code> </pre><br>   state  ,     ,    : <br><br><ol><li>  FetchTunesAction  showLoading   true. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In SetCardsAction, cards are randomly selected and showLoading is set to false. </font><font style="vertical-align: inherit;">generateNewCards can be found in the file </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryGameLogic.swift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the file that is included in the starting project.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's time to lay out the cards in GameViewController. </font><font style="vertical-align: inherit;">Start by creating a cell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CardCollectionViewCell.swift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">and add the following method to the end of the CardCollectionViewCell:</font></font><br><br><pre> <code class="objectivec hljs">func configureCell(with cardState: MemoryCard) { let url = URL(string: cardState.imageUrl) <span class="hljs-comment"><span class="hljs-comment">// 1 cardImageView.kf.setImage(with: url) // 2 cardImageView.alpha = cardState.isAlreadyGuessed || cardState.isFlipped ? 1 : 0 }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configureCell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">performs the following actions:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uses the excellent </font></font><a href="https://github.com/onevcat/Kingfisher"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingfisher</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">for caching images.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shows the map if it is guessed or flipped. </font></font></li></ol><br>       .  ,     ,     <b>UICollectionView</b>   <b>CollectionDataSource</b> ,      . <br><br>  <b>GameViewController.swift</b>    UIKit : <br><br><pre> <code class="objectivec hljs">import ReSwift</code> </pre><br>  GameViewController       showGameFinishedAlert: <br><br><pre> <code class="objectivec hljs">var collectionDataSource: CollectionDataSource&lt;CardCollectionViewCell, MemoryCard&gt;? override func viewWillAppear(_ animated: Bool) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillAppear(animated) store.subscribe(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { $<span class="hljs-number"><span class="hljs-number">0.</span></span>select { $<span class="hljs-number"><span class="hljs-number">0.</span></span>gameState } } } override func viewWillDisappear(_ animated: Bool) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillDisappear(animated) store.unsubscribe(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } override func viewDidLoad() { <span class="hljs-comment"><span class="hljs-comment">// 1 store.dispatch(fetchTunes) collectionView.delegate = self loadingIndicator.hidesWhenStopped = true // 2 collectionDataSource = CollectionDataSource(cellIdentifier: "CardCell", models: [], configureCell: { (cell, model) -&gt; CardCollectionViewCell in cell.configureCell(with: model) return cell }) collectionView.dataSource = collectionDataSource }</span></span></code> </pre><br>  ,       ,     StoreSubscriber.    gameState  viewWillAppear    viewWillDisappear.  viewDidLoad   : <br><br><ol><li>  fetchTunes      iTunes API. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cells are configured using the CollectionDataSource, which gets the appropriate model for configureCell. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you need to add an extension to execute StoreSubscriber. </font><font style="vertical-align: inherit;">Add the following to the bottom of the file:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// MARK: - StoreSubscriber extension GameViewController: StoreSubscriber { func newState(state: GameState) { collectionDataSource?.models = state.memoryCards collectionView.reloadData() // 1 state.showLoading ? loadingIndicator.startAnimating() : loadingIndicator.stopAnimating() // 2 if state.gameFinished { showGameFinishedAlert() store.dispatch(fetchTunes) } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This activates newState to handle state changes. </font><font style="vertical-align: inherit;">The data source is updated as well:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The status of the load indicator is updated depending on the state. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Restart the game and display a warning when the game is over. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile and run the game, select </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Game</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and now you can see the maps.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Play </font></font></h3><br>       .   ,   ,  ,   .   ‚Äî       . <br><br>      .  <b>FlipCardAction.swift</b>   : <br><br><pre> <code class="objectivec hljs">import ReSwift <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FlipCardAction: Action { let cardIndexToFlip: Int }</code> </pre><br> FlipCardAction  cardIndexToFlip   GameState   . <br><br>  gameReducer   FlipCardAction     .  <b>GameReducer.swift</b>      default: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let flipCardAction as FlipCardAction: state.memoryCards = flipCard(index: flipCardAction.cardIndexToFlip, memoryCards: state.memoryCards) state.gameFinished = hasFinishedGame(cards: state.memoryCards)</code> </pre><br>  FlipCardAction, flipCard    Memory    cardIndexToFlip    . hasFinishedGame ,  ,       .      <b>MemoryGameLogic.swift</b> . <br><br>    ‚Äî      .         . <br><br>   <b>GameViewController.swift</b>   UICollectionViewDelegate.    collectionView (_:didSelectItemAt:): <br><br><pre> <code class="objectivec hljs">store.dispatch(FlipCardAction(cardIndexToFlip: indexPath.row))</code> </pre><br>           indexPath.row    FlipCardAction. <br><br>  Run the game.  Now you can play.    ! :] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/024/7c1/b4c0247c1c1270c8abe69f111f50bdce.png" width="281" height="500" alt="   "></div><br><h3>  What's next? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can download the final version of the MemoryTunes application </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is still much to learn about ReSwift.</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : There is currently no good way to handle </font></font><a href="https://en.wikipedia.org/wiki/Cross-cutting_concern"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cross CuttingConcern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Swift. </font><font style="vertical-align: inherit;">In ReSwift, you get it for free! </font><font style="vertical-align: inherit;">You can solve various tasks using the </font></font><a href="https://reswift.github.io/ReSwift/master/getting-started-guide.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middleware</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">available in ReSwift. </font><font style="vertical-align: inherit;">This makes it easy to handle logging, statistics, and caching.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation interface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You have implemented your own navigation for the MemoryTunes application. </font><font style="vertical-align: inherit;">You can use a more general solution, such as </font></font><a href="https://github.com/ReSwift/ReSwift-Router"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReSwift-Router</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is still an open problem and maybe you will be one of those who will solve it ?:]</font></font></li><li> <b></b> : ReSwift, ,      . Reducers  ,        .             ,          . </li><li> <b></b> :  ,   ReSwift       ,   .    <a href="https://github.com/ReSwift/ReSwift-Recorder"></a>  ,   . </li><li> <b>Persistence</b> .         ,       .      ‚Äî   .  ReSwift     . </li><li> <b> </b> :   Redux   :  .       ReSwift   ,   <a href="https://github.com/BendingSpoons/katana-swift">Katana</a>  <a href="https://github.com/ReduxKit/ReduxKit">ReduxKit</a> . </li></ul><br>         ,  <a href="https://realm.io/news/benji-encz-unidirectional-data-flow-swift/">ReSwift talk</a> ‚Äî    (Benjamin Encz),  ReSwift <br><br>  <a href="https://github.com/ReSwift/ReSwift">ReSwift's</a>      . , ,   <a href="http://christiantietze.de/posts/2016/01/reswift-level-indirection/">Christian Tietze's blog</a>      ReSwift. <br><br>     - ,   ,      ! </div><p>Source: <a href="https://habr.com/ru/post/349714/">https://habr.com/ru/post/349714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349700/index.html">OWASP Automated Threat: Automated Web Application Threats</a></li>
<li><a href="../349704/index.html">We expand the bundle of Nginx + Php-Fpm + MySQL with magento2 on board and decompose it in containers in the Docker</a></li>
<li><a href="../349706/index.html">Kill the Dragon: The Thorny Path to Agile</a></li>
<li><a href="../349708/index.html">We focused on the client (and not on competitors) - and over the year received over a million new users</a></li>
<li><a href="../349710/index.html">How not to go crazy in the development of regulatory information management systems. From the history of our projects</a></li>
<li><a href="../349716/index.html">A Cloud Guru portal interview with Kelsey Hightower: about DevOps, Kubernetes and serverless</a></li>
<li><a href="../349718/index.html">Creating a game on Lua and L√ñVE - 3</a></li>
<li><a href="../349720/index.html">Authorization using ssl certificate on nginx + Let's Encrypt</a></li>
<li><a href="../349722/index.html">How we built VDI with 14,000 jobs for the VTB Group</a></li>
<li><a href="../349724/index.html">How we improved technical support with cohort analysis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>