<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to improve Linker implementation in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each proger surely used the ‚ÄúLinker‚Äù pattern, and most of us also faced the need to implement it in our project. And often it turns out that each of i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to improve Linker implementation in .NET</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/aaf988d9/cb613c37/6411a7a0/dc714175.png" align="right"><br>  Each proger surely used the ‚ÄúLinker‚Äù pattern, and most of us also faced the need to implement it in our project.  And often it turns out that each of its implementation imposes special requirements on the business logic to be defined, and from the point of view of working with a hierarchical structure, we want to have an equally wide range of possibilities: Add and Remove methods are often not enough, so why not add Contains, Clear and a dozen others?  And if you still need special methods for traversing subtrees through iterators?  And I want to have such functionality for various independent hierarchies, and also not to burden myself with the need to determine the implementation of such methods in each of the many Composite elements.  Well, the sheet components, too, would not hurt to simplify. <br><br>  Below, I will offer my own solution to this problem, as applied to C # features. <br><a name="habracut"></a><br><br>  So, we have the interface type Component, which is <i>overloaded with two areas of responsibility</i> : one defines the business logic - that is why the hierarchy was built;  the second provides transparent interaction in the hierarchy and manages descendants for composite elements.  Let's try to put one of them into a separate interface, which can be accessed by the property of the Children component (or the GetChildren method).  In the object that is returned by the property, all operations on the collection will be collected, including enumeration, addition and removal of child elements, as well as everything that we want. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage1/b5fadff2/55584897/9a3cf2ca/dab92ba5.png"><br><br>  We also defined the IsComposite property (method) to get a quick and readable check for whether the element is composite or sheet.  You can not use this property: then, when you try to change the collection of child elements, a NotSupportedException will be thrown for the sheet component.  Thus, we do not lose the <i>interface transparency for all components</i> - the main advantages of the ‚ÄúLinker‚Äù pattern - and at the same time we get an easy way to determine if any selected component can have child elements. <br><br>  Now we will try to determine the implementation of the IComponent interface, which would be well adapted for possible changes, and therefore applicable for building various hierarchies. <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">using</font> System.Collections.Generic; <br> <font color="#0000ff">using</font> System.Diagnostics.Contracts; <br> <font color="#0000ff">namespace</font> ComponentLibrary <br> { <br> [ContractClass( <font color="#0000ff">typeof</font> (IComponentContract))] <br> <font color="#0000ff">public</font> <font color="#0000ff">interface</font> IComponent&lt; <font color="#0000ff">out</font> TComponent, <font color="#0000ff">out</font> TChildrenCollection&gt; <br> <font color="#0000ff">where</font> TComponent : IComponent&lt;TComponent, TChildrenCollection&gt; <br> <font color="#0000ff">where</font> TChildrenCollection : <font color="#0000ff">class</font> , <font color="#2B91AF">IEnumerable</font> &lt;TComponent&gt; <br> { <br> TChildrenCollection Children { <font color="#0000ff">get</font> ; } <br> <font color="#0000ff">bool</font> IsComposite { <font color="#0000ff">get</font> ; } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  What is the interface implemented as a template from and what kind of parameters does it take?  In fact, the idea is very simple: to introduce strong typing where the actual types are not yet known. <br><br>  <i>TComponent</i> is just the actual type of that child interface (or class in a more closely related architecture) that you inherit from IComponent to add Operation () responsibilities to it. <br><br>  <i>TChildrenCollection</i> is the collection interface that you implement to access the children.  In this interface, at least only GetEnumerator () should be defined, through which you can get a collection iterator.  The fact is that sometimes it is not necessary to provide methods like Add () and Remove (), since  all elements can be added in the constructor, and the hierarchical structure itself should not be changed after creation.  And if you suddenly need a collection change notification, pass ObservableCollection &lt;TComponent&gt; as TChildrenCollection, and the trick is done! <br><br>  In a type contract, we specify the following restrictions on the return value of the Children property: 1) the returned collection is not null;  2) none of its elements is null;  3) the component is either listed as composite or does not contain any child elements.  For brevity, the contract code is not given here. <br><br>  Remember, we said that we would like to endow each component with an additional method that returns an iterator that implements the complex logic of traversing a subtree?  Suppose that we wrote such an iterator ComponentDescendantsEnumerator &lt;TComponent&gt; (its code can be downloaded from the link at the end of the article), and then wrapped it into the ComponentDescendantsEnumerable &lt;TComponent&gt; class, defining IEnumerable &lt;TComponent&gt;.  Now you need to decide where to place the methods that return such iterators?  Fortunately, C # has a very useful mechanism - extension methods.  Let's try to apply it. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">namespace</font> ComponentLibrary.Extensions <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> ComponentExtensions <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">IEnumerable</font> &lt;T&gt; GetDescendants&lt;T&gt;( <font color="#0000ff">this</font> T component) <br> <font color="#0000ff">where</font> T : IComponent&lt;T, <font color="#2B91AF">IEnumerable</font> &lt;T&gt;&gt; <br> { <br> <font color="#008000">//    </font> <br> <font color="#0000ff">return</font> <font color="#0000ff">new</font> ComponentDescendantsEnumerable&lt;T&gt;(component); <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  We implement an extension method in a separate namespace - so we can call it like a method belonging to the IComponent &lt;,&gt; interface only when we import this namespace. <br><br>  Then we have another task: we need to implement a way to get collections that never contain elements, and for all change requests (like Add / Remove) throw a NotSupportedException.  First, we will create one such collection that implements the ICollection &lt;T&gt;.  However, if the collection never changes and is always created empty, then there is no point in doing more than one such collection for the entire program (or rather, on the AppDomain).  The perfect occasion to take advantage of the Singleton pattern!  (the implementation of the class Singleton &lt;T&gt; can be found in the attached source code) <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">sealed</font> <font color="#0000ff">internal</font> <font color="#0000ff">class</font> ItemsNotSupportedCollection&lt;T&gt; : <br> Singleton&lt;ItemsNotSupportedCollection&lt;T&gt;&gt;, <br> ICollection&lt;T&gt; <br> { <br> <font color="#0000ff">private</font> ItemsNotSupportedCollection() { } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> Count { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> 0; } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> IsReadOnly { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> Contains(T item) { <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> CopyTo(T[] array, <font color="#0000ff">int</font> arrayIndex) { } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Add(T item) { <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotSupportedException(); } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Clear() { <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotSupportedException(); } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> Remove(T item) { <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotSupportedException(); } <br> <br> <font color="#0000ff">public</font> IEnumerator&lt;T&gt; GetEnumerator() <br> { <br> <font color="#0000ff">return</font> ItemsNotSupportedEnumerator&lt;T&gt;.Instance; <br> } <br> <br> IEnumerator <font color="#2B91AF">IEnumerable</font> .GetEnumerator() <br> { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .GetEnumerator(); } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  For the sake of transparency, the iterator class used represents the iterator of an empty collection, so one of its copies is also sufficient - again, Singleton. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">sealed</font> <font color="#0000ff">internal</font> <font color="#0000ff">class</font> ItemsNotSupportedEnumerator&lt;T&gt; : <br> Singleton&lt;ItemsNotSupportedEnumerator&lt;T&gt;&gt;, <br> IEnumerator&lt;T&gt; <br> { <br> <font color="#0000ff">private</font> ItemsNotSupportedEnumerator() { } <br> <br> <font color="#0000ff">public</font> T Current { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">default</font> (T); } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() { } <br> <br> <font color="#0000ff">object</font> IEnumerator.Current { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> MoveNext() { <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Reset() { <font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotSupportedException(); } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  It remains only to create a static property that is visible from the outside of the assembly and returns a read-only collection of elements for the ICollection &lt;T&gt; interface. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> ComponentCollections&lt;TComponent&gt; <br> <font color="#0000ff">where</font> TComponent : IComponent&lt;TComponent, <font color="#2B91AF">IEnumerable</font> &lt;TComponent&gt;&gt; <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> ICollection&lt;TComponent&gt; EmptyCollection <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#008000">//   </font> <br> <font color="#0000ff">return</font> ItemsNotSupportedCollection&lt;TComponent&gt;.Instance; <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  The time has come for the most interesting: the use of our mini-library to create a specific class hierarchy.  Suppose you need to organize a menu system consisting of: MenuCommand is a specific command, and Menu is a submenu that can contain other commands and submenus.  All classes are located in a separate assembly.  The sixth sense suggests that the ‚ÄúLinker‚Äù pattern would have been useful here. <br><br><img src="https://habrastorage.org/storage1/ad613213/c973b92d/192e58a9/f2c9cc0b.png"><br><br>  First, we define an interface common to all classes of the hierarchy.  Inside the interface, we define only the methods and properties required by the business logic of our menu (in this case, each element has a name and is able to display itself with the specified indentation). <br><br><img src="https://habrastorage.org/storage1/236d7132/d663c991/4fb41c6a/434a993d.png"><br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">namespace</font> MenuLibrary <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">interface</font> IMenuItem : <br> IComponent&lt;IMenuItem, ICollection&lt;IMenuItem&gt;&gt; <br> { <br> <font color="#0000ff">string</font> Name { <font color="#0000ff">get</font> ; } <br> <font color="#0000ff">void</font> Display( <font color="#0000ff">int</font> indent = 0); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  As a TComponent parameter-type, we always pass the interface of the components (that is, the same IMenuItem), and the TChildrenCollection - the interface of the implemented collection.  We could create a custom interface for the TChildrenCollection, which defines the Add, Remove and GetChild methods (and also GetEnumerator), as in the classic version of the pattern.  You can send for example IList &lt;IMenuItem&gt;, but we decided that here the standard ICollection &lt;IMenuItem&gt; interface suits us. <br><br>  This is how we define the MenuCommand leaf component: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> MenuCommand : IMenuItem <br> { <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> <font color="#0000ff">string</font> name; <br> <br> <font color="#0000ff">public</font> MenuCommand( <font color="#0000ff">string</font> name) <br> { <br> <font color="#008000">//   </font> <br> <font color="#0000ff">this</font> .name = name; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> Name { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .name; } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Display( <font color="#0000ff">int</font> indent = 0) <br> { <br> <font color="#0000ff">string</font> indentString = MenuHelper.GetIndentString(indent); <br> <font color="#2B91AF">Console</font> .WriteLine( <font color="#A31515">"{1}{0} [Command]"</font> , <font color="#0000ff">this</font> .name, indentString); <br> } <br> <br> <font color="#0000ff">public</font> ICollection&lt;IMenuItem&gt; Children <br> { <br> <font color="#0000ff">get</font> { <font color="#0000ff">return</font> ComponentCollections&lt;IMenuItem&gt;.EmptyCollection; } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> IsComposite { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; } } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  The Children property returns the previously declared ‚Äúsingleton‚Äù collection for leaf elements.  Now we will declare the composite component Menu. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> Menu : IMenuItem <br> { <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> ICollection&lt;IMenuItem&gt; children = <br> <font color="#0000ff">new</font> <font color="#2B91AF">List</font> &lt;IMenuItem&gt;(); <br> <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> <font color="#0000ff">string</font> name; <br> <br> <font color="#0000ff">public</font> Menu( <font color="#0000ff">string</font> name) <br> { <br> <font color="#008000">//    </font> <br> <font color="#0000ff">this</font> .name = name; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> Name { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .name; } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Display( <font color="#0000ff">int</font> indent = 0) <br> { <br> <font color="#0000ff">string</font> indentString = MenuHelper.GetIndentString(indent); <br> <font color="#2B91AF">Console</font> .WriteLine( <font color="#A31515">"{1}{0} [Menu]"</font> , <font color="#0000ff">this</font> .name, indentString); <br> <font color="#0000ff">int</font> childrenIndent = indent + 1; <br> <font color="#0000ff">foreach</font> (IMenuItem child <font color="#0000ff">in</font> <font color="#0000ff">this</font> .children) <br> { <br> child.Display(childrenIndent); <br> } <br> } <br> <br> <font color="#0000ff">public</font> ICollection&lt;IMenuItem&gt; Children <br> { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .children; } } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> IsComposite { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; } } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Children unexpectedly returns the used standard List &lt;T&gt; collection.  This is a good move if the user of our hierarchy is allowed to bring the type of the Children object to a List &lt;T&gt; and use all the advanced features of this class.  But if such an alignment is not allowed, then you need to wrap List &lt;T&gt; into some internal class that implements only ICollection &lt;T&gt; and is not accessible to other assemblies (or even classes). <br><br>  Now we will test the code written by us. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">using</font> System; <br> <font color="#0000ff">using</font> System.Linq; <br> <font color="#0000ff">using</font> ComponentLibrary.Extensions; <br> <font color="#0000ff">using</font> MenuLibrary; <br> <font color="#0000ff">namespace</font> MenuTest <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> MenuTest <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> Perform() <br> { <br> <font color="#008000">//   </font> <br> IMenuItem rootMenu = <font color="#0000ff">new</font> Menu( <font color="#A31515">"Root"</font> ); <br> <font color="#008000">// ...  File</font> <br> IMenuItem fileMenu = <font color="#0000ff">new</font> Menu( <font color="#A31515">"File"</font> ); <br> fileMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"New"</font> )); <br> fileMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Open"</font> )); <br> <font color="#008000">// ...  File-&gt;Export</font> <br> IMenuItem fileExportMenu = <font color="#0000ff">new</font> Menu( <font color="#A31515">"Export"</font> ); <br> fileExportMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Text Document"</font> )); <br> fileExportMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Binary Format"</font> )); <br> fileMenu.Children.Add(fileExportMenu); <br> <font color="#008000">// ...  File</font> <br> fileMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Exit"</font> )); <br> rootMenu.Children.Add(fileMenu); <br> <font color="#008000">// ...  Edit</font> <br> IMenuItem editMenu = <font color="#0000ff">new</font> Menu( <font color="#A31515">"Edit"</font> ); <br> editMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Cut"</font> )); <br> editMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Copy"</font> )); <br> editMenu.Children.Add( <font color="#0000ff">new</font> MenuCommand( <font color="#A31515">"Paste"</font> )); <br> rootMenu.Children.Add(editMenu); <br> <font color="#008000">//    </font> <br> rootMenu.Display(); <br> <font color="#2B91AF">Console</font> .WriteLine(); <br> <font color="#008000">//       ,</font> <br> <font color="#008000">//   Root,    "E"  "R"</font> <br> <font color="#0000ff">var</font> compositeMenuNames = <br> <font color="#0000ff">from</font> menu <font color="#0000ff">in</font> rootMenu.GetDescendants() <br> <font color="#0000ff">where</font> menu.IsComposite <br> &amp;&amp; (menu.Name.StartsWith( <font color="#A31515">"E"</font> ) || menu.Name.StartsWith( <font color="#A31515">"R"</font> )) <br> <font color="#0000ff">select</font> menu.Name; <br> <font color="#0000ff">foreach</font> ( <font color="#0000ff">string</font> menuName <font color="#0000ff">in</font> compositeMenuNames) <br> { <br> <font color="#2B91AF">Console</font> .WriteLine(menuName); <br> } <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Note the LINQ query on the enumeration returned by the GetDescendants () extension method.  Let's look at the result of the work. <br><br><img src="https://habrastorage.org/storage1/7c888dd8/c99a77b0/473d08c4/7a770ee5.png"><br><br>  That's how simple it is.  Moreover, in the logic of the developed components, the entire attention of the designer is focused on the construction of business logic, and not on the hierarchical structure or classes of containers. <br><br>  <b>Link to sources:</b> <a href="">http://www.fileden.com/files/2011/10/7/3205975/ComponentLibrary.zip</a> <br><br>  <b>PS</b> If something did not seem obvious to you, or you would like to look at a variant of the implementation of a hierarchy that is read-only, then you can refer to an <a href="http://sergeyalikin.blogspot.com/2011/10/net.html">extended version of</a> the same post. <br><br>  <b>PPS</b> To be honest, I hope that in the comments someone will offer a better implementation of Linker than me. <br><br>  <b>UPD</b> As <a href="https://habrahabr.ru/users/avalter/" class="user_link">avalter</a> correctly noted, here I just applied the Extract Interface, Extract Class to the Linker and used NullObject (it is advisable to finish the Extract Class, render the used collection of composite components and encapsulate it into a separate class).  The result is not just Linker, but a more flexible structure. <br><br>  <b>I do not advise to implement the pattern in this way from scratch in any way!</b>  But you can take the ComponentLibrary assembly code, copy it into your project and automatically get some advantages for your hierarchy: ready-made Null-Object collections for leaf elements, additional iterators for circumventing the structure, as well as a contract for the IComponent interface that was mentioned briefly here.  So  when implementing a new hierarchy similar to IMenuItem, one can only think about the logic of the Display () methods, if the structure interfaces implemented in the ComponentLibrary are sufficient (otherwise define your implementations). </div><p>Source: <a href="https://habr.com/ru/post/130012/">https://habr.com/ru/post/130012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130003/index.html">Intrusive localization</a></li>
<li><a href="../130004/index.html">Creating a color picker from an HTML5 image</a></li>
<li><a href="../130006/index.html">How to avoid problems with firmware LG P500 Optimus One</a></li>
<li><a href="../130008/index.html">OpenStreetMap News ‚Ññ8</a></li>
<li><a href="../130011/index.html">Cave technology of the future</a></li>
<li><a href="../130013/index.html">Cross-Site Content Forgery on Facebook</a></li>
<li><a href="../130014/index.html">Remote procedure call in Node.js using Now.js</a></li>
<li><a href="../130015/index.html">The virus got into the control system of American drone</a></li>
<li><a href="../130017/index.html">Washington County Schools Use Fingerprint Scanners</a></li>
<li><a href="../130018/index.html">Re: Virtual store in the Korean subway</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>