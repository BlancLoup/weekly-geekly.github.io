<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ways to present dictionaries for automatic text processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Automatic text analysis is almost always associated with work with dictionaries. They are used for morphological analysis, highlighting persons (dicti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ways to present dictionaries for automatic text processing</h1><div class="post__text post__text-html js-mediator-article">  Automatic text analysis is almost always associated with work with dictionaries.  They are used for morphological analysis, highlighting persons (dictionaries of personal names and surnames are needed) and organizations, as well as other objects. <br><br>  In general, a dictionary is a set of records of the form {string, data associated with this string}. <br><br>  For example, for morphological analysis, the dictionary consists of triples {word form, normal form, morphological characteristics}.  When analyzing the word ‚Äúsoap‚Äù from the sentence ‚Äúmom soap frame‚Äù one should be able to get the following analysis options: <br><table><tbody><tr><th>  Normal form </th><th>  Specifications </th></tr><tr><td>  SOAP </td><td>  S (noun), genus (genitive), ED (singular), MEDIUM (neuter gender), NEOD <br>  (inanimateness) </td></tr><tr><td>  SOAP </td><td>  S (noun), IM (nominative case), MN (plural), MEDIUM (neuter gender), NEOD (inanimateness) </td></tr><tr><td>  SOAP </td><td>  S (noun), VIN (accusative), MN (plural), MEDIUM (neuter gender), NEOD (inanimateness) </td></tr><tr><td>  WASH </td><td>  V (verb), PROSH (past tense), ED (singular), CONVERSION (indicative mood), WIFE (feminine), NESOV (imperfect form) </td></tr></tbody></table>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h1>  Hash tables </h1><br>  At first glance, everything is simple.  It is necessary to use a hash table and deal with the end.  When the dictionary is small this solution is very simple and effective. <br><br>  However, for example, the morphological dictionary of the Russian language contains about 5 million word forms.  Turns out that: <br><ul><li>  We must keep these 5 million word forms. </li><li>  For each word form there should be a link to a set of morphological characteristics. </li><li>  For each word form store its initial form </li></ul><br>  This way of organizing data is uneconomical, because, firstly, words tend mostly regularly, and, secondly, in the case of the Russian language, within a single dictionary entry, subgroups of word forms can be distinguished, in which the form itself changes slightly or does not change at all . <br><br>  For example, the word "wall": <br><ul><li>  units  h: ‚Äúwalls <b>a</b> ‚Äù [them], ‚Äúwalls <b>s</b> ‚Äù [genus], ‚Äúwalls <b>e</b> ‚Äù [dates], ‚Äúwalls <b>y</b> ‚Äù [wines], ‚Äúwalls <b>oh</b> ‚Äù [creat], ‚Äúwalls <b>oy</b> ‚Äù [pieces], ‚ÄúWall <b>e</b> ‚Äù [pred]; </li><li>  mn  h: ‚Äúwalls <b>s</b> ‚Äù [them], ‚Äúwalls‚Äù [genus], ‚Äúwalls <b>am</b> ‚Äù [dates], ‚Äúwalls <b>s</b> ‚Äù [wines], ‚Äúwalls <b>am</b> ‚Äù [creation], ‚Äúwalls <b>ah</b> ‚Äù [pred]. </li></ul><br>  It can be seen that only the ending changes, but the entire word must be stored in the hash table. <br><br>  It is possible to separately store the bases (unchangeable parts) and endings, but in this case word verification becomes more complicated. <br><br><h1>  From prefix tree to finite automata </h1><br>  For clarity of examples, we will consider a simpler task, when for each word form in the analysis it is necessary to obtain only its morphological features.  How to store the normal form will be described at the end. <br><br>  Compared to hash tables, a more compact representation is the prefix tree (trie): <br><br><img src="https://habrastorage.org/storage2/60e/fb3/cde/60efb3cde7c031270bd004704ea494f3.png"><br><br>  Important note - the figures will not show the sets of signs associated with each end node of the tree (or the state of the finite state machine).  For example, in the figure, node 6, where we will get on the ‚Äúwall‚Äù line, there will actually be 3 parses: <br><ul><li>  singular, genitive; </li><li>  plural, nominative .; </li><li>  plural, accusative. </li></ul><br><br>  A prefix tree can be considered as a finite state machine. <br><br>  In the machine there are three types of states: <br><ul><li>  The initial ones are those with which the work with an automatic machine begins.  In a deterministic automaton, this state is one, but in a non-deterministic one there can be several.  In the figures, this is the leftmost state with the number 0. </li><li>  Final - such states, the achievement of which means that there is such a word in the dictionary.  They are denoted by a double circle. </li><li>  Simple states that are neither initial nor final </li></ul><br>  In the following, the notation will be used: <br><ul><li>  line is denoted by w </li><li>  w [i] - i-th character of the given word (starting from 0). </li><li>  s [i] is the i-th node of the tree (or the state of the automaton), states are numbered with non-negative integers, we also assume that s [0] is the initial state. </li><li>  s [i] [j] - the transition from the state s [i] on the symbol j.  We assume that if there is a transition, then such an expression will return a state number, if not, then it will return -1. </li></ul><br><br>  I will give the basic algorithms for the prefix tree / finite automaton .: <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      //    ()  int[] prefix(w) { int[] stateList; //         stateList[0] = 0; int current = 0; for(int i = 0; i &lt; length(w); i++) { int next = s[current][w[i]] //   ,   if(next == -1) break; stateList[i+1] = next; } return stateList; } //      //      stateList void addSuffix(w, int[] stateList) { //        int current = stateList[length(stateList) - 1]; for(int i = length(stateList) - 1; i &lt; length(w); i++) { //      int newState = addState(); //    s[current][w[i]] = newState; current = newState; //      stateList[i + 1] = current; } //     s[current] setFinal(current); } //     trie void add(w) { //     int[] prefixStates = prefix(w); //      addSuffix(w, prefixStates) }</span></span></code> </pre> <br><br>  The representation of a prefix tree as a finite state machine has important properties: <br><ul><li>  such an automaton is determined - from each state there can be no more than one transition on a certain symbol </li><li>  there are no cycles in it - with any method of bypassing the automaton, no state is visited more than once. </li></ul><br>  Such a special automaton is called a DAFSA (deterministic acyclic finite state automaton). <br><br>  It is necessary to make one more important remark.  For convenience of presentation and for practical use, we will assume that the state is described not only by the transition table, but also by the data on the final state.  And we will assume that the state is final, if there is such data in it, and not - if they are absent. <br><br><h1>  Minimum state machines </h1><br>  Using prefix trees eliminates redundancy of prefixes.  In fact, this means that the storage volume of the unchangeable part of the word is reduced.  However, for example, in Russian, the end of a word changes mostly regularly. <br><br>  For example, the words "arrow" and "wall" change in the same way: <br><br>  WALL: units  h: ‚Äúwall‚Äù [im], ‚Äúwall‚Äù [gender], ‚Äúwall‚Äù [dates], ‚Äúwall‚Äù [wine], ‚Äúwall‚Äù [creator], ‚Äúwall‚Äù [creator], ‚Äúwall‚Äù [suggestion] ;  mn  h: "walls" [im], "walls" [genus], "walls" [dates], "walls" [wines], "walls" [creation], "walls" [pred]. <br><br>  BOOM: units  h: ‚Äúarrow‚Äù [them], ‚Äúarrows‚Äù [gender], ‚Äúarrow‚Äù [dates], ‚Äúarrow‚Äù [wines], ‚Äúarrow‚Äù [creative], ‚Äúarrow‚Äù [creative], ‚Äúarrow‚Äù [suggestion] ;  mn  h: ‚Äúarrows‚Äù [them], ‚Äúarrows‚Äù [gender], ‚Äúarrows‚Äù [dates], ‚Äúarrows‚Äù [wines], ‚Äúarrows‚Äù [creation], ‚Äúarrows‚Äù [pred]. <br><br><img src="http://habrastorage.org/storage2/1a0/469/73d/1a046973d9cd0f6b5decfec45f56d11a.png"><br><br>  It is seen that states 4 and 17, from which the endings begin, are equivalent for both words.  Obviously, there will be many words with the same inflection rules in the dictionary.  So you can significantly reduce the number of states. <br><br>  Actually, in the theory of automata there is the concept of a minimal automaton ‚Äî such an automaton that contains the minimum possible number of states but would be equivalent to this. <br><br>  For example, for the above automaton, the minimum looks like this: <br><img src="http://1450828003893513826557"><br><br>  There are also algorithms for minimization of finite automata, but they all have a significant drawback - for their work, it is necessary to first build a non-minimized automaton. <br><br>  Another less obvious drawback is that the constructed minimal automaton is not so easy to change.  The simple procedure for adding a new word that is used for a prefix tree does not fit it. <br><br>  For example, we built an automaton for the words "fox" and "box", and then minimized it. <br><br><img src="http://habrastorage.org/storage2/8bf/4c6/33a/8bf4c633a0c6401f2aa8fe4da19ec096.png"><br><br>  If you add the word ‚Äúfoxes‚Äù to this machine without complete rebuilding, you get the following picture: <br><br><img src="http://habrastorage.org/storage2/7e6/f11/841/7e6f11841bfa0cc9ced421cde3c6995d.png"><br><br>  It turns out that in the place with ‚Äúfoxes‚Äù added ‚Äúboxes‚Äù, which we did not add. <br><br>  As a result, the scheme of using classical minimization algorithms is as follows: for any change in the dictionary, it is necessary: <br><ul><li>  Build a prefix tree (or store) </li><li>  Minimize machine </li></ul><br>  If the dictionary is large, then these procedures can take considerable time and memory. <br><br><h1>  Incremental minimization of deterministic acyclic finite automata </h1><br>  The solution to the difficulties with minimizing automata is presented in the work: <a href="http://aclweb.org/anthology-new/J/J00/J00-1002.pdf">Jan Daciuk;</a>  <a href="http://aclweb.org/anthology-new/J/J00/J00-1002.pdf">Bruce W. Watson;</a>  <a href="http://aclweb.org/anthology-new/J/J00/J00-1002.pdf">Stoyan Mihov;</a>  <a href="http://aclweb.org/anthology-new/J/J00/J00-1002.pdf">Richard E. Watson.</a>  <a href="http://aclweb.org/anthology-new/J/J00/J00-1002.pdf">"Incremental Construction of Minimal Acyclic Finite-State Automata"</a> .  It presents an algorithm for incremental minimization of deterministic acyclic finite automata.  It allows changing the already constructed minimum automaton.  As a result, it is not necessary to build a full automaton, and then minimize it. <br><br>  Again, consider our machine WALL + BOOM: <br><img src="http://1450828003893513826557"><br><br>  An important concept of the algorithm is ‚Äúrow states‚Äù - this is a sequence of states, which is obtained by traversing an automaton on a given row. <br><br>  For example, when crawling a string with an arrow, we get the following sequence of states [0, 1, 2, 14, 15, 4, 9, 10]. <br><br>  Another important concept of this algorithm is the number of transitions to a given state (confluence).  If the number of transitions is more than one, then it is not safe to change this state.  In the figure, this is state 4: it has 2 incoming arrows. <br><br>  In addition, the algorithm assumes that there is a state registry that allows you to quickly get a state equal to this. <br><br>  As a result, the algorithm for adding the word w looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMinWord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    w     int[] stateList = commonPrefix(w); //         int confIdx = findConfluence(stateList); //       if(confIdx &gt; -1) { int idx = confIdx; while(idx &lt; length(stateList)) { int prev = stateList[idx - 1]; int cloned = cloneState(stateList[idx]); stateList[idx] = cloned; //     //        s[prev][w[idx - 1]] = cloned; idx++; confIdx++; } } //   addSuffix(w, stateList); //    ,    . //  ,     replaceOrRegister(w, nodeList); } void replaceOrRegister(w, int[] stateList) { int stateIdx = length(stateList) - 1; int wordIdx = length(w) - 1; //      while(stateIdx &gt; 0) { int state = stateList[stateIdx]; //    ,  state int regState = registerGet(state); if(regState == state) { //    state  ,     continue; } else if(regState == -1) { //     ,      registerAdd(state); } else { //  ,     ,  state int in = w[wordIdx]; //   s[stateList[stateIdx - 1]][in] = regState; //      stateList[stateIdx] = regState; //      removeState(state); } wordIdx--; stateIdx--; } }</span></span></code> </pre><br><br><h2>  Illustration of the algorithm </h2><br><br>  Consider the simple case when the final state is a binary sign.  Condition or final or not. <br><br>  Machine for the string "fox". <br><img src="http://habrastorage.org/storage2/e88/b71/568/e88b7156804a5707cbed8e63fbe28a76.png"><br>  It is seen that the machine is minimal, in the registry are all the states [0,1,2,3] <br><br>  Add to it the word "box".  Since they do not have a common prefix, we add the entire line as a suffix.  As a result, we get: <br><img src="http://habrastorage.org/storage2/00c/1b3/b7b/00c1b3b7b4cfc078034f2617eb0afc01.png"><br><br>  You may notice that states 3 and 6 are equal.  Replace 6 with 3: <br><img src="http://habrastorage.org/storage2/20e/68e/769/20e68e7692337517fc9eb812068707ec.png"><br><br>  Now you can see that they are equal to 2 and 5. Replace 5 with 2: <br><img src="http://habrastorage.org/storage2/b6e/ae5/bf8/b6eae5bf8abf8de9ea4ae5d646313a63.png"><br><br>  And now it is clear that they are equal to 1 and 4. Replace 4 with 1: <br><img src="http://habrastorage.org/storage2/7f4/da9/3b1/7f4da93b1250098c6aacc82818eacd2e.png"><br><br>  Add the line "foxes".  When calculating the prefix, we found that the states [0, 1, 2, 3] are the prefix path. <br>  In addition, they found that state 1 includes more than one transition.  As a result, it is necessary to clone states 1, 2 and 3 along the path of bypassing the word ‚Äúfox‚Äù, because if we simply add ‚Äúfoxes‚Äù to the previous automaton, the string ‚Äúboxes‚Äù will be recognized, which we did not specify. <br><br><img src="http://habrastorage.org/storage2/3e3/a75/723/3e3a757237e9084d2e9993a35a94c4ed.png"><br><br>  Now add the ‚Äúboxes‚Äù: <br><br><img src="http://habrastorage.org/storage2/be4/c6d/5e8/be4c6d5e8528d3b173c9ad430ca6d7e9.png"><br><br>  When adding ‚Äúboxes‚Äù the machine became smaller.  This is, at first glance, an unexpected behavior, when, as new lines are added, the automaton actually decreases.  There is also a reverse behavior - when the machine increases when a line is deleted. <br><br>  For the correct operation of the algorithm, it is important to correctly implement the work with the registry.  The state is deleted from the registry when any change occurs in the state transition table and the sign of finality. <br><br>  In addition, in contrast to the usual set or table, in addition / deletion from the registry operates exactly this state, and the request is made for equal. <br><br><h1>  Practical use </h1><br>  The presented algorithm is used in the <a href="http://www.aot.ru/">AOT</a> project and in <a href="http://iitp.ru/ru/science/works/452.htm">the ETAP-3 system</a> for organizing a quick morphological analysis.  When using finite automata, an analysis speed of about 1-1.5 million words per second is achieved.  In this case, the size of the machine without special tricks fits into 8 MB. <br><br>  Previously described storing data strings as a sign of finality.  Consider this approach in more detail. <br><br><h2>  Data storage in the state of the machine </h2><br><br>  The approach assumes that these strings are treated as some kind of atomic object.  This in turn imposes restrictions on the efficiency of minimization of the automaton. <br><br>  For example, the procedure for constructing a minimum automaton is meaningless for perfect hashing, when a unique number is associated with a string.  Because in this case, each suffix will be unique, and accordingly, there will be no minimization, since each final state is unique. <br><br>  For morphological analysis, sets of morphological characteristics can be used as associated data.  This works well since there are few such sets relative to the total number of word forms.  For example, in Russian, depending on the model adopted, the number of such sets is 500-900.  A word forms 4-5 million <br><br>  However, the efficiency of minimization comes to naught if, in addition to the characteristics, to maintain the full normal form.  This is because the pair {normal form, morphological characteristics} is almost unique. <br><br>  In the ETAP-3 system, this approach is used to store morphological information.  The machine itself stores only sets of morphological signs.  And to store the normal form, use the following trick.  At the construction stage of the automaton, not one character, but two is used as an input symbol.  For example, adding the word form ‚Äúwall‚Äù (WALL in the instrumental case) will add the following sequence of pairs of characters: ‚Äúc: C‚Äù, ‚Äút: T‚Äù, ‚Äúe: E‚Äù, ‚Äún: H‚Äù, ‚Äúo: A‚Äù , "Th: _". <br><br>  All word forms of the words ‚Äúwall‚Äù and ‚Äúarrow‚Äù in such a machine will look like this: <br><br><img src="http://habrastorage.org/storage2/6ca/ec2/459/6caec2459ba8715538496c0a919f93f4.png"><br><br>  This approach to writing normal forms has an important advantage.  It allows you to work with morphology in two directions.  It is possible to get its analysis by word form - analysis.  And you can get all its word forms in normal form - synthesis. <br><br>  The disadvantage of this approach is that, despite the fact that for a couple of signs the automaton is deterministic, it is no longer as such for the input and it is necessary to iterate through all transitions from this state.  For example, the state m, in the figure above.  It has several transitions on the sign of the word form "a". <br><br><h2>  Data storage in transitions.  Using annotations </h2><br>  Another way to store additional data was described in the original work.  It involves changing the lines themselves, which are stored in the machine. <br><br>  Proposed transaction scheme.  Instead of the target line, an expanded line is written to the machine, which consists of the target line, the character of the beginning of the data (annotation symbol) and the data itself. <br><br>  For example, in this case, the morphological characteristics can be written as follows: ‚Äúwall | + ex + women + them, ...‚Äù, where '|'  - an annotation symbol, and "+ cus", "+ wives", "+ them" - special data characters. <br><br>  This approach is used in the AOT system.  It actually stores two references as data: to the morphological characteristics and to the number of the inflection rule.  As a result, the analysis can be obtained by the word form as its morphological features, and the initial form. <br><br>  A feature of this approach is that the model of the automaton is somewhat complicated.  The transition symbol is interpreted differently depending on whether it was before or after the annotation symbol. <br><br>  Another feature is that for a line break is somewhat more complicated.  First, the line is present in the automaton, if after its traversal we are in the state from which there is a transition by the annotation symbol.  Secondly, the procedure for collecting all annotations after the annotation symbol is necessary.  Third, an annotation decoding procedure is required. <br><br><h2>  Memory optimization </h2><br>  To optimize the amount of memory, two representations of finite automata are used: one for constructing a minimum automaton, and the other for analysis.  The difference between them is that the automaton for analysis does not imply changes and therefore can be more efficiently placed in memory. <br><br>  The machine for analysis consists of three structures: <ol><li>  transition table - pairs of integers {transition symbol, target state} </li><li>  indexes of the beginning and end of the state transition range </li><li>  final state data table </li></ol><br>  Machines are quite compact.  For example, the AOT dictionary without any special tricks takes about 8Mb.  The complete data of the system of morphological analysis, which include not only dictionary analysis, but also predictive analysis, the words fit into 16Mb. <br><br>  The minimization algorithms themselves are implemented in my project on Github: <a href="https://github.com/kzn/fsa">github.com/kzn/fsa</a> </div><p>Source: <a href="https://habr.com/ru/post/190694/">https://habr.com/ru/post/190694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190676/index.html">BMW Concept i8 Laser Lights</a></li>
<li><a href="../190680/index.html">Airi - the cloud for the site</a></li>
<li><a href="../190682/index.html">Deobfuscation of one malicious code</a></li>
<li><a href="../190690/index.html">Checklist for overcoming the CAP-theorem</a></li>
<li><a href="../190692/index.html">Microsoft integrates Skype with Outlook.com</a></li>
<li><a href="../190700/index.html">YAMD: another bike to describe modules in JS</a></li>
<li><a href="../190706/index.html">HTC Desire 600 dual sim - double bet</a></li>
<li><a href="../190708/index.html">FlexPod Express (aka ExpressPod)</a></li>
<li><a href="../190710/index.html">Android stores unencrypted Wi-Fi passwords on Google servers.</a></li>
<li><a href="../190712/index.html">Protection of IT solutions in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>