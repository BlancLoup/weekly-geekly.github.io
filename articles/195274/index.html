<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Co-op streams from scratch in 33 rows on Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell distinguishes itself from most functional languages ‚Äã‚Äãin that it has deep cultural roots from the field of mathematics and computer science, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Co-op streams from scratch in 33 rows on Haskell</h1><div class="post__text post__text-html js-mediator-article">  Haskell distinguishes itself from most functional languages ‚Äã‚Äãin that it has deep cultural roots from the field of mathematics and computer science, which give the deceptive impression that Haskell is not well suited for solving practical problems.  However, the more you know Haskell, the more you appreciate that theory is often the most practical solution to many common programming problems.  This article would like to emphasize this point of view by the fact that we mix the existing theoretical foundations and create a clean user flow system. <br><img src="https://habrastorage.org/storage3/284/d6d/fc1/284d6dfc19bf572fc54c67b6f8c3594f.jpg"><br><a name="habracut"></a><br><h4>  Type of </h4><br>  Haskell is a language where types are primary, so we start by choosing the appropriate type to represent streams.  First of all, we have to indicate in simple language which flows we want to make: <br><ul><li>  Threads must extend existing instruction sequences. </li><li>  Threads must support a set of operations: branching, transfer of control, and completion </li><li>  Threads must allow different types of schedulers. </li></ul><br>  Now we translate these concepts into Haskel: <br><ul><li>  When you hear "several interpreters / planners / backends" you should think "free" (as in "free object") </li><li>  When you hear the ‚Äúsequence of commands‚Äù you should think: ‚Äúmonads‚Äù. </li><li>  When you want to ‚Äúexpand‚Äù something you have to think: ‚Äútransformers‚Äù. </li></ul><br>  Combine these words together and you will get the right mathematical solution: ‚Äúfree monad transformer‚Äù. <br><br><h5>  Syntax tree </h5><br>  ‚ÄúFree monad transformer‚Äù is a fancy name for a mathematical abstract syntax tree, where consistency plays an important role.  We provide it with a set of instructions and it builds us a syntax tree of these instructions. <br><br>  We said that we want our stream to either branch, or transfer control, or stop, so let's do a data type with forks, returns, and termination: <br><pre><code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveFunctor #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ThreadF</span></span></span><span class="hljs-class"> next = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fork</span></span></span><span class="hljs-class"> next next | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Yield</span></span></span><span class="hljs-class"> next | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  <code>ThreadF</code> presents our instruction set.  We wanted to add three new instructions, so ThreadF has three constructors, one for each command: <code>Fork</code> , <code>Yield</code> , and <code>Done</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our <code>ThreadF</code> type represents a single node in the syntax tree.  <code>next</code> fields from constructors represent where the children of the nodes should go.  <code>Fork</code> creates two ways of performing, so he has two children.  <code>Done</code> completes the current execution path, so he has no children.  <code>Yield</code> neither branches nor stops, so he has one child.  The deriving (Functor) part simply tells the free monad transformer that <code>next</code> field is where the children should go. <br><div class="spoiler">  <b class="spoiler_title">roughly what is created when the deriving is executed (Functor)</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ThreadF</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> f `fmap` (<span class="hljs-type"><span class="hljs-type">Fork</span></span> next next) = <span class="hljs-type"><span class="hljs-type">Fork</span></span> (f next) (f next) f `fmap` (<span class="hljs-type"><span class="hljs-type">Yield</span></span> next) = <span class="hljs-type"><span class="hljs-type">Yield</span></span> (f next) f `fmap` <span class="hljs-type"><span class="hljs-type">Done</span></span> = <span class="hljs-type"><span class="hljs-type">Done</span></span></code> </pre><br></div></div><br>  Now the free monad transformer <code>FreeT</code> can build the syntax tree of our commands.  We will call this tree a thread: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  `free`  import Control.Monad.Trans.Free type Thread = FreeT ThreadF</span></span></code> </pre><br>  An experienced Haskel programmer will read this code, as if saying ‚Äú <code>Thread</code> is a syntax tree built from <code>ThreadF</code> instructions‚Äù. <br><br><h5>  Instructions </h5><br>  Now we need primitive instructions.  <code>free</code> package provides a <code>liftF</code> operation that converts one command into a syntax tree one node deeper: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">yield</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> m () yield = liftF (<span class="hljs-type"><span class="hljs-type">Yield</span></span> ()) done :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> mr done = liftF <span class="hljs-type"><span class="hljs-type">Done</span></span> cFork :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> m <span class="hljs-type"><span class="hljs-type">Bool</span></span> cFork = liftF (<span class="hljs-type"><span class="hljs-type">Fork</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span>)</code> </pre><br>  You do not need to fully understand how this works, except to notice that the return value of each command corresponds to what we store in the child of the node field: <br><ul><li>  <code>yield</code> command saves <code>()</code> as its child, so the return value of the function is <code>()</code> </li><li>  <code>done</code> command has no children, so the compiler infers that it has a polymorphic return value (ie, <code>r</code> ), which means that it will never end. </li><li>  The <code>cFork</code> command stores logical values ‚Äã‚Äãas children, so it returns a <code>Bool</code> </li></ul><br>  <code>cFork</code> gets its name because it behaves like a <code>fork</code> function from C, which means the returned boolean value tells us which branch we are on after branching.  If we get <code>False</code> , then we are on the left branch and if we get <code>True</code> , then we are on the right branch. <br><br>  We can combine <code>cFork</code> and <code>done</code> anew by implementing <code>fork</code> in a more traditional Haskell style, using the convention that the left branch is the ‚Äúparent‚Äù and the right branch is the ‚Äúchild‚Äù: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad fork :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> <span class="hljs-title"><span class="hljs-title">m</span></span>) =&gt; Thread ma -&gt; Thread m () fork thread = do child &lt;- cFork when child $ do thread done</code> </pre><br>  The code above calls <code>cFork</code> , and then <code>cFork</code> says, "If I'm a child, start the split action, and then stop, otherwise just continue as usual." <br><br><h5>  Free monads </h5><br>  Notice how something unusual happened in the last code snippet.  We assembled <code>cFork</code> and <code>done</code> functions from the primitive <code>Thread</code> thread instructions using the <code>do</code> notation, and we got the new <code>Thread</code> back.  This is because Haskell allows us to use <code>do</code> notation of any type that implements the monad interface ( <code>Monad</code> ) and our free monad transformer automatically determines the necessary monad <code>instance</code> for <code>Thread</code> .  Amazing! <br><br>  In fact, our free monadny transformer is not at all super-smart.  When we compile a free monad transformer using <code>do</code> notation, all that is done is to connect these primitive syntax trees into one node of depth (i.e., instructions) into a larger syntax tree.  A sequence of two commands: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">do</span></span> yield done</code> </pre><br>  ... is discarded simply into storing the second command (ie, <code>done</code> ) as a child of the first command (ie, <code>yield</code> ). <br><br><h4>  Cyclic Thread Manager </h4><br>  Now we are going to write our own thread scheduler.  This will be a naive circular planner: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--   O(1)      import Data.Sequence roundRobin :: (Monad m) =&gt; Thread ma -&gt; m () roundRobin t = go (singleton t) --     where go ts = case (viewl ts) of --   : ! EmptyL -&gt; return () --   :      t :&lt; ts' -&gt; do x &lt;- runFreeT t --     case x of --       Free (Fork t1 t2) -&gt; go (t1 &lt;| (ts' |&gt; t2)) --       Free (Yield t') -&gt; go (ts' |&gt; t') --  :     Free Done -&gt; go ts' Pure _ -&gt; go ts'</span></span></code> </pre><br>  ... and you're done!  No, really, that's all!  This is a complete streaming implementation. <br><br><h4>  Custom streams </h4><br>  Let's try our brave new streaming system.  Let's start with something simple. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mainThread</span></span> :: <span class="hljs-type"><span class="hljs-type">Thread</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () mainThread = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"Forking thread #1"</span></span> fork thread1 lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"Forking thread #1"</span></span> fork thread2 thread1 :: <span class="hljs-type"><span class="hljs-type">Thread</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () thread1 = forM_ [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>] $ \i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ print i yield thread2 :: <span class="hljs-type"><span class="hljs-type">Thread</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () thread2 = replicateM_ <span class="hljs-number"><span class="hljs-number">3</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lift $ putStrLn <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> yield</code> </pre><br>  Each of these threads is of type <code>Thread IO ()</code> .  <code>Thread</code> is a ‚Äúmonad transformer‚Äù, which means that it expands the existing monad with additional functionality.  In our case, we extend the <code>IO</code> monad with user threads, and this, in turn, means that every time we need to invoke an <code>IO</code> action, we use <code>lift</code> to insert this action into the <code>Thread</code> . <br><br>  When we call the <code>roundRobin</code> function, we pull out our Thread monad transformer, and our stream program collapses to a linear sequence of instructions in <code>IO</code> <br><pre> <code class="haskell hljs">&gt;&gt;&gt; roundRobin mainThread :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () <span class="hljs-type"><span class="hljs-type">Forking</span></span> thread #<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">Forking</span></span> thread #<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Moreover, our streaming system is clean!  We can extend other monads, not just <code>IO</code> , and still get stream effects!  For example, we can build stream <code>Writer</code> computations, where <code>Writer</code> is one of the many pure monads (for more information about it, see <a href="http://habrahabr.ru/post/184722/">on Habr√©</a> ): <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.Writer logger :: Thread (<span class="hljs-type"><span class="hljs-type">Writer</span></span> [<span class="hljs-type"><span class="hljs-type">String</span></span>]) () logger = do fork helper lift $ tell ["Abort"] yield lift $ tell ["Fail"] helper :: Thread (<span class="hljs-type"><span class="hljs-type">Writer</span></span> [<span class="hljs-type"><span class="hljs-type">String</span></span>]) () helper = do lift $ tell ["Retry"] yield lift $ tell ["!"]</code> </pre><br>  This time, the <code>roundRobin</code> function <code>roundRobin</code> a clean <code>Writer</code> action when we start the <code>logger</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">roundRobin</span></span> logger :: <span class="hljs-type"><span class="hljs-type">Writer</span></span> [<span class="hljs-type"><span class="hljs-type">String</span></span>] ()</code> </pre><br>  ... and we can extract the results of the logging command as well: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">execWriter</span></span> (roundRobin logger) :: [<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre><br>  Notice how the type computes the net value, the list is <code>String</code> in our case.  And we can still get real streams of logged values: <br><pre> <code class="haskell hljs">&gt;&gt;&gt; execWriter (roundRobin logger) [<span class="hljs-string"><span class="hljs-string">"Abort"</span></span>,<span class="hljs-string"><span class="hljs-string">"Retry"</span></span>,<span class="hljs-string"><span class="hljs-string">"Fail"</span></span>,<span class="hljs-string"><span class="hljs-string">"!"</span></span>]</code> </pre><br><br><h4>  Conclusion </h4><br>  You may think that I am a cheater, that the main work went to the <code>free</code> library, but all the functionality that I used can fit in 12 lines of a very common code, suitable for secondary use. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeF</span></span></span><span class="hljs-class"> fax = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fx</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> fma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runFreeT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fma</span></span></span><span class="hljs-class">)) } instance (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fm</span></span></span><span class="hljs-class">) where return a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> m &gt;&gt;= f = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> $ m &gt;&gt;= \v -&gt; case v of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a -&gt; runFreeT (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> w -&gt; return (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> (&gt;&gt;= </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) w)) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadTrans</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) where lift = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> . liftM </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> liftF :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) =&gt; fr -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> fmr liftF x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FreeT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">)))</span></span></code> </pre><br>  This is a common trend in Haskell: when we use theory, we get a frequently used, elegant and powerful solution in a shocking little code. <br><br>  The writing of the article was inspired by the article by Peng Lee and Steve Zhdantevich ‚ÄúMethods of language for combining flows and events‚Äù.  The main difference is that the continuation methods were replaced by simpler methods of the free monad. </div><p>Source: <a href="https://habr.com/ru/post/195274/">https://habr.com/ru/post/195274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195258/index.html">Humble Mobile Bundle 2</a></li>
<li><a href="../195262/index.html">Thread issues. Edward A. Lee</a></li>
<li><a href="../195264/index.html">A complete solution for video services, now for free!</a></li>
<li><a href="../195268/index.html">The history of drives in advertising. Part 1: 1956-1991</a></li>
<li><a href="../195270/index.html">iOS 7 makes iPhone waterproof</a></li>
<li><a href="../195276/index.html">Digital good (direct electronic payments in the hands of musicians, artists and other creators)</a></li>
<li><a href="../195280/index.html">A look at the light in a new light: Scientists have created an unprecedented form of matter. (translation of the article)</a></li>
<li><a href="../195284/index.html">Patch for nvidia-319.49 driver for Linux 3.12.0+ kernel</a></li>
<li><a href="../195288/index.html">How we ‚Äúmoved‚Äù the entire infrastructure to the ‚Äúcloud‚Äù in 5 days</a></li>
<li><a href="../195308/index.html">New 5-Mpix IP Video Camera with Autofocus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>