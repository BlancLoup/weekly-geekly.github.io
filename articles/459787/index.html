<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++, whether the type is defined: preliminary declaration of the necessary objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time , we used SFINAE to figure out whether a type has a definition, and we used this in combination with if constexpr and universal lambda expre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++, whether the type is defined: preliminary declaration of the necessary objects</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://devblogs.microsoft.com/oldnewthing/20190710-00/%3Fp%3D102678">Last time</a> , we used SFINAE to figure out whether a type has a definition, and we used this in combination with <code>if constexpr</code> and universal lambda expressions so that the code can use the type if it is defined while still being adopted by the compiler (and discarded) if the type is not defined. <br><br>  However, there are several problems with this application: <br><br><ul><li>  Each time you need to write a <code>struct</code> . </li><li>  If the type does not exist, when assigning a name to it, the type is entered into the <i>current</i> namespace, and not into the namespace in which you wanted the type to be. </li><li>  You must use a <code>struct</code> with an unqualified name.  You cannot use it to check for a type that you did not import into the current namespace. </li></ul><br>  We can fix all three problems with one solution: pre-declare the type in the desired namespace. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/pn/ng/uf/pnngufu06qzz6g2xqdripu_mfws.jpeg"><a name="habracut"></a><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// awesome.h namespace awesome { //      struct special { ... }; } //   namespace awesome { //   ,    struct special; }</span></span></code> </pre><br>  After you have done this, you do not need to write a <code>struct</code> because the structure has been declared.  Using it as a template type parameter in <code>call_if_defined</code> will not create a new ad, since everything has already been announced.  And since she was declared, you can access her through her unqualified name, her full namespace name, or something in between.  Also through the type alias or dependent type (unfortunately, they are not between). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> app { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ call_if_defined&lt;awesome::special&gt;([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* p) { <span class="hljs-comment"><span class="hljs-comment">//      "awesome::special" // .     "special" //     . using special = std::decay_t&lt;decltype(*p)&gt;; //      "special"   //   "awesome::special". special::do_something(); }); } }</span></span></code> </pre><br>  Those who followed this series of articles from the very beginning might have noticed that the <code>call_if_defined</code> method <code>call_if_defined</code> not quite coincide with the version we wrote earlier.  The new version supports several type parameters and causes lambda only if all types are defined. <br><br>  Let's take a closer look: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TLambda&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_if_defined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TLambda&amp;&amp; lambda)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((... &amp;&amp; is_complete_type_v&lt;T&gt;))</span></span></span><span class="hljs-function"> </span></span>{ lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)...); } }</code> </pre><br>  Double brackets in if constexpr ((...)) look weird, but they are required.  The outer brackets are required by the <code>if constexpr</code> operator, and the inner brackets are required <a href="https://en.cppreference.com/w/cpp/language/fold">by the convolution expression</a> .  The convolution expression expands to <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( (is_complete_type_v&lt;T1&gt; &amp;&amp; is_complete_type_v&lt;T2&gt; &amp;&amp; ... is_complete_type_v&lt;Tn&gt;))</span></span></span></span></code> </pre><br>  The lambda call uses <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">a parameter package extension</a> : <br><br><pre> <code class="cpp hljs"> lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)...);</code> </pre><br>  It expands to <br><br><pre> <code class="cpp hljs"> lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T1*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T2*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), ..., <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Tn*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>));</code> </pre><br>  where <code>static_cast&lt;T*&gt;(nullptr)</code> repeated once for each type. <br><br>  As I noted earlier, we can use this function to call lambda if all types are defined: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Source </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; source)</span></span></span><span class="hljs-function"> </span></span>{ call_if_defined&lt;special, magic&gt;( [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* p1, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* p2) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> special = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(*p1)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> magic = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(*p2)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = source.try_get&lt;special&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s) magic::add_magic(s); }); }</code> </pre><br>  C ++ 20 allows you to write it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Source </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; source)</span></span></span><span class="hljs-function"> </span></span>{ call_if_defined&lt;special, magic&gt;( [&amp;]&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> special, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> magic&gt; (special*, magic*) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = source.try_get&lt;special&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s) magic::add_magic(s); }); }</code> </pre><br>  which allows you to call the type of the template, thereby eliminating the need to re-extract it, playing with <code>std::decay_t</code> . <br><br>  <a href="https://devblogs.microsoft.com/oldnewthing/20190712-00/%3Fp%3D102690">In the next article,</a> we will use this as a springboard and expand the circuit. <br><br><hr><br>  <b>Note</b> : This is the fourth part of the main series of articles, but there are also other parts ( <a href="https://devblogs.microsoft.com/oldnewthing/20190708-00/%3Fp%3D102664">1</a> , <a href="https://devblogs.microsoft.com/oldnewthing/20190709-00/%3Fp%3D102671">2</a> , <a href="https://devblogs.microsoft.com/oldnewthing/20190710-00/%3Fp%3D102678">3</a> , <a href="https://devblogs.microsoft.com/oldnewthing/20190712-00/%3Fp%3D102690">5</a> ).  For impatient: here's what you need to copy and paste: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_type_complete_v = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_type_complete_v &lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">void_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T))&gt;&gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TLambda&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_if_defined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TLambda&amp;&amp; lambda)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((... &amp;&amp; is_complete_type_v&lt;T&gt;))</span></span></span><span class="hljs-function"> </span></span>{ lambda(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)...); } }</code> </pre> <br><h2>  By the way, we have a cool job. </h2><br>  For over a decade, <a href="https://www.havok.com/">Havok</a> has been at the forefront of innovation in game development and interactive 3D.  As part of Cognition, the HoloLens team, we are now combining this expertise with the power of the Azure cloud to develop many exciting new services that support mixed reality.  Among them is the recently announced Azure Remote Rendering service.  We are passionate about combining AR, VR and cloud technologies, which together allow us to create innovative practices of using mixed reality. <br><br>  <b>Jobs at Havok:</b> <br><br><ul><li>  You will work in small teams with talented developers. </li><li>  You will have the opportunity to work with new technologies on a variety of hardware platforms and devices. </li><li>  You will work on solving complex technical problems with great prospects. </li><li>  You will collaborate with cool teams around the world. </li></ul><br><h4>  Duties </h4><br><ul><li>  Design, develop, and test high-quality, efficient, and clean multiplatform C ++ code </li><li>  Develop well-scalable Azure services </li><li>  Work directly with internal and external customers to stimulate product development </li></ul><br><h4>  Qualifications </h4><br><ul><li>  C ++ programming and debugging skills </li><li>  Ability to work in a team with common code </li><li>  Experience with cloud and distributed service technologies (for example, Azure Batch, Azure Blob Storage, Docker, Telemetry) </li></ul><br><h4>  It will be a plus </h4><br><ul><li>  C #, ASP.Net, JavaScript, TypeScript, React </li><li>  Unity, Unreal or related game engines </li><li>  Experience in interactive 3D, AR or VR </li><li>  Network and server services </li><li>  Performance optimization </li></ul><br>  You can learn more and submit your application <a href="https://careers.microsoft.com/us/en/job/621357/Software%2520Engineer">here</a> or through <a href="https://www.linkedin.com/in/maximevannoppen/">LinkedIn</a> . </div><p>Source: <a href="https://habr.com/ru/post/459787/">https://habr.com/ru/post/459787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45977/index.html">Tuning buckets</a></li>
<li><a href="../459771/index.html">Implement AutoMapper with Roslyn and Code Generation</a></li>
<li><a href="../459773/index.html">How to build, deploy and test Waves RIDE dApp</a></li>
<li><a href="../459775/index.html">What I learned about machine learning after working in 12 startups</a></li>
<li><a href="../459785/index.html">Deep Learning: An Overview</a></li>
<li><a href="../459789/index.html">We update Unity Android projects for compatibility with ARM64 architecture</a></li>
<li><a href="../45979/index.html">On the "Macs" need to put a few antiviruses</a></li>
<li><a href="../459793/index.html">How to come up with meaningful names for your code</a></li>
<li><a href="../459795/index.html">Bitrix and MariaDB update to the latest stable version</a></li>
<li><a href="../459797/index.html">"N-nada glasses?" Or "what are the disadvantages of ready-made Chinese glasses with diopters"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>