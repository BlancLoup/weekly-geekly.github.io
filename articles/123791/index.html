<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32F1xx - we treat arduine dependence together</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane! 
 After a long break associated with the protection of a graduation project in Baumanka, I again returned to writing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32F1xx - we treat arduine dependence together</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear habrovchane! <br>  After a long break associated with the protection of a graduation project in Baumanka, I again returned to writing articles.  Since recently, I started 32-bit microcontrollers of the STM32F series on the ARM Cortex-M3 core, this will be my story.  The article will help me to systematize knowledge about these wonderful microcontrollers, and I hope that you will serve as one of the steps towards their use and dispel fears and doubts that always arise after the cozy 8-bit AVRok when mentioning the terrible 32-bit monsters. <br>  So why Cortex, what are bad avr? <br><a name="habracut"></a><br><h4>  Ceiling </h4><br>  Generally speaking, nothing.  Microcontrollers from the AVR family are very convenient, low consuming and easy to learn.  But this is where some peculiarity lies - starting out with AVR, it‚Äôs hard for a person to force himself to switch to a more complex architecture.  It would seem that everything works so well, but it does not work - so I will take AVRku more.  More.  Anyway, do not climb?  I will take two AVRki, I will build whatnot from Arduino, until all that I planned does not fit into the chip.  This is the wrong approach.  Most often this is manifested in those who are engaged in electronics "for themselves."  I can not say that it‚Äôs just really disgusting and you should break arduins with hammers, but if you want to go beyond the crafts on your knee or take your hobby to a new level, you should objectively evaluate the areas of application of microcontrollers.  By the way, the manufacturers of microcontrollers on ARM Cortex-M3 are calling for active actions; they are ready to send a new debugging to ARM for the video of your old debug board being destroyed on an 8-bit controller, however, we will try to do without vandalism. <br>  So, moving on to specific examples.  Younger models of the STM32F10x family can be purchased at a price of 30p per piece.  As you can see, the price is comparable with AVRs.  For this price, you will receive a 32-bit microcontroller rated at 24 MHz with a Flash and RAM volume similar to that of the ATMega88.  Older models can be clocked with a frequency of up to 72 MHz, the volume of flash / RAM reaches 1M / 128K.  When should I use it instead of megu?  Then, when you run into the ‚Äúceiling‚Äù of the AVR.  Such a ‚Äúceiling‚Äù is usually computing tasks (signal processing, in particular).  Yes, I know, if you wish, you can try and shove DSP algorithms in mega, for training purposes this is even useful.  But in a real device it is much more appropriate to use a suitable processor.  What do we get by choosing STM? <br><ol><li>  Full 32-bit computing.  You do not have to spend precious cycles on the work of data, bit depth of more than 8 bits, the ALU will do it for you. </li><li>  DMA.  The DMA controller for AVR users is a luxury, available only in older, monstrous models.  In STM32F1xx DMA is even in the youngest crystals.  Using it, you can easily and naturally transfer data blocks between peripherals and memory without using a processor.  It is very useful when working with memory cards, sending large amounts of data on all kinds of UARTs and their ilk, organizing audio capture from the ADC and outputting data to a DAC. </li><li>  Speaking of DAC - in most models, including the younger ones, there is a 12-bit DAC.  For music lovers it will not work, but it is convenient to output any debug analog info.  Yes, and all sorts of toys with sound do more convenient than with the PWM. </li><li>  NVIC, I mean Nested Vector Interrupt Controller, is a programmable interrupt controller that allows you to assign priorities to them and guaranteeing a constant time to enter the interrupt is a necessary thing for systems with real-time restrictions. </li><li>  A nice little thing like an SD card controller.  The SPI controller on STMs contains a hardware CRC calculator, it can be used to fully communicate with SD cards. </li><li>  Availability of some DSP commands.  Truth be told, the Cortex-M3 is not exactly a DSP core, but such a processor is often required ‚Äî not TI's monster-eating monsters, but not weak AVRs.  The presence of a 32x32 hardware multiplier and multiplication with accumulation will help in processing the signal on M3. </li><li>  More advanced models have a USB controller, and flash volumes reach a megabyte, while you can still choose the case yourself - STM are pin-compatible and even older models can be bought in a 64-foot case.  Fee rerun will not have to. </li></ol><br>  We now turn to the disadvantages.  I can mark two: <br><ol><li>  The cabinets of the STM32F1xx are much less accessible at home than those of the same AVR.  The board will succeed, but it will require some skill. </li><li>  The architecture of these controllers is very complicated, for one timer it is necessary to have 12 registers (they are also 32-bit!), So it will not be possible to master the evening, you will have to deal with them purposefully. </li></ol><br>  What can be concluded?  Very simple: try to always think with your head, and objectively assess the situation, not allowing your mind to overshadow the habits and attachments to specific architectures.  If you see that it would be nice to use 16-bit (and higher) data, count filters, send large amounts of information - do not grab hold of arduin bookshelves.  At the same time, if you just need to check the value of the light sensor just once a minute and cut in the desk lamp, then you shouldn‚Äôt immediately run after the cortex. <br><br>  We now turn to more pressing issues.  What do we need to start working with the STM32F? <br><br><h4>  Getting Started with STM32F1xx </h4><br>  Contrary to the opinions of some comrades, 300r will be enough for you.  For the purchase of such a debug board here: <a href="http://www.terraelectronica.ru/catalog_info.php%3FID%3D1001%26CODE%3D573571%26Name%3DSTM32VLDISCOVERY%26Razdel%3D%25CE%25F2%25EB%25E0%25E4%25EE%25F7%25ED%25FB%25E5%2520%25E8%2520%25EE%25F6%25E5%25ED%25EE%25F7%25ED%25FB%25E5%2520%25EF%25EB%25E0%25F2%25FB%2520%25E8%2520%25ED%25E0%25E1%25EE%25F0%25FB%2520%25E4%25EB%25FF%2520%25F1%25E5%25EC%25E5%25E9%25F1%25F2%25E2%25E0%2520STM32%2520(Cortex-M3)%26TableName%3Dclass_19_2_40_4_6">STM32VLDISCOVERY</a> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/f61/ed5/335/f61ed533536c874cee542a1c02ccb36b.jpg" alt="image"><br>  It immediately contains both a programmer and a programmable part in the form of an STM32F100RB controller on board. <br>  Also, it does not hurt to get such a layout: <a href="http://www.voltmaster.ru/cgi-bin/qwery.pl%3Fid%3D45097%26group%3D52604">WBU-206</a> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/871/b6b/ba5/871b6bba5bd3567ef8cfc01020139215.jpg" alt="image"><br>  Allows you not to be distracted by soldering, but immediately focus on your goals.  True, complex circuits on it look disgusting - tight intertwining of wires can strike terror in immature minds) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here, in principle, and all of the iron you need to start.  Since the basics of the work were outlined in my articles by the respected <a href="http://geektimes.ru/users/dihalt/" class="user_link">DiHalt</a> , I will not repeat myself and will consider that a project can be created in Keil, and any reader of the article can compile it and flash it.  If not, we are educated on <a href="http://easyelectronics.ru/category/arm-uchebnyj-kurs">easyelectronics.ru</a> . <br>  In order not to be so boring to work, let's start not with the annoying LEDs, but with the servos.  A servo drive is an electric motor that is included in the servo system.  Feedback is implemented by obtaining information about the actual position of the shaft - say, by placing a potentiometer on one of the shafts of the gearbox. <br>  The control system receives from us information about the angle at which we want to turn the servo shaft, from the potentiometer - on which it is now turned, and forms the control voltage on the motor windings.  All this Chinese comrades upyvayut in a very small body, for example, such: <a href="http://www.dealextreme.com/p/tower-pro-mg90s-metal-gear-servos-with-parts-31962">Tower Pro MG90S</a> <br><img src="https://habrastorage.org/getpro/geektimes/post_images/97b/124/64b/97b12464bd100e81c594e90fb26bdd67.jpg" alt="image"><br>  They cost less than 200 rubles, the delivery is free (true, rather long), the gearbox is metal, not plastic.  Traditionally, servas are controlled by a PWM signal with a frequency of 20-60 Hz (note, <i>hertz</i> , not kilohertz), the signal's rotation ratio sets the angle of rotation.  Specific values ‚Äã‚Äãdepend on the servo-motor itself, so we will experiment, the benefit can be to debug the firmware on the go.  Unfortunately, I did not find any information directly on these motors, so I chose the values ‚Äã‚Äãfrom the Futaba Japanese servos - without thinking, fortunately, the Chinese developers didn‚Äôt move much away from the standards, and the server understood it quite well.  The purpose of the article will be to start a timer on STM32F1xx, generate a PWM signal with it and use this PWM to spin the Chinese server. <br>  Turn to the gland.  In this case, no special schemes are required from us - everything is already on the debug board.  We just have to connect the server to it.  A standard servomotor has 3 wires ‚Äî ground, power, and control (usually painted black, red, and orange, respectively).  For the MG90S drives I mentioned, the power supply can vary from 4.8 to 6V, and the idle consumption, according to my measurements, does not exceed 40 mA, so you can power them directly from the pin 5V of the debug board.  The PWM will be served from one of the timers onboard the controller.  Each timer has 4 independent PWM channels, so that it is possible without straining to turn up to 4 servos with one timer.  Timers with numbers 1 and 8 are somewhat more advanced than the others - they are designed to control the drivers of field-effect transistors included in the half-bridge circuit, so we will not touch them yet (despite the fact that they can also produce simple PWM signals). <br>  Instead, use the timer number 2, which falls into the category of General Purpose Timers.  To manage the servos, it was convenient for me to use its channels 3 and 4. According to the documentation, channels 3 and 4 are connected to pins PA2 and PA3. <br>  So, as a result, our experiment area is a STM32VLDISCOVERY debugging board connected to a computer's USB and two Tower Pro MG90S servo drives whose lands (black wire) are connected to the GND pin of the debugging board, power is connected to its pin 5B and the control wires of the first and second Serves are connected to pins PA2 and PA3 respectively.  If you have an oscilloscope, you can connect its channels to PA2, PA3 to immediately observe the generated signal. <br>  We now turn to the code. <br><br><h4>  Software part </h4><br>  In the code, I will focus on working with registers instead of using the Standard Peripherals Library - because  IMHO should examine how it all works from the inside, before trying to abstract from iron.  We will assume that creating a project for a debugging board in Keila and connecting CMSIS for you will not be difficult, it is described in detail in the article on easyelectronics <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-keil-cmsis-sozdanie-proekta.html">ARM.</a>  <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-keil-cmsis-sozdanie-proekta.html">Training course.</a>  <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-keil-cmsis-sozdanie-proekta.html">Keil + CMSIS.</a>  <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-keil-cmsis-sozdanie-proekta.html">Creating a project</a> <br><br>  So, the starting point for us will be the project in Keil uVision with the CMSIS connected: <br><br><pre><code class="hljs vbscript">#include <span class="hljs-string"><span class="hljs-string">"stm32f10x.h"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  This should all be compiled, flashed into the memory of the controller and debugged.  If this does not happen - read the article mentioned on easyelectronics. <br>  The start code from the assembler file (I call it <b>startup_stm32f10x_md_vl.s</b> ) contains the declaration of handwashing and exceptions that can be safely redefined in our program.  It also calls the <b>SystemInit</b> function, defined in the <b>CMSIS</b> library core_cm3.h file.  Some registers are configured in it, in particular, those responsible for clocking - this can all be done manually by replacing the <b>SystemInit</b> call in the start file with a call to its function, but for now we will not dwell on this issue.  I will only note that the frequency is set in accordance with the settings in the <b>system_stm32f10x.c</b> file, where <b>SYSCLK_FREQ_24MHz</b> is equal to 24,000,000 on line 76. <br><br>  The control code is very simple, however, there are several points that should be paid attention to so that you do not have to search for a problem in the code for a long time. <br>  The first moment is mentioned <a href="http://geektimes.ru/users/dihalt/" class="user_link">DiHalt</a> 'om - in STMs the clocking of almost all peripheral modules is disabled by default in order to save energy.  So first of all we submit clocks to our periphery: <br><br><pre> <code class="hljs erlang-repl"> RCC-&gt;APB1ENR|= RCC_APB1ENR_TIM2EN; RCC-&gt;APB2ENR|= RCC_APB2ENR_IOPAEN;</code> </pre><br>  In these two lines, we set the <b>TIM2EN</b> bits (to feed the clock on timer 2) and <b>IOPAEN</b> (to feed the clock on port A) in the <b>APB1ENR</b> and <b>APB2ENR registers,</b> respectively (APB1 and APB2 Peripheral Clock Enable Register). <br>  And here comes another important thing: <br><br><pre> <code class="hljs erlang-repl"> GPIOA-&gt;CRL |=GPIO_CRL_MODE2; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF2_0; GPIOA-&gt;CRL |=GPIO_CRL_CNF2_1; GPIOA-&gt;CRL |=GPIO_CRL_MODE3; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF3_0; GPIOA-&gt;CRL |=GPIO_CRL_CNF3_1;</code> </pre><br>  We set both pins, PA2, PA3, to the exit, but the fact is that in STMs there is a separation in the GPIO operating modes.  If we want to set the pin state to 1 or 0 programmatically, then we should choose the Output push-pull or Output open drain mode.  If it is supposed that some periphery of the timer type, which is specified in the datasheet for a specific controller model in the pinout section in the Alternate Functions column, will control its state, then the mode of operation should be Alternate function push-pull or Alternate function open drain.  If you set the mode incorrectly, the timer will not be able to issue a PWM signal. <br>  Briefly about the registers - each port contains two control registers <b>CRL</b> and <b>CRH</b> , in fact, absolutely identical.  The <b>CRL</b> stores pin settings 0‚Äì7, in the CRH - 8‚Äì15.  Each pin has 4 bits, two of which, <b>MODE</b> , are responsible for the I / O direction and the limitation on the maximum pin switching frequency in the output mode, the other two, <b>CNF</b> , store the same mode of operation. <br>  All in all, this gives us eight possible pin states: <br><ol><li>  Input not pulled ( <b>MODE</b> [1: 0] = 00, <b>CNF</b> [1: 0] = 01) </li><li>  Input pulled to power ( <b>MODE</b> [1: 0] = 00, <b>CNF</b> [1: 0] = 10, 1 is output to the port) </li><li>  Input pulled to the ground ( <b>MODE</b> [1: 0] = 00, <b>CNF</b> [1: 0] = 10, 0 output at the port output) </li><li>  Analog input ( <b>MODE</b> [1: 0] = 00, <b>CNF</b> [1: 0] = 00) - this switches off the Schmitt trigger and pull-up resistors, the pin changes to the Z-state. </li><li>  Output, open drain GPIO ( <b>MODE</b> [1: 0]! = 00, <b>CNF</b> [1: 0] = 01) </li><li>  Out, push-pull GPIO ( <b>MODE</b> [1: 0]! = 00, <b>CNF</b> [1: 0] = 00) </li><li>  Output, open drain controlled by peripherals ( <b>MODE</b> [1: 0]! = 00, <b>CNF</b> [1: 0] = 11) </li><li>  Out, push-pull managed by peripherals ( <b>MODE</b> [1: 0]! = 00, <b>CNF</b> [1: 0] = 10) </li></ol><br>  For our purposes, we need pins configured for the output controlled by the periphery in the push-pull mode.  Thus, it is necessary in the CRL register to set the values ‚Äã‚Äãof <b>MODE2</b> [1: 0] and <b>MODE3</b> [1: 0] to some other value than 00, say, 11, and <b>CNF2</b> [1: 0] and <b>CNF3</b> [1: 0] - to 10 <br>  The remaining registers related to the periphery are described in detail in document RM0008, <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/REFERENCE_MANUAL/CD00171190.pdf">STM32F1xx Reference Manual</a> .  In short, the <b>IDR</b> and <b>ODR</b> registers contain input and output values ‚Äã‚Äãon the port pins, the <b>BSRR</b> is responsible for setting / resetting, and the <b>BRR</b> only for resetting bits in the <b>ODR</b> , and it does it atomically, that is, this operation occurs during one bus cycle and into it interruption cannot interfere.  The last port register, <b>LCKR,</b> allows <b>you</b> to ‚Äúlock‚Äù the pin value, not allowing it to be changed to the cut itself. <br><br>  Next, set the timer.  According to the data found on the Internet, the PWM period should be selected from 20 to 60 Hz, while pulses with a width of about 1 ms mean 0 degrees, 1.5 ms - 90 degrees, and 2 ms - 180. <br><img src="https://habrastorage.org/getpro/geektimes/post_images/1ac/5e0/04a/1ac5e004ac07e9452659308f1d6b46e1.jpg" alt="image"><br>  As for the width of the PWM - in principle, you can choose any, but the positioning accuracy of the serv is still finite, so I chose 12 bits.  It should also be remembered that 12 bits describe a change in pulse width from 0 ms to a value equal to its period, while the server operates on a range from 1 to 2 ms, therefore not all 12 bits will be at our disposal.  Looking ahead, I will say that as a result of the experiments, I came to the following parameters: <br><ul><li>  PWM signal frequency: 35 Hz.  I chose just as an average value, the server works stably at both 30 and 50 Hz. </li><li>  The pulse width corresponding to 0 degrees: about 0.5 ms, however, if you select it to be 0.5 or less, the server starts to crack, because  is on the border of their physical abilities in turn.  Therefore, for a more stable operation, I use pulses about 0.56 ms wide </li><li>  The pulse width, corresponding to 180 degrees: about 2.3 ms, the same situation as with zero rotation - if you set a little more than the boundary, it starts to pop. </li></ul><br>  Choosing a PWM frequency of 35 Hz and a bit width of 12 bits, we get 4096 values ‚Äã‚Äãfor the entire period, 0x50 will correspond to a width of 0.56 ms, and 0x150 will correspond to a width of 2.34 ms. <br>  Thus, we obtain 256 values ‚Äã‚Äãat approximately 180 degrees, which means a resolution of approximately 40 arc-minutes per sample.  If desired, you can continue the experiments and determine the exact boundary values ‚Äã‚Äãand the accuracy with which the drive can perform the positioning. <br>  So, set the timer 2 with the following code snippet: <br><br><pre> <code class="hljs erlang-repl"> TIM2-&gt;PSC = <span class="hljs-number"><span class="hljs-number">0</span></span>x00A7; TIM2-&gt;ARR = <span class="hljs-number"><span class="hljs-number">0</span></span>x0FFF; TIM2-&gt;CCR3 = <span class="hljs-number"><span class="hljs-number">0</span></span>x050; TIM2-&gt;CCR4 = <span class="hljs-number"><span class="hljs-number">0</span></span>x0150;</code> </pre><br>  It's all very trivial: the <b>PSC</b> (Prescaler) register is responsible for the prescaler, the <b>ARR</b> (Auto-reload register) register for the maximum value that the timer will tick to.  Putting the number 0FFF in <b>ARR,</b> we get a 12-bit timer, its counting period will be equal to the clock frequency divided by 0xFFF, that is, 24000000/4096 = 5859. Dividing this value by another 0xA7, we get 5859/167 = 35 Hz. <br>  The value of the <b>CCR3</b> and <b>CCR4</b> (Capture Compare register) registers is compared with the value of the counter and sets the actual duty cycle of the PWM.  Further we set the timer operation mode: <br><br><pre> <code class="hljs erlang-repl">TIM2-&gt;CCMR2 |= TIM_CCMR2_OC3M_1|TIM_CCMR2_OC3M_2; TIM2-&gt;CCER |= TIM_CCER_CC3E; TIM2-&gt;CCMR2 |= TIM_CCMR2_OC4M_1|TIM_CCMR2_OC4M_2; TIM2-&gt;CCER |= TIM_CCER_CC4E; TIM2-&gt;CR1 |= TIM_CR1_CEN;</code> </pre><br>  The situation is the same as with the port setting registers - the two setting registers Capture and Compare Mode register, <b>CCMR1</b> , <b>CCMR2</b> are responsible for the operation modes of channels 1,2 and 3,4, respectively.  There are many settings, and it is better to read the Reference Manual on this.  If the overview - registers are responsible for the modes associated with the capture of the PW signal on the timer and its output.  The <b>CCxS</b> bits, where x is the channel number, set this channel to input or output.  By default, the output mode is enabled, so we will not touch them.  The set bits <b>OCxM [2: 0]</b> are responsible for how the channel will react to the comparison of the value of the counter (which is stored, by the way, in the register <br>  <b>TIM2-&gt; CNT</b> ) and <b>CCRx</b> registers.  In total there are 8 options: <br><ol><li>  000 - the comparison does not affect the output </li><li>  001 - if the values ‚Äã‚Äãat the channel output match, then 1 is set </li><li>  010 - if the values ‚Äã‚Äãat the channel output match, then 0 is set. </li><li>  011 - if the values ‚Äã‚Äãmatch, the output signal switches to the opposite state </li><li>  100 - output is always set to 0 </li><li>  101 - output is always set to 1 </li><li>  110 - PWM, mode 1, normal (as long as the value in <b>CCRx</b> &lt; <b>CNT</b> , at output 1, otherwise 0) </li><li>  111 - PWM, mode 2, inverse (as long as the value is in <b>CCRx</b> &lt; <b>CNT</b> , at output 0, otherwise 1) </li></ol><br>  Set mode 110, normal PWM.  Do not forget in the <b>CCER</b> register (Capture / compare enable register) to set the <b>CCxE</b> bit to enable the output of the corresponding channel. <br>  After that, turn on the entire timer by setting the <b>CEN</b> bit in the <b>CR1</b> register (Control Register 1). <br>  Everything, PWM went, a beautiful picture should appear on the oscilloscope screen, and the servos should take opposite positions.  If desired, you can set up a breakpoint after all initializations and change values ‚Äã‚Äãusing the built-in Keyl tool to view and edit the processor and peripheral registers, immediately observing the change in the signal's duty cycle on the oscilloscope screen and the position of the servo drive shaft. <br>  Now let's make the program a bit more interesting for the sake of self-education - we will change the angle values ‚Äã‚Äãfrom maximum to minimum.  To do this, recall that the ARM Cortex-M3 core includes the so-called <i>SysTick Timer</i> - this is a 24-bit timer designed for global synchronization and interrupt generation, for example, when implementing an operating system.  The timer is initialized using the <b>SysTick_Config</b> function <b>(uint32_t Ticks)</b> .  This feature is part of CMSIS, which is more ‚Äúfundamental‚Äù than the Standard Peripherals Library, so we will use it. <br>  If you are interested in the insides of this function, you can go to its description in the depths of CMSIS (file <b>core_cm3.h</b> , line 1137).  In general, the function does not do anything particularly complicated, it only checks the value of the parameter <b>Ticks</b> passed to it for exceeding 24 bits, and then sets the registers: <br>  ‚Ä¢ <b>SysTick-&gt; LOAD</b> to Ticks is the top of the timer counter, interrupts will be <b>triggered</b> at such intervals. <br>  ‚Ä¢ <b>SysTick-&gt; VAL</b> to 0 is the current value of the counter. <br>  ‚Ä¢ <b>CLKSOURCE</b> , <b>TICKINT</b> , <b>ENABLE</b> <b>bits in the SysTick-&gt; CTRL</b> register in 1. <br><br>  The <b>CLKSOURCE</b> bit <b>is</b> responsible for the clock source for the timer.  Generally speaking, the core specification does not describe what the second signal should be (the first one is always connected to the system clock), so the effect of this bit may vary from manufacturer to manufacturer.  In STM32F, the second signal is connected to <b>SystemCoreClock</b> / 8.  Having set the bit to 1, select the source of the system clock. <br>  The <b>TICKINT</b> bit enables the generation of an interrupt (or rather, an exception) over the timer overflow.  Set to 1, for the sake of it, and everything was started) <br>  The <b>ENABLE</b> bit turns on the timer. <br>  In addition to the described actions, the <b>SysTick_Config</b> function also sets the interrupt priority to 240, which is very low, considering that priorities start from 0 (actually from -3, but priorities less than 0 are non-configurable). <br>  Since the current PWM settings mean 256 steps from 0 to 180 degrees, let's set the timer to the frequency <br>  <b>SystemCoreClock</b> / 256, so that this serv path goes in 1 second: <br><br><pre> <code class="hljs lisp">SysTick_Config(<span class="hljs-name"><span class="hljs-name">SystemCoreClock/256</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  The <b>SystemCoreClock constant is</b> defined in <b>system_stm32f10x.c</b> , line 114, and is equal to the number of core clock signals in 1 s, i.e., 24,000,000. <br>  It remains to describe the timer interrupt handler and the work will be completed! <br><br><pre> <code class="hljs matlab">int8_t ChannelDir[<span class="hljs-number"><span class="hljs-number">2</span></span>]={<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>}; volatile uint16_t *DutyCycle[<span class="hljs-number"><span class="hljs-number">2</span></span>]={TIM2-&gt;CCR3,&amp;TIM2-&gt;CCR4}; void SysTick_Handler() { uint8_t <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { *DutyCycle[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]+=ChannelDir[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*DutyCycle[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]&lt;<span class="hljs-number"><span class="hljs-number">0x50</span></span>) ChannelDir[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*DutyCycle[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]&gt;<span class="hljs-number"><span class="hljs-number">0x150</span></span>) ChannelDir[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]=<span class="hljs-number"><span class="hljs-number">-1</span></span>; } }</code> </pre><br>  Since we have two channels, we will write a handler with the expectation of both channels at once.  Since we have the same memory space, we can freely access registers as ordinary memory cells, so we immediately declare a pointer to two registers: <br><br><pre> <code class="hljs erlang-repl">volatile uint16_t *DutyCycle[<span class="hljs-number"><span class="hljs-number">2</span></span>]={&amp;TIM2-&gt;CCR3,&amp;TIM2-&gt;CCR4};</code> </pre><br>  Then everything is very simple - we organize a cycle through two channels, add or subtract 1 from the current value of the duty cycle (depending on the direction) and, when the servo reaches the extreme position, change directions. <br><br>  Everything, we compile, and if everything is done correctly, then we enjoy the spectacle of the kind that is presented by me on the video below. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/xqU-xgXP1GY%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhh2I-l63mG3vXboYizYaq1up911Yw" frameborder="0" allowfullscreen=""></iframe><br><br>  The complete project code looks like this: <br><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"stm32f10x.h"</span></span> int8_t ChannelDir[<span class="hljs-number"><span class="hljs-number">2</span></span>]={<span class="hljs-number"><span class="hljs-number">1</span></span>,-<span class="hljs-number"><span class="hljs-number">1</span></span>}; volatile uint16_t *DutyCycle[<span class="hljs-number"><span class="hljs-number">2</span></span>]={&amp;TIM2-&gt;CCR3,&amp;TIM2-&gt;CCR4}; void SysTick_Handler() { uint8_t i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>;i++) { *DutyCycle[i]+=ChannelDir[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*DutyCycle[i]&lt;<span class="hljs-number"><span class="hljs-number">0x50</span></span>) ChannelDir[i]=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*DutyCycle[i]&gt;<span class="hljs-number"><span class="hljs-number">0x150</span></span>) ChannelDir[i]=-<span class="hljs-number"><span class="hljs-number">1</span></span>; } } int main() { RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN; RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM2EN; GPIOA-&gt;CRL |=GPIO_CRL_MODE2; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF2_0; GPIOA-&gt;CRL |=GPIO_CRL_CNF2_1; GPIOA-&gt;CRL |=GPIO_CRL_MODE3; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF3_0; GPIOA-&gt;CRL |=GPIO_CRL_CNF3_1; TIM2-&gt;PSC = <span class="hljs-number"><span class="hljs-number">0x00A7</span></span>; TIM2-&gt;ARR = <span class="hljs-number"><span class="hljs-number">0x0FFF</span></span>; TIM2-&gt;CCR3 = <span class="hljs-number"><span class="hljs-number">0x050</span></span>; TIM2-&gt;CCR4 = <span class="hljs-number"><span class="hljs-number">0x0150</span></span>; TIM2-&gt;CCMR2 |= TIM_CCMR2_OC3M_1|TIM_CCMR2_OC3M_2; TIM2-&gt;CCER |= TIM_CCER_CC3E; TIM2-&gt;CCMR2 |= TIM_CCMR2_OC4M_1|TIM_CCMR2_OC4M_2; TIM2-&gt;CCER |= TIM_CCER_CC4E; TIM2-&gt;CR1 |= TIM_CR1_CEN; SysTick_Config(SystemCoreClock/<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>  On this I have everything.  If you are interested in this topic, in the following articles I will try to consider something more interesting, for example, working with a display from a mobile phone. <br><br>  <b>UPD:</b> <br>  In order not to go far, useful links: <br><ul><li>  <a href="http://easyelectronics.ru/category/arm-uchebnyj-kurs">Mentioned articles on easyelectronics by ARM</a> </li><li>  <a href="http://we.easyelectronics.ru/blog/STM32/">A series of articles on STM32 on a tip from Di-Halt</a> </li><li>  <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/REFERENCE_MANUAL/CD00171190.pdf">RM0008 Reference Manual by ST</a> </li><li>  <a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/DATASHEET/CD00251732.pdf">Datasheet on STM32F100, low &amp; medium density devices</a> </li><li>  <a href="http://habrahabr.ru/blogs/controllers/139384/">My next article on STM32, working with LCD</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/123791/">https://habr.com/ru/post/123791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123784/index.html">Which of the new C ++ 0x features would you most like to see in Visual C ++ 2012?</a></li>
<li><a href="../123785/index.html">CountDown - Countdown to HTML5</a></li>
<li><a href="../123787/index.html">Smart Exception</a></li>
<li><a href="../123789/index.html">Making triodes in artisanal conditions</a></li>
<li><a href="../123790/index.html">Why couple and tuple are often bad</a></li>
<li><a href="../123793/index.html">JavaScript libraries for working with SVG</a></li>
<li><a href="../123797/index.html">IIS + .NET + Json. We write the Application Server</a></li>
<li><a href="../123799/index.html">Asus Eee Pad Transformer Review</a></li>
<li><a href="../123802/index.html">Facebook is testing a new home page design.</a></li>
<li><a href="../123804/index.html">Mash of flags: how to find out more about an exotic country</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>