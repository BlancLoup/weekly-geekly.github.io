<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study the algorithm of regular expressions in Ruby</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="According to Wikipedia, Oniguruma means "devil's chariot" in Japanese. 

 We are all familiar with regular expressions. They are the "Swiss army knife...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study the algorithm of regular expressions in Ruby</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/fd0/0c5/3bcfd00c598f7c3d71a338a0e36bc2e3.png"><br>  <i>According to Wikipedia, <a href="http://en.wikipedia.org/wiki/Oniguruma">Oniguruma</a> means "devil's chariot" in Japanese.</i> <br><br>  We are all familiar with regular expressions.  They are the "Swiss army knife of the developer."  Whatever you are looking for, whatever text you can make out, you can always do it using regular expressions.  In fact, you probably started using them much earlier than you began to use Ruby - they have long been included in most popular programming languages: Perl, JavaScript, PHP, Java, and others.  Ruby appeared in the mid-1990s, whereas regular expressions were still in the 1960s, that is, almost 30 years earlier! <br><br>  But how do regular expressions actually work? <br><a name="habracut"></a><br>  If you want to learn more about the information technologies behind the regular expression engine, you must read the fantastic series of articles from Russ Cox: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://swtch.com/~rsc/regexp/regexp1.html">Regular Expression Matching Can Be Simple And Fast (2007)</a> </li><li>  <a href="http://swtch.com/~rsc/regexp/regexp2.html">Regular Expression Matching: The Virtual Machine Approach (2009)</a> </li><li>  <a href="http://swtch.com/~rsc/regexp/regexp3.html">Regular Expression Matching in the Wild (2010)</a> </li></ul><br>  I do not want to repeat everything that Russ wrote.  But I quickly note that Ruby uses the ‚ÄúNon-recursive Backtracking Implementation‚Äù (implementation with non-recursive backtracking), which is discussed in his second article, which leads to an exponential performance degradation, just like with regular expressions in Perl .  In other words, Ruby does not use the most optimal Thompson NFA (Thompson's algorithm for non-deterministic finite automata), which Russ talks about in his first article. <br><br>  Today, I'm going to take a close look at Oniguruma, a regular expression engine that is built into Ruby.  Using some simple graphic schemes and a few examples of regular expressions, I will illustrate how it works.  Read on to get an idea of ‚Äã‚Äãwhat is happening inside Ruby every time you use regular expressions, probably there are a lot of things that you didn't even realize. <br><br><h4>  Oniguruma </h4><br>  Starting with version 1.9, MRI uses a slightly modified version of the open C library called "Oniguruma", which is also used in PHP, for regular expression processing.  Along with support for all standard regular expression functions, it also supports multibyte characters, such as Japanese text. <br><br>  At a very high level, this is what happens when a regular expression passes through Oniguruma: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93b/5d1/828/93b5d1828ae209cc80dd2ebb35e0ad0d.png"><br><br>  In the first step, Oniguruma reads a regular expression pattern, breaks it into lexemes and translates it into a tree structure containing a set of syntax nodes - Abstract Syntax Tree (AST).  This is very similar to how the interpreter itself processes your Ruby code.  In fact, you can think of the Oniguruma regular expression mechanism as a second programming language built right into Ruby.  Whenever you use regular expressions in code, you really create a second program in a completely different language.  After parsing the regular expression pattern, Oniguruma compiles it into a set of instructions, which are then executed on the virtual machine.  These instructions implement the state machine that Russ Cox describes in his articles. <br><br>  Then, when you actually search for a regular expression, the Oniguruma virtual machine executes it by simply processing the instructions that were previously compiled, applying them to the specified string. <br><br>  This week, to understand how Oniguruma works, and compare it with what Russ Cox is writing about, I rebuilt Ruby 2.0 with the ONIG_DEBUG_COMPILE and ONIG_DEBUG_MATCH flags set.  Setting these flags allowed me to see a lot of debug messages when I ran a search through several regular expressions.  In them, I saw what instructions the virtual machine had compiled into the templates, and how it performed them.  That's what I found ... <br><br><h4>  Example 1: Matching String </h4><br>  Here is a very simple Ruby script that searches for the word ‚Äúbrown‚Äù in a given string: <br><br><pre><code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"The quick brown fox jumps over the lazy dog."</span></span> p str.match(<span class="hljs-regexp"><span class="hljs-regexp">/brown/</span></span>)</code> </pre> <br>  When I run this code with Ruby's reassembled interpreter, I observe a lot of additional debugging output (much more than I show): <br><br><pre> <code class="bash hljs">$ ruby regex.rb PATTERN: /brown/ (US-ASCII) optimize: EXACT_BM exact: [brown]: length: 5 code length: 7 0:[exact5:brown] 6:[end] match_at: str: 140261368903056 (0x7f912511b590) etc ... size: 44, start offset: 10 10&gt; <span class="hljs-string"><span class="hljs-string">"brown f..."</span></span> [exact5:brown] 15&gt; <span class="hljs-string"><span class="hljs-string">" fox ju..."</span></span> [end] <span class="hljs-comment"><span class="hljs-comment">#&lt;MatchData "brown"&gt;</span></span></code> </pre><br>  The key point is the following " <code>0:[exact5:brown] 6:[end]</code> " - this line describes two virtual machine commands compiled by Oniguruma when compiling the / brown / template.  Here is what this program looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b5/8be/64f/6b58be64feb7a07a94e4aa4fe64b065c.png"><br><br>  You can think of this scheme as a finite automaton for searching / brown /: <br><br><ul><li>  <code>exact5:brown</code> checks the specified string at the current position for the presence of 5 letters "brown"; </li><li>  <code>end</code> means that the search is completed, returns matches and stops execution. </li></ul><br>  When performing a regular expression search, Oniguruma executes these instructions on the virtual machine with the specified string.  Let's take a look at how this works in my example.  First, " <code>exact5:brown</code> " is applied to the given string in the place where the word "brown" is located: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e64/ae2/337/e64ae2337f5d7154bfe46f6760aedf2e.png"><br><br>  How does Oniguruma know where to start the line?  It turns out that it contains an optimizer that decides where to start the search based on the specified string and the first instruction of the virtual machine.  You can see it above: " <code>optimize: EXACT_BM.. exact: [brown]: length: 5.. start offset: 10</code> ".  In this case, since it was precisely known that the word ‚Äúbrown‚Äù should be searched for, Oniguruma jumped to the position where this word appears for the first time.  Yes, I know that this sounds like a hack, but in reality it‚Äôs just a simple optimization of search acceleration in general regular expressions. <br><br>  Then, Oniguruma executes the instruction " <code>exact5:brown</code> ", checking whether the next 5 characters match the pattern or not.  Since they match, Oniguruma moves to the position after them and executes the following instruction: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea5/35d/2fe/ea535d2fe4471e15f117d0b14b4c0150.png"><br><br>  Now the last instruction is executed, which simply means that everything is complete.  Whenever the virtual machine executes " <code>end</code> ", it stops execution, declares success, and returns a matching string. <br><br><h4>  Example 2: Matching one of two strings </h4><br>  Let's take a more complex example and see what happens.  In this template, I want to look for an entry in the string either ‚Äúblack‚Äù or ‚Äúbrown‚Äù: <br><br><pre> <code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"The quick brown fox jumps over the lazy dog."</span></span> p str.match(<span class="hljs-regexp"><span class="hljs-regexp">/black|brown/</span></span>)</code> </pre><br>  Run again: <br><br><pre> <code class="bash hljs">$ ruby regex.rb PATTERN: /black|brown/ (US-ASCII) optimize: EXACT exact: [b]: length: 1 code length: 23 0:[push:(11)] 5:[exact5:black] 11:[jump:(6)] 16:[exact5:brown] 22:[end] match_at: str: 140614855412048 (0x7fe37281c950), ... size: 44, start offset: 10 10&gt; <span class="hljs-string"><span class="hljs-string">"brown f..."</span></span> [push:(11)] 10&gt; <span class="hljs-string"><span class="hljs-string">"brown f..."</span></span> [exact5:black] 10&gt; <span class="hljs-string"><span class="hljs-string">"brown f..."</span></span> [exact5:brown] 15&gt; <span class="hljs-string"><span class="hljs-string">" fox ju..."</span></span> [end] <span class="hljs-comment"><span class="hljs-comment">#&lt;MatchData "brown"&gt;</span></span></code> </pre><br>  Again, the key here is " <code>0:[push:(11)] 5:[exact5:black] 11:[jump:(6)] 16:[exact5:brown] 22:[end]</code> ".  This is a virtual machine program that searches for our template / black | brown /: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31f/18e/b89/31f18eb895b54bd9016b9c77ae458767.png"><br><br>  It's all a bit more complicated!  First of all, you may notice that the optimizer is now looking only for the letter ‚Äúb‚Äù: " <code>optimize: EXACT.. exact: [b]: length: 1</code> ".  This is because the words ‚Äúblack‚Äù and ‚Äúbrown‚Äù both begin with this letter. <br><br>  Now let's step by step analyze the execution of this program: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/633/233/ffa633233a83a54c70ce025c377ef733.png"><br><br>  The " <code>push</code> " command is executed at the position of the first finding of the letter "b".  It passes the following command and place in the source line to what is called the ‚ÄúBacktrack Stack‚Äù (backtrack): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/355/5ac/865/3555ac86596acdd45d4bcb92649b1137.png"><br><br>  We'll see later that the ‚ÄúBacktrack Stack‚Äù is a key place in Oniguruma‚Äôs work.  It uses it to find alternative search paths in a given string, if the first path did not lead to a result.  Let's continue with this example, and you will see what I mean. <br><br>  So, we are going to proceed to the execution of the " <code>exact5:black</code> " command, but in the line there is only the word "brown".  This means that no matches will be found, and the search will not be successful.  However, before returning the result, Oniguruma will check the stack for alternative search paths.  In this case, there is also " <code>exact5.brown</code> " - the second part of my regular expression / black | brown /.  Now Oniguruma pulls out this command and continues execution: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5dc/8f8/fc2/5dc8f8fc28f587c700a55311e26c8bed.png"><br><br>  Now there is a match here, so Oniguruma moves 5 characters and proceeds to the next instruction: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c22/768/a07/c22768a071754fe40602120cead5ba32.png"><br><br>  We again reached the " <code>end</code> " command, so we simply return the matched value. <br><br><h4>  Example 3: Construction * </h4><br>  Now my last example.  Let's see what happens when I use the following regular expression: <br><br><pre> <code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"The quick brown fox jumps over the lazy dog."</span></span> p str.match(<span class="hljs-regexp"><span class="hljs-regexp">/brown.*/</span></span>)</code> </pre><br>  We want to find the entry "brown", and then any sequence of characters to the end of the line.  Let's see the debug output: <br><br><pre> <code class="bash hljs">$ ruby regex.rb PATTERN: /brown.*/ (US-ASCII) optimize: EXACT_BM exact: [brown]: length: 5 code length: 8 0:[exact5:brown] 6:[anychar*] 7:[end] match_at: str: 140284579067040 (0x7f968c80b4a0), ... size: 44, start offset: 10 10&gt; <span class="hljs-string"><span class="hljs-string">"brown f..."</span></span> [exact5:brown] 15&gt; <span class="hljs-string"><span class="hljs-string">" fox ju..."</span></span> [anychar*] 44&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> [end] <span class="hljs-comment"><span class="hljs-comment">#&lt;MatchData "brown fox jumps over the lazy dog."&gt;</span></span></code> </pre><br>  And here we have a new state machine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfe/df6/428/dfedf64288b00ceb91aaa1571a389d9c.png"><br><br>  This time you can see the new Oniguruma virtual machine instruction: " <code>anychar*</code> ".  As you can guess, it represents the syntax pattern " <code>.*</code> ".  Let's look again at what happens at each step: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71d/530/488/71d530488345c1b68cd7397e91e9903a.png"><br><br>  We started again from the 10th position in the line, where ‚Äúbrown‚Äù appears for the first time, and again found a match, as a result, Oniguruma goes further and proceeds to the following instruction: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5cf/544/3a1/5cf5443a1247ff0dcbe0f450396334f1.png"><br><br>  The following instruction is " <code>anychar*</code> ", and this is how it works: <br><ul><li>  First, it matches any character, so it always shifts execution by one character; </li><li>  But, instead of moving to the next command, Oniguruma goes back and executes this instruction again, but for a new symbol; </li><li>  It also writes the current character and the following command to the stack, in this case the " <code>end</code> ". </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/f2e/350/c99/f2e350c99e0e4a381c7c79c595696a95.png"><br><br>  Now Oniguruma just goes through the whole part of the line, repeating these instructions for each "brown fox jumps over the lazy dog."  As it goes through the rest of the line, it again and again writes the " <code>end</code> " instruction <code>end</code> stack: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2af/b94/1e0/2afb941e07e68d74a01504416334eb56.png"><br><br>  And again: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d5/c10/694/7d5c106944bd253cb9d96020c78c99cc.png"><br><br>  Finally, it reaches the end of the original line: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/9d5/79d/7179d579d9ed5b8c14f55ff884b0cf47.png"><br><br>  This time, " <code>anychar*</code> " does not match, since there are no more characters in the string.  What happens in such cases when the team cannot find a match?  As in the previous example, Oniguruma will take a command from the stack and continue searching with it.  Thus, in this case, the " <code>end</code> " command will be executed, indicating the last position of the match in the string.  This means that Oniguruma will receive all the text to the end of the line "brown fox jumps over the lazy dog." <br><br>  But why put the " <code>anychar*</code> " instruction on the stack after each character?  The reason is that if there were some more patterns after the " <code>.*</code> ", Or " <code>.*</code> " Embedded in a more complex general expression, it would not be clear which of the segments of the original string would ultimately lead to complete coincidence .  Perhaps Oniguruma would have to try all the options.  In this simple example, the template is valid to the end of the line, so there is no need to get more than one command from the stack. <br><br>  One interesting detail.  If you add more commands after " <code>.*</code> ", For example, if you search for /.*brown/, then Oniguruma will not use the " <code>anychar*</code> " instruction.  Instead, it will use another similar command, for example, " <code>anychar*-peek-next:b</code> ".  It works just like " <code>anychar*</code> ", but instead of putting the next position on the stack on the stack each time, it puts on the stack only the coincidence position, in this case, with "b".  This optimization works because Oniguruma knows that the next character must be ‚Äúb‚Äù. <br><br><h4>  Pathology of regular expression patterns </h4><br>  I mentioned above that Ruby will show the same bad work as Perl if you give it a very complex regular expression pattern.  In fact, it is very easy to reproduce it on your computer.  Try a very simple regular expression search example: <br><br><pre> <code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"aaa"</span></span> p str.match(<span class="hljs-regexp"><span class="hljs-regexp">/a?a?a?aaa/</span></span>)</code> </pre><br>  It should execute very quickly: <br><br><pre> <code class="bash hljs">$ time ruby regex.rb <span class="hljs-comment"><span class="hljs-comment">#&lt;MatchData "aaa"&gt; ruby regex.rb 0.02s user 0.01s system 30% cpu 0.080 total</span></span></code> </pre><br>  However, if you repeat it using 29 repetitions instead of 3, then the time to find an entry will have explosive growth, as Russ shows on the graph on the left in his first article: <br><br><pre> <code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span></span> <span class="hljs-comment"><span class="hljs-comment"># 29  p str.match(/a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa/)</span></span></code> </pre><br>  Execution with 29 occurrences: <br><br><pre> <code class="bash hljs">$ time ruby regex.rb <span class="hljs-comment"><span class="hljs-comment">#&lt;MatchData "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"&gt; ruby regex.rb 17.09s user 0.01s system 99% cpu 17.098 total</span></span></code> </pre><br>  Or with 30 entries: <br><br><pre> <code class="bash hljs">$ time ruby regex.rb <span class="hljs-comment"><span class="hljs-comment">#&lt;MatchData "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"&gt; ruby regex.rb 34.00s user 0.01s system 99% cpu 34.025 total</span></span></code> </pre><br>  For 31 entries, the time is 67 seconds and increases exponentially.  The reason for this is that the algorithm that Oniguruma uses goes through a list of possible combinations that grows exponentially relative to the length of the regular expression pattern.  This would not have happened if Oniguruma and Ruby used the Thompson algorithm that Russ was talking about! <br><br><h4>  Superficial explanation </h4><br>  As I said, here is just a superficial explanation of what Oniguruma and Ruby can do.  As you probably know, there are many, very many, operators and options for regular expressions that can be used, each of them has corresponding instructions inside the virtual machine.  In addition, my examples were extremely simple and straightforward - in ordinary applications, you can have very complex regular expressions that are compiled into hundreds of different Oniguruma virtual machine instructions, which creates many different ways when searching for the right expression. <br><br>  However, the basic idea will always be the same.  Each regular expression is compiled into a series of virtual machine instructions, which is a finite state machine.  When Oniguruma comes to a standstill in the search, it will choose another variant of the path to the target from the stack, each of which could have been left by the " <code>anychar*</code> " operator or another similar command. </div><p>Source: <a href="https://habr.com/ru/post/231017/">https://habr.com/ru/post/231017/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231007/index.html">Achronix Plis - mastering experience</a></li>
<li><a href="../231009/index.html">Why block Google Play developers?</a></li>
<li><a href="../231011/index.html">Remote control and power device</a></li>
<li><a href="../231013/index.html">Summary of the preparation of pitch-performance</a></li>
<li><a href="../231015/index.html">Popularization of information security through cartoons</a></li>
<li><a href="../231019/index.html">IM + team released protected messenger</a></li>
<li><a href="../231021/index.html">Variadic Templates, Low Coupling and a bit of thinking</a></li>
<li><a href="../231023/index.html">Modernization of mirrors in the hallway</a></li>
<li><a href="../231025/index.html">Camera Review Samsung Galaxy K Zoom</a></li>
<li><a href="../231027/index.html">Robots are engaged in car parking at Dusseldorf Airport</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>