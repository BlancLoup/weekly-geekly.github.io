<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We develop pedal firmware for learning to play the balalaika</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I love video tutorials. For some reason, I personally perceive the information from the text very, very badly. And there are things in which there is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We develop pedal firmware for learning to play the balalaika</h1><div class="post__text post__text-html js-mediator-article">  I love video tutorials.  For some reason, I personally perceive the information from the text very, very badly.  And there are things in which there is not much information on paper.  Take, for example, the balalaika lessons: there are wonderful debates on YouTube, how to play this or that melody (who cares, we search by name "Sergey Vorontsov"), but it is difficult to repeat and memorize the sequence from streaming video.  It is necessary either to write down on paper (judging by the comments under the lessons, some do so), or to re-buy additional materials (but I am not greedy, but homely). <br><br><img src="https://habrastorage.org/webt/g5/_m/ax/g5_maxwworsrjbxqh3n08jytdj4.png"><br><br>  In general, in my balalaic case, and for many others, one should go like this: looked at the fragment, paused, repeated several times after the author, continued viewing.  If something is not clear - I rewind back, looked more closely.  But how does it all wind up if your hands are busy?  Moreover, in my case they are busy, albeit not with a huge button accordion, but still some kind of balalaika.  So, you have to work with your feet. <br><a name="habracut"></a><br>  Many, many years ago, when all progressive humanity used PS / 2 keyboards, they brought us a dozen USB keyboards for the project.  Of course, we connected them to one machine, clicked Ctrl on one of them, Alt on the second, and Del on the third.  The effect has been achieved.  Since then, I know that USB keyboards work completely parallel, so to help the main one, you can connect another one, which will send some codes instead. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So the idea was born to make a pedal that pretends to be a keyboard and sends the player control codes.  As a player, I initially chose VLC Player, as it has well-documented control buttons, but later it turned out that the codes I chose have the exact same purpose when watching videos on YouTube in full-screen mode.  This is good, as with multiple online views for ad impressions, it seems that the author has something to do.  Looking in the downloaded form would not be so ethical. <br><br>  So, we start designing the device. <br><br><h2>  Work logic </h2><br>  At first I wanted to make several pedals, each for its own function.  Initially, I counted 3-4 functions of these functions: on, off, wind there, wind back.  But then I figured out how much plastic it would take, plus - how I would sort out the pedals, and I was sad.  Therefore, it was decided to radically revise all the logic.  What functions are generally needed?  Start-stop, but it often hangs on the same key, usually on the space.  And roll back.  The VLC Player is ‚ÄúShift + Left‚Äù.  In YouTube, as it turned out, too.  And, if you think so - more functions and not necessary. <br><br>  Perfectly!  Let's make a short pedal pressing the ‚Äústart-stop‚Äù function, and a long one - with the ‚Äúrewind back‚Äù function. <br><br>  In the future, you can extend the functionality.  You can train the pedal recognition Morsechians.  My wife, having learned about the idea, suggested coding control pulses using elements of Irish dancing ... In general, you can extend the functionality as you please.  But one thing is clear: one pedal is enough.  Well, now we will do the recognition of long and short clicks. <br><br><h2>  Mechanics </h2><br>  For those who go home in slippers, there is a very simple solution (I found it on the Thingiverse website).  We take a button with a diameter of more than a centimeter, we twist it into any box-shaped object, we get a pedal.  The trouble is that I do not like sneakers, so this option does not suit me personally.  I need a larger surface area so that the foot does not hurt. <br><br>  Pedals in huge quantities are sold on Ali Express, you should look for the word Foot Switch.  The prices there start from 30 rubles, but at this price the cost of delivery may be about four hundred rubles.  Searching, I found out that it is quite possible to find such a pedal, for which the sum ‚Äúprice plus delivery‚Äù will be 150 rubles.  But it will take an average of a couple of months to wait (I recently waited here for an SD card for all three months). <br><br>  So I went the faster way: I made a pedal on a 3D printer.  Personal experience (and all options with Thingiverse) shows that the axis must be metal, otherwise everything will quickly break.  I took the furniture bolt M6x60 that I had with the nut attached to it, as well as the button (PSW-13) in the neighboring Radio Parts and painted them around with plastic as I could.  Here are the source materials: <br><br><img src="https://habrastorage.org/webt/fx/h9/fl/fxh9fljxy-gcfvlvf5s2ovu5sis.jpeg"><br><br>  Here they are inserted in the bottom half.  As you can see, the main feature of the design is walls, at least four millimeters thick.  With such parameters, even the gentle proto-type becomes quite durable.  The button is installed without a nut, since any void under it will lead to a plastic break, and it holds up pretty well and so. <br><br><img src="https://habrastorage.org/webt/xn/6h/zq/xn6hzqfjerkxrderg2kvpnad30o.jpeg"><br><br>  Here is an almost assembled version: <br><br><img src="https://habrastorage.org/webt/qs/ya/gb/qsyagb0p-qbpgmwwc78tvtj7vcc.jpeg"><br><br>  And here is the pedal assembly: <br><br><img src="https://habrastorage.org/webt/fc/as/fu/fcasfu9dy0rvteff4oyskczhvq0.jpeg"><br><br>  Basically, I will attach the STL files, but the solution was not perfect.  However, anyone will be able to repeat it (if they find an M6x60 bolt with the appropriate nut and a PSW-13 button).  For the first time, that's enough, and then - you can stamped mechanics and order with ALI. <br><br><h2>  USB device </h2><br>  Though lately I have been actively promoting PSoC, in the pedals to use it is unheard of waste.  The best solution is to consider a mock-up board based on the STM32F103C8T6, which can now be ordered on ALI Express for about 120 rubles (including shipping). <br><br><img src="https://habrastorage.org/webt/db/ku/er/dbkuerxaai9tfg8t6bjymx2s9xc.jpeg"><br><br>  You can, of course, speculate that there are cheaper AVR-based motherboards, but the price difference is not significant there, and the development time, due to debugging via JTAG, is much less for STM32.  An hour of time (even if it is home) - it is also worth something.  So, according to the total criterion "price of the device + price of labor costs" STM32F103 is the best option for this task.  Especially since I have about a dozen of such prototypes in store for just such a case, so the waiting time for delivery is now zero for me. <br><br>  I rummaged in the network in search of ready-made USB-keyboards based on this crystal.  On Habr√© found an article on how to make a USB mouse.  But I need a keyboard.  On the topic of keyboards, I found many clever tips on the forums (but I wanted something finished) and a couple of some ready-made, but complex projects on GitHub (and I wanted something understandable).  But he who seeks will always find.  Here is a <a href="http://www.avrki.ru/articles/content/joystick_dendy/">wonderful article</a> that has everything you need (even if it‚Äôs in the code, I‚Äôm not afraid of this non-Russian word, potential DeadLock, but I will write my own code).  The main thing is that it clearly describes all the steps, like from a ready-made ‚Äúfish‚Äù made in Cube MX, to get exactly the USB keyboard.  The only thing that the author did not, did not publish key codes.  Add them here: <br><br><img src="https://habrastorage.org/webt/ij/0b/kw/ij0bkwmzj94ve2cqynqsn25ms3y.jpeg"><br><br>  The spoon of tar is that in the modern version of the Cube MX, the names of files, functions, and even constants are slightly different from those specified in that article, but by analogy everything is fast.  I could write a new version of the text, but where is the guarantee that the developers will not change everything again?  They love to do it.  In general, you can see analogues in my example. <br><br>  So.  I created a basic project in Cube MX, made all the changes recommended by the article mentioned above.  What's next?  Next, add a description of the port button.  I chose PB12 (purely because the corresponding contact is located on the corner of the layout).  Since I always work with iron through the mcucpp library of Konstantin Chizhov, we remove the ‚Äú-C99‚Äù macro in the project properties, rename <b>main.c</b> to <b>main.cpp</b> , and then add the declaration to: <br><br><pre><code class="plaintext hljs">typedef Mcucpp::IO::Pb12 pedal1;</code> </pre> <br>  In the <b>main ()</b> function, we add port initialization (switching on port clocking, setting the direction of the leg, turning on the suspender): <br><br><pre> <code class="plaintext hljs">pedal1::ConfigPort::Enable(); pedal1::SetDirRead(); pedal1::SetPullUp (pedal1::Port::PullUp);</code> </pre><br>  Actually, with all the initialization.  I decided to build the main body in the image of the Verilog process.  I do not know why, just wanted.  A process is usually triggered by a clock pulse.  I decided that system tics are perfectly taken as clock ticks.  Therefore, the standard function of the system <b>tick</b> handler in the <b>stm32f1xx_it.c</b> file <b>is</b> added as follows: <br><br><img src="https://habrastorage.org/webt/-h/qy/rk/-hqyrk8ex2a6vmby9pa16sqgwdi.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SysTick_Handler(void) { /* USER CODE BEGIN SysTick_IRQn 0 */ /* USER CODE END SysTick_IRQn 0 */ HAL_IncTick(); HAL_SYSTICK_IRQHandler(); /* USER CODE BEGIN SysTick_IRQn 1 */ TickProcess(); /* USER CODE END SysTick_IRQn 1 */ }</code> </pre><br></div></div><br>  I put the <b>TickProcess ()</b> function in <b>main.</b>  <b>cpp</b> .  First, consider it in its entirety, then - in parts. <br><br><div class="spoiler">  <b class="spoiler_title">Here is the full feature:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">uint8_t report [8] = {0,0,0,0,0,0,0,0}; uint32_t* pReport = (uint32_t*)report; extern "C" void TickProcess() { //      20!!! static const int shortTime = 700; //      static const int longTime = 2000; //    static int localTick = 0; static int tickDuringButton = 0; static bool bButtonStatePrev; bool bButtonState = pedal1::IsSet(); //     if ((!bButtonState) &amp;&amp; bButtonStatePrev) { tickDuringButton = 0; } //     if (bButtonState &amp;&amp; (!bButtonStatePrev)) { //       //  ,  50  () if ((tickDuringButton &gt;100)&amp;&amp;(tickDuringButton &lt; shortTime)) { //    report [2] = 0x2C; } } //    if ((!bButtonState) &amp;&amp; (!bButtonStatePrev)) { if ((tickDuringButton == shortTime)||(tickDuringButton &gt; longTime)) { //  Shift+ report [0] = 2; // Shift report [2] = 0x50; //  } } //    bButtonStatePrev = bButtonState; tickDuringButton += 1; if (localTick++ % 20 == 0) { USBD_HID_SendReport (&amp;hUsbDeviceFS,report,sizeof(report)); pReport [0] = 0; pReport [1] = 0; } }</code> </pre><br></div></div><br>  The first task that is implemented in this handler is simple.  Every 20 milliseconds we send a report containing information about the pressed buttons (if there are no buttons, we still send, just with zeros).  Since the function is called every millisecond, the report should be sent to one of its twenty calls.  For this there is a variable at the beginning of the function: <br><br><pre> <code class="plaintext hljs"> static int localTick = 0;</code> </pre><br>  and the code at the end (we send the data, then we overwrite the buffer in order to start sending zeros from the next session): <br><br><pre> <code class="plaintext hljs"> if (localTick++ % 20 == 0) { USBD_HID_SendReport (&amp;hUsbDeviceFS,report,sizeof(report)); pReport [0] = 0; pReport [1] = 0; }</code> </pre><br>  The second task is more difficult.  She tracks the nature of pressing the pedal and fills the report for later sending.  Why did I say that ideology is like Verilog?  Because I always catch differences in that language: I have a variable in which the current state of the button is put: <br><br><pre> <code class="plaintext hljs"> bool bButtonState = pedal1::IsSet();</code> </pre><br>  and there is a variable in which its previous state is stored (as we remember, the previous state is the button state during the previous processing of the 1 ms timer interrupt): <br><br><pre> <code class="plaintext hljs"> static bool bButtonStatePrev;</code> </pre><br>  The pressed button gives the value <b>false</b> , the pressed button - <b>true</b> .  Thus, you can always conclude about the dynamic state of the button: <br><br><table><tbody><tr><th>  bButtonState </th><th>  bButtonStatePrev </th><th>  condition </th></tr><tr><td>  true </td><td>  true </td><td>  Long released </td></tr><tr><td>  true </td><td>  false </td><td>  Released at the previous measure </td></tr><tr><td>  false </td><td>  true </td><td>  Pressed on the previous measure </td></tr><tr><td>  false </td><td>  false </td><td>  Long pressed </td></tr></tbody></table><br>  We introduce two constants.  One sets the time for a short press.  If the press lasted less than 700 ms, then it is short.  The second sets the time when auto-repeat is enabled.  If you simply start sending the key code after seven hundred milliseconds, the player will start to shake too sharply.  This is revealed empirically.  Therefore, the logic of operation is as follows: after 700 ms, a single ‚ÄúShift + Left‚Äù code is sent, after which the user is given the opportunity to release the pedal.  If the pedal is continued to be held, then from the second second, the constant sending of this code begins until the pedal is released. <br><br><pre> <code class="plaintext hljs"> const int shortTime = 700; //      const int longTime = 2000; //   </code> </pre><br>  The time during which the button is pressed is stored in a variable: <br><br><pre> <code class="plaintext hljs"> static int tickDuringButton = 0;</code> </pre><br>  If the button has just been pressed, zero this variable, starting to measure the new time period: <br><br><pre> <code class="plaintext hljs"> //     if ((!bButtonState) &amp;&amp; bButtonStatePrev) { tickDuringButton = 0; }</code> </pre><br>  If the button has just been released, then we check the time how long it was pressed.  If quite a bit (now ‚Äúless than 100 ms‚Äù is inscribed), it is a bounce.  This does not count.  Ignore this click.  If it is longer than the duration of a short press, we also do nothing; long presses are processed below.  If, within a short press, we generate a report with a space in the buffer (which will be sent when the time comes for this): <br><br><pre> <code class="plaintext hljs"> //     if (bButtonState &amp;&amp; (!bButtonStatePrev)) { //       //  ,  100  () if ((tickDuringButton &gt;100)&amp;&amp;(tickDuringButton &lt; shortTime)) { //    report [2] = 0x2C; } }</code> </pre><br>  If the button has been held for a long time, then we send ‚ÄúShift + Left‚Äù in two cases: <br><br><ul><li>  button hold exactly 700 ms (single package); </li><li>  hold the button for more than 2 seconds (sending in each subsequent report until the button is released). </li></ul><br><pre> <code class="plaintext hljs"> //    if ((!bButtonState) &amp;&amp; (!bButtonStatePrev)) { if ((tickDuringButton == shortTime)||(tickDuringButton &gt; longTime)) { //  Shift+ report [0] = 2; // Shift report [2] = 0x50; //  } }</code> </pre><br>  That's all.  More than this code is no different from the "fish" that we made the Cube MX.  Collecting, stitching ... No, it's impossible without errors (here they are all captured, but I initially couldn't do without them), we detect them in 10 minutes through JTAG debugging (hello to AVR), we sew, rejoice ... <br><br><h2>  Alternative design </h2><br>  In general, such things are useful without a balalaika (or other viewing of video lessons).  In particular, I like to read the news, lying in bed, with a laptop on my stomach.  To scroll the text, you have to keep your right arm bent all the time, and this leads to pain in the elbow.  Therefore, I have long dreamed of a big red button that could scroll pages without bending a hand.  Actually, it can be made from the same components as the pedal, replacing the furniture bolt with a small amount of hot melt glue.  Total: button PSW13, layout STM32F103C8T6, plastic for 3D printer, hot melt glue.  Well, in the ‚Äúfirmware‚Äù I replaced the codes with ‚ÄúPgDn‚Äù by a short press and ‚ÄúUp‚Äù by a long one. <br><br><img src="https://habrastorage.org/webt/t-/pk/ll/t-pkllvtvpapghfjaulfjgzevcw.jpeg"><br><br><img src="https://habrastorage.org/webt/ma/rc/qa/marcqa0tmbl5iypd5sb3al1zvlw.png"><br><br><h2>  Conclusion </h2><br>  You can use your legs to control the display of video lessons when your hands are busy.  To do this, just one pedal, imitating the operation of the USB-keyboard.  One pedal can send multiple key codes by selecting them based on various types of keystrokes.  The article discusses a pedal that disassembles two types (short and long press). <br><br>  Mechanics can be found on Ali Express with the word Foot Switch or can be printed on a 3D printer.  As electronics, a STM32F103C8T6 prototype board can be used.  ‚ÄúFirmware‚Äù is done in less than an hour on the basis of ‚Äúfish‚Äù created by Cube MX from the manufacturer of the STM32 controllers.  The additional code takes up several screens of text (for 2K resolution, one screen). <br><br>  In general, the entire device (mechanics + ‚Äúfirmware‚Äù) was completely designed in one evening, plus it took about four hours to print the mechanics on a 3D printer. <br><br>  Ready STL files for pedal printing can be <a href="https://yadi.sk/d/4YYyMgUU6b2A-A">downloaded here</a> (the Top element should preferably be lowered by 0.4 mm to avoid a large number of supports: the surface turned out to be slightly rounded, lowering the model, we will make the printed part flat). <br><br>  STL files of the ‚Äúbig red button‚Äù can be <a href="https://yadi.sk/d/1ixVC_0HniEcJA">downloaded here</a> . <br><br>  The finished project source files and the HEX firmware file can be <a href="https://yadi.sk/d/qGJjsJNNXSUwdg">downloaded here</a> . <br><br>  Date of publication of this article was not chosen randomly.  The council decided that it was better to publish an article about such things on a serious website that day.  But in fact, if you watch videos found by the phrases ‚ÄúAlexey Arkhipovsky‚Äù, ‚ÄúDmitry Kalinin‚Äù, ‚ÄúCranberry Show‚Äù, ‚ÄúAlexey Kodenko‚Äù, then it becomes clear that the academic balalaika is like an assembler.  Both there and there absolute simplicity and mad expressive power are combined.  And according to the phrase "Sergey Vorontsov" you can understand how to learn how to use this tool. </div><p>Source: <a href="https://habr.com/ru/post/445160/">https://habr.com/ru/post/445160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445150/index.html">Upwork is registered in the Russian Federation</a></li>
<li><a href="../445152/index.html">What else can be done in the search? Yandex report</a></li>
<li><a href="../445154/index.html">Digital events in Moscow from March 25 to March 31</a></li>
<li><a href="../445156/index.html">Compact nebulizer Glenmark: useful thing in everyday life</a></li>
<li><a href="../445158/index.html">Optimum part orientation and support configuration in a 3D printer</a></li>
<li><a href="../445162/index.html">Terraform provider selectel</a></li>
<li><a href="../445164/index.html">Balanced site indicators. Part 5: Usability</a></li>
<li><a href="../445166/index.html">Everything you need to know about automatic hyping in CSS</a></li>
<li><a href="../445168/index.html">Perfect resume to be welcomed by a recruiter and an employer</a></li>
<li><a href="../445170/index.html">Three Big Lies about JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>