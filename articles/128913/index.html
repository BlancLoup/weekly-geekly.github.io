<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Image compression using wavelet</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wavelet compression is the generic name for a class of image coding methods that use a two-dimensional wavelet decomposition of an image to be encoded...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Image compression using wavelet</h1><div class="post__text post__text-html js-mediator-article">  Wavelet compression is the generic name for a class of image coding methods that use a two-dimensional wavelet decomposition of an image to be encoded.  Usually implied lossy compression.  The article will not provide complex mathematical formulas, the whole theory can be read on the links at the bottom of the article.  Here is only practice! <br><br><h4>  JPEG difference </h4><br>  The <a href="http://ru.wikipedia.org/wiki/JPEG">JPEG</a> algorithm, unlike the wavelet one, individually compresses each block of the original image of 8 by 8 pixels.  As a result, a block structure may be noticeable at high degrees of compression on the reconstructed image.  With wavelet compression, this problem does not arise, but other types of distortion may appear, having the appearance of ‚Äúghostly‚Äù ripples near sharp boundaries. <br>  It is believed that such artifacts on average are less noticeable to the observer than the "squares" created by JPEG. <br><br><h4>  Example </h4><br>  For example, we strongly compress the same <a href="">image to</a> approximately the same size: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the beginning using JPEG: <br><img src="https://habrastorage.org/storage1/5aea045e/9456c878/e79c72d9/54212e47.jpg" alt="7959 bytes"><br>  (7959 bytes) <br><br>  then the JPEG 2000 wavelet compression algorithm: <br><img src="https://habrastorage.org/storage1/237d629a/8798d468/b42d8756/fccdbff9.jpg" alt="7813 bytes"><br>  (7813 bytes) <br><br><a name="habracut"></a>  In these examples, you can immediately see the nature of the introduced distortions by both algorithms.  The image compressed using wavelet looks clearly better. <br><br>  Another example of compressing <a href="">another image</a> , with a reduction in file size of up to 3kb each: <br><br><img src="https://habrastorage.org/storage1/bb58aee2/7c1e6a7e/eb17cdf6/d295d454.jpg" alt="Jpeg"><br>  (Jpeg) <br><br><img src="https://habrastorage.org/storage1/7c704176/ad0d0ca5/0d299421/b47ee3d2.jpg" alt="JPEG 2000"><br>  (JPEG 2000) <br><br><h4>  What is it? </h4><br>  The method I implemented is in essence an analogue of the well-known <a href="http://ru.wikipedia.org/wiki/JPEG_2000">JPEG 2000</a> wavelet compression algorithm, which has not replaced the popular JPEG.  A few years ago I re-branded it into VisualBasic6.0, but especially for understanding the source code for most of the audience, I rewrote it in C #. <br>  In the presented implementation, I used a fast lifting of a discrete biorthogonal CDF 9/7 wavelet used in the JPEG 2000 image compression algorithm. You can download the C implementation <a href="">here</a> . <br><br><h4>  The limitations of the code presented here are: </h4><br>  In order not to inflate the code, I did not tolerate the ability to compress images of any size and with any aspect ratio.  Therefore, it can compress only square images, the size of the sides 256x256, 512x512, 1024x1024, 2048x2048, etc.  I also removed the memory optimization and saving / reading of the header of the file with the coefficients used in compression.  Otherwise, the code would again be unnecessarily bloated. <br><br><h4>  Main compression script: </h4><ol><li>  Load image from file; </li><li>  Convert the loaded image into a byte array of RGB values; </li><li>  Recode RGB to YCrCb with quantization of the resulting color components; </li><li>  We apply wavelet; </li><li>  We translate a multidimensional array into one-dimensional (flat); </li><li>  We compress the received stream by any available means (for example GZip). </li></ol>  The coefficients for compression in the presented code are selected in order to obtain the minimum size of the output file, but with the ability to see something. <br><br><h4>  Compressor Code (C #) </h4><br>  I am not an ace in C #, so maybe there are places in the code where you could use the standard .Net methods. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Imaging; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO.Compression; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">WaveleteCompression</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">wvCompress</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  public const int WV_LEFT_TO_RIGHT = 0; public const int WV_TOP_TO_BOTTOM = 1; public byte[] run(string path) { //     Bitmap bmp = new Bitmap(path, true); //       byte[, ,] b = this.BmpToBytes_Unsafe(bmp); //   byte[] o = this.Compress(b, bmp.Width, bmp.Height); //   RAW  - FileStream f = new System.IO.FileStream(path + ".raw", FileMode.Create, FileAccess.Write); f.Write(o, 0, o.Length); f.Close(); //     Gzip-     //         GZIP,        2   string outGZ = path + ".gz"; FileStream outfile = new FileStream(outGZ, FileMode.Create); GZipStream compressedzipStream = new GZipStream(outfile, CompressionMode.Compress, true); compressedzipStream.Write(o, 0, o.Length); compressedzipStream.Close(); //   GZip-  return o; } private byte[] Compress(byte[, ,] rgb, int cW, int cH) { // ,     int[] dwDiv = { 48, 32, 16, 16, 24, 24, 1, 1 }; int[] dwTop = { 24, 32, 24, 24, 24, 24, 32, 32 }; int SamplerDiv = 2, SamplerTop = 2; //   Y, cr, cb   int YPerec = 100, crPerec = 85, cbPerec = 85; int WVCount = 6; //     //  RGB  YCrCb double[, ,] YCrCb = YCrCbEncode(rgb, cW, cH, YPerec, crPerec, cbPerec, cW, cH); //         for (int z = 0; z &lt; 3; z++) { //       for (int dWave = 0; dWave &lt; WVCount; dWave++) { int waveW = Convert.ToInt32(cW / Math.Pow(2, dWave)); int waveH = Convert.ToInt32(cH / Math.Pow(2, dWave)); if (z == 2) { //    Y    , // ..      ( ),        YCrCb = WaveletePack(YCrCb, z, waveW, waveH, dwDiv[dWave], dwTop[dWave], dWave); } else { YCrCb = WaveletePack(YCrCb, z, waveW, waveH, dwDiv[dWave] * SamplerDiv, dwTop[dWave] * SamplerTop, dWave); } } } //     byte[] flattened = doPack(YCrCb, cW, cH, WVCount); return flattened; } /*     Double    Byte            .    Double    Short.  ,         ,         255 */ private byte[] doPack(double[, ,] ImgData, int cW, int cH, int wDepth) { short Value; int lPos = 0; int size = cW * cH * 3; //   short  int intCount = 0; short[] shorts = new short[size]; byte[] Ret = new byte[size]; //     - for(int d = wDepth-1; d &gt;= 0; d--) { int wSize = (int)Math.Pow(2f, Convert.ToDouble(d)); int W = cW / wSize; int H = cH / wSize; int w2 = W / 2; int h2 = H / 2; //    if (d == wDepth - 1) { for (int z = 0; z &lt; 3; z++) { for (int j = 0; j &lt; h2; j++) { for (int i = 0; i &lt; w2; i++) { Value = (short)Math.Round(ImgData[z, i, j]); if ((Value &gt;= -127) &amp;&amp; (Value &lt;= 127)) { Ret[lPos++] = Convert.ToByte(Value + 127); } else { Ret[lPos++] = 255; shorts[intCount++] = Value; } } } } } //   +   for (int z = 0; z &lt; 3; z++) { for (int j = 0; j &lt; H; j++) { for (int i = w2; i &lt; W; i++) { Value = (short)Math.Round(ImgData[z, i, j]); if ((Value &gt;= -127) &amp;&amp; (Value &lt;= 127)) { Ret[lPos++] = Convert.ToByte(Value + 127); } else { Ret[lPos++] = 255; shorts[intCount++] = Value; } } } } //   for (int z = 0; z &lt; 3; z++) { for (int j = h2; j &lt; H; j++) { for (int i = 0; i &lt; w2; i++) { Value = (short)Math.Round(ImgData[z, i, j]); if ((Value &gt;= -127) &amp;&amp; (Value &lt;= 127)) { Ret[lPos++] = Convert.ToByte(Value + 127); } else { Ret[lPos++] = 255; shorts[intCount++] = Value; } } } } } //    (byte[]  short[])   int shortArraySize = intCount * 2; Array.Resize(ref Ret, Ret.Length + shortArraySize); Buffer.BlockCopy(shorts, 0, Ret, Ret.Length - shortArraySize, shortArraySize); //     return Ret; } private double[, ,] WaveletePack(double[, ,] ImgArray, int Component, int cW, int cH, int dwDevider, int dwTop, int dwStep) { short Value; int cw2 = cW / 2; int cH2 = cH / 2; //    double dbDiv = 1f / dwDevider; ImgArray = Wv(ImgArray, cW, cH, Component, WV_TOP_TO_BOTTOM); ImgArray = Wv(ImgArray, cH, cW, Component, WV_LEFT_TO_RIGHT); //  for (int j = 0; j &lt; cH; j++) { for (int i = 0; i &lt; cW; i++) { if ((i &gt;= cw2) || (j &gt;= cH2)) { Value = (short)Math.Round(ImgArray[Component, i, j]); if (Value != 0) { int value2 = Value; if (value2 &lt; 0) { value2 = -value2; } if (value2 &lt; dwTop) { ImgArray[Component, i, j] = 0; } else { ImgArray[Component, i, j] = Value * dbDiv; } } } } } return ImgArray; } //     CDF 9/7  private double[, ,] Wv(double[, ,] ImgArray, int n, int dwCh, int Component, int Side) { double a; int i, j, n2 = n / 2; double[] xWavelet = new double[n]; double[] tempbank = new double[n]; for (int dwPos = 0; dwPos &lt; dwCh; dwPos++) { if (Side == WV_LEFT_TO_RIGHT) { for (j = 0; j &lt; n; j++) { xWavelet[j] = ImgArray[Component, dwPos, j]; } } else if (Side == WV_TOP_TO_BOTTOM) { for (i = 0; i &lt; n; i++) { xWavelet[i] = ImgArray[Component, i, dwPos]; } } // Predict 1 a = -1.586134342f; for (i = 1; i &lt; n - 1; i += 2) { xWavelet[i] += a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[n - 1] += 2 * a * xWavelet[n - 2]; // Update 1 a = -0.05298011854f; for (i = 2; i &lt; n; i += 2) { xWavelet[i] += a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[0] += 2 * a * xWavelet[1]; // Predict 2 a = 0.8829110762f; for (i = 1; i &lt; n - 1; i += 2) { xWavelet[i] += a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[n - 1] += 2 * a * xWavelet[n - 2]; // Update 2 a = 0.4435068522f; for (i = 2; i &lt; n; i += 2) { xWavelet[i] += a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[0] += 2 * a * xWavelet[1]; // Scale a = 1f / 1.149604398f; j = 0; //     "" //     "" if (Side == WV_LEFT_TO_RIGHT) { for (i = 0; i &lt; n2; i++) { ImgArray[Component, dwPos, i] = xWavelet[j++] / a; ImgArray[Component, dwPos, n2 + i] = xWavelet[j++] * a; } } else if (Side == WV_TOP_TO_BOTTOM) { for (i = 0; i &lt; n2; i++) { ImgArray[Component, i, dwPos] = xWavelet[j++] / a; ImgArray[Component, n2 + i, dwPos] = xWavelet[j++] * a; } } } return ImgArray; } //   RGB  YCrCb private double[, ,] YCrCbEncode(byte[, ,] BytesRGB, int cW, int cH, double Ydiv, double Udiv, double Vdiv, int oW, int oH) { double vr, vg, vb; double kr = 0.299, kg = 0.587, kb = 0.114, kr1 = -0.1687, kg1 = 0.3313, kb1 = 0.5, kr2 = 0.5, kg2 = 0.4187, kb2 = 0.0813; Ydiv = Ydiv / 100f; Udiv = Udiv / 100f; Vdiv = Vdiv / 100f; double[, ,] YCrCb = new double[3, cW, cH]; for (int j = 0; j &lt; oH; j++) { for (int i = 0; i &lt; oW; i++) { vb = (double)BytesRGB[0, i, j]; vg = (double)BytesRGB[1, i, j]; vr = (double)BytesRGB[2, i, j]; YCrCb[2, i, j] = (kr * vr + kg * vg + kb * vb) * Ydiv; YCrCb[1, i, j] = (kr1 * vr - kg1 * vg + kb1 * vb + 128) * Udiv; YCrCb[0, i, j] = (kr2 * vr - kg2 * vg - kb2 * vb + 128) * Udiv; } } return YCrCb; } private unsafe byte[, ,] BmpToBytes_Unsafe(Bitmap bmp) { BitmapData bData = bmp.LockBits(new Rectangle(new Point(), bmp.Size), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb); // number of bytes in the bitmap int byteCount = bData.Stride * bmp.Height; byte[] bmpBytes = new byte[byteCount]; Marshal.Copy(bData.Scan0, bmpBytes, 0, byteCount); // Copy the locked bytes from memory // don't forget to unlock the bitmap!! bmp.UnlockBits(bData); byte[, ,] ret = new byte[3, bmp.Width, bmp.Height]; for (int z = 0; z &lt; 3; z++) { for (int i = 0; i &lt; bmp.Width; i++) { for (int j = 0; j &lt; bmp.Height; j++) { ret[z, i, j] = bmpBytes[j * bmp.Width * 3 + i * 3 + z]; } } } return ret; } } }</span></span></code> </pre> <br><h4>  Decompressor code </h4><br>  Naturally the decompressor does everything in reverse order. <br>  As I already wrote above, for the sake of readability of the code, I did not begin to save to the header file. <br>  Therefore, in the run () method, the size of the decoded image and the coefficients for decoding the wavelet are rigidly clogged. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">WaveleteCompression</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">wvDecompress</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  public const int WV_LEFT_TO_RIGHT = 0; public const int WV_TOP_TO_BOTTOM = 1; public byte[] run(byte[] compressed) { int z; int dwDepth = 6; //     (  ,   ) //     int w = 512; int h = 512; //            (header)   int[] dwDiv = { 48, 32, 16, 16, 24, 24, 1, 1 }, dwTop = { 24, 32, 24, 24, 24, 24, 32, 32 }; int SamplerDiv = 2, YPerec = 100, crPerec = 85, cbPerec = 85; double[,,] yuv = doUnPack(compressed, w, h, dwDepth); //   for(z = 0; z &lt; 2; z++) { for(int dWave = dwDepth - 1; dWave &gt;= 0; dWave--) { int w2 = Convert.ToInt32(w / Math.Pow(2, dWave)); int h2 = Convert.ToInt32(h / Math.Pow(2, dWave)); WaveleteUnPack(yuv, z, w2, h2, dwDiv[dWave] * SamplerDiv); } } z = 2; for(int dWave = dwDepth - 1; dWave &gt;= 0; dWave--) { int w2 = Convert.ToInt32(w / Math.Pow(2, dWave)); int h2 = Convert.ToInt32(h / Math.Pow(2, dWave)); WaveleteUnPack(yuv, z, w2, h2, dwDiv[dWave]); } // YCrCb  +      byte[] rgb_flatened = this.YCrCbDecode(yuv, w, h, YPerec, crPerec, cbPerec); return rgb_flatened; } //      DoPack   wvCompress. //      (short)double-   byte[] private static double[, ,] doUnPack(byte[] Bytes, int cW, int cH, int dwDepth) { int lPos = 0; byte Value; int intIndex = 0; //      int size = cW * cH * 3; //        double[,,] ImgData = new double[3, cW, cH]; int shortsLength = Bytes.Length - size; short[] shorts = new short[shortsLength / 2]; Buffer.BlockCopy(Bytes, size, shorts, 0, shortsLength); for (int d = dwDepth - 1; d &gt;= 0; d--) { int wSize = (int)Math.Pow(2, d); int W = cW / wSize; int H = cH / wSize; int w2 = W / 2; int h2 = H / 2; //   if (d == dwDepth - 1) { for (int z = 0; z &lt; 3; z++) { for (int j = 0; j &lt; h2; j++) { for (int i = 0; i &lt; w2; i++) { Value = Bytes[lPos++]; if(Value == 255) { ImgData[z, i, j] = shorts[intIndex++]; } else { ImgData[z, i, j] = Value - 127; } } } } } //   +   for (int z = 0; z &lt; 3; z++) { for (int j = 0; j &lt; H; j++) { for (int i = w2; i &lt; W; i++) { Value = Bytes[lPos++]; if(Value == 255) { ImgData[z, i, j] = shorts[intIndex++]; } else { ImgData[z, i, j] = Value - 127; } } } } //   for (int z = 0; z &lt; 3; z++) { for (int j = h2; j &lt; H; j++) { for (int i = 0; i &lt; w2; i++) { Value = Bytes[lPos++]; if (Value == 255) { ImgData[z, i, j] = shorts[intIndex++]; } else { ImgData[z, i, j] = Value - 127; } } } } } //   return ImgData; } //    private void WaveleteUnPack(double[,,] ImgArray, int Component, int cW, int cH, int dwDevider) { int cw2 = cW / 2, ch2 = cH / 2; double dbDiv = 1f / dwDevider; //   for(int i = 0; i &lt; cW; i++) { for(int j = 0; j &lt; cH; j++) { if ((i &gt;= cw2) || (j &gt;= ch2)) { if (ImgArray[Component, i, j] != 0) { ImgArray[Component, i, j] /= dbDiv; } } } } //   for(int i = 0; i &lt; cW; i++) { reWv(ref ImgArray, cH, Component, i, WV_LEFT_TO_RIGHT); } for(int j = 0; j &lt; cH; j++) { reWv(ref ImgArray, cW, Component, j, WV_TOP_TO_BOTTOM); } } //       CDF 9/7  private void reWv(ref double[, ,] shorts, int n, int z, int dwPos, int Side) { double a; double[] xWavelet = new double[n]; double[] tempbank = new double[n]; if(Side == WV_LEFT_TO_RIGHT) { for(int j = 0; j &lt; n; j++) { xWavelet[j] = shorts[z, dwPos, j]; } } else if (Side == WV_TOP_TO_BOTTOM) { for(int i = 0; i &lt; n; i++) { xWavelet[i] = shorts[z, i, dwPos]; } } for(int i = 0; i &lt; n / 2; i++) { tempbank[i * 2] = xWavelet[i]; tempbank[i * 2 + 1] = xWavelet[i + n / 2]; } for(int i = 0; i &lt; n; i++) { xWavelet[i] = tempbank[i]; } // Undo scale a = 1.149604398f; for(int i = 0; i &lt; n; i++) { if(i % 2 != 0) { xWavelet[i] = xWavelet[i] * a; } else { xWavelet[i] = xWavelet[i] / a; } } // Undo update 2 a = -0.4435068522f; for (int i = 2; i &lt; n; i += 2) { xWavelet[i] = xWavelet[i] + a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[0] = xWavelet[0] + 2 * a * xWavelet[1]; // Undo predict 2 a = -0.8829110762f; for (int i = 1; i &lt; n - 1; i += 2) { xWavelet[i] = xWavelet[i] + a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[n - 1] = xWavelet[n - 1] + 2 * a * xWavelet[n - 2]; // Undo update 1 a = 0.05298011854f; for (int i = 2; i &lt; n; i += 2) { xWavelet[i] = xWavelet[i] + a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[0] = xWavelet[0] + 2 * a * xWavelet[1]; // Undo predict 1 a = 1.586134342f; for (int i = 1; i &lt; n - 1; i += 2) { xWavelet[i] = xWavelet[i] + a * (xWavelet[i - 1] + xWavelet[i + 1]); } xWavelet[n - 1] = xWavelet[n - 1] + 2 * a * xWavelet[n - 2]; if(Side == WV_LEFT_TO_RIGHT) { for (int j = 0; j &lt; n; j++) { shorts[z, dwPos, j] = xWavelet[j]; } } else if(Side == WV_TOP_TO_BOTTOM) { for(int i = 0; i &lt; n; i++) { shorts[z, i, dwPos] = xWavelet[i]; } } } //   YCrCb  RGB private byte[] YCrCbDecode(double[, ,] yuv, int w, int h, double Ydiv, double Udiv, double Vdiv) { byte[] bytes_flat = new byte[3 * w * h]; double vr, vg, vb; double vY, vCb, vCr; Ydiv = Ydiv / 100f; Udiv = Udiv / 100f; Vdiv = Vdiv / 100f; for(int j = 0; j &lt; h; j++) { for (int i = 0; i &lt; w ; i++) { vCr = yuv[0, i, j] / Vdiv; vCb = yuv[1, i, j] / Udiv; vY = yuv[2, i, j] / Ydiv; vr = vY + 1.402f * (vCr - 128f); vg = vY - 0.34414f * (vCb - 128f) - 0.71414f * (vCr - 128f); vb = vY + 1.722f * (vCb - 128f); if (vr &gt; 255) {vr = 255;} if (vg &gt; 255) {vg = 255;} if (vb &gt; 255) {vb = 255;} if (vr &lt; 0) {vr = 0;} if (vg &lt; 0) {vg = 0;} if (vb &lt; 0) {vb = 0;} bytes_flat[j * w * 3 + i * 3 + 0] = (byte)vb; bytes_flat[j * w * 3 + i * 3 + 1] = (byte)vg; bytes_flat[j * w * 3 + i * 3 + 2] = (byte)vr; } } return bytes_flat; } } }</span></span></code> </pre> <br><br><h4>  C # project source codes </h4><br>  <a href="">WaveleteCompression.zip</a> <br><br><h4>  Links </h4><ol><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Wavelet</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B6%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B5_%25D1%2581_%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC_%25D0%25B2%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582">Wavelet compression</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/JPEG_2000">JPEG 2000</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/JPEG">Jpeg</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B2%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Discrete wavelet transform</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Lifting_scheme">Lifting scheme</a> </li></ol>  UPD: <br>  <a href="https://habrahabr.ru/users/mikhanoid/" class="user_link">mikhanoid</a> : 1.149604398, -0.4435068522, -0.8829110762, etc.  - coefficients of the values ‚Äã‚Äãof the functions of the wavelet basis at certain points.  Read in general: <a href="http://en.wikipedia.org/wiki/Lifting_scheme">Lifting scheme</a> </div><p>Source: <a href="https://habr.com/ru/post/128913/">https://habr.com/ru/post/128913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128904/index.html">Microelectronics - psto motivations</a></li>
<li><a href="../128906/index.html">Shortiks a month later, or how does the Habraeffect actually look like</a></li>
<li><a href="../128907/index.html">New physics calculation engine in 3ds Max</a></li>
<li><a href="../128909/index.html">Porting applications to Windows Phone 7</a></li>
<li><a href="../128912/index.html">Business processes in the load</a></li>
<li><a href="../128914/index.html">Create Your Look and Feel - Part I</a></li>
<li><a href="../128915/index.html">Unusual use of the report generator</a></li>
<li><a href="../128918/index.html">Beta test Battlefield 3 starts on September 29</a></li>
<li><a href="../128920/index.html">Spain's anti-monopoly officers launched an investigation into Microsoft</a></li>
<li><a href="../128922/index.html">An example of integrating Robokassa with Rails</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>