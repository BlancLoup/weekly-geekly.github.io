<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About type conversion in arithmetic expressions in C ++ and C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In an arithmetic expression, the types of the operands can be converted to a general type. Such transformations are described in the language standard...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About type conversion in arithmetic expressions in C ++ and C #</h1><div class="post__text post__text-html js-mediator-article">  In an arithmetic expression, the types of the operands can be converted to a general type.  Such transformations are described in the language standard - in C # they are much simpler than in C ++.  However, most likely, not every programmer knows about all the subtleties. <br><a name="habracut"></a><br>  Perhaps you have had cases where the type of arithmetic expression was not as you expected?  How well do you know the standard of the language?  I propose to check myself by replacing <i>auto</i> and <i>var</i> with the correct type in these expressions and at the same time calculate the result: <br><br>  C ++ (we will assume that the <a href="http://www.viva64.com/ru/t/0028/">LP64</a> data model is <a href="http://www.viva64.com/ru/t/0028/">used</a> ): <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = c1 + c2; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = i1 + i2; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> z = i1 + u1; }</code> </pre> <br>  C #: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ byte b1 = byte.MaxValue; byte b2 = byte.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; uint u1 = uint.MaxValue; var x = b1 + b2; var y = i1 + i2; var z = i1 + u1; }</code> </pre> <br>  Answer under the picture <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e28/83f/8e6/e2883f8e6f695c0044326f1b5663d5bf.png"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      C ++ ( <a href="http://www.viva64.com/ru/t/0028/">LP64</a> ): <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = c1 + c2; <span class="hljs-comment"><span class="hljs-comment">// = 510 int y = i1 + i2; // = -2 unsigned int z = i1 + u1; // = 2147483646</span></span></code> </pre> <br>  C #: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = b1 + b2; <span class="hljs-comment"><span class="hljs-comment">// = 510 int y = i1 + i2; // = -2 long z = i1 + u1; // = 6442450942</span></span></code> </pre> <br>  From this test, or more precisely, from the standards of the C ++ language and C # follows: <br><br>  <b>1. Calculate</b> <b><i>x</i></b> <b>.</b>  In an arithmetic expression, all variables whose values ‚Äã‚Äãare representable as <i>int</i> will be converted to <i>int</i> .  Therefore, adding two variables of type <i>char</i> , <i>unsigned char</i> , <i>short int</i> , <i>unsigned short int</i> in C ++, or variables of type <i>byte</i> , <i>sbyte</i> , <i>short</i> , <i>ushort</i> in C #, the result will be of type <i>int</i> and overflow will not occur.  In our examples, the variable <i>x</i> will take the value 510. <br><br>  <b>2. Calculate</b> <b><i>y</i></b> <b>.</b>  If both arguments are of type <i>int the</i> further type expansion will no longer occur and overflow is already possible here.  In C ++, this is undefined behavior.  In C #, by default, in case of overflow, the application will continue to work.  Using the checked keyword or the / checked compiler flag, you can change the behavior of the application so that in case of overflow, OverflowException is thrown.  In our test, the variable <i>y</i> will take the value -2 in both C ++ and C #.  Although I repeat once again that in C ++ we have undefined behavior, the result of which can be anything, for example, the number 100500 can be written to <i>y</i> or a stack overflow occurs. <br><br>  <b>3. Calculating</b> <b><i>z</i></b> <b>.</b>  If one of the arguments is of type <i>int</i> , and the other is <i>unsigned int</i> in C ++ or <i>uint</i> in C #, here the standards of the two languages ‚Äã‚Äãare written differently!  In C ++, both arguments will be converted to the <i>unsigned int</i> type, by the way, there will not be any indefinite behavior during the overflow.  In C #, both arguments will be converted to the <i>long</i> type and no overflow will occur under any circumstances.  That's why we got in our programs in different languages, different values ‚Äã‚Äãfor the variable <i>z</i> . <br><br>  Consider now what errors may contain code that is written without taking into account the correct type conversion. <br><br>  C ++ example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Ipp32u; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Ipp32s; Ipp32u m_iCurrMBIndex; VC1EncoderMBInfo* VC1EncoderMBs::GetPevMBInfo(Ipp32s x, Ipp32s y) { Ipp32s row = (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? m_iPrevRowIndex : m_iCurrRowIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((m_iCurrMBIndex - x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || row &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : &amp;m_MBInfo[row][m_iCurrMBIndex - x]); }</code> </pre> <br>  This is sample code from the IPP Samples project.  When comparing the result of an expression with zero, one should remember that <i>int</i> can be converted to <i>unsigned int</i> , and <i>long</i> - to <i>unsigned long</i> .  In our case, the expression <i>m_iCurrMBIndex</i> - <i>x</i> will have the type <i>unsigned int</i> , and therefore it is always non-negative, as PVS-Studio <a href="http://www.viva64.com/ru/d/0137/">reports</a> : <a href="http://www.viva64.com/ru/d/0137/">V547</a> Expression 'm_iCurrMBIndex - x &lt;0' is always false.  Unsigned type value is never &lt;0. <br><br>  C # example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> num = maxValue - minValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt;= <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>L) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Sample() * num)) + minValue); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetSampleForLargeRange() * num))) + minValue); }</code> </pre> <br>  This is an example from the SpaceEngineers project.  In C #, you need to remember that when adding two variables of type <i>int, the</i> extension to the type of <i>long</i> will not occur, unlike the addition of a variable of type <i>int</i> and a variable of type <i>uint</i> .  Therefore, here the variable <i>num</i> will contain the value of type <i>int</i> , which always satisfies the condition <i>num</i> &lt;= 0x7fffffffL.  PVS-Studio is aware of this and displays the message <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression 'num &lt;= 0x7fffffffL' is always true. <br><br>  It is good when you know the standard and do not make such mistakes, but in practice it is difficult to constantly remember all the subtleties of the language, and in the case of C ++ it is completely unrealistic.  Therefore, it is useful to use static analyzers, for example, <a href="http://www.viva64.com/">PVS-Studio</a> . <br><br><h2>  Additional links </h2><br><ol><li>  <a href="http://en.cppreference.com/w/cpp/language/operator_arithmetic">Type conversion in arithmetic expressions in C ++</a> . </li><li>  <a href="https://msdn.microsoft.com/en-us/library/aa691330.aspx">Type conversion in arithmetic expressions in C #</a> . </li></ol><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0386/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Ilya Ivanov.  <a href="http://www.viva64.com/en/b/0386/">Type Conversion in C ++ and C # Arithmetic Expressions</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/280396/">https://habr.com/ru/post/280396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280384/index.html">Million files and one laptop</a></li>
<li><a href="../280386/index.html">Flume - manage data streams. Part 1</a></li>
<li><a href="../280388/index.html">Understanding multithreading in RxJava</a></li>
<li><a href="../280390/index.html">SaaS solutions to protect any device anywhere: why it‚Äôs simpler and cheaper + implementation example</a></li>
<li><a href="../280394/index.html">How to develop 1C: ERP (and not only)</a></li>
<li><a href="../280400/index.html">Playtests: fears and opportunities</a></li>
<li><a href="../280402/index.html">Installing Bitrix24 on IIS server using MSSQL and AD</a></li>
<li><a href="../280404/index.html">Some features of development for Ubuntu Touch</a></li>
<li><a href="../280406/index.html">Public interviews on the position of a web developer live</a></li>
<li><a href="../280408/index.html">Microsoft fixed multiple bugs in the system components of Windows 8.1 and Server 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>