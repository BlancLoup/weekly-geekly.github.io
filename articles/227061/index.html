<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SDN: revolution or evolution? Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Daniel Ginsburg, I work in Yandex as a network architect. 

 In my report, I tried to give my definition of the concept Software-define...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SDN: revolution or evolution? Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article">  Hi, my name is Daniel Ginsburg, I work in Yandex as a network architect. <br><br>  In my report, I tried to give my definition of the concept Software-defined Network, which today is understood in the industry both too broadly and too narrowly.  My story also touched upon the historical roots of the SDN, its future, and practical deployment issues. <br><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://video.yandex.ru/iframe/ya-events/m-38157-1503f582c24-11c29b527b15da5e/&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhgMRsO9SAknhGVsfEuI7e7U6CIeaQ" width="450" height="150" frameborder="0" scrolling="no" allowfullscreen="1"></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://video.yandex.ru/users/ya-events/view/2090">Video of the report</a> <br><br> <a href="http://habrahabr.ru/company/yandex/blog/227061/"><img src="https://habrastorage.org/getpro/habr/post_images/e46/b3f/a4f/e46b3fa4fbf27b7b85038c47a31c4d94.png" width="800"></a> <br><br>  To begin, let us try to answer the question, do we all have a good network?  Maybe we do not need to redo anything?  I am sure that this is not the case, and now I will try to substantiate my point of view. <br><a name="habracut"></a><br><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=http://www.slideshare.net/slideshow/embed_code/28734106&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhg879j4rToYKBuCxSuWW7fBLUTkgA" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div><br><br><h4>  Complexity </h4><br>  What is wrong now in the networked world?  The first thing that kills us is complexity.  Our network solutions, our networks are complex.  The difficulty prevents us from scaling, managing networks, making them fragile.  Difficulty is our enemy.  The transfer of useful traffic (data-plane is complicated. The data-plane of our glands knows a lot of things: to forward millions of encapsulations, to make a million different tunnels (and we continue to invent new ones). There are people who build absolutely horrible constructions from this. <br><br>  For example, they drive a multicast through <a href="http://www.cisco.com/c/en/us/tech/lan-switching/integrated-routing-bridging-irb/index.html">IRB</a> , which sticks out in <a href="http://en.wikipedia.org/wiki/Virtual_Private_LAN_Service">VPLS</a> , under which <a href="http://en.wikipedia.org/wiki/Link_aggregation">link aggregation groups</a> lie.  Such a thing is impossible to scale, impossible to debug.  And it is expensive, expensive in terms of iron and in terms of working time. <br><br>  All this wealth of data-plane capabilities must somehow be managed.  And since this whole economy is so complicated, it is difficult to manage it. <br><br>  We build wild sandwiches from protocols, and our control protocols evolve momentarily. <br><br>  My favorite (though not the most glaring) example of the momentary is the <a href="http://en.wikipedia.org/wiki/Multiprotocol_BGP">Multiprotocol BGP</a> .  In order to announce a route on it, next hop in this announcement must have the same address family (v4, v6 or something else).  When we want a v4 route with v6 next hop, we begin to invent new RFCs.  Accordingly, we have <i>n</i> <acronym>NLRI</acronym> , then <i>n <sup>2</sup></i> RFC potentially appears.  This is a terrible, flawed and inexpressive abstraction. <br><br>  When I create a network, I first of all imagine how the traffic should flow.  From here I immediately imagine how my forwarding tables should be filled.  And then I begin to think, how can I, with the help of existing protocols, fill these tables in the way I want.  And this is not always the case.  It is because of inexpressive abstractions. <br><br>  All this is very expensive.  A network element that has tremendous complexity in data-plane and <a href="http://en.wikipedia.org/wiki/Routing_control_plane">control-plane</a> , in a particular case, uses, say, 5% of opportunities, and is paid for all 100. And it is paid not only with the price of a piece of hardware, but also with the complexity of the software that is used on it, bugs in it, network fragility. <br><br><h4>  Feature velocity </h4><br>  When I need a new feature in the hardware, I come to the vendor.  If I'm lucky, I will get this feature in a year, and refracted through the mind of a vendor who knows "how best." <br><br>  Among other things, because of this, we have extremely difficult automation.  Each vendor invents its own automatic configuration method.  If I have a new vendor, I need to modify the entire control and automation system.  Not from scratch, of course, but significantly. <br><br><h2>  What to do with it </h2><br>  Obviously, you need to do something with it.  For example, remake everything and call it SDN. <br><br>  I cannot give an exact definition of this term, no one can.  Some associate it with the <a href="http://ru.wikipedia.org/wiki/Openflow">OpenFlow</a> initiative, some use it simply as an adjective in the synonymous series ‚Äúgood‚Äù, ‚Äúfashionable‚Äù, ‚Äúmodern‚Äù. <br><br>  So what is SDN?  This is something that will give us comfortable abstractions.  They will be simple, understandable natural, expressive and complete.  This will allow you to implement the necessary functions of the network yourself, and not wait for the vendor to do this.  Naturally, automation will be simplified. <br><br>  First, to separate the passage of traffic (data-plane) and signaling / control (control plane).  Secondly, to make the data-plane elements as simple as possible and, thirdly, to centralize the control-plane.  This all allows you to quickly and easily implement convenient abstractions in the control-plane independently of the data-plane. <br><br>  Now we will sort all these ideas in order. <br><br><h4>  Separation of data-plane and control-plane </h4><br>  The first question that arises in connection with the separation of data-plane and control-plane is how much should they be separated? <br><br>  This is not a new idea, they have done it or tried to do it many times already.  For example, any modern router is designed.  There are data-plane elements: forwarding engines that take packets and decide where to forward them, there is a switching matrix connecting them.  The control module exists separately.  User traffic flows through, control traffic enters the control engine, which programs the forwarding engine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e07/3ac/e5f/e073ace5f34563793d49ae81201c4ac3.png" width="640"><br><br>  This approach allows you to scale a separate network element.  On the other hand, such an approach extremely complicates the failure model.  Such composite construction breaks in parts.  Moreover, even the data-plane can break partially.  For example, if you have a broken switching matrix, and the control engine did not notice this, all user traffic will simply be dropped.  Management traffic will continue to go, and everyone will think that our network element is alive. <br><br>  On the diagram, this is not the case, but the blue traffic goes through a separate internal out-of-band control network.  And this network may also refuse.  If we take and divide the data-plane and the control-plane not within the same network element, but across the entire network, the out-of-band-management network will become as complex as our data-plane.  Accordingly, it will break as often and badly as the main network. <br><br>  The question also arises: how is it to manage the control network if it is as complex as the network transmitting useful traffic? <br><br><h4>  Simplify network elements </h4><br>  Let us turn to the idea of ‚Äã‚Äãsimplifying the data-plane elements.  We have to come up with a fairly simple and general abstraction for managing the network element.  Simple, understandable, quite flexible and expressive. <br><br>  How simple should this abstraction be?  If you don‚Äôt go deep into the details, the data-plane looks like this: a packet comes to us, we take fields from the header, lookup in the forwarding table, modify the packet headers and send to the next interface. <br><br>  The reality is somewhat more complicated.  Here is a very simplified diagram of what is happening in a single chip of a network element: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e46/b3f/a4f/e46b3fa4fbf27b7b85038c47a31c4d94.png" width="640"><br><br>  What abstraction of data-plane elements does <a href="http://ru.wikipedia.org/wiki/Openflow">OpenFlow</a> offer us?  We have fields, there is a table of lukap, we do a search, determine what needs to be done and implement it.  Everything is extremely simple. <br><br>  One of the problems with abstraction in OpenFlow 1.0 is a combinatorial explosion.  For example, take a simple artificial task.  We need to pass traffic to N hosts on the same M TCP ports, and reset the rest of the traffic.  In OpenFlow 1.0, for this we need NxM records, we have to list all the host-port combinations.  Scale this will not work. <br><br>  In OpenFlow 1.1 and all subsequent versions, the idea of ‚Äã‚Äãmultiple tables appears.  This eliminates the combinatorial explosion.  The idea is relatively elegant, but it has a problem, it reflects badly on the gland.  The fact is that iron, which costs reasonable money, does not know how to make Lukapas in any order. <br><br>  In modern iron there is an opportunity to do multi-stage processing.  We find the corresponding entry in the table, and then we carry out several processing steps: add a label, overwrite the title, then something else, etc.  This is called indirect next hops: one next hop in this case refers to the other by the index of the table.  Those.  finding the next is easy.  However, in the construction with multiple tables, we have no direct links, and we will be forced to do a multifield lookup several times, which is quite expensive.  However, we get rid of the combinatorial explosion and the same problem with N hosts and M ports is solved much easier: we will not have two tables: N records in one and M records in another. <br><br>  The <a href="https://www.opennetworking.org/working-groups/forwarding-abstractions">Forwarding Abstractions working group (FAWG)</a> operates within the framework of the Open Networking Foundation, which develops and standardizes the OpenFlow.  The idea being developed by this group is to interrogate network elements about the sequence of lukap they can do.  Those.  when the controller makes a request, the network element provides it with information about the entire monstrous pipeline that is presented in the previous picture. <br><br>  But where did the abstraction go? <br><br>  If we have introduced an abstraction, and in order to effectively use and implement it, we have to tell the controller about all the implementation details, which means that we either do something that is not abstracted or we are not abstracted there. <br><br><h4>  Centralization and decentralization </h4><br>  Let's try to determine how centralized the control-plane should be.  There is room for maneuver.  Centralization and decentralization is an oscillatory process. <br><br>  Those who have been working for a long time in the industry will most likely agree with me.  One example, in which we have already gone through several cycles.  We buy <a href="http://ru.wikipedia.org/wiki/%25CC%25E0%25F0%25F8%25F0%25F3%25F2%25E8%25E7%25E0%25F2%25EE%25F0_%25F8%25E8%25F0%25EE%25EA%25EE%25EF%25EE%25EB%25EE%25F1%25ED%25EE%25E3%25EE_%25F3%25E4%25E0%25EB%25B8%25ED%25ED%25EE%25E3%25EE_%25E4%25EE%25F1%25F2%25F3%25EF%25E0">BRAS</a> and put it in the middle.  We understand that we do not scale anything, spreading it around the edges.  Now control is lost, we return to centralization again, buy a BRAS more and put it in the middle.  And so on. <br><br>  This is a natural process that cannot be avoided.  It is dictated not only by fashion and marketing, but also by completely objective factors, technical progress.  With centralization and decentralization in the control-plane, everything will be exactly the same. <br><br>  What do the radicals from the OpenFlow approach suggest to us in this regard?  It is assumed that the network element itself is extremely stupid and incapable of any independent actions, what the controller says to it is what it does. <br><br>  Accordingly, the controller will have to respond to all events on the network.  If an element is unable to transfer traffic from one path to another by itself, then the controller should see this failure and react to it.  This design is very dangerous in terms of scaling.  We'll have to take a big controller again, divide it into several, distribute it so that it can cope with the load.  Those.  we are again in a round of centralization / decentralization. <br><br><h2>  So what to do in reality? </h2><br>  The main thing is to temper the revolutionary fervor and approach the SDN from an evolutionary point of view. <br><br>  All that SDN promises us, all that we talked about in the beginning is really good.  This is what we need to strive for.  We must make every effort to make these promises come true. <br><br>  So what do we need to do for this? <br><br>  First, standardize one data-plane mechanism.  There is no reasonable way to control the whole variety of protocols, constructions and mechanisms that exist in today's data-plane. <br><br>  Secondly, you need to choose the right element abstraction, which would be simple and at the same time flexible.  In addition, it is necessary to provide the ability to implement network functions both centrally and decentralized.  You also need to find a way to combine differently implemented functions. <br><br>  Both management styles ‚Äî centralized and decentralized ‚Äî are important.  There are naturally centralized functions, for example, high-level policies. <br><br>  And at the same time, there are functions decentralized in nature, for example, rerouting in case of failures.  In addition, there are functions that can be implemented as it is profitable here and now.  These functions include the calculation of the path.  For example, inside the data center I have no need to do traffic-engineering, there is simply no need to save bandwidth.  But in the WAN traffic-engineering may already be required, and it can and sometimes needs to be done centrally. <br><br>  A network can have a domain structure: for example, DC and WAN, access and core, RAN and blcackhaul.  Different parts of the network perform different functions, they are arranged differently, and different types of control are suitable for them.  Accordingly, in order for the network to be unified, different parts of the network need to be ‚Äústitched‚Äù and ‚Äúsuperimposed‚Äù on each other.  On top of the domains we can make transports, and on top of these transports - ‚Äúservices‚Äù. <br><br>  Proper abstraction of an element really should hide its complexity.  The wild scheme, which we considered at the beginning, in fact displays only what is happening inside a single chip.  When we talk about a multi-slot distributed box, it gets even more complicated.  And it needs to be hidden, we do not want to know what is happening there. <br><br>  This abstraction should allow to combine different management styles.  If some function is implemented in the classical way in the form of distributed signaling, and the other in the form of centralized control, they should be able to interact with each other. <br><br>  One promising approach is the <a href="http://datatracker.ietf.org/wg/i2rs/charter/">I2F i2rs</a> .  This is a slightly higher level model than the proposed OpenFlow.  For example, i2rs operates not with entries in the forwarding table, but with the concept of a route. <br><br><h2>  Where are we now </h2><br>  What technical progress allows us to do today and in the near future? <br><br>  Today, there are two of the most current applications of SDN: network virtualization and service linking.  We need to understand that we have a virtualization level and a transport level, the task of which is to drag packages. <br><br>  We have <a href="http://ru.wikipedia.org/wiki/MPLS">IP / MPLS</a> as a transport.  We are able to make a simple MPLS network, to make transport. <br><br>  95% of the MPLS control-plane complexity is concentrated in the organization of services.  It is here that efforts must be focused. <br><br>  Virtualization must start from the host.  Modern processors allow us to do it quite cheaply.  We make a virtual switch on the host, and virtualization begins with it. <br><br>  Such a network should be managed hybrid: centralized controls should be distributed.  This will give us the opportunity to take network separation policies and compile them into certain rules of hybrid controllers that manage the imposed network. <br><br>  At the same time, whatever our policies, we do not touch the transport.  It does not change anything, he does not know about our policies or about the imposed network. <br><br><h2>  Conclusion </h2><br>  Summing up, I would like to repeat the idea that SDN, no matter what is meant by it, really promises us good things, they need to be implemented.  However, this needs to be done with the right tools, rather than equating SDN and OpenFlow. </div><p>Source: <a href="https://habr.com/ru/post/227061/">https://habr.com/ru/post/227061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227041/index.html">Vulnerability in Supermicro BMC Controller allows access to control interface passwords</a></li>
<li><a href="../227045/index.html">Reusable Falcon-9R rocket successfully tested the aerodynamic control surfaces, rising to a height of 1 km</a></li>
<li><a href="../227053/index.html">The ‚ÄúYo‚Äù app, which has entered the top 10 App Store apps in the US, has been hacked by college students</a></li>
<li><a href="../227055/index.html">How to watch movies in the original, if the English is weak? Decision!</a></li>
<li><a href="../227059/index.html">NASA approved an asteroid flight date to capture it</a></li>
<li><a href="../227063/index.html">The developer spent 13 years to complete the game.</a></li>
<li><a href="../227065/index.html">Nokia Lumia 930: the flagship smartphone in detail</a></li>
<li><a href="../227067/index.html">The invention of social networks</a></li>
<li><a href="../227069/index.html">Some interesting and useful things for web developer # 19</a></li>
<li><a href="../227073/index.html">Video recordings of the Golang Moscow conference reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>