<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Applying DRY principle in RSpec</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DRY (Don't Repeat Yourself) is one of the cornerstones of modern development, and especially among ruby ‚Äã‚Äãprogrammers. But if, when writing ordinary c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Applying DRY principle in RSpec</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/456/5c2/334/4565c2334f270cdd738fdce586e81bd1.jpg"><br><br>  DRY (Don't Repeat Yourself) is one of the cornerstones of modern development, and especially among ruby ‚Äã‚Äãprogrammers.  But if, when writing ordinary code, repeating fragments are usually easily grouped into methods or individual modules, then when writing tests, where repeated code is sometimes even more, this is not always easy to do.  This article contains a small overview of the means to solve such problems when using the RSD BDD framework. <br><a name="habracut"></a><br><h4>  1. Shared Examples </h4><br>  The most famous and frequently used method for creating reusable code for Rspec.  Great for testing class inheritance and module inclusion. <br><br><pre><code class="ruby hljs">shared_examples <span class="hljs-string"><span class="hljs-string">"coolable"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:target</span></span>){described_class.new} it <span class="hljs-string"><span class="hljs-string">"should make cool"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> target.make_cool target.should be_cool <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it_should_behave_like <span class="hljs-string"><span class="hljs-string">"coolable"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  In addition, Shared Example Groups have some additional functionality, which makes them much more flexible to use: passing parameters, passing blocks and using let in the parent group to define methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="ruby hljs">shared_examples <span class="hljs-string"><span class="hljs-string">"coolable"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|target_name|</span></span> it <span class="hljs-string"><span class="hljs-string">"should make </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ target_name }</span></span></span><span class="hljs-string"> cool"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> target.make_cool target.should be_cool <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it_should_behave_like <span class="hljs-string"><span class="hljs-string">"coolable"</span></span>, <span class="hljs-string"><span class="hljs-string">"target user"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:target</span></span>){User.new} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  For more information on where and how certain methods will be available, see David Chelimsky [2]. <br><br><h4>  2. Shared Contexts </h4><br>  This feature is somewhat unknown due to its relative novelty (appeared in RSpec 2.6) and its narrow scope.  The most suitable situation for using shared contexts is the presence of several specs, which require the same initial values ‚Äã‚Äãor final actions, usually specified in the before and after blocks.  Documentation hints at this: <br><br><pre> <code class="ruby hljs">shared_context <span class="hljs-string"><span class="hljs-string">"shared stuff"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> =&gt; <span class="hljs-symbol"><span class="hljs-symbol">:b</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> before { @some_var = <span class="hljs-symbol"><span class="hljs-symbol">:some_value</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shared_method</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">it</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">works</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">let</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:shared_let</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { {<span class="hljs-string"><span class="hljs-string">'arbitrary'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'object'</span></span>} } subject <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-string"><span class="hljs-string">'this is the subject'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  A very convenient thing in shared_context is the possibility of including them according to the meta information specified in the describe block: <br><br><pre> <code class="ruby hljs">shared_context <span class="hljs-string"><span class="hljs-string">"shared with somevar"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:need_values</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'some_var'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> before { @some_var = <span class="hljs-symbol"><span class="hljs-symbol">:some_value</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe <span class="hljs-string"><span class="hljs-string">"need som_var"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:need_values</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'some_var'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it ‚Äúshould have som_var‚Äù <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @some_var.should_not be_nil <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><h4>  3. Factory facilities </h4><br>  Another simple, but very important point. <br><br><pre> <code class="ruby hljs">@user = User.create( <span class="hljs-symbol"><span class="hljs-symbol">:email</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'example@example.com'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:login</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'login1'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:password</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'password'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:status</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, ‚Ä¶ )</code> </pre><br>  Instead of repeatedly writing similar constructions, you should use the <a href="https://github.com/thoughtbot/factory_girl">factory_girl</a> gem or its analogs.  The advantages are obvious: the amount of code is reduced and there is no need to rewrite all the specs if you decide to change status to status_code. <br><br><h4>  4. Own matchrs </h4><br>  The ability to define your own matchers is one of the coolest opportunities in RSpec, thanks to which it is unrealistic to increase the readability and elegance of your specs.  Just an example. <br>  Before: <br><pre> <code class="ruby hljs">it ‚Äúshould make user cool‚Äù <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> make_cool(user) user.coolness.should &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> user.rating.should &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> user.cool_things.count.should == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  After: <br><pre> <code class="ruby hljs">RSpec::Matchers.define <span class="hljs-symbol"><span class="hljs-symbol">:be_cool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|actual|</span></span> actual.coolness.should &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> &amp;&amp; actual.rating.should &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> &amp;&amp; actual.cool_things.count.should == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> it ‚Äúshould make user cool‚Äù <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> make_cool(user) user.should be_cool <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Agree, it has become much better. <br>  RSpec allows you to set error messages for your own matchrs, display descriptions and perform cheating, which makes matchers so flexible that they are no different from built-in ones.  To realize all their power, I offer the following example [1]: <br><br><pre> <code class="ruby hljs">RSpec::Matchers.define <span class="hljs-symbol"><span class="hljs-symbol">:have_errors_on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|attribute|</span></span> chain <span class="hljs-symbol"><span class="hljs-symbol">:with_message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|message|</span></span> @message = message <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|model|</span></span> model.valid? @has_errors = model.errors.key?(attribute) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @message @has_errors &amp;&amp; model.errors[attribute].<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(@message) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> @has_errors <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> failure_message_for_should <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|model|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @message <span class="hljs-string"><span class="hljs-string">"Validation errors </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{model.errors[attribute].inspect}</span></span></span><span class="hljs-string"> should include </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{@message.inspect}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{model.</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">class</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> should have errors on attribute </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{attribute.inspect}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> failure_message_for_should_not <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|model|</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{model.</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">class</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> should not have an error on attribute </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{attribute.inspect}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><h4>  5. One-liners </h4><br>  RSpec provides the ability to use single-line syntax when writing simple specs. <br><br>  An example from a real opensource project ( <a href="https://github.com/amatsuda/kaminari">kaminari</a> ): <br><pre> <code class="ruby hljs">context <span class="hljs-string"><span class="hljs-string">'page 1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { User.page <span class="hljs-number"><span class="hljs-number">1</span></span> } it { should be_a Mongoid::Criteria } its(<span class="hljs-symbol"><span class="hljs-symbol">:current_page</span></span>) { should == <span class="hljs-number"><span class="hljs-number">1</span></span> } its(<span class="hljs-symbol"><span class="hljs-symbol">:limit_value</span></span>) { should == <span class="hljs-number"><span class="hljs-number">25</span></span> } its(<span class="hljs-symbol"><span class="hljs-symbol">:total_pages</span></span>) { should == <span class="hljs-number"><span class="hljs-number">2</span></span> } it { should skip(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Clearly much better than: <br><pre> <code class="ruby hljs">context <span class="hljs-string"><span class="hljs-string">'page 1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> before <span class="hljs-symbol"><span class="hljs-symbol">:each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @page = User.page <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> it ‚Äúshould be a Mongoid criteria‚Äù <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @page.should be_a Mongoid::Criteria <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> it ‚Äúshould have current page set to <span class="hljs-number"><span class="hljs-number">1</span></span>‚Äù <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @page.current_page.should == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ‚Ä¶. <span class="hljs-comment"><span class="hljs-comment">#etc</span></span></code> </pre><br><br><h4>  6. Dynamically created specs </h4><br>  The key point here is that the it construct (as well as context and describe) is just a method that takes a block of code as the last argument.  Therefore, they can be called both in cycles and under conditions, and even make up similar constructions: <br><br><pre> <code class="ruby hljs">it(it(<span class="hljs-string"><span class="hljs-string">"should process +"</span></span>){(<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>).should == <span class="hljs-number"><span class="hljs-number">5</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>).should == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  By the way, both specs are successful, but it's scary to even think where this can be applied, unlike the same cycles and iterators.  An example from the same Kaminari: <br><br><pre> <code class="ruby hljs">[User, Admin, GemDefinedModel].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|model_class|</span></span> context <span class="hljs-string"><span class="hljs-string">"for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{model_class}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> describe <span class="hljs-string"><span class="hljs-string">'#page'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> context <span class="hljs-string"><span class="hljs-string">'page 1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { model_class.page <span class="hljs-number"><span class="hljs-number">1</span></span> } it_should_behave_like <span class="hljs-string"><span class="hljs-string">'the first page'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Or an example with conditions: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Mongoid::VERSION =~ <span class="hljs-regexp"><span class="hljs-regexp">/^3/</span></span> its(<span class="hljs-symbol"><span class="hljs-symbol">:selector</span></span>) { should == {<span class="hljs-string"><span class="hljs-string">'salary'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> its(<span class="hljs-symbol"><span class="hljs-symbol">:selector</span></span>) { should == {<span class="hljs-symbol"><span class="hljs-symbol">:salary</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><h4>  7. Macros </h4><br>  In 2010, after the introduction of the new functionality of shared examples, David Chelimsky said that macros are no longer needed.  However, if you still think that this is the most appropriate way to improve the code of your specs, you can create them like this: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SumMacro</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it_should_process_sum</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">should</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#{s1} and #{s2}" do (s1+s2).should == result end end end describe "sum" do extend SumMacro it_should_process_sum 2, 3, 5 end</span></span></span></span></code> </pre><br>  I don‚Äôt see any sense in dwelling on this point, but if you want, you can read [4]. <br><br><h4>  8. Let and Subject </h4><br>  The let and subject constructs are needed to initialize the initial values ‚Äã‚Äãbefore performing the specs.  Of course, everything is already in the know that to write so in every spec: <br><pre> <code class="ruby hljs">it ‚Äúshould <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something‚Äù <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> user = User.new ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  It's not cool at all, but usually everyone shoves this code in before: <br><br><pre> <code class="ruby hljs">before <span class="hljs-symbol"><span class="hljs-symbol">:each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @user = user.new <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  although subject should be used for this.  And if before the subject was exclusively ‚Äúnameless‚Äù, now it can also be used explicitly by specifying the name of the variable being defined: <br><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">"number"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject(<span class="hljs-symbol"><span class="hljs-symbol">:number</span></span>){ <span class="hljs-number"><span class="hljs-number">5</span></span> } it <span class="hljs-string"><span class="hljs-string">"should eql 5"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> number.should == <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Let is similar to subject, but it is used to declare methods. <br><br><h4>  Additional links </h4><br>  1. Custom RSpec-2 Matchers <br>  <a href="http://solnic.eu/2011/01/14/custom-rspec-2-matchers.html">solnic.eu/2011/01/14/custom-rspec-2-matchers.html</a> <br>  2. David Chelimsky - in RSpec-2 <br>  <a href="http://blog.davidchelimsky.net/2010/11/07/specifying-mixins-with-shared-example-groups-in-rspec-2/">blog.davidchelimsky.net/2010/11/07/specifying-mixins-with-shared-example-groups-in-rspec-2</a> <br>  3. Ben Scheirman - Dry Up Your Rspec Files With Subject &amp; Let Blocks <br>  <a href="http://benscheirman.com/2011/05/dry-up-your-rspec-files-with-subject-let-blocks">benscheirman.com/2011/05/dry-up-your-rspec-files-with-subject-let-blocks</a> <br>  4. Ben Mabey - Writing Macros in RSpec <br>  <a href="http://benmabey.com/2008/06/08/writing-macros-in-rspec.html">benmabey.com/2008/06/08/writing-macros-in-rspec.html</a> <br><br>  And in conclusion I can only say, I can only say - try to repeat less. </div><p>Source: <a href="https://habr.com/ru/post/160915/">https://habr.com/ru/post/160915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160905/index.html">Microsoft Security Essentials Failed AV-Test Certification</a></li>
<li><a href="../160907/index.html">About Scar, Focus Factor and Buns</a></li>
<li><a href="../160909/index.html">The UN is developing a new world order for the Internet</a></li>
<li><a href="../160911/index.html">In-app Billing Subscriptions from server side</a></li>
<li><a href="../160913/index.html">Back to Dublin - continuation of the application development history</a></li>
<li><a href="../160917/index.html">New Dropbox service: Dropbox Chooser file selection dialog with search and gallery for embedding in web applications</a></li>
<li><a href="../160919/index.html">Life in the era of "dark" silicon. Part 3</a></li>
<li><a href="../160923/index.html">What the coming day prepares for us</a></li>
<li><a href="../160925/index.html">Immersion Preparation: MSM Knowledge Exam</a></li>
<li><a href="../160927/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ33 (November 24 - 30, 2012)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>