<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sheep of Electric Sheep: Designing for Autonomous Operation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who do you think will better configure PostgreSQL - DBA or ML algorithm? And if the second, then is it time for us to think about what to do when we a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sheep of Electric Sheep: Designing for Autonomous Operation</h1><div class="post__text post__text-html js-mediator-article">  Who do you think will better configure PostgreSQL - DBA or ML algorithm?  And if the second, then is it time for us to think about what to do when we are replaced by cars.  Or it will not come to this, and the person must still make important decisions.  Probably, the isolation level and transaction stability requirements should remain in the hands of the administrator.  But the indexes will soon be possible to entrust the machine to determine independently. <br><br><img src="https://habrastorage.org/webt/k-/46/k3/k-46k3vgk1dm-quvhgnjdldvbay.jpeg"><br><br>  Andy Pavlo on <a href="https://www.highload.ru/">HighLoad ++</a> told about the future DBMS, which can be ‚Äútouched‚Äù now.  If you missed this speech or prefer to receive information in Russian - under the cut translation of the speech. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will talk about the project of Carnegie Mellon University, dedicated to the creation of autonomous databases.  The term "autonomous" means a system that can automatically deploy, configure, configure itself without any human intervention.  It may take about ten years to develop something like this, but this is exactly what Andy and his students are doing.  Of course, in order to create an autonomous DBMS, machine learning algorithms are necessary, however, in this article we will focus only on the engineering side of the topic.  Consider how to design software to make it standalone. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QEAMBtUWqPM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <strong>About the speaker:</strong> Andy Pavlo is an associate professor at Carnegie Mellon University, under his leadership he creates <a href="https://pelotondb.io/">‚Äúself-managed‚Äù PelotonDB DBMS</a> , as well as <a href="https://github.com/cmu-db/ottertune">ottertune</a> , which helps to tune PostgreSQL and MySQL configs using machine learning.  Andy and his team are now true leaders in self-managed databases. <br><br>  The reason why we want to create an autonomous database management system is obvious.  Data management by means of a DBMS is a very expensive and laborious process.  The average DBA salary in the USA is about 89 thousand dollars a year.  Translated into rubles, it is 5.9 million rubles a year.  You‚Äôll pay this really big amount to people just looking after your software.  About 50% of the total cost of using the database is the payment of the work of such administrators and related personnel. <br><br>  When it comes to really big projects, such as we discuss in HighLoad ++ and which use tens of thousands of databases, the complexity of their structure goes beyond human perception.  All approach the solution to this problem superficially and try to achieve maximum performance by investing minimal effort in setting up the system. <br><br><blockquote>  You can save a lot of money if you configure the database at the application and environment level to ensure maximum performance. </blockquote><br><h2>  Self-adaptive databases, 1970‚Äì1990 </h2><br>  The idea of ‚Äã‚Äãautonomous DBMS is not new, their history dates back to the 1970s, when relational databases were first created.  Then they were called self-adaptive databases (Self-Adaptive Databases), and with their help they tried to solve the classic problems of database design, over which people are still struggling.  These are the choice of indices, the partitioning and construction of the database schema, as well as the placement of data.  At that time, tools were developed that helped database administrators deploy databases.  These tools, in fact, worked the same way as their modern counterparts work today. <br><br>  Administrators track requests executed by the application.  They then pass this stack of requests to the tuning algorithm, which builds an internal model of how the application should use the database. <br><br>  If you create a tool that helps you automatically select indexes, then build charts from which you can see how often calls are made to each column.  Then pass this information to the search algorithm, which will look at many different locations - try to determine which of the columns can be indexed in the database.  The algorithm will use the internal value model to show that this particular will give better performance than other indices.  Then the algorithm will give a suggestion, what changes in the indices need to be made.  At this point, it's time to get involved with the person, consider the proposal and, not only decide whether it is right, but also choose the right time to implement it. <br><br><img src="https://habrastorage.org/webt/gp/bz/wt/gpbzwtyv3yingx-qfyov_qao7i0.png"><br><br>  Database administrators should know how the application is used when there is a drop in user activity.  For example, on Sunday at 3:00 am the lowest level of database queries, so you can reload indexes at this time. <br><br>  As I said, all the design tools of the time worked the same way - <strong>this</strong> is <strong>a very old problem</strong> .  The supervisor of my supervisor back in 1976 wrote an article about automatic index selection. <br><br><h2>  Self-tuning databases, 1990‚Äì2000 </h2><br>  In the 1990s, people, in fact, worked on the same problem, only the name changed from adaptive to self-adjusting databases. <br><br>  The algorithms have become a little better, the tools have become a little better, but at a high level, they also worked as before.  The only company that was at the forefront of the self-tuning systems movement was Microsoft Research with their automatic administration project.  They developed really great solutions, and in the late 90s, early 00s, they again presented a set of recommendations for configuring their database. <br><br>  The key idea that Microsoft put forward was different from what it was in the past ‚Äî instead of the customization tools supporting their own models, they actually simply reused the query optimizer cost model, which helps determine the benefits of one index against another.  If you think about it, it makes sense.  When you need to know whether a single index can really speed up queries, it doesn‚Äôt matter how big it is if the optimizer doesn‚Äôt select it.  Therefore, the optimizer is used to find out if it will actually select something. <br><br><img src="https://habrastorage.org/webt/wx/tm/ae/wxtmae-qjlpvjydyrqmqhku0ac8.png"><br><br>  In 2007, Microsoft Research published <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/vldb07-10yr.pdf">an article</a> outlining a retrospective of ten years of research.  And it is well covered all the complex tasks that have arisen on each segment of the path. <br><br>  Another task that was noticed in the era of self-tuning databases: <strong>how to make automatic tuning of regulators.</strong>  The database controller is a configuration parameter that changes the behavior of the database system at run time.  For example, the parameter that is present in almost every database is the size of the buffer.  Or, for example, you can control parameters such as blocking policies, the frequency of cleaning the disk and the like.  Due to the significant increase in the complexity of DBMS regulators in recent years, this topic has become relevant. <br><br>  To show how bad things are, I‚Äôll give an overview that my student did after examining many releases of PostgreSQL and MySQL. <br><br><blockquote>  Over the past 15 years, the number of regulators in PostgreSQL has increased 5 times, and in MySQL - 7 times. </blockquote><br><img src="https://habrastorage.org/webt/mq/u7/y1/mqu7y1e6ntezta8e-jxj-wvf5t0.png"><br><br>  Of course, not all regulators actually control the task execution process.  Some, for example, contain file paths or network addresses, so only a person can configure them.  But a few dozen of them can actually affect performance.  No man can hold that much in his head. <br><br><h2>  Cloud Databases, 2010‚Äì‚Ä¶ </h2><br>  Then we find ourselves in the era of the 2010s, in which we are to this day.  I call it the era of cloud databases.  During this time, much work has been done to automate the deployment of a large number of databases in the cloud environment. <br><br>  The main thing that bothers the major suppliers of cloud systems is how to place tenant or migrate from one to another.  How to determine how much resources each tenant will need, and then try to distribute them among the cars so as to maximize productivity or meet the SLA at minimum cost. <br><br>  Amazon, Microsoft and Google solve this problem, but mostly at the operational level.  Only recently, cloud service providers began to think about the need to configure individual database systems.  This work is not visible to ordinary users, but it determines the high level of the company. <br><br><blockquote>  Summing up the 40-year database research with autonomous and non-autonomous systems, it can be concluded that this work is still not enough. </blockquote><br>  Why today we can not have a truly autonomous system of self-government?  There are three reasons for this. <br><br><img src="https://habrastorage.org/webt/sm/d0/eg/smd0ega2yn_5o-ywbdz3zod1yf0.png"><br><br>  First, all of these tools, except for the distribution of workload from cloud service providers, are only <strong>advisory in nature</strong> .  That is, on the basis of the calculated option, the person must make a final, subjective decision as to whether such a proposal is correct.  Moreover, it takes some time to monitor the operation of the system in order to decide whether the decision made remains true as the service develops.  And then apply knowledge to your own internal decision making model in the future.  You can do this for one DB, but not for tens of thousands. <br><br>  The next problem is that <strong>any measures are only a reaction to something</strong> .  In all the examples that we have reviewed, work goes with data on past workload.  A problem arises, records about it are transmitted to the instrument, and he says: ‚ÄúYes, I know how to solve this problem.‚Äù  But the solution concerns only a problem that has already occurred.  The tool does not predict future events and therefore does not offer preparatory actions.  A person can do it, and does it manually, but tools cannot do this. <br><br>  The final reason is that in none of the solutions is <strong>there a transfer of knowledge</strong> .  Here is what I mean: for example, let's take a tool that worked in one application on the first database instance, if you put it in one more same application on another database instance, it could, based on the knowledge gained, work with the first database data to help set up a second database.  In fact, all tools start from scratch, they need to re-get all the data about what is happening.  The man works quite differently.  If I know how to set up one application in a certain way, I can see the same patterns in another application and maybe set it up much faster.  But none of these algorithms, none of these tools, still work in this way. <br><br>  Why am I sure it is time for a change?  The answer to this question is about the same as the question of why super data arrays or machine learning became popular.  <strong>Equipment becomes better</strong> : production resources increase, storage capacity grows, hardware capacity increases, which speeds up calculations for learning machine learning models. <br><br>  We have become available advanced software.  Previously, you had to be an expert on MATLAB or low-level linear algebra to write some machine learning algorithms.  Now we have Torch and Tenso Flow, which make ML available, and, of course, we have learned to better understand the data.  People know exactly what data may be needed to make decisions in the future, so do not discard as much data as before. <br><br>  The goal of our research is to close this circle in autonomous DBMS.  We can, like the previous tools, propose solutions, but instead of relying on the person ‚Äî whether the solution is right, when exactly you need to deploy it ‚Äî the algorithm will do it automatically.  And then with the help of feedback will learn and eventually get better. <br><br>  I want to talk about the projects we are currently working at Carnegie Mellon University.  In them we approach the problem in two different ways. <br><br>  In the first ‚Äî OtterTune ‚Äî we look for ways to customize the database, treating them like black boxes.  That is, ways to <strong>customize existing DBMSs</strong> , without controlling the internal part of the system, and observing only the response. <br><br>  The Peloton project is about <strong>creating new databases from scratch</strong> , from scratch, given that the system should work autonomously.  What adjustments and optimization algorithms need to be laid - which cannot be applied to existing systems. <br><br>  Consider both projects in order. <br><br><h2>  Ottertune </h2><br>  The project for adjusting existing systems that we developed is called OtterTune. <br><br>  Imagine that a database is configured as a service.  The idea is that you load the time metrics for performing heavy DB operations that consume all the resources, and the recommended configuration of regulators comes in response, which, in our opinion, will increase performance.  This can be delay time, bandwidth or any other characteristic that you specify - we will try to find the best option. <br><br><img src="https://habrastorage.org/webt/zq/wi/eb/zqwiebmj38ma58e37dycznrjamq.png"><br><br>  The main thing that is new in the OtterTune project is the <strong>ability to use data from previous sessions to</strong> customize and increase the efficiency of the next sessions.  For example, we take the PostgreSQL configuration, in which there is an application that we have never seen before.  But if it has certain characteristics or uses a database like the databases that we have already seen in our applications, then we already know how to configure it and this application is more efficient. <br><br>  At a higher level, the algorithm works as follows. <br><br>  Suppose there is a target database: PostgreSQL, MySQL, or VectorWise.  You need to install a controller in the same domain that will perform two tasks. <br><br><img src="https://habrastorage.org/webt/fv/bu/e_/fvbue_hzhuwaq4zxkzyalcoxhke.png"><br><br>  The first is performed by the so-called collector - a tool that collects data about the current configuration, i.e.  metrics of query execution time from applications to the database.  The data collected by the collector, loaded into the Tuning Manager - service settings.  It does not matter if the database is running locally or in the cloud.  After downloading, the data is saved in our own internal repository, which stores all test sessions we have ever made. <br><br>  Before making recommendations, you need to perform two steps.  First, you need to look at the runtime metrics and find out which of them are really important.  In the example below, the metrics returned by MySQL but on the <code>SHOW_GLOBAL_STATUS</code> on InnoDB.  Not all of them are useful for our analysis.  It is known that in machine learning a large amount of data is not always good.  Because then it takes even more data to separate the wheat from the chaff.  As in this case, <strong>it is important to get rid of entities that do not really matter</strong> . <br><br><img src="https://habrastorage.org/webt/qq/th/js/qqthjszvgbp7pp8m1q3d0ze2qge.png"><br><br>  For example, there are two metrics: <code>INNODB_BUFFER_POOL_BYTES_DATA</code> and <code>INNODB_BUFFER_POOL_PAGES_DATA</code> .  In fact, this is the same metric, but in different units.  You can perform a statistical analysis, see that the metrics are strongly correlated, and conclude that using both for analysis is redundant.  If one of them is discarded, the dimension of the learning task is reduced and the time to receive a response is reduced. <br><br>  At the second stage we do the same, only with regards to the regulators.  <strong>MySQL has 500 regulators</strong> , and, of course, not all of them are really significant, and different applications are important for different applications.  It is necessary to carry out another statistical analysis to find out which regulators will really affect the objective function. <br><br><img src="https://habrastorage.org/webt/g7/wz/h9/g7wzh9wquhh68lwkovxrnxdt8b0.png"><br><br>  In our example, we found that the three regulators <code>INNODB_BUFFER_POOL_SIZE</code> , <code>FLUSH_METHOD</code> and <code>LOG_FILE_SIZE</code> have the greatest impact on performance.  At their expense, the latency for transactional workload is reduced. <br><br>  There are other interesting points related to regulators.  In the screenshot there is a controller named <code>TIMED_MUTEXES</code> .  If you refer to the MySQL working documentation, section 45.7 will indicate that this regulator is outdated.  But <strong>the machine learning algorithm cannot read the documentation</strong> , so it does not know about it.  He knows that there is a regulator that can be turned on or off, and it will take a long time to realize that this does not affect anything.  But you can make calculations in advance and find out that the regulator is not doing anything, and not wasting time setting it up. <br><br>  After analysis, the data is transferred to our configuration algorithm using <strong>the Gaussian process model</strong> ‚Äî a rather old method.  You have probably heard about deep learning, we are doing something similar, but without deep networks.  We use the <strong>GPflow</strong> - package for working with models of the Gaussian process, developed in Russia on the basis of TensorFlow.  The algorithm issues a recommendation that should improve the objective function;  This data is passed back to the installation agent running inside the controller.  The agent applies the changes, performing a reset ‚Äî unfortunately, it‚Äôs necessary to restart the database ‚Äî and then the process repeats again.  Some more metrics of execution time are collected, transferred to the algorithm, an analysis is made of the possibility of improving and increasing productivity, a recommendation is issued, and so on, again and again. <br><br><img src="https://habrastorage.org/webt/nz/qb/xc/nzqbxcp2ja9jbdwnaeoggdya0fw.png"><br><br>  The key feature of OtterTune is that as input to the algorithms, only information about the execution time metrics is needed.  We do not need to see your data and user requests.  We just need to track read and write operations.  This is a weighty argument - data belonging to you or your customers will not be disclosed to third parties.  We do not need to see any requests, the algorithm works based only on the runtime metrics, because it gives recommendations for regulators, and not for physical design. <br><br>  Let's take a look at the work of the OtterTune demo.  On the project website, we will launch Postgres 9.6, and load the system with a TPC-C test.  Let's start with the initial PostgreSQL configuration, which is deployed when installed on Ubuntu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0e/7s/5o/0e7s5ohwzj1g_lfw-lxmi6_ibjm.png"></div><br><br>  First, we will run the TPC-C test for five minutes, collect the required runtime metrics, load them into the OtterTune service, get recommendations, apply the changes, and then repeat the process.  Let's come back to this later.  The database system runs on one computer, the Tensor Flow service runs on another, and loads the data here. <br><br><img src="https://habrastorage.org/webt/6h/9d/yx/6h9dyxfovr6efc8m-a-znaguzgo.png"><br><br>  After five minutes, refresh the page (the demonstration of this part of the results begins at <a href="https://www.youtube.com/watch%3Fv%3DQEAMBtUWqPM%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1728">this moment</a> ).  When we first started, in the default configuration for PostgreSQL, 623 transactions occurred per second.  Then, after receiving the recommendation and applying the changes once, the number of transactions <strong>increased to 2300 per second</strong> .  We have to admit that this demonstration has already been launched several times, so the system already has a set of previously collected data.  That is why the solution is so fast.  What would happen if the system did not have such previously collected data?  This algorithm is a kind of step-by-step function, and gradually it would have reached that level. <br><br><img src="https://habrastorage.org/webt/4q/ke/g3/4qkeg3wsp7yfxom1mojcv2mafhq.png"><br><br>  After some time and five iterations, the best result was 2600. We went from 600 transactions per second, and were able to reach values ‚Äã‚Äãof 2600. A small drop occurred due to the algorithm decided to try a different way of adjusting the regulators after reaching good results.  The result was with a margin, so a large drop in performance did not happen.  Having received a negative result, the algorithm reconfigured and began to look for other methods of regulation. <br><br>  We conclude that we should not be afraid of launching a bad strategy into the work, because the algorithm will explore the solution space and try on different configurations to achieve the terms of the SLA agreement.  Although you can always customize the service so that the algorithm chooses only enhancement solutions.  And over time you will get all the best and best results. <br><br>  Now back to the topic of our conversation.  I will tell you about the results already available from an <a href="https://dl.acm.org/citation.cfm%3Fid%3D3064029">article</a> published in Sigmod.  We configured MySQL and PostgreSQL for TPC-C using OtterTune, in order to increase throughput. <br><br>  Compare the configuration of these DBMS, deployed by default when first installed on Ubuntu.  Next, let's run several open source configuration scripts that can be obtained from Percona and some other consulting firms working with PostgreSQL.  These scripts use heuristic procedures, like the rule that for your hardware you must set a certain buffer size.  We also have a configuration from Amazon RDS, which already has presets from Amazon for the equipment you work on.  Then we compare this with the result of manual configuration of expensive DBA, but with the condition that they have 20 minutes and the ability to set any parameters.  And the last step is to run OtterTune. <br><br><img src="https://habrastorage.org/webt/vb/oi/gg/vboigg_vly5yx81jkjs4zjslsqa.jpeg"><br><br>  For MySQL, it is clear that the default configuration is far behind, the scripts work a little better, RDS is a little better.  In this case, the best result was shown by the database administrator - the leading MySQL administrator from Facebook. <br><br>  <strong>OtterTune lost to man</strong> .  But the fact is that there is a certain regulator that disables the synchronization of magazine cleaning, and for Facebook it doesn‚Äôt matter.  However, we denied access to this OtterTune regulator, because the algorithms do not know whether you agree to lose the last five milliseconds of data.  In our opinion, this decision should be made by a person.  Perhaps Facebook agrees with such losses, we do not know.  If we set up this regulator in the same way, then we can compete with the person. <br><br><blockquote>  This example shows how we try to be conservative in that the final decision should be made by a person.  Because there are certain aspects of databases, about which the ML algorithm does not guess. </blockquote><br>  In the case of PostgreSQL, configuration scripts work well.  RDS does a little worse.  But, it is worth noting that OtterTune's performance has exceeded this person.  The histogram shows the results obtained after the database was set up by the chief expert on PostgreSQL in the Wisconsin judicial system.  In this example, OtterTune was able to find the optimal balance between the size of the log file and the size of the buffer pool, balancing the amount of memory used by these two components and ensuring the best performance. <br><br>  The main conclusion is that OtterTune uses such algorithms and machine learning that we can achieve the same or better performance compared to very, very expensive DBA.  And this concerns not only a single instance of the database, we can scale up to tens of thousands of copies, because it‚Äôs just software, just data. <br><br><h2>  Peloton </h2><br>  The second project that I would like to talk about is called Peloton.  This is a completely new data system that we are building from scratch at Carnegie Mellon.  We call it a self-managed DBMS. <br><br>  The idea is to find out which changes for the better can be made if you control the entire software stack.  How to make the settings better than OtterTune can do, at the expense of knowing about each fragment of the system, about the entire program cycle. <br><br><img src="https://habrastorage.org/webt/av/8g/13/av8g13hhckp7k2adftmzn7tlv5a.png"><br><br>  How it will work: we have integrated the <strong>components of machine learning with reinforcement</strong> into the database system, and we can observe all aspects of its behavior during execution and then make recommendations.  And we are not limited to recommendations for setting up regulators, as it happens in the OtterTune service, we would like to perform the entire standard set of actions that I mentioned earlier: the choice of indices, the choice of partitioning schemes, the vertical and horizontal scaling, etc. <br><br>  <em>The name of the</em> <em>Peloton</em> <em>system</em> <em>is likely to change.</em>  <em>I do not know how in Russia, but here in the USA, the term ‚Äú</em> <em>peloton‚Äù means ‚Äúfearless‚Äù and ‚Äúfinish‚Äù, and in French it means ‚Äúplatoon‚Äù.</em>  <em>But in the US, there is the</em> <em>Peloton</em> <em>exercise bike company</em> <em>, which has a lot of money.</em>  <em>Every time there is a mention of them, for example, opening a new store, or a new advertisement on TV, all my friends write to me: "Look, they stole your idea, stole your name."</em>  <em>Advertising shows beautiful people who ride their exercise bikes, and we simply cannot compete with it.</em>  <em>And recently,</em> <em>Uber announced a new resource planner called ‚Äú</em> <em>Peloton‚Äù, so we can no longer call our system that way.</em>  <em>But we don‚Äôt have a new name yet, so in this story I‚Äôll still use the current version of the name.</em> <br><br>  Consider how this system works at a high level.  For example, take the target database, again, this is our software, this is what we work with.  We are collecting the same workload history that I showed earlier.  The difference is that we are going to generate prediction models that will allow us to predict what the workload cycles will be in the future, what the requirements of the workload will be in the future.  That is why we call this system a self-managing DBMS. <br><br><blockquote>  The basic idea of ‚Äã‚Äãthe work of a self-managed DBMS is similar to the idea of ‚Äã‚Äãa car with automatic control. </blockquote><br>  An unmanned vehicle looks in front of itself and can see what is located in front of it on the road, can predict how to get to its destination.  The autonomous database system works in the same way.  You should be able to look to the future and conclude what the workload will look like in a week or an hour.  Then we transfer this predicted data to the planning component ‚Äî we call it the brain ‚Äî working on Tensor Flow. <br><br>  The process echoes the work of AlphaGo from London within the framework of the Google Deep Mind project, at the top level it all works according to a similar scenario: a Monte Carlo tree search is used, the search results are various actions that need to be performed to achieve the desired goal. <br><br>  The work scheme is approximately determined by the following algorithm: <br><br><ul><li>  The source data is a set of required actions, for example, deleting an index, adding an index, vertical and horizontal scaling, and the like. </li><li>  A sequence of actions is generated, which ultimately leads to the maximum of the objective function. </li><li>  All criteria except the first one are discarded and changes are applied. </li><li>  The system looks at the resulting effect, then the process repeats over and over. </li></ul><br><img src="https://habrastorage.org/webt/lt/5u/te/lt5uteozlshw-wvgoc8eh2qaj5s.png"><br><br>  You should not constantly resort to the metaphor of an unmanned vehicle, but this is how they work.  This is called the planning horizon. <br><br>  Looking at the horizon on the road, we set an imaginary point to which we need to get, and then we begin to plan the sequence of actions to reach this point on the horizon: speed up, slow down, turn left, turn right, etc.  Then we mentally discard all the actions except the first one that need to be performed, perform it, and then repeat the process again.  UAVs chase such an algorithm 30 times a second.  With regard to databases, this process proceeds a little slower, but the idea itself remains the same. <br><br>  We decided to create our own database system <strong>from scratch, rather than build something on top of</strong> <strong>PostgreSQL or</strong> <strong>MySQL</strong> , because, frankly, they are too slow compared to what we would like to do.  PostgreSQL is great, I love it and use it in my university courses, but it takes too much time to create indexes, because all the data comes from the disks. <br><br>  In analogies with cars, an autonomous DBMS on PostgreSQL can be compared to an unmanned truck.  The wagon will be able to recognize the dog in front of the road and drive around it, but not if it ran out onto the roadway right in front of the car.  Then the collision is inevitable, because the wagon is not sufficiently maneuverable.  We decided to create a system from scratch in order to be able to apply changes as quickly as possible and figure out what the correct configuration is. <br><br>  Now we have solved the first problem and published <a href="https://db.cs.cmu.edu/papers/2018/mod435-maA.pdf">an article</a> about a combination of deep learning and classical linear regression for automatic selection and prediction of workloads. <br><br>  But there is a bigger problem for which we do not have a good solution yet - <strong>action catalogs</strong> .  The question is not how to choose actions, because the guys from Microsoft have already done it.  The question is how to determine whether one action is better than another, in terms of what happens before and after deployment.  How to reverse the action, if the index created by the command of a person is not optimal, how can you cancel this action and specify the reason for the cancellation.  In addition, there are a number of other tasks in terms of the interaction of our own system with the outside world, for which we do not have a solution yet, but we are working on them. <br><br>  <em>By the way, I will tell an interesting story about a well-known database company.</em>  <em>This company had an automatic index selection tool, and the tool had a problem.</em>  <em>One customer constantly canceled all indices that the tool recommended and applied.</em>  <em>This cancellation occurred so often that the tool hung.</em>  <em>He did not know what the future strategy of behavior should be, because any solution offered to a person received a negative evaluation.</em>  <em>When the developers turned to the client and asked: ‚ÄúWhy do you cancel all recommendations and suggestions on indexes?‚Äù, The client answered that he simply did not like their names.</em>  <em>People are stupid, but you have to deal with them.</em>  <em>And for this problem, I still have no solution.</em> <br><br><h2>  Designing an autonomous DBMS </h2><br>  Considering two different approaches to creating autonomous database systems, now let's talk about how to design a DBMS so that it is autonomous. <br><br>  Let us dwell on three topics: <br><br><ul><li>  how to set up regulators, </li><li>  how to collect internal metrics </li><li>  how to design action. </li></ul><br>  Let's return to the key points once again: the database system should provide the correct information to the machine learning algorithms for later making the best decisions.  The amount of useless data that we transmit must be reduced to increase the speed of receiving responses. <br><br>   ,   ,     ,        .       <code>PG_SETTINGS</code>      ,       . <br><br><blockquote>    ,    ,  ,     ..    ,   . </blockquote><br>   ,          ,    , ,        . <br><br>   ,    ,     ,      . <br><br>     : <br><br><ul><li> <strong> </strong> .    ,      ,       . </li><li> <strong>      </strong> .     ,      ,     -1  0,     . </li><li> <strong>   </strong> ,     . ,     .     64- ,       0  2 <sup>64</sup> .          ,      . </li></ul><br>        ,    .     ,        10 ,         ,     10 .     ,        . <br><br>  -   ,    .  , ,   . ,     ,        ,        . <br><br>   ,       , ,    .        ,     .        ,  ,     ,  ‚Äî     .      ,      . <br><br>  ,     ,     ,   .           ,      . <br><br> ,       ,      .        ,        :     ,    ,    ,   ,    .       -       Oracle,         ,       . <br><br><img src="https://habrastorage.org/webt/hp/7z/1p/hp7z1pthfae3wegk-k3jdbggzvs.png"><br><br> ,        ,            . <br><br>   ,     ,      .     ,  ,  ,     .   -   ,   ,   ,   .  :    PostgreSQL             ,            . <br><br><img src="https://habrastorage.org/webt/rb/mq/_x/rbmq_xap9pleuyrmfnrw2ofevbg.png"><br><br>       ,       ,      ,     . <br><br>   - ,   ,    ,         .  ,    ,       .    RocksDB,   MyRocks  MySQL. <br><br> RocksDB     .       ,        .  ,    ,      ,       .       RocksDB,      . <br><br><img src="https://habrastorage.org/webt/r4/i0/d8/r4i0d82qeejj7rhh1f6fftdd1ua.png"><br><br>    ,       ,    ,      ,  .  MyRocks       .      ‚Äî      : <code>ROCKSDB_BITES_READ, ROCKSDB_BITES_WRITTEN</code> .      ,    ,      .   ,                .     ,        . <br><br><img src="https://habrastorage.org/webt/uh/dh/3z/uhdh3zbip3urg8cdphihobpsine.png"><br><br><blockquote> , ,      ,                 . </blockquote><br>       ,   ,   open source.          ,        . <br><br>    ,    ,  <strong>    </strong> .  MySQL  ,       .       ,    .         5 ,      10 ,        ,       .     5   ,     ‚Äî      . <br><br>     ,          .          ‚Äî PostgreSQL    . <br><br>  ‚Äî    .   ,    . ,   ,     ,   ,        . <br><br>        .     ,        ‚Äî       SLA.       ,     . <br><br>  ,     .   ,           .       ,      .   ,       . <br><br><img src="https://habrastorage.org/webt/8a/yg/zk/8aygzkmzaogstbgocmxpypcwpjq.png"><br><br> ,       -   ,     .     ,       ,  -  ,   . ,  ,    ,    ‚Äî    ,     -, ,        . <br><br>    ,  ,      ,        . <br><br> ,         .  ,  ,     ,      ,    5-  .     downtime,        . <br><br>   ,       ,    ,   ,    ,           .  ,           ,     ,     ,    . <br><br><h2> Oracle autonomous database </h2><br>      <strong>  </strong> <strong>Oracle</strong> .  2017  Oracle ,        .  ,     Oracle,     ,  ¬´  ,   Oracle   20 ¬ª. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/-f/-d/zo-f-daby9ck_ghomdje3fpny_8.png"></div><br><br> <em>    .  ,       , ,   ,    ,        .   <a href="https://db.cs.cmu.edu/papers/2017/p42-pavlo-cidr17.pdf"></a>  </em> <em>CIDR     ,     .     ,   : ¬´,    ,    ,       . ,        ,     , </em> <em>Oracle       ?¬ª      ,   ‚Äî       .</em> <br><br> ,    ,      ,  Oracle.   ,      . <br><br> ,  <strong>  </strong> ‚Äî   ,       ,       ,         - . <br><br>    ‚Äî <strong> ,   </strong> .  ,    ,     ,      2000- .   ,  Oracle    ,     .      ,     :   ,    ‚Äî      -      . <br><br>   ,      .     ,      ,     . <br><br>   ‚Äî <strong>  </strong> .        ,      .     :      JOIN.        .           .         ,       .             . <br><br>        Oracle. Microsoft  2017   SQL Server,    .  IBM DB2   00-   ,   ¬´LEO¬ª ‚Äî  .   ,  1970-,      Ingres.    ,        JOIN,    ,    .       . <br><br><blockquote>        ,     ,      . </blockquote><br>     ,   ,         .   ,    ,      . ,   ,  . <br><br>  ,     ,     ‚Äî  ,     ,    ,      .  ,   ,  ,      .   ,    ,       ..,     . <br><br><blockquote> HighLoad++    ,        <a href="https://www.highload.ru/siberia/2019/">HighLoad++ Siberia</a>  .     ,    39   ,   ,    highload- -        . <br><br>  <a href="https://www.highload.ru/moscow/2019">HighLoad++</a>    ,    <a href="https://www.highload.ru/moscow/2019/news/1082"> </a> .           ,     <a href="https://usedata.ru/2019">UseData Conf</a> ‚Äî  16 ,   . <a href="http://eepurl.com/VYVaf"></a>  ,       . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/456580/">https://habr.com/ru/post/456580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456564/index.html">List of users with weak passwords in MS SQL</a></li>
<li><a href="../45657/index.html">Gamebox - an arcade toy on JavaScript.</a></li>
<li><a href="../456570/index.html">This Friday, June 21, the anniversary DevConfX will be held; on June 22, exclusive workshops</a></li>
<li><a href="../456572/index.html">40 years of advergeaming - retrospective of promotional video games</a></li>
<li><a href="../456578/index.html">Concepts VueJS for backend developers - master class on June 22</a></li>
<li><a href="../456582/index.html">Why is the Internet still online?</a></li>
<li><a href="../456584/index.html"># ITX5 will bring together JAVA-developers</a></li>
<li><a href="../456588/index.html">Studying Dependency Injection</a></li>
<li><a href="../456592/index.html">Cognitive distortions in mastering the ‚Äútenses‚Äù of the English language, or Who's stopping us, will help us</a></li>
<li><a href="../456594/index.html">2 minutes with Webpack tree-shaking and re-export</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>