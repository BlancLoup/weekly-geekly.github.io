<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit testing in Laravel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I often hear among community discussions the opinion that unit testing in Laravel is wrong, difficult, and the tests themselves are long and giving no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit testing in Laravel</h1><div class="post__text post__text-html js-mediator-article"><p>  I often hear among community discussions the opinion that unit testing in Laravel is wrong, difficult, and the tests themselves are long and giving no benefit.  Because of this, few people write these tests, limiting themselves only to feature tests, and the utility of unit tests tends to 0. <br>  I also thought so once, but once I thought about it and asked myself - maybe I don‚Äôt know how to cook them? </p><br><p>  For a while I understood and at the exit I had a new understanding of unit tests, and the tests became clear, friendly, fast and began to help me. <br>  I want to share my understanding with the community, and even better to understand this topic, to make my tests even better. </p><a name="habracut"></a><br><h2 id="nemnogo-filosofii-i-ogranicheniy">  Some philosophy and limitations </h2><br><p>  Laravel - in some places a kind of framework.  Especially in terms of facades and eloquent.  I will not touch upon discussions or convictions of these moments, but I will show how I combine them with unit tests. <br>  I write tests after (or simultaneously) writing the main code.  My approach may not be compatible with the TDD approach or require partial adjustments. </p><br><p>  The main question I ask myself before writing a test is ‚Äúwhat exactly do I want to test?‚Äù.  This is an important question.  This very thought allowed me to reconsider my views on writing unit tests and the project code itself. </p><br><p>  Tests should be stable and minimally dependent on the environment.  If you make mutations, your tests fail, most likely they are good.  Conversely, if they do not fall, they are probably not very good. </p><br><p>  Out of the box Laravel supports 3 types of tests: </p><br><ul><li>  Browser </li><li>  Feature </li><li>  Unit </li></ul><br><p>  I will talk mainly about Unit tests. </p><br><p>  I am not testing all code through unit tests (perhaps this is not correct).  I am not testing some code at all (more on this below). </p><br><p>  If moki are used in tests, do not forget to do Mockery :: close () on tearDown. </p><br><p>  Some examples of tests are "taken from the Internet." </p><br><h2 id="kak-ya-testiruyu">  How I test </h2><br><p>  Below I will group test examples by class groups and try to give test examples for each class group.  For most groups of classes, I will not give examples of the code itself. </p><br><h3 id="middleware">  Middleware </h3><br><p>  For the unit test middleware, I create an object of class Request, an object of the desired Middleware, then I call the handle method and execute the necessary asserts.  Middleware by the actions performed can be divided into 3 groups: </p><br><ul><li>  changing the request object (changing body request, or sessions) </li><li>  redirecting (changing the response status) </li><li>  doing nothing with the request object <br>  Let's try to give an example of the test for each group: </li></ul><br><p>  Suppose that we have the following Middleware, whose task is to modify the title field: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitlecaseMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($request-&gt;title) { $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; title_case($request-&gt;title) ]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br><p>  A test for such Middleware might look like this: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeTitleToTitlecase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request; $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Title is in mixed CASE'</span></span> ]); $middleware = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TitlecaseMiddleware; $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'Title Is In Mixed Case'</span></span>, $req-&gt;title); }); }</code> </pre> <br><p>  Tests for groups 2 and 3 will be such a plan, respectively: </p><br><pre> <code class="php hljs">$response = $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals($response-&gt;getStatusCode(), <span class="hljs-number"><span class="hljs-number">302</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   $this-&gt;assertEquals($response, null); //      request</span></span></code> </pre> <br><h3 id="request-class">  Request class </h3><br><p>  The main task of this class group is to authorize and validate requests. </p><br><p>  I do not test these classes through unit tests (I admit that this may not be true), only through feature tests.  In my opinion, unit tests are redundant for these classes, but I found some interesting examples of how this can be done.  Perhaps they will help you if you decide to test your request class unit with tests: </p><br><ul><li>  <a href="https://medium.com/%40daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053">https://medium.com/@daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053</a> </li><li>  <a href="https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest">https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest</a> </li></ul><br><h3 id="controller">  Controller </h3><br><p>  I also do not test controllers through unit tests.  But when testing them, I use one feature that I would like to talk about. </p><br><p>  Controllers, in my opinion, should be light.  Their task is to get the right request, call the necessary services and repositories (since both of these terms are ‚Äúalien‚Äù for Laravel, I will give an explanation according to my terminology), return the answer.  Sometimes trigger an event, a job, etc. <br>  Accordingly, when testing through feature tests, we need not only to call the controller with the necessary parameters and check the answer, but also to lock the necessary services and check that they are actually being called (or not being called).  Sometimes - create a record in the database. </p><br><p>  An example of a controller test with mock class of service: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProductCategorySync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = Mockery::mock(\App\Services\Product::class); app()-&gt;instance(\App\Services\Product::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>)-&gt;once(); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/sync/eventsCallback'</span></span>, [ <span class="hljs-string"><span class="hljs-string">"eventType"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"PRODUCT_SYNC"</span></span> ]); $response-&gt;assertStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> <br><p>  An example of a controller test with a facades mock (in our case, an event, but by analogy is done for other Laravel facades): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $user = factory(User::class)-&gt;create(); Passport::actingAs( $user ); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/cart/update'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'products'</span></span> =&gt; [ [ <span class="hljs-comment"><span class="hljs-comment">// our changed data ] ], ]); $data = json_decode($response-&gt;getContent()); $response-&gt;assertStatus(200); $this-&gt;assertEquals($user-&gt;id, $data-&gt;data-&gt;userId); // and assert other data from response Event::assertDispatched(CartChanged::class); }</span></span></code> </pre> <br><h3 id="service-i-repositories">  Service and Repositories </h3><br><p>  There are no out of box data types.  I try to keep the controllers thin, so I put all the extra work into one of these groups of classes. </p><br><p>  I defined the difference between them as follows: </p><br><ul><li>  If I need to implement some business logic, then I bring it to the appropriate service layer (class). </li><li>  In all other cases, I bring this to the repository class group.  As a rule, there goes the functional of working with Eloquent.  I understand that this is not quite the correct definition of the repository level.  I also heard that some endure everything related to Eloquent in the model.  My approach is a kind of compromise, in my opinion, although ‚Äúacademically‚Äù is not quite true. </li></ul><br><p>  For the Repository classes, I almost do not write tests. </p><br><p>  An example of the Service class test below: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUpdateCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $cartService = resolve(CartService::class); $cartRepo = resolve(CartRepository::class); $user = factory(User::class)-&gt;make(); $cart = $cartRepo-&gt;getCart($user); <span class="hljs-comment"><span class="hljs-comment">// set data $data = [ ]; $newCart = $cartService-&gt;updateForUser($user, $data); $this-&gt;assertEquals($data, $newCart-&gt;toArray()); Event::assertDispatched(CartChanged::class, 1); }</span></span></code> </pre> <br><h3 id="event-listener-jobs">  Event-Listener, Jobs </h3><br><p>  These classes are tested almost according to the general principle - we prepare the data necessary for testing;  Call the required class from the framework and check the result. <br>  Example for Listener: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $user = factory(User::class)-&gt;create(); $cart = Cart::create([ <span class="hljs-string"><span class="hljs-string">'userId'</span></span> =&gt; $user-&gt;id, <span class="hljs-comment"><span class="hljs-comment">// other needed data ]); $listener = new CreateTaskForSyncCart(); $listener-&gt;handle(new CartChanged($cart)); $job = // get our job $this-&gt;assertSame(json_encode($cart-&gt;products), $job-&gt;payload); $this-&gt;assertSame($user-&gt;id, $job-&gt;user_id); // some additional asserts. Work with this data simplest for example $this-&gt;assertTrue($updatedAt-&gt;equalTo($job-&gt;last_updated_at)); }</span></span></code> </pre> <br><h3 id="console-commands">  Console commands </h3><br><p>  I see console commands as some kind of controller that can additionally output (and produce more complex manipulations with console input / output described in the documentation) data.  Accordingly, tests are obtained similar to the controller: we check that the necessary methods of services are triggered, events are triggered (or not), and we also check the interaction with the console (output or request data). </p><br><p>  An example of such a test: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSendCartSyncDataEmptyJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = m::mock(CartJobsRepository::class); app()-&gt;instance(CartJobsRepository::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getAll'</span></span>) -&gt;once()-&gt;andReturn(collect([])); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;artisan(<span class="hljs-string"><span class="hljs-string">'sync:cart'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Get all jobs for sending...'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'All count for sending: 0'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Empty jobs'</span></span>) -&gt;assertExitCode(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="otdelnye-vneshnie-biblioteki">  Separate external libraries </h3><br><p>  As a rule, if separate libraries have features for unit tests, they are described in the documentation.  In other cases, work with this code is tested in the same way as the service layer.  Libraries themselves do not make sense to cover with tests (only if you want to send PR to this library) and should be considered as some kind of black box. </p><br><p>  On many projects I have to interact through API with other services.  In Laravel, the Guzzle library is often used for this purpose.  It seemed to me convenient to bring all the work with other services into a separate class of the NetworkService service.  This made it easier for me to write and test the core code, helped standardize responses and error handling. </p><br><p>  I give examples of several tests for my NetworkService class: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuccessfulSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $mockHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockHandler([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>), ]); $handler = HandlerStack::create($mockHandler); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'handler'</span></span> =&gt; $handler]); app()-&gt;instance(\GuzzleHttp\Client::class, $client); $networkService = resolve(NetworkService::class); $response = $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'200'</span></span>, $response-&gt;getStatusCode()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsupportedMethodSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsetConfigUrlNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_url'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">''</span></span>); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_token'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">'token'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToApi(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); }</code> </pre> <br><h2 id="vyvody">  findings </h2><br><p>  This approach allows me to write better and more understandable code, to take advantage of the SOLID and SRP approaches when writing code.  My tests have become faster, and most importantly - they began to bring me a favor. </p><br><p>  With active refactoring when expanding or changing functionality, we immediately see what exactly falls and we can quickly and precisely fix errors without releasing them from the local environment.  This makes error correction as cheap as possible. </p><br><p>  I hope that the principles and approaches I have described will help you understand unit testing in Laravel and make unit tests your helpers in code development. </p><br><p>  Write your additions and comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/457866/">https://habr.com/ru/post/457866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457854/index.html">Hello from 80s programmers</a></li>
<li><a href="../45786/index.html">Cartoon "Gypsy": Who is the boss ?.</a></li>
<li><a href="../457860/index.html">Developing an application for streaming with Node.js and React</a></li>
<li><a href="../457862/index.html">iOS Digest number 8 (June 14 - June 27)</a></li>
<li><a href="../457864/index.html">Myths and legends of system analysis or what does an analyst in the bank</a></li>
<li><a href="../457872/index.html">How to manage time and stop procrastinating?</a></li>
<li><a href="../457874/index.html">Why are employees coming back? Stories left and returned</a></li>
<li><a href="../457876/index.html">Translation: IEEE 802.15.4z Standard. What awaits us in the future?</a></li>
<li><a href="../457884/index.html">Sovereign Online - Clarifying Orders</a></li>
<li><a href="../457886/index.html">Two-factor authentication on the site using a USB token. Now for Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>