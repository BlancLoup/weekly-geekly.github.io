<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating audio plug-ins, part 15</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All posts series: 
 Part 1. Introduction and setup 
 Part 2. Learning Code 
 Part 3. VST and AU 
 Part 4. Digital Distortion 
 Part 5. Presets and GUI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating audio plug-ins, part 15</h1><div class="post__text post__text-html js-mediator-article">  All posts series: <br>  <a href="http://habrahabr.ru/post/224911/">Part 1. Introduction and setup</a> <br>  <a href="http://habrahabr.ru/post/225019/">Part 2. Learning Code</a> <br>  <a href="http://habrahabr.ru/post/225457/">Part 3. VST and AU</a> <br>  <a href="http://habrahabr.ru/post/225751/">Part 4. Digital Distortion</a> <br>  <a href="http://habrahabr.ru/post/225755/">Part 5. Presets and GUI</a> <br>  <a href="http://habrahabr.ru/post/226439/">Part 6. Signal synthesis</a> <br>  <a href="http://habrahabr.ru/post/226573/">Part 7. Receive MIDI Messages</a> <br>  <a href="http://habrahabr.ru/post/226823/">Part 8. Virtual Keyboard</a> <br>  <a href="http://habrahabr.ru/post/227475/">Part 9. Envelopes</a> <br>  <a href="http://habrahabr.ru/post/227601/">Part 10. Refinement GUI</a> <br>  <a href="http://habrahabr.ru/post/227791/">Part 11. Filter</a> <br>  <a href="http://habrahabr.ru/post/227827/">Part 12. Low-frequency oscillator</a> <br>  <a href="http://habrahabr.ru/post/228267/">Part 13. Redesign</a> <br>  <a href="http://habrahabr.ru/post/231513/">Part 14. Polyphony 1</a> <br>  <a href="http://habrahabr.ru/post/231923/">Part 15. Polyphony 2</a> <br>  <a href="http://habrahabr.ru/post/232153/">Part 16. Antialiasing</a> <br><hr><br>  In this post we will finish the work on polyphony: we will code the code and bring the GUI into working condition. <br><br><img src="https://habrastorage.org/files/219/04b/0f9/21904b0f959e4c1a94c5838752ccea45.png"><br><a name="habracut"></a><br><h3>  Saturday </h3><br><br>  Let's start with <code>MIDIReceiver</code> .  Since the structure is now polyphonic, we do not need the <code>mLast</code> variables.  From <i>MIDIReceiver.h,</i> remove <code>mLastNoteNumber</code> , <code>mLastFrequency</code> and <code>mLastVelocity</code> , including their initializations and getters, i.e.  <code>getLastNoteNumber</code> , <code>getLastFrequency</code> and <code>getLastVelocity</code> .  Also delete <code>noteNumberToFrequency</code> .  Just in case, the class should look like this now: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MIDIReceiver</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IMidiQueue mMidiQueue; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyCount = <span class="hljs-number"><span class="hljs-number">128</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mNumKeys; <span class="hljs-comment"><span class="hljs-comment">// how many keys are being played at the moment (via midi) bool mKeyStatus[keyCount]; // array of on/off for each key (index is note number) int mOffset; public: MIDIReceiver() : mNumKeys(0), mOffset(0) { for (int i = 0; i &lt; keyCount; i++) { mKeyStatus[i] = false; } }; // Returns true if the key with a given index is currently pressed inline bool getKeyStatus(int keyIndex) const { return mKeyStatus[keyIndex]; } // Returns the number of keys currently pressed inline int getNumKeys() const { return mNumKeys; } void advance(); void onMessageReceived(IMidiMsg* midiMessage); inline void Flush(int nFrames) { mMidiQueue.Flush(nFrames); mOffset = 0; } inline void Resize(int blockSize) { mMidiQueue.Resize(blockSize); } Signal2&lt; int, int &gt; noteOn; Signal2&lt; int, int &gt; noteOff; };</span></span></code> </pre><br><br>  Change the <code>advance</code> function in <i>MIDIReceiver.cpp</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MIDIReceiver::advance() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!mMidiQueue.Empty()) { IMidiMsg* midiMessage = mMidiQueue.Peek(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (midiMessage-&gt;mOffset &gt; mOffset) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; IMidiMsg::EStatusMsg status = midiMessage-&gt;StatusMsg(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noteNumber = midiMessage-&gt;NoteNumber(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> velocity = midiMessage-&gt;Velocity(); <span class="hljs-comment"><span class="hljs-comment">// There are only note on/off messages in the queue, see ::OnMessageReceived if (status == IMidiMsg::kNoteOn &amp;&amp; velocity) { if(mKeyStatus[noteNumber] == false) { mKeyStatus[noteNumber] = true; mNumKeys += 1; noteOn(noteNumber, velocity); } } else { if(mKeyStatus[noteNumber] == true) { mKeyStatus[noteNumber] = false; mNumKeys -= 1; noteOff(noteNumber, velocity); } } mMidiQueue.Remove(); } mOffset++; }</span></span></code> </pre><br><br>  Three things have changed here: <br><br><ul><li>  Removed members of <code>mLast</code> </li><li>  The <code>noteOn</code> signal <code>noteOn</code> generated when any key is pressed (the note number must not differ from <code>mLastNoteNumber</code> ) </li><li>  The <code>noteOff</code> signal <code>noteOff</code> also generated when any key is released (the note number must not be <code>mLastNoteNumber</code> ) </li></ul><br><br>  Go to <i>SpaceBass.h</i> .  Here you need to delete the following: <br><ul><li>  <code>#include</code> for <i>Oscillator.h</i> , <i>EnvelopeGenerator.h</i> and <i>Filter.h</i> , instead write <code>#include "VoiceManager.h"</code> </li><li>  <code>mOscillator</code> , <code>mEnvelopeGenerator</code> , <code>mFilter</code> , <code>mFilterEnvelopeGenerator</code> and <code>mLFO</code> </li><li>  <code>filterEnvelopeAmount</code> and <code>lfoFilterModAmount</code> </li><li>  member functions <code>onNoteOn</code> , <code>onNoteOff</code> , <code>onBeginEnvelopeCycle</code> , <code>onFinishedEnvelopeCycle</code> </li></ul><br><br>  The code looks better, right?  The plugin class no longer interacts directly with other classes, only with <code>VoiceManager</code> . <br>  Add to the <code>private</code> section: <br><br><pre> <code class="cpp hljs">VoiceManager voiceManager;</code> </pre><br><br>  Modify the class constructor in <i>SpaceBass.cpp</i> : <br><br><pre> <code class="cpp hljs">SpaceBass::SpaceBass(IPlugInstanceInfo instanceInfo) : IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo), lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - <span class="hljs-number"><span class="hljs-number">1</span></span>) { TRACE; CreateParams(); CreateGraphics(); CreatePresets(); mMIDIReceiver.noteOn.Connect(&amp;voiceManager, &amp;VoiceManager::onNoteOn); mMIDIReceiver.noteOff.Connect(&amp;voiceManager, &amp;VoiceManager::onNoteOff); }</code> </pre><br><br>  <code>mMIDIReceiver</code> now connected to <code>VoiceManager</code> , not a plug-in class.  <code>EnvelopeGenerator</code> now controlled by the <code>VoiceManager</code> and <code>Voice</code> classes, so we no longer hook them up using <code>Connect()</code> . <br>  Now the compiler swears, because  <code>ProcessDoubleReplacing</code> refers to the things we have just removed.  The new implementation is very simple: this is a call to <code>VoiceManager::nextSample</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpaceBass::ProcessDoubleReplacing( <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>** inputs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>** outputs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nFrames) { <span class="hljs-comment"><span class="hljs-comment">// Mutex is already locked for us. double *leftOutput = outputs[0]; double *rightOutput = outputs[1]; processVirtualKeyboard(); for (int i = 0; i &lt; nFrames; ++i) { mMIDIReceiver.advance(); leftOutput[i] = rightOutput[i] = voiceManager.nextSample(); } mMIDIReceiver.Flush(nFrames); }</span></span></code> </pre><br><br>  Note that all interactions with oscillators, envelope generators and filters have disappeared. <br>  In the body of <code>Reset()</code> , we no longer have access to these components, so we need to make sure that <code>VoiceManager</code> the sampling rate for all components: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpaceBass::Reset() { TRACE; <span class="hljs-function"><span class="hljs-function">IMutexLock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sampleRate = GetSampleRate(); voiceManager.setSampleRate(sampleRate); }</code> </pre><br><br>  <code>setSampleRate</code> is not yet implemented, add it to the <code>public</code> section in the <i>VoiceManager.h header</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSampleRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sampleRate)</span></span></span><span class="hljs-function"> </span></span>{ EnvelopeGenerator::setSampleRate(sampleRate); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NumberOfVoices; i++) { Voice&amp; voice = voices[i]; voice.mOscillatorOne.setSampleRate(sampleRate); voice.mOscillatorTwo.setSampleRate(sampleRate); } mLFO.setSampleRate(sampleRate); }</code> </pre><br><br>  In essence, the function simply calls <code>setSampleRate</code> for each voice and each component.  It would have been possible to statically call <code>Oscillator::mSampleRate</code> , but I would still have to call <code>updateIncrement</code> for both oscillators of each voice.  But in my opinion, the first option is more transparent. <br><br>  Now everything is fine, except that the interface knobs do not work.  But before we finish them, let's add tone modulation for oscillators. <br><br><h3>  Tone modulation </h3><br><br>  Up to this point, refactoring was mainly <i>structural</i> : we moved parts of the code to different parts of the plugin structure and deleted everything that was unnecessary.  I postponed the modulation of the tone until that moment, because  it is not related to polyphony, did not want to throw everything in one pile. <br><br>  In the <code>Voice::nextSample</code> immediately before <code>return</code> write: <br><br><pre> <code class="cpp hljs">mOscillatorOne.setPitchMod(mLFOValue * mOscillatorOnePitchAmount); mOscillatorTwo.setPitchMod(mLFOValue * mOscillatorTwoPitchAmount);</code> </pre><br><br>  As you can see, the amount of modulation of the tone is determined by the value of the LFO multiplied by the value of the parameter associated with the GUI knob. <br>  Add to the <code>private</code> section in <i>Oscillator.h</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mPitchMod;</code> </pre><br><br>  And to the constructor initialization list: <br><br><pre> <code class="cpp hljs">mPitchMod(<span class="hljs-number"><span class="hljs-number">0.0</span></span>),</code> </pre><br><br>  In the <code>public</code> section you need a setter: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPitchMod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount)</span></span></span></span>;</code> </pre><br><br>  We will write the function in <i>Oscillator.cpp</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Oscillator::setPitchMod(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> amount) { mPitchMod = amount; updateIncrement(); }</code> </pre><br><br>  By setting the modulation value of the tone, we change the frequency itself, so we need to call <code>updateIncrement</code> .  And inside this function, we need to somehow take into account <code>mPitchMod</code> .  Let's rewrite <code>updateIncrement</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Oscillator::updateIncrement() { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pitchModAsFrequency = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(mPitchMod) * <span class="hljs-number"><span class="hljs-number">14.0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPitchMod &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { pitchModAsFrequency = -pitchModAsFrequency; }</code> </pre><br><br>  What's going on here?  <code>mPitchMode</code> changes from <code>-1</code> to <code>1</code> , but we would be more comfortable with the presentation of the type ‚Äúplus 491.3 Hz‚Äù.  <code>pow</code> will help us with the translation in hertz, but negative values ‚Äã‚Äãwill be lost when calling <code>fabs</code> (absolute value).  The following <code>if</code> returns us negative values.  Subtracting the unit at the end is necessary, because when <code>mPitchMod</code> is zero, the expression <code>pow(2.0, 0)</code> will yield <code>1</code> , and we will get a modulation of the tone at 1 Hz, which is wrong. <br>  Next, we compute the <code>calculatedFrequency</code> from the fundamental frequency of the <code>mFrequency</code> and the value in hertz that we just received: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> calculatedFrequency = fmin(fmax(mFrequency + pitchModAsFrequency, <span class="hljs-number"><span class="hljs-number">0</span></span>), mSampleRate/<span class="hljs-number"><span class="hljs-number">2.0</span></span>);</code> </pre><br><br>  First, we add these two frequencies.  <code>fmin</code> ensures that we do not exceed half the sampling rate.  We cannot rise above <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D0%259D%25D0%25B0%25D0%25B9%25D0%25BA%25D0%25B2%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0">the Nyquist frequency</a> , otherwise we will get aliasing.  <code>fmax</code> ensures that the frequency does not fall below zero. <br>  Well, append the phase increment: <br><br><pre> <code class="cpp hljs"> mPhaseIncrement = calculatedFrequency * <span class="hljs-number"><span class="hljs-number">2</span></span> * mPI / mSampleRate; }</code> </pre><br><br>  Here everything is as before, except that now, naturally, we use <code>calculatedFrequency</code> . <br><br><h3>  Interface knobs </h3><br><br>  The last piece of the puzzle!  After this, our syntyuk will be ready! <br><br>  Let's start with the LFO knobs.  They do not affect the voices, so with them everything is somewhat different than with other parameters.  Replace the <code>OnParamChange</code> function <code>OnParamChange</code> a new one: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpaceBass::OnParamChange(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> paramIdx) { <span class="hljs-function"><span class="hljs-function">IMutexLock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; IParam* param = GetParam(paramIdx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(paramIdx == mLFOWaveform) { voiceManager.setLFOMode(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(paramIdx == mLFOFrequency) { voiceManager.setLFOFrequency(param-&gt;Value()); } }</code> </pre><br><br>  We check which parameter changes, and call either <code>setLFOMode</code> or <code>setLFOFrequency</code> .  These two functions have not yet been written; let's do it in the <code>public</code> section in <i>VoiceManager.h</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLFOMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Oscillator::OscillatorMode mode)</span></span></span><span class="hljs-function"> </span></span>{ mLFO.setMode(mode); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLFOFrequency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frequency)</span></span></span><span class="hljs-function"> </span></span>{ mLFO.setFrequency(frequency); };</code> </pre><br><br>  As you can see, both of them just call <code>mLFO</code> setters. <br><br>  For the remaining parameters, we use <i>C ++ functional mechanisms</i> .  These are very powerful and convenient things, but they are not often spoken of in language guides.  I think you will agree on what is worth knowing about them.  So what is the problem? <br><br>  When turning the knob, <code>OnParamChange</code> is <code>OnParamChange</code> with the parameter ID and its value.  Let's say <code>mFilterCutoff</code> with a value of <code>0.3</code> .  Now we are <code>VoiceManager</code> : <i>‚Äúfor each <code>Voice</code> set the filter slice to <code>0.3</code> ‚Äù</i> .  Further, perhaps, we would call the <code>setFilterCutoffForEachVoice</code> function, which would look something like this (I <code>setFilterCutoffForEachVoice</code> it just for demonstration): <br><br><pre> <code class="cpp hljs">VoiceManager::setFilterCutoffForEachVoice(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newCutoff) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NumberOfVoices; i++) { voice[i].mFilter.setCutoff(newCutoff); } }</code> </pre><br><br>  It seems that everything is not bad, but we would need about ten such functions for different parameters.  Each would be a little different, but <code>for</code> all would be the same.  It would be nice to be able to say <i>"Here is a change, it should be applied to all voices</i> . <i>"</i>  In C ++, this possibility naturally exists.  You can take a function, prefill it with some input values, and call it to handle various things.  This is similar to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind</a> in JavaScript, but still with data type compatibility checking. <br>  Let's try this approach!  Add to <i>VoiceManager.h</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tr1/functional&gt; // #include &lt;functional&gt; if that doesn't work</span></span></span></span></code> </pre><br><br>  In <code>public</code> add: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (Voice&amp;)&gt; VoiceChangerFunction;</code> </pre><br><br>  <code>VoiceChangerFunction</code> is a function that takes <code>Voice&amp;</code> as the first parameter and returns <code>void</code> .  In fact, it is not at all necessary that this be a function.  Anything that can be called using <code>()</code> . <br>  After that add the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeAllVoices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VoiceChangerFunction changer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NumberOfVoices; i++) { changer(voices[i]); } }</code> </pre><br><br>  <code>VoiceChangerFunction</code> over all voices and applies the whole <code>changer</code> to them. <br>  Under this add the functions themselves.  They all look about the same: each accepts a link to the <code>Voice&amp;</code> voice and some other parameters and changes that voice. <br><a name="changingFunctions"></a><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Functions to change a single voice: static void setVolumeEnvelopeStageValue(Voice&amp; voice, EnvelopeGenerator::EnvelopeStage stage, double value) { voice.mVolumeEnvelope.setStageValue(stage, value); } static void setFilterEnvelopeStageValue(Voice&amp; voice, EnvelopeGenerator::EnvelopeStage stage, double value) { voice.mFilterEnvelope.setStageValue(stage, value); } static void setOscillatorMode(Voice&amp; voice, int oscillatorNumber, Oscillator::OscillatorMode mode) { switch (oscillatorNumber) { case 1: voice.mOscillatorOne.setMode(mode); break; case 2: voice.mOscillatorTwo.setMode(mode); break; } } static void setOscillatorPitchMod(Voice&amp; voice, int oscillatorNumber, double amount) { switch (oscillatorNumber) { case 1: voice.setOscillatorOnePitchAmount(amount); break; case 2: voice.setOscillatorTwoPitchAmount(amount); break; } } static void setOscillatorMix(Voice&amp; voice, double value) { voice.setOscillatorMix(value); } static void setFilterCutoff(Voice&amp; voice, double cutoff) { voice.mFilter.setCutoff(cutoff); } static void setFilterResonance(Voice&amp; voice, double resonance) { voice.mFilter.setResonance(resonance); } static void setFilterMode(Voice&amp; voice, Filter::FilterMode mode) { voice.mFilter.setFilterMode(mode); } static void setFilterEnvAmount(Voice&amp; voice, double amount) { voice.setFilterEnvelopeAmount(amount); } static void setFilterLFOAmount(Voice&amp; voice, double amount) { voice.setFilterLFOAmount(amount); }</span></span></code> </pre><br><br>  But we cannot pass their <code>changeAllVoices</code> functions.  They are not functions of the <code>VoiceChangerFunction</code> , because everyone takes more than one argument.  We will fill in all the arguments first but the first ( <code>Voice&amp;</code> ).  And this will turn them into <code>VoiceChangerFunction</code> functions. <br>  Add <code>#include &lt;tr1/functional&gt;</code> (or <code><code>#include ).   OnParamChange  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code></code> <i>SpaceBass.cpp</i> <code><code>#include ).   OnParamChange  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code></code> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> <pre> <code class="hljs dos"><code>#include ).   OnParamChange</code>  <code><span class="hljs-keyword"><span class="hljs-keyword">else</span></span></code>  ,    : <br> <br> <code class="cpp"> // ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, <span class="hljs-number"><span class="hljs-number">1</span></span>, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code><span class="hljs-number"><span class="hljs-number">1</span></span></code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, <span class="hljs-number"><span class="hljs-number">1</span></span>, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, <span class="hljs-number"><span class="hljs-number">2</span></span>, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, <span class="hljs-number"><span class="hljs-number">2</span></span>, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </pre> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> <ul><li> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </li> <li> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </li> </ul> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> <pre> <code class="hljs dos"><code>#include ).   OnParamChange</code>  <code><span class="hljs-keyword"><span class="hljs-keyword">else</span></span></code>  ,    : <br> <br> <code class="cpp"> // ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, <span class="hljs-number"><span class="hljs-number">1</span></span>, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code><span class="hljs-number"><span class="hljs-number">1</span></span></code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, <span class="hljs-number"><span class="hljs-number">1</span></span>, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, <span class="hljs-number"><span class="hljs-number">2</span></span>, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, <span class="hljs-number"><span class="hljs-number">2</span></span>, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </pre> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> <pre> <code class="hljs dos"><code>#include ).   OnParamChange</code>  <code><span class="hljs-keyword"><span class="hljs-keyword">else</span></span></code>  ,    : <br> <br> <code class="cpp"> // ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, <span class="hljs-number"><span class="hljs-number">1</span></span>, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code><span class="hljs-number"><span class="hljs-number">1</span></span></code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, <span class="hljs-number"><span class="hljs-number">1</span></span>, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, <span class="hljs-number"><span class="hljs-number">2</span></span>, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, <span class="hljs-number"><span class="hljs-number">2</span></span>, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </pre> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> <h3> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </h3> <code><code>#include ).   OnParamChange</code>  <code>else</code>  ,    : <br> <br> <code class="cpp"> // ... } else { using std::tr1::placeholders::_1; using std::tr1::bind; VoiceManager::VoiceChangerFunction changer; switch(paramIdx) { // We'll add this part in a moment } voiceManager.changeAllVoices(changer); } }</code> <br> <br>    ,     <code>std::tr1::</code>  .     <code>_1</code>  <code>bind</code> (  ).    <code>VoiceChangerFunction</code> . <code>switch</code>  <code>changer</code>    ID .     <code>changeAllVoices</code> ,     <code>changer</code> . <br> <br>      <code>changer</code> ? <br> <br>    ,  <a href="https://habr.com/ru/post/231923/"></a>   <code>std::tr1::bind</code>     , <code>Voice&amp;</code> <br> <br>       <code>VoiceChangerFunction</code> .    ,   ,     .   <code>case</code>  <code>switch(paramIdx)</code> : <br> <br> <code class="cpp">case mOsc1Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 1, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break;</code> <br> <br>     (. bind)  ,      .    <code>setOscillatorMode</code> .   -   . <code>_1</code>     ,     .       <code>changer</code> .    <code>changer</code>      <code>Voice&amp;</code> .     :    <code>1</code>   .        <code>OscillatorMode enum</code> . <br> <br>    <code>changer</code>    .   .    ,      ,   : <br> <br> <code class="cpp">case mOsc1PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 1, param-&gt;Value()); break; case mOsc2Waveform: changer = bind(&amp;VoiceManager::setOscillatorMode, _1, 2, static_cast&lt;Oscillator::OscillatorMode&gt;(param-&gt;Int())); break; case mOsc2PitchMod: changer = bind(&amp;VoiceManager::setOscillatorPitchMod, _1, 2, param-&gt;Value()); break; case mOscMix: changer = bind(&amp;VoiceManager::setOscillatorMix, _1, param-&gt;Value()); break; // Filter Section: case mFilterMode: changer = bind(&amp;VoiceManager::setFilterMode, _1, static_cast&lt;Filter::FilterMode&gt;(param-&gt;Int())); break; case mFilterCutoff: changer = bind(&amp;VoiceManager::setFilterCutoff, _1, param-&gt;Value()); break; case mFilterResonance: changer = bind(&amp;VoiceManager::setFilterResonance, _1, param-&gt;Value()); break; case mFilterLfoAmount: changer = bind(&amp;VoiceManager::setFilterLFOAmount, _1, param-&gt;Value()); break; case mFilterEnvAmount: changer = bind(&amp;VoiceManager::setFilterEnvAmount, _1, param-&gt;Value()); break; // Volume Envelope: case mVolumeEnvAttack: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mVolumeEnvDecay: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mVolumeEnvSustain: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mVolumeEnvRelease: changer = bind(&amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break; // Filter Envelope: case mFilterEnvAttack: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&gt;Value()); break; case mFilterEnvDecay: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&gt;Value()); break; case mFilterEnvSustain: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&gt;Value()); break; case mFilterEnvRelease: changer = bind(&amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&gt;Value()); break;</code> <br> <br>     :      <code>changer</code>         - <code>enum</code>     . <br>   -        <code>VoiceManager</code>       ,     <code>changeAllVoices</code> .       . <br> <br> ! <br> <br> ,      !  ,    ,  ,      .    . <br> <br>       <a href=""></a> . <br> <br>     ,         . <br> <br> <a href="http://martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/"> </a> .</code> </div><p>Source: <a href="https://habr.com/ru/post/231923/">https://habr.com/ru/post/231923/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231911/index.html">5 ways to keep call center customers</a></li>
<li><a href="../231915/index.html">MediaTek and LTE: first results</a></li>
<li><a href="../231917/index.html">Secure Deployment of ElasticSearch Server</a></li>
<li><a href="../231919/index.html">Announced by Nokia Lumia 530</a></li>
<li><a href="../231921/index.html">Sweater: Finally on the App Store</a></li>
<li><a href="../231925/index.html">Games for science</a></li>
<li><a href="../231929/index.html">Ultra Efficient Text Processing</a></li>
<li><a href="../231931/index.html">The Facebook Gifts service is closing</a></li>
<li><a href="../231933/index.html">SocialTask: the proper promotion of the commercial group VKontakte</a></li>
<li><a href="../231935/index.html">Creating and setting up a Minecraft server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>