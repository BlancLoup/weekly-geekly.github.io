<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generation of type objects on the fly (or madness with Rust)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will have a little fun with the programming language Rust, and in particular, with type-objects. 


 When I got acquainted with Rus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generation of type objects on the fly (or madness with Rust)</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article we will have a little fun with the programming language Rust, and in particular, with type-objects. </p><br><p>  When I got acquainted with Rust, one of the details of the implementation of type-objects seemed to me interesting.  Namely, the fact that the virtual table of functions is located not in the data itself, but in the "thick" pointer to them.  Each pointer to a type-object) contains a pointer to the data itself, as well as a link to a virtual table, which will contain the addresses of functions that implement this type-object for a given structure (but since this is an implementation detail, the behavior may change. </p><a name="habracut"></a><br><p>  Let's start with a simple example that demonstrates thick pointers.  The following code will output on 64-bit architecture 8 and 16: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = &amp;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disp: &amp;std::fmt::Display = v; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, std::mem::size_of_val(&amp;v)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   -: {}"</span></span>, std::mem::size_of_val(&amp;disp)); }</code> </pre> <br><p>  What is interesting?  When I was engaged in enterprise-Java, one of the tasks, which quite regularly arose was the adaptation of existing objects for given interfaces.  That is, the object is already there, issued in the form of a link, but it is necessary to adapt it to the specified interface.  And you can not change the input object, it is what it is. </p><br><p>  I had to do something like this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Json value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...- , , ,  "value"  //   Person return new PersonJsonAdapter(value); }</span></span></code> </pre> <br><p>  At such an approach, there were various problems.  For example, if the same object "adapts" twice, then we get two different <code>Person</code> (in terms of comparison of references).  And the fact that you have to create new objects every time is somehow ugly. </p><br><p>  When I saw the type objects in Rust, I had a thought that in Rust this could be done much more elegantly!  You can also take and assign another virtual table to the data and get a new type-object!  And do not allocate memory for each instance.  At the same time, the whole logic of "borrowing" remains in place - our adaptation function will look like something like <code>fn adapt&lt;'a&gt;(value: &amp;'a Json) -&gt; &amp;'a Person</code> (that is, we kind of borrow from source data). </p><br><p>  Moreover, it is possible to ‚Äúforce‚Äù the same type (for example, <code>String</code> ) to implement our type-object several times, with different behavior.  What for?  But you never know what you might need in the enterprise? </p><br><p>  Let's try to implement it. </p><br><h2 id="postanovka-zadachi">  Formulation of the problem </h2><br><p>  We set the task in the following way: make the function <code>annotate</code> , which "assigns" the following type-object to the usual <code>String</code> type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; }</code> </pre> <br><p>  And the <code>annotate</code> function itself: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    - `Object`,   , ///   "" -- ,    `type_name`. fn annotate&lt;'a&gt;(input: &amp;'a String, type_name: &amp;str) -&gt; &amp;'a dyn Object { // ... }</span></span></code> </pre> <br><p>  Write a test right away.  First, we make sure that the "attributed" type coincides with the expected one.  Second, make sure that we can get the source line and it will be the same line (from the point of view of pointers): </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated1 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Widget"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated2 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Gadget"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -   ,    assert_eq!("Widget", annotated1.type_name()); assert_eq!("Gadget", annotated2.type_name()); let unwrapped1 = annotated1.as_string(); let unwrapped2 = annotated2.as_string(); //       --   assert_eq!(unwrapped1 as *const String, &amp;input as *const String); assert_eq!(unwrapped2 as *const String, &amp;input as *const String); }</span></span></code> </pre> <br><h2 id="podhod-1-a-posle-nas-hot-potop">  Approach number 1: and after us even the flood! </h2><br><p>  To begin with we will try to make absolutely naive implementation.  Just wrap our data in a "wrapper", which will additionally contain <code>type_name</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { value: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value } }</code> </pre> <br><p>  So far, nothing special.  Just like in Java.  But we do not have a garbage collector, where will we store this wrapper?  We also need to return the link, so much so that it remains valid after calling the <code>annotate</code> function.  Nothing terrible shove in the box ( <code>Box</code> ) so that the wrapper ( <code>Wrapper</code> ) was allocated on the heap.  And then return the link to it.  And in order to keep the wrapper alive after calling the <code>annotate</code> function, we will <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">‚Äúleak‚Äù</a> this box: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(Wrapper { value: input, type_name: type_name.into(), }); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::leak(b) }</code> </pre> <br><p>  ... and the test passes! </p><br><p>  But this is some kind of dubious decision.  Not only do we still allocate memory for each "annotation", so also the memory leaks ( <code>Box::leak</code> returns a link to the data stored on the heap, but also "forgets" the box itself, that is, it will not be automatically released ). </p><br><h2 id="podhod-2-arena">  Approach number 2: arena! </h2><br><p>  To begin with, let's try to save these wrappers somewhere so that they would still be released at some point.  But at the same time saving the <code>annotate</code> signature as it is.  That is, to return a link with reference counting (for example, <code>Rc&lt;Wrapper&gt;</code> ) is not appropriate. </p><br><p>  The simplest option is to create an auxiliary structure, a ‚Äútype system‚Äù, which will be responsible for storing these wrappers.  And when we finish, we will free this structure and all the wrappers with it. </p><br><p>  Something like this.  The <a href="https://crates.io/crates/typed-arena"><code>typed-arena</code></a> library is used to store wrappers, but the <code>Vec&lt;Box&lt;Wrapper&gt;&gt;</code> type could also be avoided, the main thing is to ensure that the <code>Wrapper</code> does not move anywhere (in the nightly Rust, you could use the <a href="https://doc.rust-lang.org/1.30.1/std/pin/index.html">pin API</a> for this): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { wrappers: typed_arena::Arena&lt;Wrapper&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { wrappers: typed_arena::Arena::new(), } } <span class="hljs-comment"><span class="hljs-comment">///     `input`,      , ///    (  ,    , ///        )! pub fn annotate&lt;'a: 'b, 'b&gt;( &amp;'a self, input: &amp;'b String, type_name: &amp;str ) -&gt; &amp;'b dyn Object { self.wrappers.alloc(Wrapper { value: input, type_name: type_name.into(), }) } }</span></span></code> </pre> <br><p>  But where did the parameter responsible for the link lifetime of the <code>Wrapper</code> type go?  We had to get rid of it, since we cannot attribute any fixed lifetime to the type <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> .  Each wrapper has a unique parameter dependent on <code>input</code> ! </p><br><p>  Instead, we sprinkle a little insecure Rust to get rid of the lifetime parameter: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span> { value: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-comment"><span class="hljs-comment">///   -- ,     (  /// `annotate`),     (    - /// `&amp;Object`)  ,      (`String`). fn as_string(&amp;self) -&gt; &amp;String { unsafe { &amp;*self.value } } }</span></span></code> </pre> <br><p>  And the tests pass again, thereby giving us confidence in the correctness of the decision.  In addition to the feeling of light awkwardness due to <code>unsafe</code> (as it should be, it is better not to joke with unsafe Rust!). </p><br><p>  But still, what about the promised version, which does not require additional memory allocations for wrappers? </p><br><h2 id="podhod-3-da-razverznutsya-vrata-ada">  Approach # 3: let the gates of hell open </h2><br><p>  Idea.  For each unique "type" ("Widget", "Gadget"), we will create a virtual table.  Hands, during the execution of the program.  And we assign it to the link given to us to the data itself (which we have, as we remember, is just a <code>String</code> ). </p><br><p>  First, a small description of what we need to get.  So, the link to the type of object, how is it arranged?  In fact, these are just two pointers, one to the data itself, and the other to a virtual table.  So we write: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TraitObject</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> data: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vtable: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), }</code> </pre> <br><p>  ( <code>#[repr(C)]</code> we need to guarantee the correct location in memory). </p><br><p>  It seems everything is simple, we will generate a new table for the specified parameters and "collect" a link to the type-object!  But what does this table consist of? </p><br><p>  The correct answer to this question would be ‚Äúthis is the implementation detail‚Äù.  But we will do so;  create a <code>rust-toolchain</code> file in the root of our project and write it there: <code>nightly-2018-12-01</code> .  After all, a fixed assembly can be considered stable, right? </p><br><p>  Now that we have fixed the version of Rust (in fact, we will need the nightly build for one of the libraries just below). </p><br><p>  After some <a href="http://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/">searching on the Internet</a> , we find out that the table format is simple: first there is a link to the destructor, then two fields related to memory allocation (type size and alignment), and then functions follow one after another (the order is at the discretion of the compiler, but we have only two functions, so the probability of guessing is quite large, 50%). </p><br><p>  So we write: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Copy)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtualTableHeader</span></span></span></span> { destructor_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ()), size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, align: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectVirtualTable</span></span></span></span> { header: VirtualTableHeader, type_name_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, as_string_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Similarly, <code>#[repr(C)]</code> needed to ensure proper memory placement.  I divided into two structures, a little later it will be useful to us. </p><br><p>  Now let's try to write our type system, which will provide the <code>annotate</code> function.  We will need to cache the generated tables, so we will get the cache: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeInfo</span></span></span></span> { vtable: ObjectVirtualTable, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { infos: RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, TypeInfo&gt;&gt;, }</code> </pre> <br><p>  We use the internal state of <code>RefCell</code> so that our <code>TypeSystem::annotate</code> function can get <code>&amp;self</code> as a shared link.  This is important because we are ‚Äúborrowing‚Äù from <code>TypeSystem</code> to ensure that the virtual tables we generated have lived longer than the reference to the type object we return from <code>annotate</code> . </p><br><p>  Since we want to annotate many instances, we cannot borrow <code>&amp;mut self</code> as a variable reference. </p><br><p>  And we outline this code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;( &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> infos = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infos.borrow_mut(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imp = infos.entry(type_name).or_insert_with(|| <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,  ? let vtable = unimplemented!(); TypeInfo { vtable } }); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; //       - unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } } }</span></span></code> </pre> <br><p>  Where do we get this table from?  The first three entries in it will match the entries for any other virtual table for a given type.  Therefore, just take and copy them.  At first we will get this type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Whatever</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Whatever <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> T {}</code> </pre> <br><p>  It is useful to us to get this "any other virtual table".  And then, we copy these three records from him: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever = input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Whatever; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_vtable_header = whatever_obj.vtable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VirtualTableHeader; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vtable = ObjectVirtualTable { <span class="hljs-comment"><span class="hljs-comment">//  ! header: *whatever_vtable_header, type_name_fn: unimplemented!(), as_string_fn: unimplemented!(), }; TypeInfo { vtable }</span></span></code> </pre> <br><p>  Basically, we could get the size and alignment via <code>std::mem::size_of::&lt;String&gt;()</code> and <code>std::mem::align_of::&lt;String&gt;()</code> .  But from where it is still possible to ‚Äústeal‚Äù the destructor, I do not know. </p><br><p>  OK, but where do we get the addresses of these functions, <code>type_name_fn</code> and <code>as_string_fn</code> ?  You may notice that <code>as_string_fn</code> in general, not needed, a pointer to the data is always the first entry in the type-object representation.  That is, this function is always the same: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... fn as_string(&amp;self) -&gt; String { self } }</span></span></code> </pre> <br><p>  But with the second function is not so easy!  It depends on our type name, <code>type_name</code> . </p><br><p>  It does not matter, we can simply generate this function in runtime.  Take for this library <a href="https://crates.io/crates/dynasm"><code>dynasm</code></a> (currently, requires the nightly assembly Rust).  Read about <br>  <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">function calling conventions</a> . </p><br><p>  For simplicity, suppose that we are only interested in Mac OS and Linux (after all these fun transformations, compatibility doesn't really bother us anymore, right?).  And, yes, only x86-64, of course. </p><br><p>  The second function, <code>as_string</code> , is easy to implement.  We are promised that the first parameter will be in the <code>RDI</code> register.  And return the value to <code>RAX</code> .  That is, the function code will be something like: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, rdi ; ret );</code> </pre> <br><p>  But the first function is a little trickier.  First, we need to return <code>&amp;str</code> , and this is a thick pointer.  Its first part is a pointer to a string, and the second part is the length of a string slice.  Fortunately, the convention above allows you to return 128-bit results using the <code>EDX</code> register for the second part. </p><br><p>  It remains to get somewhere a link to a string slice that contains our <code>type_name</code> string.  We do not want to rely on <code>type_name</code> (although it is possible to ensure that <code>type_name</code> will live longer than the returned value through annotations of lifetime). </p><br><p>  But we have a copy of this string, which we put in the hash table.  Crossing our fingers, we will assume that the location of the string slice that does not return to <code>String::as_str</code> does not change from moving the <code>String</code> (and the <code>String</code> will move during the <code>HashMap</code> size change, where this string is stored as a key).  I don‚Äôt know if the standard library guarantees this behavior, but how can we play just? </p><br><p>  We get the necessary components: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_ptr = type_name.as_str().as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_len = type_name.as_str().len();</code> </pre> <br><p>  And we write this function: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, QWORD type_name_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; mov rdx, QWORD type_name_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; ret );</code> </pre> <br><p>  And finally, the final <code>annotate</code> code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-comment"><span class="hljs-comment">//       let type_name_ptr = type_name.as_str().as_ptr(); let type_name_len = type_name.as_str().len(); let mut infos = self.infos.borrow_mut(); let imp = infos.entry(type_name).or_insert_with(|| unsafe { let mut ops = dynasmrt::x64::Assembler::new().unwrap(); //     `type_name` let type_name_offset = ops.offset(); dynasm!(ops ; mov rax, QWORD type_name_ptr as i64 ; mov rdx, QWORD type_name_len as i64 ; ret ); //     `as_string` let as_string_offset = ops.offset(); dynasm!(ops ; mov rax, rdi ; ret ); let buffer = ops.finalize().unwrap(); //      let whatever = input as &amp;dyn Whatever; let whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); let whatever_vtable_header = whatever_obj.vtable as *const VirtualTableHeader; let vtable = ObjectVirtualTable { header: *whatever_vtable_header, type_name_fn: std::mem::transmute(buffer.ptr(type_name_offset)), as_string_fn: std::mem::transmute(buffer.ptr(as_string_offset)), }; TypeInfo { vtable, buffer } }); assert_eq!(imp.vtable.header.size, std::mem::size_of::&lt;String&gt;()); assert_eq!(imp.vtable.header.align, std::mem::align_of::&lt;String&gt;()); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } }</span></span></code> </pre> <br><p>  For <code>dynasm</code> purposes, <code>dynasm</code> need to add the <code>buffer</code> field to our <code>TypeInfo</code> structure.  This field controls the memory that stores the code of our generated functions: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused)]</span></span> buffer: dynasmrt::ExecutableBuffer,</code> </pre> <br><p>  And all the tests pass! </p><br><h2 id="gotovo-master">  Done, master! </h2><br><p>  It‚Äôs so easy and natural to generate your type object implementations in the Rust code! </p><br><p>  The latter solution actively relies on implementation details and is therefore not recommended for use.  But in reality you have to do what is necessary.  Desperate times require desperate measures! </p><br><p>  There is, however, (yet) one feature that I rely on here.  Namely, it is safe to release the memory occupied by the virtual table after there are no references to the type-object that uses it.  On the one hand, it is logical that a virtual table can be used only through type-object references.  On the other hand, the tables provided by Rust have a lifetime of <code>'static</code> .  It can be assumed that some code separates the table from the link for some of its own purposes (for example, for <a href="http://idubrov.name/rust/2018/06/16/dynamic-casting-traits.html">some dirty work</a> ). </p><br><p>  Source code can be <a href="https://github.com/idubrov/crazy-traits">found here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432202/">https://habr.com/ru/post/432202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432190/index.html">Underside client-side physics prediction</a></li>
<li><a href="../432192/index.html">4 signs that you are not ready to implement a project management solution</a></li>
<li><a href="../432196/index.html">About the composition of functions in JavaScript</a></li>
<li><a href="../432198/index.html">Delivery Manager - a new role in the world of Agile</a></li>
<li><a href="../432200/index.html">How Ivan stand conversion investigated</a></li>
<li><a href="../432204/index.html">Seminar "20 little things that will make the work in the data center truly comfortable", December 13, Moscow</a></li>
<li><a href="../432206/index.html">Detailed analysis of what Google showed at the FlutterLive conference (and what it means for Dart and the world)</a></li>
<li><a href="../432208/index.html">Kubernetes 1.13: a review of major innovations</a></li>
<li><a href="../432210/index.html">Qualcomm Introduces Snapdragon 855 Platform with 5G Support</a></li>
<li><a href="../432212/index.html">7 years of educational projects Mail.Ru Group: sharing experience in key areas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>