<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Imagrium: A framework for automating cross-platform testing of mobile applications.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The company in which I work develops custom software, including mobile applications based on Android and iOS. Due to the fact that the competition in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Imagrium: A framework for automating cross-platform testing of mobile applications.</h1><div class="post__text post__text-html js-mediator-article">  The company in which I work develops custom software, including mobile applications based on Android and iOS.  Due to the fact that the competition in this segment of the market is quite high, testers are not only responsible for meeting the final product specifications and customer expectations, but also put in a tight framework for budget and testing time.  This encourages us to explore new tools and methods that would allow us to reduce testing costs and improve product quality. <br><br>  <i>Imagrium</i> is the result of one of these studies.  Technically, this is a Jython framework for cross-platform testing of mobile Android / iOS applications using <b>image recognition</b> , written by our company.  It is presented in the form of a working PyDev project, which you can change to fit your needs.  The code is distributed under the MIT license and <a href="https://github.com/azoft-dev-team/imagrium">is available</a> on Github.  In this article I will talk about the principles of the framework and its device. <br><a name="habracut"></a><br><h1>  Work principles </h1><br>  The framework is already about 2 years old, during this time it has grown and developed, incorporating the experience of using it on combat projects.  In this case, the basic principles, perhaps, have not changed much.  They are: <br><br>  <i><b>Use the same tests on different platforms</b></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually, our customers order the application directly under several platforms, most often Android and iOS.  It turns out that the specification is the same, the functional tests are the same, so the most effective from our point of view would be to have one test base for different platforms.  In other words, the same test should take place under different platforms. <br><br>  <i><b>Separate resources from logic</b></i> <br><br>  Tools that allow cross-platform testing can be divided into two types: <br><ul><li>  Providing a common API and mediation service that translates common calls to axis-specific calls (MonkeyTalk, Appium, Robotium). </li><li>  Using the pattern recognition method (Borland Silk Mobile, eggPlant). </li></ul><br><br>  We are big fans of the first approach, but at that time some tools were not yet there, the others were not very stable, and this forced us to try our hand at writing alternatives.  At the same time, we did not want another record-and-replay instrument, because tests created by such instruments very quickly become very difficult to maintain.  Why?  Because in them resources are connected with the logic of work.  For example, when changing a primitive operation, you will have to not only transfer pictures in all texts, but also change the necessary steps in the necessary tests.  I wanted to avoid such meaningless and costly work using the popular PageObject pattern. <br><br>  <i><b>Maintain continuous integration and convenient debugging</b></i> <br><br>  All our projects are automatically built by Jenkins, so from the very first line of the code of this framework, we would like the tests for the application to be launched automatically too.  Initially, it was not so easy because they decided to use Sikuli (as the most popular, documented and free solution) for working with images, which at that time did not have an easy way to separate the library from the IDE and only had support for Jython 2.5 (which, by the way, there was still no support for json, yes, yes), in unittest there were no heaps of tasty features (for example, auto-finding tests).  However, over time, these difficulties were overcome, and now the test results are available in jUnit format, and Ant makes a beautiful page with statistics. <br><br>  On the second point, if you saw the Sikuli IDE, then you understand that doing something a little more serious in it than a 10-line application is a pain.  If only because there is no debugger.  For us, this was enough to switch to using PyDev Eclipse, which is familiar to programmers and contains a lot of support features to speed development. <br><br>  <i><b>Ensure the same initial state of the system for all tests.</b></i> <br><br>  We borrowed the idea of ‚Äã‚Äãindependence of tests from each other from jUnit because  this makes it possible to run tests in parallel or perform random checks.  Another task that pushed us towards this is the drop in tests in the middle of execution.  We needed a system in which the fall of one test would not affect the performance of other tests.  As a result, we decided to use snapshots (snapshots) of the emulator on Android and the reset function of the simulator on iOS. <br><br>  <i><b>Emulator downloads and responses should not critically delay test execution.</b></i> <br><br>  We really liked the speed of the iOS simulator, which could not be said about the boxed Android emulator.  We had hopes for HAXM and x86 images supplied by Intel, but the trouble is that these images prior to version 4.4 did not contain the Google API, which is used in most of our applications (i.e., applications were simply not installed on these images).  In turn, the image 4.4, which contains this API, was unstable for us (for example, it could crash when the application was reinstalled).  Therefore, we chose <a href="http://genymotion.com/">Genymotion</a> and <a href="https://www.virtualbox.org/">VirtualBox</a> to create and manage snapshots. <br><br>  If you share these principles and think about some kind of framework for testing, we suggest you consider ours as one of the alternatives. <br><br><h1>  Environmental requirements </h1><br>  Imagrium works successfully on Java 7 x64 and Windows 7 x64 ( <i>win</i> branch of the repository) or MacOS 10.9 (branch of the <i>ios</i> repository). <br>  Historically, only Android was tested under Windows, and only iOS under MacOS. <br><br><h1>  Demonstration of work </h1><br>  Before we take a quick look at the rules for writing tests on Imagrium, we want to show a video with the capabilities of the framework.  This video shows the passing test for the HopHop app on iOS and Android. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/IUJOzHMKZgo%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253&amp;usg=ALkJrhjxx9I20dCFOD7khqGLubUctCRMZg" frameborder="0" allowfullscreen=""></iframe><br><br><h1>  How to write tests </h1><br>  The code written in Imagrium can be divided into two blocks: <i>pages</i> and <i>tests</i> .  In this grouping, a test is a sequence of operations conducted on different pages, as well as transitions between pages.  For example: <br><br><pre><code class="python hljs">authPage = AuthPage.load(AppLauncher.box, self.settings) fbAuthPage = authPage.signUpFb() fbAuthPage.fillEmail(self.settings.get(<span class="hljs-string"><span class="hljs-string">"Facebook"</span></span>, <span class="hljs-string"><span class="hljs-string">"email"</span></span>)) fbAuthPage.fillPassword(self.settings.get(<span class="hljs-string"><span class="hljs-string">"Facebook"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>)) fbConfirmPage = fbAuthPage.login() lobbyPage = fbConfirmPage.confirm()</code> </pre> <br><br>  As you can guess from the code, the test first loads the AuthPage page, then switches from it to fbAuthPage, fills in the necessary data and submits the form, confirms the user and sends it to the lobbyPage.  In other words, the test goes through the pages and performs clear with t.  operations tester, leaving the implementation of operations inside pages.  Those.  tests are a fairly simple group, and in order to learn how to write them, we need only learn how to write pages.  It is also quite simple. <br><br><h2>  We write pages </h2><br>  <i>The page</i> is a Jython screen view of the / activity / application page.  Technically, this is a class with fields and methods that govern these fields.  In the most difficult case, it looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FbAuthPage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Page)</span></span></span><span class="hljs-class">:</span></span> email = ResourceLoader([Resource.fbEmailFieldiOS, Resource.fbEmailFieldiOS_ru]) password = ResourceLoader([Resource.fbPasswordFieldiOS, Resource.fbPasswordFieldiOS_ru]) actionLogin = ResourceLoader([Resource.fbLoginBtniOS, Resource.fbLoginBtniOS_ru]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, box, settings)</span></span></span><span class="hljs-function">:</span></span> super(FbAuthPage, self).__init__(box, settings) self.email = self.box self.password = self.box self.actionLogin = self.box self.settings = settings self.waitPageLoad() self.checkIfLoaded([<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span><span class="hljs-function">:</span></span> self.email.click() self.waitPageLoad() self.inputText(text)</code> </pre><br><br>  This snippet uses most of Imagrium's delicacies, so let's discuss this snippet with details in detail.  framework capabilities. <br><br><h3>  Field Definition and Localization </h3><br>  Let's start with this line: <br><br><pre> <code class="python hljs"> email = ResourceLoader([Resource.fbEmailFieldiOS, Resource.fbEmailFieldiOS_ru])</code> </pre><br><br>  This fragment links the <i>email</i> page field with a graphic resource (image or line).  In this case, we associate the field with two resources at once (for the English and Russian locales).  When a page asks for an <i>email</i> field, the system tries to find one of these images and returns the area associated with the first successfully found image. <br><br>  According to our agreements, we store graphic resources in the <i>res</i> directory.  To set a resource, we must pass to the <i>ResourceLoader the</i> path to the resource or text, for example: <br><br><pre> <code class="python hljs"> email = ResourceLoader(<span class="hljs-string"><span class="hljs-string">"res/pages/ios/fb_auth/fbEmailFieldiOS.png"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>)</code> </pre><br><br>  but for the flexibility and convenience of maintaining the code, we store the paths to resources in the variables of the <i>src.core.r.Resource</i> object. <br><br>  <b>Total</b> : To manage a graphic item or line, you need to add a <i>ResourceLoader</i> declaration to the corresponding page. <br><br><h3>  Page initialization and field validation </h3><br>  The declaration of the field only sets the connection we need to use it, we need to refer to the field.  Such calls occur either when using any operation on the field (for example, dragging or clicking), or when the page is initialized.  The last operation is very important, because firstly it allows you to set the search area for the fields (we usually want to narrow it to the emulator boundaries) and check that we are on the page we want.  Therefore, let's take a closer look at what happens in the page initialization code using the example of <i>FbAuthPage</i> . <br><br>  First, we must always inherit the page from the <i>src.core.page.Page</i> class <i>.</i> <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FbAuthPage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Page)</span></span></span><span class="hljs-class">:</span></span></code> </pre><br>  as it gives us access to common methods of managing pages, for example, the method of waiting for full page load.  We also need to start the parent constructor when the page is initialized. <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, box, settings)</span></span></span><span class="hljs-function">:</span></span> super(FbAuthPage, self).__init__(box, settings)</code> </pre><br><br>  and the last feature of initialization is the ability to set a search field for the field, usually it is the area occupied by the emulator, and to search only in it, we write <br><pre> <code class="python hljs"> self.email = self.box self.password = self.box</code> </pre><br>  The <i>box</i> parameter is initially considered after creating the emulator snapshot and before launching the application for the first time, and then it is passed from page to page.  In more detail, two lines (vertical and horizontal on the emulator) from, for example, <i>res / pages / android / hdpi / core</i> , are <i>taken</i> , the system detects them on the page and builds an emulator area on them.  If we do not assign fields to the fields, the system searches for the entire screen (which usually affects the quality of the search), although this is necessary for some exotic things, for example, to press a hardware button on the emulator. <br><br>  Usually when we initialize a page, we check that we have the fields we need on it, and do it with this method: <br><pre> <code class="python hljs">self.checkIfLoaded([<span class="hljs-string"><span class="hljs-string">'email'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>])</code> </pre><br><br>  Some fields may not be visible during initialization, specify only visible.  If the page cannot find the fields, it sends an <i>AssertionError</i> exception that causes the test to fail and also reports the details to stdout. <br><br>  <b>Total</b> : If you want the system to search for fields within the emulator, assign them <i>self.box</i> .  Use page field validation with <i>self.checkIfLoaded ()</i> . <br><br><h3>  What can you do with fields </h3><br>  In our <i>FbAuthPage</i> sample code <i>,</i> we used the <i>click ()</i> method on the <i>email</i> field: <br><pre> <code class="python hljs">self.email.click()</code> </pre><br><br>  Each field is actually represented by a <a href="http://doc.sikuli.org/match.html">Match</a> object from Sikuli, so you can do everything with it that is written in the corresponding spec (drag, click, pinch, release, enter text, etc.). <br><br><h3>  Configuration access </h3><br>  Configuration is a very important part of running tests.  In particular, it determines under which platform we want to run tests, which tests, for which application.  Also in the configuration, you can register your variables and use them in tests or in the code pages. <br><br>  In our example class <i>FbAuthPage,</i> you can see the line: <br><pre> <code class="python hljs">self.settings = settings</code> </pre><br><br>  Here, the <i>settings</i> attribute is a sample <a href="https://docs.python.org/2/library/configparser.html">ConfigParser</a> associated with the current configuration file, so you can use all the methods from the official spec when working with it.  Imagrium adds <i>settings</i> to each test, so you can use the configuration directly in the tests. <br><br>  Example of working with the configuration: <br><br><pre> <code class="python hljs">self.settings.get(<span class="hljs-string"><span class="hljs-string">"Facebook"</span></span>, <span class="hljs-string"><span class="hljs-string">"email"</span></span>)</code> </pre><br><br><h3>  OS dependent methods </h3><br>  For example, sometimes you have to press the back button (specific to Android) or enter text (in Sikuli, this is not possible to do simply because it enters the text asynchronously, which usually leads to the fact that some of the characters do not have time to add).  To provide these features, classes were introduced that give your page OS-specific functionality. <br><br>  In practice, it looks like this (multiple inheritance!): <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FbAuthPageiOS</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FbAuthPage, iOSPage)</span></span></span><span class="hljs-class">:</span></span></code> </pre><br><br>  or so: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FbAuthPageAndroidHdpi</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FbAuthPage, AndroidPage)</span></span></span><span class="hljs-class">:</span></span></code> </pre><br><br>  <i>Total:</i> If we want OS-specific functions, we inherit from the required class. <br><br><h3>  Page organization </h3><br>  In the previous sections, we first talked about <i>FbAuthPage</i> , and then peredkachili on <i>FbAuthPageiOS</i> and <i>FbAuthPageAndroidHdpi</i> .  In this section, we will discuss what these classes are, why they are needed, and how they are related to <i>FbAuthPage</i> . <br><br>  Initially, we said that we want to run the same test on different platforms, but even within the same platform, we can make serious differences in the presentation of graphic resources.  For example, resources under hdpi may differ from xhdpi, resources under iOS may differ from those under Android.  At the same time <u>, only resources differ</u> , and the methods of working with them remain the same (or almost the same, adjusted for guidelines).  It was necessary to come up with some solution to redefine resources for different platforms, and we used standard inheritance.  In other words, our pages can be divided into two levels - <i>general</i> and <i>platform-specific</i> . <br><br><ol><li>  The general page contains the general logic of working with resources on the page.  In our example, this is <i>FbAuthPage</i> .  These methods do the same operations for both iOS and Android. </li><li>  Platform-specific pages usually contain only resources that need to redefine the resources of the common page.  They look something like this: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FbAuthPageAndroidHdpi</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FbAuthPage, AndroidPage)</span></span></span><span class="hljs-class">:</span></span> email = ResourceLoader([Resource.fbEmailFieldAndroidHdpi, Resource.fbEmailFieldAndroidHdpi_ru])</code> </pre><br></li></ol><br><br>  With such a variety of pages, I would not want the test or the page to decide which pages to load.  In Imagrium, it is the responsibility of the system to read the configuration and load the necessary pages when the page calls the <i>load ()</i> method.  In order for the system to load the correct classes, these classes must be specifically named.  In details: <br><br><ul><li>  iOS pages should be called <b>[shared page] + ‚ÄúiOS‚Äù</b> , for example: <i>FbAuthPageiOS</i> .  Additionally, this page should be an <i>FbAuthPage</i> heir. <br></li><li>  Android pages have more parameters - this is the OS version and density.  First, the system tries to load the class <b>[common page] + "_" + "[major version]" + "_" + "[minor version]" + "_" + "Android" + "[density]"</b> .  For example: <i>FbAuthPage_4_2_AndroidHdpi</i> .  If she did not find such a class, then she tries to load: <b>[common page] + ‚ÄúAndroid‚Äù + ‚Äú[density]‚Äù</b> .  For example: <i>FbAuthPageAndroidHdpi</i> . <br></li></ul><br><br>  If the class is still not found, the system returns an AssertionError with the appropriate description, which fails the test. <br><br>  In practice, it looks like this: <br><br>  In the test we write <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">fbAuthPage</span></span> = authPage.signUpFb()</code> </pre><br><br>  In the AuthPage general page there is a method: <br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signUpFb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.actionAgreeTermsBtniOS.click() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.actionSignUpFb.click() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FbAuthPage.load(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.box, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.settings)</code> </pre><br><br>  This method calls the <i>load ()</i> method, during which the system decides which page to call (for example, <i>FbAuthPageiOS</i> or <i>FbAuthPageAndroidHdpi</i> ). <br><br>  <b>Total</b> : We implement the general logic of the page, and then, if another density / platform requires it, we add the modified resources to the appropriate classes of pages.  The configuration system decides which page to trigger in the appropriate case. <br><br><h2>  How to run tests </h2><br>  It is assumed that you are cloning a project from Github, open PyDev in Eclipse, delete everything that is superfluous, add everything you need, and then want to test it.  For testing, you need to install everything that is needed for the framework to work (see installation instructions), and then run from the project root: <br><br><pre> <code class="hljs">ant</code> </pre><br><br>  In a little more detail, this call runs <i>run.py</i> with a specific configuration file as the only input parameter (for example, <i>conf / android_settings.conf</i> ) as well as prescribing the necessary paths in the PATH and CLASSPATH variables, and then creates a page with test results. <br><br>  In the general case, when testing, the emulator is started, the application is reinstalled on it, after which a snapshot of the emulator is created.  Then, for each test, the same snapshot is launched, on which the next test passes. <br><br><h1>  Conclusion </h1><br>  We recommend using Imagrium when you need to test multiple platforms at once or when you do not have easy access to the application code to add locators for GUI elements.  The most quickly learn the framework for those who programmed in Python, although the simplicity of the syntax of the language should facilitate the rapid learning to work with the tool.  In this article, only the basics of working with Imagrium were given, I will explain in detail in subsequent articles if this article is interesting to the community, in detail about the configuration of the framework and its capabilities (for example, multi-user scripting).  You can also read the official documentation on the Github project page and see <a href="https://github.com/azoft-dev-team/imagrium/wiki/Tutorial:-The-Hello,-World!-Project">this Hello, World example</a> . </div><p>Source: <a href="https://habr.com/ru/post/232525/">https://habr.com/ru/post/232525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232513/index.html">Manipulations with objects in photos in 3D</a></li>
<li><a href="../232515/index.html">See the invisible</a></li>
<li><a href="../232519/index.html">Sensor Hug helps to track water consumption throughout the day</a></li>
<li><a href="../232521/index.html">What is your procrastinator?</a></li>
<li><a href="../232523/index.html">Google's HTML5 Web Designer Update</a></li>
<li><a href="../232527/index.html">Efficient backup scripts</a></li>
<li><a href="../232531/index.html">Hack mobile online game? Easy!.</a></li>
<li><a href="../232533/index.html">The second meeting of the community JUG.EKB</a></li>
<li><a href="../232535/index.html">Looking for an ergonomic workplace</a></li>
<li><a href="../232537/index.html">How we nontrivially chose a place for coworking in Moscow and how we arranged everything inside</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>