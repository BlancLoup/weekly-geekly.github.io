<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transformation of development and delivery processes for legacy applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our team is responsible for the operation and development of a large corporate product. 
 In early 2017, having rested from a major introduction and r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Transformation of development and delivery processes for legacy applications</h1><div class="post__text post__text-html js-mediator-article"><p>  Our team is responsible for the operation and development of a large corporate product. <br>  In early 2017, having rested from a major introduction and re-reading "lessons learned", we firmly decided to revise the process of developing and delivering our application.  We were worried about the low speed and quality of delivery, not allowing us to provide the level of service that our customers expect from us. </p><br><p>  It was time to move from words to deeds - to change processes. </p><br><p>  This article will briefly describe what we started with, what we did, what the situation is now, what difficulties we have encountered, what we had to leave behind brackets, what we are planning to do. </p><a name="habracut"></a><br><h1 id="nachalo">  Start </h1><br><h3 id="nemnogo-o-sisteme">  Little about the system </h3><br><p>  The application is a classic example of a monolithic enterprise application of the "architectural spill of the 2000s": </p><br><ul><li>  Operated and developed over 15 years. </li><li>  It is a set of one and a half dozen WinForms, windows services and ASP .Net applications tied to a single MS SQL database. </li><li>  Codebase size: ~ 1MLOC for C #, ~ 9000 database objects.  Much of the business logic is executed on the database side. </li><li>  The application consists of ~ 250 + solutions for creating a win / web client (one solution per group of related forms).  This is the legacy of the previous development process and client architecture. </li><li>  The application supports several types of processes (clients) by changing the internal configuration: setting up processes, authorities, flexible fields, etc., in the system database configuration tables.  At the same time, the application code base is the same for all clients. </li><li>  The application is deployed and supported on 25+ sites (each site is an independent copy of the system) and serves a total of several thousand end users in different time zones. </li></ul><br><h3 id="process-dostavki-do-transformacii">  Delivery process before transformation </h3><br><ol><li>  development and assembly of the finished application and its components is carried out by the contracting organization. </li><li>  the code was stored on the side of the contracting organization (local version of MS TFS).  The code is transmitted to the customer on a monthly basis as an archive of the current version of the main repository branch. </li><li>  Delivery was carried out by delivery of "delta updates": for the application (set of dll, exe, etc.) and database components (set of sql scripts create / alter).  The application was assembled and the delta packages were prepared by the contractor. </li><li>  the deployment process was supported by the transport system, the changes were applied automatically. </li></ol><br><p>  Delivery is carried out in the framework of monthly releases (as it is arranged with us, I told earlier <a href="https://habr.com/post/321664/">here</a> ). </p><br><h3 id="suschestvovavshie-problemy">  Existing problems </h3><br><p>  <em>Lack of control</em> </p><br><ul><li>  despite the formal possession of the code, the actual assembly of the application by the customer was impossible. </li><li>  as a result, it is impossible to make sure that the code transmitted to the customer is working. </li><li>  changes in the code are not transparent to the customer.  It is not possible to compare the requested and actual changes in the product. </li><li>  code analysis is difficult for SQL, and impossible for C # components </li></ul><br><p>  <em>Complexity and mistakes</em> </p><br><ul><li>  Delta package preparation is a time-consuming procedure to develop, a source of errors and certain project costs. </li><li>  Deploying an application from the delta package set requires tracking the order of the packages.  Error in breaking package order is a major deployment problem and the source of a significant portion of incidents. </li><li>  Regressions occur regularly: errors that seem to have already repaired and rolled out corrections to the product appeared again. </li></ul><br><p>  <em>Restrictions</em> </p><br><ul><li>  the ability to restore the state of the system at the moment in the past (roll back changes) is virtually absent. </li><li>  the ability to effectively scale development resources and early testing by attracting the customer‚Äôs staff is virtually non-existent. </li></ul><br><h3 id="ozhidaemye-rezultaty">  Expected results </h3><br><p>  At the beginning of the project, we set clear goals to solve the problems outlined above. </p><br><ul><li>  Move the code repository under the control of the customer </li><li>  Move application build process to customer side </li><li>  Modify the change propagation process by abandoning the "delta of change" in favor of a full update. </li></ul><br><p>  Additionally, using the solutions obtained when achieving the first two goals, we expected: </p><br><ul><li>  Improve the technical quality of the solutions obtained by monitoring the code </li><li>  Increase the involvement and convenience of testing through the provision of self-service deployment. </li></ul><br><h1 id="etapy-bolshogo-puti">  Stages of the big way </h1><br><h3 id="analiz-tekuschego-sostoyaniya-processov-razrabotki">  Analysis of the current state of development processes </h3><br><p>  First step: analyze the existing contractor development process.  This helped plan changes so that, if possible, do not interrupt work. </p><br><p>  Unfortunately, familiarity with the development process showed that, in the understanding of the present-day IT industry, there was no process. </p><br><ol><li>  The database code and business logic to it was not maintained in the repository up to date.  The main reason: the lack of tools that implement the assembly of the code in the repository and the deployment of the result.  So, the code in the repository is just documentation. </li><li>  The "real" version of the database code is in a common "development database", which has dozens of developers. </li><li>  The client application code (C #, ASP.NET) was maintained in the repository, but the quality and timeliness of the commit is not guaranteed. </li><li>  The assembly of components (not the entire application) was carried out at developer stations.  It is not entirely clear how the code was updated before the build.  The assembled component was laid out on a shared shared folder.  From there, the "delta package" was formed for the customer. </li><li>  The complete lack of practice of branches development.  By indirect evidence, we suspected this a long time ago - but after immersion in the process everything became obvious. </li></ol><br><h3 id="perehod-na-novyy-repozitoriy-i-sistemu-kontrolya-versiy">  Switch to a new repository and version control system </h3><br><p>  Dependence on MS platforms and corporate standards predetermined the choice of development environment - Team Foundation Server. <br>  However, by the time we started the project directly (April 2017), a version of Visual Studio Team Services had just been released.  The product seemed very interesting, was designated as a strategic direction for MS, offered git repositories, build and deployment for on-prem and cloud. </p><br><p>  Corporate on-prem TFS was lagging behind the version and functionality of VSTS, migration to the new version was only in the process of discussion.  We did not want to wait.  We decided to go straight to VSTS, as it reduced our overhead costs for supporting the platform and gave us full control over how and what we were doing. </p><br><p>  At the time of the change, the development team had experience with TFSVC, the application code was stored in such a repository.  On the other hand, GIT has actually become a standard for the IT community long ago ‚Äî the customer and third-party consultants recommended switching to this system. <br>  We wanted the development team to be involved in making a decision on a new version control system, and made an informed choice. </p><br><p>  We deployed two projects in VSTS with different repositories - TFSVC and GIT.  A set of scenarios were identified that were proposed to test and evaluate the usability of each system. </p><br><p>  Among the evaluated scenarios were: </p><br><ul><li>  Create a merge of branches </li><li>  Organization of joint work (on the same or different branches) </li><li>  Operations on chains of changes (commit, cancel) </li><li>  Integration of third-party changes </li><li>  The ability to continue to work when the server is unavailable. </li></ul><br><p>  As a result, as expected, GIT was chosen, and so far no one regretted it. </p><br><p>  We started using GitFlow as a process.  This process provided enough control over the changes and allowed delivery of releases, as we have become accustomed to. </p><br><ol><li>  We defended the develop branch with a policy that required all changes to go through pull requests. </li><li> We try to adhere to the practice of "one ticket - one pull-requack".  Changes from different tickets are never combined within a single change.  We try to do our utmost testing on the feature branch to avoid the situation with corrections in subsequent pull-requests. </li><li>  When you merge into develop, all changes are merged into one commit (squash). </li><li>  Release branches are created from develop. </li><li>  If necessary, the latest changes can be added to the release branch selectively (cherry-pick) or all (rebase).  We do not fix the fix directly in the release branch. </li><li>  After deploying the last release to the product, it goes to the master via push force (only a few people have this right) </li></ol><br><h3 id="avtomatizaciya-sborki-produkta">  Product assembly automation </h3><br><p>  The application consisted of a large number of assemblies, hundreds of solutions.  As it turned out during the audit process, all this was collected separately and "manually." <br>  In the first stage, we decided not to redo everything ‚Äúfrom scratch‚Äù (so as not to stop the existing delivery), but to ‚Äúwrap‚Äù the assembly into the msbuild script set ‚Äî one script per component. <br>  Thus, we quickly obtained scenarios that carried out all the necessary intermediate artifacts, and in the end - the finished product. </p><br><p>  A separate story is a database project.  Unfortunately, the system contains several CLR components that were not well structured.  Dependencies do not allow a simple database deployment.  At the moment, this is solved by the pre-deployment script. <br>  In addition, due to the uneven system landscape (SQL Server versions 2008 and 2014 were installed at different points), the project base assembly for .Net versions 2.0 and 4.0 had to be organized. </p><br><p>  After all the scripts were ready and tested, they were used in the build VSTS scripts. </p><br><p>  Immediately before the start of the assembly, the versions of all products were updated to a common standard number, including the pass-through build number.  The same number was saved in the post-deployment script.  Thus, all the components: the database and all client applications ‚Äî came out consistent and equally numbered. </p><br><h3 id="razvertyvaniya-na-testovyy-stend">  Deploying to a test bench </h3><br><p>  Once the primary version of the build process has been completed, we proceed to the preparation of the deployment scenario. </p><br><p>  As expected, the database has caused the most trouble. </p><br><p>  Deploying on top of a copy of the real database revealed many conflicts between the build and the state of real systems: </p><br><ul><li>  Unmatched versions in GIT and in the real system </li><li>  DB schemas owned by users that were planned to be deleted. </li></ul><br><h3 id="stabilizaciya-processa-razrabotki">  Stabilization of the development process </h3><br><p>  This, of course, is strange to talk about and, even more so, to write here, but the most serious change for developers was the introduction of the principle ‚Äúif this is not in git, this does not exist‚Äù.  Previously, the code was commited "for reporting to the customer".  Now - without this, it is impossible to deliver anything. </p><br><p>  The hardest thing was with the database code.  After moving to the database deployment from the repository, through the assembly and deployment using sqlpackage, the "delta" approach was replaced by the "desired state" approach.  Packages were a thing of the past, everything had to be deployed automatically. </p><br><p>  But!  Until the full transition to the new deployment process, it was still necessary to deliver the changes.  And it was necessary to do it in the old manner - "delta updates". </p><br><p>  We were faced with the task of ensuring full and constant consistency of the state of the system upon delivery of delta packages, and the contents of the repository. </p><br><p>  To do this, we organized the following process: </p><br><ol><li>  Regularly, the code from the repository was collected and deployed to an empty ‚Äúmodel‚Äù database. </li><li>  On the basis of the ‚Äúmodel‚Äù base, a special autotest was prepared.  For each object of the "model" database, checksums were calculated.  The autotest contains all of these checksums and at startup it calculates the checksums of the corresponding objects of the "checked" database.  Any discrepancy in the composition of the objects or their checksums leads to a drop in the test. </li><li>  The "falling" test automatically prohibited the transfer of packets from the test environment further along the landscape.  Such integration has already been implemented in the previous transport system. </li></ol><br><p>  Thus, with the help of automatic control, it was possible to relatively quickly bring the product database code to git in the current state and maintain it without additional efforts from the project team.  At the same time, the developers began to get used to the need to correctly and promptly commit the code to the repository. </p><br><h3 id="razvertyvanie-produkta-na-okruzheniya-integracionnyh-testov">  Product deployment to integration test environments </h3><br><p>  After the previous stage was completed, we proceeded directly to deploying the application on a test environment.  We have completely stopped the application of delta packages to test systems and switched to automatic deployment using VSTS. </p><br><p>  From that moment, the whole team began to receive the first fruits from the efforts expended earlier: the deployment took place without any additional efforts.  The custom code is automatically built, deployed, and tested. </p><br><p>  Unfortunately, as we understood later, the "alignment of the repository" carried out led to the fact that we had a version of the stably supported version of "develop", but the version of "production" was also not available.  And so beyond the test environment - there was nothing to go to QAS and PRD with. </p><br><p>  The application code on the database side could be compared with the productive one and understand the differences.  There was nothing to compare client applications with - there was only the actual productive version in the form of a set of executable files, and from which they were assembled reliably it was impossible to say. </p><br><h3 id="testirovanie-produkta-kak-rezultata-avtomaticheskoy-sborki">  Product testing as a result of automatic build </h3><br><p>  After changing the approach to the assembly, the product had to be subjected to a large regression test.  It was necessary to make sure that the application is running and nothing is lost. <br>  When testing just got easier with the functionality placed on the side of the database.  Fortunately, we had a significant set of autotests, covering critical areas. </p><br><p>  But there were no tests for C # - so everything was checked by hand.  It was a significant amount of work, and the check took some time. </p><br><h3 id="pryzhok-very---pilotnoe-razvertyvanie-na-produktiv">  "Leap of Faith" - pilot deployment to productive </h3><br><p>  Despite the testing, deploying to production was the first time scary. </p><br><p>  We were lucky - we had just scheduled the next deployment of the system at the new site.  And we decided to use this chance for a pilot deployment. <br>  Users did not see, it was easy to fix possible errors of the assembly, the real productive work had not yet begun. </p><br><p>  We deployed the system, and for several weeks it was in the mode of pre-productive use (low load, a certain pattern of use, which can be skipped in production).  During this time, several defects were revealed during testing.  They were corrected as they were found, and the new version immediately rolled out for checking. </p><br><p>  After the official launch and the week of post-launch support, we announced that this is the first copy assembled and delivered "in a new way". </p><br><p>  This version of the assembly became the first stable version of the master branch, it was hung with holiday tags "fisrt_deployment" (we didn‚Äôt order the badges with the commit hash, though). </p><br><h3 id="masshtabirovanie-razvertyvaniya-na-ves-produktivnyy-landshaft">  Scale deployment across the entire production landscape </h3><br><p>  As James Bond used to say: "the second time is much easier."  After the success of the pilot deployment, we quickly connected the remaining instances of systems of a similar type. </p><br><p>  But the system has several types of use - one functionality can be used for one type, and not used in other cases.  Accordingly, the functionality tested on the implementation of the first type did not necessarily guarantee success for other cases. </p><br><p>  To test the functionality of the remaining types of use, we began to use active projects that were under development.  The idea was similar and the first deployment - we began to use automatic assemblies, "slipping" them to users along with the project functionality.  Thus, users, working with the "project" version of the product at the same time tested and the old functionality. </p><br><p>  Scaling itself revealed unexpected technical problems: </p><br><p>  <em>Non-uniform system landscape</em> <br>  In addition to directly deploying the application, we first had to take care that everything was the same everywhere - .Net versions, Powershell, and modules.  It all took a fair amount of time. </p><br><p>  <em>Network connection</em> <br>  At some sites, the network connection simply did not allow all the components of the assembly to be pumped.  There were timeouts, damage in the process of transfer.  A lot of things checked and tried - not very successfully. </p><br><p>  I had to dwell on the following solution: the build script was finalized so that all the results were packed into one large archive, which was then cut into small fragments (2 MB each).  We finalized the deployment scenario to eliminate concurrency when downloading artifacts, took all 2 megabyte fragments and restored from them what is already possible to deploy. </p><br><p>  <em>Conflict with antivirus</em> <br>  Another strange problem we are facing is antivirus software conflict and one of the deployment steps: when any ‚Äúsuspicious‚Äù files, such as .js, .dll, are extracted from artifact archives, the antivirus starts to look at them closely.  And the strangest thing is that the antivirus starts to rush to the file even before the end of the unpacking and the unpacking process drops with the message ‚Äúthe file is busy by another process‚Äù.  While we are struggling with this, excluding the local folder with artifacts from scanning is not very good, but nothing else has been invented. </p><br><h3 id="uluchshenie-processov">  Process improvement </h3><br><p>  After stabilization of the assembly and deployment processes, we switched to ‚Äúsewing shoes for shoemakers‚Äù - improving internal processes. </p><br><ul><li>  built the basic integration of the corporate IT support system (service-now.com) with VSTS for transferring tickets in the form of Work Items.  We have corrected the merge policy in develop - now we will definitely require the presence of a connected ticket. </li><li>  CI connected to all feature branches.  As soon as the code change is published - the version is automatically compiled and ready for testing. </li><li>  on the side of the contracting organization, they deployed a large set of test benches and organized "self-service" deployment of the assemblies for internal testing </li><li>  on the customer side, several test benches were also deployed - for each type of system.  Any developer or employee of a department can initiate a deployment, the deployment permission is given by the employee responsible for the type of system and coordinating testing. </li><li>  organized the infrastructure for working on projects: special naming of project branches, CI / CD for dedicated instances of the system with which developers, analysts and end business users work </li><li>  consolidated some checks in the form of pull requests policies (more in a <a href="https://habr.com/post/428660/">separate article</a> ) </li><li>  integrated storage of auto-tests into a common repository (previously tests were stored separately) and build and deploy processes.  Now the product build contains code and tests ‚Äî both for the development branches and for the product as a whole. </li><li>  as an experiment, VSTS agents were installed on the local computers of analysts who are engaged in testing and deploying the client part there, which must be tested for assembly. </li></ul><br><h1 id="itogi">  Results </h1><br><h3 id="tekuschaya-situaciya">  Current situation </h3><br><ul><li>  All application code is stored and maintained in MS VisualStudio Team Services (more recently, Azure Devops) managed by the client.  Version Control Systems - GIT </li><li>  All changes are completely transparent and linked to service tickets (incidents / changes) </li><li>  Due to the transition to git / GitFlow, parallel development has been greatly simplified. </li><li>  A code review procedure was introduced with the participation of a customer representative. </li><li>  The application is built by the CI system.  Full assembly is carried out for both the main and feature branches, which allows you to organize early testing. </li><li>  Deploying the application to all target nodes is based on scripts.  Gradually, the configuration steps for the base components and applications are added to the application deployment steps. </li><li>  Employees of the customer‚Äôs IT department can initiate the deployment of assemblies (final or intermediate) to test environments - for testing or early familiarization.  Business users also have access to test environments. </li><li>  we still adhere to the main release cycles of 1 month.  Although in the last month we are rolling out something practical weekly. </li><li>  there was a process of "experimental" version rollout on some sites. </li></ul><br><h3 id="vremya-po-etapam">  Time by stages </h3><br><table><thead><tr><th>  No </th><th>  Stage description </th><th>  Duration </th></tr></thead><tbody><tr><td>  one </td><td>  From the beginning of the project - to full control over the code, the process of assembly and delivery to the test environment </td><td>  6 months </td></tr><tr><td>  2 </td><td>  From the first deployment to the test environment - to the first pilot release on production </td><td>  3 months </td></tr><tr><td>  3 </td><td>  From pilot deployment to production ‚Äî until first release for all instances </td><td>  5 months </td></tr></tbody></table><br><p>  Total duration - 14 months </p><br><p>  The duration, especially at the final stage, was largely determined by the coordination, and the agreed calendar of system maintenance. </p><br><h3 id="trudozatraty">  Labor costs </h3><br><p>  The total cost of the involved employees of the customer and the contractor for all work related to the change is approximately 250 people * days. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427111/">https://habr.com/ru/post/427111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427097/index.html">Mobile application helps to detect depression and other psychological problems at the earliest stages.</a></li>
<li><a href="../427101/index.html">Google plans to charge mobile device manufacturers up to $ 40 for each device sold.</a></li>
<li><a href="../427105/index.html">Learn to learn: continuing education is the key to competitiveness in the digital economy</a></li>
<li><a href="../427107/index.html">Parsim X12 "on the knee"</a></li>
<li><a href="../427109/index.html">Space Piracy - Deceitful Delta-V and Hydrogen Stealth Steamboats - Part 1</a></li>
<li><a href="../427113/index.html">Programmable valve arrays: how will they help 5G networks</a></li>
<li><a href="../427117/index.html">Asterisk conference rooms</a></li>
<li><a href="../427123/index.html">Turing game</a></li>
<li><a href="../427129/index.html">Threat Intelligence - a modern approach to ensuring information security</a></li>
<li><a href="../427131/index.html">Acquaintance with ‚ÄúAudiomania‚Äù: 15 thematic materials about production, design, offices and business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>