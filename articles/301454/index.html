<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kino: communication frawemork on NetMQ. Short description</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About 8 years ago I started working in a team that developed one service. The interface of the service was quite simple, only 4 methods, and it perfor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kino: communication frawemork on NetMQ. Short description</h1><div class="post__text post__text-html js-mediator-article"><p>  About 8 years ago I started working in a team that developed one service.  The interface of the service was quite simple, only 4 methods, and it performed a single task.  During all this time, the code was constantly changing: new business rules and restrictions were implemented, versioning was added.  At one point, the front-end needed a very small functionality that was buried deep in service.  The implementation of the necessary function was developed as a component and did not pose any problems to give access to it from the service through an additional method ... Except for one: the logical coherence of the service methods was violated, that is, its "insides" began to become "externals". </p><br><p>  The problem could be solved if we transform all these small internal components, to which external access was required, into separate services.  In this case, the front-end could gain access to their functionality;  the main service would become more compact and its role was reduced to orchestration of calls. </p><br><p>  We used WCF to build services.  Deploying the service in 50 lines of code on WCF, at least on 3-4 servers, with load-balancer, new URLs and other bells and whistles, seemed not a good idea.  And I wanted some kind of lightness, perspective ... </p><br><p>  A few years later, I participated in another project at Workflow Foundation.  Looking at what worked in the XAML editor, I thought: ‚ÄúWhy not imagine the whole workflow as a sequence of messages‚Äù? </p><a name="habracut"></a><br><h3>  Kino tests </h3><br><p>  The search for existing solutions, to be honest, I did not.  At that time (4-5 years ago) little was known about <em>‚ÄúOrleans‚Äù</em> , and I learned about <em>Akka</em> after the start of cycling.  On the one hand, this is bad, unworthy of a professional developer and all that.  On the other hand, something new could have turned out ... How good or bad everything turned out, a respected reader can judge. </p><br><p>  So, I started creating the <strong>kino</strong> : actor-like communication framework on <strong>NetMQ</strong> .  The suffix "-like" because classical actors have a hierarchical organization, supervisors, they are stateful and, in general, they have a whole mathematical model there ... Everything is simpler, but, nevertheless, we will have actors too. </p><br><h3>  In short, what is what? </h3><br><p>  The main means of communication in <em>kino</em> is the message.  Each message has a version and a type, which are used to find the corresponding handler.  There is a slight deviation from the rule, but for now let's not talk about it. </p><br><p>  Actors ( <em>Actors</em> ) - the main consumers and producers of messages.  <em>Actor</em> announces its interface by specifying the type and version of the message that it can receive.  There is another extras member, <em>MessageHub</em> , which can also receive and send messages.  However, there are certain differences between them.  <em>Actor</em> should be considered as a service: it can only respond when it receives an incoming message.  <em>MessageHub</em> is a client that can send a message and (try) receive a reply message if necessary.  So, most often, the initial message is sent via <em>MessageHub</em> and processed by one or more <em>Actors</em> . </p><br><p>  To search for recipients of messages, <em>MessageRouter is</em> required.  It stores the routing table ‚Äî version matching (Version) and message type (Identity) with a list of <em>Actors</em> that can process it.  For one process, one <em>MessageRouter is</em> enough. </p><br><p>  To go beyond one process / host, we need to gain knowledge about the outside world, that is, about the other <em>MessageRouters</em> and their routing tables.  The source for this knowledge is the <em>Rendezvous</em> service.  This is the only well-known address that must be configured for the <em>kino-</em> based application.  <em>Rendezvous</em> accepts from everyone and distributes to all connected <em>MessageRouters the</em> information about adding new and removing nonexistent routes, <em>ping the</em> established connections.  <em>Rendezvous</em> service forms a single network of <em>kino</em> components. </p><br><h3>  Also, but in more detail </h3><br><p>  <strong>1. Message</strong> </p><br><p>  This is a typical message that you can send a walk on the <em>kino</em> network: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyMessage</span></span> : <span class="hljs-title"><span class="hljs-title">Payload</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] MessageIdentity = <span class="hljs-string"><span class="hljs-string">"NAMESPACE.MYMESSAGE"</span></span>.GetBytes(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] MessageVersion = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span>.GetBytes(); <span class="hljs-comment"><span class="hljs-comment">//    , .. ,       public override byte[] Version =&gt; MessageVersion; public override byte[] Identity =&gt; MessageIdentity; }</span></span></code> </pre> <br><p>  There are 3 distribution patterns (Distribution Pattern) supported: <em>unicast</em> , <em>broadcast</em> and <em>direct</em> .  In the first case, the message is sent to only one processor registered in the network.  In the second - all. </p><br><pre> <code class="cs hljs">IPayload payload = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyMessage(); IMessage message = Message.Create(payload, DistributionPattern.Broadcast);</code> </pre> <br><p>  In the case of <em>direct distribution</em> , which can be particularly useful in testing, the message is sent to a specific <em>MessageRouter</em> 's: </p><br><pre> <code class="cs hljs">IMessage message = Message.CreateFlowStartMessage(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyMessage()); message.SetReceiverNode(receiverIdentity); <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br><p>  You can get to the data in the received message as follows: </p><br><pre> <code class="cs hljs">MyMessage payload = message.GetPayload&lt;MyMessage&gt;();</code> </pre> <br><p>  <strong>2. Actors</strong> </p><br><p>  To create your actor, you must inherit the class from <em>Actor</em> and implement at least one message handler method in it: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyMessageProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">Actor</span></span> { [MessageHandlerDefinition(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (MyMessage))] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActorResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMessageHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } [MessageHandlerDefinition(typeof (OtherMessage))] public Task&lt;IActorResult&gt; OtherMessageHandler(IMessage message) { //   } } ```cs      ,       *kino*.         ,     : ```cs public class LocalMessageProcessor : Actor { //      [MessageHandlerDefinition(typeof (LocalMessage), true)] public async Task&lt;IActorResult&gt; MyMessageHandler(IMessage message) { //   } }</span></span></code> </pre> <br><p>  The framework guarantees that the actor's handler method will receive only messages of the type that is declared.  The result returned can be one or more messages of any type, and with different <em>distribution patterns</em> .  That is, we can send a response to the initial sender and at the same time inform everyone else of something else: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyMessageProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">Actor</span></span> { [MessageHandlerDefinition(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (MyMessage))] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActorResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMessageHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IMessage message</span></span></span><span class="hljs-function">)</span></span> { MyMessage payload = message.GetPayload&lt;MyMessage&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UpdateDb(payload); IMessage response = Message.Create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseMessage(result)); IMessage notifyRequest = Message.Create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyMessage(result), DistributionPattern.Broadcast); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionResult(response, notifyRequest); } }</code> </pre> <br><p>  <strong>3. ActorHost</strong> </p><br><p>  We haven't talked about <em>ActorHost</em> yet.  This is a component that performs several functions: </p><br><ul><li>  stores references to handler methods of all registered <em>Actors</em> </li><li>  register handlers in <em>MessageRouter</em> </li><li>  accepts messages for processing from <em>MessageRouter</em> to <em>Actors</em> and sends responses back to the <em>MessageRouter</em> . </li></ul><br><p>  Calling handler methods in <em>ActorHost</em> occurs in a single thread (with the exception of asynchronous methods).  Therefore, <em>ActorHost</em> does not support multiple registrations of handlers of the same message.  If it is necessary to scale the same type of <em>Actor</em> within the same process, it is necessary to create a new <em>ActorHost</em> instance for each of them.  <em>ActorHostManager</em> assumes all these difficulties in choosing and creating <em>ActorHosts</em> : </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     MyActor IActor actor = new MyActor(); //  ,    ActorHost actorHostManager.AssignActor(actor); //  ,    actor = new MyActor(); // ,       MyActor actorHostManager.AssignActor(actor, ActorHostInstancePolicy.AlwaysCreateNew);</span></span></code> </pre> <br><p>  <strong>4. MessageHub</strong> </p><br><p>  Let's go back a little, how it all began.  And it began with the fact that there was a need to spread the code from one WCF-service to several components accessible on the network.  As a result, instead of calling hundreds of methods in one process, we got a certain flow of messages ( <em>message flow</em> ), which, in addition, travel to different servers.  However, the functionality and behavior for the end user of the service should ideally remain the same.  That is, if the client used to call the service method synchronously and expect to receive a response, then with all this <em>kino</em> , the client's work pattern should not change drastically.  It is necessary to determine from all this message flow what is the answer to the client and deliver it back. </p><br><p>  <em>MessageHub</em> is designed to solve this problem.  With it, you can send a message to the <em>kino</em> network, without waiting for an answer: </p><br><pre> <code class="cs hljs">IPayload payload = message.GetPayload&lt;MyMessage&gt;(); IMessage message = Message.CreateFlowStartMessage(payload); messageHub.SendOneWay(message);</code> </pre> <br><p>  And you can also specify that the sender expects a specific answer: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   IMessage request = Message.CreateFlowStartMessage(new StartMessage()); // ,         ICallbackPoint callbackPoint = CallbackPoint.Create&lt;ResultMessage&gt;(); //       using(IPromise promise = messageHub.EnqueueRequest(request, callbackPoint)) { if(promise.GetResponse().Wait(timeout)) { //    ResultMessage result = promise.GetResponse().Result.GetPayload&lt;ResultMessage&gt;(); } else { //  ‚Ä¶ } }</span></span></code> </pre> <br><p>  <strong>5. MessageRouter</strong> </p><br><p>  <em>MessageRouter</em> is a node on the <em>kino</em> network.  It connects other components, <em>ActorHosts</em> and <em>MessageHubs</em> , for messaging.  In turn, <em>MessageRouters</em> find their own kind and connect to each other using the <em>Rendezvous</em> service, thus forming a <em>kino</em> network. </p><br><p>  The <em>kino</em> uses the <a href="https://github.com/zeromq/netmq">NetMQ</a> library as a transport.  She was practically hammered into the framework with nails and it was not planned to use other transport. </p><br><p>  So, message routing.  It is carried out according to the following algorithms: </p><br><p>  ‚Ä¢ <em>Unicast</em> message: </p><br><pre> <code class="diff hljs">   ActorHost  MessageHub,             MessageRouter  ,              !</code> </pre> <br><p>  ‚Ä¢ <em>Broadcast</em> message: </p><br><pre> <code class="diff hljs">    ActorHosts  MessageHubs,            broadcast-     Actor   MessageRouter  ,                      !</code> </pre> <br><p>  ‚Ä¢ <em>Direct</em> message: </p><br><pre> <code class="diff hljs"> unicast-  MessageRouter  ,   ,   (ReceiverNode),              !  &lt; broadcast-&gt;</code> </pre> <br><p>  <strong>6. Rendezvous</strong> </p><br><p>  <em>Rendezvous</em> service is the only well-known service whose address must be configured for all nodes on the same <em>kino</em> network.  It performs the following functions: </p><br><ul><li>  <em>broadcast ‚Äî</em> redirect routing changes: adding new routes and deleting invalid routes. </li><li>  <em>broadcast</em> - <em>PING</em> distribution of messages for monitoring connected nodes, </li><li>  <em>broadcast ‚Äî</em> sends <em>PONG</em> reply messages from connected nodes. </li></ul><br><p>  If necessary, the <em>Rendezvous</em> service can be installed on a server cluster.  The leader selected by consensus is responsible for all of the above functions.  In the event of a "fall" of the cluster, the <em>kino</em> network will continue to work.  However, information about changes in routing will not be available.  When the <em>Rendezvous</em> service is restored, the nodes will receive a network configuration update. </p><br><p>  <strong>Open questions</strong> </p><br><ul><li>  Well, actually, to see something in the production.  Until it came to that ... </li><li>  How to work with messages of different <em>wire</em> format in the same network </li><li>  Possible problems with a large number of connections to the <em>Rendezvous</em> service, batch processing of <em>PONG</em> messages </li><li>  Combining multiple <em>kino</em> networks, that is, routing between nodes connected to different <em>Rendezvous</em> servers / clusters </li></ul><br><p>  The <em>kino</em> project on Github: <a href="https://github.com/iiwaasnet/kino">https://github.com/iiwaasnet/kino</a> <br>  Wiki: <a href="https://github.com/iiwaasnet/kino/wiki">https://github.com/iiwaasnet/kino/wiki</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/301454/">https://habr.com/ru/post/301454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301442/index.html">Running NodeJS-application on Android</a></li>
<li><a href="../301444/index.html">Internet information architecture</a></li>
<li><a href="../301446/index.html">Four words that cannot be (part 2)</a></li>
<li><a href="../301448/index.html">Qualitative methods in UX research: how to start talking to users</a></li>
<li><a href="../301452/index.html">Nginx + OpenSSL 1.0.2h = ALPN. Enable ALPN support on Ubuntu 14.04</a></li>
<li><a href="../301458/index.html">Overview of 5 platforms for creating websites</a></li>
<li><a href="../301460/index.html">How to find the nearest cafe, sight, free taxi through the eyes of a programmer</a></li>
<li><a href="../301464/index.html">Simply AWeSome - Amazon Web Services in Brief</a></li>
<li><a href="../301466/index.html">How to keep track of news in the C ++ world</a></li>
<li><a href="../301468/index.html">GUI to the tacacs daemon - TacacsGUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>