<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Outside: an introduction to libcds</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I give a brief overview of how to use the lock-free library of data structures libcds. I will not go into the implementation here, it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Outside: an introduction to libcds</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5de/b72/678/5deb72678cc8b803830b72e1f760c140.png" align="right"><br>  In this article, I give a brief overview of how to use the lock-free library of data structures libcds.  I will not go into the implementation here, it‚Äôs just a view <i>from the outside</i> , a view from the library user. <br><br>  The libcds library has its own point of view on many well-known data structures.  This is partly due to the target area ‚Äî the lock-free data structures are quite minimalist in the set of methods provided ‚Äî partly in the desire to go beyond the limitations and solutions of the standard STL library.  What came out of this is up to the libcds users. <br><br>  Who cares - welcome under the cat <br><a name="habracut"></a><br>  <a href="http://libcds.sourceforge.net/">Libcds</a> is a C ++ library of lock-free data structures and safe memory reclamation (SMR) methods for lock-free structures.  It is almost header-only ‚Äî all data structures are defined in the .h files of the headers and only the implementation of the core of the SMR algorithms is rendered into a small dynamic library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  SMR Overview </h2><br>  Perhaps the most subtle point in the development of a lock-free data structure is to determine at what point in time it is safe to physically remove the container element.  Deleting an item is always a two-phase operation: first, we exclude the item from the container, then delete (deallocate) the memory allocated for the item.  In the lock-free approach, the second phase - physical deletion - requires that there is complete certainty that no one (none of the parallel streams) has a link, global or local, to the item to be deleted. <br>  SMR algorithms that can be considered as specialized garbage collectors (GC) are responsible for safe removal.  In this article I will not dwell on the internal details of the implementation of a particular SMR algorithm, I will give only a general description, sufficient to start working with libcds.  I hope to discuss in detail all the algorithms in future articles. <br><br>  The following SMR algorithms are implemented in libcds: <br><ul><li> <i>Hazard Pointer</i> is perhaps the first and most famous of the SMR algorithms.  Invented by Michael (this surname) in 2002 [Mic02, Mic03, Mic04].  It is distinguished by relative simplicity and good speed; it is intended for the ‚Äúprotection‚Äù of local references to elements of the container.  The disadvantage is that you specify the maximum number of concurrent threads.  Header file <code>&lt;cds/gc/hp.h&gt;</code> , class <code>cds::gc::HP</code> </li><li>  <i>Pass-the-Buck</i> is conceptually similar to the Hazard Pointer, but does not depend on the number of threads.  Proposed in 2002 by Herlihy, V. Luchangco and M. Moir [Her02, Her05].  Due to the independence from the number of threads, it is a bit heavier than the Hazard Pointer.  Header <code>&lt;cds/gc/ptb.h&gt;</code> , class <code>cds::gc::PTB</code> </li><li>  <i>Hazard Pointer with Reference Counting</i> is a variant of the Hazard Pointer algorithm proposed by representatives of the Swedish school headed by H√•kan Sundell - Gidenstam et al. [Gid05, Gid06].  Like the Hazard Pointer, it depends on the number of threads.  A distinctive feature is that it can protect global references to container elements, that is, it is possible to implement iterators.  Not recommended for use due to insufficient performance and rare glitches (I can not debug it to the end).  Header file <code>&lt;cds/gc/hrc.h&gt;</code> , class <code>cds::gc::HRC</code> </li><li>  <i>RCU (Read-Copy Update)</i> - unlike the above, this algorithm refers to synchronization algorithms, that is, suspends execution of streams when deleting elements, but allows parallel execution of other operations ‚Äî insert, search ‚Äî is therefore good for data structures with rare deletion, type map, set.  It is proposed by Paul McKenney and is actively used in the Linux kernel;  The original RCU can only be implemented in the OS kernel, but in 2009 Desnoyers proposed the RCU version for application (user space RCU, URCU) [Des09, Des11], which is implemented in libcds.  The library offers five implementations of URCU, the most efficient is buffered URCU.  Header file <code>&lt;cds/urcu/general_buffered.h&gt;</code> , class <code>cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;</code> .  In libcds, URCU applies only to map and set. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/927/aba/0b1/927aba0b1bfcb77049461c406eddb737.jpg" align="right"><br>  All SMR algorithms require a <u>single</u> object representing the GC, that is, the GC is a singleton.  In the dynamic library - the core of libcds - is just the implementation of the basic SMR algorithms. <br><br>  As a rule, your application should use only one SMR algorithm (although libcds allows for using several different GC algorithms - all tests are built this way, but you cannot use two objects of the same GC).  Therefore, the first thing to do is to select the SMR algorithm.  Most data structure classes in libcds have GC, the memory management algorithm, as their first template argument.  Moreover, for each GC class there is its own specialization of the template class (template) of the container class, so for different GCs, as a rule, you should include (include) different container class header files. <br><br>  To use SMR algorithms, there is no need to know the internal structure of the GC, - all the mechanics of interaction with GC is hidden inside the container classes.  But it is required to initialize the GC singleton object at the beginning of the program, as well as at the beginning of each thread (thread), which uses containers that depend on the GC. <br><div class="spoiler">  <b class="spoiler_title">Containers without GC</b> <div class="spoiler_text">  In libcds there are some lock-free data structures without GC: <br><ul><li>  lock-based containers using sophisticated (fine-grained) synchronization algorithms </li><li>  limited (bounded) in maximum size containers </li><li>  set and map that do not support append-only operations.  As a rule, each set / map template class has a separate specialization for ‚ÄúGC‚Äù <code>cds::gc::nogc</code> .  The class <code>cds::gc::nogc</code> is actually a mark of the fact that the container does not support removal. </li></ul><br></div></div><br><br><h2>  Libcds initialization </h2><br>  The initialization of the library is to declare a GC object.  This object should be the only one in your program.  A GC object is simply an object-oriented superstructure over the internal implementation of the SMR algorithm.  As a rule, your program will not need to refer to the methods of the GC object, - all interaction with the GC is hidden inside the lock-free data structure, so the GC object can be local. <br>  In libcds, all different types of GC - <code>cds::gc::HP</code> , <code>cds::gc::PTB</code> <code>cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;</code> , <code>cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt; &gt;</code> , etc., are initialized uniformly, but the constructors may take different arguments that set the parameters of a particular GC.  All arguments to GC constructors have default values;  In this introductory article, I will call constructors with no arguments, relying on default values. <br><br>  The initialization code for the Hazard Pointer memory management algorithm is as follows: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cds/init.h&gt; //cds::Initialize  cds::Terminate #include &lt;cds/gc/hp.h&gt; //cds::gc::HP (Hazard Pointer) int main(int argc, char** argv) { //  libcds cds::Initialize() ; { //  Hazard Pointer  cds::gc::HP hpGC ; //  main thread  lock-free  // main thread    //   libcds cds::threading::Manager::attachThread() ; // , libcds    //     ... } //  libcds cds::Terminate() ; }</span></span></span></span></code> </pre><br>  The <code>cds::Initialize()</code> function initializes some global internal libcds data and defines the topology of the system.  This is followed by the creation of a GC object, in this example, Hazard Pointer, class <code>cds::gc::HP</code> , the object is created with arguments by default. <br>  At the end, <code>main</code> should call the terminator function of the <code>cds::Terminate</code> library, which will release (free) the internal structures. <br><div class="spoiler">  <b class="spoiler_title">Can I get rid of the cds :: Initialize () and cds :: Terminate () calls?</b> <div class="spoiler_text">  It is <code>cds::Initialize()</code> get rid of <code>cds::Initialize()</code> and <code>cds::Terminate</code> (for example, by defining them in the <code>DllMain</code> dll of the Windows library or by declaring static internal functions with the constructor / destructor attribute for GCC), since these functions are half inline and generally depend on macros that can be specified on the compiler command line. <br></div></div><br><br><h3>  Initializing threads </h3><br>  Many SMR algorithms, as well as lock-free data structures, require support from threads.  For example, some data is local to the thread (per-thread data), so it must be in thread local storage (TLS).  To ensure this, some implementations dictate their flow control policy or their class hierarchy for threads.  This, of course, is convenient for the library developer, but it is completely inconvenient for the user.  Therefore, when designing libcds, I went another way: the library does not depend on the model (or class hierarchy) of streams you selected, but must be explicitly attached (attach) to the stream. <br><br>  Each thread working with a container from libcds should be initialized as follows: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cds::threading::Manager #include &lt;cds/threading/model.h&gt; int myThreadEntryPoint(void *) { //     libcds cds::threading::Manager::attachThread() ; //        // lock-free  libcds ... //    libcds cds::threading::Manager::detachThread() ; return 0; }</span></span></code> </pre><br>  The <code>cds::threading::Manager</code> class is an adapter class for the internal thread management infrastructure.  You may need it only to connect / disconnect the stream to the libcds infrastructure. <br>  The above thread initialization code is not exceptionally safe.  A better approach is to use an object whose constructor connects the stream to the libcds infrastructure, and the destructor disables it.  For this, each GC class has an internal <code>thread_gc</code> class.  With it, the thread initialization looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cds/gc/hp.h&gt; int myThreadEntryPoint(void *) { //     libcds cds::gc::HP::thread_gc threadGC ; //        // lock-free  libcds ... return 0; }</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">What if the thread was not created by us?</b> <div class="spoiler_text">  There are situations when it is required to connect a stream that was not created by us to libcds, and we cannot influence the initialization of this stream in any way.  For example, our application is a web server plugin.  The web server creates a thread pool (thread pool) and calls handlers implemented in plugins in the context of these threads.  In this case, we can neither create a GC-object, nor initialize a thread by declaring an object of type <code>GC::thread_gc</code> .  What to do? <br><br>  We have to use the internal libcds initialization mechanisms: create a library initialization class and declare a static object of this class: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cds/gc/hp.h&gt; class LibcdsInit { public: LibcdsInit() { //  libcds cds::Initialize(); //  Hazard Pointer singleton cds::gc::hzp::GarbageCollector::Construct() ; } ~LibcdsInit() { //  Hazard Pointer singleton //  true ‚Äì   //  Hazard Pointer   cds::gc::hzp::GarbageCollector::Destruct(true) ; //  libcds cds::Terminate(); }; }; //    static LibcdsInit libcdsInitializator ;</span></span></span></span></code> </pre><br>  Instead of the initializer class <code>LibcdsInit</code> corresponding calls can be placed in <code>DllMain</code> (for Windows) or in constructors / destructors ( <code>__attribute__((constructor))</code> for GCC). <br><br>  The initialization of a thread is to connect it ‚Äúforever‚Äù with a call to <code>cds::threading::Manager::attachThread()</code> : <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cds::threading::Manager #include &lt;cds/threading/model.h&gt; void callback() { Cds::threading::Manager::attachThread(); //      lock-free //  libcds }</span></span></code> </pre><br>  We do not call thread disconnection. <br></div></div><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a29/80b/fba/a2980bfba3a4841a5fa1c69d66718ca6.jpg" align="right"><br><h2>  Containers </h2><br>  After initializing the library, you can use the lock-free data structure.  In libcds containers are divided into two large classes - ordinary and <s>unusual</s> intrusive. <br>  Regular ones are STL-style containers, they store a copy of the data.  All such containers are declared in the <code>cds::container</code> namespace. <br>  Intrusive containers store the data itself, not copies.  The idea is taken from <a href="http://www.boost.org/doc/libs/1_54_0/doc/html/intrusive.html">boost :: intrusive</a> .  The advantage of intrusive containers is that you do not need to call the allocator to create a copy of the data.  It is believed, and not without reason, that the use of a standard allocator negates the idea of ‚Äã‚Äãlock-free, since the allocator itself contains synchronization primitives within itself.  In general, this is correct, but modern advanced allocators can optimize memory allocation, eliminating internal synchronization due to, for example, the presence of a memory pool for each stream. <br>  I will not dwell on intrusive containers in this article - they require special techniques to free up memory when removing an item from a container, this is a topic for another conversation.  Here I will just note that most classes of conventional containers are based on intrusive ones, that is, as a rule, all the interesting lock-free code is in the class of the intrusive container.  Intrusive containers are declared in the <code>cds::intrusive</code> . <br><br>  All data structures in libcds are template classes with a uniform template interface.  There are two types of template-interfaces: <br><ul><li>  based on variadic template </li><li>  traits based </li></ul><br>  Variadic template based ads are used for simple containers - stacks and queues.  The general pattern is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GC, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>‚Ä¶ Options&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">queue</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ };</code> </pre><br>  For compilers that do not support the variadic template, emulation is used. <br>  Inside the container class, <code>Options</code> packaged in a <code>Traits</code> structure. <br><br>  The Variadic template approach was not very convenient for complex inheritance, therefore for classes of more complex containers such as <code>set</code> , <code>map</code> , etc., traits are used: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GC, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ };</code> </pre><br>  For each such class, there is a <code>make_traits</code> that transforms the variadic template into traits: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>‚Ä¶ Options&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> pack&lt;Options‚Ä¶&gt;::type type ; };</code> </pre><br>  Using <code>make_traits</code> declaring a container object takes the form: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ }; cds::container::SkipListSet&lt; cds::gc::HP, Foo, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> cds::container::skip_list::make_traits&lt; Opt1, Opt2, Opt3 &gt;::type &gt; theSkipListSet ;</code> </pre><br>  Such an ad, of course, looks cool, but it can create problems when debugging, - the class name can take several dozen lines.  Traits ads are more compact for debugging: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skipListSetTraits</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cds::container::skip_list::make_traits&lt; Opt1, Opt2, Opt3 &gt;::type {}; cds::container::SkipListSet&lt; cds::gc::HP, Foo, skipListSetTraits &gt; theSkipListSet ;</code> </pre><br><br>  The template arguments for the data structure class are: <br><ul><li>  <code>GC</code> - SMR algorithm used </li><li>  <code>T</code> - the type of data stored in the container </li><li>  <code>Options‚Ä¶</code> or <code>Traits</code> - options (policy) of the container </li></ul><br>  On the options should stay separately. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/462/c46/b77/462c46b77b2585c2e6f73831aa2e14a5.jpg" align="right"><br><h3>  Options </h3><br>  Each container class, in addition to the data type and the SMR algorithm, can have a varied number of additional settings defining a particular behavior.  For example, for ordered containers (map, set) it is necessary to specify the binary predicate of comparison of the <code>std::less&lt;T&gt;</code> elements.  Or set one or another action strategy when detecting parallel work (back-off strategy).  Or install the allocator used to create container elements. <br>  Each container class has several (up to a dozen) such, as a rule, optional settings, which I call options.  The approach used in STL, when each setting is a template template's template argument, is not very pleasant to me: such position-dependent arguments with default values ‚Äã‚Äãcomplicate the use of the class.  If the class has 10 template arguments with default values, in order to change the eighth argument, we need to specify the default values ‚Äã‚Äãof all seven arguments preceding the eighth one.  It is very uncomfortable.  Therefore, in libcds I use a position-independent approach. <br>  With this approach, each option has its own type;  For example, the ‚Äúallocator‚Äù option has the following declaration: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Alloc&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pack</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Alloc allocator ; }; };</code> </pre><br>  Here, the template argument <code>Alloc</code> is a specific class of allocator, and the <code>allocator</code> structure itself is the name of the option.  Here is the task of the allocator through the option: <br><pre> <code class="cpp hljs">cds::opt::allocator&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt;</code> </pre><br>  Using such option declarations, it is quite easy to build a meta function that collects the structure of <code>traits</code> from options.  This process is called <i>packing</i> . <br>  There are two types of options in libcds: <br><ul><li>  General options - applicable to many containers.  Declarations of such options are in the <code>cds::opt</code> namespace, and valid values ‚Äã‚Äãfor options are in the namespace <code>cds::opt::v</code> </li><li>  Special options - applicable only to a specific container class.  Their declarations are located in the namespace of a specific container, for example, in <code>cds::container::skip_list</code> </li></ul><br>  In the description of each class of the container is a list of valid options. <br><br><h3>  Comparison predicates </h3><br>  In many containers of the type map, set it is necessary to specify the predicate of comparison of elements.  In STL, predicates <code>std::less&lt;T&gt;</code> are used for this, which are able to compare only elements of type <code>T</code>  But very often it is inconvenient and costly.  For example, the type <code>std::string</code> can be compared with the value <code>char const *</code> , and for such a comparison there is no need to create a temporary object <code>std::string</code> .  For set-containers, the type <code>T</code> stored in the container very often has the key fields needed for comparison, and the ‚Äúload‚Äù is the actual data that is not involved in the search. <br>  Considering all this, libcds uses extended predicates that can compare values ‚Äã‚Äãof different types.  Predicates are given by options.  Moreover, as a comparison predicate, you can use extended less (option <code>cds::opt::less&lt; typename Less &gt;</code> ) or extended compare (option <code>cds::opt::compare&lt; typename Comparator &gt;</code> ).  Compare returns an integer value: <br><ul><li>  <code>cmp(a, b) &lt; 0</code> if <code>a &lt; b</code> </li><li>  <code>cmp(a, b) == 0</code> if <code>a == b</code> </li><li>  <code>cmp(a, b) &gt; 0</code> if <code>a &gt; b</code> </li></ul><br>  The <code>std::string::compare</code> function method also works. <br>  Writing extended predicates ( <code>Less</code> for the <code>cds::opt::less&lt; typename Less &gt;</code> option <code>cds::opt::less&lt; typename Less &gt;</code> or <code>Comparator</code> for the <code>cds::opt::compare&lt; typename Comparator &gt;</code> option) is your conscience.  Here's what the <code>Comparator</code> might look like for string comparisons: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string_cmp</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s1, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s2)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compare( s2 ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s2)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compare( s2 ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s1, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s2)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ‚Äìs2.compare( s1 ); } };</code> </pre><br><br><h3>  Allokatory </h3><br>  Containers from the <code>cds::container</code> namespace store copies of data, so one of the options for them is <code>cds::opt::allocator</code> - the allocator for allocating memory for data.  Some containers have two allocator options ‚Äî one for distributing data ( <code>cds::opt::node_allocator</code> ) and another ( <code>cds::opt::allocator</code> ) for allocating memory for the supporting structures of the container.  By default, the <code>std::allocator&lt;int&gt;</code> used as the <code>std::allocator&lt;int&gt;</code> .  If you want to use your allocator, its interface should be the same as that of <code>std::allocator</code> . <br><br>  The library relies heavily on two properties of allocators: <br><ul><li>  each allocator has a <code>template &lt;typename Other&gt; struct rebind</code> , which allows to rebuild the allocator for a different type <code>Other</code> .  As I have already said, the default <code>std::allocator&lt;int&gt;</code> is <code>std::allocator&lt;int&gt;</code> , - the container, by means of the <code>rebind</code> metafunction <code>rebind</code> changes the <code>int</code> type to the required one </li><li>  allocator is a global object.  This requirement arises from the fact that the physical removal of the lock-free element of a container is delayed and can occur after the destruction of the container object itself.  Therefore, unlike STL, the libcds containers never store references to the allocator object and do not have methods for specifying the allocator object.  If you need to allocate memory within the container method, the allocator is called via a temporary object: <code>allocator_type().allocate( 1 )</code> .  Similarly, freeing memory is done by calling <code>allocator_type().deallocate( p )</code> .  It is worth noting once again that the release is delayed and can occur even when the container object itself is no longer present, and it is called from the SMR algorithm. </li></ul><br><br><h2>  Brief specifications </h2><br>  Supported compilers: <br><ul><li>  GCC 4.3 and above </li><li>  MS Visual C ++ 2008 and up </li><li>  Clang 3.0 and higher (with the standard GCC library libstdc ++) </li></ul><br><br>  Supported operating systems and processor architectures: <br><ul><li>  Windows x86, amd64 </li><li>  Linux x86, amd64, Intel Itanium, Sparc </li><li>  Solaris sparc </li><li>  HP-UX Intel Itanium </li></ul><br>  Support for other operating systems or processor architectures is possible, but not trivial, especially if the target compiler does not support C ++ 11 <code>atomic</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/321/b18/f3e/321b18f3eb0009709ab76bc2eff4da9b.jpg" align="right"><br><h2>  Conclusion </h2><br>  I hope after reading this article it will be clear how to use the libcds library.  In addition, I tried to explain the basic principles, guided by which I implement in the library data structures. <br><br>  I absolutely do not touch on performance issues.  As I mentioned earlier, you can only talk about performance in relation to a specific task and a specific hardware.  Modern hardware is very different about lock-free algorithms: one favors them, the other is necessary to persuade for a long time, choosing one or another container class options to achieve acceptable performance.  Lock-free data structures are quite complex compared to their normal counterparts, so the ‚Äúwho is faster‚Äù factor starts playing: either a synchronization primitive + a regular container, or a complex lock-free container without external synchronization. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want good advice, here it is: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try not to use shared data at all</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I did not discover America with such advice, but it can be difficult to follow it in everyday life.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Links</b> <div class="spoiler_text"> [Des09] M.Desnoyers <a href="http://publications.polymtl.ca/206/1/2009_MathieuDesnoyers.pdf">Low-Impact Operating System Tracing</a> PhD Thesis,Chapter 6 ¬´User-Level Implementations of Read-Copy Update¬ª <br><br> [Des11] M.Desnoyers, P.McKenney, A.Stern, M.Dagenias, J.Walpole <a href="http://www.dorsal.polymtl.ca/static/publications/desnoyers-ieee-urcu-submitted.pdf">User-Level Implementations of Read-Copy Update</a> <br><br> [Gid05] Anders Gidenstam, Marina Papatriantafilou and Philippas Tsigas <a href="http://www.non-blocking.com/download/GidPST05_LockFreeGC_TR.pdf">Practical and Efficient Lock-Free Garbage Collection Based on Reference Counting</a> <br><br> [Gid06] A.Gidenstam <a href="http://www.adm.hb.se/~agd/Papers/gidenstam_phd.pdf">Algorithms for synchronization and consistency in concurrent system services</a> , Chapter 5 ¬´Lock-Free Memory Reclamation¬ª Thesis for the degree of Doctor of Philosophy <br><br> [Her02] M. Herlihy, V. Luchangco, and M. Moir. <a href="http://cs.brown.edu/~mph/HerlihyLM02/smli_tr-2002-112.pdf">The repeat offender problem: A mechanism for supporting dynamic-sized lockfree data structures</a> Technical Report TR-2002-112, Sun Microsystems Laboratories, 2002 <br><br> [Her05] M. Herlihy, V. Luchangco, P. Martin, and M. Moir. <a href="http://secs.ceas.uc.edu/~paw/classes/ece975/sp2010/papers/herlihy-05.pdf">Nonblocking Memory Management Support for Dynamic_Sized Data Structures</a> ACM Transactions on Computer Systems, Vol.23, No.2, May 2005 <br><br> [Mic02] Maged M.Michael <a href="http://pdf.aminer.org/000/544/295/safe_memory_reclamation_for_dynamic_lock_free_objects_using_atomic.pdf">Safe memory reclamation for dynamic lock-free objects using atomic reads and writes</a> <br><br> [Mic03] Maged M.Michael <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.130.8984%26rep%3Drep1%26type%3Dpdf">Hazard Pointers: Safe memory reclamation for lock-free objects</a> <br><br> [Mic04] Andrei Alexandrescy, Maged Michael <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.112.6406%26rep%3Drep1%26type%3Dpdf">Lock-free Data Structures with Hazard Pointers</a> <br></div></div><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock-free data structures</font></font></b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/195948/">   </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/196548/">    </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/197520/"> </a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/202190/">  </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/216013/"> </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/219201/"> </a> </li><li> <a href="http://habrahabr.ru/post/230349/"> </a> </li><li> <a href="http://habrahabr.ru/post/250383/">Concurrent maps: </a> </li><li> <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li> <a href="https://habrahabr.ru/post/251267/">Concurent maps: </a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li> <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/196834/">  libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/196834/">https://habr.com/ru/post/196834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196816/index.html">Optimization of web environment on the Jelastic platform for PHP projects</a></li>
<li><a href="../196820/index.html">To entrust the production of electronics: from its own factory to the fabless company</a></li>
<li><a href="../196826/index.html">Lego Specifications Game in Ciklum Odessa, October 16</a></li>
<li><a href="../196828/index.html">We load data in Oracle</a></li>
<li><a href="../196832/index.html">Nissan LEAF robot car first in Japan received a license plate</a></li>
<li><a href="../196842/index.html">Edward Jordon speaking at the RCC 2013: "Past, Present and Future"</a></li>
<li><a href="../196844/index.html">Yandex.DNS - secure home internet</a></li>
<li><a href="../196848/index.html">Source codes of RosVyborov are open</a></li>
<li><a href="../196850/index.html">Questions for interviews with the former scener</a></li>
<li><a href="../196852/index.html">Author Blackhole exploit kit arrested</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>