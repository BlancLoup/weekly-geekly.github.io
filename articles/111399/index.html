<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Configure PPPoE with traffic shaping for a small network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once there was a task to set up Internet distribution for a couple of dozen computers (office and home). The boxed solutions turned out to be either p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Configure PPPoE with traffic shaping for a small network</h1><div class="post__text post__text-html js-mediator-article">  Once there was a task to set up Internet distribution for a couple of dozen computers (office and home).  The boxed solutions turned out to be either paid or rather difficult to customize, so it was decided to use our own based on Debian Linux.  I want to share the experience of his uplifting with you in this post, but the versions listed here could have become a little outdated since the writing of the manual ‚Äúfor myself‚Äù, so you need to take some care.  Also, you need to take into account that the above solution is far from ideal and professional.  It will help more likely those who need to quickly pick up a server that distributes the Internet.  In the end, we will have Internet distribution via PPPoE with the appointment of internal IP clients, traffic shaping, DNS server and simple monitoring of current sessions from the console. <br><a name="habracut"></a><br><br><h4>  System preparation </h4><br> <code>aptitude update <br> aptitude install openssh-server mc mtr tracert nano tcpdump bind9 pppoe freeradius radiusclient1 rcconf php5</code> <br> <br><h4>  DNS server setup </h4><br>  We carry out <br> <code>nano /etc/bind/named.conf.options</code> <br> <br>  Add to the end of the file: <br> <code>allow-transfer { none; }; <br> allow-query { 10.128.0.0/16; localhost; }; //   <br> allow-recursion { 10.128.0.0/16; localhost; }; //   <br> version "My ISP DNS"; //     <br></code> <br><br>  Let's start setting up a chroot environment for our DNS server.  Create directories for the root file system of the DNS server ‚Äî root-dns: <br> <code>mkdir -p /root-dns/etc <br> mkdir /root-dns/dev <br> mkdir -p /root-dns/var/cache/bind <br> mkdir -p /root-dns/var/run/bind/run <br> /etc/init.d/bind9 stop <br> nano /etc/default/bind9</code> <br> <br>  Found the line "OPTIONS =" and replaced: <br> <code>OPTIONS="-u bind -t /root-dns"</code> <br> <br> <code>mv /etc/bind /root-dns/etc <br> ln -s /root-dns/etc/bind /etc/bind <br> nano /etc/init.d/bind9 <br></code> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Found the line "OPTIONS =" and replaced: <br> <code>OPTIONS="-u bind -t /root-dns"</code> <br> <br>  Run: <br> <code>nano /etc/init.d/rsyslogd</code> <br> <br>  Found "RSYSLOGD_OPTIONS" and replaced: <br> <code>RSYSLOGD_OPTIONS="-c3 -a /root-dns/dev/log"</code> <br> <br>  Protect the named.conf configuration file from editing and deletion: <br> <code>chattr +i /root-dns/etc/bind/named.conf</code> <br> <br>  Note.  Do not forget to remove the attribute ‚Äúi‚Äù before editing the configuration file (chattr -i ...) <br><br> <code>mknod /root-dns/dev/null c 1 3 <br> mknod /root-dns/dev/random c 1 8 <br> chmod 666 /root-dns/dev/null /root-dns/dev/random <br> chown -R bind:bind /root-dns/var/* <br> chown -R bind:bind /root-dns/etc/bind <br> /etc/init.d/bind9 start <br></code> <br><br><h4>  PPPoE server </h4><br> <code>cd /tmp <br> apt-get build-dep pppoe <br> apt-get source pppoe <br> cd rp-pppoe-3.8/src <br> ./configure <br></code> <br><br>  Run: <br> <code>nano config.h</code> <br> <br>  Now in the newly created config.h file you need to replace the line: <br> <code>/* #undef HAVE_LINUX_KERNEL_PPPOE */</code> <br> <br>  on line: <br> <code>#define HAVE_LINUX_KERNEL_PPPOE 1</code> <br> <br>  We carry out: <br> <code>cd .. <br> ./debian/rules PLUGIN_PATH=/usr/lib/pppd/2.4.4/rp-pppoe.so <br> ./debian/rules binary <br> cd .. <br> dpkg -i pppoe_3.8-3_i386.deb <br></code> <br><br>  Freeze the package in the system to prevent its automatic update: <br> <code>echo pppoe hold | dpkg ‚Äîset-selections</code> <br> <br>  From this point on, at least with each system update, you should look through the list of updates.  If pppoe releases an update to close the vulnerability, it will be necessary to rebuild the fresh source package, unmute the package in the system using the command: <br> <code>echo pppoe install | dpkg --set-selections</code> <br> <br>  Now the system has a package with a PPPoE server installed that allows you to maintain kernel-level PPPoE connections.  To start the server in this mode, add the -k option to the command described in the previous section: pppoe-server -I eth1 -L 192.168.0.1 -k <br><br>  Run: <br> <code>nano /etc/ppp/pppoe-server-options</code> <br> <br>  Paste: <br> <code>logfile /var/log/pppoe.log <br> debug <br> mtu 1472 <br> mru 1472 <br> auth <br> require-pap <br> #require-chap <br> default-asyncmap <br> ktune <br> lcp-echo-interval 20 <br> lcp-echo-failure 2 <br> ms-dns 10.128.0.1 <br> plugin radius.so <br> plugin radattr.so <br> 10.128.0.1: <br> nobsdcomp <br> noccp <br> noendpoint <br> noipdefault <br> noipx <br> novj <br> receive-all</code> <br> <br>  Run: <br> <code>nano /etc/ppp/options</code> <br> <br>  In the / etc / ppp / options config: remove everything, set: <br> <code>lock</code> <br> <br>  Run: <br> <code>nano /etc/init.d/pppoe-server <br></code> <br><br>  Script: <br> <code>#!/bin/bash <br> # init file for rp-pppoe server <br> # <br> # description: PPPOE kernel mode server <br> # <br> # processname: pppoe-server <br> # chkconfig: - 45 45 <br> # source function library <br> #. /etc/rc.status <br> case "$1" in <br> start) <br> echo -n "Starting PPPOE server: " <br> /usr/sbin/pppoe-server -I eth0 -L 10.128.0.1 -R 10.128.1.1 -k <br> # eth0 ‚Äî ,      <br> #10.128.0.1 - IP PPPoE  <br> #10.128.1.1 -  IP   <br> #touch /var/lock/subsys/pppoed <br> #rc_status -v <br> ;; <br> stop) <br> echo -n "Shutting down PPPOE server: " <br> pkill pppoe-server <br> #rm -f /var/lock/subsys/pppoed <br> #rc_status -v <br> ;; <br> restart) <br> $0 stop <br> $0 start <br> ;; <br> status) <br> status pppoe-server <br> ;; <br> *) <br> echo "Usage: pppoed {start|stop|restart|status}" <br> exit 1 <br> esac <br> exit 0 <br></code> <br><br>  Run: <br> <code>rcconf</code> <br> <br>  Disable bind.  Then we go in there again and see that he has disappeared altogether from the list.  Below it is there, and near our pppoe-server.  Turned on both this and that.  Send out <br><br> <code>cd /root-dns/etc/bind <br> rndc-confgen -r /dev/urandom -a <br> chgrp bind rndc.key <br> chmod +r rndc.key <br> nano named.conf.options <br></code> <br><br>  At the end of the file add: <br> <code>controls { <br> inet 127.0.0.1 allow { localhost; } keys { rndc-key; }; <br> }; <br> include "/etc/bind/rndc.key"; <br></code> <br><br>  Now, you also need to enable forvarding in the kernel and make iptables rules catch.  The configuration will be test. <br><br><h4>  Parameters sysctl.conf, iptables, network interface settings </h4><br>  Run: <br> <code>nano /etc/sysctl.conf</code> <br> <br>  Uncommented, added something nebylo: <br> <code>net.ipv4.conf.default.rp_filter=1 <br> net.ipv4.conf.all.rp_filter=1 <br> net.ipv4.tcp_syncookies=1 <br> net.ipv4.ip_forward=1 <br> kernel.panic = 1 <br> kernel.panic_on_oops = 1 <br> kernel.panic_on_io_nmi = 1 <br> kernel.panic_on_unrecovered_nmi = 1</code> <br> <br>  The last 4 lines are a reboot at various system crashes, so as not to go to reboot somewhere in another city.  Save, then do the test config for iptables: <br> <code>iptables -t nat -F <br> iptables-save &gt; /etc/firewall.conf <br> nano rc.local <br></code> <br><br>  Now in rc.local we will have: <br> <code>ifconfig eth0 up <br> iptables-restore &lt;/etc/firewall.conf <br></code> <br><br>  Further, we configure / etc / network / interfaces - here eth0 has turned out to be local, for it we don‚Äôt write anything at all, except auto eth0.  And about eth1 - if this is the Internet - I would think about a static external ip, otherwise SNAT cannot be used, but only MASQUERADE, and it loads the system more. <br><br>  Run: <br> <code>nano /etc/network/interfaces</code> <br> <br>  Config: <br> <code>auto lo <br> iface lo inet loopback <br> auto eth0 <br> auto eth1 <br> <br> allow-hotplug eth0 eth1 <br> iface eth1 inet dhcp <br></code> <br><br>  In this listing, eth1 is the Internet via NAT and DHCP config. <br><br><h4>  PPPoE trial run </h4><br>  Next you need to test PPPoE without radius.  To do this, we comment on 2 lines of plugins in / etc / ppp / pppoe-server-options. <br><br>  Run: <br> <code>nano /etc/ppp/pppoe-server-options</code> <br> <br>  Config: <br> <code>#plugin radius.so <br> #plugin radattr.so <br></code> <br><br>  Run: <br> <code>nano /etc/ppp/pap-secrets</code> <br> <br>  We add to the end or replace the entire contents: <br> <code>test * test 10.128.2.10</code> <br> <br>  We start pppoe-server: <br> <code>/etc/init.d/pppoe-server start</code> <br> <br>  Reboot the server, checked PPPoE and internet.  On any client, we create a PPPoE connection and connect using the login and password test.  In order for the Internet to work for the client, you need to enable masquerading: <br> <code>iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE</code> <br> <br>  Works?  Well, returned as it was: <br> <code>iptables -t nat -F</code> <br> <br><h4>  Freeradius </h4><br>  Run: <br> <code>nano /etc/radiusclient/servers</code> <br> <br>  Replace the contents of the file: <br> <code>127.0.0.1 my-isp-radius</code> <br> <br>  Run: <br> <code>nano /etc/radiusclient/radiusclient.conf</code> <br> <br>  Replace the contents of the file: <br> <code>auth_order radius,local <br> login_tries 4 <br> login_timeout 60 <br> nologin /etc/nologin <br> issue /etc/radiusclient/issue <br> # RADIUS settings <br> authserver localhost:1812 <br> acctserver localhost:1812 <br> servers /etc/radiusclient/servers <br> dictionary /etc/radiusclient/dictionary <br> login_radius /usr/sbin/login.radius <br> # RADIUS server <br> seqfile /var/run/radius.seq <br> mapfile /etc/radiusclient/port-id-map <br> default_realm <br> radius_timeout 10 <br> radius_retries 3 <br> login_local /bin/login <br></code> <br><br>  Run: <br> <code>nano /etc/freeradius/radiusd.conf</code> <br> <br>  Replace the contents of the file: <br> <code>prefix = /usr <br> exec_prefix = /usr <br> sysconfdir = /etc <br> localstatedir = /var <br> sbindir = ${exec_prefix}/sbin <br> logdir = /var/log/freeradius <br> raddbdir = /etc/freeradius <br> radacctdir = ${logdir}/radacct <br> #     . <br> confdir = ${raddbdir} <br> run_dir = ${localstatedir}/run/freeradius <br> #    . <br> libdir = ${exec_prefix}/lib <br> #  pid-.   . <br> pidfile = ${run_dir}/freeradius.pid <br> #        FreeRADIUS <br> user = freerad <br> group = freerad <br> #   ( )    . <br> max_request_time = 30 <br> #       max_request_time <br> delete_blocked_requests = no <br> #   ( )   reply   NAS. <br> cleanup_delay = 5 <br> #     .      <br> #     256. <br> #        1024. <br> max_requests = 5120 <br> #   ip .   RADIUS     <br> #    ip . <br> bind_address = 127.0.0.1 <br> #   FreeRADIUS  port.   , <br> #     /etc/services <br> port = 0 <br> # / ip   dns . <br> #       . <br> hostname_lookups = no <br> # /     . <br> allow_core_dumps = no <br> #    . <br> regular_expressions = yes <br> extended_expressions = yes <br> #   User-Name     . <br> log_stripped_names = no <br> #     . <br> log_auth = yes <br> #      . <br> # log_auth_badpass -    <br> # log_auth_goodpass -   <br> log_auth_badpass = yes <br> log_auth_goodpass = no <br> # /  . <br> usercollide = no <br> #   /     . <br> lower_user = no <br> lower_pass = no <br> #     / . <br> nospace_user = no <br> nospace_pass = no <br> #     DoS . <br> security { <br> #      RADIUS . <br> max_attributes = 200 <br> #  ( )   Access-Reject . <br> reject_delay = 1 <br> #     Status-Server <br> status_server = no <br> } <br> #   RADIUS . <br> #    . <br> $INCLUDE ${confdir}/clients.conf <br> #  snmp . <br> snmp=no <br> #   . <br> thread pool { <br> #    . <br> start_servers = 5 <br> #    . <br> max_servers = 32 <br> #    . <br> min_spare_servers = 3 <br> max_spare_servers = 10 <br> <br> #    .       <br> # RADIUS .   300,     <br> #   . <br> max_requests_per_server = 0 <br> } <br> <br> #    . <br> modules { <br> #  PAP . <br> #      PAP . <br> # encryption_scheme      . <br> # clear -    . <br> pap { <br> encryption_scheme = clear <br> } <br> #  CHAP . <br> #      CHAP . <br> # authtype       Auth-Type=CHAP <br> chap { <br> authtype = CHAP <br> } <br> #   . <br> # ..   . <br> preprocess { <br> # huntgroups -   .  huntgoups. <br> # hints - . <br> huntgroups = ${confdir}/huntgroups <br> hints = ${confdir}/hints <br> <br> #  Cisco VSA. <br> with_cisco_vsa_hack = no <br> } <br> #  Microsoft CHAP . <br> #      Microsoft CHAP v2 <br> # authtype       Auth-Type=MS-CHAP <br> # use_mppe = no     VPN . <br> mschap { <br> authtype = MS-CHAP <br> use_mppe = no <br> } <br> #   Livingston RADIUS . <br> # usersfile    . <br> #          . <br> # acctusersfile     (). <br> # compat - .     FreeRADIUS  . <br> files { <br> usersfile = ${confdir}/users <br> compat = no <br> } <br> <br> #     . <br> detail { <br> detailfile = ${radacctdir}/%{Client-IP-Address}/detail-%Y%m%d <br> detailperm = 0600 <br> } <br> <br> #     . <br> detail auth_log { <br> detailfile = ${radacctdir}/%{Client-IP-Address}/auth-detail-%Y%m%d <br> detailperm = 0600 <br> } <br> <br> #    reply . <br> detail reply_log { <br> detailfile = ${radacctdir}/%{Client-IP-Address}/reply-detail-%Y%m%d <br> detailperm = 0600 <br> } <br> <br> #      . <br> #  NAS   Acct-Session-ID. <br> # key     Acct-Session-ID <br> acct_unique { <br> key = "User-Name, Acct-Session-Id, NAS-IP-Address, Client-IP-Address, NAS-Port-Id" <br> } <br> <br> #       <br> #     cakesql.conf <br> #$INCLUDE ${confdir}/sql.conf <br> #$INCLUDE ${confdir}/sql/mysql/counter.conf <br> } <br> <br> #  <br> #      preprocess <br> #    . <br> #  chap mschap  chap  mschap . <br> authorize { <br> preprocess <br> chap <br> mschap <br> #     . <br> # auth_log <br> files <br> #sql <br> } <br> #  <br> #    ,  . <br> authenticate { <br> Auth-Type PAP { <br> pap <br> } <br> <br> Auth-Type CHAP { <br> chap <br> } <br> <br> Auth-Type MS-CHAP { <br> mschap <br> } <br> <br> } <br> #   . <br> preacct { <br> preprocess <br> } <br> #   . <br> accounting { <br> #  Acct-Session-Id   NAS      . <br> acct_unique <br> #   detail . <br> detail <br> #      <br> #sql <br> } <br> #    reply-. <br> post-auth { <br> #      . <br> reply_log <br> } <br> log { <br> destination = files <br> file = ${logdir}/radius.log <br> syslog_facility = daemon <br> stripped_names = no <br> auth = no <br> auth_badpass = no <br> auth_goodpass = no <br> } <br></code> <br><br>  Run: <br> <code>nano /etc/freeradius/clients.conf</code> <br> <br>  Replace the contents of the file: <br> <code>client localhost { <br> ipaddr = 127.0.0.1 <br> secret = my-isp-radius <br> require_message_authenticator = no <br> nastype = other <br> } <br></code> <br><br>  Run: <br> <code>nano /etc/freeradius/users</code> <br> <br>  Config: <br> <code>steve Cleartext-Password := "testing" <br> Service-Type = Framed-User, <br> Framed-Protocol = PPP, <br> Framed-IP-Address = 10.128.13.3, <br> Framed-IP-Netmask = 255.255.0.0, <br> Framed-Routing = Broadcast-Listen, <br> Framed-Filter-Id = "std.ppp", <br> Framed-MTU = 1500, <br> Framed-Compression = Van-Jacobsen-TCP-IP <br> <br> #        <br> <br> DEFAULT Framed-Protocol == PPP <br> Framed-Protocol = PPP, <br> Framed-Compression = Van-Jacobson-TCP-IP <br> <br> DEFAULT Hint == "CSLIP" <br> Framed-Protocol = SLIP, <br> Framed-Compression = Van-Jacobson-TCP-IP <br> <br> DEFAULT Hint == "SLIP" <br> Framed-Protocol = SLIP <br></code> <br><br>  In general, in the future you will need to configure a bundle with MySQL, but at this stage it is not critical.  When adding a user, you need to restart Freeradius: <br> <code>/etc/init.d/freeradius restart</code> <br> <br>  Now you need to deal with traffic shaping.  The idea is that the speed should be regulated individually for each user and transmitted as an attribute from the Radius server to the NAT server.  What for?  In order to subsequently be able to expand the structure and distribute the load across multiple NAS. <br><br><h4>  Traffic shaping </h4><br>  So preparation.  Install the Wondershaper: <br> <code>aptitude install wondershaper</code> <br> <br>  This package is a single script that works with CBQ / HTB prioritization and has a reasonable call format.  If desired, you can test his work before implementation: <br> <code>wondershaper ppp0 512 512</code> <br> <br>  Naturally, ppp0 should exist and be the result of connecting the client to our server.  After the command is executed, the client's web browser can go to any site that measures speed, such as <a href="http://speedtest.net/">speedtest.net</a> - and make sure that it is cut by the shaper.  To reset the settings without disconnecting with the client (Kick, that is), we do <br> <code>wondershaper clear ppp0</code> <br> <br>  and make sure that the speed is again normal (that is, it is equal to the speed we take from the ‚Äúbig brother‚Äù on the WAN interface. Adding speed limits should be automated using a simple file parser /var/run/radattr.ppp* that appear when successful ppp connection and contain all the attributes transmitted by the Radius server to the PPPoE server. Let‚Äôs take care of the attributes.We supplement the contents of the additional attributes file of / etc / freeradius / dictionary with this: <br><br>  Run: <br> <code>nano /etc/freeradius/dictionary</code> <br> <br>  Config: <br> <code># Limit session traffic <br> ATTRIBUTE Session-Octets-Limit 227 integer <br> # What to assume as limit - 0 in+out, 1 in, 2 out, 3 max(in,out) <br> ATTRIBUTE Octets-Direction 228 integer <br> # Connection Speed Limit <br> ATTRIBUTE PPPD-Upstream-Speed-Limit 230 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit 231 integer <br> ATTRIBUTE PPPD-Upstream-Speed-Limit-1 232 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit-1 233 integer <br> ATTRIBUTE PPPD-Upstream-Speed-Limit-2 234 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit-2 235 integer <br> ATTRIBUTE PPPD-Upstream-Speed-Limit-3 236 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit-3 237 integer <br> ATTRIBUTE Acct-Interim-Interval 85 integer</code> <br> <br>  Further, the same attributes should be added to the Raduisclient dictionary.  We edit / etc / radiusclient / dictionary, at the end we add the same: <br><br>  Run: <br> <code>nano /etc/radiusclient/dictionary</code> <br> <br>  Config: <br> <code># Limit session traffic <br> ATTRIBUTE Session-Octets-Limit 227 integer <br> # What to assume as limit - 0 in+out, 1 in, 2 out, 3 max(in,out) <br> ATTRIBUTE Octets-Direction 228 integer <br> # Connection Speed Limit <br> ATTRIBUTE PPPD-Upstream-Speed-Limit 230 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit 231 integer <br> ATTRIBUTE PPPD-Upstream-Speed-Limit-1 232 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit-1 233 integer <br> ATTRIBUTE PPPD-Upstream-Speed-Limit-2 234 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit-2 235 integer <br> ATTRIBUTE PPPD-Upstream-Speed-Limit-3 236 integer <br> ATTRIBUTE PPPD-Downstream-Speed-Limit-3 237 integer <br> ATTRIBUTE Acct-Interim-Interval 85 integer <br></code> <br><br>  Everything is fine, now they (FreeRadius and RadiusClient) will understand each other.  Accordingly, additional lines will appear in the user settings of freeradius, indicating the limit of the incoming and outgoing speed (but not mandatory).  Example / etc / freeradius / users with changes: <br><br>  Run: <br> <code>nano /etc/freeradius/users</code> <br> <br>  Config: <br> <code>steve Cleartext-Password := "testing" <br> Service-Type = Framed-User, <br> Framed-Protocol = PPP, <br> Framed-IP-Address = 10.128.13.3, <br> Framed-IP-Netmask = 255.255.0.0, <br> Framed-Routing = Broadcast-Listen, <br> Framed-Filter-Id = "std.ppp", <br> Framed-MTU = 1500, <br> Framed-Compression = Van-Jacobsen-TCP-IP <br> <b>PPPD-Downstream-Speed-Limit = 1024, <br> PPPD-Upstream-Speed-Limit = 1024 <br></b> <br> #        <br> <br> DEFAULT Framed-Protocol == PPP <br> Framed-Protocol = PPP, <br> Framed-Compression = Van-Jacobson-TCP-IP <br> <br> DEFAULT Hint == "CSLIP" <br> Framed-Protocol = SLIP, <br> Framed-Compression = Van-Jacobson-TCP-IP <br> <br> DEFAULT Hint == "SLIP" <br> Framed-Protocol = SLIP</code> <br> <br>  Now the NAS receives information about the speed, but can not handle them.  We make two scripts that perform the parsing of the transferred attributes when establishing a connection: <br><br>  Run: <br> <code>nano /etc/ppp/ip-up.d/0001shaper</code> <br> <br>  Script: <br> <code>#!/bin/sh <br> /root-scripts/shape-on $1 $5 <br> exit 0</code> <br> <br>  Run: <br> <code>nano /etc/ppp/ip-down.d/0001shaper</code> <br> <br>  Script: <br> <code>#!/bin/sh <br> /root-scripts/shape-off $1 $5 <br> exit 0</code> <br> <br>  As you can see from these listings, some script is called that applies and cancels the shaping.  From this point on - in more detail.  $ 1 is the transferred interface name, that is, ppp0 for example, $ 5 is Framed-IP, that is, the PPP client IP.  Create a coveted directory and put two files into it: <br> <code>mkdir /root-scripts <br> nano /root-scripts/shape-on</code> <br> <br>  Script: <br> <code>#!/bin/sh <br> if [ -f /var/run/radattr.$1 ] <br> then <br> DOWNSPEED=`awk '/PPPD-Downstream-Speed-Limit/ {print $2}' /var/run/radattr.$1` <br> UPSPEED=`awk '/PPPD-Upstream-Speed-Limit/ {print $2}' /var/run/radattr.$1` <br> wondershaper $1 $DOWNSPEED $UPSPEED <br> fi <br> iptables -A FORWARD -s $2 -j ACCEPT <br> iptables -A INPUT -s $2 -j ACCEPT <br> iptables -t nat -A POSTROUTING -s $2 -o eth1 -j MASQUERADE <br></code> <br><br>  Run: <br> <code>nano /root-scripts/shape-off</code> <br> <br>  Script: <br> <code>#!/bin/sh <br> iptables -D FORWARD -s $2 -j ACCEPT <br> iptables -D INPUT -s $2 -j ACCEPT <br> iptables -t nat -D POSTROUTING -s $2 -o eth1 -j MASQUERADE <br></code> <br><br>  Run: <br> <code>chmod +x /root-scripts/*</code> <br> <br>  In eth1 listings, this is still the WAN interface.  So, what we get as a result: The client connects to the PPP server, gets an IP address.  A script is automatically called that configures shaping on the client PPP interface and enables masquerading for it.  When disconnecting the masquerading rule is also removed automatically.  It seems like the wondershaper does not need to be forcibly uncoupled from pppx, in any case, the manuals are silent about this and everything works fine in practice. <br><br><h4>  Simple iptables based protection </h4><br>  Now let's pay a little attention to iptables and server security.  Replace /etc/firewall.conf: <br><br>  Run: <br> <code>nano /etc/firewall.conf</code> <br> <br>  Script: <br> <code>#!/bin/bash <br> <br> #reset all <br> iptables -F <br> iptables -Z <br> iptables -t nat -F <br> iptables -t nat -Z <br> <br> #iface config <br> INET_IFACE="eth1" <br> LO_IFACE="lo" <br> LO_IP="127.0.0.1" <br> <br> #kernel modules <br> modprobe ip_tables <br> modprobe ip_conntrack <br> modprobe iptable_filter <br> modprobe iptable_mangle <br> modprobe iptable_nat <br> modprobe ipt_LOG <br> modprobe ipt_limit <br> modprobe ipt_state <br> modprobe ipt_MASQUERADE <br> modprobe ip_conntrack_ftp <br> modprobe ip_conntrack_irc <br> modprobe ip_nat_ftp <br> modprobe ip_nat_irc <br> <br> #default policy <br> iptables -P INPUT DROP <br> iptables -P OUTPUT DROP <br> iptables -P FORWARD DROP <br> <br> #user chains <br> iptables -N bad_tcp_packets <br> iptables -N allowed <br> iptables -N tcp_packets <br> iptables -N udp_packets <br> iptables -N icmp_packets <br> iptables -N blocksshd <br> blocksshd --start <br> <br> ###bad_tcp_packets chain <br> iptables -A bad_tcp_packets -p tcp --tcp-flags SYN,ACK SYN,ACK -m state --state NEW -j REJECT --reject-with tcp-reset <br> #iptables -A bad_tcp_packets -p tcp ! --syn -m state --state NEW -j LOG --log-prefix "New not syn:" <br> iptables -A bad_tcp_packets -p tcp ! --syn -m state --state NEW -j DROP <br> <br> ###allowed chain <br> iptables -A allowed -p TCP --syn -j ACCEPT <br> iptables -A allowed -p TCP -m state --state ESTABLISHED,RELATED -j ACCEPT <br> iptables -A allowed -p TCP -j DROP <br> <br> ###tcp_packets chain <br> iptables -A tcp_packets -p TCP -s 0/0 --dport 22 -j blocksshd <br> iptables -A tcp_packets -p TCP -s 0/0 --dport 22 -j allowed <br> iptables -A tcp_packets -p TCP -s 0/0 --dport 25 -j allowed <br> #iptables -A tcp_packets -p TCP -s 0/0 --dport 80 -j allowed <br> <br> ###udp_packets chain <br> iptables -A udp_packets -p UDP -s 0/0 --destination-port 53 -j ACCEPT <br> <br> ###icmp chain <br> iptables -A icmp_packets -p ICMP -s 0/0 --icmp-type 8 -j ACCEPT <br> iptables -A icmp_packets -p ICMP -s 0/0 --icmp-type 11 -j ACCEPT <br> <br> ###input chain <br> iptables -A INPUT -p TCP -j bad_tcp_packets <br> iptables -A INPUT -p ALL -i $LO_IFACE -j ACCEPT <br> iptables -A INPUT -p ALL -m state --state ESTABLISHED,RELATED -j ACCEPT <br> iptables -A INPUT -p TCP -i $INET_IFACE -j tcp_packets <br> iptables -A INPUT -p UDP -i $INET_IFACE -j udp_packets <br> iptables -A INPUT -p ICMP -i $INET_IFACE -j icmp_packets <br> #iptables -A INPUT -m limit --limit 3/minute --limit-burst 3 -j LOG --log-level DEBUG --log-prefix "IPT INPUT packet died: " <br> <br> ###forward chain <br> iptables -A FORWARD -p tcp -j bad_tcp_packets <br> #custom rules <br> #iptables -A FORWARD -s 10.128.0.10/32 -d 192.168.1.1/32 -p tcp -j ACCEPT <br> <b>iptables -A FORWARD -s 10.128.0.0/16 -d 192.168.1.1/32 -p tcp -j DROP</b> <br> #/custom rules <br> iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT <br> #iptables -A FORWARD -m limit --limit 3/minute --limit-burst 3 -j LOG --log-level DEBUG --log-prefix "IPT FORWARD packet died: " <br> <br> ###OUTPUT chain <br> iptables -A OUTPUT -p tcp -j bad_tcp_packets <br> iptables -A OUTPUT -p ALL -j ACCEPT <br> #iptables -A OUTPUT -m limit --limit 3/minute --limit-burst 3 -j LOG --log-level DEBUG --log-prefix "IPT OUTPUT packet died: " <br> <br> ###mangle <br> iptables -t mangle -A POSTROUTING -o $INET_IFACE -j TTL --ttl-set 64 <br></code> <br><br>  What do we see here?  First, the highlighted rule.  It will differ in the actual configuration or simply be absent as unnecessary, but the point is this: if the gateway for the server is an ADSL modem or similar device with a web admin area, we do not need to invent clever passwords to enter there.  Instead, we prohibit access to them from client tunnels, but we still allow one thing - it will be a service account with which you can break into it.  Of course, it is not for customers.  Further.  Commands including protection against SSH server bruteforcing have been added.  For their work, you need to configure blocksshd. <br><br><h4>  BlockSSHd </h4><br>  First you need to download it from <a href="http://blocksshd.sourceforge.net/">blocksshd.sourceforge.net</a> and unzip files somewhere.  I used to download wget, but the way - of course - cut from the page of SourceForge, that is, it will most likely be different: <br> <code><a href=""></a> cd /tmp <br> wget downloads.sourceforge.net/project/blocksshd/blocksshd/BlockSSHD%201.3/blocksshd-1.3.tar.gz?use_mirror=kent <br></code> <br><br>  This script is written in Perl and requires some additional modules to work.  So, let's do the modules: <br> <code>cpan <br> upgrade <br> install Sys::Syslog <br> install Sys::Hostname <br> install File::Tail <br> install Tie::File <br> install Net::DNS <br> install Net::Subnets <br> install Getopt::Long <br> exit <br></code> <br><br>  I draw attention to the fact that all this in one fell swoop does not need to copy and paste into the terminal.  This is because each operation takes a lot of time to complete and during the entire installation Cpan will ask questions.  All questions can simply press Enter, there everything is correct by default, oddly enough. <br><br>  Now you need to unpack the blocksshd and install it: <br> <code>cd /tmp <br> tar -xvzf ./blocksshd-1.3.tar.gz <br> cd blocksshd-1.3 <br> make install <br></code> <br><br>  And of course, the version at the time of writing the manual was this one, and maybe any, so you need to carefully do everything and not copy-paste to the console.  It remains to edit the blocksshd configuration: <br><br>  Run: <br> <code>nano /etc/blocksshd.conf</code> <br> <br>  Config: <br> <code>$cfg = { <br> os =&gt; 'linux', # Target OS - either linux or bsd <br> chain =&gt; 'blocksshd', # Name of iptables or pf chain <br> logfile =&gt; '/var/log/secure', # Log file to monitor <br> logcheck =&gt; '10', # How often to check the log file <br> <b>max_attempts =&gt; '4', # Max number of failures</b> <br> timeout =&gt; '360', # Reset IP count if no activity after time out in seconds <br> <b>unblock =&gt; '1', # Enable unblocking <br> unblock_timeout =&gt; '43200', # Time in seconds after which to unblock a blocked IP address <br></b> restore_blocked =&gt; '0', # Turn on checking for previously blocked IPs <br> log_ips =&gt; '/etc/blocksshd.list', # Log file for blocked IPs <br> pid_file =&gt; '/var/run/blocksshd.pid', # Location of PID file <br> <b>send_email =&gt; '0', # Enable the sending of email notifications</b> <br> email =&gt; 'root', # Email address to send notifications <br> mail =&gt; '/bin/mail', # Location of mail binary <br> email_whois_lookup =&gt; '1', # enable whois lookup of the blocked ip addres in the sent email <br> whois =&gt; '/usr/bin/whois', # location of the whois binary <br> sed =&gt; '/bin/sed', # location of the sed binary <br> iptables =&gt; '/sbin/iptables', # Location of iptables binary - only for Linux <br> pfctl =&gt; '/sbin/pfctl', # Location of pfctl binary - only for BSD <br> whitelist =&gt; [qw{ <br> 127.0.0.1/32 <br> }], # whitelist - list of IPs that will never be blocked - IPs must be specified in the form ad$ <br> }; <br> <br> #leave 1; here! <br> 1; <br></code> <br><br>  In this listing you need to pay attention to the selected lines.  The first is the maximum number of attempts to log in from one address, the second is whether it is necessary to unblock a banned ip after the time in seconds specified in the third line has elapsed.  Fourth - whether to notify by email about hacking attempts. <br>  Now you can restart the server and test what happened. <br><br><h4>  Simplest monitoring </h4><br>  For the convenience of monitoring active sessions, you can use a script written ‚Äúon the knee‚Äù.  We will create it and set up a simlink for a simple launch, and of course we will check: <br><br>  Run: <br> <code>nano /root-scripts/clients</code> <br> <br>  Script: <br> <code>#!/usr/bin/php <br> &lt;? <br> function time_since($original) { <br> $chunks = array( <br> array(60 * 60 * 24 , 'D '), <br> array(60 * 60 , 'h:'), <br> array(60 , 'min'), <br> ); <br> $today = time(); <br> $since = $today - $original; <br> for ($i = 0, $j = count($chunks); $i &lt; $j; $i++) { <br> $seconds = $chunks[$i][0]; <br> $name = $chunks[$i][1]; <br> if (($count = floor($since / $seconds)) != 0) { <br> break; <br> } <br> } <br> $print = "$count{$name}"; <br> if ($i + 1 &lt; $j) { <br> $seconds2 = $chunks[$i + 1][0]; <br> $name2 = $chunks[$i + 1][1]; <br> if (($count2 = floor(($since - ($seconds * $count)) / $seconds2)) != 0) { <br> $print .= "$count2{$name2}"; <br> } <br> } <br> return $print; <br> } <br> <br> function execShellCmdRaw($cmd) { <br> ob_start(); <br> passthru($cmd); <br> $buffer = ob_get_contents(); <br> ob_end_clean(); <br> return $buffer; <br> } <br> <br> function rawToArray($buffer) { <br> return empty($buffer)?array():preg_split('/[\r\n]+/', $buffer, -1, PREG_SPLIT_NO_EMPTY); <br> } <br> <br> function execShellCmd($cmd) { <br> return rawToArray(execShellCmdRaw($cmd)); <br> } <br> <br> function getNATSources() { <br> $nat = execShellCmd('iptables -t nat -L | grep MASQUERADE'); <br> $nats = array(); <br> foreach ($nat as $s) { <br> $pos_start = strpos($s, '--') + 2; <br> $pos_end = strpos($s, 'anywhere'); <br> $n = trim(substr($s, $pos_start, $pos_end - $pos_start)); <br> $nats[$n] = $n; <br> } <br> return $nats; <br> } <br> <br> function getTunnelMacAddr($pid) { <br> $pppdc = execShellCmd('ps -p '.$pid.' -f | grep pppd'); <br> $pppdc = $pppdc[0]; <br> $pos_start = strpos($pppdc, '-e ') + 3; <br> $pos_end = strpos($pppdc, '-S \'\''); <br> return trim(substr($pppdc, $pos_start, $pos_end - $pos_start)); <br> } <br> <br> function getPPPTunnels() { <br> $ifc = execShellCmd('ifconfig -a'); <br> $tunnels = array(); <br> $nat = getNATSources(); <br> foreach ($ifc as $i =&gt; $s) { <br> if (substr($s, 0, 3) == 'ppp') { <br> $ppp = array(); <br> $ppp['interface'] = substr($s, 0, 4); <br> $ppp['framed_ip'] = trim(substr($ifc[$i+1], strpos($ifc[$i+1], 'PtP:') + 6, 12)); <br> $RXpos_start = strpos($ifc[$i+6], '(') + 1; <br> $RXpos_end = strpos($ifc[$i+6], ')'); <br> $ppp['tx'] = substr($ifc[$i+6], $RXpos_start, $RXpos_end - $RXpos_start); //TX(user) = RX(server) <br> $tx_sub = substr($ifc[$i+6], $RXpos_end + 1); <br> $TXpos_start = strpos($tx_sub, '(') + 1; <br> $TXpos_end = strpos($tx_sub, ')'); <br> $ppp['rx'] = substr($tx_sub, $TXpos_start, $TXpos_end - $TXpos_start); <br> $ppp['nat'] = array_key_exists($ppp['framed_ip'], $nat)?'on':'off'; <br> $pidf = '/var/run/'.$ppp['interface'].'.pid'; <br> if (file_exists($pidf)) { <br> $ppp['uptime'] = time_since(filemtime($pidf)); <br> $ppp['pid'] = trim(file_get_contents($pidf)); <br> $ppp['mac_addr'] = getTunnelMacAddr($ppp['pid']); <br> $ppp['username'] = 'detectedusername'; <br> $tunnels[] = $ppp; <br> } <br> } <br> } <br> return $tunnels; <br> } <br> <br> function clientTable($tunnels) { <br> printf("\n"); <br> printf(" %15s | ","IP Address"); <br> printf("%20s | ","MAC Address "); <br> printf("%3s | ","NAT"); <br> printf("%16s | ","User name "); <br> printf("%9s | ","TX (up)"); <br> printf("%9s | ","RX (down)"); <br> printf("%11s","Uptime "); <br> printf("\n "); <br> for ($i = 0; $i &lt; 101; $i++) printf("-"); <br> printf("\n"); <br> foreach($tunnels as $tun) { <br> printf(" %15s | ",$tun['framed_ip']); <br> printf("%20s | ",$tun['mac_addr']); <br> printf("%3s | ",$tun['nat']); <br> printf("%16s | ",$tun['username']); <br> printf("%9s | ",$tun['tx']); <br> printf("%9s | ",$tun['rx']); <br> printf("%11s",$tun['uptime']); <br> printf("\n"); <br> } <br> printf("\n"); <br> } <br> <br> function addRadParams(&amp;$tunnels = NULL) { <br> $radusers = rawToArray(file_get_contents('/etc/freeradius/users')); <br> $users = array(); <br> foreach ($radusers as $i =&gt; $s) { <br> if (strpos($s, 'Cleartext-Password') !== FALSE) { <br> $user = array(); <br> $user['username'] = trim(substr($s, 0, strpos($s, 'Cleartext-Password'))); <br> $si = $i + 1; <br> while (strpos($radusers[$si], 'Framed-IP-Address') == FALSE) $si++; <br> $ip_raw = explode('=', $radusers[$si]); <br> $ip_raw = $ip_raw[1]; <br> $users[trim($ip_raw, ' ,')] = $user; <br> } <br> } <br> foreach ($tunnels as $i =&gt; $tun) { <br> $tunnels[$i]['username'] = $users[$tun['framed_ip']]['username']; <br> } <br> return $tunnels; <br> } <br> <br> $t = getPPPTunnels(); <br> addRadParams($t); <br> clientTable($t); <br></code> <br><br>  Run: <br> <code>chmod +x /root-scripts/clients <br> ln -s /root-scripts/clients /usr/bin/clients <br> clients <br></code> <br><br>  We get something like: <br><br> <code>IP Address | MAC Address | NAT | User name | TX (up) | RX (down) | Uptime <br> ----------------------------------------------------------------------------------------------------- <br> 10.128.1.7 | 1:00:19:66:df:39:26 | on | room56 | 507.4 MiB | 445.5 MiB | 16h:31min <br> 10.128.1.3 | 23:00:13:8f:70:30:03 | on | room47 | 8.2 MiB | 137.8 MiB | 1h:14min <br> 10.128.1.5 | 3:00:a1:b0:11:74:cf | on | room50 | 19.2 MiB | 500.2 MiB | 16h:30min <br></code> <br><br>  That's all, our server is ready to use.  According to my observations, I can say that a simple system unit with 1 GB of DDR1 and 2 GHz processor is enough to distribute a 16-megabit channel for 30 users (it was just not needed anymore) and the system does not experience a significant load. <br><br>  Good luck to novice providers! </div><p>Source: <a href="https://habr.com/ru/post/111399/">https://habr.com/ru/post/111399/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111392/index.html">Canobuvosti. The most anticipated games of 2011</a></li>
<li><a href="../111393/index.html">Wrappers for creating classes: evil or good?</a></li>
<li><a href="../111394/index.html">DRM bypass for some applications in the Mac AppStore</a></li>
<li><a href="../111396/index.html">Hosting Center - brazen extortionists</a></li>
<li><a href="../111398/index.html">Creating Packet Tracer Exercises to Prepare for Cisco Certification</a></li>
<li><a href="../111401/index.html">How to design programs and their user interfaces, or DISC theory for ‚Äúnon-licenses‚Äù</a></li>
<li><a href="../111402/index.html">Bicubic interpolation, theory and practical implementation</a></li>
<li><a href="../111404/index.html">Answering machine for calls to Skype for Python</a></li>
<li><a href="../111408/index.html">Creating your own archetypes and directories in Maven</a></li>
<li><a href="../111411/index.html">Habr's favorites in PDF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>