<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Error Handling in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Like many programming languages, Rust encourages the developer to handle errors in a certain way. In general, there are two general error handling app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Error Handling in Rust</h1><div class="post__text post__text-html js-mediator-article"><img align="left" width="256" height="256" src="https://habrastorage.org/getpro/habr/post_images/1ed/ae5/952/1edae5952c9e9a92d9e87d8bc427c953.png"><p>  Like many programming languages, Rust encourages the developer to handle errors in a certain way.  In general, there are two general error handling approaches: using exceptions and via return values.  And Rust prefers return values. </p><br><br><p>  In this article we intend to detail the work with errors in Rust.  Moreover, we will try to immerse ourselves in error handling from various angles time after time, so that at the end you will have a confident practical idea of ‚Äã‚Äãhow all this fits together. </p><br><br><p>  In a naive implementation, error handling in Rust can look verbose and annoying.  We will consider the main stumbling blocks, as well as demonstrate how to make error handling concise and convenient using the standard library. </p><br><a name="habracut"></a><br><h2>  Content </h2><br><p>  This article is very long, mainly because we start from the very beginning - considering the types of sums (sum type) and combinators, and then try to consistently explain the Rust approach to error handling.  So developers who have experience with other expressive type systems can freely jump from section to section. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/270371/">The basics</a> <ul><li>  <a href="https://habr.com/ru/post/270371/">Explanation unwrap</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Option type</a> <ul><li>  <a href="https://habr.com/ru/post/270371/">Combination of values ‚Äã‚Äã&lt;T&gt;</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/270371/">Result type</a> <ul><li>  <a href="https://habr.com/ru/post/270371/">Convert string to number</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Creating a Result nickname</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/270371/">Short digression: unwrap is not necessarily evil</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/270371/">Work with several types of errors</a> <ul><li>  <a href="https://habr.com/ru/post/270371/">Combination Option and Result</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Constraints of combinators</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Premature return</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Macro try!</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Declaring your own type of error</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/270371/">Types from the standard library used for error handling</a> <ul><li>  <a href="https://habr.com/ru/post/270371/">Error type</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Type From</a> </li><li>  <a href="https://habr.com/ru/post/270371/">This macro try!</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Combining your own types of errors</a> </li><li>  <a href="https://habr.com/ru/post/270371/">Recommendations for library authors</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/270371/">Conclusion</a> </li></ul><br><a name="the-basics"></a><h2>  The basics </h2><br><p>  Error handling can be viewed as a <i>varied analysis</i> of whether some calculation was performed successfully or not.  As will be shown later, the key to the convenience of error handling is to reduce the amount of explicit variable analysis that the developer must perform, while keeping the code easily compatible with other code (composability). </p><br><br><p>  <i>(Translator's note: Variable analysis is one of the most commonly used methods of analytical thinking, which is to consider a problem, question, or some situation from the point of view of each possible specific case. At the same time, considering each such case separately is sufficient to solve the initial question.</i> </p><br><br><p>  <i>An important aspect of this approach to solving problems is that such an analysis should be exhaustive.</i>  <i>In other words, when using a variance analysis, <b>all</b> possible cases should be considered.</i> </p><br><br><p> <i>In Rust, variable analysis is implemented using the syntactic construction of <a href="http://kgv.github.io/rust_book_ru/src/match.html"><code>match</code></a> .</i>  <i>At the same time, the compiler guarantees that such analysis will be exhaustive: if the developer does not consider all possible options for the specified value, the program will not be compiled.)</i> </p><br><br><p>  Preserving the compatibility of the code is important, because without this requirement we could just get <a href="http://doc.rust-lang.org/std/macro.panic!.html"><code>panic</code></a> whenever we come across something unexpected.  ( <code>panic</code> causes the current thread to interrupt and, in most cases, terminates the entire program.) Here is an example: </p><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     1  10. //     ,   ,  true. //     false. fn guess(n: i32) -&gt; bool { if n &lt; 1 || n &gt; 10 { panic!(" : {}", n); } n == 5 } fn main() { guess(11); }</span></span></code> </pre><br><p>  If you try to run this code, the program will crash with a message like this: </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">thread</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;main&gt;'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">' : 11'</span></span>, src/bin/panic-simple.rs:<span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><p>  Here is another, less contrived example.  A program that takes a number as an argument doubles its value and prints on the screen. </p><br><br><a name="code-unwrap-double"></a><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> argv = env::args(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = argv.nth(<span class="hljs-number"><span class="hljs-number">1</span></span>).unwrap(); <span class="hljs-comment"><span class="hljs-comment">//  1 let n: i32 = arg.parse().unwrap(); //  2 println!("{}", 2 * n); }</span></span></code> </pre><br><p>  If you run this program without parameters (error 1) or if the first parameter is not an integer number (error 2), the program will end in panic, just as in the first example. </p><br><br><p>  Handling errors in a similar style is like an elephant in a china shop.  The elephant will rush in the direction in which he wants, and destroy everything in its path. </p><br><br><a name="unwrapping-explained"></a><h3>  Explanation <code>unwrap</code> </h3><br><p>  In the previous example, we stated that the program would simply panic if one of the two conditions for the occurrence of an error is fulfilled, although, unlike the first example, there is no explicit <code>panic</code> call in the program code.  However, the <code>panic</code> call is built into the <code>unwrap</code> call. </p><br><br><p>  <code>unwrap</code> in Rust is like saying: ‚ÄúGive me the result of the calculations, and if an error occurs, just panic and stop the program.‚Äù  We could just show the source code of the <code>unwrap</code> function, because it‚Äôs pretty simple, but before that we have to deal with the types <code>Option</code> and <code>Result</code> .  Both of these types have an <code>unwrap</code> method defined for them. </p><br><br><a name="the-option-type"></a><h4>  <code>Option</code> type </h4><br><p>  <code>Option</code> type is <a href="http://doc.rust-lang.org/std/option/enum.Option.html">declared in the standard library</a> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre><br><p>  <code>Option</code> type is a way to express the <i>possibility of the absence of</i> anything using the Rust type system.  Expression of the <i>possibility of absence</i> through a type system is an important concept, since such an approach allows the compiler to require the developer to handle such an absence.  Let's take a look at an example that tries to find a character in a string: </p><br><br><a name="code-option-ex-string-find"></a><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  Unicode- `needle`  `haystack`.    , //      .   `None`. fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { for (offset, c) in haystack.char_indices() { if c == needle { return Some(offset); } } None }</span></span></code> </pre><br><p>  Note that when this function finds the corresponding character, it returns not just <code>offset</code> .  Instead, it returns <code>Some(offset)</code> .  <code>Some</code> is a variant or <i>constructor of a value</i> for type <code>Option</code> .  It can be interpreted as a function of type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code> .  Accordingly, <code>None</code> is also a value constructor, only it has no parameters.  It can be interpreted as a function of type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code> . </p><br><br><p>  It may seem that we made a lot of noise out of nothing, but this is only half the story.  The second half is the <i>use of</i> the <code>find</code> function we wrote.  Let's try to use it to find the extension in the file name. </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_name = <span class="hljs-string"><span class="hljs-string">"foobar.rs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> find(file_name, <span class="hljs-string"><span class="hljs-string">'.'</span></span>) { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   ."</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(i) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">" : {}"</span></span>, &amp;file_name[i+<span class="hljs-number"><span class="hljs-number">1</span></span>..]), } }</code> </pre><br><p>  This code uses <a href="http://kgv.github.io/rust_book_ru/src/patterns.html">pattern matching</a> to perform <i>variable analysis</i> for the <code>Option&lt;usize&gt;</code> value returned by the <code>find</code> function.  In fact, variable analysis is the only way to get to the value stored inside <code>Option&lt;T&gt;</code> .  This means that you, as a developer, are required to handle the case when the <code>Option&lt;T&gt;</code> value is <code>None</code> , not <code>Some(t)</code> . </p><br><br><p>  But wait, what about the <code>unwrap</code> we used <a href="https://habr.com/ru/post/270371/"><code> </code></a> ?  There was no variable analysis!  Instead, the variable analysis was moved inside the <code>unwrap</code> method.  You can do it yourself if you want: </p><br><br><a name="code-option-def-unwrap"></a><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unwrap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>::<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(val) =&gt; val, <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>::<span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"called `Option::unwrap()` on a `None` value"</span></span>), } } }</code> </pre><br><p>  The <code>unwrap</code> method <i>abstracts variable analysis</i> .  This is exactly what makes <code>unwrap</code> convenient to use.  Sorry, <code>panic!</code>  means that <code>unwrap</code> inconvenient to combine with another code: it is an elephant in a china shop. </p><br><br><a name="composing-optiont-values"></a><h4>  Combination of values <code>Option&lt;T&gt;</code> </h4><br><p>  In the <a href="https://habr.com/ru/post/270371/">previous example,</a> we looked at how you can use <code>find</code> to get the file name extension.  Of course, not all file names can be found <code>.</code>  , so there is a possibility that the name of some file does not have an extension.  This <i>absence feature is</i> interpreted at the type level through the use of <code>Option&lt;T&gt;</code> .  In other words, the compiler will force us to consider the possibility that the extension does not exist.  In our case, we just type a message about it. </p><br><br><p>  Getting the file name extension is a fairly common operation, so it makes sense to put the code into a separate function: </p><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,    , //     `.`   . //   `file_name`     `.`,  `None`. fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { match find(file_name, '.') { None =&gt; None, Some(i) =&gt; Some(&amp;file_name[i+1..]), } }</span></span></code> </pre><br><p>  (Hint: do not use this code. Instead, use the <a href="http://doc.rust-lang.org/std/path/struct.Path.html"><code>extension</code></a> method from the standard library.) </p><br><br><p>  The code looks simple, but its important aspect is that the <code>find</code> function makes us consider the probability of missing values.  This is good, because it means that the compiler will not allow us to accidentally forget about the option when the extension is missing in the file name.  On the other hand, every time performing an explicitly variable analysis, just as we did in <code>extension_explicit</code> , can become a bit tedious. </p><br><br><p>  In fact, variable analysis in <code>extension_explicit</code> is a very common pattern: if <code>Option&lt;T&gt;</code> has a certain <code>T</code> value, then convert it using a function, and if not, just return <code>None</code> . </p><br><br><p>  Rust supports parametric polymorphism, so it is very easy to declare a combinator that abstracts this behavior: </p><br><br><a name="code-option-map"></a><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;F, T, A&gt;(option: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;, f: F) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">FnOnce</span></span>(T) -&gt; A { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> option { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(value) =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(f(value)), } }</code> </pre><br><p>  In fact, the <code>map</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html">defined in the standard library</a> as the <code>Option&lt;T&gt;</code> method. </p><br><br><p>  Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method to get rid of the variative analysis: </p><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,    , //     `.`   . //   `file_name`     `.`,  `None`. fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { find(file_name, '.').map(|i| &amp;file_name[i+1..]) }</span></span></code> </pre><br><p>  There is one more behavior that can often be met - this is the use of the default value in the case where the <code>Option</code> value is <code>None</code> .  For example, your program may consider that the file extension is <code>rs</code> if it is actually missing. </p><br><br><p>  It is easy to imagine that this case of alternative analysis is not specific only to file extensions - this approach can work with any <code>Option&lt;T&gt;</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unwrap_or</span></span></span></span>&lt;T&gt;(option: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> option { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(value) =&gt; value, } }</code> </pre><br><p>  The trick is that the default value should be of the same type as the value that can be inside <code>Option&lt;T&gt;</code> .  Using this method is elementary: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(extension(<span class="hljs-string"><span class="hljs-string">"foobar.csv"</span></span>).unwrap_or(<span class="hljs-string"><span class="hljs-string">"rs"</span></span>), <span class="hljs-string"><span class="hljs-string">"csv"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(extension(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>).unwrap_or(<span class="hljs-string"><span class="hljs-string">"rs"</span></span>), <span class="hljs-string"><span class="hljs-string">"rs"</span></span>); }</code> </pre><br><p>  (Note that <code>unwrap_or</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html">declared as an</a> <code>Option&lt;T&gt;</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html">method</a> in the standard library, so we used it instead of the function we declared earlier. Don't forget to also study the more general <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>unwrap_or_else</code></a> method). </p><br><br><p>  There is one more combinator that we think is worth paying special attention to: <code>and_then</code> .  It makes it easy to combine various calculations that allow for the <i>possibility of absence</i> .  An example is most of the code in this section that is associated with the definition of the extension of a given file name.  To do this, we first need to know the name of the file, which is usually extracted from the <i>file path</i> .  Although most file paths contain a file name, this is not the case with <i>all</i> file paths.  An example is the way <code>.</code>  <code>..</code> or <code>/</code> . </p><br><br><p>  Thus, we have defined the task of finding the extension of a given <i>file path</i> .  Let's start with an explicit variable analysis: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_path_ext_explicit</span></span></span></span>(file_path: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> file_name(file_path) { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(name) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> extension(name) { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(ext) =&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(ext), } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_name</span></span></span></span>(file_path: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br><p>  You might think we could just use a <code>map</code> combinator to reduce variable analysis, but its type does not quite fit.  The fact is that <code>map</code> accepts a function that only does something with an internal value.  The result of such a function <i>always</i> <a href="https://habr.com/ru/post/270371/"><code>  Some</code></a> .  Instead, we need a method similar to <code>map</code> , but which allows the caller to pass another <code>Option</code> .  Its general implementation is even simpler than the <code>map</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;F, T, A&gt;(option: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;, f: F) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">FnOnce</span></span>(T) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;A&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> option { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(value) =&gt; f(value), } }</code> </pre><br><p>  Now we can rewrite our function <code>file_path_ext</code> without explicit variable analysis: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_path_ext</span></span></span></span>(file_path: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { file_name(file_path).and_then(extension) }</code> </pre><br><p>  <code>Option</code> type has many other combinators <a href="http://doc.rust-lang.org/std/option/enum.Option.html">defined in the standard library</a> .  It is very useful to review this list and familiarize yourself with the available methods - they will often help you reduce the number of variable analysis.  Familiarization with these combinators will pay off also because many of them are defined with similar semantics for the <code>Result</code> type, which we will discuss later. </p><br><br><p>  Combinators make use of types like <code>Option</code> more convenient, because they reduce the explicit variable analysis.  They also meet the compatibility requirements, as they allow the caller to handle the possibility of no result in their own way.  Methods such as <code>unwrap</code> it impossible, because they will panic when <code>Option&lt;T&gt;</code> is <code>None</code> . </p><br><br><a name="the-result-type"></a><h3>  <code>Result</code> type </h3><br><p>  The type <code>Result</code> also <a href="http://doc.rust-lang.org/std/result/">defined in the standard library</a> : </p><br><br><a name="code-result-def"></a><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span></span>&lt;T, E&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(T), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(E), }</code> </pre><br><p>  Type <code>Result</code> is an advanced version of <code>Option</code> .  Instead of expressing the possibility of <i>absence</i> , as <code>Option</code> does, <code>Result</code> expresses the possibility of <i>error</i> .  As a rule, <i>errors are</i> necessary to explain why the result of a particular calculation was not obtained.  Strictly speaking, this is a more general form of <code>Option</code> .  Consider the following type alias, which in all senses is semantically equivalent to the real <code>Option&lt;T&gt;</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;T, ()&gt;;</code> </pre><br><p>  Here, the second parameter of the <code>Result</code> type <code>Result</code> fixed and defined by <code>()</code> (pronounced as ‚Äúunit‚Äù or ‚Äúempty tuple‚Äù).  Type <code>()</code> has exactly one value - <code>()</code> .  (Yes, this is the type and value of this type, which look the same!) </p><br><br><p>  The <code>Result</code> type is a way to express one of two possible outcomes of a calculation.  By convention, one outcome means the expected result or " <code>Ok</code> ", while the other outcome means an exceptional situation or " <code>Err</code> ". </p><br><br><p>  Like <code>Option</code> , the <code>Result</code> type has an <code>unwrap</code> method <a href="http://doc.rust-lang.org/std/result/enum.Result.html">defined in the standard library</a> .  Let's announce it by ourselves: </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T, E: ::std::fmt::<span class="hljs-built_in"><span class="hljs-built_in">Debug</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;T, E&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unwrap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val) =&gt; val, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>::<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"called `Result::unwrap()` on an `Err` value: {:?}"</span></span>, err), } } }</code> </pre><br><p>  This is actually the same as the <a href="https://habr.com/ru/post/270371/"><code> Option::unwrap</code></a> , except that we added the error value to the <code>panic!</code> message <code>panic!</code>  .  This makes debugging easier, but it forces us to require the parameter type <code>E</code> (which represents our type of error) to implement the <a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> .  Since the vast majority of types must implement <code>Debug</code> , usually in practice this restriction does not interfere.  (Implementing a <code>Debug</code> for some type simply means that there is a reasonable way to print a readable description of the value of this type.) </p><br><br><p>  OK, let's go to the example. </p><br><br><a name="parsing-integers"></a><h4>  Convert string to number </h4><br><p>  The standard library Rust allows elementary to convert strings to integers.  In fact, it is so simple that it is tempting to write something like: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_number</span></span></span></span>(number_str: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-number"><span class="hljs-number">2</span></span> * number_str.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;().unwrap() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = double_number(<span class="hljs-string"><span class="hljs-string">"10"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(n, <span class="hljs-number"><span class="hljs-number">20</span></span>); }</code> </pre><br><p>  Here you should be skeptical about calling <code>unwrap</code> .  If the string cannot be parsed as a number, you will get a panic: </p><br><br><pre> <code class="hljs ruby">thread <span class="hljs-string"><span class="hljs-string">'&lt;main&gt;'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">/home/rustbuild</span></span><span class="hljs-regexp"><span class="hljs-regexp">/src/rust</span></span>-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.<span class="hljs-symbol"><span class="hljs-symbol">rs:</span></span><span class="hljs-number"><span class="hljs-number">729</span></span></code> </pre><br><p>  This is pretty unpleasant, and if something like this happened in the library you use, you might be reasonably angry.  So we should try to handle the error in our function, and let the caller decide what to do with it.  This means the need to change the type that is returned by <code>double_number</code> .  But which one?  To understand this, you need to look at the signature of <a href="http://doc.rust-lang.org/std/primitive.str.html"><code> parse</code></a> from the standard library: </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>&lt;F: FromStr&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;F, F::<span class="hljs-literal"><span class="hljs-literal">Err</span></span>&gt;; }</code> </pre><br><p>  Hmm  At least we know that we must use <code>Result</code> .  It is possible that the method could return <code>Option</code> .  In the end, the string is either parsed as a number or not, is it?  This is, of course, a reasonable way, but the internal implementation knows <i>why the</i> string did not split as an integer.  (This may be an empty string, or incorrect numbers, too large or too short a length, etc.) Thus, using <code>Result</code> makes sense, because we want to provide more information than just ‚Äúabsence‚Äù.  We want to say <i>why the</i> conversion failed.  You should think in a similar way when faced with the choice between <code>Option</code> and <code>Result</code> .  If you can provide detailed error information, then you probably should.  (We'll talk more about this later.) </p><br><br><p>  Good, but how do we write our return type?  The <code>parse</code> method is generic for all different types of numbers from the standard library.  We could (and probably should) also make our function generalized, but for now let's dwell on a specific implementation.  We are only interested in the <code>i32</code> type, so we should <a href="http://doc.rust-lang.org/std/primitive.i32.html"><code>   FromStr</code></a> (do a search in your browser for the string ‚ÄúFromStr‚Äù) and look at its <a href="http://kgv.github.io/rust_book_ru/src/associated-types.html">associated type</a> <code>Err</code> .  We do this to determine the specific type of error.  In this case, this is <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> .  Finally, we can rewrite our function: </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num::ParseIntError; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_number</span></span></span></span>(number_str: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, ParseIntError&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> number_str.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> double_number(<span class="hljs-string"><span class="hljs-string">"10"</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(n, <span class="hljs-number"><span class="hljs-number">20</span></span>), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: {:?}"</span></span>, err), } }</code> </pre><br><p>  Not bad, but we had to write a lot more code!  And we are again annoyed by the variable analysis. </p><br><br><p>  Combinators rush to the rescue!  Like <code>Option</code> , <code>Result</code> has many combinators defined as methods.  There is a large list of combinators common between <code>Result</code> and <code>Option</code> .  And the <code>map</code> is included in this list: </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num::ParseIntError; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_number</span></span></span></span>(number_str: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, ParseIntError&gt; { number_str.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;().map(|n| <span class="hljs-number"><span class="hljs-number">2</span></span> * n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> double_number(<span class="hljs-string"><span class="hljs-string">"10"</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(n, <span class="hljs-number"><span class="hljs-number">20</span></span>), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: {:?}"</span></span>, err), } }</code> </pre><br><p>  All expected methods are implemented for <code>Result</code> , including <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>unwrap_or</code></a> and <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>and_then</code></a> .  In addition, since <code>Result</code> has a second type parameter, there are combinators that only affect the error value, such as <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>map_err</code></a> (analog <code>map</code> ) and <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>or_else</code></a> (analog <code>and_then</code> ). </p><br><br><a name="the-result-type-alias-idiom"></a><h4>  Creating a <code>Result</code> nickname </h4><br><p>  In the standard library, you can often see types like <code>Result&lt;i32&gt;</code> .  But wait, since <a href="https://habr.com/ru/post/270371/"><code>  Result</code></a> with two type parameters.  How can we get around this by pointing out only one of them?  The answer lies in the definition of an alias of the <code>Result</code> type, which <i>fixes</i> one of the parameters with a specific type.  The type of error is usually fixed.  For example, our previous example with converting strings to numbers can be rewritten as: </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num::ParseIntError; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::result; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span></span>&lt;T&gt; = result::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;T, ParseIntError&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_number</span></span></span></span>(number_str: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>(); }</code> </pre><br><p>  Why do we do this?  Well, if we have a lot of functions that can return <code>ParseIntError</code> , then it is much more convenient to define an alias that always uses <code>ParseIntError</code> , so we will not repeat all the time. </p><br><br><p>  The most notable use of this approach in the standard library is the alias <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a> .  As a rule, it is enough to write <code>io::Result&lt;T&gt;</code> to make it clear that you are using a type alias from the <code>io</code> module, and not the usual definition from <code>std::result</code> .  (This approach is also used for <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a> ) </p><br><br><a name="a-brief-interlude-unwrapping-isnt-evil"></a><h3>  Short digression: <code>unwrap</code> is not necessarily evil </h3><br><p>  If you were attentive, you may have noticed that I took a rather tough stance against methods like <code>unwrap</code> that can cause <code>panic</code> and interrupt the execution of your program.  <i>Basically</i> , this is good advice. </p><br><br><p>  Nevertheless, <code>unwrap</code> can still be used wisely.  The factors that justify the use of <code>unwrap</code> are somewhat vague, and reasonable people may disagree with me.  I will summarize my <i>opinion</i> on this issue: </p><br><br><ul><li>  <b>Examples and dirty code.</b>  When you write just an example or a quick script, error handling is simply not required.  For such cases, it is difficult to find something more convenient than <code>unwrap</code> , so here its use is very attractive. </li><li>  <b>Panic indicates an error in the program.</b>  If the logic of your code should prevent certain behavior (say, getting an item from an empty stack), then using <code>panic</code> also acceptable.  The fact is that in this case, a panic will report a bug in your program.  This can occur explicitly, for example from an unsuccessful call <code>assert!</code>  , or occur because the array index is outside the allocated memory. </li></ul><br><p>  This is probably not an exhaustive list.  In addition, when using <code>Option</code> often better to use the <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>expect</code></a> method.  This method does exactly the same as <code>unwrap</code> , except that in case of a panic it will print your message.  This will allow you to better understand the cause of the error, because a specific message will be displayed, and not just ‚Äúcalled unwrap on a <code>None</code> value‚Äù. </p><br><br><p>  My advice comes down to this: use common sense.  There are reasons why words like ‚Äúnever do X‚Äù or ‚ÄúY is considered harmful‚Äù will not appear in this article.     ,    ,  , ,       .      ,        . </p><br><br><p> ,        Rust    <code>unwrap</code> ,     . </p><br><br><a name="working-with-multiple-error-types"></a><h2>      </h2><br><p>          ,       <code>Option&lt;T&gt;</code> ,    <code>Result&lt;T, SomeError&gt;</code> .   ,      <code>Option</code> ,  <code>Result</code> ?      <code>Result&lt;T, Error1&gt;</code>  <code>Result&lt;T, Error2&gt;</code> ?    ‚Äî  <i>   </i> ,          . </p><br><br><a name="composing-option-and-result"></a><h3>  <code>Option</code>  <code>Result</code> </h3><br><p>      ,   <code>Option</code> ,  ,   <code>Result</code> .      ,     ,     . </p><br><br><p> ,        .       <code>Option</code>  <code>Result</code> .        ,     ? </p><br><br><p>            : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> argv = env::args(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = argv.nth(<span class="hljs-number"><span class="hljs-number">1</span></span>).unwrap(); <span class="hljs-comment"><span class="hljs-comment">//  1 let n: i32 = arg.parse().unwrap(); //  2 println!("{}", 2 * n); }</span></span></code> </pre><br><p>      <code>Option</code>  <code>Result</code> ,     ,       ,     ,       . </p><br><br><p>    ,  <code>argv.nth(1)</code>  <code>Option</code> ,     <code>arg.parse()</code>  <code>Result</code> .      .      <code>Option</code>  <code>Result</code> , <i></i>   ‚Äî  <code>Option</code>  <code>Result</code> .   ,     ( <code>env::args()</code> ) ,      .      <code>String</code>   .  Let's try: </p><br><br><a name="code-error-double-string"></a><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_arg</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> argv: env::Args) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { argv.nth(<span class="hljs-number"><span class="hljs-number">1</span></span>) .ok_or(<span class="hljs-string"><span class="hljs-string">"Please give at least one argument"</span></span>.to_owned()) .and_then(|arg| arg.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;().map_err(|err| err.to_string())) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> double_arg(env::args()) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, n), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: {}"</span></span>, err), } }</code> </pre><br><p> c      . -,   <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option::ok_or</code></a> .      <code>Option</code>  <code>Result</code> .      ,     ,   <code>Option</code>  <code>None</code> .     ,   ,    : </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ok_or</span></span></span></span>&lt;T, E&gt;(option: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;, err: E) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;T, E&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> option { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(val) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre><br><p>   ,    ‚Äî <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result::map_err</code></a> .    ,   <code>Result::map</code> ,   ,    <i></i>  <code>Result</code> .   <code>Result</code>  <code>k(...)</code> ,     . </p><br><br><p>   <code>map_err</code> ,           (-   <code>and_then</code> ).     <code>Option&lt;String&gt;</code> ( <code>argv.nth(1)</code> )  <code>Result&lt;String, String&gt;</code> ,     <code>ParseIntError</code>  <code>arg.parse()</code>  <code>String</code> . </p><br><br><a name="the-limits-of-combinators"></a><h3>   </h3><br><p>   IO     ‚Äî   ,   ,       Rust.      IO        . </p><br><br><p>    .    ,          .        <code>2</code>   . </p><br><br><p>         <code>unwrap</code> ,         <code>unwrap</code> .     ,     ,    ,     .    ,     ,        . </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = File::open(file_path).unwrap(); <span class="hljs-comment"><span class="hljs-comment">//  1 let mut contents = String::new(); file.read_to_string(&amp;mut contents).unwrap(); //  2 let n: i32 = contents.trim().parse().unwrap(); //  3 2 * n } fn main() { let doubled = file_double("foobar"); println!("{}", doubled); }</span></span></code> </pre><br><p> (:   <code>AsRef</code>  <a href="http://doc.rust-lang.org/std/fs/struct.File.html"><code>  ,     std::fs::File::open</code></a> .            .) </p><br><br><p>      ,   : </p><br><br><ol><li>    . </li><li>      . </li><li>      . </li></ol><br><p>      <a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> .         <a href="http://doc.rust-lang.org/std/fs/struct.File.html"><code>std::fs::File::open</code></a>  <a href="http://doc.rust-lang.org/std/io/trait.Read.html"><code>std::io::Read::read_to_string</code></a> . ( ,     <a href="https://habr.com/ru/post/270371/"><code>    Result</code></a> ,  .      <code>Result</code> ,  <a href="http://doc.rust-lang.org/std/io/type.Result.html">  </a> ,  ,     <code>io::Error</code> .)     <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> . ,  <code>io::Error</code> <i></i>     .       . </p><br><br><p>     <code>file_double</code> .  ,         ,  <i> </i> ,  -      . ,  ,    <i> </i> ,       .    ,      <code>i32</code> ,          .  ,          <code>i32</code>  - . </p><br><br><p> ,    :    : <code>Option</code>  <code>Result</code> ? , ,      <code>Option</code> .  -    ,      <code>None</code> .   ,  <i> ,   </i> ,      .  ,        .     <i> </i> ,    <code>Result&lt;i32, E&gt;</code> .      <code>E</code> ?     <i></i>  ,       .      <code>String</code> .  ,      : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { File::open(file_path) .map_err(|err| err.to_string()) .and_then(|<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents) .map_err(|err| err.to_string()) .map(|_| contents) }) .and_then(|contents| { contents.trim().parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;() .map_err(|err| err.to_string()) }) .map(|n| <span class="hljs-number"><span class="hljs-number">2</span></span> * n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> file_double(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, n), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">": {}"</span></span>, err), } }</code> </pre><br><p>   .     ,     .       <i>  </i> .       <code>file_double</code>  <code>Result&lt;i32, String&gt;</code> ,      .         : <code>and_then</code> , <code>map</code>  <code>map_err</code> . </p><br><br><p>  <code>and_then</code>       ,      .       ,    :        . ,    <code>and_then</code> . </p><br><br><p>  <code>map</code> ,      <code>Ok(...)</code>  <code>Result</code> . ,    , <code>map</code>   <code>Ok(...)</code> ( <code>i32</code> )  <code>2</code> .      ,     .     <code>map</code> . </p><br><br><p>  <code>map_err</code> ‚Äî  ,     .  ,  ,   <code>map</code> ,   ,     <code>Err(...)</code>  <code>Result</code> .             ‚Äî <code>String</code> .   <code>io::Error</code> ,   <code>num::ParseIntError</code>  <code>ToString</code> ,     <code>to_string</code> ,   . </p><br><br><p>     ,  -  .     ,      .    :  . </p><br><br><a name="early-returns"></a><h3>  <code>return</code> </h3><br><p>            <i> </i> .  <code>return</code>     .     <code>return</code>  <code>file_double</code>  ,        . </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> File::open(file_path) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(file) =&gt; file, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err.to_string()), }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) = file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err.to_string()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> contents.trim().parse() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; n, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err.to_string()), }; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> file_double(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, n), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">": {}"</span></span>, err), } }</code> </pre><br><p> -      ,    ,  ,   ,       ,   ,     .        <code>match</code>  <code>if let</code> .   ,         (   ). </p><br><br><p>     ?   ,       ‚Äî    ,      ,   . ,  <i></i>   .   ‚Äî   . </p><br><br><a name="the-try-macro"></a><h3>  <code>try!</code> </h3><br><p>      Rust ‚Äî   <code>try!</code>  .       ,   ,     ,    <i> </i> .  ,     <i> </i> ,     . </p><br><br><p>     `try!: </p><br><br><a name="code-try-def-simple"></a><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> try { ($e:expr) =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> $e { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val) =&gt; val, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }); }</code> </pre><br><p> ( <a href="http://doc.rust-lang.org/std/macro.try!.html"> </a>   .    ). </p><br><br><p>   <code>try!</code>       .          ,     ,   : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(File::open(file_path).map_err(|e| e.to_string())); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents).map_err(|e| e.to_string())); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(contents.trim().parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;().map_err(|e| e.to_string())); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> file_double(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, n), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">": {}"</span></span>, err), } }</code> </pre><br><p>  <code>map_err</code> - ,  <a href="https://habr.com/ru/post/270371/"><code>  try!</code></a> ,         <code>String</code> .    ,      ,      <code>map_err</code> !     ,      -        . </p><br><br><a name="defining-your-own-error-type"></a><h3>     </h3><br><p>           ,   ,          <code>String</code>      . </p><br><br><p>  <code>String</code>   ,          ,        ,        .   ,   <code>String</code>     . </p><br><br><p>    ,    ,  ,  .        ,        ,          .   ,       <a href="https://habr.com/ru/post/270371/"> </a> . </p><br><br><p>        ,   <code>String</code>  <i> </i> .  ,       ,        ,      .  ,         <code>String</code> ‚Äî    . ,     ,    ,       . (,        ,    ). </p><br><br><p> ,  <code>io::Error</code>     <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a> ,   <i> </i> ,  ,         -.  ,     -     . (,  <code>BrokenPipe</code>    ,      <code>NotFound</code>           .)  <code>io::ErrorKind</code> ,          ,           <code>String</code> . </p><br><br><p>  ,   <code>String</code>            ,      ,      <i> </i> .            ,      . </p><br><br><p>    <i>   </i>     -   <code>enum</code> .   ,     <code>io::Error</code> ,  <code>num::ParseIntError</code> ,      : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-comment"><span class="hljs-comment">//   `Debug` ,   ,     `Debug`. //           CliError #[derive(Debug)] enum CliError { Io(io::Error), Parse(num::ParseIntError), }</span></span></code> </pre><br><p>        .     ,         <code>CliError</code> ,    : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, CliError&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(File::open(file_path).map_err(CliError::Io)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents).map_err(CliError::Io)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(contents.trim().parse().map_err(CliError::Parse)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> file_double(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, n), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">": {:?}"</span></span>, err), } }</code> </pre><br><p>    ‚Äî   <code>map_err(|e| e.to_string())</code> (    )  <code>map_err(CliError::Io)</code>  <code>map_err(CliError::Parse)</code> .  <i> </i>         .  ,  <code>String</code>       ,       <code>enum</code> ,   <code>CliError</code> ,      ,   ,    <i> </i> ,  . </p><br><br><p>     ,       ,   <code>String</code>      ,       .    ,       .  ,               . </p><br><br><a name="standard-library-traits-used-for-error-handling"></a><h2>    ,     </h2><br><p>      ,     <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>  <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a> .   <code>Error</code>       ,   <code>From</code>         . </p><br><br><a name="the-error-trait"></a><h3>  <code>Error</code> </h3><br><p>  <code>Error</code> <a href="http://doc.rust-lang.org/std/error/trait.Error.html">   </a> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt::{<span class="hljs-built_in"><span class="hljs-built_in">Debug</span></span>, Display}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Debug</span></span> + Display { <span class="hljs-comment"><span class="hljs-comment">/// A short description of the error. fn description(&amp;self) -&gt; &amp;str; /// The lower level cause of this error, if any. fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None } }</span></span></code> </pre><br><p>    ,  ,       <i></i> ,    .    ,        .  ,  ,    : </p><br><br><ul><li>       ( <code>Debug</code> ). </li><li>       ( <code>Display</code> ). </li><li>     ( <code>description</code> ). </li><li>     ,    ( <code>cause</code> ). </li></ul><br><p>       ,   <code>Error</code>       <code>Debug</code>  <code>Display</code> .       ,    <code>Error</code> .  <code>rror</code>   ,       ,             <a href="http://kgv.github.io/rust_book_ru/src/trait-objects.html">-</a> (trait object).     <code>Box&lt;Error&gt;</code> ,  <code>&amp;Error</code> . ,  <code>cause</code>  <code>&amp;Error</code> ,     -.      <code>Error</code>  -. </p><br><br><p>      ,   <code>Error</code> .      ,     <a href="https://habr.com/ru/post/270371/"> </a> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-comment"><span class="hljs-comment">//   `Debug` ,   ,     `Debug`. //           CliError #[derive(Debug)] enum CliError { Io(io::Error), Parse(num::ParseIntError), }</span></span></code> </pre><br><p>          :    I      .        ,  ,        <code>enum</code> . </p><br><br><p>  <code>Error</code>          : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::error; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> fmt::Display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CliError { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       `Display`, //        CliError::Io(ref err) =&gt; write!(f, "IO error: {}", err), CliError::Parse(ref err) =&gt; write!(f, "Parse error: {}", err), } } } impl error::Error for CliError { fn description(&amp;self) -&gt; &amp;str { //       `Error`, //        match *self { CliError::Io(ref err) =&gt; err.description(), CliError::Parse(ref err) =&gt; err.description(), } } fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; { match *self { //        `err` //    (`&amp;io::Error`  `&amp;num::ParseIntError`) //  - `&amp;Error`.        `Error`. CliError::Io(ref err) =&gt; Some(err), CliError::Parse(ref err) =&gt; Some(err), } } }</span></span></code> </pre><br><p>  ,      <code>Error</code> :   <code>description</code>  <code>cause</code>       . </p><br><br><a name="the-from-trait"></a><h3>  <code>From</code> </h3><br><p>  <code>std::convert::From</code>   <a href="http://doc.rust-lang.org/std/convert/trait.From.html"> </a> : </p><br><br><a name="code-from-def"></a><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">From</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(T) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre><br><p>  ,   ?  <code>From</code>  ,       <i></i>   <code></code>  -   (  , ¬´ ¬ª  ,   ,  <code>Self</code> ).     <code>From</code> ‚Äî <a href="http://doc.rust-lang.org/std/convert/trait.From.html">  ,   </a> . </p><br><br><p>    ,   <code>From</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bytes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cow: ::std::borrow::Cow&lt;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>);</code> </pre><br><p> , <code>From</code>      .    ? ,    : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, E: Error + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;E&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Error + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;</code> </pre><br><p>   ,  <i></i> ,   <code>Error</code> ,    - <code>Box&lt;Error&gt;</code> .    ,       . </p><br><br><p>    ,      ,  , <code>io::Error</code> and <code>num::ParseIntError</code> ?     <code>Error</code> ,     <code>From</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::error::Error; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-comment"><span class="hljs-comment">//    let io_err: io::Error = io::Error::last_os_error(); let parse_err: num::ParseIntError = "not a number".parse::&lt;i32&gt;().unwrap_err(); // ,  let err1: Box&lt;Error&gt; = From::from(io_err); let err2: Box&lt;Error&gt; = From::from(parse_err);</span></span></code> </pre><br><p>      .  <code>err1</code>  <code>err2</code>  <i> </i> ‚Äî -.  ,       ,       <code>err1</code>  <code>err2</code>   .  ,   <code>err1</code>  <code>err2</code> ,        ‚Äî <code>From::from</code> .    ,   <code>From::from</code>       . </p><br><br><p>      ,      ,           ,    . </p><br><br><p>        ‚Äî  <code>try!</code>  . </p><br><br><a name="the-real-try-macro"></a><h3>   <code>try!</code> </h3><br><p>       <code>try!</code>  : </p><br><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> try { ($e:expr) =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> $e { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val) =&gt; val, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }); }</code> </pre><br><p>     .      <a href="http://doc.rust-lang.org/std/macro.try!.html"> </a> : </p><br><br><a name="code-try-def"></a><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> try { ($e:expr) =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> $e { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(val) =&gt; val, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(::std::convert::<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from(err)), }); }</code> </pre><br><p>    ,    :      <code>From::from</code> .    <code>try!</code>   ,          . </p><br><br><p>     <code>try!</code> ,    ,   ,         : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(File::open(file_path).map_err(|e| e.to_string())); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents).map_err(|e| e.to_string())); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(contents.trim().parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;().map_err(|e| e.to_string())); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n) }</code> </pre><br><p>   ,       <code>map_err</code> .   ,        ‚Äî   ,    <code>From</code> .      , <code>From</code>  ,        <code>Box&lt;Error&gt;</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::error::Error; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Error&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(File::open(file_path)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(contents.trim().parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;()); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n) }</code> </pre><br><p>        .        -  ,   <code>try!</code>    : </p><br><br><ol><li>  . </li><li>  . </li><li>   . </li></ol><br><p>       ,   ,    ,  <code>unwrap</code>    . </p><br><br><p>     :  <code>Box&lt;Error&gt;</code> <i>   </i> .    <code>Box&lt;Error&gt;</code>  ,    ()    . , , ,   <code>String</code> ,     ,  <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>description</code></a>  <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>cause</code></a> ,   : <code>Box&lt;Error&gt;</code>       . (:    ,   Rust      ,     ,    <a href="https://crates.io/crates/error">    </a> ). </p><br><br><p>        <code>CliError</code>      . </p><br><br><a name="composing-custom-error-types"></a><h3>     </h3><br><p>        <code>try!</code>  ,           <code>From::from</code> .        <code>Box&lt;Error&gt;</code> ,  ,       . </p><br><br><p>   ,   ,     :    .   ,          : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::{<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, Read}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-comment"><span class="hljs-comment">//   `Debug` ,   ,     `Debug`. //           CliError #[derive(Debug)] enum CliError { Io(io::Error), Parse(num::ParseIntError), } fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; { let mut file = try!(File::open(file_path).map_err(CliError::Io)); let mut contents = String::new(); try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io)); let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse)); Ok(2 * n) }</span></span></code> </pre><br><p>  ,        <code>map_err</code> .  Why?   <a href="https://habr.com/ru/post/270371/"><code>try!</code></a>  <a href="https://habr.com/ru/post/270371/"><code>From</code></a> .   ,      <code>From</code> ,      <code>io::Error</code>  <code>num::ParseIntError</code>     <code>CliError</code> .      !     <code>CliError</code> ,        <code>From</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;io::Error&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CliError { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(err: io::Error) -&gt; CliError { CliError::Io(err) } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;num::ParseIntError&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CliError { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) } }</code> </pre><br><p>     <code>From</code>   <code>CliError</code>    .           . <i> </i> ,    . </p><br><br><p> ,    <code>file_double</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_double</span></span></span></span>&lt;P: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, CliError&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(File::open(file_path)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> contents)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(contents.trim().parse()); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span> * n) }</code> </pre><br><p> ,    ‚Äî    <code>map_err</code> .     ,   <code>try!</code>  <code>From::from</code>   .   ,     <code>From</code>    ,   . </p><br><br><p>       <code>file_double</code>  ,     -  , ,       ,            : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CliError</span></span></span></span> { Io(io::Error), ParseInt(num::ParseIntError), ParseFloat(num::ParseFloatError), }</code> </pre><br><p>      <code>From</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::num; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;num::ParseFloatError&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CliError { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(err: num::ParseFloatError) -&gt; CliError { CliError::ParseFloat(err) } }</code> </pre><br><p>  That's all! </p><br><br><a name="advice-for-library-writers"></a><h3>     </h3><br><p>        ,          .           ( <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a> ),     ( <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a> ).   ,   ,               . , ,      . </p><br><br><p>  ,       <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> .          <a href="https://habr.com/ru/post/270371/"> </a> .   <code>Error</code>  ,         (     <code>fmt::Debug</code>  <code>fmt::Display</code> ). </p><br><br><p>  ,     <code>From</code>    .    (  )    <a href="https://habr.com/ru/post/270371/">   </a> . , <a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>  <code>From</code>  <code>io::Error</code>  <code>byteorder::Error</code> . </p><br><br><p> ,   ,     <a href="https://habr.com/ru/post/270371/"><code>  Result</code></a> , ,         .        <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>  <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a> . </p><br><br><a name="the-short-story"></a><h2>  Conclusion </h2><br><p>     ,           Rust.      .   <i></i> .      ,      . </p><br><br><ul><li>      ,      , , ,    <code>unwrap</code> (- <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result::unwrap</code></a> , <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option::unwrap</code></a>  <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option::expect</code></a> ). ,    ,  ,      . ( ,   !) </li><li>     ,     <code>unwrap</code> .   :       ,  ,  -   -    ! </li><li>     ,   -  -  <code>unwrap</code> ,   <code>String</code>    ,  <code>Box&lt;Error + Send + Sync&gt;</code> (- <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>  From</code></a> .) </li><li>   ,         <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>  <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> ,   <a href="http://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a>  . </li><li>          ,         <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> . ,   ,  <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> ,          . (-    Rust,       <code>From</code>   ,      .) </li><li>  ,   <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>  <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> .  ,       ,           <code>try!</code>   ( <code>and_then</code> , <code>map</code>  <code>unwrap_or</code> ‚Äî  ). </li></ul><br><p> <i>            ¬´The Rust Programming Language¬ª.        <a href="http://kgv.github.io/rust_book_ru/"></a> .  ,      ,   Rust,      <a href="https://gitter.im/ruRust/general">   Rust</a> .</i> </p></div><p>Source: <a href="https://habr.com/ru/post/270371/">https://habr.com/ru/post/270371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270361/index.html">Animation of transitions between two fragments</a></li>
<li><a href="../270363/index.html">Game with a list of conditions</a></li>
<li><a href="../270365/index.html">Evaluation of test coverage on the project</a></li>
<li><a href="../270367/index.html">How I won the Beeline BigData Contest</a></li>
<li><a href="../270369/index.html">Using websocket in Extjs applications</a></li>
<li><a href="../270373/index.html">Impact analysis on the example of corporate data warehouse infrastructure</a></li>
<li><a href="../270377/index.html">Magento 2.0 Release Candidate Released</a></li>
<li><a href="../270379/index.html">Half a Century to "Universal Machine Languages" (1966‚Äì2016): Past, Present, Future</a></li>
<li><a href="../270381/index.html">TvOS application development</a></li>
<li><a href="../270383/index.html">Java Programmer Cheat Sheet 4. Java Stream API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>