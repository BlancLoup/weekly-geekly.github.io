<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Attackers exploit a vulnerability in the Ksoft Uploader software! for installing Gh0st RAT</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our analysts receive for analysis thousands of new malware samples every day and among this general flow, it is possible to find curious instances. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Attackers exploit a vulnerability in the Ksoft Uploader software! for installing Gh0st RAT</h1><div class="post__text post__text-html js-mediator-article">  Our analysts receive for analysis thousands of new malware samples every day and among this general flow, it is possible to find curious instances.  In this case, it is not even about the executable file, but about the data file, which is the configuration file of a legitimate application.  Such a file and fell into our hands. <br><br><img src="https://habrastorage.org/files/c35/61b/51f/c3561b51f93e4b69b4dac674f1291827.jpeg"><br><br>  Further analysis of the suspicious file showed that it is malicious and leads to a vulnerability in the product Uploader!  Ksoft company.  Below are the details of the exploit and a brief description of its payload. <br><a name="habracut"></a><br>  The exploit itself, that is, the specially configured configuration file of the specified software that we found, uses a buffer overflow ( <i>BufferOv</i> ) vulnerability for its work.  Program Uploader!  Designed for user experience with FTP protocol.  Its settings such as the address of the remote FTP host and the user name are stored in the configuration file referred to as uploadpref.dat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The PoC code for this exploit was <a href="https://www.exploit-db.com/exploits/32050/">published</a> back in March 2014. <br><br>  Uploader tool configuration file!  consists of a set of lines, which includes a line with the name of the user and the name of the target host server to upload (upload) files.  For processing the file data and its subsequent parsing, the application uses a standard C ++ incoming stream called <i>std :: ifstream</i> .  When reading lines from a file, the application correctly checks the size using the C ++ functions <i>in_stream.get (buffer, sizeof (buffer), '\ n')</i> .  However, the application code processing the last field in the file with an encrypted password uses the <i>in_stream &gt;&gt; buffer</i> code, with the buffer array located on the stack.  In the event that the application does not call the <i>in_stream.width (...)</i> function, the <i>in_stream &gt;&gt; buffer</i> call will fill the buffer buffer on the stack until the end of the file or the white space character is reached. <br><br><img src="https://habrastorage.org/files/11b/259/de3/11b259de3d8e4a1d8f982bfd8ebd88b3.png"><br>  Fig.  The vulnerability is present in the <i>in_stream &gt;&gt; encrypted_password</i> call, which allows the exploit to overflow the buffer on the stack and execute the necessary code. <br><br>  ESET specialists promptly contacted the developers of this software and informed them about the found vulnerability.  Within 24 hours, Ksoft experts fixed the vulnerability and released a new version of the Uploader!  v 3.6. <br><br>  The malicious file uploadpref.dat analyzed by us causes the program to copy the required amount of data onto the stack and overflow the buffer whose size is fixed and is 80 bytes.  As a result of overwriting the data placed in front of the buffer variable, the exploit damages the frame structure (Structured Exception Handler) SEH and places the shellcode there, as well as a pointer to it in the frame.  Copying data to an overflowed buffer is stopped by an exception (exception), which signals that the top of the stack has been reached and that it has been addressed at an unacceptable address in the memory (access violation).  As a result of the exception that occurred, Windows calls the pointer function from the SEH frame, which has already been overwritten by the exploit.  This new address points to the gadget with the code from the address space of the Uploader! .. The gadget is a set of instructions <i>pop ecx;</i>  <i>pop ecx;</i>  <i>ret</i> .  After these instructions are executed, the execution flow is transferred to the first shell code of the exploit, which is already located on the stack. <br><br><img src="https://habrastorage.org/files/7a5/633/9db/7a56339db04d450bb67c5b2023cd49de.png"><br>  Fig.  View from the debugger of the situation of triggering an exception in case of violation of memory access on the stack.  In the command window you can see the instructions of the gadget, from which control is transferred to the shell code. <br><br>  The method of rewriting SEH handlers is already quite ancient and was described in detail by the Corelan Team team on their <a href="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh">website</a> .  Windows Vista SP1 + operating systems contain a special function called Structured Exception Handling Overwrite Protection (SEHOP), which protects applications from illegitimate rewriting of SEH handlers at the OS level.  This feature is disabled by default on client editions of Windows and enabled by default on server editions.  Enabling such a function on client editions of Windows can be performed using the EMET tool or this <a href="https://support.microsoft.com/en-us/kb/956607">instruction</a> .  In addition, support for the SEHOP mechanism should be provided by the application itself, which must be linked using the / SAFESEH option (not present in the Uploader!). <br><br>  The exploit is based on the PoC volume, the link to which we cited above, it contains similar sequences of <i>pop</i> commands <i>;</i>  <i>pop;</i>  <i>ret</i> at the beginning of the file.  In the case of the original PoC, there are significantly more of them and there are a total of 178 teams.  Other parts of the exploit, such as the shellcode and its execution levels, were added by the authors themselves. <br><br><img src="https://habrastorage.org/files/4f7/742/6b6/4f77426b6d1e4035856746284010413b.png"><br>  Fig.  Header uploadpref.dat from poc. <br><br><img src="https://habrastorage.org/files/e4f/e97/841/e4fe9784114143278e0977186e4709b9.png"><br>  Fig.  Header uploadpref.dat from the exploit. <br><br>  Before launching the payload, the exploit needs to perform several steps of its code. <br><br>  At stage zero (Stage 0), the shellcode takes control from the SEH handler code, which points to a gadget with a sequence of instructions <i>pop ecx;</i>  <i>pop ecx;</i>  <i>ret</i> .  The first <i>shellcode</i> instructions unpack the code of the next level ( <i>shell_code_1</i> ).  It calculates a single-byte value from a two-byte word and writes it to the same memory location. <br><br><img src="https://habrastorage.org/files/c4e/1d6/668/c4e1d66684144c21bef1c55c3afd1b8b.png"><br>  Fig.  The unpacking code for the subsequent shellcode part. <br><br>  At the end of the first level (Stage 1) the contents of the entire uploadpref.dat file will be copied into memory.  For this purpose, the shellcode uses the Windows API functions, obtaining their addresses by analyzing the export tables of the corresponding Windows system libraries directly.  The function is searched based on the calculated hash of its name.  The hash is calculated by summing each individual hexadecimal representation of the character from the name of the function in lower case and multiplying the intermediate iteration sum by two.  Below is the Python code that implements this algorithm. <br><br><blockquote>  def hash_name (name): <br>  result = 0 <br>  for c in name: <br>  result = 2 * (result + (ord ¬© | 0x60)) <br>  return result </blockquote><br><br>  It is interesting to note that this algorithm for calculating the hash is identical to that specified as an example in the book by Chris Anley and John Heasman entitled "The Shellcoder's Handbook: Discovering and Exploiting Security Holes".  Its implementation in C can be found on page 145 of the second edition of the book. <br><br>  After receiving the corresponding function addresses, the <i>shell_code_1</i> code allocates two buffers in size in memory with the size of the size of the file uploadpref.dat.  The contents of the entire file are copied to one of the buffers, and the second remains intact.  After this, the shellcode transfers control to the code from this file located at offset 0x10 from the beginning of the file.  Below this code is listed in C. <br><br><blockquote>  HANDLE f = CreateFileA (‚Äúuploadpref.dat‚Äù, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0); <br>  DWORD uploadpref_size = GetFileSize (f, 0); <br>  char * memblock1 = VirtualAlloc (NULL, uploadpref_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); <br>  char * memblock2 = VirtualAlloc (NULL, uploadpref_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); <br>  ReadFile (f, memblock1, uploadpref_size); <br>  stage_2 = &amp; memblock1 [0x10]; <br>  stage_2 (&amp; memblock1 [0x650], memblock2); <br>  // the address of the buffer memblock2 is passed to the exploit code as an argument, the exploit will later pass control </blockquote><br><br>  At the second level (Stage 2), the function unpacks data at offset 0x650 from their beginning into the <i>memblock2</i> buffer.  For data decompression, a rather inefficient algorithm is used, after which their size is 3.632 bytes.  After this operation, control is transferred to the beginning of the <i>blocklock2</i> block, which contains the third level shell code (Stage 3). <br><br>  At Stage 3, the exploit code reopens the uploadpref.dat file and extracts the PE file from it, which is located at offset 0x1600.  The file is placed in a dedicated memory buffer.  The decompression algorithm is identical to the one used at the previous level.  After this, the exploit creates a new process in suspend mode, injects the executable file there and launches it.  The PE file extracted from uploadpref.dat is 56.832 bytes in size and specializes in the loading and execution of a Gh0st RAT dropper. <br><br>  The table below shows the structure of the uploadpref.dat file. <br><br><img src="https://habrastorage.org/files/68a/524/aac/68a524aac0d84354a3febdb70dbfc906.png"><br><br>  The downloader copies the original exploit file (uploadpref.dat) and its extracted file called msfeedssync.exe to the current user's Application Data directory.  After that, it creates a shortcut to the executable file and places it in the Start menu autostart directory.  Thus, after the reboot, the exploit will work again and all steps will be executed again. <br><br><img src="https://habrastorage.org/files/93a/1b1/35b/93a1b135b2f14dce8681494c40742ac9.png"><br><br><img src="https://habrastorage.org/files/e20/223/249/e20223249e244eb7b4c43b7f98ba7414.png"><br>  Fig.  A shortcut in the startup folder indicating the execution of the malware file. <br><br>  After performing the above operations, the bootloader is considered to be successfully installed in the system and after a reboot it can successfully perform its main function, which is to download the Gh0st RAT dropper.  Dropper will be downloaded using the HTTP protocol.  To do this, the malware runs at intervals of 30 minutes.  two streams.  Based on the HTTP user-agent string, which each of them uses to work with a remote server, we called the first thread <i>Alan_function</i> , and the second <i>BFunction</i> .  Each of them tries to download the Gh0st RAT dropper from different URLs that use the same domain name.  After downloading the file, it is unpacked, each of the threads tries to call different parts of the dropper code. <br><br><ul><li>  The <i>Alan_function thread</i> expects the uploaded file to be an executable PE file and simply executes it for execution, passing control to the entry point. </li><li>  The <i>BFunction thread</i> expects the uploaded file to be a DLL.  In this case, it will call from it an exported function called <i>TestFunction</i> . </li></ul><br><img src="https://habrastorage.org/files/1d4/39e/426/1d439e42616642dbaca2131bcff5c570.png"><br><br>  We were able to detect the first propagation method of the malware dropper, which was used in March 2015. The executable file downloaded by the daunloader was associated with the daunloader itself, since one of its obfuscation functions included the unpacking code of the dropper DLL file calling the exported function <i>TestFunction</i> .  This library can be delivered to the <i>BFunction</i> thread to achieve the same results. <br><br>  The Gh0st RAT executable file downloaded this way is the dropper of this malicious program.  Gh0st RAT has been previously documented by various researchers of AV companies.  The backdoor network protocol includes a string of five characters to identify a malicious campaign.  In our case, the identifier was the string "A1CEA".  We were able to find the following links providing backdoor information with the same campaign ID. <br><br><ul><li>  A sample that was discovered in December 2013 and was loaded into the <a href="https://malwr.com/analysis/YWQ1YWNlNjhjZDk2NGYzNjg1YjAxYjVkYmIyMmVmNDY/">Malwr</a> database. </li><li>  The Snort Rule that was <a href="https://rules.emergingthreats.net/changelogs/snort-2.9.0.etpro.2015-03-04T00:08:05.txt">added</a> on March 3, 2015 </li><li>  Analysis of a sample of malware on the Korean portal <a href="http://www.wins21.co.kr/blog/blog-sub-01.html%3Ft%3D31%26num%3D53">Wins</a> . </li></ul><br>  In the Gh0st RAT sample we analyzed, the C &amp; C server with the address <a href="http://www.phw2015.com/">www.phw2015.com</a> and the TCP port 2015 was used. At the time of our analysis, the domain corresponded to the IP address 112.67.10.110. <br><br>  This modification of the Gh0st was slightly different from the original backdoor and contained the following functions. <br><br><ul><li>  The function of collecting data on the characteristics of the computer. </li><li>  A special function called ‚ÄúTestFunction‚Äù that loads other malicious components of the backdoor. </li></ul><br>  In the sample analyzed by us, all Gh0st functions were active, including the keylogger. <br><br>  <b>Conclusion</b> <br><br>  The analyzed exploit is not special or even essential, since the Ksoft Uploader! Software for which it is intended is not a widespread application.  We know practically nothing about the purpose for which it was used and by what intruders, like what the vector of its propagation was.  A social engineering method could be used for propagation, but in this case the attack should have been directed, since the attackers should have information on the victim‚Äôs computer‚Äôs presence on the computer.  Anyway, the attackers had to lure a potential victim to download this file, and then also point the user to its use and placement in the directory with the program itself. <br><br>  Gh0st RAT was described in the following studies. <br><br>  Michael G. Spohn (McAfee), Know Your Digital Enemy: Anatomy of a Gh0st RAT, 2012 <br><br>  <a href="http://www.mcafee.com/ca/resources/white-papers/foundstone/wp-know-your-digital-enemy.pdf">www.mcafee.com/ca/resources/white-papers/foundstone/wp-know-your-digital-enemy.pdf</a> <br><br>  Snorre Fagerland (Norman), The many faces of Gh0st Rat, 2012 <br><br>  <a href="http://download01.norman.no/documents/ThemanyfacesofGh0stRat.pdf">download01.norman.no/documents/ThemanyfacesofGh0stRat.pdf</a> <br><br>  <b>Compromise Identifiers (IoC)</b> <br><br><img src="https://habrastorage.org/files/775/794/c32/775794c3210743afa9a64ac5d97ac8fb.png"><br><br>  The backdoor uses a mutex with the following name: <br><br>  <a href="http://www.phw2015.comwww.phw2015.comwww.phw2015.com/">www.phw2015.com www.phw2015.com www.phw2015.com</a> <br><br><img src="https://habrastorage.org/files/ac2/342/8dc/ac23428dcb6442dd9eaa98f189c0b2b6.png"></div><p>Source: <a href="https://habr.com/ru/post/269751/">https://habr.com/ru/post/269751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269739/index.html">Conference on web analytics and internet marketing CONVERT.2015 will be held in Yekaterinburg on December 7</a></li>
<li><a href="../269741/index.html">Swift + VK.API, or the story of SwiftyVK</a></li>
<li><a href="../269743/index.html">We continue to fight the frontend-routine</a></li>
<li><a href="../269745/index.html">Learning machine learning</a></li>
<li><a href="../269747/index.html">Why google voice neural nets search?</a></li>
<li><a href="../269753/index.html">Testing the functionality of Symantec Backup Hot-Add. Increased speed of copying and restoring data</a></li>
<li><a href="../269755/index.html">Control modes using the mouse and the touch screen in Windows 10 and Windows 8</a></li>
<li><a href="../269757/index.html">The book "Minecraft. Program your world "</a></li>
<li><a href="../269759/index.html">Pytest</a></li>
<li><a href="../269761/index.html">What's New: 3 technological trends in algorithmic trading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>