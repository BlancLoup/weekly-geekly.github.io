<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.3 - Hello Window</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last lesson we prepared a workspace and now we are fully ready to create a window. 
 This translation was prepared jointly with FERusM for whic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.3 - Hello Window</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  In the last lesson we prepared a workspace and now we are fully ready to create a window. <br>  This translation was prepared jointly with <a href="https://habr.com/users/ferusm/" class="user_link">FERusM</a> for which many thanks to him. <br>  Interested please under the cat. <br><a name="habracut"></a><br><cut></cut><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">3D model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br>  Part 5. Advanced Lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  <a href="https://habr.com/post/354208/">Omnidirectional shadow maps</a> </li></ol><br></div></div><br><h1>  Part 1.3.  Hello window </h1><br>  After installing <b>GLFW, it</b> 's time to make a simple program, as is customary in such materials, let it be Hello World.  First you need to create a .cpp file and connect several headings, you also need to set the variable <b>GLEW_STATIC</b> , which indicates that we will use the static version of the <b>GLEW</b> library. <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ GLEW    GLFW. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ GLEW #define GLEW_STATIC #include &lt;GL/glew</span></span>.h&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> GLFW <span class="hljs-comment"><span class="hljs-comment">#include &lt;GLFW/glfw3.h&gt;</span></span></code> </pre> <br><blockquote>  Make sure that GLEW is connected before GLFW.  The GLEW header file contains the connection of all the necessary OpenGL header files, such as <b>GL / gl.h</b> </blockquote><br><blockquote>  <b>Translator's Note</b> <br>  As <a href="https://habr.com/users/truebers/" class="user_link">TrueBers</a> noted <a href="https://habr.com/users/truebers/" class="user_link">,</a> this is supposedly just an outdated crutch and modern versions of GLFW themselves connect the required libraries, however, if the <i>GLFW_INCLUDE_NONE</i> flag is not set, and by default it is not declared. </blockquote><br>  Next, write the function main, so far it will create a GLFW window.  It will look like this: <br><br><pre> <code class="hljs ruby">int main() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> GLFW glfwInit(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> GLFW /<span class="hljs-regexp"><span class="hljs-regexp">/    OpenGL. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); return 0; }</span></span></code> </pre><br>  In this function, we first initialize <b>GLFW by</b> calling the function <b>glfwInit</b> , then proceed to configure it using the function <b>glfwWindowHint</b> .  <b>glfwWindowHint</b> has a very simple signature, the first argument is to pass the identifier of the parameter that is being changed, and the second parameter is the value that is set to the corresponding parameter.  Parameter identifiers, as well as some of their values, are in a common listing with the <b>GLFW_</b> prefix.  More details on setting the GLFW context can be found in the <a href="http://www.glfw.org/docs/latest/window.html">official <b>GLFW</b> documentation</a> .  If when you run this example, you get errors that are very similar to undefined behavior, it means that you have incorrectly connected the GLFW library. <br><br>  Since the articles will use OpenGL version 3.3, you need to tell GLFW that we are using this version, which happens as a result of calling the glfwWindowHint method with arguments: <br><br><pre> <code class="cpp hljs">GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number"><span class="hljs-number">3</span></span> GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Thus, GLFW takes all the necessary steps when creating an OpenGL context.  This ensures that if the user does not have the required version of OpenGL (in this case, version 3.3 is being considered), then GLFW will simply not start.  In addition to the installation version, we clearly indicated that we will use the profile <b>GLFW_OPENGL_CORE_PROFILE</b> .  This will result in an error when using legacy OpenGL functions.  If you are using Mac OS X, you must add the following function call <b>glfwWindowHint (GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</b> to the GLEW initialization code. <br><blockquote>  Make sure that your hardware supports OpenGL version 3.3 and above and that the corresponding version of OpenGL is installed in the OS.  To find out the version of OpenGL on your Linux computer, use glxinfo in the console.  For Windows, you can use the <a href="http://download.cnet.com/OpenGL-Extensions-Viewer/3000-18487_4-34442.html">OpenGL Extension Viewer</a> .  If the OpenGL version is lower than necessary, make sure your hardware supports it and / or try updating the drivers. </blockquote><br>  Now we need to create a window object.  This object contains all the necessary information about the window and is used by GLFW functions. <br><br><pre> <code class="hljs cpp">GLFWwindow* window = glfwCreateWindow(<span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-string"><span class="hljs-string">"LearnOpenGL"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Failed to create GLFW window"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; glfwTerminate(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } glfwMakeContextCurrent(window);</code> </pre><br>  The signature of the function glfwCreateWindow requires the following arguments: ‚ÄúWindow height‚Äù, ‚ÄúWindow width‚Äù, ‚ÄúWindow name‚Äù (we will not need the remaining arguments).  Returns a pointer to an object of type GLFWwindow, which we will need later.  Next, we create a window context, which will be the main context in this thread. <br><br><h2>  GLEW </h2><br>  In the last lesson we said that GLEW manages pointers to OpenGL functions, so we must initialize GLEW before calling any OpenGL functions. <br><br><pre> <code class="hljs cpp">glewExperimental = GL_TRUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (glewInit() != GLEW_OK) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Failed to initialize GLEW"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Notice that we set the <i>glewExperimental</i> variable to <b>GL_TRUE</b> before initializing GLEW.  Setting the value of <i>glewExperimental</i> to <b>GL_TRUE</b> allows GLEW to use the latest techniques to control OpenGL functionality.  Also, if you leave this variable with the default value, you may experience problems using the Core-profile mode. <br><br><h2>  Viewport </h2><br>  Before we begin to draw anything, we need to do something else.  We need to tell OpenGL the size of the window being drawn, so that OpenGL knows how we want to display data and coordinates relative to the window.  We can set these values ‚Äã‚Äãthrough the <b>glViewport</b> function. <br><br><pre> <code class="hljs vhdl">int <span class="hljs-literal"><span class="hljs-literal">width</span></span>, height; glfwGetFramebufferSize(window, &amp;<span class="hljs-literal"><span class="hljs-literal">width</span></span>, &amp;height); glViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">width</span></span>, height);</code> </pre><br>  The first 2 arguments to <b>glViewport</b> are the position of the bottom left corner of the window.  The third and fourth are the width and height of the rendered window in px, which we get directly from GLFW.  Instead of manually setting the widths and heights of 800 and 600, respectively, we will use the values ‚Äã‚Äãfrom GLFW, since this algorithm also works on screens with high DPI (like Apple Retina). <br><br>  We can also set smaller values ‚Äã‚Äãfor the viewport.  In this case, all rendered information will be smaller, and we will be able, for example, to draw another part of the application outside the viewport. <br><blockquote>  Behind the scenes, OpenGL uses data passed through <b>glViewport</b> to convert 2D coordinates to screen coordinates.  For example, the position <b>(-0.5, 0.5)</b> as a result will be converted to <b>(200, 450).</b>  Notice that the OpenGL coordinates being processed are in the range from -1 to 1, respectively, we can effectively convert from (-1, 1) to (0.800) and (0.600). </blockquote><br><h2>  We prepare the engines </h2><br>  We do not want the application to fall immediately after rendering one image.  We want the program to continue to render the images and process user input until it is closed.  To do this, we need to create a loop called the <i>game loop</i> , which will be processed until we tell GLFW to stop. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!glfwWindowShouldClose(<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>)) { glfwPollEvents(); glfwSwapBuffers(<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>); }</code> </pre><br>  The function <b>glfwWindowShouldClose</b> checks at the beginning of each iteration of the cycle whether GLFW received a close instruction, if so, the function will return true and the game loop will stop working, after which we will be able to close our application. <br><br>  The <b>glfwPollEvents</b> function checks whether any events were triggered (such as keyboard input or mouse movement) and calls the installed functions (which we can set via callback functions).  Usually we call the event-handling functions at the beginning of the loop iteration. <br><br>  The <b>glfwSwapBuffers</b> function replaces the color buffer (a large buffer containing color values ‚Äã‚Äãfor each pixel in the GLFW window) that was used for drawing during the current iteration and shows the result on the screen. <br><blockquote>  <b>Double buffering</b> <br>  When an application draws to a single buffer, the resulting image may flicker.  The reason for this behavior is that the drawing is not instantaneous, but pixel by pixel from the top left, right down.  Since the image is not displayed instantly, but gradually, it can have a lot of artifacts.  To avoid these problems, windowing applications use double buffering.  <b>The front buffer</b> contains the resulting image displayed to the user; at the same time, the <b>rear buffer</b> is being drawn.  As soon as the drawing is finished, these buffers are swapped and the image is displayed to the user at the same time. </blockquote><br><h2>  Something else </h2><br>  As soon as we are out of the game cycle, we need to clear the resources allocated to us.  This is done with the <b>glfwTerminate</b> function at the end of the main function. <br><br><pre> <code class="hljs kotlin">glfwTerminate(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  This code will clear all resources and exit the application.  Now, try building the application and if there are no problems with this, you will see the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7f7/29d/870/7f729d870ef0474c9b99882c31f86a38.png"></div><br>  If you have the most boring black picture, then you did everything right!  If you draw something else or you have problems connecting all the examples in the lesson, then try this source code. <br><br>  If you have problems building the application, first of all, make sure that the linker in your IDE is configured correctly (as described in the last lesson).  Also make sure your code has no errors.  You can easily compare it with the source code presented above.  If you still have problems, review the comments on the original article, maybe there you will find a solution to your problem. <br><br><h2>  Input </h2><br>  To achieve some control over input, we can use callback functions in GLFW.  Callback functions are pointers to functions that can be passed to GLFW so that they are called at the right time.  One of these functions is <b>KeyCallback</b> , which will be called each time the user uses the keyboard.  The prototype of this function is as follows: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">key_callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GLFWwindow* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scancode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  This function takes as its first argument a pointer to the GLFWwindow, then comes the number describing the key pressed, the action performed on the key, and the number describing the modifiers (shift, control, alt or super).  When the key is pressed, GLFW will call this function and pass the required arguments to it. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> key_callback(GLFWwindow* <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> key, <span class="hljs-type"><span class="hljs-type">int</span></span> scancode, <span class="hljs-type"><span class="hljs-type">int</span></span> action, <span class="hljs-type"><span class="hljs-type">int</span></span> mode) { //    ESC,    WindowShouldClose  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>, GL_TRUE); }</code> </pre><br>  In our (new) <b>key_callback</b> function, we check whether the key pressed is the ESC key and if it was clicked (not released), then we close the GLFW by setting the WindowShouldClose property to true using glfwSetWindowShouldClose.  The next state loop check will break the loop and the application will close. <br><br>  It remains only to transfer this function to GLFW.  This is done as follows: <br><br><pre> <code class="hljs lisp">glfwSetKeyCallback(<span class="hljs-name"><span class="hljs-name">window</span></span>, key_callback)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  There are a large number of callback functions that can be overridden.  For example, we can override functions for window resizing, error handling, etc.  Register the callback function is necessary after creating the window and before the game cycle. <br><br><h2>  Drawing </h2><br>  We would like to place all the drawing commands in the game loop, since we want the drawing to take place at each iteration of the cycle.  It should look something like this: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   while(!glfwWindowShouldClose(window)) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . glfwPollEvents(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    glfwSwapBuffers(window); }</span></span></code> </pre><br>  To just make sure that everything works as it should, we will clear the screen, filling it with our own color.  At the beginning of each iteration of rendering, it is often necessary to clear the screen, otherwise we will see the results of past rendering (sometimes you really need to achieve this effect, but often this is not so).  We can easily clear the buffer using <b>glClear</b> , into which we will pass special bits to indicate which particular buffers need to be cleared.  The bits we can set now are <b>GL_COLOR_BUFFER_BIT</b> , <b>GL_DEPTH_BUFFER_BIT,</b> and <b>GL_STENCIL_BUFFER_BIT</b> .  Now we need to clear only the color buffer. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">glClearColor</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.2f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.3f</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.3f</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glClear</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_COLOR_BUFFER_BIT</span></span>);</code> </pre><br>  Notice that we also set the color we <b>want</b> , which will clear the screen, via <b>glClearColor</b> .  As soon as we call <b>glClear, the</b> entire buffer will be filled with the specified color.  In the result, you get a green-blue color. <br><br><blockquote>  As you can see, <b>glClearColor</b> is a state <i>setting</i> function, and <b>glClear</b> is a state function that uses state to determine the fill color of a screen. </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e67/d9c/703/e67d9c70334545d9b1754d92014de9cb.png"></div><br>  The complete lesson source code can be found <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/hellowindow2">here</a> . <br><br>  Now we have everything to start filling the game loop with calls to the rendering functions, but we will save it for the next lesson. </div><p>Source: <a href="https://habr.com/ru/post/311234/">https://habr.com/ru/post/311234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311220/index.html">Programming & Music: we understand and write VSTi synthesizer on C # WPF. Part 1</a></li>
<li><a href="../311224/index.html">The history of one study in log4net and its acceleration more than 10 times</a></li>
<li><a href="../311226/index.html">JSX: antipattern or not?</a></li>
<li><a href="../311230/index.html">Alexey Igoshin (HomeApp) changes the rules of the game on the Russian real estate market using information technology</a></li>
<li><a href="../311232/index.html">Using autoencoders to build a recommendation system</a></li>
<li><a href="../311236/index.html">New NetApp Storage Systems Running ONTAP 9.1</a></li>
<li><a href="../311238/index.html">Google Photos can not delete files from the SD card</a></li>
<li><a href="../311240/index.html">Change the paradigm of decision making in the IT business or pity your liver</a></li>
<li><a href="../311242/index.html">Microsoft introduced Windows Defender Application Guard protection technology for the Edge web browser</a></li>
<li><a href="../311248/index.html">VIPER Book</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>