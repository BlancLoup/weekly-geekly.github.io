<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to hack a switched off computer or execute code in Intel ME</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the recent Black Hat Europe conference, Positive Technologies researchers Mark Yermolov and Maxim Goryachiy spoke about a vulnerability in the Inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to hack a switched off computer or execute code in Intel ME</h1><div class="post__text post__text-html js-mediator-article">  At the recent Black Hat Europe conference, Positive Technologies researchers Mark Yermolov and Maxim Goryachiy <a href="https://www.blackhat.com/eu-17/briefings.html">spoke about a vulnerability in the Intel Management Engine 11</a> , which allows attackers to access most of the data and processes on the device. <br><br>  This level of access also means that any attacker who exploits this vulnerability, bypassing traditional software-based protection, will be able to launch attacks even when the computer is turned off.  Today we publish in our blog the details of the study. <a name="habracut"></a><br><br><h2>  1. Introduction </h2><br>  The Intel Management Engine is a closed technology that is a microcontroller integrated into the Platform Controller Hub (PCH) chip with a set of embedded peripherals.  It is through PCH that almost all communication between the processor and external devices takes place, therefore Intel ME has access to almost all data on the computer and the ability to execute third-party code allows you to completely compromise the platform.  Such endless opportunities have attracted researchers for years and years, but now interest in Intel ME technology has grown significantly.  One of the reasons for this is the transition of this subsystem to a new hardware (x86) and software (modified MINIX as an operating system) architecture.  The use of the x86 platform makes it possible to use all the power of binary code analysis tools, which was previously difficult, since before the 11th version, the kernel with the rare command system, ARC, was used.  Unfortunately, the analysis of Intel ME 11th version was made difficult by the fact that executable modules are packed with a Huffman code with unknown tables.  But our research team managed to restore them (the utility for unpacking images can be found on our page in GitHub [2]). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After unpacking the executable modules, we began to study the software and hardware "stuffing" of Intel ME.  Our efforts were rewarded, and in the end we got full control over the entire platform. <br><br><h3>  1.1.  Intel Management Engine 11 Overview </h3><br>  A detailed description of the internal arrangement of Intel ME and its components can be found in [1], [3], [4].  Note that, starting in 2015, the LMT processor core was integrated into the PCH with the x86 instruction set.  This core is used in SOC Quark. <br><br><img src="https://habrastorage.org/webt/m_/rr/wu/m_rrwukb5b5lqfpzrtzm83foork.png"><br><br>  <i>LMT2 IdCode ME kernel</i> <br><br>  A large number of modern Intel technologies are associated with the Intel Management Engine - Intel Active Management Technology, Intel Platform Trust Technology (fTPM), Intel Software Guard Extensions, Intel Protected Audio Video Path.  ME is also the root of trust for Intel Boot Guard technology, which does not allow an attacker to inject his code into UEFI.  The main purpose of the ME is the initial initialization of the platform, and the launch of the main processor.  ME also has almost limitless access to data that is processed on a computer. ME can intercept and modify network packets, the image on the video card, has full access to USB devices.  Such capabilities mean that if an attacker gains the ability to execute his code inside the ME, it will mean a new era of malicious software that cannot be detected by modern means of protection.  But fortunately for all 17 years of the history of this technology, only 3 vulnerabilities have been found (publicly). <br><br><h3>  1.2.  Intel ME known vulnerabilities </h3><br><h4>  1.2.1.  Ring-3 Rootkits </h4><br>  The first public vulnerability in Intel ME was found in 2009. Alexander Tereshkin and Rafal Wojtczuk presented a report on Black Hat Introducing Ring-3 Rootkits.  The attack was made by injecting the code into a specialized UMA memory area, into which the ME unloads the currently unused memory pages. <br><br>  After the announcement of the research results, Intel implemented UMA protection - now this area is encrypted with AES and for each page IU stores its checksum, which is checked when the page ‚Äúreturns‚Äù to the main memory of ME. <br><br><h4>  1.2.2.  Zero-Touch Provisioning </h4><br>  In 2010, Vassilios Ververis introduced an attack on the implementation of ME in GM45.  Using the ‚Äúzero touch‚Äù configuration mode, he was able to bypass the AMT authorization. <br><br><h4>  1.2.3.  Silent Bob is Silent </h4><br>  In May 2017, a vulnerability was published in the AMT authorization system (CVE-2017-5689), which allowed unauthorized users to get full access to the main system on motherboards with vPro technology support. <br><br>  Thus, until now, only one vulnerability has been found (Ring-3 rootkits), which allows the execution of arbitrary code inside Intel ME. <br><br><h2>  2. Attack Vectors </h2><br>  Virtually all the data that ME uses in its work is either directly or indirectly signed by Intel.  But IU still provides some possibilities for user interaction: <br><br><ul><li>  Local Management Interface - HECI </li><li>  Network (vPro only) </li><li>  Host Memory (UMA) </li><li>  SPI flash </li><li>  Internal file system </li></ul><br><h3>  2.1.  Heci </h3><br>  HECI - is a separate PCI-device, which is a ring buffer and is used to exchange messages between the main system and the ME. <br>  Applications located inside the ME can register their handlers for HECI.  This increases the number of potential security issues (CVE-2017-5711). <br><br><h3>  2.2.  Network (vPro only) </h3><br>  AMT is a single large module that integrates a huge number of different network protocols at various levels, this module contains a large amount of legacy code, but is only present on business segment systems. <br><br><h3>  2.3.  Hardware attack on SPI-interface </h3><br>  In the process of studying ME, we had an idea to bypass signature verification using an SPI flash emulator.  This is a specialized device that would look like a normal SPI-flash for PCH, but with different calls it sends different data.  Thus, if the signature of the data is first controlled, and then they are reread, then you can attack and inject your code inside the ME.  We failed to find such errors in the firmware, the data are first read, then the signature is checked.  With repeated requests, their identity is controlled by the data obtained at the first reading. <br><br><h3>  2.4.  Internal file system </h3><br>  The Intel Management Engine uses SPI flash as the main file storage with its own file system.  On the one hand, the file system has a rather complex structure [6], on the other hand, many privileged processes store their configuration files here.  On this basis, the file system seemed to us the most promising place to influence ME. <br><br>  The next step in the search for vulnerabilities was the choice of a binary module. <br><br><h3>  2.5.  The choice of module for analysis </h3><br>  The operating system ME is implemented similar to that used in Unix model of differentiation and access control, with the difference that the processes are the subjects of the system.  For each process, its user ID, groups, list of available equipment and allowed system calls are statically set. <br><br><img src="https://habrastorage.org/webt/sy/zw/ty/syzwtyhml7tu80jzlkuhfvqsesq.png"><br>  <i>An example of static rules for the process</i> <br><br>  Thus, not every process in the system can load modules for execution.  Moreover, the monitoring of integrity and privileges is set by the process that launches it.  He can elevate his privileges by giving the new process high access rights. <br><br>  One of the processes with the ability to generate new ones is BUP (BringUP).  In the process of reverse engineering of this module, in the initialization function of the Trace Hab device, we found an overflow of the stack buffer.  The file ‚Äú/ home / bup / ct‚Äù did not have a signature, and could be integrated into the ME firmware via the service program - Flash Image Tool.  This made it possible to cause a buffer overflow inside the BUP process using a large BUP initialization file.  But it was possible to use it only after bypassing the protection from stack buffer overflow. <br><br><img src="https://habrastorage.org/webt/gv/f8/bq/gvf8bq_uawil63ybtuptiycrmlo.png"><br><br>  <i>Stack buffer overflow</i> <br><br><h3>  2.6.  Buffer overflow protection bypass </h3><br>  ME implements a classic way to protect against buffer overflow in a stack - a stack canary.  Implemented this mechanism as follows: <br><br><ol><li>  For each process at the time of its creation, a 32-bit value is copied from a hardware random-number generator to a special area (read-only); </li><li>  In the function prologue, this value is copied over the return address in the stack, thereby protecting it; </li><li>  In the epilogue of the function, the stored value is compared with the reference value.  If it does not match, a software interrupt is generated; int 81h terminating the process. </li></ol><br>  Thus, for operation, it is necessary either to predict the value of the canary, or to take control before the integrity check is performed.  Further study has shown that any failure in the random number generator is regarded by ME as fatal failure and leads to its inoperability. <br><br>  Studying the functions that are called after the overflow and before the integrity check we found that the function we called <code>bup_dfs_read_file</code> indirectly calls <b>memcpy</b> .  She, in turn, uses as the value of the target address, the data obtained from some structure, which we called TLS (Tread Local Storage).  It is worth noting that the bup functions for reading and writing files use the services of the system library for working with shared memory.  Using it, the functions of reading and writing, receive and record information.  But no one except BUP uses this data, so the use of this mechanism may seem dubious.  We believe that this is due to the fact that part of the BUP code that interacts with MFS is copied from another module ‚Äî the file system driver, where the use of shared memory is justified. <br><br><img src="https://habrastorage.org/webt/xx/-y/b-/xx-yb-sb3_srtwe9iyubijlrvs8.png"><br><br>  <i>Function call memcpy</i> <br><br><img src="https://habrastorage.org/webt/pb/lw/-a/pblw-aecpk83z2lshd-hi3milew.png"><br><br>  <i>Getting an address from TLS</i> <br><br>  As it turned out later, in the event of a buffer overflow, this TLS area can be overwritten by the file reading function, which bypasses the buffer overflow protection. <br><br><h3>  2.7.  Tread local storage </h3><br>  All access to the TLS structure occurs through the gs segment register. The structure itself has the following form: <br><br><img src="https://habrastorage.org/webt/zd/z_/ag/zdz_agororgmozugaqp96vsvime.png"><br><br>  <i>TLS structure</i> <br><br><img src="https://habrastorage.org/webt/pj/ku/eo/pjkueohbzwxgr4gbd5qm9ihgg2m.png"><br><br>  <i>Getting TLS fields</i> <br><br>  The segment pointed to by gs is not writable, but the TLS structure itself is located at the bottom of the stack (!!!), which allows you to change it to bypass the restriction.  Thus, in the event of a buffer overflow, we can rewrite the pointer to TLS and form the SYSLIB_CTX structure.  And the algorithm of operation of the algorithm of the function bup_dfs_read_file, using this trick, allows you to get an arbitrary write. <br><br><h3>  2.8.  Using the read function implementation to get arbitrary write primitive </h3><br>  The bup_dfs_read_file function reads data from SPI-flsh blocks of 64 bytes, which allows you to first overwrite the pointer to SYSLIB_CTX and TLS.  At the next iteration, the sys_write_shared_mem function retrieves the address we created and sends it to memcpy as the target address.  This allows you to get a record primitive within the BUP process. <br><br><img src="https://habrastorage.org/webt/cq/zj/fu/cqzjfucypd7aajzqakk3su5e4cg.png"><br><br>  <i>Iterative reading of the file inside bup_dfs_read_file</i> <br><br>  The absence of ASLR allows you to overwrite the return address of the memcpy function and take control.  There is also waiting for trouble for the attacker - the stack is not executable.  But using the fact that BUP is able to create new processes and checks the signature for the modules to be launched, we can create a new process with specified permissions using return-oriented programming (ROP). <br><br><h3>  2.9.  Possible vectors of operation </h3><br>  To successfully exploit this vulnerability, write access to MFS or the entire Intel ME region is required.  Equipment manufacturers should block access to the region with ME, but unfortunately, not everyone is doing it [8].  If there is such a configuration error on the system, it automatically makes it vulnerable. <br><br>  Intel ME provides full-time ability to provide write access to the ME region by sending a special HMR-FPO message via HECI from the BIOS [9].  An attacker can send such a message using a vulnerability in the BIOS or DMA attack. <br>  In the case of physical access to the attacked machine, the attacker can always rewrite to his image (via SPI programmer or using a special jumper), which leads to a complete cracking of the platform. <br><br>  One of the most pressing issues is the question of the possibility of remote operation.  It seems to us that this possibility exists if the following conditions are met: <br><br><ol><li>  Attacked platform with activated AMT. </li><li>  The attacker knows the AMT administrator password or uses a vulnerability to bypass authorization. </li><li>  The BIOS does not have a password (or is known to the attacker). </li><li>  The BIOS has an option that allows you to open write access to the ME region. </li></ol><br>  Fulfillment of these conditions allows an attacker to gain access to the ME region remotely. <br><br>  Note also that the ROM does not control the version of Intel ME at startup, which makes it possible to upgrade to the old version that contains the vulnerability. <br><br><h3>  2.10.  Vulnerability Overview CVE-2017-5705,6,7 </h3><br>  The found vulnerability was assigned the number INTEL-SA-00086 (CVE-2017-5705, CVE-2017-5706, CVE-2017-5707).  Here is a short excerpt from his description: <br><br>  <b>CVSSv3 Vectors:</b> <br><ul><li>  8.2 High AV: L / AC: L / PR: H / UI: N / S: C / C: H / I: H / A: H </li></ul><br>  <b>Affected products:</b> <br><ul><li>  6th, 7th &amp; 8th Generation Intel Core Processor Family </li><li>  Intel Xeon Processor E3-1200 v5 &amp; v6 Product Family </li><li>  Intel Xeon Processor Scalable Family </li><li>  Intel Xeon Processor W Family </li><li>  Intel Atom C3000 Processor Family </li><li>  Apollo Lake Intel Atom Processor E3900 series </li><li>  Apollo Lake Intel Pentium </li><li>  Celeron N and J series Processors </li></ul><br><h3>  2.11.  Disclosure Timeline </h3><br><ul><li>  June 27, 2017 - Bug reported to Intel PSIRT </li><li>  June 28, 2017 - Intel started initial investigation </li><li>  July 5, 2017 - Intel requested proof-of-concept </li><li>  July 6, 2017 - Additional information sent to Intel PSIRT </li><li>  July 17, 2017 - Intel acknowledged the vulnerability </li><li>  July 28, 2017 - Bounty payment received </li><li>  November 20, 2017 - Intel published SA-00086 security advisory </li></ul><br><h2>  3. Conclusion </h2><br>  Thus, we have found the vulnerability of Intel ME, which allows you to execute arbitrary code.  This threatens all technologies such as Intel Protected Audio Video Path (PAVP), Intel Platform Trust Technology (PTT or fTPM), Intel BootGuard, Intel Software Guard Extention (SGX) and many others. <br><br>  Exploiting the vulnerability we found in the bup module, we managed to enable a mechanism called PCH red unlock, which opens up full access to all PCH devices for using them via the DFx chain, in other words using JTAG.  One of these devices is the ME core itself.  This made it possible to debug the code running on ME, read the memory of all processes and the kernel, and also manage all the devices inside the PCH.  We counted in the aggregate about 50 internal devices, full access to which has only ME, and the main processor only to a very limited subset of them. <br><br>  We do not claim that there is no error in our study or it is exhaustive.  Nevertheless, we hope that it will help other researchers interested in the security and "stuffing" of Intel ME. <br><br>  <b>Authors</b> : Mark Yermolov and Maxim Hot <br><br><h3>  Bibliography </h3><br>  [1] Dmitry Sklyarov, Intel ME: The Way of the Static Analysis, Troopers 2017. <br>  [2] <a href="https://github.com/ptresearch/unME11">Intel ME 11.x Firmware Images Unpacker</a> . <br>  [3] Xiaoyu Ruan, Platform Embedded Security Technology Revealed. <br>  [4] Igor Skochinsky, Intel ME Secrets.  Where does it exactly, does RECON 2014. <br>  [5] Alexander Tereshkin, Rafal Wojtczuk, Introducing Ring-3 Rootkits, Black Hat USA, 2009. <br>  [6] Dmitry Sklyarov, Intel ME: flash file system explained, Black Hat Europe, London, 2017. <br>  [8] Alex Matrosov, <a href="https://medium.com/%40matrosov/bypass-intel-boot-guard-cc05edfca3a9">Who Watch BIOS Watchers?</a>  . <br>  [9] Mark Yermolov, Maxim Goryachiy, ‚Äú <a href="http://2016.phdays.ru/program/51879/">How to become the sole owner of your own computer</a> ‚Äù, PHDays VI. <br></div><p>Source: <a href="https://habr.com/ru/post/346974/">https://habr.com/ru/post/346974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346964/index.html">Learn OpenGL. Lesson 4.4 - Clipping of faces</a></li>
<li><a href="../346966/index.html">(Non) security monitoring systems: NagiosXI</a></li>
<li><a href="../346968/index.html">‚ÄúKnowledge Day‚Äù for AI: published by the TOP30 of the most impressive machine learning projects over the past year (v.2018)</a></li>
<li><a href="../346970/index.html">Automatic update and backup 1C using powershell</a></li>
<li><a href="../346972/index.html">Open class lesson on group work</a></li>
<li><a href="../346976/index.html">JavaScript - fill a niche between microservices and objects - ‚Äúnano-services‚Äù</a></li>
<li><a href="../346978/index.html">Development for Android and iOS: Open Day in webinar format</a></li>
<li><a href="../346980/index.html">Micro-UART for Microcontroller (ATtiny13A)</a></li>
<li><a href="../346982/index.html">Report from the Moscow CocoaHeads Meetup meeting December 15</a></li>
<li><a href="../346984/index.html">Java conference with English roots. Continuing mega review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>