<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to compilers, interpreters and JITs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the birth of PHP 7, the debate about abstract syntax trees, just-in-time compilers, static analysis, etc. does not stop. But what do all these t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to compilers, interpreters and JITs</h1><div class="post__text post__text-html js-mediator-article">  Since the birth of PHP 7, the debate about abstract syntax trees, just-in-time compilers, static analysis, etc. does not stop. But what do all these terms mean?  Are these some magical properties that make PHP much more productive?  And if so, how does it all work?  In this article, we will look at the basics of how programming languages ‚Äã‚Äãwork and explain the process that should be performed before the computer starts, for example, your PHP script. <br><a name="habracut"></a><br><h1>  Interpreting the code </h1><br>  But before we talk about how this all works, let's look at one simple example.  Imagine that we have a new programming language (think up any name).  The language is pretty simple: <br><br><ul><li>  each line is an <i>expression</i> </li><li>  each expression consists of a <i>command</i> (operator) </li><li>  and any number of <i>values</i> (operands) that the command operates on. </li></ul><br>  Example: <br><br> <code>set a 1</code> <br> <code>set b 2</code> <br> <code>add abc</code> <br> <code>print c</code> <br> <br>  This is a simple language, so we can safely assume that this code just prints to screen 3. The <code>set</code> operator takes a variable and assigns a number to it (just like <code>$a=1</code> in PHP).  The <code>add</code> operator takes two variables to add and stores the result in the third.  The <code>print</code> statement displays it on the screen. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now let's write a program that reads each ‚Äúexpression‚Äù, finds the operator and operands, and then does something with them, depending on the particular operator.  This is pretty simple to implement in PHP, as you can see in Listing 1. <br><br>  Listing 1 <br><br><pre> <code class="php hljs"><span class="hljs-number"><span class="hljs-number">01.</span></span> <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-number"><span class="hljs-number">02.</span></span> <span class="hljs-number"><span class="hljs-number">03.</span></span> $lines = file($argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-number"><span class="hljs-number">04.</span></span> <span class="hljs-number"><span class="hljs-number">05.</span></span> $linenr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">06.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lines <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $line) { <span class="hljs-number"><span class="hljs-number">07.</span></span> $linenr++; <span class="hljs-number"><span class="hljs-number">08.</span></span> $operands = explode(<span class="hljs-string"><span class="hljs-string">" "</span></span>, trim($line)); <span class="hljs-number"><span class="hljs-number">09.</span></span> $command = array_shift($operands); <span class="hljs-number"><span class="hljs-number">10.</span></span> <span class="hljs-number"><span class="hljs-number">11.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ($command) { <span class="hljs-number"><span class="hljs-number">12.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'set'</span></span> : <span class="hljs-number"><span class="hljs-number">13.</span></span> $vars[$operands[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = $operands[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-number"><span class="hljs-number">14.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-number"><span class="hljs-number">15.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'add'</span></span> : <span class="hljs-number"><span class="hljs-number">16.</span></span> $vars[$operands[<span class="hljs-number"><span class="hljs-number">2</span></span>]] = $vars[$operands[<span class="hljs-number"><span class="hljs-number">0</span></span>]] + $vars[$operands[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-number"><span class="hljs-number">17.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-number"><span class="hljs-number">18.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'print'</span></span> : <span class="hljs-number"><span class="hljs-number">19.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $vars[$operands[<span class="hljs-number"><span class="hljs-number">0</span></span>]] . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-number"><span class="hljs-number">20.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-number"><span class="hljs-number">21.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> : <span class="hljs-number"><span class="hljs-number">22.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(sprintf(<span class="hljs-string"><span class="hljs-string">"Unknown command in line %s\n"</span></span>, $linenr)); <span class="hljs-number"><span class="hljs-number">23.</span></span> } <span class="hljs-number"><span class="hljs-number">24.</span></span> }</code> </pre><br>  This is a very simple program, and you don‚Äôt have to write your next web application in your new language.  But this example helps to understand how easy it is to create a new language and get a program that is able to read and execute this language.  In our case, it reads the source file line by line and executes the code depending on the current operator.  To run the application, we do not need to convert it to assembler or binary code, it works fine anyway.  This method of program execution is called interpretation.  For example, in this way Basic programs are often executed: each expression is read and immediately executed in high-level mode. <br><br>  But there are a number of problems.  One of them is that it is quite easy to write such a language processor, but it will be very slow to execute a new language.  After all, we will have to process each line and check: <br><br><ul><li>  What operator need to perform? </li><li>  Is this the correct operator? </li><li>  Does it have the right amount of operands? </li></ul><br>  But we should not forget about other tasks.  For example, the set operator can assign only numeric values ‚Äã‚Äãto variables or string values ‚Äã‚Äãtoo?  Or even the values ‚Äã‚Äãof other variables?  To correctly process each expression, you need to answer all these questions.  What happens if you write <code>set 1</code> 4?  In short, it‚Äôs almost impossible to create fast-running applications. <br><br>  But, despite the slow pace, interpretation has advantages: we can immediately launch the program after each change made.  For attentive: when I change something in a PHP script, I can immediately execute it and see the changes;  Does this mean PHP is an interpreted language?  At the moment, we assume that yes.  The PHP script is interpreted like our hypothetical simple language.  But in the following sections we will come back to this! <br><br><h1>  Transcompiling </h1><br>  How can we make our program "work fast"?  This can be done in different ways.  One of these, developed on Facebook, is called HipHop (I mean the ‚Äúold‚Äù HipHop system, not the HHVM used today).  HipHop converted one language (PHP) to another (C ++).  The result of the conversion could be converted into binary code using the C ++ compiler.  His computer is able to understand and execute without additional load in the form of an interpreter.  As a result, a HUGE amount of computational resources is saved and the application runs much faster. <br><br>  This method is called source-to-source compiling, or transcompiling, or even transpiling.  In fact, it is not compiling into binary code, but a conversion to something that can be compiled into machine code by existing compilers. <br><br>  Transcompiling allows you to directly execute binary code, which improves performance.  However, this method has a downside: before you run the code, we first need to perform a transcompiling, and then a real compilation.  But this should only be done when changes are made to the application, that is, only during development. <br><br>  Trans-compiling is also used to make ‚Äúhard‚Äù languages ‚Äã‚Äãsimpler and more dynamic.  For example, browsers do not understand code written in LESS, SASS and SCSS.  But it can be transported in CSS, which browsers understand.  Maintaining CSS is easier, but you have to transform further. <br><br><h1>  Compiling </h1><br>  In order for everything to work even faster, you need to get rid of the stage of transcompiling.  That is, to compile our language immediately into binary code, which could be immediately executed, without additional workload in the form of interpretation or transcompiling. <br><br>  Unfortunately, writing a compiler is one of the most difficult tasks in computer science.  For example, when compiling into binary code, you need to consider which computer it will run on: on 32-bit Linux, or on 64-bit Windows, or generally on OS X. But the interpreted script can be easily run anywhere.  As in PHP, we do not need to worry about where our script is executed.  Although there may be code designed for a specific OS, which makes it impossible to run the script on other systems, but this is not the fault of the interpreter. <br><br>  But even if we get rid of the trans-capillating stage, we cannot escape compiling.  For example, large programs written in C (compiled language) can be compiled for almost an hour.  Imagine that you wrote an application in PHP and you need to wait another ten minutes before you see whether the changes are working. <br><br><h1>  Using the best </h1><br>  If interpretation means slow execution, and compiling is difficult to implement and takes more time to develop, how do languages ‚Äã‚Äãlike PHP, Python or Ruby work?  They are pretty quick! <br><br>  This is because they use both interpretation and compilation.  Let's see how it turns out. <br><br>  What if we could transform our fictional language not directly into binary code, but into something very similar to it (this is called ‚Äúbytecode‚Äù)?  And if this bytecode was so close to how the computer works, that it would be interpreted very quickly (for example, millions of bytecodes per second)?  This would make our application almost as fast as a compiled one, while retaining all the advantages of interpreted languages.  Most importantly, we would not have to compile scripts with every change. <br><br>  It looks very tempting.  In fact, many languages ‚Äã‚Äãwork in a similar way - PHP, Ruby, Python and even Java.  Instead of reading and interpreting lines of source code one by one, these languages ‚Äã‚Äãuse a different approach: <br><br><ul><li>  Step 1. Read the script (PHP) entirely in memory. </li><li>  Step 2. Completely convert / compile the script into bytecode. </li><li>  Step 3. Run the bytecode using the interpreter (PHP). </li></ul><br>  In fact, there are more steps, and in reality the whole process is much more complicated.  But in general, these three steps are enough to run the script from the command line or to execute the request through your web server. <br><br>  The process can be easily optimized: suppose we run a web server and each request executes the script <code>index.php</code> .  Why load it every time in memory?  It is better to cache the file so that you can quickly convert it with each request. <br><br>  Another optimization: after generating the bytecode, we can use it with all subsequent requests.  So you can cache it (most importantly, make sure that by changing the source file the bytecode will be recompiled).  This is what the opcode caches do, like the OPCache extension in PHP: they cache the compiled scripts so that they can be quickly executed on subsequent requests without redundant downloads and compiling into bytecode. <br><br>  Finally, the final step to high speed is bytecode execution by our PHP interpreter.  In the next section, we will compare this with ordinary interpreters.  To avoid confusion: such a bytecode interpreter is often called a ‚Äúvirtual machine‚Äù, because to a certain extent it copies the work of a machine (computer).  Do not confuse this with virtual machines running on computers, like VirtualBox or VMware.  We are talking about such things as JVM (Java Virtual Machine) in the world of Java and HHVM (HipHop Virtual Machine) in the world of PHP.  Python and Ruby have their own virtual machines.  In a way, they are all highly specialized and productive bytecode interpreters. <br><br>  Each VM executes its own bytecode generated by a specific language, and they are incompatible with each other.  You cannot execute PHP bytecode on a Python VM, and vice versa.  However, it is theoretically possible to create a program that compiles PHP scripts into bytecode, which will be understandable by the Python VM.  So in theory, you can run PHP scripts in Python (a serious challenge!). <br><br><h1>  Bytecode </h1><br>  How does the byte code look and work?  Consider two examples.  Take the PHP code: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $a + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  You can view its bytecode using <a href="http://3v4l.org/">3v4l.org</a> or installing <a href="https://derickrethans.nl/projects.html">the VLD extension</a> .  We get the following: <br><br><img src="https://habrastorage.org/files/3b9/b17/abf/3b9b17abf6d64863906b03cc889d8065.jpg"><br><br>  Now take a similar example in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> a + <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Python can directly generate operation codes ¬© python: <br><br>  <a href="https://docs.python.org/2/library/dis.html">dis.dis (func)</a> : <br><br><img src="https://habrastorage.org/files/db4/391/2ea/db43912ea78947359f19288cb94b73ee.jpg"><br><br>  We have two simple scripts and their bytecodes.  Note that bytecodes are similar to the language that we ‚Äúcreated‚Äù at the beginning of the article: each line is an operator with any number of operands.  In PHP bytecode, the variable is prefixed with!, So! 0 means variable 0. Bytecode does not matter that you use the $ a variable: during compiling, variable names lose their meaning and are converted to numbers.  This facilitates and accelerates their processing by the virtual machine.  Most of the necessary "checks" are performed at the compilation stage, which also relieves the load from the virtual machine and increases its speed. <br><br>  Since the byte code consists of simple instructions, interpretation is very fast.  Instead of thousands of binary instructions that need to be processed for each expression of an interpreted language, in byte-code there are several hundred instructions for each expression (sometimes even less).  Therefore, virtual machines run much faster than interpreted languages. <br><br>  In other words, virtualka took all the best from two worlds.  Although we still need to compile from source code to bytecode, this process becomes fast and transparent.  And after receiving the bytecode, the virtual machine quickly and efficiently interprets it without unnecessary overhead.  As a result, we have a high-performance application. <br><br><h1>  From source code to byte code </h1><br>  Now, when we are able to efficiently execute the generated bytecode, there remains the task of compiling the source code into this bytecode. <br><br>  Consider the following PHP expressions: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">1</span></span>; $a=<span class="hljs-number"><span class="hljs-number">1</span></span>; $a = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  All of them are equally true and must be converted to the same byte codes.  But how do we read them?  Indeed, in our own interpreter we parse the commands, separating them with spaces.  This means that the programmer must write code in the same style, unlike PHP, where you can use deviations or spaces, brackets in one line or transfer to the second line, etc., in one line. The compiler will first try to convert your original code in tokens.  This process is called lexing or tokenization. <br><br><h1>  Lexing </h1><br>  Tokenization (lexing) consists in converting the source PHP code ‚Äî without understanding its meaning ‚Äî into a long list of tokens.  This is a complex process, but in PHP you can do something quite similar.  The code in Listing 2 yields the following result: <br><br><pre> <code class="cpp hljs">T_OPEN_TAG &lt;?php T_VARIABLE $a T_WHITESPACE = T_WHITESPACE T_LNUMBER <span class="hljs-number"><span class="hljs-number">3</span></span> ; T_WHITESPACE T_ECHO echo T_WHITESPACE T_CONSTANT_ENCAPSED_STRING <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> ;</code> </pre><br>  The string value is converted to tokens: <br><br><ul><li>  &lt;? php converted to token T_OPEN_TAG, </li><li>  $ a is converted to the T_VARIABLE token, which contains the value of $ a. </li></ul><br>  The tokenizer knows this when, when reading a code, it detects a $ sign with the letter a, after which any number of letters and numbers can follow.  Numbers are tokenized as T_LNUMBER and can be one or more bits.  Tokenization allows you to present the source code in a more structured form, without forcing the programmer to do it.  But, as already mentioned, the tokenizer does not understand the meaning of tokens.  It ideally tokens and $ a = 1, and 1 = $ a.  And in the next part, we will learn to parse - set the value to the stream of tokens. <br><br><h1>  Parsing </h1><br>  When parsing tokens, we must follow some of the ‚Äúrules‚Äù that make up our language.  For example, there may be a rule: the first detected token in the program must be T_OPEN_TAG (corresponding to &lt;? Php). <br><br>  Another possible rule: an assignment can consist of any T_VARIABLE followed by the symbol =, and then T_LNUMBER, T_VARIABLE or T_CONSTANT_ENCAPSED_STRING.  In other words, we allow $ a = 1, or $ a = $ b, or $ a = 'foobar', but not 1 = $ a.  If the parser detects a series of tokens that do not satisfy any of the rules, a syntax error will be automatically generated.  In general, parsing is a process that defines a language and allows us to create syntax rules. <br><br>  See the list of rules used in PHP <a href="http://bit.ly/zend-language-parser">at</a> .  If your PHP script satisfies the syntax rules, additional checks are performed to confirm that the syntax is not only correct, but also meaningful: the definition of <code>public abstract final final private class foo() {}</code> may be correct, but does not make sense from the point of view PHP  Tokenization and parsing are tricky processes, and often third-party applications are used to perform them.  Often used tools like flex and bison (in PHP too).  They can also be considered as transcompilers: they transform your rules into C-code, which will be automatically compiled when you compile PHP. <br><br>  Parsers and tokenizers are also useful in other areas.  For example, they are used to parse SQL expressions in databases, and PHP also writes quite a few parsers and tokenizers.  The Doctrine object-relational mapper has its own parser for DQL expressions, as well as a ‚Äútranscompiler‚Äù for converting DQL to SQL.  Many template engines, including Twig, use their own tokenizers and parsers to ‚Äúcompile‚Äù template files back into PHP scripts.  In fact, these engines are also transcompilers! <br><br><h1>  Abstract syntax tree </h1><br>  After tokenization and parsing of our language, we can generate bytecode.  Up to PHP 5.6, it was generated during parsing.  But it would be more usual to add a separate stage to the process: let the parser generate not a bytecode, but the so-called abstract syntax tree (AST).  This is a tree structure in which the entire program is represented in the abstract.  AST not only simplifies the generation of bytecode, but also allows us to make changes to the tree before it is transformed.  The tree is always generated in a special way.  The tree node, which is an if expression, necessarily has three elements under it: <br><br><ul><li>  the first one contains a condition (like <code>$a == true</code> ); </li><li>  the second contains expressions that must be executed if the condition <code>true</code> is met; </li><li>  the third contains expressions that must be executed if the <code>false</code> condition is met (the expression is <code>else</code> ). </li></ul><br>  Even if <code>else</code> missing, element three, just the third will be empty. <br><br>  As a result, we can ‚Äúrewrite‚Äù the program before it is converted to bytecode.  Sometimes it is used to optimize the code.  If we find that the developer repeatedly recalculated the variable inside the loop, and we know that the variable always has the same value, the optimizer can rewrite the AST to create a temporary variable that does not need to be recalculated each time.  The tree can be used for a small reorganization of the code so that it works faster: delete unnecessary variables, etc. This is not always possible, but when we have a tree of the entire program, it is much easier to perform such checks and optimization.  Inside an AST, you can see whether variables are declared before they are used or if assignment is used in a conditional block ( <code>if ($a = 1) {}</code> ).  And when potentially erroneous structures are detected, issue a warning.  With the help of the tree, you can even analyze the code from the point of view of information security and warn users during script execution. <br><br>  All this is called static analysis - it allows you to create new features, optimizations and validation systems that help developers write harmonious, secure and fast code. <br><br>  In PHP 7.0, a new parsing engine (Zend 3.0) has appeared, which also generates AST during parsing.  Since it is quite fresh, not much can be done with it.  But the very fact of its existence means that we can expect the appearance of various possibilities in the near future.  The <code>token_get_all()</code> function already accepts a new, undocumented TOKEN_PARSE constant, which in the future can be used to return not only tokens, but also parsed AST.  Third-party extensions like php-ast allow you to view and edit the tree directly in PHP.  A complete redesign of the Zend engine and AST implementations will open PHP for a variety of new tasks. <br><br><h1>  JIT </h1><br>  In addition to virtual machines running highly optimized byte-code generated from AST, there is another method for increasing speed.  But this is one of the most difficult to implement things. <br><br>  How is the application executed?  It takes a lot of time to set it up: for example, you need to run the framework, parse routes, process environment variables, etc. After all these procedures are completed, the program is usually still not running.  ,       -   .  ,     ,           (,   )   ? ,        ,       ,   . ,         ,       ,   ,      . <br><br>          .        -,   .    JIT- (just-in-time,   ).     .  ,   -         ,      ,      .   ‚Äî   .    ,     .         ,       . <br><br>    JIT-   .      ;    ,       ;    ,       .   JIT'   :    ,    . <br><br>    JIT'        ,            . JIT'       runtime   ,     .            ,  JIT'    . <br><br>      HHVM,     JIT-: PHP- (   Hack)   -,     HHVM.   ,        ;      ,      .        -,       . <br><br> PHP 7    JIT-,         .          ,  ,     JIT-.    ,    PHP 7  ! </div><p>Source: <a href="https://habr.com/ru/post/304748/">https://habr.com/ru/post/304748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304734/index.html">How not to step on a rake, working with serialization</a></li>
<li><a href="../304738/index.html">Vulnerabilities of corporate information systems - 2015: inside is worse than outside</a></li>
<li><a href="../304740/index.html">Signal and Transport Protocols WebRTC: Tearing Covers</a></li>
<li><a href="../304742/index.html">Usability rules for bots</a></li>
<li><a href="../304744/index.html">ETERNUS Snapshot Manager - an effective tool for high data availability</a></li>
<li><a href="../304750/index.html">Recognition of the RF passport on the Elbrus platform. Part 1</a></li>
<li><a href="../304752/index.html">Wecon LX3V: Chinese PLC with aliexpress</a></li>
<li><a href="../304754/index.html">The report on the results of "My Circle" for June 2016, and the most popular vacancies of the month</a></li>
<li><a href="../304758/index.html">Who should be afraid of among malware</a></li>
<li><a href="../304760/index.html">Popular logistics trends for e-commerce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>