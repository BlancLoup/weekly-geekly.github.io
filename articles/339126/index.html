<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker security issues</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As the Docker ecosystem matures and stabilizes, the topics related to the security of this product are attracting more and more attention. When design...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker security issues</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/ce2/c0b/dc4/ce2c0bdc442b41e0aa5f6b5b38a8ad28.jpg"><br><br><p>  As the Docker ecosystem matures and stabilizes, the topics related to the security of this product are attracting more and more attention.  When designing the infrastructure, it is impossible to avoid the issue of Docker security. </p><br><p>  Docker has some great security features built in: </p><br><ul><li><p>  <strong>Docker containers are minimal:</strong> one or more running processes, only the necessary software.  This reduces the likelihood of being affected by software vulnerabilities. </p><br></li><li><p>  <strong>Docker containers perform a specific task.</strong>  It is known in advance what should be performed in the container, paths to directories, open ports, daemon configurations, mount points, etc., are defined. In such conditions, it is easier to detect any security-related anomalies.  This system organization principle goes hand in hand with microservice architecture, allowing to significantly reduce the attack surface. </p><br></li><li><p> <strong>Docker containers are isolated</strong> from both the host and other containers.  This is achieved thanks to the ability of the Linux kernel to isolate resources using <code>cgroups</code> and <code>namespaces</code> .  But there is a serious problem - the kernel has to be divided between the host and the containers (we will return to this topic a little later). </p><br></li><li>  <strong>Docker containers are reproducible.</strong>  Thanks to their declarative build system, any administrator can easily figure out from what and how the container was made.  It is highly unlikely that you end up with an unknown person who is configured a legacy system that no one wants to configure again.  Familiar, is not it?  ;) </li></ul><br><p>  However, there are weaknesses in Docker-based systems.  In this article we will just talk about them, having considered <strong>7</strong> Docker security issues. </p><a name="habracut"></a><br><p>  Each section is divided into the following parts: </p><br><ul><li>  Threat description: attack vector and causes. </li><li>  Best Practices: What can be done to prevent threats of this type. </li><li>  Example (s): simple, easily reproducible exercises for practice. </li></ul><br><h2 id="bezopasnost-docker-hosta-i-yadra">  Docker host and kernel security </h2><br><p>  <strong>Description</strong> </p><br><p>  In a compromised system, insulation and other container security mechanisms are unlikely to help.  In addition, the system is designed so that the containers use the host core.  For many reasons already familiar to you, this increases work efficiency, but from a security point of view this feature is a threat that must be dealt with. </p><br><p>  <strong>Best practics</strong> </p><br><p>  The topic of securing a Linux host is quite extensive, and a lot of literature has been written about it.  As for Docker exclusively: </p><br><ul><li><p>  Make sure that the configuration of the host and the Docker engine is secure (access is restricted and provided only to authenticated users, the communication channel is encrypted, etc.) I recommend using the <a href="https://github.com/docker/docker-bench-security">Docker bench audit tool tool</a> to check the configuration for compliance with best practices. </p><br></li><li><p>  Update the system in a timely manner, subscribe to the security update of the operating system and other installed software, especially if it is installed from third-party repositories (for example, container orchestration systems, one of which you have probably already installed). </p><br></li><li><p>  Use minimal, specifically designed for use with containers of the host system, such as CoreOS, Red Hat Atomic, RancherOS, etc. This will reduce the attack surface, as well as take advantage of convenient features such as, for example, performing system services in containers. </p><br></li><li>  You can use the <strong><em>Mandatory Access Control</em></strong> system to prevent unwanted operations from being performed both on the host and in containers.  This will help you tools such as Seccomp, AppArmor or SELinux. </li></ul><br><p>  Examples: </p><br><p>  Seccomp allows you to limit the actions available to the container, in particular - system calls.  This is something like a firewall, but for the kernel call interface. </p><br><p>  Some privileges are blocked by default.  Try the following commands: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run -it alpine sh / # whoami root / # mount /dev/sda1 /tmp mount: permission denied (are you root?)</span></span></code> </pre> <br><p>  or </p><br><pre> <code class="bash hljs">/ <span class="hljs-comment"><span class="hljs-comment"># swapoff -a swapoff: /dev/sda2: Operation not permitted</span></span></code> </pre> <br><p>  It is possible to create a custom Seccomp profile, for example, by disallowing <a href="">chmod</a> calls. </p><br><p>  Let's download the default profile for Secker Docker: </p><br><pre> <code class="bash hljs">https://raw.githubusercontent.com/moby/moby/master/profiles/seccomp/default.json</code> </pre> <br><p>  While editing the file, you will see the whitelist of the system calls (around line 52), remove the <strong><em>chmod</em></strong> , <strong><em>fchmod</em></strong> and <strong><em>fchmodat</em></strong> from it. </p><br><p>  Now run the container with this profile and check the work of the established restrictions: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker container run --rm -it --security-opt seccomp=./default.json alpine sh / # chmod +r /usr chmod: /usr: Operation not permitted</span></span></code> </pre> <br><h2 id="vyhod-za-predely-docker-konteynera">  Going beyond the Docker container </h2><br><p>  <strong>Description</strong> </p><br><p>  The term ‚Äúcontainer breakout‚Äù is used to denote a situation in which a program running inside a Docker container can overcome isolation mechanisms and gain additional privileges or access to confidential information on a host.  To prevent such breakthroughs, a decrease in the number of container privileges issued to it by default is used.  For example, the default Docker daemon runs as root, but it is possible to create a user-name namespace or remove potentially dangerous container privileges. </p><br><p>  Quote from the article about the <a href="https://blog.docker.com/2014/06/docker-container-breakout-proof-of-concept-exploit/">default Docker configuration vulnerabilities</a> : </p><br><p>  ‚ÄúThis experimental exploit is based on the fact that the kernel allows any process to open a file by its inode.  On most inodes, the root directory (/) is 2. This makes it possible to go through the directory tree of the host file system until the desired object is found, for example, a password file. ‚Äù </p><br><p>  <strong>Best practics</strong> </p><br><ul><li><p>  <a href="https://docs.docker.com/engine/security/security/">The privileges (capabilities)</a> that are not needed by the application should be removed. </p><br><ul><li>  CAP_SYS_ADMIN is <a href="https://www.slideshare.net/jpetazzo/linux-containers-lxc-docker-and-security/19-HoweverCAPSYSADMIN_is_a_big_can">especially</a> tricky in terms of security, since it gives the right to perform a significant number of superuser-level operations: mounting file systems, entering kernel namespaces, ioctl operations ... </li></ul><br></li><li><p>  To ensure that container privileges are equivalent to ordinary user rights, create an isolated user namespace for your containers.  <a href="https://docs.docker.com/engine/security/userns-remap/">If possible,</a> avoid running containers with uid 0. </p><br></li><li><p>  If you still can‚Äôt do without a privileged container, make sure that it is installed from a trusted repository (see below, the section ‚ÄúAuthenticity of container images‚Äù). </p><br></li><li>  Carefully monitor the mounting of potentially dangerous host resources: <strong>/var/run/docker.sock</strong> ), <strong>/ proc</strong> , <strong>/ dev</strong> , etc. These resources are usually needed to perform operations related to the basic functionality of containers.  Make sure that you understand why and how it is necessary to limit the access of processes to this information.  Sometimes it is enough just to set the ‚Äúread only‚Äù mode.  Never give write rights without wondering why this right is needed.  In any case, Docker uses <a href="https://medium.com/%40nagarwal/docker-containers-filesystem-demystified-b6ed8112a04a">copy-on-write</a> to prevent changes from occurring in a running container to its base image and potentially to other containers that will be created based on that image. </li></ul><br><p>  <strong>Examples</strong> </p><br><p>  The root user of the Docker container can create devices by default.  You will probably want to ban it: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sudo docker run --rm -it --cap-drop=MKNOD alpine sh / # mknod /dev/random2 c 1 8 mknod: /dev/random2: Operation not permitted</span></span></code> </pre> <br><p>  Root can also change the permissions of any file.  It's easy to check: create a file with any ordinary user, run <strong><em>chmod 600</em></strong> (read and write are only available to the owner), log in as root and make sure that the file is still available to you. </p><br><p>  This can also be fixed, especially if you have folders with sensitive user data. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sudo docker run --rm -it --cap-drop=DAC_OVERRIDE alpine sh</span></span></code> </pre> <br><p>  Create a regular user and go to his home directory.  Then: </p><br><pre> <code class="bash hljs">~ $ touch supersecretfile ~ $ chmod 600 supersecretfile ~ $ <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> ~ <span class="hljs-comment"><span class="hljs-comment"># cat /home/user/supersecretfile cat: can't open '/home/user/supersecretfile': Permission denied</span></span></code> </pre> <br><p>  Many security scanners and malware collect their network packets from scratch.  This behavior can be disabled as follows: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run --cap-drop=NET_RAW -it uzyexe/nmap -A localhost Starting Nmap 7.12 ( https://nmap.org ) at 2017-08-16 10:13 GMT Couldn't open a raw socket. Error: Operation not permitted (1)</span></span></code> </pre> <br><p>  A complete list of privileges can be found <a href="https://docs.docker.com/engine/reference/run/">here</a> .  I recommend that you familiarize yourself with it and remove all the privileges that your containers do not need. </p><br><p>  If you create a container without a namespace, then by default, processes running inside the container will be run on behalf of the superuser from the point of view of the host. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run -d -P nginx # ps aux | grep nginx root 18951 0.2 0.0 32416 4928 ? Ss 12:31 0:00 nginx: master process nginx -g daemon off;</span></span></code> </pre> <br><p>  However, we can create a separate <a href="https://docs.docker.com/engine/security/userns-remap/">custom namespace</a> .  To do this, add the conf key to the <strong><em>/etc/docker/daemon.json</em></strong> file (be careful, follow the json syntax rules): </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"userns-remap"</span></span>: <span class="hljs-string"><span class="hljs-string">"default"</span></span></code> </pre> <br><p>  Restart the Docker.  This will create a user <strong><em>dockremap</em></strong> .  The new namespace will be empty. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl restart docker # docker ps</span></span></code> </pre> <br><p>  Run the nginx image again: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run -d -P nginx # ps aux | grep nginx 165536 19906 0.2 0.0 32416 5092 ? Ss 12:39 0:00 nginx: master process nginx -g daemon off;</span></span></code> </pre> <br><p>  Now the <strong><em>nginx</em></strong> process runs in a different (user-defined) namespace.  Thus, we managed to improve the isolation of containers. </p><br><h2 id="podlinnost-obrazov-docker">  Docker image authenticity </h2><br><p>  <strong>Description</strong> </p><br><p>  You can find many Docker images on the Internet that do all sorts of useful and cool things, but if you download images without using any mechanisms of trust and authentication, you are essentially running <a href="https://blog.acolyer.org/2017/04/03/a-study-of-security-vulnerabilities-on-docker-hub/">arbitrary software</a> on your systems. </p><br><ul><li>  Where did this image come from? </li><li>  Do you trust its creators?  What security policies do they use? </li><li>  Do you have an objective cryptographic proof that the image was really created by these people? </li><li>  Are you sure that no one changed the image after it was uploaded? </li></ul><br><p>  Docker will launch whatever you ask for, so <strong>encapsulation</strong> will not help here.  Even if you use exclusively images of your own production, it makes sense to check if someone changes them after creation.  The solution ultimately comes down to the classic PKI-based chain of trust. </p><br><p>  <strong>Best practics</strong> </p><br><ul><li><p>  Common Sense: Do not run untested software and / or software from untrusted sources. </p><br></li><li><p>  Using the Docker registry servers, which can be found in this list of <a href="https://sysdig.com/blog/20-docker-security-tools/">Docker Security Tools</a> , expand the trust server. </p><br></li><li>  For any image that loads or runs on the system, provide a mandatory digital signature verification. </li></ul><br><p>  <strong>Examples</strong> </p><br><p>  Deploying a full-fledged trusted server is beyond the scope of this article, but you can now start by signing your images. </p><br><p>  If you don‚Äôt have an account on <a href="https://hub.docker.com/">Docker Hub</a> , get one. </p><br><p>  Create a directory with a simple Dockerfile with the following contents: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat Dockerfile FROM alpine:latest</span></span></code> </pre> <br><p>  Collect the image: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker build -t &lt;youruser&gt;/alpineunsigned .</span></span></code> </pre> <br><p>  Log in to your Docker Hub account and download the image: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker login [‚Ä¶] # docker push &lt;youruser&gt;/alpineunsigned:latest</span></span></code> </pre> <br><p>  Enable Docker Trust in Docker: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># export DOCKER_CONTENT_TRUST=1</span></span></code> </pre> <br><p>  Now try to get the image you just uploaded: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker pull &lt;youruser&gt;/alpineunsigned</span></span></code> </pre> <br><p>  You should receive the following error: </p><br><pre> <code class="bash hljs">Using default tag: latest Error: remote trust data does not exist <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> docker.io/&lt;youruser&gt;/alpineunsigned: notary.docker.io does not have trust data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> docker.io/&lt;youruser&gt;/alpineunsigned</code> </pre> <br><p>  With DOCKER_CONTENT_TRUST turned on, collect the container again.  Now it will be signed by default. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker build --disable-content-trust=false -t &lt;youruser&gt;/alpinesigned:latest .</span></span></code> </pre> <br><p>  Now you can download and download signed containers without any security warnings.  When you first download a trusted image, Docker will create a <a href="https://docs.docker.com/engine/security/trust/content_trust/">root key</a> for you.  You will also need a repository key.  In both cases, you will be asked to set a password. </p><br><p>  Your private keys will be saved in the <strong><em>~ / .docker / trust</em></strong> directory, restrict access to them and create a backup. </p><br><p>  DOCKER_CONTENT_TRUST is an environment variable that will disappear after the terminal session is closed.  However, a trust check must be implemented at every stage of the process - from assembling images and placing them in registries to downloading and executing on servers. </p><br><h2 id="zloupotreblenie-resursami">  Resource abuse </h2><br><p>  <strong>Description</strong> </p><br><p>  On average, containers are much more numerous than virtual machines.  They are lightweight, which allows you to run a lot of containers, even on a very modest iron.  This is certainly an advantage, but the other side of the coin is a serious competition for host resources.  Errors in software, design flaws, and hacker attacks can lead to <strong><em>Denial of Service</em></strong> .  To prevent them, you must properly configure resource limits. </p><br><p>  The situation is worsened by the fact that there are several resources that need to be monitored: CPU, memory, disk space, network load, I / O, paging, etc. There are <a href="https://sysdig.com/blog/container-isolation-gone-wrong/">not so obvious resources</a> in the kernel as, for example, user identifiers ( UIDs). </p><br><p>  <strong>Best practics</strong> </p><br><p>  By default, in most containerization systems, the restriction of these resources is disabled.  However, in the production of their customization is simply required.  I recommend to adhere to the following principles: </p><br><ul><li><p>  Use the resource limit functions that come with the Linux kernel and / or containerization systems. </p><br></li><li><p>  Try to carry out load testing of the system before its launch into commercial operation.  For this purpose, both synthetic tests and ‚Äúplayback‚Äù of real traffic of the combat system are used.  Load testing is vital for finding out the limits and <strong><em>normal</em></strong> workloads. </p><br></li><li>  Deploy <a href="https://sysdig.com/">monitoring and alerts for Docker</a> .  I am sure that in case of abuse of resources (malicious or not) you would prefer to receive a timely warning instead of falling into the wall at full speed. </li></ul><br><p>  <strong>Examples</strong> </p><br><p>  Control groups ( <strong><em>cgroups</em></strong> ) is a tool provided by the Linux kernel that allows you to limit the access of processes and containers to system resources.  Some limits can be controlled from the Docker command line: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run -it --memory=2G --memory-swap=3G ubuntu bash</span></span></code> </pre> <br><p>  This command will set the limit of 2 GB of available memory to a container (only 3 GB for main memory and paging).  To check the constraints, run the load simulator, for example, the <code>stress</code> program, which is in the Ubuntu repositories: </p><br><pre> <code class="bash hljs">root@e05a311b401e:/<span class="hljs-comment"><span class="hljs-comment"># stress -m 4 --vm-bytes 8G</span></span></code> </pre> <br><p>  In the output of the program you will see the line 'FAILED'. </p><br><p>  The following lines should appear in the host <strong><em>syslog</em></strong> : </p><br><pre> <code class="bash hljs">Aug 15 12:09:03 host kernel: [1340695.340552] Memory cgroup out of memory: Kill process 22607 (stress) score 210 or sacrifice child Aug 15 12:09:03 host kernel: [1340695.340556] Killed process 22607 (stress) total-vm:8396092kB, anon-rss:363184kB, file-rss:176kB, shmem-rss:0kB</code> </pre> <br><p>  With <code>docker stats</code> you can clarify current memory consumption and set limits.  In the case of Kubernetes, in the submission definition, you can reserve the resources necessary for the normal operation of the application, as well as set limits.  See <a href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/">requests and limits</a> : </p><br><pre> <code class="hljs mel">[...] - name: wp <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: wordpress resources: requests: <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-string"><span class="hljs-string">"64Mi"</span></span> cpu: <span class="hljs-string"><span class="hljs-string">"250m"</span></span> limits: <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-string"><span class="hljs-string">"128Mi"</span></span> cpu: <span class="hljs-string"><span class="hljs-string">"500m"</span></span> [...]</code> </pre> <br><h2 id="uyazvimosti-v-obrazah-konteynerov">  Container Vulnerabilities </h2><br><p>  <strong>Description</strong> </p><br><p>  Containers are insulated black boxes.  If they perform their functions, it is easy to forget which programs of which versions are running inside.  The container can perfectly cope with its responsibilities from an operational point of view, while using vulnerable software.  These vulnerabilities can be fixed long ago in upstream, but not in your local image.  If you do not take appropriate measures, problems of this kind can go unnoticed for a long time. </p><br><p>  <strong>Best practics</strong> </p><br><p>  The presentation of containers as unchangeable atomic parts of the system is reasonable from an architectural point of view, however, to ensure safety, their contents should be regularly checked: </p><br><ul><li>  To get the latest fixes for vulnerabilities, regularly update and rebuild your images.  Of course, do not forget to test them before sending to production. <br><ul><li>  Patching working containers is considered bad form.  It is better to rebuild the image with each update.  Docker implements a declarative, efficient and easy-to-understand build system, so this procedure is actually simpler than it seems at first glance. </li><li>  Use software that regularly receives security updates.  Everything that you install manually, bypassing the repositories of your distribution, you need to update yourself in the future. </li><li>  <a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/">Gradual rolling updates</a> without service interruption are considered to be a fundamental feature of the system building model using Docker and microservices. </li><li>  User data is separated from container images, which makes the upgrade process safer. </li></ul></li><li>  Do not complicate.  Simple systems are less likely to require updates.  The smaller the components in the system, the smaller the attack surface and the easier the upgrade.  Break containers if they become too complex. </li><li>  Use vulnerability scanners.  There are plenty of them now - both free and commercial.  Try to keep abreast of developments related to the security of the software you use, subscribe to mailing lists, alert services, etc. <br><ul><li>  Make security scanning a mandatory step in your CI / CD chains, automate as much as possible - don't rely only on manual checks. </li></ul></li></ul><br><p>  <strong>Examples</strong> </p><br><p>  Many Docker image registries offer an image scanning service.  Choose, for example, <a href="https://quay.io/">CoreOS Quay</a> , which uses an open source Docker image security scanner called <a href="https://github.com/coreos/clair">Clair</a> .  Quay is a commercial platform, but some services are free.  You can create a trial account by following <a href="https://quay.io/plans/">these instructions</a> . </p><br><p>  After registering your account, open <strong><em>Account Settings</em></strong> and set a new password (you will need it to create repositories). </p><br><p>  Click <strong>+</strong> in the upper right corner and create a new public repository: </p><br><img src="https://habrastorage.org/web/08e/4ef/671/08e4ef6712334137b23f58a29bc123a7.png"><br><br><p>  Here we will create an empty repository, but, as can be seen in the screenshot, there are other options. </p><br><p>  Now from the console, log in to Quay and upload a local image there: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker login quay.io # docker push quay.io/&lt;your_quay_user&gt;/&lt;your_quay_image&gt;:&lt;tag&gt;</span></span></code> </pre> <br><p>  If the image is already loaded, you can click on its ID and see the results of the security scan, sorted in descending order of vulnerability, which are provided with links to CVE and package versions containing fixes. </p><br><img src="https://habrastorage.org/web/dda/4b6/400/dda4b64000fa40d18d0a704d5c444718.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2 id="uchetnye-dannye-i-sekrety-docker">  Docker credentials and secrets </h2><br><p>  <strong>Description</strong> </p><br><p>  In most cases, programs need confidential data for normal operation: user password hashes, certificates, encryption keys, etc. This situation is exacerbated by the nature of the containers: you do not just raise the server, but set up an environment in which microservices can be constantly created and destroyed.  In this case, an automatic, reliable and secure process of using confidential information is required. </p><br><p>  <strong>Best practics</strong> </p><br><ul><li><p>  Do not use environment variables to store secrets.  This is a common and unsafe practice. </p><br></li><li><p>  Do not keep secrets in the images of containers.  Read this <a href="https://wycd.net/posts/2017-02-21-ibm-whole-cluster-privilege-escalation-disclosure.html">discovery and resolution report for a vulnerability in one of the IBM services</a> : ‚ÄúThe private key and certificate were left behind in the container image by mistake.‚Äù </p><br></li><li>  If your system is complex enough, deploy Docker credential management software.  In the <a href="https://sysdig.com/blog/20-docker-security-tools/">Docker security tools</a> article, we looked at several commercial and free solutions.  Take up creating your own secrets repository (with downloading secrets using <code>curl</code> , mounting volumes, etc., etc.) only if you know very well what you are doing. </li></ul><br><p>  <strong>Examples</strong> </p><br><p>  First, let's see how environment variables are intercepted: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run -it -e password='S3cr3tp4ssw0rd' alpine sh / # env | grep pass password=S3cr3tp4ssw0rd</span></span></code> </pre> <br><p>  That is, it is elementary, even if you switch to a regular user with <strong><em>su</em></strong> : </p><br><pre> <code class="bash hljs">/ <span class="hljs-comment"><span class="hljs-comment"># su user / $ env | grep pass password=S3cr3tp4ssw0rd</span></span></code> </pre> <br><p>             . ,  Kubernetes    <code>secret</code> .  Docker Swarm        ,    : </p><br><p>   Docker Swarm (,       ): </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker swarm init --advertise-addr &lt;your_advertise_addr&gt;</span></span></code> </pre> <br><p>      ‚Äî    : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat secret.txt This is my secret</span></span></code> </pre> <br><p>         (secret resource): </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker secret create somesecret secret.txt</span></span></code> </pre> <br><p>   Docker Swarm      (   <strong><em>uid, gid, mode</em></strong>  . .): </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker service create --name nginx --secret source=somesecret,target=somesecret,mode=0400 nginx</span></span></code> </pre> <br><p>    nginx ‚Äî        : </p><br><pre> <code class="bash hljs">root@3989dd5f7426:/<span class="hljs-comment"><span class="hljs-comment"># cat /run/secrets/somesecret This is my secret root@3989dd5f7426:/# ls /run/secrets/somesecret -r-------- 1 root root 19 Aug 28 16:45 /run/secrets/somesecret</span></span></code> </pre> <br><p>        ,                 . </p><br><h2 id="monitoring-bezopasnosti-docker-vo-vremya-vypolneniya">   Docker    </h2><br><p>  <strong>Description</strong> </p><br><p>             Docker:  ,  , ,         ,  . .   ,      ,           ? </p><br><p> <strong> </strong> </p><br><ul><li><p>         .             0-day,    ?          Windows,            . </p><br></li><li><p>           ,       .        . </p><br></li><li>          ,         . </li></ul><br><p>  <strong>Examples</strong> </p><br><p> <a href="https://www.sysdig.org/falco/">Sysdig Falco</a> ‚Äî      ,     .    . Sysdig Falco  Linux-            Docker,         ,  container.id, container.image,  Kubernetes   . </p><br><p>  Falco        .   ,  -       production. </p><br><p>    Falco      (   production; ,        ): </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># curl -s https://s3.amazonaws.com/download.draios.com/stable/install-falco | sudo bash # service falco start</span></span></code> </pre> <br><p>        nginx: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run -d --name nginx nginx # docker exec -it nginx bash</span></span></code> </pre> <br><p>      <strong><em>/var/log/syslog</em></strong>    : </p><br><pre> <code class="bash hljs">Aug 15 21:25:31 host falco: 21:25:31.159081055: Debug Shell spawned by untrusted binary (user=root shell=sh parent=anacron cmdline=sh -c run-parts --report /etc/cron.weekly pcmdline=anacron -dsq)</code> </pre> <br><p> ,  Sysdig Falco   ,     .       ,       <a href="https://github.com/draios/falco/wiki/Falco-Examples"></a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker was created taking into account security requirements, and some of its features help in ensuring it. </font><font style="vertical-align: inherit;">However, do not forget about caution, because there is no other way than to constantly monitor current trends and apply the best practices that have developed in this area. </font><font style="vertical-align: inherit;">Also consider using container-specific security tools that help combat vulnerabilities and threats related to using Docker.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I hope the topic you are interested in. </font></font></p><br><p>  References: </p><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Original: </font></font><a href="https://sysdig.com/blog/7-docker-security-vulnerabilities/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 Docker security vulnerabilities and threats</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ol></div><p>Source: <a href="https://habr.com/ru/post/339126/">https://habr.com/ru/post/339126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339116/index.html">3 cases of real estate data analysis. Data Science Week 2017. Review. Part 1</a></li>
<li><a href="../339118/index.html">Three career paths in IT: founder, leader or employee</a></li>
<li><a href="../339120/index.html">What will happen in Rancher 2.0 and why does it switch to Kubernetes?</a></li>
<li><a href="../339122/index.html">Debugging PL / SQL code for an external DB session</a></li>
<li><a href="../339124/index.html">We write the generator of ip-addresses in Python with whistles, dudels and Tkinter GUI</a></li>
<li><a href="../339128/index.html">VMware vCloud Director. What's new in version 9.0?</a></li>
<li><a href="../339136/index.html">A selection of interesting events for the week in Moscow</a></li>
<li><a href="../339138/index.html">Decompilation of RNC ProPack 5 years long</a></li>
<li><a href="../339140/index.html">ITMO University team reached the final of the World Robot Olympiad</a></li>
<li><a href="../339142/index.html">‚ÄúOne more step to blockchain‚Äù: Bitfury Group presented Exonum 0.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>