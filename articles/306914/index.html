<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding Go: io Package</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of one of Ben Johnson's articles from the "Go Walkthrough" series on a more in-depth study of the standard library in the context of real-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding Go: io Package</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Translation of one of Ben Johnson's articles from the "Go Walkthrough" series on a more in-depth study of the standard library in the context of real-world tasks.</em> </p><br><p>  Go is a well-adapted bytes programming language.  Whether you have lists of bytes, streams of bytes, or just individual bytes, Go makes it easy to work with them.  These are the primitives on which we build our abstractions and services. </p><br><p>  The <a href="https://golang.org/pkg/io">io</a> package is one of the most fundamental in the entire standard library.  It provides a set of interfaces and auxiliary functions for working with byte streams. </p><br><p>  This post is one of a series of articles on a more in-depth analysis of the standard library.  Despite the fact that standard documentation provides a lot of useful information, in the context of real-world tasks it can be difficult to figure out what to use and when.  This series of articles aims to show the use of standard library packages in the context of real-world applications. </p><a name="habracut"></a><br><h2>  Reading bytes </h2><br><p>  When working with bytes, there are two fundamental operations: reading and writing.  Let's first take a look at reading bytes. </p><br><h3>  Reader Interface </h3><br><p>  The simplest design for reading bytes from a stream is the <a href="https://golang.org/pkg/io/">Reader</a> interface: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Read(p []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br><p>  This interface is repeatedly implemented in the standard library for everything in general - from <a href="https://golang.org/pkg/net/">network connections</a> to <a href="https://golang.org/pkg/os">files</a> and to <a href="https://golang.org/pkg/bytes/">wrappers for slices in memory</a> . </p><br><p>  The reader takes the buffer, p, as an input to the Read () method, so that it does not need to allocate memory.  If Read () returned a new slice, instead of taking it as an argument, the reader would have to allocate memory each time Read () was called.  It would be a disaster for the garbage collector. </p><br><p>  One of the problems with the Reader interface is that it comes with a set of rather ornate rules.  First, it returns an io.EOF error during the normal course of business, simply if the data stream has terminated.  This can be confusing for newbies.  Secondly, there is no guarantee that your buffer will be full.  If you sent an 8-byte slice, in fact you can read from 0 to 8 bytes.  The processing of reading in parts can be difficult and easily error prone.  Fortunately, we have quite a few support functions for solving these problems. </p><br><h3>  Improving reading guarantees </h3><br><p>  Imagine that you have a protocol that needs to be parsed and you want to read an 8-byte uint64 value from the reader.  In this case, it is preferable to use io.ReadFull (), since you know exactly how much you want to read: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r Reader, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span></code> </pre> <br><p>  This function checks that the buffer is full before returning a value.  If the size of the received data differs from the buffer size, then you will get an io.ErrUnexpectedEOF error.  This simple guarantee simplifies the code quite a lot.  To read 8 bytes, just do this: </p><br><pre> <code class="go hljs"> buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := io.ReadFull(r, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  There are also quite a few higher-level parsers like <a href="https://golang.org/pkg/encoding/binary/">binary.Read ()</a> that can parse certain types.  We will get closer to them in the next posts about other packages. </p><br><p>  Another slightly less used auxiliary function is <a href="https://golang.org/pkg/io/">ReadAtLeast ()</a> : </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadAtLeast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r Reader, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, min </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span></code> </pre> <br><p>  This function writes readable data into your buffer, but not less than the specified number of bytes.  I did not find the need for this function for myself, but I can easily imagine its benefit for cases when you want to reduce the number of Read () calls and buffer additional data. </p><br><h3>  Thread merging </h3><br><p>  Often you can meet a situation where you need to combine several readers together.  This is easy to do with <a href="https://golang.org/pkg/io/">MultiReader</a> : </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MultiReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(readers ...Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reader</span></span></span></span></code> </pre> <br><p>  For example, you want to send an HTTP response in which the header is read from memory, and the content of the response body is from a file.  Many people will first read the file into a buffer in memory before sending it, but it is slow and may require a lot of memory. </p><br><p>  Here is a simpler approach: </p><br><pre> <code class="go hljs"> r := io.MultiReader( bytes.NewReader([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"...my header..."</span></span>)), myFile, ) http.Post(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/octet-stream"</span></span>, r)</code> </pre> <br><p>  MultiReader allows <a href="http/">http.Post () to</a> use both readers as one. </p><br><h3>  Duplication of streams </h3><br><p>  One of the points that you may encounter when working with readers is that if the data were read, they cannot be read again.  For example, your application could not parse the HTTP request body, but you cannot analyze it, because the parser has already read the data, it is no longer in the reader. </p><br><p>  <a href="https://golang.org/pkg/io/">TeeReader</a> is a good solution here - it allows you to save the read data, while not interfering with the reading process. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TeeReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r Reader, w Writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reader</span></span></span></span></code> </pre> <br><p>  This function creates a new wrapper reader around your r reader.  Any read operation from a new reader will also write data to w.  This writer can be anything from a <a href="https://golang.org/pkg/bytes/">buffer in memory</a> to a log file to the standard error stream <a href="https://golang.org/pkg/os/">STDERR</a> . </p><br><p>  For example, you can capture erroneous queries like this: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer body := io.TeeReader(req.Body, &amp;buf) <span class="hljs-comment"><span class="hljs-comment">// ... process body ... if err != nil { // inspect buf return err }</span></span></code> </pre> <br><p>  However, it is important to be careful with the size of the read response body, so as not to waste memory. </p><br><h3>  Stream Length Restriction </h3><br><p>  Since streams are not limited in size, sometimes reading from them can lead to problems with memory or disk space.  A typical example is a file handler.  Usually, there are limits on the maximum size of the loaded file in order not to overflow the disk, but it can be tedious to implement them manually. </p><br><p>  <a href="https://golang.org/pkg/io/">LimitReader</a> gives us this functionality by providing a wrapper around the reader that limits the number of bytes available for reading. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LimitReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r Reader, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reader</span></span></span></span></code> </pre> <br><p>  One of the moments when working with LimitReader is that it will not tell you if r has subtracted more than n.  It will simply return <a href="https://golang.org/pkg/io/">io.EOF</a> as soon as it subtracts n bytes.  Alternatively, you can set the limit to n + 1 and then check whether you have read more than n bytes at the end. </p><br><h2>  Byte writing </h2><br><p>  Now, after we got acquainted with reading bytes from streams, let's see how to write them to streams. </p><br><h3>  Interface writer </h3><br><p>  The Writer interface is essentially an inverted Reader.  We specify a set of bytes to be written to the stream: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Writer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Write(p []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br><p>  In general, writing bytes is a simpler operation than reading.  With readers, the difficulty is to work correctly with partial and incomplete readings, but with partial or incomplete writing, we just get an error. </p><br><h3>  Duplicate recording </h3><br><p>  Sometimes you need to send data to several writers at once.  For example, in a log file and in STDERR.  This is similar to TeeReader, only we want to duplicate the record, not the reading. </p><br><p>  In this case, we are suitable <a href="https://golang.org/pkg/io/">MultiWriter</a> : </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MultiWriter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(writers ...Writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Writer</span></span></span></span></code> </pre> <br><p>  The name may be a little confusing, because it is not quite the writer-version of the MultiReader.  If the MultiReader combines several readers into one, the MultiWriter returns a writer that duplicates the entries in all the writers. </p><br><p>  I actively use MultiWriter in unit tests, where I want to make sure that the services write to the log correctly: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { LogOuput io.Writer } ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s MyService s.LogOutput = io.MultiWriter(&amp;buf, os.Stderr)</code> </pre> <br><p>  Using MultiWriter allows me to check the contents of the buf and at the same time see the full output of the logs in the terminal for debugging. </p><br><h2>  Copy bytes </h2><br><p>  Now that we‚Äôve dealt with both reading and writing bytes, it‚Äôs logical to figure out how we can combine these two operations together and copy the data between them. </p><br><h3>  Combining readers &amp; writers </h3><br><p>  The easiest way to copy from the reader to the writer is to use the <a href="https://golang.org/pkg/io/">Copy ()</a> function: </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dst Writer, src Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(written </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span></code> </pre> <br><p>  This function uses a 32 KB buffer to read from src and write to dst.  If an error other than io.EOF occurs, the copying stops and the error returns. </p><br><p>  One of the problems with Copy () is that you have no way to guarantee the maximum number of bytes copied.  For example, you want to copy a log file to its current size.  If the log continues to grow while copying, you will get more bytes than expected.  In this case, you can use the <a href="https://golang.org/pkg/io/">CopyN ()</a> function, which copies no more than the specified number: </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dst Writer, src Reader, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(written </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span></code> </pre> <br><p>  Another important point with Copy () is that each copy is allocated a buffer of 32KB.  If you need to do many copy operations, you can reuse the already allocated buffer and use <a href="https://golang.org/pkg/io/">CopyBuffer ()</a> : </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dst Writer, src Reader, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(written </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span></code> </pre> <br><p>  The overhead of Copy () is actually very small, so I personally do not use CopyBuffer (). </p><br><h3>  We optimize copying </h3><br><p>  To avoid the use of an intermediate buffer, data types can implement special interfaces for reading and writing them directly.  If they are implemented for a type, the Copy () function will not use a buffer, but will use these special methods. </p><br><p>  If the type implements the <a href="https://golang.org/pkg/io/">WriterTo</a> interface, then it can write data directly: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> WriterTo <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WriteTo(w Writer) (n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>, err error) }</code> </pre> <br><p>  I used it in the BoltDB <a href="https://godoc.org/github.com/boltdb/bolt">Tx.WriteTo ()</a> function, which allows users to create a database snapshot from a transaction. </p><br><p>  On the other hand, the ReaderFrom interface allows the type to directly read data from the reader: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ReaderFrom <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ReadFrom(r Reader) (n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>, err error) }</code> </pre> <br><h3>  Adaptation of readers and writers </h3><br><p>  Sometimes you find yourself in a situation where you have a function that accepts a Reader, but you only have a Writer.  You may want to dynamically write data to an HTTP request, but http.NewRequest () only accepts Reader. </p><br><p>  You can invert the writer using <a href="https://golang.org/pkg/io/">io.Pipe ()</a> : </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PipeReader, *PipeWriter)</span></span></span></span></code> </pre> <br><p>  Here you get a new reader and writer.  Any entry to the PipeWriter will be forwarded to the PipeReader. </p><br><p>  I rarely used this function, but <a href="https://golang.org/pkg/os/exec/">exec.Cmd</a> uses it to implement Stdin, Stdout and Stderr pipes, which can be very useful when working with programs that are started. </p><br><h2>  Closing threads </h2><br><p>  Everything good comes to an end, and work with threads is no exception.  The Closer interface provides a general way to close threads: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Closer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Close() error }</code> </pre> <br><p>  There‚Äôs nothing to write about, the interface is very simple, but I always try to return an error in my Close () methods so that my types implement this interface if necessary.  Closer is not always used directly; it is often used in conjunction with other interfaces, such as <a href="https://golang.org/pkg/io/">ReadCloser</a> , <a href="https://golang.org/pkg/io/">WriteCloser,</a> and <a href="https://golang.org/pkg/io/">ReadWriteCloser</a> . </p><br><h2>  Thread Navigation </h2><br><p>  Flows are usually constantly appearing data from start to finish, but there are exceptions.  A file, for example, can be a stream, but you can also arbitrarily move to any position within the file. </p><br><p>  The Seeker interface provides the ability to navigate within the stream: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Seeker <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Seek(offset <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>, whence <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>, error) }</code> </pre> <br><p>  There are three ways to jump to the desired position: the transition from the current position, the transition from the beginning of the stream and the transition from the end.  You specify this method with the argument whence.  Argument offset indicates how many bytes to move. </p><br><p>  Streaming can be useful if you use blocks of fixed size or if your file contains an index with offsets.  Sometimes the data is in the header and it is logical to use the transition from the beginning of the stream, but sometimes the data is in the tail and it is more convenient to move from the end. </p><br><h2>  Optimization for data types </h2><br><p>  Reading and writing portions can be tedious if all you need is a single byte or <a href="https://golang.org/pkg/builtin/">rune</a> .  Go has interfaces that make life easier. </p><br><h3>  Work with individual bytes </h3><br><p>  The <a href="https://golang.org/pkg/io/">ByteReader</a> and <a href="https://golang.org/pkg/io/">ByteWriter interfaces</a> provide simple methods for reading and writing one byte: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ByteReader <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ReadByte() (c <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, err error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ByteWriter <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WriteByte(c <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) error }</code> </pre> <br><p>  Note that there is no parameter for the number of bytes, it will always be 0 or 1. If the byte has not been read or written, an error is returned. </p><br><p>  There is also a <a href="https://golang.org/pkg/io/">ByteScanner</a> interface that allows you to conveniently work with buffered readers for bytes: </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ByteScanner <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ByteReader UnreadByte() error }</code> </pre> <br><p>  This interface allows you to return a byte back to the stream.  This is convenient, for example, when writing LL (1) parsers, since it allows you to look at the byte forward. </p><br><h3>  Work with individual runes </h3><br><p>  If you parse Unicode data, then you should work with runes instead of individual bytes.  In this case, you must use the <a href="https://golang.org/pkg/io/">RuneReader</a> and <a href="https://golang.org/pkg/io/">RuneScanner interfaces</a> : </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> RuneReader <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ReadRune() (r <span class="hljs-keyword"><span class="hljs-keyword">rune</span></span>, size <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> RuneScanner <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { RuneReader UnreadRune() error }</code> </pre> <br><h2>  Conclusion </h2><br><p>  Byte streams are important for many Go programs.  These are interfaces for everything from network connections to disk files to user input from the keyboard.  The <a href="https://golang.org/pkg/io">io</a> package provides basic primitives for working with all of this. </p><br><p>  We looked at reading, writing and copying bytes, as well as optimizing these operations for specific tasks.  These primitives may look simple, but they are the basic building blocks for applications that are actively working with data. </p><br><p>  Please study the io package carefully and use its interfaces in your programs.  Also, I‚Äôll be happy if you share your interesting ways of using the <a href="https://golang.org/pkg/io">io</a> package, as well as any tips on how to improve this series of articles. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306914/">https://habr.com/ru/post/306914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306902/index.html">Hamlet's smuggling with a cat</a></li>
<li><a href="../306904/index.html">We work with a hybrid cloud: VMware vCloud Connector, part 1</a></li>
<li><a href="../306906/index.html">Shake dust from the globe: check the project NASA World Wind</a></li>
<li><a href="../306908/index.html">It doesn't matter if you are big or small. The main thing is not small. Stuffing Material Design</a></li>
<li><a href="../306912/index.html">Moscow Institute of Physics and Technology: the reception of applications to the online magistracy in modern combinatorics is ending</a></li>
<li><a href="../306916/index.html">Stylization of images using neural networks: no mysticism, just matan</a></li>
<li><a href="../306918/index.html">11 Essential Hiring Tips for Starting Employers</a></li>
<li><a href="../306920/index.html">Is there life after the failure of popular browsers to support the architecture of NPAPI</a></li>
<li><a href="../306922/index.html">Creating a Doodle Jump game for Android in Intel XDK in 2 hours on JavaScript from scratch</a></li>
<li><a href="../306924/index.html">Mal, Yes Del: Review younger servers in the HPE ProLiant ML line</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>