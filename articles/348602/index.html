<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Boost.Asio with Coroutines TS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Using callbacks is a popular approach to building network applications using the Boost.Asio library (and not only that). The problem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Boost.Asio with Coroutines TS</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br><p>  Using callbacks is a popular approach to building network applications using the Boost.Asio library (and not only that).  The problem with this approach is the deterioration of readability and maintainability of the code with the complication of the logic of the data exchange protocol <a href="https://habrahabr.ru/post/201826/">[1]</a> . </p><br><p>  As an alternative to callbacks, coroutines can be used to write asynchronous code, the readability level of which will be close to the readability of synchronous code.  Boost.Asio supports this approach by providing the ability to use the Boost.Coroutine library to handle callbacks. </p><br><p>  Boost.Coroutine implements the coroutines by storing the execution context of the current thread.  This approach competed for the inclusion of the C ++ standard in the next edition of the proposal from Microsoft, which introduces the new keywords co_return, co_yield and co_await.  The Microsoft offer has received the status of Technical Specification (TS) <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4649.pdf">[2]</a> and has a high chance of becoming a standard. </p><br><p>  Article <a href="https://blogs.msdn.microsoft.com/vcblog/2017/05/19/using-c-coroutines-with-boost-c-libraries/">[3]</a> demonstrates the use of Boost.Asio with Coroutines TS and boost :: future.  In my article I want to show how you can do without boost :: future.  We will take as <a href="">an example an</a> asynchronous TCP echo server from Boost.Asio and modify it using coroutines from Coroutines TS. </p><br><a name="habracut"></a><br><p>  At the time of writing, Coroutines TS is implemented in the Visual C ++ 2017 compilers and clang 5.0.  We will use clang.  You must set compiler flags to enable experimental support for the C ++ 20 standard (-std = c ++ 2a) and Coroutines TS (-fcoroutines-ts).  You also need to include the header file &lt;experimental / coroutine&gt;. </p><br><br><h1>  Coroutine to read from socket </h1><br><br><p>  In the original example, the function to read from the socket looks like this: </p><br><pre><code class="hljs markdown">void do<span class="hljs-emphasis"><span class="hljs-emphasis">_read() { auto self(shared_</span></span>from<span class="hljs-emphasis"><span class="hljs-emphasis">_this()); socket_</span></span>.async<span class="hljs-emphasis"><span class="hljs-emphasis">_read_</span></span>some( boost::asio::buffer(data<span class="hljs-emphasis"><span class="hljs-emphasis">_, max_</span></span>length), [<span class="hljs-string"><span class="hljs-string">this, self</span></span>](<span class="hljs-link"><span class="hljs-link">boost::system::error_code ec, std::size_t length</span></span>) { if (!ec) { do_write(length); } }); }</code> </pre> <br><p>  We initiate an asynchronous read from the socket and set the callback to be called upon receiving the data and initiate sending it back.  The original recording function looks like this: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shared_from_this())</span></span></span></span>; boost::asio::async_write( socket_, boost::asio::buffer(data_, length), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self](boost::system::error_code ec, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-comment"><span class="hljs-comment">/*length*/</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ec) { do_read(); } }); }</code> </pre><br><p>  If we successfully write data to the socket, we again initiate an asynchronous read.  In essence, the program logic is reduced to a loop (pseudocode): </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!ec) { ec = <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ec) { ec = <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(buffer); } }</code> </pre><br><p>  It would be convenient to encode this in the form of an explicit loop, but in that case we would have to read and write synchronous operations.  This is not suitable for us, since we want to serve several client sessions in one execution thread at the same time.  Coroutines come to the rescue.  Rewrite the do_read () function as follows: </p><br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shared_from_this())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>[ec, length] = co_await async_read_some( socket_, boost::asio::buffer(data_, max_length)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ec) { do_write(length); } }</code> </pre><br><p>  Using the co_await keyword (as well as co_yield and co_return) turns a function into a coroutine.  Such a function has several points (suspension point), where its execution is suspended (suspend) while preserving the state (values ‚Äã‚Äãof local variables).  Later, the coroutine can be resumed (resume), starting at the last stop.  The co_await keyword in our function creates a suspension point: after an asynchronous reading is initiated, the do_read () coroutine execution will be suspended until the reading is completed.  The function does not return from the function, but the program continues from the point where the coroutine is called.  When the client connects, session :: start () is called, where do_read () is called the first time for this session.  After the start of asynchronous reading, the start () function continues, the return from it occurs and the reception of the next connection is initiated.  Then the code from Asio, which called the handler argument async_accept (), continues. </p><br><p>  In order for the co_await magic to work, its expression ‚Äî in our case, the async_read_some () function ‚Äî must return a class object that corresponds to a specific contract.  The implementation of async_read_some () is taken from the comment to the article <a href="https://blogs.msdn.microsoft.com/vcblog/2017/05/19/using-c-coroutines-with-boost-c-libraries/">[3]</a> . </p><br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SyncReadStream, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DynamicBuffer&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_read_some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Awaiter</span></span></span><span class="hljs-class"> {</span></span> SyncReadStream &amp;s; DynamicBuffer buffers; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sz; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; coro)</span></span></span><span class="hljs-function"> </span></span>{ s.async_read_some(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffers), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, coro](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sz) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;ec = ec; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;sz = sz; coro.resume(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(ec, sz); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Awaiter{s, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;DynamicBuffer&gt;(buffers)}; }</code> </pre><br><p>  async_read_some () returns an Awaiter class object that implements the contract required by co_await: </p><br><ul><li>  await_ready () is called at the beginning of the wait to check if the result of the asynchronous operation is ready.  Because to get the result, we always need to wait until the data is read, we return false. </li><li>  await_suspend () is called before the calling coroutine is suspended.  Here we initiate an asynchronous read and pass a handler that will save the results of the asynchronous operation to the Awaiter member variables and resume the coroutine. </li><li>  await_resume () - the return value of this function will be the result of executing co_await.  Just return the previously saved results of the asynchronous operation. </li></ul><br><p>  If we now try to build our program, we get a compilation error: </p><br><br><pre> <code class="hljs cs">error: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> function cannot be a coroutine: <span class="hljs-string"><span class="hljs-string">'std::experimental::coroutines_v1::coroutine_traits&lt;void, session &amp;&gt;'</span></span> has no member named <span class="hljs-string"><span class="hljs-string">'promise_type'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ^</code> </pre><br><p>  The reason is that the compiler requires that some kind of contract be implemented for the coroutine too.  This is done using the std :: experimental :: coroutine_traits template specialization: </p><br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:experimental::coroutine_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, Args...&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">promise_type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_return_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::experimental::<span class="hljs-function"><span class="hljs-function">suspend_never </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::experimental::<span class="hljs-function"><span class="hljs-function">suspend_never </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">final_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unhandled_exception</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::terminate(); } }; };</code> </pre><br><p>  We specialized coroutine_traits for coroutines with a return value of type void and any number and type of parameters.  The coroutine do_read () fits this description.  The template specialization contains the type promise_type with the following functions: </p><br><ul><li>  get_return_object () is called to create an object that the coroutine will subsequently fill in and return.  In our case, nothing needs to be created, since do_read () returns nothing. </li><li>  initial_suspend () determines whether the coroutine will be suspended before the first call.  The analogy is the launch of a suspended thread in Windows.  We need do_read () to execute without an initial stop, so we return suspend_never. </li><li>  final_suspend () determines whether the coroutine will be suspended before returning a value and ending.  Return suspend_never. </li><li>  return_void () tells the compiler that the coroutine returns nothing. </li><li>  unhandled_exception () is called if an exception was thrown inside the coroutine, and it was not handled inside the coroutine.  In this case, abort the program. </li></ul><br><p>  Now you can start the server and check its operation by opening several connections using telnet. </p><br><br><h1>  Coroutine to write to socket </h1><br><p>  The do_write () write function is still based on the use of a callback.  Fix it.  Rewrite do_write () as follows: </p><br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shared_from_this())</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Awaiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;session&gt; ssn; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ec; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; coro)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>[ec, sz] = co_await async_write( ssn-&gt;socket_, boost::asio::buffer(ssn-&gt;data_, length)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;ec = ec; coro.resume(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Awaiter{self, length}; }</code> </pre><br><p>  Let's write an awaitable wrapper for writing to the socket: </p><br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SyncReadStream, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DynamicBuffer&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Awaiter</span></span></span><span class="hljs-class"> {</span></span> SyncReadStream &amp;s; DynamicBuffer buffers; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sz; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(ec, sz); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; coro)</span></span></span><span class="hljs-function"> </span></span>{ boost::asio::async_write( s, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffers), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, coro](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sz) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;ec = ec; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;sz = sz; coro.resume(); }); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Awaiter{s, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;DynamicBuffer&gt;(buffers)}; }</code> </pre><br><p>  The last step is to rewrite do_read () as an explicit loop: </p><br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shared_from_this())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>[ec, sz] = co_await async_read_some( socket_, boost::asio::buffer(data_, max_length)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ec) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = co_await do_write(sz); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ec) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error writing to socket: "</span></span> &lt;&lt; ec &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error reading from socket: "</span></span> &lt;&lt; ec &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><p>  The program logic is now recorded in a form close to synchronous code, however, it runs asynchronously.  The tar spoon is that we had to write an additional awaitable class for the return value of do_write ().  This illustrates one of the shortcomings of Coroutines TS - the spread of co_await up the stack of asynchronous calls <a href="https://habrahabr.ru/post/278267/">[4]</a> . </p><br><p>  Alteration of the server :: do_accept () function into a coroutine will be left as an exercise.  The full text of the program can be found on <a href="">GitHub</a> . </p><br><br><h1>  Conclusion </h1><br><p>  We looked at using Boost.Asio with Coroutines TS for programming asynchronous network applications.  The advantage of this approach is to improve the readability of the code, since it becomes close in shape to synchronous.  The disadvantage is the need to write additional wrappers to support the coroutines model implemented in Coroutines TS. </p><br><br><h1>  Links </h1><br><ol><li>  <a href="https://habrahabr.ru/post/201826/">Asynchrony: back to the future</a> </li><li>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4649.pdf">Working Draft, Technical Specification for C ++ Extensions for Coroutines</a> </li><li>  <a href="https://blogs.msdn.microsoft.com/vcblog/2017/05/19/using-c-coroutines-with-boost-c-libraries/">Using C ++ Coroutines with Boost C ++ Libraries</a> </li><li>  <a href="https://habrahabr.ru/post/278267/">Objection to making Coroutines with await in C ++ 17</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/348602/">https://habr.com/ru/post/348602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348592/index.html">Fintech Digest: eBay vs. PayPal, the international payment system on the blockchain</a></li>
<li><a href="../348594/index.html">Internet people and non-people</a></li>
<li><a href="../348596/index.html">Traffic Management with Fiddler</a></li>
<li><a href="../348598/index.html">5 best countries for IT business</a></li>
<li><a href="../348600/index.html">Tutorial on Unreal Engine: C ++</a></li>
<li><a href="../348604/index.html">What happened to the manufacturers of ITSM solutions in 2017 (Gartner report)</a></li>
<li><a href="../348606/index.html">The transition from AngularJS to Angular: life after AngularJS (3/3)</a></li>
<li><a href="../348610/index.html">Html-sketchapp - a pledge of unity of programmers and designers</a></li>
<li><a href="../348612/index.html">Javascript es6: extension operator</a></li>
<li><a href="../348614/index.html">Why you should be bored at work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>