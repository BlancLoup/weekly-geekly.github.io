<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ansible vs Salt (SaltStack) vs StackStorm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer 


 Over the past month, I have listened to interviews with developers on all three products and heard the statement "consider [Ansible / S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ansible vs Salt (SaltStack) vs StackStorm</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/b50/722/dc3/b50722dc33834721a8ab64cb44f5c62e.jpg" alt="image"></p><br><h2 id="diskleymer">  Disclaimer </h2><br><p>  Over the past month, I have listened to interviews with developers on all three products and heard the statement "consider <em>[Ansible / Salt / StackStorm]</em> glue."  And now I, as a self-made amateur, will say with pleasure that in my garage is not the only pot with glue.  I have 6 different types of glue for different applications, different bonded materials and environmental conditions.  All these 3 products are in the same camp, and each can be successfully used to achieve completely different goals.  Recently there has been a big overlap of functionality, which consists in the fact that they all penetrate into the field of network automation.  The opinions below are <em>mine</em> , not my employer (who sells network infrastructure products and deployments worth billions of dollars). </p><a name="habracut"></a><br><p>  I <strong>used</strong> all three products, in the development of two of them (Salt and StackStorm) made a significant contribution and partially contributed to the development of Ansible.  Speaking frankly, the product with which I am least familiar is Ansible, but I talked with colleagues and collected information to fill in the blanks. </p><br><hr><br><p>  <em>If you are going to scroll through the text to the end and find out which product I declared the winner, you will be disappointed.</em>  <em>Think over your requirements and try more than one product.</em> </p><br><hr><br><p><img src="https://habrastorage.org/web/81d/c24/066/81dc24066a494d68950fd51c5f8e571e.png" alt="* Use under adult supervision *"><br>  <em>Use under adult supervision</em> </p><br><p>  Ask yourself a few questions: </p><br><ul><li>  What environments need to be supported?  What is the set of servers and network devices? </li><li>  Who are my users?  Hardcore system administrators, information security specialists, developers? </li><li>  How much I am ready to allocate for user development </li></ul><br><h2 id="s-agentom-ili-bez-agenta">  With or without an agent? </h2><br><p>  Give it attention, it really matters.  In this article, I am going to focus on the automation of devices and their orchestration.  These devices can be routers, switches, firewalls, emitting electromagnetic waves of the next generation of circulators - does not matter.  What really matters is that an agent will not be installed in their operating system.  Ansible had a compatible solution ‚Äî using SSH as a transport, so it fits well into the world of endpoint configurations, for which SSH is the least common denominator.  SaltStack was created as a bus for a high-speed and safe minion (agent) that manages communication, but it also has an agentless mode of use.  StackStorm came out on the playing field last and in its architecture does not give preference to any of the works.  It supports agent-based tools through packages for Chef, Puppet, Salt, as well as its own SSH remote controls and built-in support for calling Ansible playbook scripts. </p><br><h2 id="api">  API </h2><br><p>  Another key difference is the API: </p><br><ul><li>  Ansible provides a CLI interface, Ansible Tower (corporate version) has an API; </li><li>  StackStorm has a CLI, but also has a REST API for all components and services in the free version; </li><li>  Salt has both the CLI and the REST API (it is not enabled by default), it is also possible to use the ‚ÄúEnterprise API‚Äù as part of the Enterprise product, which includes features such as RBAC. </li></ul><br><h1 id="ansible">  Ansible </h1><br><p>  Ansible is the brainchild of Michael DeHaan.  The product was designed to automate monotonous server administration tasks in large environments.  Michael was in the newly formed technology group RedHat, where he founded various projects (such as <a href="http://www.cobblerd.org/">Cobbler</a> ), and after leaving RedHat he founded Ansible (although Ansible is now owned by RedHat).  <a href="https://www.ansible.com/blog/2013/12/08/the-origins-of-ansible">An excerpt</a> from Michael's Ansible Basics blog explaining the purpose of the project: </p><br><blockquote>  <em>‚ÄúWe wanted to create another very democratic project to solve new open source problems in Red Hat, which could involve a wide range of developers.</em>  <em>We remembered the busrpc.</em>  <em>This project existed to fill the gaps between Cobbler and Puppet.</em>  <em>Cobbler can prepare the system, and Puppet can add configuration files.</em>  <em>But, since Puppet is too descriptive, it cannot be used to perform operations such as rebooting servers or performing ‚Äúon demand‚Äù tasks at an intermediate time</em> . </blockquote><p>  These ‚Äúon demand‚Äù tasks evolved into Ansible playbooks, and then the Ansible ecosystem of ecosystems appeared and began its development. </p><br><h2 id="dizayn">  Design </h2><br><p>  Ansible is simple, which is its main quality (this will immediately become clear if you look at the other 2 qualities).  It has neither demons nor databases, and installation requirements are minimal.  Ansible is simply installed on a Linux machine and that's it.  You can define target servers in a static file, group them into meaningful sections, or use some kind of dynamic host discovery module (such as Amazon EC2 or OpenStack) to search for virtual machines based on an API call.  Once the inventory has been taken, you can select host-specific or group-specific variables for use in playbooks.  They are, again, stored in static text files. </p><br><p>  Then Ansible will connect to the selected host or group and start the playbook.  A collection of scripts (playbook) is a sequence of Ansible modules for execution on remote hosts written in YAML. </p><br><p>  Connecting to a remote host is a bit like a <em>well-planned military exercise</em> : he entered, did his job and left. </p><br><p>  Ansible works according to the following algorithm: connecting to a server via SSH (or WS-Man / WinRM for Windows), copying Python code, executing and deleting itself. </p><br><h2 id="arhitektura">  Architecture </h2><br><p>  The Ansible architecture is straightforward: there is an application running on the local computer and tasks performed on the remote host that support SSH communication and files transmitted via SCP / SFTP.  Ansible does not have a server-client architecture, unlike the other two products, so task parallelization occurs on a local machine, but does not scale to multiple servers (if you do not use Tower). </p><br><p>  Ansible when managing remote machines does not leave their code on them, so the question of how to update Ansible when upgrading to a new version is not really worth it. </p><br><h2 id="rasshiryaemost">  Extensibility </h2><br><p>  Modules in Ansible are <em>really easy</em> to develop, as, indeed, in the other two products.  Read the style guide if you later decide to try to mix your solution into the open source product repository instead of refactoring it. </p><br><pre><code class="hljs pgsql">#!/usr/bin/python <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span> = str(datetime.datetime.now()) print <span class="hljs-type"><span class="hljs-type">json</span></span>.dumps({ "time" : <span class="hljs-type"><span class="hljs-type">date</span></span> })</code> </pre> <br><pre> <code class="hljs ruby">ansible/hacking/test-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> -</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> ./</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timetest</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">py</span></span></span></span></code> </pre> <br><p>  You should see something like this: </p><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"time"</span></span>: <span class="hljs-string"><span class="hljs-string">"2012-03-14 22:13:48.539183"</span></span>}</code> </pre> <br><p>  In modules, you can define your own code to form ‚Äú <strong>facts</strong> ‚Äù about a remote host at the ‚Äú <strong>gathering</strong> ‚Äù stage, which can be used by your own or third-party modules.  This can be implemented in the form of viewing both installed files and configuration to determine how to configure the service. </p><br><h2 id="korporativnaya-podderzhka">  Corporate support </h2><br><p>  Ansible Tower is a corporate version (Enterprise) that turns Ansible command line into a service with a web interface, a scheduler and a notification system. <br><img src="https://habrastorage.org/web/ff9/4ae/a5a/ff94aea5ac404715a6de0400687d17f0.png" alt="Task manager"><br>  <em>Task Manager</em> </p><br><p>  It also has a user interface for playbooks, through which you can automate the deployment of cloud infrastructure, and then automatically add virtual machines to the list. <br>  It should be noted that the task scheduler, cloud deployments and the server are features of the free versions of both Salt and StackStorm. </p><br><h2 id="podderzhka-setey">  Networking support </h2><br><p>  Ansible's section on <a href="https://www.ansible.com/network-automation">network support</a> is the most comprehensive among all three products and covers all major network equipment and platform vendors.  In Ansible it is possible: </p><br><ul><li>  Automate the configuration of everything related to network equipment - from specifying systems for connecting to configuring basic services, all with the help of modules and playbooks for a specific network platform. </li><li>  Test and verify the current state of the network, perform or postpone the process of collecting facts about the existing configuration. </li><li>  Continuously check compliance with changes to network settings. </li></ul><br><p>  Ansible supports Arista, Cisco (all programmable platforms), F5, Juniper and other manufacturers.  Only in Ansible support is mainly provided and provided by vendors, and not by the community.  At the moment, these are the best APIs, the greatest functionality and work with the latest platforms (since newer versions are supported). </p><br><h2 id="silnye-storony">  Strengths </h2><br><ul><li>  Very quick and easy to get started. </li><li>  Many examples, documentation and modules from the community. </li><li>  Ansible Tower implements features for large enterprise deployments. </li><li>  Network modules supported by vendors. </li></ul><br><h2 id="slabye-storony">  Weak sides </h2><br><ul><li>  In the absence of proper control, operators can save playbooks and SSH keys to their own laptops.  Not quite a flaw in Ansible, but constant monitoring is required. </li><li>  No history of automation events, control over the target host is maintained only for the duration of the playbook, not more.  Cannot be used for long-term tasks. </li></ul><br><h1 id="stackstorm">  Stackstorm </h1><br><p>  I used StackStorm from version v0.11 (early pre-beta) up to the latest version v2.2.  This is a sophisticated multi-purpose platform, just like Salt.  Although the story about it takes time, but still often the listener creates the wrong impression about the system.  I see in this both strength and weakness.  Weakness, because the complexity of the system can force you to abandon the deployment altogether or use a simpler, but incorrect solution where StackStorm would be a good alternative (often in such cases you even write your own solution from scratch).  The strength is that as soon as it becomes clear how to use strengths, the system becomes truly flexible. <br><br><img src="https://habrastorage.org/web/4e5/c6f/431/4e5c6f4318c14efab700a952ef584300.png" alt="Interface StackStorm"><br>  <em>Interface StackStorm</em> </p><br><h2 id="dizayn-1">  Design </h2><br><p>  The core of StackStorm is an executable engine with pluggable rules, designed as a deeply tunable IFTTT service (if-this-then-that, "if it is, then that").  You can configure StackStorm to respond to events that occur by running a simple ‚Äúaction‚Äù (command) or a complex workflow.  Workflows are available in two versions: as ActionChain - action chains (proprietary DSL workflow) or as a workflow on OpenStack Mistral, the engine of which is based on YAML. </p><br><p>  StackStorm also includes a service for ‚Äúchatops‚Äù, with which you can initiate workflows from events or chat platform messages (for example, Slack). </p><br><p>  The list of basic components StackStorm: </p><br><ul><li>  <strong>Sensors</strong> - Python plug-ins for inbound or outbound integration, receiving or observing events.  When an event in the external system is handled by the sensor, the StackStorm trigger will fire. </li><li>  <strong>Triggers</strong> - views of external events in StackStorm.  There are common triggers (for example, timers and webbooks) and integration triggers (for example, an alarm in Sensu or a task update in JIRA).  A new type of trigger can be determined by writing a sensor plugin. </li><li>  <strong>Actions</strong> are outgoing StackStorm integration.  There are common actions (ssh, REST call), integrations (OpenStack, Docker, Puppet) or custom actions.  Actions are either Python plugins or other scripts that integrate into StackStorm by adding a few lines of metadata.  Actions can be invoked directly by the user through the CLI or API, or used and invoked as part of the rules and workflows. </li><li>  <strong>Rules</strong> bind triggers to actions (or workflows), applying matching criteria and binding the information obtained from the trigger to the input of actions. </li><li>  <strong>Workflows</strong> combine actions into ‚Äúuber-actions‚Äù, defining the order, conditions for the transition, and transferring data between them.  Most automation solutions contain more than one step and, therefore, require more than one action.  Workflows, like "atomic" actions, are available in the action library, can be called manually or <em>started according to the rules</em> . </li><li>  <strong>Packages</strong> are content placement units for deployment.  They simplify managing and sharing plug-in content by StackStorm by grouping integration tools (triggers and actions) and automation (rules and workflows).  A growing number of packages are available in the StackStorm community.  The user can create their own packages, post them on Github or send them to <a href="https://exchange.stackstorm.org/">StackStorm Exchange</a> . </li><li>  <strong>An audit trail</strong> with complete information about the context launch and the results of actions launched manually or automatically. </li></ul><br><h2 id="dizayn-2">  Design </h2><br><p>  StackStorm consists of a number of services that use a message queue (rabbit) and a data warehouse (mongo) to save their state and exchange data among themselves.  StackStorm also has a web interface (yes, even in the free version!), Which allows you to customize rules, perform ‚Äúon demand‚Äù actions and check the audit log. </p><br><h2 id="arhitektura-1">  Architecture </h2><br><p><img src="https://habrastorage.org/web/4c7/476/21a/4c747621a75d4e9a89279cf98a392bb5.png"></p><br><p>  Unlike Ansible and Salt, StackStorm was not designed to set up workstations or communications.  StackStorm includes packages for Salt, Chef, Puppet and Ansible, so if you need to use Chef for the agent and configuration management system, use StackStorm to call API-based services, such as Sensu or Kubernetes.  This is an easily achievable and obvious solution.  In Salt, there is still a concept of execution on the end machine or on the master (optional).  If you want to call the Kubernetes API, then the question of which computer caused the API becomes controversial.  The same goes for network device configuration. </p><br><p>  MongoDB can be scaled using well-documented templates, the same goes for RabbitMQ.  The services themselves were developed with the HTTP / RESTful API and can use load balancing for scaling.  Roles can be deployed on a single server or distributed across multiple servers depending on needs. </p><br><p>  I <em>really</em> like StackStorm extensibility, this is definitely a key advantage over the other two products.  StackStorm extension points are called <a href="https://docs.stackstorm.com/packs.html">packages</a> .  They are standalone, can be stored in Git, and manage their dependencies through virtual Python-level package environments.  When you install the package, you specify the Git URL or HTTP URL, (optional) credentials, and StackStorm already downloads, configures, and installs the package. </p><br><p>  If StackStorm were a programming language, it would be <em>strongly typed</em> .  For actions, types of all input data are specified, for triggers fields and types are specified.  This makes it easy to predict what will be returned by a third-party extension, and is a unique feature of StackStorm. </p><br><p>  Unlike Salt and Ansible, StackStorm <em>does not contain any extensions on delivery</em> , all of which must be installed individually.  This facilitates deployment and simplifies dependencies. <br>  When designing the integration mechanism for StackStorm, you can create sensors, actions, and workflows in one definition.  The Salt and Ansible modules are autonomous.  Thus, if an extension (for example, Salt) includes the Beacons, Execution Modules, and Status Modules, then they have nothing in common except for the name and the author.  This can create problems when managing pip dependencies. </p><br><p>  The solution to this problem in StackStorm is that each package has its own requirements.txt file, as well as a YAML file that describes the purpose, requirements, and version of the package.  You can upgrade the package in a linear fashion while maintaining the existing configuration.  Packages also contain a template configuration, in contrast to Ansible and Salt, in which the module configuration format is kept <em>only</em> in the documentation, making them more prone to user error.  In addition, you often have to look at the module code if the developer did not bother to document the configuration parameters properly. </p><br><p>  Another unique feature is that ChatOps aliases (chat commands) are built into the packages.  Therefore, when installing, for example, the NAPALM package, all chat commands for NAPALM are also installed. </p><br><h2 id="korporativnaya-podderzhka-1">  Corporate support </h2><br><p>  StackStorm is an open source Apache-2 licensed product hosted on GitHub.  StackStorm is owned by Brocade (which recently sold part of its assets, and part of StackStorm is now owned by Extreme Networks). </p><br><p>  When licensing StackStorm, a product called ‚ÄúBrocade Workflow Composer‚Äù is purchased, and the license holder receives additional functionality, as well as Enterprise-level-support.  The system I worked with, deployed in a production environment, was licensed, and their support team left me with the impression of being responsive and knowledgeable.  You also get RBAC, in which you can specify for each level of actions, who and what actions have access to. </p><br><p><img src="https://habrastorage.org/web/12d/958/211/12d958211ae44f4598edeab503f36353.png" alt="Brocade Workflow Composer"><br>  <em>Brocade Workflow Composer</em> </p><br><h2 id="podderzhka-setey-1">  Networking support </h2><br><p>  You're lucky if you use Brocade VLX or SDX, as they are <a href="https://bwc-docs.brocade.com/latest/solutions/essentials/overview.html">well supported</a> , which is to be expected. </p><br><p>  In April 2017, they combined support for the NAPALM library and the cross-platform Python abstraction pack for Cisco, Juniper, Arista, and other vendors.  Now you can use NAPALM functionality in terms of routing, interfaces, BGP peering and some other great features.  Matt Oswalt (co-author of O'Reilly's book on network automation) wrote a <a href="https://stackstorm.com/2017/04/11/ensuring-network-configuration-consistency-stackstorm-napalm/">good blog</a> about progress in this direction. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/M7Zi2HbFelQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Demonstration of NAPALM for StackStorm</em> </p><br><h2 id="silnye-storony-1">  Strengths </h2><br><ul><li>  The free default web interface is easy to use and does not require deep knowledge of Python or DevOps. </li><li>  ChatOps integration is built in, works out of the box (using Slack, the API key is simply deployed) and supports many other chat platforms. </li><li>  OpenStack Mistral is really powerful, and if you master it, it will be possible to immediately cover several DevOps tools, it is easy to create branches and loops. </li><li>  Brocade Workflow Composer is a great way to get non-developers to use the system. </li></ul><br><h2 id="slabye-storony-1">  Weak sides </h2><br><ul><li>  Does not have as many expansion packs available as Salt and Ansible.  First check to see if the packages are available for your systems and API and what features are included in them. </li><li>  The OpenStack Mistral system is still rather poorly documented, there is a lot of trial and error in the syntax of YAQL queries. </li></ul><br><h1 id="salt">  Salt </h1><br><p>  First of all, Salt is a product, SaltStack is a company.  So when I talk about Salt, I talk about Salt Open, an open source version. </p><br><p>  Salt has a massive list of constituents, at first (and when I say ‚Äúat first‚Äù, I mean ‚Äúfirst year‚Äù), it can be really amazing.  Salt performs many functions, therefore, as a rule, comparing Salt with Ansible, Salt-fans say ‚Äúyes, but he does much more‚Äù.  As with StackStorm, it works for and against Salt.  If I just told you to bring grains (crystals) from the mine, you would think that I mean Tolkien's novel, but as soon as you know what a Salt <strong>mine is</strong> in Salt terminology, everything will become obvious. </p><br><h2 id="dizayn-3">  Design </h2><br><p>  Salt was born as a distributed system for remote execution of commands and request data at remote sites or <em>minions</em> .  Remote execution is possible either on individual nodes or on groups using arbitrary selection criteria - ‚Äú <em>targeting</em> ‚Äù. </p><br><p>  Salt has been expanded to a configuration management system capable of supporting remote nodes in predetermined <em>states</em> (for example, ensuring that certain packages are installed on them and certain services are running).  Salt has a lot of <a href="https://docs.saltstack.com/en/getstarted/overview.html">components</a> , and I‚Äôm just sure I missed something! </p><br><ul><li>  <strong>A master</strong> server that runs basic services for communicating with the Salt minions.  It also contains a keystore for encrypting between it and the minions. </li><li>  <strong>Minions</strong> are agents that use the Salt micro version for local execution and communication with the master. </li><li><p>  <strong>The engines</strong> - they are Salt Engines (salt engines) - are external processes, executed for a long time, that work with Salt. </p><br></li><li>  <strong>States or formulas</strong> are files containing YAML and template data for customizing minions.  The template mechanism is also <strong>very flexible</strong> .  It is not limited to Jinja support, but also supports chetah, genshi, mako (very important for those who have experience with Puppet), wempy, or even pure Python. </li></ul><br><p>  Minions (proxy or regular) can be addressed using grains (grains, crystals), pillars (pillars, columns) or identifiers.  There are other <a href="https://docs.saltstack.com/en/latest/topics/targeting/">plug-ins for targeting</a> , as well as the ability to create your own, based on something like SQL-query or KVP-storage. </p><br><ul><li><p>  <strong>Grains</strong> - Salt contains an interface for getting information about the system below.  It is called the interface of "grains", because it is a "salt", consisting of "grains" of information.  Grains are collected for the operating system, domain name, IP address, kernel, OS type, memory, and many other system properties.  The grains interface is available for Salt modules and components, so the necessary minion commands are automatically available in the respective systems. </p><br></li><li>  <strong>Pillars</strong> is a Salt interface designed to provide <em>global</em> values ‚Äã‚Äãthat are distributed among minions.  Pillar is a free-form data resource, which can be JSON, YAML or other required and can be stored in files or <a href="https://docs.saltstack.com/en/latest/topics/development/external_pillars.html">externally</a> .  This is a unique Salt property that allows it to be integrated with other systems in which a common data warehouse would be useful (for example, ITSM or a resource registry). </li></ul><br><p>  To retrieve data, you can also use data from minions and store them in Salt <a href="https://docs.saltstack.com/en/latest/topics/mine/">mine</a> (salt mine).  In the future, this data can be used in other tasks, such as the configuration of states based on templates.  Unlike Ansible (which only supports YAML), it can be implemented in different formats. </p><br><h2 id="arhitektura-2">  Architecture </h2><br><p>  Salt architecture is based on the principle of the wheel hub and the spokes (fan structure).  Some very large deployments use several wizards, but this is quite rare.  Wizards can easily scale to many thousands of nodes in part because of the lightweight ZeroMQ message bus.  Other deployment models: </p><br><ol><li>  Installation without a wizard. </li><li>  Hierarchical wizards that are interconnected with syndics. </li></ol><br><p>  The wizard contains status files that are usually placed on a shared storage volume.  They are configured as a tree to allow targeting to define server groups for configuration and environments / applications for deployment. <br><img src="https://habrastorage.org/web/a1b/551/e3e/a1b551e3e069437684d1ca7ecfa62071.png"></p><br><p>  The event-based Salt system uses beacons.  Like the StackStorm sensor and trigger system, Salt beacons trigger events to the message bus, which can then be processed in the reactor (on the master).  The mechanism of the rules in the reactor is rather crude compared to StackStorm, since usually the state or execution command is activated behind the beacon triggering the event.  However, beacons work on minions, so if events are detected on servers, everything is very clear.  Since StackStorm and Ansible do not have agents, this will be a unique feature of Salt. </p><br><p>  <a href="https://docs.saltstack.com/en/latest/topics/thorium/index.html">Thorium</a> (thorium) - complex reactor for Salt, was included in the last release as an experiment and, <em>perhaps</em> , will be supported in future releases.  Thorium adds support for more complex rules and event collection. </p><br><h2 id="rasshiryaemost-1">  Extensibility </h2><br><p>  <strong><em>Everything</em></strong> in Salt is extensible, up to modules that display the results of execution in the CLI.  This is a big plus of Salt, as you can easily implement your own changes without having to maintain a parallel fork in the main project.  Each function in Salt is also pluggable. </p><br><p>  The most common scenarios for expansion can be the development <strong>of a state module</strong> (to describe how a piece of software or a service should be configured) or <strong>an execution module</strong> (code to interact with an API or system).  Both types of modules can be written in a relatively small pattern, both are well documented and can be tested using a good built-in test environment.  You can perform nodal checking of modules using PyTest, even without being on the master or without a working master at all.  Linux testing is required for integration testing, although modules with small hacker skills can also be run on OSX (there is no question about Windows, as is the case with StackStorm with Ansible). </p><br><p>  It‚Äôs possible to either maintain your standalone package or directly contribute to the Salt project on GitHub.           ,             .    3-5      , ,   Salt  ¬´ <em>  </em> ¬ª,   . </p><br><p>  Salt   <a href="https://docs.saltstack.com/en/latest/topics/spm/"> , SPM</a> ,          (state files).      ,     ,        (      ). </p><br><p> Salt             . -        .    (      Salt),  ,  ,  . </p><br><h2 id="korporativnaya-podderzhka-2">   </h2><br><p> ¬´Salt Open¬ª ‚Äî       ,     "Salt Enterprise",      ,  : </p><br><ul><li> -  ,  ,       LDAP; </li><li>   ServiceNow,          ServiceNow ITSM; </li><li> RBAC   LDAP (); </li><li> ¬´Enterprise API¬ª,     Enterprise  REST API. </li></ul><br><h2 id="podderzhka-setey-2">   </h2><br><p>  Salt    ,  ZeroMQ   ,          ,          Salt.    Salt    ¬´ <strong></strong> ¬ª. - ‚Äî   ‚Äî  ,           SSH, HTTP      .     ,    ,       <strong></strong> .       Puppet (    ,     ), ,     , <strong> </strong> ,    .  ,      .       40  .   -,   Python,     .  Salt       SaltConf. </p><br><p>      : </p><br><ul><li> JunOS (Juniper); </li><li> NXOS (Cisco); </li><li> Cisco NSO ( NETCONF  Cisco); </li><li> NAPALM. <br><img src="https://habrastorage.org/web/e15/ee1/37a/e15ee137aebd4cc396642713f30d5f63.png"><br>  Salt  <a href="https://docs.saltstack.com/en/latest/ref/proxy/all/salt.proxy.napalm.html">  </a> NAPALM      Cloudflare. NSO  NAPALM   ,  NSO     Cisco,     ,      . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/99jHvkVM0Dk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em> NAPALM   Salt</em> </p><br><h2 id="silnye-storony-2">   </h2><br><ul><li> Salt     ,     ( <code>salt-ssh</code> ). </li><li>       ZeroMQ. </li><li>             Windows,   Linux     . </li><li>       (, LinkedIn) . </li><li> Salt           API-    . </li></ul><br><h2 id="slabye-storony-2">  Weak sides </h2><br><ul><li> ,   ,       . </li><li>       , . .       pip-. </li></ul><br><h1 id="zaklyuchenie">  Conclusion </h1><br><h2 id="osnovannyy-na-sobytiyah-ili-net">     ? </h2><br><p>        . Salt  StackStorm   . StackStorm  ,    (),    ,    ,     . Salt   ‚Äî ,       ,          .   .  Ansible       (  )   . </p><br><h2 id="podderzhka-soobschestva">   </h2><br><p>  ,        <strong>Ansible</strong> ,        (  Brocade  StackStorm)    . , Ansible      .    NAPALM  NSO   StackStorm,    Salt   ,     Arista, JunOS (Juniper), Cisco APIC-EM, NXOS  .. </p><br><h2 id="vremya-nachinat">   </h2><br><p>  <strong>Ansible</strong> ‚Äî     (,  , ).              CLI        -      .        (,  ),  ,    .           ,         ,            . </p><br><h2 id="hranilischa-dannyh-konfiguraciy">    </h2><br><p> <strong>Salt</strong>  ,     .         Hashicorp Vault,    .         SQL, ,  ,  ¬´ ¬ª. ,            ,   . </p><br><h2 id="bezopasnost">  Security </h2><br><p>   Ansible  Salt, Salt        ,  Ansible  SSH  .    Ansible,  ,     ,     (,   ). <strong>Salt</strong>      . ,   grains        . StackStorm    MongoDB,     , ,    ,      . </p><br><h2 id="obuchenie">  Training </h2><br><p>       ,   ,     . Salt  Ansible    , StackStorm ‚Äî . Salt  (RedHat) Ansible        , StackStorm ‚Äî <strong></strong> (). Salt  Ansible    PluralSight,   <strong></strong> . </p><br><h2 id="licenzirovanie">  </h2><br><p>  Salt,  StackStorm   Apache-2, Ansible ‚Äî GPLv3.         OSS,   - ¬´TLDR Legal¬ª. Salt      SuSE      ( -    OSS). </p><br><h2 id="navyki">  Skills </h2><br><p>  (     ),  Ansible       DevOps   .   ,    Ansible  ,  Salt  StackStorm.   DevOps   ,     ,         . </p><br><h2 id="kakoy-kley-mne-vybrat">    ? </h2><br><p> ,         .      , ,    DevOps,     ,   ,     . </p><br><blockquote> <em>    ,    ,  ,     ‚Äî   .</em> </blockquote><p><img src="https://habrastorage.org/web/135/581/118/1355811180384d3bafdedc4002a72483.png"></p><br><blockquote> <strong></strong> : <em>        Salt, StackStorm, Ansible   </em> . </blockquote><br><h3 id="entoni-shou">   </h3><br><p> <em>       Dimension Data, , ,  Python,    opensource,   </em> . </p><br><h2 id="ssylki">  Links </h2><br><ol><li> <a href="https://medium.com/%40anthonypjshaw/ansible-v-s-salt-saltstack-v-s-stackstorm-3d8f57149368">Ansible vs Salt (SaltStack) vs StackStorm</a> . </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330594/">https://habr.com/ru/post/330594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330580/index.html">Intel Skylake and Kaby Lake chips - a problem was detected with active Hyper-Threading</a></li>
<li><a href="../330582/index.html">Cipherman who doesn't need money</a></li>
<li><a href="../330584/index.html">Favicon today: formats, support, automation</a></li>
<li><a href="../330588/index.html">Using the KOMPAS-3D API ‚Üí Lesson 2 ‚Üí Drawing Design</a></li>
<li><a href="../330592/index.html">Information security: do not wait for the "fried rooster" - he will come</a></li>
<li><a href="../330596/index.html">We write software that will hate</a></li>
<li><a href="../330598/index.html">Time of the brave. How to migrate to the clouds without violating the requirements of regulators?</a></li>
<li><a href="../330600/index.html">The third IT conference GeekDay - three days of free programming workshops</a></li>
<li><a href="../330602/index.html">Talk to me completely. Or how to get rid of cold hands at the interview</a></li>
<li><a href="../330604/index.html">Zabbix: LLD monitoring of IPMI sensors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>