<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DryadLINQ. Microsoft Research Distributed LINQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The focus of yesterday's post on Habr√© was the Microsoft Research - Dryad framework for distributed computing . 

 The framework is based on the repre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DryadLINQ. Microsoft Research Distributed LINQ</h1><div class="post__text post__text-html js-mediator-article">  <em>The focus of <a href="https://habr.com/post/182164/">yesterday's post</a> on Habr√© was the Microsoft Research - Dryad framework for distributed computing</em> . <br><br>  The framework is based on the representation of a task as a <em>directed acyclic graph</em> , where the <em>vertices of the graph</em> are <em>programs</em> , and the <em>edges</em> are the <em>channels</em> through which data is transmitted.  Also, the <em>Dryad framework ecosystem</em> was reviewed and a detailed <em>overview of the architecture of one of the central components of the</em> framework <em>ecosystem</em> , the execution environment for distributed applications of Dryad, was made. <br><br>  <em>In this article we will discuss the top-level component of the software stack of the Dryad framework, a query language for the distributed storage DryadLINQ.</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/a26/1c0/959/a261c095997714cebce988ef62cfe6ff.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">#region Lyrical digression (about writing motivation)</b> <div class="spoiler_text">  Yesterday's article about Dryad, I missed one paragraph, which should be written whenever you write something about Microsoft products. <br><br>  I emphasize: I <i>do not propose</i> , <i>nor do I discourage the</i> use of Dryad in my research projects (since only an academic license is now available).  More than this, I repeat that Dryad is an ‚Äú <i>internal</i> ‚Äù <i>product to</i> all of us a well-known <strike>evil</strike> corporation, whose development strategy [of product and evil] Microsoft has the right to decide alone (which is quite fair). <br><br>  All these facts do not (speak for myself) the study of the ideas and concepts of the Dryad platform are less interesting or less useful for professional development (again for themselves).  If you have something different, then <strike>this is not</strike> your business. <br><br>  For those who <strike>read through the line</strike> worries that the article on the comparison with <strike>Hadoop</strike> open-source projects, and not about DryadLINQ, I hint that the comparison with alternative solutions will be <i>only in the next article</i> . <br></div></div><br><h2>  1. General information <br></h2><blockquote>  For example, it can be used to write the code.  That's the beauty of the DryadLINQ programming model. <br>  - Yuan Yu, Principal Researcher, Microsoft Research <br></blockquote><img alt="Dryad. Software stack" src="https://habrastorage.org/getpro/habr/post_images/e8d/718/d8e/e8d718d8e0146d058fe851e86e2b7554.png"><br><br>  <strong>DryadLINQ</strong> is a high-level query language for data stored in a distributed file system and has an SQL-like syntax.  DryadLINQ is based on the .NET Language Integrated Query (LINQ) software model, implements a specific LINQ provider for interacting with the Dryad runtime and provides the developer with an API for writing distributed running LINQ expressions. <br><br>  Unlike the query languages ‚Äã‚Äãfor the Hadoop platform - HiveQL, Pig Latin - DryadLINQ is not another query language with a specific syntax (necessary for learning).  Instead, DryadLINQ is based on well-known .NET developers: <br><ul><li>  LINQ unified <em>software model</em> ; </li><li>  =&gt; as a result - an elegant <em>functional approach for writing queries to data</em> ; </li><li>  <em>the</em> .NET Framework <em>object model</em> ; </li><li>  MS Visual Studio <em>development environment</em> ; </li><li>  <em>higher-level PL</em> , such as C #, F #, or any CLS-compatible language. </li></ul><br>  Expanding the first paragraph of the above list, it is worth noting that LINQ initially did not contain explicit references to the nature of the data warehouse to which the request is made.  And built on the basis of LINQ, API DryadLINQ also <del>  does not give out </del>  strive not to "betray" their distributed nature. <br><br>  Thus, by minimizing the differences in the syntax for writing a query to a database (on LINQ-to-SQL) or to a distributed file system (on DryadLINQ), the solution to one of the most frequent cases ‚Äî migration from a database to a database ‚Äî is greatly simplified. based on a distributed file system. <br><br>  This is how DryadLINQ is presented to a distributed application developer.  Below we talk about the <em>internal implementation of DryadLINQ: about the stages of querying data, components and concepts that underlie DryadLINQ</em> . <br><br><h2>  2. Stages of implementation <br></h2><br><img alt="DryadLINQ. Execution stages" src="https://habrastorage.org/getpro/habr/post_images/c9d/b09/d94/c9db09d945e75cf6e06f82e661c6a2b1.png"><br>  Source of illustration [5] <br><br>  <strong>Step 1. A</strong> custom distributed application containing a LINQ expression is running.  LINQ expressions are executed deferred (they will not be executed until the data returned by the query will be needed).  DryadLINQ expressions are also deferred. <br><br>  <strong>Step 2.</strong> When parsing LINQ expressions, the DryadLINQ-specific trigger ‚ÄúToDryadTable ()‚Äù is called.  DryadLINQ intercepts this trigger (so at this stage it becomes clear that the request for data will be distributed). <br><br>  <strong>Step 3.</strong> DryadLINQ compiles the LINQ expression into the distributed Dryad query plan: the LINQ expression tree expands over subqueries, each of which represents a separate vertex in the future Dryad execution graph;  the generation of service data necessary for launching remote vertex operations, generation of the code executed on the vertices, serialization of the necessary data types. <br><br>  <strong>Step 4.</strong> DryadLINQ calls application-specific Dryad Job Manager. <br><br>  <strong>Step 5. The</strong> Job Manager creates an application execution graph using the plan generated in step 3. <br><br>  <strong>Step 6.</strong> Vertex programs are executed on the vertices defined for them. <br><br>  <strong>Step 7.</strong> At the end of the execution of the Dryad-task, the result is recorded in the output table (s). <br><br>  <strong>Step 8. The</strong> Job Manager returns the result to the node performing the DryadLINQ job and completes. <br><br>  <strong>Step 9. The</strong> control is returned to the application that initiated the execution of the DryadLINQ expression.  The result of the query is a DryadTable object.  DryadTable implements IEnumerable &lt;T&gt;, so the contents of the strongly typed collection of DryadTable can be accessed as normal .NET objects. <br><br><h2>  3. DryadLINQ compiler <br></h2><br>  The heart of the query language DryadLINQ is the <strong>parallel compiler</strong> (parallel compiler) DryadLINQ.  If we draw an analogy with the world of the SQL query language, the DryadLINQ compiler can be compared with the DBMS query scheduler / optimizer. <br><br>  The compiler is responsible for compiling DryadLINQ expressions into a distributed program that runs on a Dryad cluster.  The DryadLINQ compiler contains both a <em>static component</em> that generates an execution plan and a <em>dynamic component</em> that allows you to optimize performance based on different policies, changing the execution plan right in runtime. <br><br><h3>  3.1.  Execution Plan Graph <br></h3><br>  When passing control to the compiler, the latter transforms the LINQ expression into <strong>an execution plan graph</strong> (Execution Plan Graph, EPG).  An EPG is a <em>prototype of a performance graph</em> (that is, not a final plan). <br><br>  The DryadLINQ optimizer also supplements EPG with metadata that can provide additional information about the distributed task during planning and execution.  So for the vertices of the graph is <em>information about the data partitioning scheme</em> , and for the edges of the graph it is the <em>.NET data type</em> and <em>data compression scheme,</em> if any. <br><br><h3>  3.2.  DryadLINQ Optimizations <br></h3><br>  In turn, DryadLINQ optimizer performs both <em>static optimization based on greedy algorithms</em> (greedy heuristics) and <em>dynamic optimization based on the statistical information collected during the execution.</em> <br><br><h4>  Static optimization <br></h4><br>  The main tasks of the static optimizer are two: <em>minimizing the number of I / O operations</em> on disk media and in the network.  Which is logical, since traditionally the disk subsystem and interfaces for machine-to-machine interaction are a bottleneck in distributed computing environments. <br><br>  The most interesting static optimization techniques are listed below: <ol><li>  <strong>Pipelining</strong> (interprocess communication): the optimizer tries to localize the calculations as much as possible within a single computing node, if possible; </li><li>  <strong>I / O reduction</strong> : the optimizer tries to use TCP-pipe and in-memory FIFO for data transfer between vertex operations instead of the default data transfer method - writing / reading temporary files to / from the disk (Dryad data channels were discussed in detail in the previous article); </li><li>  <strong>Removing redundancy</strong> : the optimizer removes redundant / unnecessary hash- and range-partitioning steps. </li></ol><br><h4>  Dynamic optimization <br></h4><br>  The dynamic optimizer changes the execution graph during <em>the execution of a distributed task</em> .  Thus, based on the collected statistical data (potentially, even a specially trained model), the optimizer can override the graph.  The main techniques for dynamic optimization are listed below: <br>  <strong>Dynamic aggregation</strong> : data aggregation is one of the most effective ways to reduce the amount of data transferred between nodes.  Aggregation occurs in turn at the level of the compute node, rack, and cluster.  Such optimization very much depends on the topological location of the node and the aggregated data; therefore, it is most effective to carry it out during execution (that is, dynamically). <br><br>  <strong>Data-dependent partitioning</strong> : the optimizer dynamically sets the number of partitions (partitions) in a data set, depending on its size of the input data set.  As with Dynamic aggregation, it is precisely possible to estimate the size of the input set only during the execution of a distributed task. <br><br><h2>  4. Practice <br></h2><br><h3>  Word count <br></h3><br>  DryadLINQ offers surprisingly concise syntax for writing queries to data.  The following listing is a complete implementation of the calculation in accordance with the map / reduce model: <br><br>  Listing 1. Implementing the map / reduce programming model. <br><pre><code class="hljs django"><span class="xml"><span class="xml">public static IQueryable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TResult</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> MapReduce</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TSource,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TMap</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TKey</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TResult</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">( this IQueryable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TSource</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> source, Expression</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Func</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TSource</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IEnumerable</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TMap</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt;&gt; mapper, Expression</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Func</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TMap</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TKey</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt; keySelector, Expression</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Func</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">IGrouping</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TKey</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">TMap</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">, TResult&gt;&gt; reducer) { return source .SelectMany(mapper) .GroupBy(keySelector) .Select(reducer); }</span></span></code> </pre> <br>  Listing 2 demonstrates how the implementation of the map / reduce program model presented above is used to create a Dryad word counting task in a certain data source foo.pt (Partitioned Table) stored in a distributed file system. <br><br>  Listing 2. Word counting with DryadLINQ. <br><pre> <code class="hljs pgsql">const string inputPath = @"file://\\machine\directory\foo.pt"; const string outputPath = @"file://\\machine\directory\count.pt"; PartitionedTable&lt;LineRecord&gt; inputTable = PartitionedTable.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>&lt;LineRecord&gt;(inputPath); var result = inputTable.MapReduce( r =&gt; r.Line.Split(<span class="hljs-string"><span class="hljs-string">' '</span></span>), // r: <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> w =&gt; w, // w: words g =&gt; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Tuple&lt;string, <span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(g.Key, g.Count())); // g: <span class="hljs-keyword"><span class="hljs-keyword">groups</span></span> result.ToDryadPartitionedTable(outputPath);</code> </pre> <br>  The Dryad framework generates the following execution graph for this application: <br><br><img alt="MapReduce Execution Plan" src="https://habrastorage.org/getpro/habr/post_images/0a0/020/559/0a002055921735d883311db84a095ee9.png"><br>  Source of illustration [3]. <br><br>  Moreover, the execution graph in step (2) and (3) is generated dynamically based on information about the amount of data sent between the vertices and the topological location of vertex-operations, processing this data. <br><br><h3>  PageRank calculation <br></h3><br>  Listings 3-5 presents the code for the distributed PageRank calculation algorithm. <br><br>  Listing 3. Implementing the PageRank calculation algorithm [5]. <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static IQueryable&lt;Rank&gt; PRStep(IQueryable&lt;Page&gt; pages, IQueryable&lt;Rank&gt; ranks) { // <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> pages <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ranks, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> disperse updates var updates = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> page <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pages <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> rank <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ranks <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> page.Name equals rank.Name <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> page.Disperse(rank); // re-accumulate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> updates <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rank <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> rank.Rank <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> rank.Name <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Rank(g.Key, g.Sum()); }</code> </pre> <br>  Listing 4. Calculating PageRank using DryadLINQ.  Source [5]. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> inputPath = <span class="hljs-string"><span class="hljs-string">@"dfs://pages.txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> outputPath = <span class="hljs-string"><span class="hljs-string">@"dfs://outputranks.txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pages = PartitionedTable.Get&lt;Page&gt;(inputPath); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ranks = pages.Select(page =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rank(page.Name, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iterationCount = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iter &lt; iterationCount; iter++) ranks = PRStep(pages, ranks); ranks.ToPartitionedTable&lt;Rank&gt;(outputPath);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Listing 5. Helper classes.</b>  <b class="spoiler_title">Source [5]</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Page { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Page(Int64 <span class="hljs-type"><span class="hljs-type">name</span></span>, Int64 degreee, Int64[] links) { this.Name = <span class="hljs-type"><span class="hljs-type">name</span></span>; this.Degree = degreee; this.Links = links; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int64 <span class="hljs-type"><span class="hljs-type">Name</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int64 Degree { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int64[] Links { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Rank[] Disperse(Rank rank) { Rank[] ranks = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Rank[Links.Length]; <span class="hljs-type"><span class="hljs-type">double</span></span> score = rank.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> / this.Degree; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ranks.Length; i++) ranks[i] = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Rank(this.Links[i], score); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ranks; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Rank { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Rank(Int64 <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span> rank) { this.Name = <span class="hljs-type"><span class="hljs-type">name</span></span>; this.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = rank; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int64 <span class="hljs-type"><span class="hljs-type">Name</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> </div></div><br>  Data transfer between different iterations will occur through <em>the in-memory FIFO channel</em> , which guarantees an order of magnitude <em>higher performance</em> than data transmission over the network, as is the case with the implementation of a similar algorithm in Hadoop (this is the latest release version of [plain] Hadoop) . <br><img alt="PageRank Execution Plan" src="https://habrastorage.org/getpro/habr/post_images/2c1/701/5b2/2c17015b2951ebabfd67f984beaf7e6e.png"><br>  Source of illustration [5] <br><br>  <em>Addition to the illustration</em> : data transfer between iterations iteration 1&gt; iteration 2&gt; ...&gt; iteration n occurs exclusively through the in-memory channel FIFO. <br><br><h2>  5. Limitations <br></h2><br>  The Dryad framework, unlike Hadoop MapReduce, does not confuse the responsibility of <em>executing a distributed application</em> and a <em>programming model / query language</em> with which such applications can be written. <br><br>  Despite this division of responsibilities, in my opinion, <em>the DryadLINQ software model in itself still mixes responsibilities</em> when it assumes not only direct obligations regarding the interpretation of LINQ expressions in the Dryad program, but also builds EPG graphs of execution and optimizations .  The latter will inevitably lead to a longer run time for the Dryad job: more CPU cycles are spent on interpreting the DryadLINQ expression than it would have left with fewer commitments. <br><br>  As a consequence, the interpretation of the set of DryadLINQ expressions on a single computational node will have a greater negative impact on the task execution time, both at the local level and at the cluster level as a whole.  Although I still do not see how the described problem can grow into the problem of scalability of the Dryad cluster as a whole. <br><br>  Another note relates to a <em>static optimizer, which, in order to effectively apply optimizations, needs to know too much</em> , including the internal "affairs" of the components of the Runtime Runtime - the topology of web sites, the data partitioning scheme. <br><br>  From the documentation it remains unclear what the statistics are for the dynamic optimizer: after all, the statistics on the number of I / O operations is again the internal data of the execution engine (Dryad runtime), which should not be disclosed at the level of the program model (DryadLINQ). <br><blockquote>  DryadLINQ performs both static and dynamic optimizations.  [3] <br></blockquote>  From the passage quoted above, the question immediately arises: why does the dynamic optimization problem fall under the responsibility of DryadLINQ?  Indeed, according to the semantics, the dynamic optimizer works already after the final interpretation of the DryadLINQ expression, that is, at the runtime level. <br><br><h2>  6. Advantages <br></h2><br><h4>  Full programming language <br></h4><br>  Development using modern high-level programming languages, LINQ model with the ability to write queries to data in a functional style. <br><br><h4>  Strong data typing <br></h4><br>  The Dryad framework performs calculations on strongly typed data and returns strongly typed collections of objects. <br><br><h4>  Automatic data serialization <br></h4><br>  The data is automatically serialized / deserialized by the framework during transmission over channels. <br><br><h4>  Automatic execution parallelization <br></h4><br>  DryadLINQ generates a distributed execution plan that runs in a cluster.  Improved utilization of multiprocessor compute nodes through the use of PLINQ (Parallel LINQ) for tasks running locally. <br><br><h4>  Automatic performance optimization <br></h4><br>  The execution graph is optimized by the special components of the Dryad framework, both during the creation of the execution plan, using optimization policies, and dynamically during execution, relying on statistical data. <br><br><h4>  Familiar development tools <br></h4><br>  For writing MPP applications using the DryadLINQ program model, you can use MS Visual Studio, as well as VS features such as: Intellisense, code refactoring, integrated debugging, build, source code management. <br><br><h4>  100% compatible with the .NET Framework <br></h4><br>  DryadLINQ can be used with any .NET-library and CLS-compatible programming languages ‚Äã‚Äãwith static typing. <br><br><h2>  Conclusion <br></h2><br>  <em>DryadLINQ is a program model familiar to .net developers, perfectly integrated into the existing .NET Framework stack, with expressiveness and brevity inherent in the functional style of writing programs.</em>  <em>In addition, the DryadLINQ model provides developers with LINQ-like syntax for writing queries to a distributed data repository, encapsulating the details of the distributed nature of a query, scheduling execution, and its optimization.</em> <br><div class="spoiler">  <b class="spoiler_title">For those who are bored (or a bonus)</b> <div class="spoiler_text">  In the third and <a href="https://habr.com/post/182688/">final part of the cycle, the</a> Dryad framework will be compared with other MPP ‚Äútools‚Äù - relational DBMS, GPU computing and the Hadoop platform.  Therefore, ahead of us are waiting for "fascinating" arguments in the comments on the topic "Windows is buggy" and the fall of karma. <br></div></div><br><h2>  List of sources <br></h2><br>  [1] <a href="http://research.microsoft.com/en-us/projects/dryadlinq/default.aspx">The DryadLINQ Project</a> .  Microsoft Research. <br>  [2] M. Isard and Y. Yu.  <em>Distributed data-parallel computing using a high-level programming language</em> .  In International Conference on Management of Data (SIGMOD), 2009. <br>  [3] Y. Yu, M. Isard, Fetterly, M. Budiu, U. Erlingsson, PK Gunda, and J. Currey.  <em>DryadLINQ: a system for general-purpose distributed data-parallel computing using a high-level language</em> .  In Proceedings of the 8th Symposium on Operating Systems Design and Implementation (OSDI), 2008. <br>  [4] Y. Yu, M. Isard, D. Fetterly, M. Budiu, U. Erlingsson, PK Gunda, J. Currey, Report MSR-TR-2008-74, Microsoft Research, 2008. <br>  [5] Jinyang Li.  <em>Dryad / DryadLinq Slides adapted from those of Yuan Yu and Michael Isard</em> , 2009. </div><p>Source: <a href="https://habr.com/ru/post/182282/">https://habr.com/ru/post/182282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182268/index.html">Computex 2013. Day two. ASUS, Thermaltake and ADATA</a></li>
<li><a href="../182270/index.html">Asterisk Conference - create through mail</a></li>
<li><a href="../182274/index.html">Attempt to take habrainterviyu from the former scenery</a></li>
<li><a href="../182276/index.html">7 methods of project portfolio analysis</a></li>
<li><a href="../182278/index.html">DevConf 2013 will be held on June 14 - a JavaScript section program is formed</a></li>
<li><a href="../182286/index.html">The reverse engineering of the PlayStation 1 processor has begun: madness of the brave we are singing a song!</a></li>
<li><a href="../182288/index.html">FSB disown idea to ban anonymizers</a></li>
<li><a href="../182290/index.html">The game party is 12 years old ... Who is more?</a></li>
<li><a href="../182292/index.html">Another JavaScript Script Loader</a></li>
<li><a href="../182294/index.html">Configure Travis-CI for iOS open source projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>