<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Library patterns: Why frameworks are evil</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear readers! 

 Today we want to offer you a translation of a technical article, whose author, Thomas Petrichek, considers various aspects of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Library patterns: Why frameworks are evil</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear readers! <br><br>  Today we want to offer you a translation of a technical article, whose author, Thomas Petrichek, considers various aspects of working with libraries in the F # language.  Since we are currently exploring the potential of one book, in the creation of which this author participated, the article is positioned primarily as a sample text, using as an example you can appreciate the author‚Äôs narrative talent, the quality of his ideas, arguments and reasoning, as well as code examples.  However, since the considerations outlined in the article are not limited to working with F #, we hope that the text will be informative and interesting for the widest audience. <br><a name="habracut"></a><br><br>  This article is written based on one of <a href="http://tomasp.net/blog/2015/library-layers/">my previous posts</a> on the design of functional libraries, but it will be quite clear without such an introductory post, since it is devoted to another topic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the previous article I described some principles that came in handy when writing libraries in a functional style.  I rely on my own experience of creating libraries in the F # language, but the ideas that will be presented here are quite universal and will be useful when working with any programming language.  In a previous post, I wrote how multiple levels of abstraction allow you to create libraries that simplify the implementation of 80% of the scenarios, but are useful and more interesting in practical cases. <br><br>  In this article I'm going to talk about two other aspects: how to develop composable libraries and how (and most importantly - why) avoid callbacks when developing libraries.  As is clear from the title of the article, its essence boils down to the following: write libraries, not frameworks! <br>  Comparing frameworks and libraries <br><br>  What is the difference between a framework and a library?  Primarily in how you can use those and others, and what will be the nature of the code in the first and in the second case. <br><br><ul><li>  Frameworks  When you use the framework, its task is to ensure the operation of the system.  It defines a series of extension points (interfaces) where you connect your implementations. </li><li>  Libraries.  When using the library for the operation of the system you are responsible.  The library defines a series of points through which you can access it (functions and types), and your code calls them as needed. </li></ul><br><br><img src="https://habrastorage.org/files/db9/d91/a9d/db9d91a9dd284764a696790eb28278ce.png"><br><br>  The difference is shown in the above diagram.  The framework defines the structure that you have to fill out, and the library itself has some structure around which you build your code. <br><br>  Of course, such a division into libraries and frameworks is not straightforward.  Some components combine the features of the first and second: you call such a component as a library, but it has certain niches (for example, an interface) that you have to fill. <br><br>  <b>What is wrong with frameworks?</b> <br><br>  Having considered the above scheme, you can already see what problems can arise with frameworks.  In this section, I will describe some things related to three such problems (and in the next section I will look at ways to solve them). <br><br>  <i><b>No frameworks are packaged.</b></i> <br><br><br>  Probably the biggest and most obvious problem of frameworks is that they do not fit together.  If you have two frameworks, then each of them will have its own specific niche, which you will have to fill.  But usually there is no way to insert one framework into another (and it‚Äôs usually unclear why one framework should be conditionally inside, and the other outside). <br><br>  There is a different situation with libraries.  You control them, so your program may well call many libraries.  Of course, this presents some difficulties - you have to write more complex code around the end points of the libraries - but, as a rule, it is quite realizable. <br><br><img src="https://habrastorage.org/files/6cd/b38/2ba/6cdb382ba1bb436ca817e60cf518491e.png"><br><br><blockquote>  Theoretical retreat <br><br>  I'm not saying that the following considerations have any theoretical basis, but the frameworks are a bit like monads.  If you are outside the monad, then you can ‚Äúget inside‚Äù it with the help of the module.  Then you can perform various operations inside the monad, but you can‚Äôt leave it anymore.  Frameworks are similar to such monads. <br>  It is well known that assembling monads is difficult (like frameworks).  If you have monads M1 and M2, then they can be joined using the operation M1 (M2 Œ±) ‚Üí M2 (M1 Œ±), i.e.  interchange the ambient and ambient monads.  Is it possible to do something similar with frameworks? </blockquote><br><br>  <i><b>Frameworks are hard to explore.</b></i> <br><br>  Another major problem with frameworks is that they are difficult to test and investigate.  In F #, it is very useful to load the library into F # Interactive, to try to run it with various input options and see what the library does.  For example, you can use the Suave web development library to start a simple web server, like this: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//        #r "Suave.0.25.0/lib/net40/Suave.dll" open Suave.Web open Suave.Http //   -,     hello startWebServer defaultConfig &lt;| fun ctx -&gt; async { let whoOpt = ctx.request.queryParam "who" let message = sprintf "Hello %s" (defaultArg whoOpt "world") return! ctx |&gt; Successful.OK message }</span></span></code> </pre> <br><br>  This fragment loads the library, and then calls startWebServer with the default configuration and function for processing requests (the function receives the who query parameter and displays a greeting). <br>  This practice is very useful, as it allows the user to quickly experiment with the library. <br><br>  Try calling startWebServer with different parameters and see what it does (or, in the case of other functions, what it returns). <br><br><blockquote>  Theoretical retreat <br><br>  The difference between libraries and frameworks is in many ways similar to the one that exists between a function call and the need to specify a function as an argument: <br>  lib: œÑ1 ‚Üí œÑ2 (library) <br>  fwk: (œÉ2 ‚Üí œÉ1) ‚Üí unit (framework) <br>  In the case of library, you will need to create the value œÑ1, so that you can call the lib function.  Sometimes the library provides you with other functions that create œÑ1 (in this case, you just need to find the first function from such a chain and call it).  When writing code interactively, you can try to set different values ‚Äã‚Äãof œÑ1, run the function and see what it returns.  This way you can easily explore the behavior of the library (and how to use it to achieve what you need).  In addition, in this case, testing code using libraries is simplified. <br><br>  In the case of the framework, the situation is more complicated.  You have to write a function that takes œÉ2 and produces œÉ1.  The first problem is that you do not quite know what value of œÉ2 you will receive in different situations.  In an ideal world, ‚Äúinvalid values ‚Äã‚Äãare not representable,‚Äù but in reality you want to start writing such code that, first of all, handles the most common cases.  It is equally difficult to understand (and investigate) what values ‚Äã‚Äãof œÉ1 you must give in order to achieve the desired behavior. </blockquote><br><br>  Now, if you go back to my example with Suave, the reader may have a question: is it a library (we call a function) or a framework (specify a function that needs to be called).  In fact, the above example demonstrates both aspects.  As will be shown later, this version of the framework framework is not so bad (see the sections on callbacks and async below). <br><br>  <i><b>The frameworks define the organization of your code.</b></i> <br><br>  The next problem with frameworks is that they define the structure of your code.  A typical example of such a case: we work with a framework that requires inheriting from a certain base class and implementing specific methods.  For example, the Game class in the XNA framework looks like this (I know that XNA is dead, but this pattern also applies to other similar frameworks): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DrawingContext ctx</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br><br>  It is assumed that in Initialize you will load any resources that may be required in your game;  Update is called repeatedly to calculate the next state, and Draw is called when the screen needs to be updated.  The interface is clearly focused on the imperative programming model, so you will get something like this, which is shown below.  Here we write a stupid version of the game in Mario, where Mario just slowly goes from left to right: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> = inherit Xna.Game() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutable x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutable mario = None <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Initialize() = mario &lt;- Some(Image.Load(<span class="hljs-string"><span class="hljs-string">"mario.png"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Update() = x &lt;- x + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Draw(ctx) = mario |&gt; Option.iter (fun mario -&gt; ctx.Draw(x, <span class="hljs-number"><span class="hljs-number">0</span></span>, mario))</code> </pre><br><br>  The framework structure as such does not contribute to writing beautiful code in it.  Here I just made the most straightforward implementation.  The variable field x corresponds to the location of Mario, and mario is the option value for storing the resource. <br><br>  You could argue that in C # such code could be more beautiful (for example, I had to use the option value, since all F # fields must be initialized), but this is true only if you completely ignore the check.  In fact, using the option value here, we make the code more secure (since we cannot accidentally use mario in Draw if we have not initialized it).  Or does the framework ensure that Initialize will always be called before Draw?  How do we know this? <br><br>  <b>How to avoid the "smells" of frameworks</b> <br><br>  I hope I could convince you that writing libraries is better than building frameworks.  But so far I have not given any specific advice on how this is done.  In the rest of the article we will look at a couple of specific examples. <br><br>  <i><b>Support interactive research</b></i> <br><br>  Even if you are not writing a library in F #, you should use F # Interactive so that you can use it interactively!  Not only is the F # language <a href="http://fsprojects.github.io/ProjectScaffold/writing-docs.html">perfectly suited for documenting the library</a> , but also by writing an interactive script, you can be sure that it will be very easy to call your library (if you are working on the .NET platform, then there is another option - work with <a href="http://www.linqpad.net/">LINQPad</a> ). <br><br>  I will illustrate my reasoning with two examples.  The first code snippet shows how you can use the <a href="http://tpetricek.github.io/FSharp.Formatting/">F # Formatting library</a> to convert the documentation directory containing the F # script files and Markdown documents into an HTML file, or how to process a single file: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#r "FSharp.Literate.dll" open FSharp.Literate //    Literate.ProcessDirectory("C:/demo/docs") //     Literate.ProcessMarkdown("C:/demo/docs/sample.md") Literate.ProcessScriptFile("C:/demo/docs/sample.fsx")</span></span></code> </pre><br><br>  The point is that you need to refer to the library, open the namespace and find the type of Literate as an entry point.  By doing this, you can use the "."  and see what you have! <br><br>  I think all good libraries should support this practice.  As another example, let's take a look at FunScript, which converts F # code into JavaScript.  As a rule, it is used as part of a web framework, but it works fine by itself.  The following snippet generates JavaScript code for a simple async loop, which increments the number on the page every second: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#r "FunScript.dll" #r "FunScript.TypeScript.Binding.lib.dll" open FunScript open FunScript.TypeScript Compiler.compile &lt;@ let rec loop n : Async&lt;unit&gt; = async { Globals.window.document.title &lt;- string n do! Async.Sleep(1000) return! loop (n + 1) } loop 0 @&gt;</span></span></code> </pre><br><br>  Again, we simply refer to the library (in this case, DOM bindings), and then call one function ‚Äî the compile function accepts the F # quote.  Having discovered this, you can try out for yourself what things she can handle!  The previous example shows beautiful support for F # async {...} and bindings that give you access to the DOM. <br><br>  <i><b>Use only simple callbacks.</b></i> <br><br>  When I talked about frameworks in a theoretical digression above, I noted that the framework, in essence, can be called any construct that takes a function as an argument.  Do I mean that you should not use higher order functions?  Of course not! <br><br>  Compare the following two simple fragments ‚Äî in the first, standard functions are used for processing lists, and in the second, a certain input is read (using the first function), which is then validated and processed (using the second function): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      [ 1 .. 10 ] |&gt; List.filter (fun n -&gt; n%3 = 0) |&gt; List.map (fun n -&gt; n*10) //      ,  , //          readAndProcess (fun () -&gt; File.ReadAllText("C:/demo.txt")) (fun s -&gt; s.ToUpper())</span></span></code> </pre><br><br>  There are two differences between the first and second examples.  When working with list processing functions, we always specify only one function as an argument.  Moreover, such functions should never maintain state. <br><br>  In the second case, two functions are indicated.  In my opinion, this is a sign that the function is more complicated than it should. <br><br>  Secondly, readAndProcess obliges us to return the state of the string from the first function, and then accept the string as input for the second function.  This is another potential problem.  What if we have to transfer some other state from the first function to the second? <br><br>  Of course, here I am considering a simplified case, but let's see what can happen inside readAndProcess.  This function can handle some exceptions and first check the validity of the input, and only then call the second argument: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> readAndProcess readInput processInput = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input = readInput() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input = <span class="hljs-literal"><span class="hljs-literal">null</span></span> || input = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-function">then None else </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">processInput input</span></span></span><span class="hljs-function">) with :? System.IO.IOException -&gt; None</span></span></code> </pre><br><br>  How could this abstraction be improved?  First of all, this function actually solves two problems.  First, it handles exceptions (rather stupidly, but this is a learning example).  Second, it validates the input.  We can divide it into two functions: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ignoreIOErrors f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">try</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f(</span></span></span><span class="hljs-function">)) with :? System.IO.IOException -&gt; None </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> validateInput input</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input = <span class="hljs-literal"><span class="hljs-literal">null</span></span> || input = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-function">then None else </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">)</span></span></code> </pre><br><br>  Now validateInput becomes the most common function that returns Some if the input was valid.  The ignoreIOErrors function still takes a function as an argument ‚Äî in this case, it makes sense, since exception handling is a typical example of the <a href="http://blog.enfranchisedmind.com/2007/07/the-hole-in-the-middle-pattern/">Hole in the Middle</a> pattern.  With the help of new features you can write: <br><br><pre> <code class="cs hljs">ignoreIOErrors (fun () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input = File.ReadAllText(<span class="hljs-string"><span class="hljs-string">"C:/demo.txt"</span></span>) validateInput input |&gt; Option.map (fun valid -&gt; valid.ToUpper() ))</code> </pre><br><br>  If you try, then here you can keep within three lines, but the code is a little longer and a little clearer. <br><br>  In my opinion, this is a plus, since you see what is happening (and you can start with an interactive call validateInput!) Also, if you like the readAndProcess function more, this is also good - you can easily define it using the two above functions ( but not vice versa!) So, your library can provide a multi-level abstraction, as discussed in <a href="http://tomasp.net/blog/2015/library-layers/">my previous article</a> .  But if we provide only high-level abstraction, it will limit our capabilities. <br><br>  In summary, the transfer of functions as arguments is perfectly acceptable, but be careful.  If the function takes as its argument two or more functions, then this is probably not the best low-level abstraction.  If the functions passed as arguments must separate and transmit some state, then you should definitely provide an alternative (in case the caller needs something other than the ‚Äústandard‚Äù state transfer). <br><br>  <i><b>Inverting callbacks using events and async</b></i> <br><br>  Speaking about how frameworks affect the organization of your code, I cited a simple game engine as an example.  What could be done differently, so that you would not have to use variable fields and implement a specific class?  In F #, you could use asynchronous workflows and an event-oriented programming model. <br><br>  The situation is complicated in those languages ‚Äã‚Äãwhere there is nothing like computational expressions (as well as <a href="http://tomasp.net/blog/csharp-async.aspx/">iterators allowing to simulate such a functional</a> ), however C # supports await, F # has computational expressions, Haskell has do notation, and in Python, you can abuse it generators. <br><br>  The idea is that instead of writing virtual methods that you need to implement, we provide events that are triggered when you need to perform an operation.  So, the interface for our Game class might look like this: <br><br><pre> <code class="cs hljs">type Game = member Update : IEvent&lt;unit&gt; member Draw : IEvent&lt;DrawingContext&gt; member IsRunning : <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span></code> </pre><br><br>  When working with F # async, we can write code differently.  Returning to the original premise of comparing frameworks and libraries, we can achieve complete control over everything that happens!  The following example first initializes the resources and the Game object, and then implements the loop (using recursive async blocks), waiting for the Update or Draw event using the AwaitObservable method: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     let game = Inverted.Game() let mario = Image.Load("mario.png") //  ,      let rec loop x = async { if game.IsRunning then let! evt = Async.AwaitObservable(game.Update, game.Draw) match evt with | Choice1Of2() -&gt; //   'Update' return! loop (x + 1) | Choice2Of2(ctx) -&gt; //   'Draw' ctx.Draw(x, 0, mario) return! loop x } //  Game  x=0 loop 0</span></span></code> </pre><br><br>  Of course, absolute control cannot be achieved, since we do not know when we will receive calls from the system to update the game state or redraw the screen.  But we can fully control the initialization of resources, check when the game is playing, and wait for an event. <br><br>  The key point here is the use of async {...}.  We can use AwaitObservable to order: "resume calculations when Update or Draw is required."  When an event occurs, we perform the necessary action (update the state in line 12 or draw Mario in line 15), and then continue.  The most pleasant thing in this case is that such code can be easily extended to produce more complex logic - see, for example, the <a href="http://trelford.com/blog/post/FractalZoom.aspx">article by</a> Phil Trelford.  Another way to implement these properties is to use <a href="http://www.developerfusion.com/article/139804/an-introduction-to-f-agents/">F # agents</a> , which gives you similar control over logic. <br><br>  So now we control everything, but have we achieved much?  If you are not used to F #, then, most likely, the above code will seem confusing to you.  The main idea is that, reversing the control, we can easily write our own abstractions.  Here we come to the final stage ... <br><br>  <i><b>Use multiple levels of abstraction.</b></i> <br><br>  As I wrote in a <a href="http://tomasp.net/blog/2015/library-layers/">previous post</a> , the library should provide several levels of abstraction.  The Game type I used in the previous snippet is a low-level abstraction;  it is useful if you want to build something intricate, while giving you complete control.  But in other cases, the game can really consist of a couple of functions: ‚Äúupdate‚Äù and ‚Äúdraw‚Äù. <br>  This is done without difficulty, since we can simply take the previous code snippet and extract several parts into arguments: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startGame draw update init = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> game = Inverted.Game() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec loop x = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> game.IsRunning then <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! evt = Async.AwaitObservable(game.Update, game.Draw) match evt with | Choice1Of2() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! loop (update x) | Choice2Of2(ctx) -&gt; draw x ctx <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! loop x } loop init</code> </pre><br><br>  The startGame abstraction takes two functions as arguments, plus the initial state.  The update function updates the state, and the draw function draws it using the specified DrawingContext context.  Thus, we can write our game in ‚ÄúMario‚Äù in just four lines: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mario = Image.Load(<span class="hljs-string"><span class="hljs-string">"mario.png"</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span> |&gt; startGame (fun x ctx -&gt; ctx.Draw(x, <span class="hljs-number"><span class="hljs-number">0</span></span>, mario)) (fun x -&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><br>  If you carefully read the entire post, you can ask: Do I not contradict myself here?  Didn't I write above that higher-order functions that accept multiple functions (especially if they share a state) are perverse frameworks?  Yes, I said that!  But let me clarify this point: <br><br>  It is quite possible to have a convenient operation that takes a couple of other functions as a high-level abstraction, but it should have a simpler and more explicit alternative! <br><br>  You can take the four lines above, look at the definition of startGame and convert them to the 14 lines of code that we have already seen above (excluding comments).  That is, you should be able to gain control by placing one (not very deep) stage under the hood.  This practice differs from building brittle scaffolding on top of a badly crafted library, which sometimes has to be resorted to to write beautiful code. <br><br>  <i><b>Develop composable libraries</b></i> <br><br>  As mentioned above, one of the main reasons why libraries should be written, rather than frameworks, is the composability of libraries.  If you have complete control over this process, you can choose which libraries to use to solve which part of the problem.  Sometimes it is not easy, but with libraries you at least have a chance! <br><br>  I suppose there is no universal recipe for creating libraries that fit well.  It is probably important to note the following: your types should provide all the important information that other libraries would need (for similar purposes) if the need arose to create a similar data structure. <br><br>  A good example of this kind is <a href="https://www.nuget.org/packages/FsLab">FsLab</a> , a package that combines a number of F # packages for working with data (including <a href="http://bluemountaincapital.github.io/Deedle/">Deedle</a> , <a href="http://numerics.mathdotnet.com/">Math.NET Numerics,</a> and others).  The FsLab package comes with one script that bundles a number of other libraries together (the source code is <a href="">here</a> ). <br><br>  Two simple examples from the file are functions that perform the conversion from matrix to frame (Matrix.toFrame) and in the opposite direction (Frame.toMatrix): <br><br><pre> <code class="cs hljs">module Matrix = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline toFrame matrix = matrix |&gt; Matrix.toArray2 |&gt; Frame.ofArray2D module Frame = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline toMatrix frame = frame |&gt; Frame.toArray2D |&gt; DenseMatrix.ofArray2</code> </pre><br><br>  The solution here is quite simple, since both the Deedle frame and the Math.NET matrices can be converted to a two-dimensional array and back, so we just have to go in the array from one element to another. <br><br>  It looks very simple, but I see the essence in the following: no matter what your library does, you should make every effort to have this library with others (or replace certain components in it if they don‚Äôt like it!). </div><p>Source: <a href="https://habr.com/ru/post/261249/">https://habr.com/ru/post/261249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261239/index.html">We monitor the status of Push-notifications and news of the project + UPD RSS</a></li>
<li><a href="../261241/index.html">Read more about 3D navigation in nanoCAD Plus 7</a></li>
<li><a href="../261243/index.html">World OpenStack Summit and other news</a></li>
<li><a href="../261245/index.html">Lecture by Dmitry Vetrov on big data math: tensors, neural networks, Bayesian inference</a></li>
<li><a href="../261247/index.html">Anatomy of virtual telephony. Familiarity with the interface. Part 2</a></li>
<li><a href="../261253/index.html">"Programming a mouse" for microcontrollers</a></li>
<li><a href="../261255/index.html">Sberbank Security Online</a></li>
<li><a href="../261257/index.html">220 Volt AC Voltage Regulator</a></li>
<li><a href="../261259/index.html">Yandex-Transfer in the terminal via Java</a></li>
<li><a href="../261263/index.html">"Pip -t" is a simple alternative to virtualenv</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>