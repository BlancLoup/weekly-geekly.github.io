<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using mbed code in your own project on STM32 - overclocking experience of the Chinese LCD</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes someone else's code is very helpful in connecting to the peripheral iron microcontroller. Unfortunately, it is more difficult to adapt someo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using mbed code in your own project on STM32 - overclocking experience of the Chinese LCD</h1><div class="post__text post__text-html js-mediator-article">  Sometimes someone else's code is very helpful in connecting to the peripheral iron microcontroller.  Unfortunately, it is more difficult to adapt someone else's code to your project than to rewrite it yourself, especially when it comes to mega frameworks like arduino or mbed.  Wishing to connect a Chinese LCD based on ILI9341 to the STM32L476G DISCOVERY board, the author set out to use the driver written for mbed in the demo project from ST without changing a single line in its code.  As a result, we managed to accelerate the screen at the same time to unprecedented update speeds of 27 fps. <br><br><img src="https://habrastorage.org/files/e3a/44f/7c3/e3a44f7c39d643e29471ee044ea6ea38.jpg"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Introduction to the problem </h4><br>  ST Microelectronics produces very interesting microcontrollers, both in terms of capabilities and price, and also produces boards for rapid development.  About one of them will be discussed - <a href="http://www.st.com/web/catalog/tools/FM116/CL1620/SC959/SS1532/LN1848/PF261635%3Ficmp%3Dpf261635_pron_pr_sep2015%26sc%3Dstm32l476g-disco">STM32L476G DISCOVERY</a> .  The computational capabilities of this board are quite pleasing - a 32-bit ARM with a maximum clock frequency of 80MHz can perform floating-point operations.  At the same time, he is able to reduce power consumption to a minimum and work on batteries, waiting for the opportunity to do something useful.  To this device, I decided to connect a cheap Chinese color LCD with a resolution of 320 by 240, working on the SPI interface.  How to use it with mbed is described in detail <a href="https://geektimes.ru/post/258852/">here</a> .  <a href="https://www.mbed.com/">Mbed</a> is an online programming environment where you can compile your firmware without having a compiler on your computer at all, and then download and flash it by simply copying it to your mbed-compatible card, which when connected to USB looks like a removable disk.  All this is great, but there are a few problems.  Firstly, not all motherboards are mbed-compatible.  Secondly, there are many existing projects that are not compatible with mbed at all, including the software supplied by ST.  And finally, not all developers are compatible with mbed, some (for example, the author of these lines) find in this wonderful tool more disadvantages than advantages.  What are these drawbacks, we will discuss below until it suffices to mention that after connecting <a href="https://developer.mbed.org/users/dreschpe/code/SPI_TFT_ILI9341/">the display driver</a> to the demo project from ST and a few simple optimizations, it began to work faster about 10 times. <br><br><h4>  We study the driver code </h4><br>  It is time to download and examine the source code of <a href="https://developer.mbed.org/users/dreschpe/code/SPI_TFT_ILI9341/">the display driver</a> .  Working with ports in mbed is organized through calls to methods of classes that represent I / O ports.  For example, the DigitalOut class implements access to the output port.  Assigning a zero or one to an instance of this object initiates writing the corresponding bit to the output port.  Initialization of the DigitalOut class is performed by the PinName enumerated type, the only purpose of which is to identify the processor stem.  One of the main drawbacks of implementing DigitalOut and other classes that implement I / O is that the port is initialized in the class instance constructor.  This is great for flashing an LED if an instance of the DigitalOut class is created on the stack in the main function.  But let us imagine that we have a lot of various iron, the initialization of which is scattered across several modules.  If we make instances of our I / O classes static variables, we lose all control over the initialization, since it will occur before the main function and in an arbitrary order.  ST libraries (they are called HAL - hardware abstraction level) use a different, more flexible, paradigm.  Each I / O port has its own context and a set of functions that work with it, but they can be called exactly when it is needed.  Port contexts are usually created as static variables, but no automatic uncontrolled initialization takes place (ST libraries are written in C).  It is also worth mentioning the extremely <a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1533/PF259242%3Ficmp%3Dpf259242_pron_pr_jun2014%26sc%3Dstm32cube-pr6">handy</a> utility <a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1533/PF259242%3Ficmp%3Dpf259242_pron_pr_jun2014%26sc%3Dstm32cube-pr6">CubeMX</a> , which can generate all the necessary initialization code for the set of ports you need and even allows you to subsequently make changes to this set of ports without affecting your own code.  Its only drawback - the inability to use with existing projects, you must start the project by using this utility. <br><br>  The mbed library to initialize microcontroller resources uses the same HAL functions from the ST library, but it does this in a strikingly mindless way.  To make sure of this, just look at the SPI port initialization code (which we need to work with the display) in the <a href="">spi_api.c</a> file.  The spi_init function first looks for a suitable SPI port for the legs it will use, and then calls the init_spi function, which actually initializes the port.  In this case, for all 3 possible SPI ports, one static context structure is used. <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SPI_HandleTypeDef SpiHandle;</code> </pre> <br>  In essence, this is a classic example of using global variables instead of local ones.  Even taking into account the fact that we have one computational core, the global context is not protected from simultaneous use of code in different places, there are still interruptions, as well as preemptive multitasking. <br><br><h4>  We connect the library to your project </h4><br>  So I don't want to write all the code on mbed.  I much like the examples from ST, which come as part of <a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1743/LN1897%3Ficmp%3Dtt2930_gl_pron_oct2015%26sc%3Dstm32cube-pr14">CubeMX</a> .  I did not find the finished driver for my LCD for ST libraries, I didn‚Äôt have a desire to write it myself.  There remains an alternative way to have fun - connect a driver written for mbed, and so that it does not need to change anything.  All you need is to implement the mbed libraries in an alternative way.  In fact, the task is simpler than it seems, because of all the mbed libraries, the LCD driver uses only the output port and SPI.  In addition, it needs delay generation functions and file and stream classes.  With the latter, everything is simple - we do not need them and are replaced by plugs that do nothing.  The delay generation functions are easy to write; they are in the <a href="">wait_api.h</a> file.  Implementing I / O classes requires a bit more creativity.  We are going to fix the lack of mbed libraries and not to initialize the hardware in the constructor.  The constructor will receive a link to the context of the port, located somewhere else, its initialization code will be completely independent of our interface classes.  There is only one way to pass this information to the constructor, without changing the driver code, through PinName, which instead of simply listing the legs will now store the pointer to the port, the leg number, and also an optional pointer to the resource (like SPI) to which this leg is connected. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinName</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PinName() : m_port(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pin(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_obj(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} PinName(GPIO_TypeDef* port, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* obj = <span class="hljs-number"><span class="hljs-number">0</span></span>) : m_port(port), m_pin(pin), m_obj(obj) { assert_param(m_port != <span class="hljs-number"><span class="hljs-number">0</span></span>); } GPIO_TypeDef* m_port; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> m_pin; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* m_obj; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PinName not_connected; };</code> </pre><br><br>  The implementation of the output port is fairly trivial.  To improve performance, we will try to use HAL functions less, and work as far as possible directly with port registers, as well as write inline code, which will allow the compiler to avoid function calls. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DigitalOut</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: DigitalOut(GPIO_TypeDef* port, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> pin) : m_port(port), m_pin(pin) { assert_param(m_port != <span class="hljs-number"><span class="hljs-number">0</span></span>); } DigitalOut(PinName <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; N) : m_port(N.m_port), m_pin(N.m_pin) { assert_param(m_port != <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bit) m_port-&gt;BSRR = m_pin; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_port-&gt;BRR = m_pin; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: GPIO_TypeDef* m_port; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> m_pin; };</code> </pre><br><br>  The code for implementing the SPI port is not much more complicated; you can see it <a href="">here</a> .  Since we have separated the port initialization from the interface code, we ignore configuration change requests.  Digit word just remember.  If the user wants to transfer a 16-bit word, and the port is configured as 8-bit, then it is enough for us to simply swap the bytes and transfer them one by one - the port buffer still fits up to 4 bytes.  All files needed to compile the driver are compiled in the <a href="https://github.com/olegv142/STM32L4-ILI9341/tree/master/compat">compat</a> directory.  Now you can connect the original <a href="https://github.com/olegv142/STM32L4-ILI9341/tree/master/third">driver files</a> to the project and compile them.  We will also need <a href="">code</a> that initializes the ports, creates an instance of the driver, and draws something meaningful on the screen. <br><br><h4>  Overclocking </h4><br>  If LCD is used to display something dynamic, then there is a natural desire to make communication with it faster.  The first thing that comes to mind is to increase the SPI clock frequency, which the driver sets at 10MHz, but we ignore its wishes and can set any of them.  It turned out that the screen works fine and at a frequency of 40 MHz - this is the maximum frequency that our processor is capable of with a clock frequency of 80 MHz.  To evaluate the performance, a simple code was written, which in a cycle outputs a bitmap of 100x100 pixels.  The result was then extrapolated to the full screen (the bitmap that occupies the entire screen simply does not fit in the memory).  The result - 11fps is quite far from the theoretical limit of 32fps, which is obtained if you transmit 16 bits for each pixel without stopping.  The reason becomes clear if you look into the <a href="">source code of the driver</a> .  If he needs to transfer a sequence of bytes, he simply transfers them one by one, at best packing in 16 bit words.  The reason for this inefficient design lies in the mbed API.  <a href="https://developer.mbed.org/handbook/SPI">The SPI class</a> has a method for transmitting an array of data, but it can only be used asynchronously, calling the notification function upon completion, and in the context of an interrupt handler.  It is not surprising that very few people use this method.  I have supplemented my implementation of the SPI class with a function that transmits a buffer and waits for the transfer to complete.  After I added this function call to the bitmap transfer code, the performance increased to 27fps, which is already very close to the theoretical limit. <br><br><h4>  Source </h4><br>  Lies <a href="https://github.com/olegv142/STM32L4-ILI9341">here</a> .  IAR was used for compilation IAR Embedded Workbench for ARM 7.50.2.  The demo firmware code from ST is taken as a basis.  The description of the pins to which the LCD is connected can be found in the file <a href="">lcd.h.</a> </div><p>Source: <a href="https://habr.com/ru/post/390909/">https://habr.com/ru/post/390909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../390899/index.html">Professor Gotche: ‚ÄúBig Pharma Behavior‚Äù Meets the Criterion ‚ÄúOrganized Crime‚Äù ‚Äù</a></li>
<li><a href="../390901/index.html">German military tested the 10-kilowatt laser machine HEL</a></li>
<li><a href="../390903/index.html">Google showed a neural network capable of recognizing a country from a photo (as well as a city and a street), even if the photo was taken in a house</a></li>
<li><a href="../390905/index.html">Sales of phablets increased in Russia</a></li>
<li><a href="../390907/index.html">Apple responded to FBI requirements. In court, the company will support Google, Facebook and Microsoft.</a></li>
<li><a href="../390911/index.html">Geektimes + MWC2016 and all - all - all</a></li>
<li><a href="../390913/index.html">HR problems and IT specialists search</a></li>
<li><a href="../390915/index.html">In Mumbai, 16 zones were identified where you can‚Äôt take selfies: so that tourists don‚Äôt die</a></li>
<li><a href="../390917/index.html">CHIP - $ 9 Raspberry Pi Killer</a></li>
<li><a href="../390919/index.html">Raspberry Pi 3 will get Wi-Fi, Bluetooth LE - the first photos of mini-PC are already on the Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>