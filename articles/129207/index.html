<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing your own linux daemon with auto repair feature</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dear users, I would like to share with you the experience of writing server daemons. There are a lot of articles about this in Runet, but most of them...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing your own linux daemon with auto repair feature</h1><div class="post__text post__text-html js-mediator-article">  Dear users, I would like to share with you the experience of writing server daemons.  There are a lot of articles about this in Runet, but most of them do not give answers to such important questions as: <br><ul><li>  How to add a daemon to startup? </li><li>  What to do if in the process of work an error occurred and the demon crashed? </li><li>  How to update the configuration of the daemon without interrupting its work? </li></ul><br>  In this part, we consider the following points: <br><ul><li>  The principle of the demon. </li><li>  Fundamentals of the development of monitoring the state of the demon. </li><li>  Error handling at work, with a detailed report in the log. </li><li>  Some issues related to system resources. </li></ul><br>  For clarity, the source code of the following parts will be shown: <br><ul><li>  The main program template. </li><li>  Daemon monitoring function template. </li><li>  Error handling function template. </li><li>  A number of auxiliary functions. </li></ul><br><a name="habracut"></a><br>  <b>The principle of the demon.</b> <br>  Judging by the demon is a regular program running in the background.  But since our daemon will be launched from init.d, certain restrictions are imposed on it: <br><ul><li>  The daemon must save its PID to a file so that it can be correctly stopped later. </li><li>  You need to perform a number of preparatory operations to start working in the background. </li></ul><br>  In our model, the daemon will function according to the following algorithm: <br><ul><li>  Separation from the controlling terminal and transition to the background. </li><li>  The division into two parts: the parent (monitoring) and descendant (demon functionality). </li><li>  Monitoring the status of the daemon process. </li><li>  Processing the command to update the config. </li><li>  Error processing. </li></ul><br><br>  <b>Template program.</b> <br>  This code will perform all actions that are necessary for a successful launch of the daemon. <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> ** argv) <br> { <br> <font color="#0000ff">int</font> status; <br> <font color="#0000ff">int</font> pid; <br> <br> <font color="#008000">//      ,     </font> <br> <font color="#0000ff">if</font> (argc != 2) <br> { <br> printf( <font color="#A31515">"Usage: ./my_daemon filename.cfg\n"</font> ); <br> <font color="#0000ff">return</font> -1; <br> } <br> <br> <font color="#008000">//   </font> <br> status = LoadConfig(argv[1]); <br> <br> <font color="#0000ff">if</font> (!status) <font color="#008000">//     </font> <br> { <br> printf( <font color="#A31515">"Error: Load config failed\n"</font> ); <br> <font color="#0000ff">return</font> -1; <br> } <br> <br> <font color="#008000">//  </font> <br> pid = fork(); <br> <br> <font color="#0000ff">if</font> (pid == -1) <font color="#008000">//     </font> <br> { <br> <font color="#008000">//       </font> <br> printf( <font color="#A31515">"Error: Start Daemon failed (%s)\n"</font> , strerror(errno)); <br> <br> <font color="#0000ff">return</font> -1; <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> (!pid) <font color="#008000">//   </font> <br> { <br> <font color="#008000">//       </font> <br> <font color="#008000">//        ,</font> <br> <font color="#008000">//         </font> <br> umask(0); <br> <br> <font color="#008000">//   ,     </font> <br> setsid(); <br> <br> <font color="#008000">//    ,     ,    .</font> <br> <font color="#008000">//     </font> <br> chdir( <font color="#A31515">"/"</font> ); <br> <br> <font color="#008000">//   //,       </font> <br> close(STDIN_FILENO); <br> close(STDOUT_FILENO); <br> close(STDERR_FILENO); <br> <br> <font color="#008000">//       </font> <br> status = MonitorProc(); <br> <br> <font color="#0000ff">return</font> status; <br> } <br> <font color="#0000ff">else</font> <font color="#008000">//   </font> <br> { <br> <font color="#008000">//  , ..    ( )  </font> <br> <font color="#0000ff">return</font> 0; <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  The logic of work is simple and should not cause problems with understanding.  The only thing that needs to be clarified: <br><ul><li>  LoadConfig - this function loads the config from the specified file, its code will depend on the format of the config you are using, and will not be considered in this article. </li><li>  Closing descriptors is necessary because we will not use printf and scanf for other functions of working with console I / O.  This action is optional and is used to save resources. </li><li>  The transition to the root of the disk is necessary so that later there will be no problems associated with unmounting the disks.  If the current folder of the daemon resides on a disk that needs to be unmounted, the system will not allow this until the daemon is stopped. </li><li>  MonitorProc - this function will perform basic actions related to monitoring the status of the program. </li></ul><br>  <b>Fundamentals of the development of monitoring the state of the demon</b> <br>  The main purpose of monitoring is to monitor the status of the daemon process.  Only two things will be important to us: <br><ol><li>  Notification of the completion of the daemon process. </li><li>  Get the daemon completion code. </li></ol><br>  All monitoring of the daemon will be included in the MonitorProc function.  The whole point of monitoring is to start a child process and monitor it, and depending on its completion code, restart it or complete its work. <br>  Source code monitoring function: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> MonitorProc() <br> { <br> <font color="#0000ff">int</font> pid; <br> <font color="#0000ff">int</font> status; <br> <font color="#0000ff">int</font> need_start = 1; <br> sigset_t sigset; <br> siginfo_t siginfo; <br> <br> <font color="#008000">//     </font> <br> sigemptyset(&amp;sigset); <br> <br> <font color="#008000">//    </font> <br> sigaddset(&amp;sigset, SIGQUIT); <br> <br> <font color="#008000">//       </font> <br> sigaddset(&amp;sigset, SIGINT); <br> <br> <font color="#008000">//    </font> <br> sigaddset(&amp;sigset, SIGTERM); <br> <br> <font color="#008000">//       </font> <br> sigaddset(&amp;sigset, SIGCHLD); <br> <br> <font color="#008000">//         </font> <br> sigaddset(&amp;sigset, SIGUSR1); <br> sigprocmask(SIG_BLOCK, &amp;sigset, NULL); <br> <br> <font color="#008000">//       PID'</font> <br> SetPidFile(PID_FILE); <br> <br> <font color="#008000">//   </font> <br> <font color="#0000ff">for</font> (;;) <br> { <br> <font color="#008000">//    </font> <br> <font color="#0000ff">if</font> (need_start) <br> { <br> <font color="#008000">//  </font> <br> pid = fork(); <br> } <br> <br> need_start = 1; <br> <br> <font color="#0000ff">if</font> (pid == -1) <font color="#008000">//   </font> <br> { <br> <font color="#008000">//      </font> <br> WriteLog( <font color="#A31515">"[MONITOR] Fork failed (%s)\n"</font> , strerror(errno)); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> (!pid) <font color="#008000">//   </font> <br> { <br> <font color="#008000">//     </font> <br> <br> <font color="#008000">//      </font> <br> status = WorkProc(); <br> <br> <font color="#008000">//  </font> <br> exit(status); <br> } <br> <font color="#0000ff">else</font> <font color="#008000">//   </font> <br> { <br> <font color="#008000">//     </font> <br> <br> <font color="#008000">//   </font> <br> sigwaitinfo(&amp;sigset, &amp;siginfo); <br> <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> (siginfo.si_signo == SIGCHLD) <br> { <br> <font color="#008000">//   </font> <br> wait(&amp;status); <br> <br> <font color="#008000">//     </font> <br> status = WEXITSTATUS(status); <br> <br> <font color="#008000">//         ,     </font> <br> <font color="#0000ff">if</font> (status == CHILD_NEED_TERMINATE) <br> { <br> <font color="#008000">//      </font> <br> WriteLog( <font color="#A31515">"[MONITOR] Child stopped\n"</font> ); <br> <br> <font color="#008000">//  </font> <br> <font color="#0000ff">break</font> ; <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> (status == CHILD_NEED_WORK) <font color="#008000">//    </font> <br> { <br> <font color="#008000">//     </font> <br> WriteLog( <font color="#A31515">"[MONITOR] Child restart\n"</font> ); <br> } <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> (siginfo.si_signo == SIGUSR1) <font color="#008000">//       </font> <br> { <br> kill(pid, SIGUSR1); <font color="#008000">//   </font> <br> need_start = 0; <font color="#008000">//         </font> <br> } <br> <font color="#0000ff">else</font> <font color="#008000">//   -   </font> <br> { <br> <font color="#008000">//       </font> <br> WriteLog( <font color="#A31515">"[MONITOR] Signal %s\n"</font> , strsignal(siginfo.si_signo)); <br> <br> <font color="#008000">//  </font> <br> kill(pid, SIGTERM); <br> status = 0; <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> } <br> <br> <font color="#008000">//   ,   </font> <br> WriteLog( <font color="#A31515">"[MONITOR] Stop\n"</font> ); <br> <br> <font color="#008000">//    PID'</font> <br> unlink(PID_FILE); <br> <br> <font color="#0000ff">return</font> status; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote>  By code, you need to clarify the following: <br><ul><li>  PID_FILE is a constant that will store the file name for saving the PID.  In our case, this is /var/run/my_daemon.pid </li><li>  WriteLog is a function that writes to the log.  In it, you can come up with what your heart desires and write a log anywhere or even send it somewhere </li><li>  WorkProc - a function that implements the daemon's functionality directly. </li></ul><br>  Work requires an auxiliary function to create a PID file. <br>  Code: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> SetPidFile( <font color="#0000ff">char</font> * Filename) <br> { <br> FILE* f; <br> <br> f = fopen(Filename, <font color="#A31515">"w+"</font> ); <br> <font color="#0000ff">if</font> (f) <br> { <br> fprintf(f, <font color="#A31515">"%u"</font> , getpid()); <br> fclose(f); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  At the moment, our demon is already able to run, monitor its descendant, which performs the basic functions and, if necessary, restart it or send him a signal about the configuration change.  Next, consider the child code pattern: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> WorkProc() <br> { <br> <font color="#0000ff">struct</font> sigaction sigact; <br> sigset_t         sigset; <br> <font color="#0000ff">int</font> signo; <br> <font color="#0000ff">int</font> status; <br> <br> <font color="#008000">//         </font> <br> <font color="#008000">//        </font> <br> sigact.sa_flags = SA_SIGINFO; <br> <font color="#008000">//    </font> <br> sigact.sa_sigaction = signal_error; <br> <br> sigemptyset(&amp;sigact.sa_mask); <br> <br> <font color="#008000">//     </font> <br> <br> sigaction(SIGFPE, &amp;sigact, 0); <font color="#008000">//  FPU</font> <br> sigaction(SIGILL, &amp;sigact, 0); <font color="#008000">//  </font> <br> sigaction(SIGSEGV, &amp;sigact, 0); <font color="#008000">//    </font> <br> sigaction(SIGBUS, &amp;sigact, 0); <font color="#008000">//  ,     </font> <br> <br> sigemptyset(&amp;sigset); <br> <br> <font color="#008000">//     </font> <br> <font color="#008000">//    </font> <br> sigaddset(&amp;sigset, SIGQUIT); <br> <br> <font color="#008000">//       </font> <br> sigaddset(&amp;sigset, SIGINT); <br> <br> <font color="#008000">//    </font> <br> sigaddset(&amp;sigset, SIGTERM); <br> <br> <font color="#008000">//         </font> <br> sigaddset(&amp;sigset, SIGUSR1); <br> sigprocmask(SIG_BLOCK, &amp;sigset, NULL); <br> <br> <font color="#008000">//   -    </font> <br> SetFdLimit(FD_LIMIT); <br> <br> <font color="#008000">//   ,    </font> <br> WriteLog( <font color="#A31515">"[DAEMON] Started\n"</font> ); <br> <br> <font color="#008000">//    </font> <br> status = InitWorkThread(); <br> <font color="#0000ff">if</font> (!status) <br> { <br> <font color="#008000">//   </font> <br> <font color="#0000ff">for</font> (;;) <br> { <br> <font color="#008000">//   </font> <br> sigwait(&amp;sigset, &amp;signo); <br> <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> (signo == SIGUSR1) <br> { <br> <font color="#008000">//  </font> <br> status = ReloadConfig(); <br> <font color="#0000ff">if</font> (status == 0) <br> { <br> WriteLog( <font color="#A31515">"[DAEMON] Reload config failed\n"</font> ); <br> } <br> <font color="#0000ff">else</font> <br> { <br> WriteLog( <font color="#A31515">"[DAEMON] Reload config OK\n"</font> ); <br> } <br> } <br> <font color="#0000ff">else</font> <font color="#008000">//  -  ,    </font> <br> { <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <br> <font color="#008000">//          </font> <br> DestroyWorkThread(); <br> } <br> <font color="#0000ff">else</font> <br> { <br> WriteLog( <font color="#A31515">"[DAEMON] Create work thread failed\n"</font> ); <br> } <br> <br> WriteLog( <font color="#A31515">"[DAEMON] Stopped\n"</font> ); <br> <br> <font color="#008000">//     </font> <br> <font color="#0000ff">return</font> CHILD_NEED_TERMINATE; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  According to the code you need to say: <br><ul><li>  InitWorkThread is a function that creates all daemon workflows and initializes all work. </li><li>  DestroyWorkThread is a function that stops daemon workflows and correctly releases resources. </li><li>  ReloadConfig is a function that updates the config file (re-read the file and make the necessary changes to its work).  The file name can also be taken from the command line parameters. </li></ul><br>  These functions are already dependent on your daemon implementation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The principle of operation is the following: we install our handler on error signals, then we start all the workflows and wait for the completion signals or the update of the config. <br><br>  <b>Error handling at work, with a detailed report in the log.</b> <br><br>  Of course, the demons should work perfectly and not cause any kind of errors, but everyone can be wrong, and sometimes there are errors that are quite difficult to detect at the testing stage.  This is especially true for errors that occur when a heavy load.  For this important point in the development of the daemon is the correct error handling, as well as squeezing out of the error as much information as possible.  In this case, consider error handling while maintaining the call stack (backtrace).  This will give us information about exactly where the error occurred (in which function), and also we will be able to find out who called this function. <br><br>  Error handler function code: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">static</font> <font color="#0000ff">void</font> signal_error( <font color="#0000ff">int</font> sig, siginfo_t *si, <font color="#0000ff">void</font> *ptr) <br> { <br> <font color="#0000ff">void</font> * ErrorAddr; <br> <font color="#0000ff">void</font> * Trace[16]; <br> <font color="#0000ff">int</font> x; <br> <font color="#0000ff">int</font> TraceSize; <br> <font color="#0000ff">char</font> ** Messages; <br> <br> <font color="#008000">//       </font> <br> WriteLog( <font color="#A31515">"[DAEMON] Signal: %s, Addr: 0x%0.16X\n"</font> , strsignal(sig), si-&gt;si_addr); <br> <br> <br> <font color="#0000ff">#if</font> __WORDSIZE == 64 <font color="#008000">//     64  </font> <br> <font color="#008000">//      </font> <br> ErrorAddr = ( <font color="#0000ff">void</font> *)((ucontext_t*)ptr)-&gt;uc_mcontext.gregs[REG_RIP]; <br> <font color="#0000ff">#else</font> <br> <font color="#008000">//      </font> <br> ErrorAddr = ( <font color="#0000ff">void</font> *)((ucontext_t*)ptr)-&gt;uc_mcontext.gregs[REG_EIP]; <br> <font color="#0000ff">#endif</font> <br> <br> <font color="#008000">//  backtrace     </font> <br> TraceSize = backtrace(Trace, 16); <br> Trace[1] = ErrorAddr; <br> <br> <font color="#008000">//   </font> <br> Messages = backtrace_symbols(Trace, TraceSize); <br> <font color="#0000ff">if</font> (Messages) <br> { <br> WriteLog( <font color="#A31515">"== Backtrace ==\n"</font> ); <br> <br> <font color="#008000">//   </font> <br> <font color="#0000ff">for</font> (x = 1; x &lt; TraceSize; x++) <br> { <br> WriteLog( <font color="#A31515">"%s\n"</font> , Messages[x]); <br> } <br> <br> WriteLog( <font color="#A31515">"== End Backtrace ==\n"</font> ); <br> free(Messages); <br> } <br> <br> WriteLog( <font color="#A31515">"[DAEMON] Stopped\n"</font> ); <br> <br> <font color="#008000">//          </font> <br> DestroyWorkThread(); <br> <br> <font color="#008000">//      </font> <br> exit(CHILD_NEED_WORK); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  When using backtrace, you can get data of approximately the following form: <br> <code>[DAEMON] Signal: Segmentation fault, Addr: 0x0000000000000000 <br> == Backtrace == <br> /usr/sbin/my_daemon(GetParamStr+0x34) [0x8049e44] <br> /usr/sbin/my_daemon(GetParamInt+0x3a) [0x8049efa] <br> /usr/sbin/my_daemon(main+0x140) [0x804b170] <br> /lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xe6) [0x126bd6] <br> /usr/sbin/my_daemon() [0x8049ba1] <br> == End Backtrace == <br></code> <br>  From this data, you can see that the main function called the GetParamInt function.  The GetParamInt function called GetParamStr.  In the GetParamStr function at offset 0x34, a memory address at the zero address occurred. <br><br>  In addition to the call stack, you can save the value of registers (uc_mcontext.gregs array). <br>  It should be noted that the most informative information from backtrace can be obtained only when compiling without cutting out debugging information, as well as using the -rdynamic option. <br><br>  As you can see, the code uses the CHILD_NEED_WORK and CHILD_NEED_TERMINATE constants.  You can assign the value of these constants yourself, the main thing is that they are not the same. <br><br>  <b>Some issues related to system resources.</b> <br><br>  The important point is to set the maximum number of descriptors.  Any open file, socket, pipe, and others spend descriptors that, if exhausted, will not open the file or create a socket or accept an incoming connection.  This may affect the performance of the daemon.  By default, the maximum number of open descriptors is 1024. This number is very small for highly loaded network daemons.  Therefore, we will put this value more in accordance with their requirements.  To do this, use the following function: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> SetFdLimit( <font color="#0000ff">int</font> MaxFd) <br> { <br> <font color="#0000ff">struct</font> rlimit lim; <br> <font color="#0000ff">int</font> status; <br> <br> <font color="#008000">//     -  </font> <br> lim.rlim_cur = MaxFd; <br> <font color="#008000">//     -  </font> <br> lim.rlim_max = MaxFd; <br> <br> <font color="#008000">//   -</font> <br> status = setrlimit(RLIMIT_NOFILE, &amp;lim); <br> <br> <font color="#0000ff">return</font> status; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  <b>Instead of a conclusion.</b> <br>  So we looked at how to create the basis for a demon.  Of course, the code does not claim to be perfect, but it copes with its tasks perfectly. <br>  In the next article, the issues related to installing / uninstalling the daemon, managing it, writing autoload scripts for init.d and directly adding to autoload will be discussed. <br><br>  Link to source code: <a href="http://pastebin.com/jdX5wn0E">http://pastebin.com/jdX5wn0E</a> <br>  The source code contains all the functions used in one file.  When developing a project, it is desirable to scatter them into different files in accordance with their functional purpose. </div><p>Source: <a href="https://habr.com/ru/post/129207/">https://habr.com/ru/post/129207/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129201/index.html">The implementation of dictionary objects, as in Javascript</a></li>
<li><a href="../129202/index.html">Put the objects on the stream, the pattern of the factory of objects</a></li>
<li><a href="../129204/index.html">The story of a hack or how they tried to lead away everything, but did not take away anything</a></li>
<li><a href="../129205/index.html">On-the-fly Compilation in Erlang</a></li>
<li><a href="../129206/index.html">Zynga launched CityVille on Google+</a></li>
<li><a href="../129208/index.html">Sea, sun, student projects: Mat Fur Summer School</a></li>
<li><a href="../129211/index.html">Rally for a radical extension of life</a></li>
<li><a href="../129212/index.html">What markup is better to use for a content resource?</a></li>
<li><a href="../129217/index.html">What quotes do you use in your code?</a></li>
<li><a href="../129218/index.html">All serious</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>