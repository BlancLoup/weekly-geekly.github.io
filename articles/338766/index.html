<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Options in Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite some experience in mobile development (including the use of Swift), regularly on the basis of swift options there were situations when I knew ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Options in Swift</h1><div class="post__text post__text-html js-mediator-article"><p>  Despite some experience in mobile development (including the use of Swift), regularly on the basis of swift options there were situations when I knew <strong>what</strong> to do, but did not quite clearly understand <strong>why</strong> .  It was necessary to be distracted and go deep into the documentation - the number of ‚Äúnotes on the margins‚Äù was replenished with depressing periodicity.  At a certain point, they reached a critical mass, and I decided to streamline them in a single comprehensive guide.  The material turned out to be quite voluminous, since an attempt was made to reveal the topic in as much detail as possible.  The article will be useful for both beginner Swift developers and experienced professionals from the world of Objective-C - there is a non-zero probability that the latter will find something new for themselves.  And if they do not find it, they will add their own new in the comments, and everyone will benefit. </p><a name="habracut"></a><br><h4 id="chto-takoe-optionals">  <strong>What are Optionals?</strong> </h4><br><p>  <em>Optionals</em> are a convenient mechanism for handling situations where the value of a variable may be missing.  The value will be used only if it is. </p><br><h4 id="zachem-nuzhny-optionals-kogda-est-proverka-na-nil">  <strong>Why do we need Optionals when there is a nil check?</strong> </h4><br><p> First, the <code>nil</code> equality / inequality test applies only to <a href="https://en.wikipedia.org/wiki/Nullable_type">nullable types</a> and is not applicable to primitive types, structures, and enums.  To indicate the absence of a value for a variable of a primitive type, it is necessary to introduce special values, such as <em>NSNotFound</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text"><p>  <a href="https://developer.apple.com/reference/foundation/foundation_constants/nsnotfound"><em>NSNotFound</em></a> should not only be considered as a special value, but also ensure that it is not included in the set of acceptable values ‚Äã‚Äãof the variable.  The situation is further complicated by the fact that <em>NSNotFound</em> is considered equal to <em>NSIntegerMax</em> , i.e.  may have different values ‚Äã‚Äãfor different (32-bit / 64-bit) platforms.  This means that <em>NSNotFound</em> cannot be directly written to files and archives or used in <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/PreferencePanes/Tasks/Communication.html"><em>Distributed Objects</em></a> . </p></div></div><br><p>  Accordingly, the user of this variable must take into account that special values ‚Äã‚Äãare possible.  In Swift, even a primitive type can be used in an optional style, that is, explicitly indicating that values ‚Äã‚Äãmay not be. </p><br><p>  Secondly: explicit optionality is checked at the compilation stage, which reduces the number of errors in runtime.  An optional variable in Swift cannot be used in the same way as a non-optional variable (with the exception of implicitly derived options, see the <em>Implicit Unwrapping</em> section for <em>details</em> ).  The optional must either be forced to convert to the usual value, or use special transformative idioms, such as <code>if let</code> , <code>guard let</code> and <code>??</code>  .  Options in Swift implement not just a check, but the whole paradigm of <a href="https://en.wikipedia.org/wiki/Option_type">an optional type</a> in <a href="https://en.wikipedia.org/wiki/Option_type">type</a> <a href="https://en.wikipedia.org/wiki/Type_theory">theory</a> . </p><br><p>  Thirdly, optionals are syntactically more concise than checking for <code>nil</code> , which is especially well seen on the chains of optional calls - the so-called <em>Optional Chaining</em> . </p><br><h4 id="kak-eto-rabotaet">  <strong>How it works?</strong> </h4><br><p>  An optional in Swift is a special container object that can contain either <code>nil</code> or an object of a particular type, which is specified when the container is declared.  These two states are denoted by the terms <em>None</em> and <em>Some,</em> respectively.  If at creation of an optional variable the assigned value is not specified, then <code>nil</code> assigned by default. </p><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text"><p>  In the documentation, the default value in the case of the absence of an explicit assignment is not mentioned, but <a href="https://developer.apple.com/documentation/swift/optional">it is said</a> that it <em>represents the absence of a value</em> .  If an optional variable is declared without an explicit assignment (some <em>Some was</em> not assigned), then it logically follows that <em>None</em> is implicitly assigned ‚Äî the optionals have no third "uninitialized" state. </p></div></div><br><p>  Is the optional declared by a combination of type name and lexeme <code>?</code>  .  So, record <code>Int?</code>  Is a container declaration, an instance of which may contain <code>nil</code> inside (state <em>None Int</em> ) or a value of type <code>Int</code> (state <em>Some Int</em> ).  That is why when converting an <code>Int?</code>  in <code>Int</code> uses the term <em>unwrapping</em> instead of <em>cast</em> , i.e.  The "containerized" essence of the option is underlined.  A nick in Swift denotes a state of <em>None</em> that can be assigned to any option.  This logically leads to the impossibility of assigning <code>nil</code> (state <em>None</em> ) to a variable that is not optional. </p><br><p>  In fact, an optional is a system enumeration: </p><br><pre> <code class="hljs ruby">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ The absence of a value. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> In code, the absence of a value is typically written using the <span class="hljs-string"><span class="hljs-string">`nil`</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> literal rather than the explicit <span class="hljs-string"><span class="hljs-string">`.none`</span></span> enumeration <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> none /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> The presence of a value, stored as <span class="hljs-string"><span class="hljs-string">`Wrapped`</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> some(Wrapped) /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Creates an instance that stores the given value. public init(<span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-symbol"><span class="hljs-symbol">some:</span></span> Wrapped) ... /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Creates an instance initialized with <span class="hljs-string"><span class="hljs-string">`nil`</span></span>. /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Do <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> call this initializer directly. It is used by the compiler /<span class="hljs-regexp"><span class="hljs-regexp">/ when you initialize an `Optional` instance with a `nil` literal. public init(nilLiteral: ()) ... }</span></span></code> </pre> <br><p>  The <code>Optional</code> enumeration has two possible states: <code>.none</code> and <code>some(Wrapped)</code> .  Record <code>Wrapped?</code>  processed by the preprocessor ( <em>Swift's type system</em> ) and transformed into <code>Optional&lt;Wrapped&gt;</code> , i.e.  The following entries are equivalent: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: <span class="hljs-type"><span class="hljs-type">Int?</span></span></code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;</code> </pre> <br><p>  The token <code>nil</code> in fact denotes <code>Optional.none</code> , i.e.  The following entries are equivalent: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: <span class="hljs-type"><span class="hljs-type">Optional</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">Optional</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span></code> </pre> <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable = <span class="hljs-type"><span class="hljs-type">Optional</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span></code> </pre> <br><p>  The <code>Optional</code> enumeration has two constructors.  The first <code>init(_ some: Wrapped)</code> constructor <code>init(_ some: Wrapped)</code> takes as input the value of the corresponding type, i.e.  The following entries are equivalent: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable = <span class="hljs-type"><span class="hljs-type">Optional</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  .some- Int  </span></span></code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable = Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    Int  </span></span></code> </pre> <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable = <span class="hljs-type"><span class="hljs-type">Int?</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  Int   </span></span></code> </pre> <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-comment"><span class="hljs-comment">//  Int   </span></span></code> </pre> <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable = <span class="hljs-type"><span class="hljs-type">Optional</span></span>.some(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  Int  </span></span></code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable = Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;.some(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><p>  The second <code>init(nilLiteral: ())</code> constructor <code>init(nilLiteral: ())</code> is an implementation of the <code>ExpressibleByNilLiteral</code> protocol </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressibleByNilLiteral</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/// Creates an instance initialized with `nil`. public init(nilLiteral: ()) }</span></span></code> </pre> <br><p>  and initializes the optional variable with the <code>.none</code> state.  This constructor is used by the compiler.  According to the <a href="https://developer.apple.com/documentation/swift/optional/1538243-init">documentation</a> it is not recommended to call it directly. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> test = Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;(nilLiteral: ()) <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  which is logical, since the conversion of the empty tuple Void <code>()</code> to <code>nil</code> somewhat unclear. </p><br><p>  Instead, this constructor should be used. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">//  var my_variable: Int? = Optional.none</span></span></code> </pre> <br><p>  or not to use explicit assignment at all </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> my_variable: <span class="hljs-type"><span class="hljs-type">Int?</span></span></code> </pre> <br><p>  since <code>nil</code> will be assigned by default. </p><br><p>  The <code>Optional&lt;Wrapped&gt;</code> enumeration also contains the unsafelyUnwrapped property, which provides read access to the <code>.some</code> optional: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optional</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressibleByNilLiteral</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">/// The wrapped value of this instance, unwrapped without checking whether /// the instance is `nil`. public var unsafelyUnwrapped: Wrapped { get } }</span></span></code> </pre> <br><p>  If the optional is in the <code>.none</code> state, a call to <code>unsafelyUnwrapped</code> will result <strong>in a serious program crash</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text"><p>  In <em>debug build -Onone debug mode, there</em> will be a runtime error: </p><br><pre> <code class="hljs lua">_fatal <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: unsafelyUnwrapped of <span class="hljs-literal"><span class="hljs-literal">nil</span></span> optional_</code> </pre> <br><p>  In the release build <em>optimized build -O there</em> will be a runtime error <strong><a href="https://developer.apple.com/documentation/swift/optional/1641793-unsafelyunwrapped">or undefined behavior</a></strong> .  A safer operation is <em>Force Unwrapping</em> (or <em>Explicit Unwrapping</em> ) - the forced extraction of a <code>.some</code> denoted by a token <code>!</code>  .  Applying <em>Force Unwrapping</em> to an option in the <code>.none</code> state will result in runtime error: </p><br><pre> <code class="hljs lua">_fatal <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: unexpectedly found <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> unwrapping an Optional value_</code> </pre> </div></div><br><pre> <code class="hljs pgsql">let my_variable1 = <span class="hljs-type"><span class="hljs-type">Int</span></span>?(<span class="hljs-number"><span class="hljs-number">42</span></span>) //  <span class="hljs-number"><span class="hljs-number">42</span></span>,  Optional <span class="hljs-type"><span class="hljs-type">Int</span></span> let my_value1A = my_variable1! //  <span class="hljs-number"><span class="hljs-number">42</span></span>,  <span class="hljs-type"><span class="hljs-type">Int</span></span> let my_value1B = my_variable1.unsafelyUnwrapped //  <span class="hljs-number"><span class="hljs-number">42</span></span>,  <span class="hljs-type"><span class="hljs-type">Int</span></span> let my_variable2 = <span class="hljs-type"><span class="hljs-type">Int</span></span>?.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> //  nil,  Optional <span class="hljs-type"><span class="hljs-type">Int</span></span> let my_value2A = my_variable2! //   //     -Onone,     -O let my_value2B = my_variable2.unsafelyUnwrapped</code> </pre> <br><h4 id="idiomy-ispolzovaniya">  <strong>Idioms use</strong> </h4><br><p>  It makes little sense to use a regular two-state enumeration.  It is quite possible to implement a similar mechanism yourself: create an <em>enum</em> with two states and constructors for the corresponding values, add some postfix operator for <em>Force Unwrapping</em> (for example, as it is done <a href="http://jamesonquave.com/blog/re-implementing-optionals-using-swifts-powerful-enum-type/">here</a> ), add the ability to compare with <code>nil</code> or even invent your own <code>nil</code> and m .d  Options should be integrated directly into the language itself so that their use is natural, not alien.  Of course, such integration can be considered as ‚Äúsyntactic sugar‚Äù, however, high-level languages ‚Äã‚Äãexist to write (and read) the code on them easily and pleasantly.  The use of optionals in Swift implies a number of idioms or special language constructs that help reduce errors and make the code more concise.  Such idioms include <em>Implicit Unwrapping</em> , <em>Optional Chaining</em> , <em>Nil-Coalescing</em> and <em>Optional Binding</em> . </p><br><h4 id="implicit-unwrapping">  <strong>Implicit unwrapping</strong> </h4><br><p>  Safe use of <em>Force Unwrapping</em> implies a preliminary check for <code>nil</code> , for example, in the if condition: </p><br><pre> <code class="hljs pgsql">// getOptionalResult()   nil let my_variable: <span class="hljs-type"><span class="hljs-type">Int</span></span>? = getOptionalResult() //  Optional <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> my_variable != nil { // my_value  .<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-   getOptionalResult() let my_value = my_variable! } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let my_value = my_variable! }</code> </pre> <br><p>  Sometimes it is obvious from the structure of the program that a variable is technically optional, but by the time it is first used it is always in a <code>.some</code> state, i.e.  is not <code>nil</code> .  To use an optional in a non-optional context (for example, passing it to a function with a non-optional type parameter), you have to constantly use <em>Force Unwrapping</em> with a preliminary check, which is boring and tedious.  In these cases, implicitly <em>unwrapped optional</em> can be applied implicitly.  An implicitly retrieved optional is declared by a combination of the type name and the token <code>!</code>  : </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_variable1: Int? = 42 //  Optional Int <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_variable2: Int! = 42 //  Implicitly Unwrapped Optional Int var my_variable3: Int! = 42 //  Implicitly Unwrapped Optional Int ... my_variable3 = nil // -   nil ... func sayHello(<span class="hljs-built_in"><span class="hljs-built_in">times</span></span>:Int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0...times { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>) } } sayHello(<span class="hljs-built_in"><span class="hljs-built_in">times</span></span>: my_variable1!) //     sayHello(<span class="hljs-built_in"><span class="hljs-built_in">times</span></span>: my_variable1) //   sayHello(<span class="hljs-built_in"><span class="hljs-built_in">times</span></span>: my_variable2!) // ,       sayHello(<span class="hljs-built_in"><span class="hljs-built_in">times</span></span>: my_variable2) //   sayHello(<span class="hljs-built_in"><span class="hljs-built_in">times</span></span>: my_variable3) //  </code> </pre> <br><p>  In the call to <code>sayHello(times: my_variable2)</code> extracting the value <code>42</code> from <code>my_variable2</code> <strong>is still carried out, only implicitly</strong> .  The use of implicitly retrievable options makes the code more readable ‚Äî there are no exclamation marks that distract attention (it is likely that the reader will be troubled by the use of <em>Force Unwrapping</em> without prior verification).  In practice, it is rather an anti-pattern, increasing the likelihood of error.  The implicitly retrievable option forces the compiler to "close eyes" on the fact that the optional is used in a non-optional context.  An error that can be detected at compile time (call <code>sayHello(times: my_variable1)</code> ) will manifest only in runtime (call <code>sayHello(times: my_variable3)</code> ).  Explicit code is always better than implicit.  It is logical to assume that such a reduction in the security code is required not only for the sake of eliminating exclamation marks, and this is true. </p><br><p>  Implicitly optional options allow you to use <code>self</code> in the constructor to initialize properties and, in addition,: </p><br><ul><li>  do not violate the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html">two-step initialization</a> rules (in the constructor, all properties must be initialized before <code>self</code> accessing) - otherwise the code will not be compiled; </li><li>  avoid unnecessary options in a property for which it is not required (in its meaning, the value of a property cannot be absent). </li></ul><br><p>  A vivid example of where you need to use <code>self</code> in a constructor for initializing properties is given in the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">documentation</a> : </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Country</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capitalCity: <span class="hljs-type"><span class="hljs-type">City!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, capitalName: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.capitalCity = <span class="hljs-type"><span class="hljs-type">City</span></span>(name: capitalName, country: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> country: <span class="hljs-type"><span class="hljs-type">Country</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, country: <span class="hljs-type"><span class="hljs-type">Country</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.country = country } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> country = <span class="hljs-type"><span class="hljs-type">Country</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Canada"</span></span>, capitalName: <span class="hljs-string"><span class="hljs-string">"Ottawa"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(country.name)'s capital city is called \(country.capitalCity.name)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Prints "Canada's capital city is called Ottawa"</span></span></code> </pre> <br><p>  In this example, instances of the <em>Country</em> and <em>City</em> classes should have friend-to-friend references by the time the initialization is completed.  Each country must have a capital and each capital must have a country.  These connections are not optional - they are unconditional.  During the initialization process of the <code>country</code> object, it is necessary to initialize the <code>capitalCity</code> property.  To initialize <code>capitalCity</code> you need to create an instance of the <em>City</em> class.  The <em>City</em> constructor requires the corresponding <em>Country</em> instance as a parameter, i.e.  requires access to <code>self</code> .  The difficulty is that the <em>Country</em> instance is not yet fully initialized, i.e.  <code>self</code> cannot be used. </p><br><p>  This task has an elegant solution: <code>capitalCity</code> declared a mutable implicitly retrievable option.  Like any mutable optional, <code>capitalCity</code> by default initialized to the <code>nil</code> state, that is, by the time the <em>City</em> constructor is called, all the properties of the <code>country</code> object have already been initialized.  Requirements of two-stage initialization are met, the <em>Country</em> constructor is in the second phase - you can pass <code>self</code> to the <em>City</em> constructor.  <code>capitalCity</code> is an implicit option, i.e.  it can be accessed in a non-contextual context without adding <code>!</code>  . </p><br><p>  A side effect of using an implicitly retrievable option is the ‚Äúbuilt-in‚Äù <code>assert</code> : if <code>capitalCity</code> for some reason, this will lead to runtime error and program crashes. </p><br><p>  Another example of the justified use of implicitly retrievable <code>@IBOutlet</code> : the context of their use implies that the <code>.some</code> automatically assigned to the variable at the time of the first call.  If this is not the case, a runtime error will occur.  Automatic generation of code in <em>Interface Builder</em> creates properties with <code>@IBOutlet</code> in the form of implicit <code>@IBOutlet</code> .  If this behavior is unacceptable, the property with <code>@IBOutlet</code> can be declared as an explicit optional and always process <code>.none</code> values ‚Äã‚Äãexplicitly.  As a rule, it is still better to get a ‚Äúcrash‚Äù right away than to do a long debugging in case of an accidentally untied <code>@IBOutlet</code> property. </p><br><h4 id="optional-chaining">  <strong>Optional chaining</strong> </h4><br><p>  <em>Optional Chaining</em> is a process of successive calls on a chain, where each link returns an option.  The process is interrupted at the first option in the <code>nil</code> state ‚Äî in this case the result of the entire call chain will also be <code>nil</code> .  If all the links in the chain are in the <code>.some</code> state, then the resulting value will be optional with the result of the last call.  To form the links of the chain is used token <code>?</code>  which is placed immediately after the call that returns the option.  Chain links can be any operations that return an optional: access to a local variable (as the first link), calls to properties and methods, access by index. </p><br><p>  <em>Optional shaping</em> always works sequentially from left to right.  Each next link is passed <code>.some</code> previous link, while the resulting value of the chain is always optional, i.e.  The chain works according to the following rules: </p><br><ul><li>  the first link must be optional; </li><li>  after the token <code>?</code>  should be the next link; </li><li>  if the link is in the <code>.none</code> state, then the chain aborts the call process and returns <code>nil</code> ; </li><li>  if the link is in the <code>.some</code> state, then the chain gives the <code>.some</code> link to the input of the next link (if there is one); </li><li>  if the result of the last link is optional, then the chain returns this optional; </li><li>  if the result of the last link is not an optional, the chain returns this result wrapped in the optional (the result of the calculation is assigned to the <code>.some</code> returned optional). </li></ul><br><pre> <code class="hljs bash">//    :   ‚Äî  `country.mainSeaport?`, country.mainSeaport?.nearestVacantPier?.capacity //  ,  `?`     <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> mainSeaport = country.mainSeaport? //   `nil`    country = Country(name: <span class="hljs-string"><span class="hljs-string">"Mongolia"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> capacity = country.mainSeaport?.mainPier?.capacity //    ‚Äî      country = Country(name: <span class="hljs-string"><span class="hljs-string">"Finland"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> nearestVacantPier = country.mainSeaport?.nearestVacantPier //    ‚Äî   ,   capacity //    country = Country(name: <span class="hljs-string"><span class="hljs-string">"Finland"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> capacity = country.mainSeaport?.nearestVacantPier?.capacity</code> </pre> <br><p>  It is important to distinguish between chains of optional calls and nested options.  An nested optional is formed when the <code>.some</code> one optional is another optional: </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> valueA = 42 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionalValueA = Optional(valueA) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> doubleOptionalValueA = Optional(optionalValueA) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> tripleOptionalValueA = Optional(doubleOptionalValueA) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> tripleOptionalValueB: Int??? = 42 //  `?`    <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> doubleOptionalValueB = tripleOptionalValueB! <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionalValueB = doubleOptionalValueB! <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> valueB = optionalValueB! <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(valueA)"</span></span>) // 42 <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(optionalValueA)"</span></span>) // Optional(42) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(doubleOptionalValueA)"</span></span>) // Optional(Optional(42)) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(tripleOptionalValueA)"</span></span>) // Optional(Optional(Optional(42))) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(tripleOptionalValueB)"</span></span>) // Optional(Optional(Optional(42))) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(doubleOptionalValueB)"</span></span>) // Optional(Optional(42)) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(optionalValueB)"</span></span>) // Optional(42) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(valueB)"</span></span>) // 42</code> </pre> <br><p>  <em>Optional shaping</em> does not increase the nesting level of the returned option.  However, this does not exclude the situation when the resultant value of any link is an option with several levels of nesting.  In such situations, to continue the chain you need to register <code>?</code>  in an amount equal to the number of nesting levels: </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionalAppDelegate = UIApplication.shared.delegate <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> doubleOptionalWindow = UIApplication.shared.delegate?.window <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionalFrame = UIApplication.shared.delegate?.window??.frame //  <span class="hljs-string"><span class="hljs-string">'?'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(optionalAppDelegate)"</span></span>) // Optional( ... ) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(doubleOptionalWindow)"</span></span>) // Optional(Optional( ... )) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(optionalFrame)"</span></span>) // Optional( ... )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text"><p>  Generally speaking, it is not necessary that all levels of nesting be "deployed" using a token <code>?</code>  . Part of them can be replaced by forced extraction <code>!</code>  That will reduce the number of "implicit" links in the chain.  A separate question is whether this makes sense. </p></div></div><br><p>  The <code>UIApplication.shared.delegate?.window??.frame</code> chain actually consists of four links: <code>UIApplication.shared.delegate?</code>  , <code>.frame</code> and two links, combined in one call <code>.window??</code>  .  The second "double" link is represented by an option of the second level of nesting. </p><br><p>  An important feature of this example is also a special way of forming a double optional, which differs from the way of forming a <code>doubleOptionalValue</code> in the previous example.  <code>UIApplication.shared.delegate!.window</code> is <strong>an optional property</strong> in which the optional is returned.  The optionalness of a property means that the property itself may be missing, and not just the <code>.some</code> the optional returned from the property.  An optional property, like all other properties, can return any type, not just an optional one.  Optionality of this kind is formed in the <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">@ objc protocols</a> with the <code>optional</code> modifier: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIApplicationDelegate</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObjectProtocol</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-meta"><span class="hljs-meta">@available</span></span>(iOS <span class="hljs-number"><span class="hljs-number">5.0</span></span>, * ) <span class="hljs-keyword"><span class="hljs-keyword">optional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> window: <span class="hljs-type"><span class="hljs-type">UIWindow?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  optional ... }</span></span></code> </pre> <br><p>  In protocols with optional properties and methods (otherwise, optional requirements), the <code>@objc</code> modifier <code>@objc</code> specified for each optional requirement and for the protocol itself.  This requirement does not apply to the <em>UIApplicationDelegate</em> protocol from the example above, since  it is translated to Swift from the system library on Objective-C.  Calling an unfulfilled optional request on an object that accepts such a protocol returns an optional type of the corresponding type in the <code>.none</code> state.  Calling an implemented optional request returns an optional type of the corresponding type in the <code>.some</code> state.  Thus, optional properties and methods, in contrast to <em>optional editing</em> , increase the nesting level of the returned option.  An optional method, like a property, is "wrapped" in an optional completely - the <code>.some</code> method is placed in the <code>.some</code> value, and not just the return value: </p><br><pre> <code class="hljs pgsql">@objc <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> protocol myOptionalProtocol { @objc optional var my_variable: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } @objc optional var my_optionalVariableA: <span class="hljs-type"><span class="hljs-type">Int</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } //  : //  @objc      <span class="hljs-type"><span class="hljs-type">Int</span></span>?, .. <span class="hljs-type"><span class="hljs-type">Int</span></span> //    @objc optional var my_optionalVariableB: UIView? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } @objc optional func my_func() -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> @objc optional func my_optionalResultfuncA() -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>? //  : //  @objc      <span class="hljs-type"><span class="hljs-type">Int</span></span>?, .. <span class="hljs-type"><span class="hljs-type">Int</span></span> //    @objc optional func my_optionalResultfuncB() -&gt; UIView? @objc optional init(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span>) //  : //  optional    } @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate, myOptionalProtocol { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { let protocolAdoption = self <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> myOptionalProtocol // Optional&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt; print("\(type(of: protocolAdoption.my_variable))") // Optional&lt;Optional&lt;UIView&gt;&gt; print("\(type(of: protocolAdoption.my_optionalVariableB))") // Optional&lt;() -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>&gt; print("\(type(of: protocolAdoption.my_func))") // Optional&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt; print("\(type(of: protocolAdoption.my_func?()))") // Optional&lt;() -&gt; Optional&lt;UIView&gt;&gt; print("\(type(of: protocolAdoption.my_optionalResultfuncB))") // Optional&lt;UIView&gt; print("\(type(of: protocolAdoption.my_optionalResultfuncB?()))") <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre> <br><p>   <code>@objc</code> -   ,   ,      Swift       Objective-C: </p><br><ul><li>      ,    Objective-C,      <code>@objc</code> (..        ); </li><li>  <code>optional</code>   - <code>init</code> ; </li><li> c     <code>@objc</code>       ‚Äî   . </li></ul><br><p>   <em>Force Unwrapping</em>            ,    <em>Force Unwrapping</em>       <code>.none</code> . </p><br><h4 id="nil-coalescing"> <strong>Nil-Coalescing</strong> </h4><br><p>  <em>Nil-Coalescing</em>  <code>.some</code> - ,     <code>.some</code> ,    ,     <code>.none</code> .  <em>Nil-Coalescing</em>  ,   <code>if else</code> ,   ,     <code>?</code>  : </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionalText: String? = tryExtractText() //  <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> textA: String <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> optionalText != nil { textA = optionalText! } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { textA = <span class="hljs-string"><span class="hljs-string">"Extraction Error!"</span></span> } //   ,    <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> textB = (optionalText != nil) ? optionalText! : <span class="hljs-string"><span class="hljs-string">"Extraction Error!"</span></span> //     <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> textC = optionalText ?? <span class="hljs-string"><span class="hljs-string">"Extraction Error!"</span></span></code> </pre> <br><p>         <code>.some</code> -  .       : </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optionalText: <span class="hljs-type"><span class="hljs-type">String?</span></span>? = tryExtractOptionalText() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = optionalText ?? <span class="hljs-type"><span class="hljs-type">Optional</span></span>(<span class="hljs-string"><span class="hljs-string">"Extraction Error!"</span></span>)</code> </pre> <br><p>            : </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wayA: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = doSomething() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wayB: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = doNothing() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> defaultWay: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = ignoreEverything() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatDo = wayA ?? wayB ?? defaultWay</code> </pre> <br><h4 id="optional-binding-i-privedenie-tipov"> <strong>Optional Binding   </strong> </h4><br><p> <em>Optional Binding</em>  ,    <code>.some</code> -,   ,             ( ). <em>Optional Binding</em>     <code>if</code> , <code>while</code>  <code>guard</code> . </p><br><p>      <em>Optional Binding</em>  ,    ,     . </p><br><p>  Swift        <code>return</code>   <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html"> </a> <code>()</code> .   <code>=</code>    <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html">  </a> ,         <code>==</code> . </p><br><p> ,        ,         <code>nil</code> ,     <code>nil</code> .         <code>if</code> ,       <em>true</em> ,  <code>nil</code>   <em>false</em> : </p><br><pre> <code class="hljs lua">var my_optionalVariable: Int? = <span class="hljs-number"><span class="hljs-number">42</span></span> //  , my_variable <span class="hljs-string"><span class="hljs-string">""</span></span>  .some- my_optionalVariable <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let my_variable = my_optionalVariable { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(my_variable)"</span></span>) // <span class="hljs-number"><span class="hljs-number">42</span></span> } my_optionalVariable = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> //  , my_variable   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let my_variable = my_optionalVariable { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(my_variable)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Optional variable is nil!"</span></span>) // Optional variable is <span class="hljs-literal"><span class="hljs-literal">nil</span></span>! }</code> </pre> <br><p> ,     <em>true</em> ,           . - <code>nil</code>        <code>.some</code> -  .   <em>true</em> <code>.some</code> -      ""    (      <em>Optional Binding</em> ). </p><br><p>       <code>if</code>   <em>true</em> ,  ,    <em>false</em>      .   ,  ,       <code>.some</code> -,    <em>false</em> (   <code>.none</code> )   .       <code>guard</code> : </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_optionalVariable: Int? = extractOptionalValue() //   <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_variableA: Int <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> value = my_optionalVariable { my_variableA = value } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(my_variableA + 1) //  guard <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_variableB = my_optionalVariable <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(my_variableB + 1)</code> </pre> <br><p>  Swift     (,      )     <code>as</code> .  ,         (,  ),      <code>as!</code> ,     <code>as?</code>  .      <em>Force Unwrapping</em> , ..         ,           <code>nil</code> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Shape {} <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>: Shape {} <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Triangle: Shape {} let <span class="hljs-type"><span class="hljs-type">circle</span></span> = Circle() let circleShape: Shape = Circle() let triangleShape: Shape = Triangle() <span class="hljs-type"><span class="hljs-type">circle</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Shape //   <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Float</span></span> //   circleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span> //   circleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">Circle</span></span> // <span class="hljs-type"><span class="hljs-type">circle</span></span> triangleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">Circle</span></span> //   circleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Circle</span></span> // Optional&lt;<span class="hljs-type"><span class="hljs-type">Circle</span></span>&gt; triangleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Circle</span></span> // nil</code> </pre> <br><p>  ,    <code>as?</code>  ,       <em>Optional Binding</em> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Shape {} <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>: Shape {} <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Triangle: Shape {} let circleShape: Shape = Circle() let triangleShape: Shape = Triangle() //  ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-type"><span class="hljs-type">circle</span></span> = circleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Circle</span></span> { print("Cast success: \(type(of: circle))") // <span class="hljs-keyword"><span class="hljs-keyword">Cast</span></span> success: (<span class="hljs-type"><span class="hljs-type">Circle</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { print("Cast failure") } //  ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-type"><span class="hljs-type">circle</span></span> = triangleShape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Circle</span></span> { print("Cast success: \(type(of: circle))") } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { print("Cast failure") // <span class="hljs-keyword"><span class="hljs-keyword">Cast</span></span> failure }</code> </pre> <br><h4 id="map-i-flatmap"> <strong>map  flatMap</strong> </h4><br><p>  <code>map</code>  <code>flatMap</code>      Swift,        <em>Optional</em> : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral { ... <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Evaluates the given closure when this `Optional` instance is not `nil`, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> passing the unwrapped value as a parameter. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Use the `map` method with a closure that returns a nonoptional value. public func map</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;U&gt;</span></span></span><span class="hljs-comment">(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U? </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Evaluates the given closure when this `Optional` instance is not `nil`, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> passing the unwrapped value as a parameter. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Use the `flatMap` method with a closure that returns an optional value. public func flatMap</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;U&gt;</span></span></span><span class="hljs-comment">(_ transform: (Wrapped) throws -&gt; U?) rethrows -&gt; U? ... }</span></span></code> </pre> <br><p>         <code>.some</code> -      ,    .    <code>nil</code> ,    <code>nil</code> .   <code>map</code>  <code>flatmap</code>    -:  <code>flatMap</code>     <code>nil</code> (),   <code>map</code>     : </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_variable: Int? = 4 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_squareVariable = my_variable.map { v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> v * v } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(my_squareVariable)"</span></span>) // Optional(16) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> my_reciprocalVariable: Double? = my_variable.flatMap { v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v == 0 { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> nil } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 1.0 / Double(v) } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(my_reciprocalVariable)"</span></span>) // Optional(0.25)</code> </pre> <br><p>   <code>map</code>  <code>flatmap</code>   ,       <code>if</code>  <code>guard</code> ,   ,      : </p><br><pre> <code class="hljs lua">let dateFormatter = DateFormatter() dateFormatter.dateFormat = <span class="hljs-string"><span class="hljs-string">"dd MMM yyyy"</span></span> let <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: Date? = extractOptionalDate() //  let dateStringA: String <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { dateStringA = dateFormatter.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(from: <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>!) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dateStringA = <span class="hljs-string"><span class="hljs-string">"Unknown date"</span></span> } //   ,    let dateStringB = (<span class="hljs-built_in"><span class="hljs-built_in">date</span></span> == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-literal"><span class="hljs-literal">nil</span></span> : dateFormatter.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(from: <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>!)) ?? <span class="hljs-string"><span class="hljs-string">"Unknown date"</span></span> // ,     ( map  ) let dateStringC = <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>.map(dateFormatter.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) ?? <span class="hljs-string"><span class="hljs-string">"Unknown date"</span></span></code> </pre> <br><p>             ,   .  ,         <code>.some</code> -   ,   <code>map</code>  <code>flatmap</code> : </p><br><pre> <code class="hljs haskell">//  <span class="hljs-type"><span class="hljs-type">Optional</span></span> <span class="hljs-type"><span class="hljs-type">Binding</span></span>        func prepareForSegue(segue: <span class="hljs-type"><span class="hljs-type">UIStoryboardSegue</span></span>, sender: <span class="hljs-type"><span class="hljs-type">AnyObject</span></span>?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = tableView.indexPathForCell(cell) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = items[indexPath.row] } } //    <span class="hljs-number"><span class="hljs-number">3</span></span> : // <span class="hljs-number"><span class="hljs-number">1</span></span>)     ; // <span class="hljs-number"><span class="hljs-number">2</span></span>)      flatMap  ; // <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-type"><span class="hljs-type">Optional</span></span> <span class="hljs-type"><span class="hljs-type">Binding</span></span>   flatMap. func prepareForSegue(segue: <span class="hljs-type"><span class="hljs-type">UIStoryboardSegue</span></span>, sender: <span class="hljs-type"><span class="hljs-type">AnyObject</span></span>?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = (sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span>).flatMap(tableView.indexPathForCell) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = items[indexPath.row] } }</code> </pre> <br><h4 id="opcionaly-i-obrabotka-isklyucheniy"> <strong>   </strong> </h4><br><p> Swift     ,     ‚Äî     <code>nil</code> .         <code>try?</code> (  <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html"></a> ): </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someThrowingFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } //  let y: Int? do { y = try someThrowingFunction() } catch { y = nil } //  let x = try? someThrowingFunction()</span></span></code> </pre> <br><p>   <code>x</code>  <code>y</code>  ,   ,    <code>someThrowingFunction()</code> .  ,    <code>try?</code>  ,     <code>as?</code>  .     <code>try!</code> ,        .      ,    : </p><br><pre> <code class="hljs erlang">//  ,  loadImage    // photo    (   x  y) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> photo = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! loadImage(atPath: <span class="hljs-string"><span class="hljs-string">"./Resources/John Appleseed.jpg"</span></span>)</code> </pre> <br><h4 id="opcionaly-i-objective-c"> <strong>  Objective-C</strong> </h4><br><p>  Objective-C   .  <code>nil</code>  Objective-C   , ..          <code>nil</code> .  Swift <code>nil</code>     <code>.none</code> ,      <code>nil</code> ,   Xcode 6.3    Objective-C   Swift    .  Xcode 6.3  Objective-C          <em>nullability annotations</em> : </p><br><pre> <code class="hljs css">@<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> myObject : NSObject @property (copy, readonly) NSArray * _Nullable myValuesA; @<span class="hljs-keyword"><span class="hljs-keyword">property</span></span> (copy, readonly) NSString * _Nonnull myStringA; @<span class="hljs-keyword"><span class="hljs-keyword">property</span></span> (copy, readonly, nullable) NSArray * myValuesB; @<span class="hljs-keyword"><span class="hljs-keyword">property</span></span> (copy, readonly, nonnull) NSString * myStringB; @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>    <code>nullable</code> ( <code>_Nullable</code> ), <code>nonnull</code> ( <code>_Nonnull</code> ),   <code>null_unspecified</code>  <code>null_resettable</code> . <em>Nullability</em> -a       ,       .        <code>NS_ASSUME_NONNULL_BEGIN</code>  <code>NS_ASSUME_NONNULL_END</code>     .         ,        Objective-C (    , ,    <code>nil</code>    <em>nonnull</em> ). </p><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The annotation </font></font><code>null_resettable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implies that the property setter may take </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but the property getter instead </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns some </font></font><a href="https://developer.apple.com/library/content/documentation/Xcode/Conceptual/RN-Xcode-Archive/Chapters/xc6_release_notes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">default value</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><br><p>   Objective-C  Swift    : </p><br><ul><li>     <code>NS_ASSUME_NONNULL_BEGIN</code>  <code>NS_ASSUME_NONNULL_END</code>     () ; </li><li>    <code>nonnull</code>  <code>_Nonnull</code>     () ; </li><li>    <code>nullable</code>  <code>_Nullable</code>    ; </li><li>    <code>null_resettable</code> <a href="https://developer.apple.com/videos/play/wwdc2015/202/%3Ftime%3D219">  </a>   ; </li><li>   <em>nullability</em> -a   <code>null_unspecified</code> (  )      . </li></ul><br><p>     Swift  Objective-C  : </p><br><ul><li>     <code>.none</code> ,    <em>NSNull</em> ; </li><li>     <code>.some</code> ,     <code>.some</code> -. </li></ul><br><h4 id="rezyume-sintaksis"> <strong>, </strong> </h4><br><p>  <code>!</code>      ,   : </p><br><ul><li>      ; </li><li>    ; </li><li>       <code>as!</code>  ; </li><li>       <code>try!</code>  . </li></ul><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The unary operator of logical negation is </font></font><code>!</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not considered, since it refers to another context.</font></font></p></div></div><br><p>  <code>?</code>      ,   : </p><br><ul><li>    ; </li><li>     <em>optional chaining</em> ; </li><li>       <code>as?</code>  ; </li><li>     <code>nil</code>   <code>try?</code>  . </li></ul><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ternary conditional operator is </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not considered because it belongs to a different context.</font></font></p></div></div><br><p>  <code>??</code>      : </p><br><ul><li>  <em>Optional haining</em>       ; </li><li>    <em>Nil-Coalescing</em> . </li></ul><br><h4 id="zaklyuchenie">  <strong>Conclusion</strong> </h4><br><p>   ‚Äî  <a href="https://en.wikipedia.org/wiki/Tony_Hoare">   </a> .              ,   .  ,   <em>null</em>  ,           . </p><br><p>       ,      .  ++  Java        "",   . ""      , ,   ""  .  , ..   ,    <em>Cogito, ergo sum</em> (. ‚Äî ",  ").         ,           .  Swift     . </p><br><h3 id="dopolnitelnye-materialy">  Additional materials </h3><br><ul><li> <a href="https://developer.apple.com/documentation/swift/optional">Generic Enumeration: Optional (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/documentation/swift/optional/1641793-unsafelyunwrapped">Instance Property: unsafelyUnwrapped (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html">Swift Language Guide: Optionals (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">Unowned References and Implicitly Unwrapped Optional Properties (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html">Nil-Coalescing Operator (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html">Optional Chaining (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">Optional Protocol Requirements (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/swift/blog/%3Fid%3D23">The as! Operator (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">Converting Errors to Optional Values (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/swift/blog/%3Fid%3D25">Nullability and Objective-C (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html">Nullability and Optionals (developer.apple.com)</a> </li><li> <a href="https://developer.apple.com/library/content/documentation/Xcode/Conceptual/RN-Xcode-Archive/Chapters/xc6_release_notes.html">Xcode 6.3 Release Notes: Objective-C Language Enhancements (developer.apple.com)</a> </li><li> <a href="https://en.wikipedia.org/wiki/Option_type">Option type (en.wikipedia.org)</a> </li><li> <a href="https://en.wikipedia.org/wiki/Nullable_type">Nullable type (en.wikipedia.org)</a> </li><li> <a href="http://jamesonquave.com/blog/re-implementing-optionals-using-swifts-powerful-enum-type/">Re-implementing Optionals using Swift's powerful enum type (jamesonquave.com)</a> </li></ul><br><p> UPD: (by Alexander Zimin)  <code>init(nilLiteral: ())</code>      : </p><br><pre> <code class="hljs lisp">var test = Optional&lt;Int&gt;(<span class="hljs-name"><span class="hljs-name">nilLiteral</span></span>: ())</code> </pre> <br><p>   ,    Apple    . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338766/">https://habr.com/ru/post/338766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338752/index.html">The saga of the Gulf Stream and the level of information security in a large security company</a></li>
<li><a href="../338758/index.html">How Alexey Moiseenkov reached Prisma and went further</a></li>
<li><a href="../338760/index.html">The process of release of iOS-applications in Badoo</a></li>
<li><a href="../338762/index.html">Data geometry 3. Scalar product of pairs</a></li>
<li><a href="../338764/index.html">Making MitM using openssl on Android</a></li>
<li><a href="../338770/index.html">Stream API & ForkJoinPool</a></li>
<li><a href="../338772/index.html">Mobile applications: what is the 2017 holiday season and how to make the most of it?</a></li>
<li><a href="../338776/index.html">How I participated in a Xiaomi bug bounty and what was it for me</a></li>
<li><a href="../338778/index.html">Text Ergonomics: A user of social networks sees about 54,000 words per day</a></li>
<li><a href="../338780/index.html">[Translation] Around the circle: optical effects when designing interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>