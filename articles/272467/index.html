<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of key performance indicators - Part 2, analysis of user, business and application metrics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to publish a translation of testing and performance analysis from the Patterns & Practices team on what key performance indicators are nee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of key performance indicators - Part 2, analysis of user, business and application metrics</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <em>We continue to publish a translation of testing and performance analysis from the Patterns &amp; Practices team on what key performance indicators are needed with.</em>  <em>For the translation, thanks to Igor Shcheglovitov from Kaspersky Lab.</em>  <em>The rest of our articles on testing can be found on the tag <a href="http://habrahabr.ru/search/%3Fq%3D%255Bmstesting%255D%26target_type%3Dposts">mstesting</a></em> </blockquote><br>  In the <a href="http://habrahabr.ru/company/microsoft/blog/271547/">first article of the</a> cycle on the analysis of key performance indicators, we set the context, now turn to specific things.  In this part - about the analysis of user, business and inside application metrics. <br><br>  User metrics provide insight into how users use the system.  Performance at this level is determined by how the user interface handles requests and works with client resources.  Most modern user interfaces are browsers and devices.  In this case, the main metrics will be page load time, JavaScript code, type of browser or device, geographical location. <br><br>  So, <br><h3>  How to collect custom metrics? .. </h3><a name="habracut"></a><br>  Most modern browsers allow you to collect performance data that includes network traffic and client code profiling.  This information may be useful in terms of development and testing, but in production it is not practical to collect data like this.  Another solution is to include on the client side an additional JavaScript code that would record and transmit information about the execution time of a particular site to a certain place.  Such code can intercept the page loading time, session data (the execution time of some script, which may include opening multiple pages or performing several operations), JavaScript or errors on the client side, the execution time of AJAX requests.  JavaScript code sends this data to a service that collects this information, and also allows you to subsequently investigate it.  <a href="http://yahoo.github.io/boomerang/doc/">Boomerang</a> is an open source solution that implements this approach. <br>  <a href="http://azure.microsoft.com/documentation/articles/app-insights-get-started/">Microsoft AppInsights</a> works similarly - you can explicitly embed AppInsight API function calls into your code.  Using features such as <a href="">TrackPageView</a> and <a href="">TrackEvent</a> , you can measure the performance of browser sessions and examine the information collected in near-real-time on the Azure portal.  The example in the figure below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/02e/ef7/90a/02eef790ae6c410c9bbdb238b539ed5b.png"><br><br>  Many application performance monitoring (APM) utilities support client-server browser tracing.  These utilities, like Boomerang, insert JavaScript elements into a web page, collecting and displaying information.  The figure shows the information collected when browsing the browser pages with the popular <a href="http://azure.microsoft.com/en-gb/documentation/articles/store-new-relic-cloud-services-dotnet-application-performance-management/">New Relic</a> APM tool. <br><br>  <b>Note: The</b> embedded code may not work if the user browser is behind a firewall or proxy that does not have access to CDN New Relic or access to the public network is blocked. <br><br><img src="https://habrastorage.org/files/9fd/8a8/ecb/9fd8a8ecb8d34b878a659fac3b7fce8a.png"><br>  Performance Monitoring in New Relic <br><br><h3>  What to pay attention to? </h3><br>  The following is general information about client-side code instrumentation. <br><br>  <b>Page views, page load time and time spent on page</b> <br><br>  These custom performance metrics are key.  If, for example, the load time of some popular pages is large, then users may start complaining and stop going there.  From the point of view of the system, this data represents end-to-end telemetry for measuring throughput (from the beginning of a request to its full implementation). <br><br>  <b>Session tracing</b> <br><br>  Session tracing can be used to track the duration of operations and resource consumption in sessions.  It is necessary to control all downloadable content, every AJAX request, all user interaction (mouse clicks and scrolling), all JavaScript events, all exceptions. <br><br>  <b>Client-side ecosystem</b> <br><br>  Client code can be run on various devices and operating systems, including various versions of Windows, Android and iOS, as well as various types of browsers.  To collect telemetry of client code performance in various environments is important, since it allows you to reveal various facts, such as in which browser the code runs faster. <br><br>  Below is an example of data collected using New Relic.  On the graph you can see the bandwidth, measured in pages per minute (ppm), and other metrics such as page load time. <br><br><img src="https://habrastorage.org/files/9d4/da4/0c7/9d4da40c79524f7c94d6aa70d655f766.png"><br>  Analysis of browsing by browser in New Relic <br><br>  Please note that New Relic builds a report for various browsers.  There may be a correlation between the type of device and the operating system - most likely Apple devices will work on iOS and use the Safari browser, Android devices will use Chrome, and Windows devices will use Internet Explorer.  There may be exceptions: other types of devices, browsers and operating systems, in which case you will need to use code that will save data about the device, operating system and browser.  Below is an example of using Application Insights to collect client OS information. <br><br><img src="https://habrastorage.org/files/3e4/e9b/00d/3e4e9b00dede473ca080efc076f3143d.png"><br>  Session analysis by operating system compiled using Application Insights <br><br>  <b>Javascript and html rendering errors.</b> <br><br>  JavaScript and HTML code in web applications may not use all supported functions.  It is important to find them and determine how to correct the situation - this can be done using APM utilities, many of which are capable of catching rendering errors and JavaScript. <br><br>  <b>Geographical location of clients</b> <br><br>  The geographical location of clients is usually associated with page load time, as well as with delays that occur when using the application.  Many customers will come from places other than the location of your application.  Data on the location of clients can be extracted from resources that take a considerable amount of time to load.  This information may be useful when designing applications that should provide minimal delays (even depending on the region).  The figure shows a graph of average page load time depending on the state in the United States. <br><br><img src="https://habrastorage.org/files/661/e03/9da/661e039da840470d86b428b6d9a0f10c.png"><br>  Average web application page load time depending on the location of the client in a particular US state <br><br>  <b>Session ID and User ID requests</b> <br><br>  In some situations, it may be useful to trace user activity or specific sessions.  Most APMs cannot conduct such a trace by default, but allow you to add custom user metrics (explicit insertion of trace calls into client code) to monitor user activity (ignoring confidentiality considerations). <br><br><h3>  Business metrics </h3><br>  Business metrics are aimed at measuring the volume and frequency of business transactions and transactions.  These metrics can help you determine if your application meets the required business expectations ‚Äî for example, for an application that processes large amounts of video (a video server), you may need to measure the number of video files downloaded over a period of time, the speed of searching for the desired video, as well as how often they watch this or that video. <br>  This process usually assesses the business impact on the system as a whole, by examining and aggregating business telemetry data, which is collected in real time with a comparison of historical data.  By collecting these long-term analytical data, the business analyst may be interested in such pressing issues as determining why business operations fail to intersect with performance problems. <br><br>  <b>How to collect them</b> <br><br>  There are many APM tools designed specifically to collect such information.  For example, New Relic uses the .NET Profiling API ‚Äî monitoring agents are registered as CLR profilers when the application is started. <br><br>  This process does not require changing the application code.  New Relic agents intercept CLR calls and save them to the repository.  = New Relic = can represent intercepted telemetry as a stream of activities in the context of time.  If you need to intercept additional information, New Relic has an API, using which, you can include collecting custom metrics. <br><br>  Using this approach, New Relic can collect data about individual business transactions that customers call.  You can put this information together in order to display throughput (in requests per minute) and average response time (in milliseconds), as shown in the figure. <br><br><img src="https://habrastorage.org/files/f89/239/d8a/f89239d8a47f46a6845d1ebaf4d051fa.png"><br>  Average time of operations in New Relic <br><br>  Application Insights has similar features that allow you to record performance and throughput for each operation in a web application. <br><br><img src="https://habrastorage.org/files/efa/d80/ee0/efad80ee0fca4234a2b3cd1f01d5f366.png"><br>  Average operations time in Application Insights <br><br>  Analysis of business metrics to determine long-term trends requires access to historical telemetry.  Many APM tools have the ability to store data for a certain period (for example, over the past 30 days), but analyzing the data may require collecting, logging, and downloading performance data to local tools like Excel.  This data can come from various sources (event logs, performance counters, application and server traces).  You must configure your applications to save key performance metrics that analysis may require. <br><br><h3>  What to pay attention to? </h3><br>  Consider choosing business metrics for monitoring. <br><br>  <b>Business Transactions Breaking Service Level Objectives (SLO)</b> <br><br>  If any of the business transactions are violated by SLO, an appropriate warning should occur.  SLO is part of a Service Level Agreement (SLA), and this document describes the acceptable level of business operations for your organization.  The SLO must be defined in terms of measurable aspects of the system, such as the percentage of operation response time (for example, 99% of all requests for operation X must be performed in time Y in ms or less).  You should be aware if your system does not perform SLO.  Application Insights allows you to define rules that can send corresponding notifications to operators in case performance metrics exceed the thresholds specified in these rules.  The example in the figure shows the rule setting - sending an e-mail message if the response time of any web page exceeds 1 second. <br><br><img src="https://habrastorage.org/files/4f0/1d9/ca5/4f01d9ca5ae74b588f2f3bc9be581c85.png"><br>  Creating a notification in Application Insights <br><br>  The figure below shows the notification from Application Insights. <br><br><img src="https://habrastorage.org/files/40f/b3c/a1a/40fb3ca1a5e34e0cb2d46dc1cab6469c.png"><br>  Application Insights Notice <br><br>  The operator can use emails to view current system status.  New Relic also allows you to set policies that can trigger a notification when the System Performance Index (Application Performance Index or Apdex) for business transactions shows poor performance. <br><br>  <b>Note:</b> Apdex is the industry standard for units of measure whereby 1 shows excellent performance, and 0 means problems.  More information about this can be found on the website <a href="http://apdex.org/">APDEX.org</a> <br><br>  The figure below shows the default policy for transactions in New Relic.  A warning is generated when the average Apdex value in the interval for 10 minutes falls below the value of 0.85 or below 0.7 in 5 minutes.  A warning is also generated if the error rate exceeds 1% in 10 minutes or 5% in 3 minutes.  New Relic will also create a corresponding warning if the web application is unavailable for 1 minute (the test is performed using ping on the preconfigured endpoint of the application). <br><br><img src="https://habrastorage.org/files/f04/a94/d8b/f04a94d8b9a64b4ebc4f44dbd54033db.png"><br>  Configuring Notifications in New Relic <br><br>  <b>Falling business transactions</b> <br><br>  All business transactions must be monitored for failures.  SLO warnings can indicate recurring problems for a specific period, but they are also important for determining the causes of individual failures.  Information about exceptions can be obtained in various ways: the application can write them to the windows event log or use APM custom logging (which was described earlier).  The following figure shows how this information displays New Relic. <br><br><img src="https://habrastorage.org/files/6d4/a02/6b6/6d4a026b6a1c48e18d601b4e77b99957.png"><br>  Exceptions in New Relic <br><br>  You can get similar information using Application Insights, as well as determine, through it, the causes of individual exceptions. <br><br><img src="https://habrastorage.org/files/d97/434/5f2/d974345f25a04e97b55f585562c2b892.png"><br>  Failed requests for Application Insights <br><br>  <b>Patterns of bandwidth and response time of business transactions</b> <b><br></b> <br>  All business transactions should be monitored for bandwidth and runtime, which will allow for a dynamic analysis of historical slices.  This requires that APM has access to historical data. Many APMs can create reports that allow you to analyze historical performance data of individual operations.  The report below was generated using New Relic, it shows how the current performance of various web transactions correlates with the data obtained from yesterday. <br><br><img src="https://habrastorage.org/files/fff/d6b/d75/fffd6bd7555c44f7b83cc80a5bd32e67.png"><br>  Patterns in New Relic <br><br>  You can customize and modify these reports.  One of the features of New Relic is the ability to compare the performance of the current day to that of the same day last week.  If the business is cyclical in nature (on some days a large load is expected than on others), then this form of analysis may be useful. <br><br>  If you have access to historical performance data, then you can download and analyze it.  For example, you can load them into Excel and build reports on the performance of your system depending on the time of day, day of the week, a specific operation, or depending on the user. <br><br><h3>  <b>Application Metrics</b> </h3><br><br>  Application metrics imply a low-level view of how well the system works under load (what exactly happens under the application ‚Äúhood‚Äù).  Obtaining this information requires tracking application logs, database connections, and how the application uses external services (cache, ServiceBus, authorization / authentication, etc.).  Framework metrics are also important - ASP.NET and CLR counters (for applications built on .NET), information about exceptions, blocking resources, and using threads. <br><br>  <b>How to collect them</b> <br><br>  Many of these metrics can be obtained very simply using system performance counters or other services provided by the operating system.  As described earlier, many APM tools also allow you to embed (without manually changing the code) various diagnostic modules in your system that can capture information generated by the application (database calls, third-party services, etc.). <br>  If necessary, you can also embed custom functions in the code of your application to highlight external API calls and other significant actions (such code changes should be minimized, as this affects the overall performance).  This can be done using logging (connecting the logger interface) or an advanced API that the APM you use provides. <br><br>  <b>Note:</b> This approach binds your application to a specific API, which requires manual insertion into the code of certain diagnostic calls that are waiting for data in a specific APM-specific format. <br><br>  <b>Causes of high latency and low bandwidth</b> <br><br>  The operations performed by the application include not only interactive requests from users, but also batch processing and periodically running background jobs.  Monitoring the business layer can give you information about how much SLO is being performed.  Application metrics provide insights into why this is not happening ‚Äî they may contain information about various aspects of queries and how they are performed within the system. <br><br>  The figure below shows the main screen of New Relic, which shows the performance of the working system.  The operator allocated a point in time when the system performed heavy database operations (MsSQL DBMS).  The figure shows that the application performs them poorly (Apdex at the level of 0.53, which indicates some problems).  At this time, the throughput was 710 requests per minute.  The operation of the application is characterized by two operations (web transactions), one of which - the transaction at ChattyProduct, apparently, constitutes a large part of the server time. <br><br><img src="https://habrastorage.org/files/078/9fa/b73/0789fab731e44e3db12f7037d36b911c.png"><br>  The Overview screen in New Relic, showing bandwidth and latency in a web application in a short amount of time. <br><br>  For ChattyIO queries, you need to understand which resources are being used inefficiently.  Telemetry will provide an opportunity to detail the request to determine what it actually does.  In New Relic for this purpose it is proposed to do transaction tracing as shown in the figure. <br><br><img src="https://habrastorage.org/files/fac/b67/556/facb6755670f41899f5329147920fad4.png"><br>  Obviously, the operation uses significant database resources, opening 45 connections.  One specific request is executed 43 times.  This DB activity may explain why an operation takes time to complete. <br><br>  A deeper look at the trace details shows how the operation works with the connections ‚Äî it creates them for each query, rather than re-using existing ones. <br><img src="https://habrastorage.org/files/267/d61/e4b/267d61e4ba28419b954b615d8829b1cf.png"><br><br>  This operation should be analyzed in order to optimize the number of connections and queries to the database. <br><br>  <b>Exceptions</b> <br><br>  Exceptions are often the cause of user frustration.  They may indicate an error in the code, but they may also result from excessive consumption or unavailability of resources.  To avoid loss of business and financial problems, it is necessary to identify the causes of exceptions promptly. <br>  On the Overview screen in New Relic (see below), it is clear that something led to a large number of exceptions.  This caused a significant drop in performance (Apdex dropped to 0).  At this point, there is also a significant jump in throughput, which is probably due to errors leading to rapid disruptions in operations. <br><br><img src="https://habrastorage.org/files/5eb/5db/676/5eb5db676132493591c3f1bd0f2512c4.png"><br><br>  The study of errors on the Errors screen in New Relic provides additional information, including the details of the exception and the operation that was performed at this point.  Please note that New Relic allows you to switch to internal exceptions to get a full stack. <br><br><img src="https://habrastorage.org/files/3e4/e6b/b15/3e4e6bb15beb45f7b4f5ea5c2e207127.png"><br><br>  This information gives you the understanding that the problem lies in the database - sometimes the connection falls off.  This may be due to the previous scenario - opening a large number of connections, which can exhaust the resources available for the connection and lead to the fact that when executing new queries it is not possible to create new connections to the database, or it may be a problem with the database itself, which requires checking server. <br><br>  <b>Framework Performance</b> <br><br>  The code of your application in runtime can use technologies such as the .NET Framework, ASP.NET or other frameworks.  It is important to understand that they have an impact on the performance of your system.  In many cases, they provide their own metrics that allow you to look inside the processes occurring in the application, which helps you use these mechanisms more efficiently and optimize the code.  For example, .NET performance counters include metrics showing how part starts the garbage collection process, and how many objects are on the heap.  You can use this information to identify memory waste and associated resources in the code of your application (for example, creating unreasonably large arrays, constantly creating and destroying large strings, or errors in incorrect destruction of resources). <br><br>  Web applications depend on the web server, which accepts requests from the client and redirects them to the processing code.  Business workloads for cloud applications can be very asymmetric, with unpredictable high activity surges that are followed by rest periods.  A typical web server is able to process only a certain maximum number of concurrent requests, so other requests can be queued.  If the request is not processed within a certain period of time, a timeout error may be returned to the client.  On some systems, if the number of requests in the queue exceeds a predetermined threshold value, subsequent requests will immediately be dropped with an error message that will be returned to the client.  This is a built-in security mechanism to prevent unplanned spike in client requests.  This strategy also prevents the client from being ‚Äúblocked‚Äù when the request is likely to return with a timeout error.  However, if this happens frequently, then it may be necessary to distribute the load across multiple web servers or to research the application for problems or optimization.  Therefore, it is very important to control the speed of processing requests, as well as the number of requests waiting in the queue.  For example, for ASP.NET applications you can use the following performance counters: <br><br><ul><li>  ASP.NET \ Requests Queued, the number of requests waiting in the queue for processing </li><li>  ASP.NET \ Requests Current, the total number of requests currently running.  The value of this counter includes the number of requests processed in the queue and waiting to be sent to the client.  If this value exceeds the requestQueueLimit parameter, which is located in the processModelsection section of the web server configuration file, subsequent requests will be discarded. </li><li>  ASP.NET Application \ Requests Executing, shows the number of simultaneously running requests. </li><li>  ASP.NET Application \ Requests / sec, current application bandwidth </li><li>  ASP.NET Application \ Request Execution Time, execution time (in ms) after the request </li><li>  ASP.NET Application \ Wait Time; timeout in queue of the last request. </li></ul><br><br>  <b>Note:</b> By default, the IIS, ASP.NET and .NET Framework configuration is optimized based on the number of CPU cores.  But for applications that frequently perform I / O operations (for example, web services using external resources), some changes to this configuration can significantly improve performance. <br><br>  Let's continue to look at examples with a web server.  You should always investigate the reasons for the long queue length.  A large number of pending requests in conjunction with a low CPU, network utilization, or memory may indicate problems with the backend.  For example, if the cloud service for data storage uses a SQL database, and the latter contains some processing logic (stored procedures, triggers), then the database itself may be a bottleneck, which will lead to the accumulation of requests in the queue.  If the performance monitoring of the backend services shows that they are working normally, but the queue length of your application will be preserved, then the lack of threads caused by the blocking of synchronous operations may be the cause of the web server problems. <br><br>  Below is an example of a diagram (created by New Relic), in which a simple application has a waiting time in the request queue due to synchronous I / O operations.  Due to the lack of available threads, IIS becomes unable to execute requests in a timely manner and the time spent in the queue gradually increases.  Note that the CPU time and network utilization (shown in the second graph) is very low. <br><br><img src="https://habrastorage.org/files/cff/545/29a/cff54529a884465bbdff28f0eba84944.png"><br><br><img src="https://habrastorage.org/files/869/74b/45c/86974b45c01d4c229fb478cb98c181d9.png"><br><br>  As the queue length increases, response time increases and the number of failed requests increases.  The graph below shows the load test results of a simple application.  As the load increases (the number of simultaneous users), the latency (operation time) and throughput (number of operations per second) increase.  Notice that the left axis represents the user load, and the logarithmic right axis measures latency and throughput.  When the user load exceeds the 6000 figure, requests begin to generate exceptions (either timeouts or failures due to excessive queue length).  These exceptions lead to a decrease in latency and an increase in throughput due to the fact that the exception is generated faster than successful requests are executed. <br><br><img src="https://habrastorage.org/files/c90/f1f/35d/c90f1f35dd1f4769b6e5ea7df2db253c.png"><br><br>  Along with the increase in the user base, the overall load on the system will also increase.  You must make sure that the system does not reach the point where it may suddenly collapse under load.  To do this, it is necessary to control the use of shared resources by the system (CPU, memory, network bandwidth, etc.) and the graphs of the dependence of this information on bandwidth and latency and / or delay.  This form of measurement often requires you to monitor the infrastructure metrics and telemetry of other services on which your application depends.  As an example, the following figure shows the New Relic telemetry from the application described earlier - we see data on memory usage and CPU usage for the application.  Utilization (loading) of a processor is a relatively constant value within certain bounds (if there are several processors in the system, its utilization may exceed 100%), despite the bandwidth differences.  You need to check if the system will start generating exceptions at this point.  If so, this may indicate insufficient capacity to increase the load.  Memory utilization is also fairly stable, although it can grow slowly with the load.  But if it starts to grow without any reason, then this may indicate a memory leak. <br><br><img src="https://habrastorage.org/files/c81/ae8/ea1/c81ae8ea10d24f67be8f8f358b29e49e.png"><br>  <b>Server Resources at New Relic</b> <br><br>  Thank you all for your attention!  In the next, and final part - about system metrics and other points of interest for analysis. <br><br>  Parts of the article: <br>  <a href="http://habrahabr.ru/company/microsoft/blog/271547/">Key Performance Indicator Analysis - Part 1</a> <br>  <a href="http://habrahabr.ru/company/microsoft/blog/272467/">Analysis of key performance indicators - Part 2, analysis of user, business and application metrics</a> <br>  <a href="http://habrahabr.ru/company/microsoft/blog/272567/">Analysis of key performance indicators - part 3, the last, about system and service metrics.</a> </div><p>Source: <a href="https://habr.com/ru/post/272467/">https://habr.com/ru/post/272467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272451/index.html">Creators of ransomware and fraudulent tech support sites are combined</a></li>
<li><a href="../272455/index.html">Presentation of the program settings in 1C. One of the methods</a></li>
<li><a href="../272457/index.html">Announced the start of acceptance of works at the symposium CTCrypt'2016</a></li>
<li><a href="../272459/index.html">Intro to rxjava</a></li>
<li><a href="../272461/index.html">How to split VPN traffic in MacOS</a></li>
<li><a href="../272469/index.html">Translation: Instructions for conducting code review</a></li>
<li><a href="../272471/index.html">How to scale Ruby applications</a></li>
<li><a href="../272473/index.html">About system thinking</a></li>
<li><a href="../272475/index.html">Simple Computer Classroom Management System</a></li>
<li><a href="../272477/index.html">The digest of interesting materials for the mobile developer # 132 (November 30 - December 6)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>