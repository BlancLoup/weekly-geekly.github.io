<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding a Cartesian product using LINQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Question: how to find the Cartesian product of an arbitrary number of sequences using LINQ? 

 For a start, let's make sure we know what this is about...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding a Cartesian product using LINQ</h1><div class="post__text post__text-html js-mediator-article"> Question: <strong>how to find the Cartesian product of <i>an arbitrary</i> number of sequences using LINQ?</strong> <br><br>  For a start, let's make sure we know what this is about.  I will denote sequences as ordered sets: <code>{a, b, c, d...}</code> Cartesian product of two sequences S1 and S2 is a sequence of all possible ordered pairs such that their first element is from S1 and the second is from S2.  So, for example, if you have two sequences <code>{a, b}</code> and <code>{x, y, z}</code> , then their Cartesian product looks like <code>{{a, x}, {a, y}, {a, z}, {b, x}, {b, y}, {b, z}}</code> . <br><br>  For simplicity, suppose that S1 and S2 consist of elements of the same type.  Of course, we can define the Cartesian product of a sequence of lines with a sequence of numbers as a sequence of tuples (string, int), but later it will be difficult to generalize because the C # type system, in particular, does not work in the best way with tuples of arbitrary length. <br><a name="habracut"></a><br>  LINQ has an operator specifically for calculating Cartesian products: in the ‚Äúmethod syntax‚Äù it is <code>SelectMany</code> , in the ‚Äúquery syntax‚Äù it is a query with two ‚Äúfrom‚Äù expressions: <blockquote> <code>var s1 <font color="#008000">=</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> a, b <font color="#000000">}</font> <font color="#008000">;</font> &lt;br/&gt; <br> var s2 <font color="#008000">=</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> x, y, z <font color="#000000">}</font> <font color="#008000">;</font> &lt;br/&gt; <br> var product <font color="#008000">=</font> &lt;br/&gt; <br> from first <font color="#0600FF">in</font> s1 &lt;br/&gt; <br> from second <font color="#0600FF">in</font> s2 &lt;br/&gt; <br> select <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> first, second <font color="#000000">}</font> <font color="#008000">;</font></code> </blockquote> <br>  Of course, we can generalize the Cartesian product to more than two sequences.  The Cartesian product of n sequences <code>{S1, S2, ... , Sn}</code> is the sequence of all possible n-element sequences that have the first element of S1, the second of S2, and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This definition lacks a trivial case: what is the Cartesian product of zero sequences?  Let it then consist of a sequence containing a single element: an empty sequence, that is, <code>{ { } }</code> . <br><br>  Note that this gives a logical definition of the Cartesian product of one sequence.  The Cartesian product of a sequence containing a single sequence (say, <code>{{a, b}}</code> ) is the sequence of all possible single-element sequences, where the first (and only) element of <code>{a, b}</code> .  Thus, the Cartesian product <code>{{a, b}}</code> is <code>{{a}, {b}}</code> . <br><br>  With LINQ, you can create a Cartesian product of any number of sequences simply <i>if you know how much you will work with</i> : <blockquote> <code>var product <font color="#008000">=</font> &lt;br/&gt; <br> from first <font color="#0600FF">in</font> s1 &lt;br/&gt; <br> from second <font color="#0600FF">in</font> s2 &lt;br/&gt; <br> from third <font color="#0600FF">in</font> s3 &lt;br/&gt; <br> select <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> first, second, third <font color="#000000">}</font> <font color="#008000">;</font></code> </blockquote> <br>  But what if you do not know at the stage of writing the code, how many sequences will you have?  That is, how to write the function body: <blockquote> <code><font color="#0600FF">public</font> <font color="#0600FF">static</font> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> CartesianProduct <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> <font color="#000000">(</font> <font color="#0600FF">this</font> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> sequences <font color="#000000">)</font></code> </blockquote> <br>  Well, there is a reason to use induction;  this idea almost never fails when working with recursively defined data structures. <br><br>  If <code>sequences</code> contains zero sequences, the job is done: we simply return <code>{ { } }</code> . <br><br>  How to find the Cartesian product of two sequences, say again <code>{a, b}</code> and <code>{x, y, z}</code> ?  We start by counting the Cartesian product of the first sequence.  Let the inductive hypothesis be that we somehow did it, so we know the answer: <code>{{a}, {b}}</code> .  How to connect <code>{{a}, {b}}</code> with <code>{x, y, z}</code> to get the total product? <br><br>  Let us go back in search of inspiration to the original definition of the Cartesian product of two sequences.  Cartesian product <code>{{a}, {b}}</code> and <code>{x, y, z}</code> are random <code>{{{a}, x}, {{a}, y}, {{a}, z}, {{b}, x}, {{b}, y}, {{b},z}}</code> , which is nonetheless seductively close to what we want to receive.  We don't just want to find the Cartesian product <code>{{a}, {b}}</code> and <code>{x, y, z}</code> , creating a <i>sequence</i> containing <code>{a}</code> and <code>x</code> , but no, instead we need to calculate the Cartesian product by <i>appending</i> <code>x</code> to <code>{a}</code> to get <code>{a, x}</code> !  In other words, by <i>concatenating</i> <code>{a}</code> and <code>{x}</code> . <br><br>  In terms of code: let us have an old Cartesian product, say <code>{{a}, {b}}</code> .  We want to connect it with the sequence <code>{x, y, z}</code> : <blockquote> <code>var newProduct <font color="#008000">=</font> &lt;br/&gt; <br> from old <font color="#0600FF">in</font> oldProduct &lt;br/&gt; <br> from item <font color="#0600FF">in</font> sequence &lt;br/&gt; <br> select old. <font color="#0000FF">Concat</font> <font color="#000000">(</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> item <font color="#000000">}</font> <font color="#000000">}</font> <font color="#008000">;</font></code> </blockquote> <br>  And now we have a safe induction transition.  If <code>oldProduct</code> is <i>any</i> Cartesian product, then we can calculate its combination with another sequence to get a new Cartesian product. <br><br>  For every fireman: does this method work with induction backing?  Yes.  If we want to combine the Cartesian product <code>{ { } }</code> with the sequence <code>{{a}, {b}}</code> , we merge <code>{ }</code> with <code>{a}</code> and <code>{ }</code> with <code>{b}</code> to get <code>{{a}, {b}}</code> . <br><br>  Let's put it all together: <blockquote> <code><font color="#0600FF">static</font> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> CartesianProduct <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> <font color="#000000">(</font> <font color="#0600FF">this</font> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> sequences <font color="#000000">)</font> &lt;br/&gt; <br> <font color="#000000">{</font> &lt;br/&gt; <br> <font color="#008080">//  :</font> &lt;br/&gt; <br> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> result <font color="#008000">=</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> Enumerable. <font color="#0000FF">Empty</font> <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#000000">}</font> <font color="#008000">;</font> &lt;br/&gt; <br> <font color="#0600FF">foreach</font> <font color="#000000">(</font> var sequence <font color="#0600FF">in</font> sequences <font color="#000000">)</font> &lt;br/&gt; <br> <font color="#000000">{</font> &lt;br/&gt; <br> var s <font color="#008000">=</font> sequence <font color="#008000">;</font> <font color="#008080">//     </font> &lt;br/&gt; <br> <font color="#008080">//  :  SelectMany,      </font> &lt;br/&gt; <br> result <font color="#008000">=</font> &lt;br/&gt; <br> from seq <font color="#0600FF">in</font> result &lt;br/&gt; <br> from item <font color="#0600FF">in</font> s &lt;br/&gt; <br> select seq. <font color="#0000FF">Concat</font> <font color="#000000">(</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> item <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> &lt;br/&gt; <br> <font color="#000000">}</font> &lt;br/&gt; <br> <font color="#0600FF">return</font> result <font color="#008000">;</font> &lt;br/&gt; <br> <font color="#000000">}</font></code> </blockquote> <br>  It works fine, but if you want, you can make a little more beautiful.  Essentially we use a <i>battery</i> here.  Consider an example easier, say, the summation of a list of integers.  One way to do this is to say ‚ÄúLet the battery first be zero.  A new battery is obtained from the old one by adding the current element to the old battery. ‚Äù  If we have the starting value of the battery and in some way we can get the new value from the old and from the current sequence element, then we can use the useful <code>Aggregate</code> method.  It takes the starting value of the battery and the function that takes the last value and the current item and returns the new value of the battery.  At the output of the method - the total value of the battery. <br><br>  In this case, we will start with an empty product as a battery, and each time we will ‚Äúadd‚Äù to it by combining the current sequence with the product of the previous ones.  At each step of the algorithm, the accumulator is equal to the Cartesian product of the sequences already scanned. <blockquote> <code><font color="#0600FF">static</font> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> CartesianProduct <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> <font color="#000000">(</font> <font color="#0600FF">this</font> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> sequences <font color="#000000">)</font> &lt;br/&gt; <br> <font color="#000000">{</font> &lt;br/&gt; <br> IEnumerable <font color="#008000">&lt;</font> IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;&gt;</font> emptyProduct <font color="#008000">=</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> Enumerable. <font color="#0000FF">Empty</font> <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#000000">}</font> <font color="#008000">;</font> &lt;br/&gt; <br> <font color="#0600FF">return</font> sequences. <font color="#0000FF">Aggregate</font> <font color="#000000">(</font> &lt;br/&gt; <br> emptyProduct, &lt;br/&gt; <br> <font color="#000000">(</font> accumulator, sequence <font color="#000000">)</font> <font color="#008000">=&gt;</font> &lt;br/&gt; <br> from accseq <font color="#0600FF">in</font> accumulator  &lt;br/&gt; <br> from item <font color="#0600FF">in</font> sequence  &lt;br/&gt; <br> select accseq. <font color="#0000FF">Concat</font> <font color="#000000">(</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> item <font color="#000000">}</font> <font color="#000000">)</font> <font color="#000000">)</font> <font color="#008000">;</font> &lt;br/&gt; <br> <font color="#000000">}</font></code> </blockquote> <br>  And finally, a few words for those who understand.  Remember, the <b>result of a LINQ query is a query that will provide the results on demand, not the results directly</b> .  When we build this battery, we generally do not calculate the Cartesian product.  We are building a large complex query that, <i>when launched,</i> will produce a Cartesian product.  The request is built vigorously, but will be carried out lazily. <br><br><h5>  From translator </h5><br>  Eric walked around in his post the specific name of the idiom that he used, namely <i>convolution</i> .  However, on this topic on Habrahabr there were already posts.  The interested person can find an excellent translation <a href="http://habrahabr.ru/blogs/net/57503/">‚ÄúCatamorphism in F #‚Äù</a> . <br><br>  The same problem, much less verbose, but with the same algorithm, can be solved on F #.  Instead of LINQ, list comprehensions will fit well into the code - one of the remarkable features traditionally inherent in functional languages.  To achieve greater performance, it is necessary to stick an element to the list from the head, with an operator <code>(::)</code> .  In this case, to achieve the classical form of the Cartesian product, the initial sequence must be turned over before work begins. <br><br>  In sum, the convolution, pipelines and list expressions will give such a beautiful code: <blockquote> <code><font color="#0000FF">let</font> product seqs = <br> List.rev seqs <br> |&gt; List.fold <br> ( <font color="#0000FF">fun</font> acc cur -&gt; <br> [ <font color="#0000FF">for</font> seq <font color="#0000FF">in</font> acc <font color="#0000FF">do</font> <br> <font color="#0000FF">for</font> item <font color="#0000FF">in</font> cur <font color="#0000FF">do</font> <br> <font color="#0000FF">yield</font> item::seq]) [[]]</code> </blockquote> </div><p>Source: <a href="https://habr.com/ru/post/99128/">https://habr.com/ru/post/99128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99119/index.html">Toshiba Laptop ExpertLab (familiarity)</a></li>
<li><a href="../99120/index.html">There are more ‚Äúmobile‚Äù Facebook users than Russians</a></li>
<li><a href="../99121/index.html">Sign in with multiple Google accounts at the same time ... soon</a></li>
<li><a href="../99123/index.html">BlackBerry 6 interface</a></li>
<li><a href="../99125/index.html">Google allowed to work with different accounts simultaneously</a></li>
<li><a href="../99129/index.html">Free payment - how it works</a></li>
<li><a href="../99130/index.html">China has stopped funding the Green Dam web filter</a></li>
<li><a href="../99133/index.html">Parallels - how to make money on localization</a></li>
<li><a href="../99134/index.html">Robots will prepare space for humans</a></li>
<li><a href="../99135/index.html">I got screwed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>