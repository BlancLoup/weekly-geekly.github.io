<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing a function from the standard library D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr, I want to invite everyone on a small tour of the language D. Why? Well, why do people go on excursions at all - to have fun, to see something...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing a function from the standard library D</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2ce/c1c/63c/2cec1c63c4d442efa4950c53e17a6fdd.png" align="left">  Hi Habr, I want to invite everyone on a small tour of the language D. Why?  Well, why do people go on excursions at all - to have fun, to see something new and in general it is interesting.  D can hardly be called new or at least young, but in the last couple of years there was a rapid development, <a href="http://erdani.com/">Andrei Alexandrescu</a> came into the community and quickly became a leading developer, with his ability to anticipate trends, he made a great contribution to the concepts of the language itself and especially to the standard library. <br><br>  Since its inception, D has been positioned as an improved C ++ (at least in my reading of the story).  The ability to discard some outdated constructions and introduce in their place something new that could not be implemented in classic C ++, while at the same time carefully preserving low-level features such as built-in assembler, pointers and using C libraries, make D a unique contender for the title of ‚Äúnext in C‚Äù - C ++ - ... ".  Well, from my point of view, I myself (probably it would be polite to add ‚Äúunfortunately‚Äù) is absolutely monolingual, I have been writing in C ++ for many years and any attempts to get acquainted with other languages ‚Äã‚Äãinevitably ended in a sound healthy sleep.  However, I heard from representatives of other faiths that D is also interesting for them as a language, so I invite everyone to the excursion. <br><br>  What will I show?  <a href="https://wiki.dlang.org/Books">Several very good books</a> have already been written on D, so I decided to just take the <i>getopt ()</i> function from the standard library and look at its code, an invaluable exercise that allows you to revitalize what you read in the books.  Why this particular feature?  Well, she is familiar to everyone and is systemically independent, I personally use it 3-4 times a week and can imagine in detail how it could be written in 3 different languages.  In addition, the author of the code is Alexandrescu, I have seen <i>training examples of</i> his code in books many times and have never seen the code written <i>in production</i> , it‚Äôs curious.  In the end, I certainly could not resist and wrote my bicycle (naturally improved), in this case it is absolutely appropriate and no less useful than parsing someone else's code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will see far from all of what it would be worth seeing, and I myself am far from being an expert, so read it yourself who is interested in the links at the end. <br><a name="habracut"></a><br><h3>  External examination </h3>  Something like this code illustrates how to use the function: <br><pre><code class="hljs cmake">void main(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] args) { // placeholders <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>; bool quiet; enum Count { zero, one, two, three }; Count count; int selector; int[] <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] dict; std.getopt.arraySep=<span class="hljs-string"><span class="hljs-string">","</span></span>; auto help=getopt(args, , std.getopt.config.bundling , <span class="hljs-string"><span class="hljs-string">"q|quiet"</span></span>, <span class="hljs-string"><span class="hljs-string">"opposite of verbose"</span></span>, &amp;quiet , <span class="hljs-string"><span class="hljs-string">"v|verbose"</span></span>, delegate{quiet=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;} , <span class="hljs-string"><span class="hljs-string">"o|output"</span></span>, &amp;<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> , <span class="hljs-string"><span class="hljs-string">"on"</span></span>, delegate{selector=<span class="hljs-number"><span class="hljs-number">1</span></span>;} , <span class="hljs-string"><span class="hljs-string">"off"</span></span>, delegate{selector=-<span class="hljs-number"><span class="hljs-number">1</span></span>;} , std.getopt.config.required, <span class="hljs-string"><span class="hljs-string">"c|count"</span></span>, <span class="hljs-string"><span class="hljs-string">"counter"</span></span>, &amp;count , <span class="hljs-string"><span class="hljs-string">"list"</span></span>, &amp;<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> , <span class="hljs-string"><span class="hljs-string">"map"</span></span>, &amp;dict ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(help.helpWanted) defaultGetoptPrinter(<span class="hljs-string"><span class="hljs-string">"Options:"</span></span>, help.options); }</code> </pre> <br>  The first thing we see is ‚Äúalmost C‚Äù, then we notice the presence of dynamic arrays ‚Äî string [] and int [], and associative arrays ‚Äî string [string].  Then some kind of suspicious assignment - <i>std.getopt.arraySep = ","</i> , is there really a global variable!?, Are we going to the kunstkamera or where?  All so, dynamic and associative arrays are present in the language and constitute one of its foundations (I personally immediately recall Perl, in a good sense of the word).  But <i>std.getopt.arraySep</i> is really a global variable belonging to a module and the assignment to it is probably terrible from the point of view of a purist, even in such a specific function as <i>getopt ()</i> .  However, this is not so simple, <i>arraySep</i> <b>could</b> be defined as a <b>couple of functions</b> : <br><br><pre> <code class="hljs cs">@<span class="hljs-function"><span class="hljs-function">property </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arraySep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } @<span class="hljs-function"><span class="hljs-function">property </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arraySep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> separator</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre>  and <b>look</b> like a variable, while meeting the most stringent standards for data encapsulation.  This is a kind of branded chip D - syntactic sugar brought to perfection and forming the unique look of the language.  Moreover, this call might look like <pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">","</span></span>.arraySep;</code> </pre><br>  seems like a contrived perversion?  And how about this design: <br><pre> <code class="hljs pgsql">auto helloWorld="dlrowolleh".<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>.capitalize_at(<span class="hljs-number"><span class="hljs-number">0</span></span>).capitalize_at(<span class="hljs-number"><span class="hljs-number">5</span></span>).insert_at(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>);</code> </pre><br>  This is of course a speculative example, just to show that such syntax makes sense, but this construct is used in D as widely and with the same success as a <i>pipe</i> (the | sign) in bash squeaks.  It has its beautiful name: <i>Uniform Function Call Syntax</i> , although in fact it is nothing more than syntactic sugar that allows you to call <i>fun (a, b, c)</i> as <i>a.fun (b, c)</i> . <br>  Then we see the actual function call and the incredible flexibility of the interface immediately catches the eye, an arbitrary number of configuration parameters, including an arbitrary handler and a description, are passed directly to the function.  The suspicion that D is a language with dynamic typing involuntarily creeps in.  Nothing like this, as we will see later, this is just a perfected pattern technique. <br>  In general, the description of the option is given by the following line: <br>  <b>[modifier] options options, [description,] &amp; handler</b> <br>  The most trivial part here is the option options, just a string of the form ‚Äúf | foo | x | something-else‚Äù that defines possible synonyms, both short and long.  Description (syntax help string) is also just a string, but it is no longer necessary, which already implies some work with types at the compilation stage. <br>  Real magic begins with a handler, it should be an address, but the <i>address is almost anything</i> including <i>enum</i> (in this place my internal C ++ - my nickname wrinkled my forehead), as well as the address of a function or a lambda function (well, it's simple, yes?). <br>  More details: <br><ul><li>  if the handler is set to a pointer to <i>bool</i> , the option is assumed without arguments, -f or --foo will write <i>true</i> to a variable.  However, you can do it like this: --foo true or --foo = false. </li><li>  if the handler is a pointer to a string, a numeric type or <i>enum</i> , an option is expected with an argument that is converted to the desired type and assigned to the pointer. </li><li>  another sub-option, if the handler is a pointer to the integer type, and the option ends in '+', then the handler is incremented each time the option is encountered on the command line. </li><li>  if the handler is a pointer to an array, then the option with an argument is implied, which is converted to the required type and added to the array, you can also give several values ‚Äã‚Äãseparated by commas.  After parsing the command line --foo = 1,2,3,4,5 the corresponding array will be [1,2,3,4,5]. </li><li>  similarly, you can pass a pointer to <i>an associative array</i> , then as a parameter you need to pass a list of pairs &lt;key&gt; = &lt;value&gt; that will be converted to the desired type. </li></ul><br>  The function returns a tuple of two elements ‚Äî a list of options that can be printed, and the logical variable helpWanted, = true if the -h or --help option (which is automatically added to the list) is present on the command line. <br>  Well, to complete the picture, each option may have a modifier, for example, <i>required</i> or <i>caseInsensitive</i> .  In addition, the module defines several global variables, such as optionChar = '-', endOfOptions = "-" and arraySep = ",", the assignment of which changes the syntax of the command line. <br>  As a result, we obtain a universal and convenient function, it is obvious that this is a template and it is approximately clear how to implement something similar in C ++, but how exactly is this done in D? <br><br><h3>  Open the hood </h3>  The first thing that attracts attention is an extremely simple and natural way of defining template functions, the difference in the syntax of ordinary and template functions is so subtle that it changes perception ‚Äî you write not ‚Äúordinary‚Äù and ‚Äúsample‚Äù functions, but simply functions, some of whose formal parameters can be patterned.  Looking ahead, I‚Äôll say that the <b>opts</b> arguments can be accessed as an array ‚Äî <b>opts [0], opts [$ - 1] or opts [2..5];</b> <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">GetoptResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getopt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T...</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args, T opts</span></span></span><span class="hljs-function">)</span></span> { ... getoptImpl(args, cfg, rslt, opts); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rslt; }</code> </pre><br>  There is nothing more to say about the top-level function, because it immediately transfers the control to <b>getoptImpl ()</b> to which we will now look. <br><pre> <code class="hljs cs"> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getoptImpl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T...</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configuration cfg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GetoptResult rslt, T opts</span></span></span><span class="hljs-function">) 2</span></span> { <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opts.length</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(opts[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span></span><span class="hljs-function">) : config))</span></span> { <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-comment"><span class="hljs-comment">// it's a configuration flag, act on it 8 setConfig(cfg, opts[0]); 9 return getoptImpl(args, cfg, rslt, opts[1 .. $]); 10 } else { 11 // it's an option string ... 16 static if(is(typeof(opts[1]) : string)) { 17 auto receiver=opts[2]; 18 optionHelp.help=opts[1]; 19 immutable lowSliceIdx=3; 20 } else { 21 auto receiver=opts[1]; 22 immutable lowSliceIdx=2; 23 } ... 34 bool optWasHandled=handleOption(option, receiver, args, cfg, incremental); 41 return getoptImpl(args, cfg, rslt, opts[lowSliceIdx .. $]); 42 } 43 } else { 44 // no more options to look for, potentially some arguments left ... 68 } 75 } 76 }</span></span></code> </pre><br>  As you can see by the numbers, I threw out very few lines, but the whole structure of this code is in full view. <br>  The first thing that attracts attention is the <i>static if () {} else static if () {} else {} construct</i> , yes, that's exactly what you probably thought of.  The branch of the <i>static if</i> expression is selected <i>at compile time</i> ; naturally, the condition must also be known at compile time.  Thus, this code (slightly giving away spaghetti to my picky taste) during compilation is truncated to several lines making sense for this particular set of function arguments.  As I said before, template parameters can be treated as an <i>immutable</i> array, <i>static if (opts.length)</i> returns 0 if the list of options is empty, so the code starting at line 43 replaces the template specialization for this case. <br>  Another interesting point is that braces after <i>static if () do not change the scope</i> , take a look: <br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">16</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>() { <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> lowSliceIdx=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> lowSliceIdx=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">23</span></span> } <span class="hljs-number"><span class="hljs-number">41</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getoptImpl(args, cfg, rslt, opts[lowSliceIdx .. $]);</code> </pre><br>  The variable lowSliceIdx is defined in one of the blocks, but it is used outside of them, very logical in my opinion.  Since this variable is defined as <i>immutable (= constexpr)</i> , it is also available at compile time and can be used in templates. <br>  Let's take a look deeper, where the analysis of options and the work with types actually begin: <br><pre> <code class="hljs cs"> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(opts[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span></span><span class="hljs-function">) : config))</span></span> { <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-comment"><span class="hljs-comment">// it's a configuration flag, act on it 8 setConfig(cfg, opts[0]); 9 return getoptImpl(args, cfg, rslt, opts[1 .. $]); 10 } else { ...... 42 }</span></span></code> </pre><br>  Ohhh, here it is!  D did the long-awaited C ++ <i>typeof (expr)</i> and it works exactly as intended.  But that's not all, the expression <i>is (T == U)</i> is <i>true</i> if and only if (naturally at compile time) when types T and U are equal, and with template parameters and other uses, <i>is</i> simply turned into a Swiss knife for working with types.  Generally speaking, <i>is ()</i> is a built-in SFINAE that returns <i>true</i> if and only if the argument is any type, that is, the expression is syntactically correct.  For example, <i>is (arg == U [], U)</i> checks that <i>arg</i> is an array, and <i>is (arg: int)</i> - that <i>arg</i> can be automatically converted to an <i>int</i> , the colon unobtrusively hints at inheritance.  Later there will be more examples.  Thus, the expression on line 6 statically checks if the type of the first parameter ( <i>typeof (opt [0]) is</i> reduced to a certain type of <i>config</i> . And <i>config</i> is simply an enumeration of all possible option modifiers: <br><pre> <code class="hljs pgsql">enum config { /// Turns <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sensitivity <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> caseSensitive, /// Turns <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sensitivity <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> caseInsensitive, /// Turns bundling <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bundling, /// Turns bundling <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> noBundling, /// Pass unrecognized arguments through passThrough, /// Signal unrecognized arguments <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> errors noPassThrough, /// Stop at first argument that does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> look <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> an <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> stopOnFirstNonOption, /// <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> erase the endOfOptions separator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> args keepEndOfOptions, /// Makes the next <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> a required <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> required }</code> </pre><br>  after which <i>getoptImpl ()</i> saves the value (saves + value =&gt; runtime) of the modifier and recursively calls itself, removing the first argument from the options ( <i>opt [1 .. $]</i> ).  Thus, we dealt with the first case of type handling and it turned out surprisingly simple.  If you dismiss these endless <i>compile time / runtimes</i> and read the code as it is, and meeting <i>typeof (T) to</i> look a couple of pages up, where this type is defined (in our case, in the list of actual parameters <i>getopt ()</i> , then even to the offensive it's just that in C ++ it is much more like magic. Or maybe it was conceived? In the end, the compiler has all the same information as me - in the form of input code. <br>  Next, by recursively pulling one element from the input array, the compiler will get to the first string parameter, which must be a list of tags for this option, line 11. Here begins options that are again very easily resolved: if the second (next) parameter is a string, this is the description, and the third is the address of the processor;  otherwise (not a string), this is a handler.  Accordingly, we pull out from the list either three or two parameters and pass them to the next function - <i>handleOption (),</i> which already parses the command line itself, and then naturally recursively call ourselves and everything starts all over again. <br>  Further, nothing new happens in comparison with what we have already seen.  The <i>handleOption ()</i> function, a template with a single parameter ‚Äî the type of handler, passes through the entire command line, checking whether it fits the description and, if it finds it, performs an action corresponding to its handler.  I will briefly review the most interesting from my point of view points. <br>  First, a general view from above: <br><pre> <code class="hljs coffeescript">static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver) == bool)) { *receiver=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> non-boolean option, which might include an argument static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver) == enum)) { *receiver=to!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver))(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver) : real)) { *receiver=to!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver))(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver) == string)) { *receiver=to!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver))(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(receiver) == delegate) || <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver) == function)) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> functor with two, one <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-literal"><span class="hljs-literal">no</span></span> parameters static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(receiver(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)) : void)) { receiver(option, val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(receiver(<span class="hljs-string"><span class="hljs-string">""</span></span>)) : void)) { receiver(option); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { static assert(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(receiver()) : void)); receiver(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isArray!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver))) { foreach (elem; ...) *receiver ~= elem; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isAssociativeArray!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver))) { foreach (k, v; ...) (*receiver)[k]=v; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { static assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Dunno how to deal with type "</span></span> ~ <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(receiver).stringof); } }</code> </pre><br>  Note repeating design <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(*receiver</span></span></span><span class="hljs-function">)</span></span> == ...)) { *receiver=to!(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(*receiver))(val);</code> </pre>  actually means ‚Äúif a pointer to something is passed as a handler, try converting the argument to this type and assign it to the pointer‚Äù. <br>  Pointers to <b>bool</b> are processed separately, which may have no argument;  arrays and associative arrays, where the argument is added to the container;  as well as functions and lambda functions, which may have one, two, or no arguments.  Pay attention to the internal function type selector: <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(receiver(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">))</span></span> { receiver(option, val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(receiver(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">))</span></span> { receiver(option); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(receiver(</span></span></span><span class="hljs-function">)) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">))</span></span>; receiver(); }</code> </pre><br>  This is one more use case of the <i>is (T)</i> expression, it is reduced to <i>true</i> only if T is some existing type.  In this particular case, it looks at the type returned by the functions <i>(* receiver) (), (* receiver) ("") or (* receiver) ("", "")</i> , if such a signature of the function exists, the type also exists, otherwise - <i>SFINAE</i> .  ( <i>void</i> is a full type) <br>  It is also useful to get acquainted with the universal converter D from the <i>std.conv</i> module: <i>to! (T) (&lt;lexical&gt;)</i> , it works like <i>boost :: lexical_cast</i> but unlike it can even convert a string to <i>enum</i> since D shamelessly uses all the information available compile time, which we see in the code above. <br>  That's all, about 400 significant lines of code implemented a fairly complex function, and with the result that it is very difficult, if not impossible, to reproduce in C ++.  Well, we, in our turn, got acquainted with the peculiarities of working with types in D - template functions with a variable number of arguments, choice of type and code branch at compile time, as well as type conversion.  In fact, this is only a small part of the toolkit that D offers developers, the site has a huge collection of articles on various topics.  I do not urge anyone to switch to D or teach D, but if you have a spark of curiosity and interest in the new, this is certainly the language with which you should get acquainted at least superficially. <br><br><h3>  Criticism of pure reason </h3>  However, I can not refrain from criticism, I absolutely do not like something in the proposed implementation.  By and large, this has nothing to do with the language itself, nevertheless it is interesting to discuss it from general programming positions. <br>  Firstly, this implementation is made <b>one-pass</b> , that is, the option is retrieved from the list and the command line is immediately passed; the first match found terminates the loop.  This means that you cannot write <i>-qqq</i> as a synonym for ‚Äúquieter, quieter, even quieter‚Äù, or <i>--map A = 1 --map B = 2 --map C = 3</i> instead of <i>--map A = 1, B = 2, C = 3</i> .  Generally speaking, this is not a bug, but it violates some existing conventions when using <i>getopt ()</i> and I would like to see more traditional behavior. <br>  Secondly, and this is already a serious architectural error in my opinion, the function returns a certain structure with syntactic help, which is usually printed with the <i>-h | --help</i> key, but the same function <b>throws an exception</b> in case of an error.  That is, if you made a mistake on the command line, the program will no longer be able to tell you how to properly.  Generally speaking, this is obtained from the same single-pass implementation. <div class="spoiler">  <b class="spoiler_title">UPD: Does Alexandrescu read Habr?</b> <div class="spoiler_text">  In the last commit it was fixed, not quite as I would have done, but nonetheless. </div></div>  In addition, there are several minor flaws, for example, the option can have any number of synonyms, but only the first two are <i>included</i> in the syntax hint: in the <i>‚Äúx | abscissa | initialX‚Äù option, the</i> last value can be detected only by looking at the code.  Well, and similar annoying little things. <br>  Therefore, I did my own implementation as an exercise where I fixed these flaws and did my own different bells and whistles (only as an exercise), in general I had fun as I wanted. <br><h3>  Here was my bike!  Where is my bike? </h3>  But no, the bike is now <a href="https://github.com/sdegtiarev/getopt">there</a> , it happens.  I decided that a good guide should know where to stay, so the tour ends here. <br>  I hope it was interesting <br><br><h3>  Bibliography </h3>  I read the first three books, so I give each a separate number.  They are all good, but none for my taste is perfect, so I read with a sandwich - a chapter from one, the corresponding chapters from two others. <br><ol><li>  <a href="http://ddili.org/ders/d.en/index.html">Probably the historically first book on D</a> </li><li>  <a href="http://www.amazon.com/D-Programming-Language-Andrei-Alexandrescu/dp/0321635361">Book Alexandrescu</a> </li><li>  <a href="https://www.packtpub.com/application-development/d-cookbook">Very good cookbook</a> </li><li>  <a href="https://wiki.dlang.org/Books">All other currently existing books on D</a> </li><li>  <a href="http://dlang.org/articles.html">A bunch of articles, even more interesting than books, but each on a separate topic</a> <a href="http://dlang.org/articles.html"><br></a> </li><li>  <a href="http://wiki.dlang.org/The_D_Programming_Language">The wiki is just as interesting as articles, but unfortunately you need to know what you are looking for.</a> <a href="http://wiki.dlang.org/The_D_Programming_Language"><br></a> </li><li>  <a href="http://dlang.org/">Main site D</a> </li><li>  <a href="http://dlang.ru/">Russian version also exists</a> </li><li>  <a href="http://dlang.org/phobos/">Standard library on github.</a>  <a href="http://dlang.org/phobos/">Sources getopt () ibid.</a> <a href="http://dlang.org/phobos/"><br></a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/263515/">https://habr.com/ru/post/263515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263505/index.html">We display data from Serial in Chrome Application</a></li>
<li><a href="../263507/index.html">Python meetup - 2 years</a></li>
<li><a href="../263509/index.html">Developer Path, Part 3: The Game Creation History</a></li>
<li><a href="../263511/index.html">Improving Fody MethodDecoratorEx for asynchronous methods</a></li>
<li><a href="../263513/index.html">Continuous Success and why this should not be forgotten when developing a project (using the example of Drupal)</a></li>
<li><a href="../263531/index.html">We write and listen to conversations in 3CX</a></li>
<li><a href="../263533/index.html">The Magic of Tensor Algebra: Part 12 - Rodrigues-Hamilton Parameters in Solid Kinematics</a></li>
<li><a href="../263535/index.html">IBM, along with 200 universities around the world, is preparing the next generation of cloud service developers</a></li>
<li><a href="../263537/index.html">Chasing yourself, or a great way to start your day.</a></li>
<li><a href="../263539/index.html">Emmett Shire: How to Twitch Talk to Users</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>