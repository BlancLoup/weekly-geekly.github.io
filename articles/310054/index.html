<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of the OPCache extension for PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP is a scripting language that compiles the files you need to run by default. During compilation, it extracts opcodes , executes them, and then imme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of the OPCache extension for PHP</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/86a/63e/fa3/86a63efa391f4c4792939a0488d03ed0.jpg"><br><br>  PHP is a scripting language that compiles the files you need to run by default.  During compilation, it extracts <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">opcodes</a> , executes them, and then immediately destroys them.  PHP was designed this way: when it goes to execute the R request, it forgets everything that was performed during the R-1 request. <br><br>  It is very unlikely that on production servers the PHP code will change between the execution of several requests.  So we can assume that during compilations the same source code is always read, and therefore the opcode will be exactly the same.  And if you extract it for each script, it turns out a waste of time and resources. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/4e0/612/784/4e06127842a14af089913031fa616b3b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Due to the long compilation time extensions have been developed for opcode caching.  Their main task is to compile each PHP script <b>once</b> and cache the resulting opcodes into shared memory so that they can be read and executed by each PHP workflow from your production pool (PHP-FPM is usually used). <br><br>  As a result, the overall performance of the language greatly increases, and the launch of the script takes at least half the time (highly dependent on the script itself).  Usually even less, because PHP doesn't need to compile the same scripts over and over again. <br><br>  The more complex the application, the higher the efficiency of this optimization.  If a program runs a bunch of files, for example, a framework-based application, or products like Wordpress, then the duration of running scripts can be reduced by 10-15 times.  The fact is that the PHP compiler is slow because it has to convert one syntax to another, it tries to understand what you have written and somehow optimize the resulting code in order to speed up its execution.  So yes, the compiler is slow and consumes a lot of memory.  With the help of profilers like <a href="https://blackfire.io/">Blackfire,</a> we can predict the duration of the compilation. <br><br><img src="https://habrastorage.org/files/399/5cc/c97/3995ccc9772744c3b20bcb3965080f6d.png"><br><br><h1>  Introduction to OPCache </h1><br>  The OPCache source code was opened in 2013, and it began to come with PHP 5.5.0.  Since then, this is the standard solution for opcode caching in PHP.  Here we will not consider other solutions, because of them I am familiar only with APC, whose support was discontinued in favor of OPCache.  In short: if you used APC before, now use OPCache.  <b>Now it is a PHP solution officially recommended by PHP developers for opcode caching.</b>  <b>Of course, if you want, you can use other tools, but never activate more than one extension to cache opcodes at the same time</b> .  This will surely bring down PHP. <br><br>  Also keep in mind that further development of OPCache will be carried out only within PHP 7, but not PHP 5. In this article we will look at OPCache for both versions, so you will see the difference (it is not too large). <br><br>  So, OPCache is an extension, more precisely, a zend extension, embedded in PHP source code from version 5.5.0.  It needs to be activated using the usual activation process via php.ini.  As for distributions, check with the manual to make PHP and OPCache friendly. <br><br><h3>  Two functions of one product </h3><br>  OPCache has two main functions: <br><br><ul><li>  Opcode caching. </li><li>  Optimization of opcodes. </li></ul><br>  Since OPCache runs the compiler to get and cache the codes, it can use this step to optimize them.  In fact, we are talking about a variety of compiler optimizations.  OPCache works as a multi-pass compiler optimizer. <br><br><img src="https://habrastorage.org/files/48f/22a/20b/48f22a20be4c47518a617ef6388e89dd.png"><br><br><h1>  Interiors OPCache </h1><br>  Let's see how OPCache works inside.  If you want to check the code, you can take it, for example, <a href="https://github.com/php/php-src/tree/PHP-7.0/ext/opcache">from here</a> . <br><br>  The idea of ‚Äã‚Äãcaching opcodes will not be difficult to understand and analyze.  You will need a good understanding of the work and architecture of the Zend engine, and you will immediately begin to notice the places where you can optimize. <br><br><h3>  Shared memory models </h3><br>  As you know, there are many shared memory models in different operating systems.  Modern Unix systems use several approaches to shared memory usage by processes, the most popular of which are: <br><br><ul><li>  System-V shm API </li><li>  POSIX API </li><li>  mmap API </li><li>  Unix socket API </li></ul><br>  OPCache can use the first three, if supported by your OS.  INI-setting <i>opcache.preferred_memory_model</i> explicitly set the desired model.  If you leave the parameter at zero, OPCache will select the first model running on your platform, sequentially going through the table: <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_shared_memory_handler_entry handler_table[] = { <span class="hljs-comment"><span class="hljs-comment">#ifdef USE_MMAP { "mmap", &amp;zend_alloc_mmap_handlers }, #endif #ifdef USE_SHM { "shm", &amp;zend_alloc_shm_handlers }, #endif #ifdef USE_SHM_OPEN { "posix", &amp;zend_alloc_posix_handlers }, #endif #ifdef ZEND_WIN32 { "win32", &amp;zend_alloc_win32_handlers }, #endif { NULL, NULL} };</span></span></code> </pre> <br>  The default is to use <i>mmap</i> .  This is a good model, developed and stable.  Although it is less informative for system administrators than the System-V SHM model, like its <code>ipcs</code> and <code>ipcrm</code> . <br><br>  As soon as OPCache starts (that is, PHP starts), it checks the shared memory model and allocates one large segment, which it will then distribute into parts.  In this case, the segment will no longer be released or resized. <br><br>  That is, when running PHP, OPCache allocates one large memory segment that is not freed or fragmented. <br><br>  Segment size can be set in megabytes using the <i>opcache.memory_consumption</i> INI settings.  Do not save, ask more.  <b>Never allow the exhaustion of shared memory</b> , if this happens, the processes will be blocked.  We will discuss this below. <br><br>  Set the size of the segment according to your needs, and do not forget that a production server allocated for PHP processes can consume several dozen gigabytes of memory for PHP alone.  So it is often allocated a segment of 1 GB or more, it all depends on the specific needs.  If you are using a modern stack of applications, based on the framework, with a large number of dependencies, etc ... you can‚Äôt do at least a gigabyte. <br><br>  The segment will be used by OPCache for several tasks: <br><br><ul><li>  Caching the data structure of the script, including opcode caching. </li><li>  Creating a common internal (interned) string buffer. </li><li>  Storing hash tables of cached scripts. </li><li>  The state storage of global shared memory OPCache. </li></ul><br>  Remember that the shared memory segment contains not only opcodes, but also other things necessary for OPCache to work.  So estimate, how much memory is needed, and set the desired size of the segment. <br><br><img src="https://habrastorage.org/files/d3b/9b8/39d/d3b9b839da464d769e1a1eb359ade3f6.png"><br><br><h3>  Opcode caching </h3><br>  Consider the details of the caching mechanism. <br><br>  The idea is to copy into a shared memory (shm, shared memory) data of each pointer that does not change from request to request, that is, immutable data.  A lot of them.  After loading a previously used script from the shared memory, the pointer data is restored to the standard process memory associated with the current request.  A working PHP compiler uses Zend Memory Manager (Zend Memory Manager, ZMM) to place each pointer.  This type of memory is tied to the request, so ZMM will attempt to automatically free pointers when the current request is completed.  In addition, these pointers are placed from the heap of the current request, so it turns out something like a private extended memory, which can not be used in conjunction with other PHP-processes.  Therefore, the OPCache task is to view each structure returned by the PHP compiler, so as not to leave the pointer allocated to this pool, but to copy it into the dedicated pool of shared memory.  And here we are talking about the compile time.  Everything that has been posted by the compiler is considered immutable.  The variable data will be created <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">by the Zend virtual machine</a> during execution, so you can safely save everything created by the Zend compiler into shared memory.  For example, functions and classes, pointers to function names, pointers to OPArray functions, class constants, names of declared class variables and, finally, their default content ... Many things are created in memory by a PHP compiler. <br><br>  This model is used to reliably prevent locks.  Later we will touch the topic of blocking.  In fact, OPCache performs all of its work immediately, before execution, so already during the execution of the OPCache script there is nothing to do.  The variable data will be created in the classic process heap using ZMM, and the immutable data will be restored from shared memory. <br><br>  So, OPCache connects to the compiler and replaces the structure that the latter must fill during the compilation of scripts with its own.  Then, instead of directly populating the tables of the Zend engine and internal structures, it forces the compiler to fill the <code>persistent_script</code> structure. <br><br>  Here she is: <br><br><pre> <code class="php hljs">typedef struct _zend_persistent_script { ulong hash_value; char *full_path; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> unsigned int full_path_len; zend_op_array main_op_array; HashTable function_table; HashTable class_table; long compiler_halt_offset; <span class="hljs-comment"><span class="hljs-comment">/*  __HALT_COMPILER  -1 */</span></span> int ping_auto_globals_mask; <span class="hljs-comment"><span class="hljs-comment">/*  autoglobal'   */</span></span> accel_time_t timestamp; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> zend_bool corrupted; <span class="hljs-comment"><span class="hljs-comment">#if ZEND_EXTENSION_API_NO &lt; PHP_5_3_X_API_NO zend_uint early_binding; /*     */ #endif void *mem; /*  ,    */ size_t size; /*     */ /*  ,        ADLER32, *      struct */ struct zend_persistent_script_dynamic_members { time_t last_used; ulong hits; unsigned int memory_consumption; unsigned int checksum; time_t revalidate; } dynamic_members; } zend_persistent_script;</span></span></code> </pre><br>  And so OPCache replaces the compiler structure with its <code>persistent_script</code> , by simply switching function pointers: <br><br><pre> <code class="php hljs">new_persistent_script = create_persistent_script(); <span class="hljs-comment"><span class="hljs-comment">/*    op_array,      */</span></span> orig_active_op_array = CG(active_op_array); orig_function_table = CG(function_table); orig_class_table = CG(class_table); orig_user_error_handler = EG(user_error_handler); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> CG(function_table) = &amp;ZCG(function_table); EG(class_table) = CG(class_table) = &amp;new_persistent_script-&gt;class_table; EG(user_error_handler) = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; zend_try { orig_compiler_options = CG(compiler_options); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> CG(compiler_options) |= ZEND_COMPILE_HANDLE_OP_ARRAY; CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES; CG(compiler_options) |= ZEND_COMPILE_DELAYED_BINDING; CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION; op_array = *op_array_p = accelerator_orig_compile_file(file_handle, type TSRMLS_CC); <span class="hljs-comment"><span class="hljs-comment">/*  PHP- */</span></span> CG(compiler_options) = orig_compiler_options; } zend_catch { op_array = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; do_bailout = <span class="hljs-number"><span class="hljs-number">1</span></span>; CG(compiler_options) = orig_compiler_options; } zend_end_try(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> CG(active_op_array) = orig_active_op_array; CG(function_table) = orig_function_table; EG(class_table) = CG(class_table) = orig_class_table; EG(user_error_handler) = orig_user_error_handler;</code> </pre><br>  As you can see, the PHP compiler is completely isolated and disconnected from normally populated tables.  Now it fills <code>persistent_script</code> structures.  Next, OPCache should look at these structures and replace the pointers to the request with pointers to the shared memory.  OPCache needed: <br><br><ul><li>  Script Functions </li><li>  Script classes </li><li>  The main OPArray script. </li><li>  Script path </li><li>  The structure of the script itself. </li></ul><br><img src="https://habrastorage.org/files/fe5/a31/ad5/fe5a31ad545d4edaa7fb5020639a77cd.png"><br><br>  Also, the compiler is passed some options that disable the optimizations it performs, for example, <code>ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION</code> and <code>ZEND_COMPILE_DELAYED_BINDING</code> .  This adds OPCache work.  Remember that OPCache connects to the Zend engine, it is not a patch for the source code. <br><br>  Since we now have a <code>persitent_script</code> structure, we need to cache its information.  The PHP compiler filled out our structures, but with the help of ZMM allocated memory from the edge: it will be released upon completion of the current request.  Then we need to look at this memory and copy the contents into a segment of shared memory so that the collected information can be used for several requests and not re-calculated each time. <br><br>  The process is structured as follows: <br><br><ul><li>  The PHP script is placed in the cache and the total data size of each variable (all target pointer objects) is calculated. </li><li>  Already allocated shared memory is reserved for one large block of the same size. </li><li>  All the variable structures of the script are scanned, and the variable data of all pointer targets is copied into the newly reserved shared memory block. </li><li>  To download the script (when it comes to this) the opposite is done. </li></ul><br>  So, OPCache intelligently uses shared memory, never fragmenting it through releases and seals.  For each script, it calculates the exact size of the total memory required to store information, and then copies the data there.  <b>The memory is never released or returned to the OPCache.</b>  Therefore, it is used extremely efficiently and is not fragmented.  This greatly improves the performance of shared memory, because there is no linked-list or B-tree (BTree) that you have to store and view when managing memory, which can be freed (as malloc / free does).  OPCache stores data in a shared memory segment, and when they lose relevance (due to script validity checking), the buffers are not released, but are marked as ‚Äúwasted‚Äù.  When the lost memory reaches its maximum, OPCache restarts.  This model is very different, for example, from APC.  Its great advantage is that over time, performance does not fall, because the buffer from shared memory is never managed (not released, not compacted, etc.).  All these memory management operations are a purely technical thing, not improving functionality, but reducing performance.  <b>OPCache was designed to provide the highest possible performance with respect to the execution of the PHP environment.</b>  The ‚Äúinviolability‚Äù of the shared memory segment also provides a very good processor cache access rate (especially L1 and L2), because OPCache also aligns the memory pointers with L1 / L2. <br><br>  Caching a script primarily involves calculating the exact size of its data.  Here is the calculation algorithm: <br><br><pre> <code class="php hljs">uint zend_accel_script_persist_calc(zend_persistent_script *new_persistent_script, char *key, unsigned int key_length TSRMLS_DC) { START_SIZE(); ADD_SIZE(zend_hash_persist_calc(&amp;new_persistent_script-&gt;function_table, (int (*)(void* TSRMLS_DC)) zend_persist_op_array_calc, sizeof(zend_op_array) TSRMLS_CC)); ADD_SIZE(zend_accel_persist_class_table_calc(&amp;new_persistent_script-&gt;class_table TSRMLS_CC)); ADD_SIZE(zend_persist_op_array_calc(&amp;new_persistent_script-&gt;main_op_array TSRMLS_CC)); ADD_DUP_SIZE(key, key_length + <span class="hljs-number"><span class="hljs-number">1</span></span>); ADD_DUP_SIZE(new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + <span class="hljs-number"><span class="hljs-number">1</span></span>); ADD_DUP_SIZE(new_persistent_script, sizeof(zend_persistent_script)); RETURN_SIZE(); }</code> </pre><br>  I repeat: we need to cache: <br><br><ul><li>  Script Functions </li><li>  Script classes </li><li>  The main OPArray script. </li><li>  Script path </li><li>  The structure of the script itself. </li></ul><br>  The iterative algorithm performs a deep search for functions, classes and OPArray: it caches the data of all pointers.  For example, in PHP 5 for functions you need to copy to shared memory (shm): <br><br><ul><li>  Hash Tables of Functions <br><br><ol><li>  Container table of hash table functions (Bucket **) </li><li>  Container hash table of functions (Bucket *) </li><li>  Container key hash table of functions (char *) </li><li>  Index of data containers hash table of functions (void *) </li><li>  Data containers hash table functions (*) </li></ol></li><li>  OPArray functions <br><br><ol><li>  OPArray File Name (char *) </li><li>  OPArray Literals (names (char) and <i>values ‚Äã‚Äã(zval)</i> ) </li><li>  Opcodes OPArray (zend_op *) </li><li>  OPArray function names function name (char *) </li><li>  arg_infos OPArray (zend_arg_info, <i>as well as the name and the name of the class are both char</i> ) </li><li>  Array break-continue OPArray (zend_brk_cont_element *) </li><li>  OPArray static variables (Full hash table and zval *) </li><li>  OPArray documentation comments (char *) </li><li>  Try-catch OPArray array try- (zend_try_catch_element *) </li><li>  Compiled OPArray Variables (zend_compiled_variable *) </li></ol></li></ul><br>  In PHP 7, the list is somewhat different due to the difference in structures (for example, a hash table).  As I said, the idea is to copy the data of all the pointers into common memory.  Since deep copying can affect intersecting structures, OPCache uses a translate table for storing pointers: each time a pointer is copied from conventional memory associated with a request to a common one, the table between the old and new pointer addresses is written to the table.  The process responsible for copying first looks in the translation table to see if this data has already been copied.  If copied, it uses old pointer data to avoid duplication: <br><br><pre> <code class="php hljs">void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC) { void **old_p, *retval; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_hash_index_find(&amp;xlat_table, (ulong)source, (void **)&amp;old_p) == SUCCESS) { <span class="hljs-comment"><span class="hljs-comment">/* we already duplicated this pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *old_p; } retval = ZCG(mem);; ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size)); memcpy(retval, source, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (free_source) { interned_efree((char*)source); } zend_shared_alloc_register_xlat_entry(source, retval); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br>  <code>ZCG(mem)</code> is a fixed-size shared memory segment that is filled as items are added.  Since it is already allocated, there is no need to allocate memory for each copy (this would reduce overall performance), just when filling a segment, the boundary of the pointers' addresses shifts. <br><br>  We looked at a script caching algorithm that takes a pointer and data from a heap bound to a request and then copies them into shared memory, if this has not been done before.  The loading algorithm does the exact opposite: it takes <code>persistent_script</code> from the shared memory and scans all its dynamic structures, copying the common pointers into pointers located in the memory bound to the process.  After that, the script is ready to run using the Zend engine (Zend Engine Executor), now it does not embed the addresses of common pointers (which will lead to serious bugs when one script changes the structure of another).  Now Zend is deceived by OPCache: he did not notice the pointer substitution that occurred before the execution of the script. <br><br>  The process of copying from conventional memory to shared (caching the script) and back (loading the script) is well optimized, and even if you have to do a lot of copying or searching through a hash that does not improve performance, it still turns out much faster than running the PHP compiler every time . <br><br><h3>  Sharing internal row storage </h3><br>  The internal storage of strings (interned strings) is a good memory optimization, which appeared in PHP 5.4.  It looks logical: when PHP encounters a string (char *), it stores it in a special buffer and uses the pointer again each time it encounters the same string, you can learn more about them from <a href="http://jpauli.github.io/2015/09/18/php-string-management.html">this article</a> . <br><br>  They work like this: <br><br><img src="https://habrastorage.org/files/e05/0a7/e59/e050a7e59dad4dc78c9b5379f7bb11cd.png"><br><br>  All pointers use the same string instance.  But there is one problem: the buffer of this internal line is used separately for each process and is mainly controlled by the PHP compiler.  This means that in a PHP-FPM pool, every PHP workflow will save its own copy of this buffer.  Like that: <br><br><img src="https://habrastorage.org/files/cf5/826/f95/cf5826f95026444a92561cbffdbe41da.png"><br><br>  This leads to large memory losses, especially when you have a lot of workflows, and when you use very large string in the code (hint: the explanatory comments in PHP are strings). <br><br>  OPCache shares this buffer between all workflows in the pool.  Something like this: <br><br><img src="https://habrastorage.org/files/549/e76/e32/549e76e3209d445dafd2ea7d5b8f96b1.png"><br><br>  OPCache uses a shared memory segment to store all of these shared buffers.  Therefore, when assigning a segment size, your use of internal row storage should be taken into account.  Using the <i>opcache.interned_strings_buffer</i> INI settings, <i>you</i> can customize the use of shared memory for storage.  Let me remind you once again: make sure that you have enough memory allocated.  If you do not have enough space for these strings ( <i>opcache.interned_strings_buffer is</i> too low), OPCache will not restart.  After all, it still has enough free shared memory, only the row storage buffer is full, which does not block request processing.  You simply cannot save and share strings, and strings that use the memory of the PHP workflow will not be available.  It is better to avoid such situations in order not to reduce performance. <br><br>  Check the logs: when you run out of memory for this, OPCache will warn you about this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZCSG(interned_strings_top) + ZEND_MM_ALIGNED_SIZE(sizeof(Bucket) + nKeyLength) &gt;= ZCSG(interned_strings_end)) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> zend_accel_error(ACCEL_LOG_WARNING, <span class="hljs-string"><span class="hljs-string">"Interned string buffer overflow"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arKey; }</code> </pre><br>  Such lines include almost all types of lines encountered by the PHP compiler during its operation: variable names, ‚Äúphp strings‚Äù, function names, class names ... Comments that are today called ‚Äúannotations‚Äù are also strings, and most often huge size.  They occupy most of the buffer, so don't forget about them. <br><br><h3>  Locking mechanism </h3><br>  Since we are talking about shared memory, we should also talk about the mechanisms for locking memory.  The bottom line is this: <b>every PHP process that wants to write to shared memory will block all other processes that also want to write to it</b> .  So the main difficulties are connected with writing, and not with reading.  You may have 150 PHP processes reading from shared memory, but only one can write to it at a time.  A write operation does not block reading, but only other write operations. <br><br>  So <b>in OPCache there should be no deadlocks until you want to sharply warm up your cache</b> .  If, after the deployment of the code, you do not regulate traffic to the server, the scripts will begin to be intensively compiled and cached.  And since the operation of writing a cache to shared memory is performed under the condition of an exclusive lock, then all processes will start, because some lucky person started writing to memory and blocked all the others.  And when he removes the lock, all other processes that were waiting for their turn will find that the file they just compiled is already stored in shared memory.  And then they will begin to destroy the result of the compilation in order to load data from the shared memory.  This is an unforgivable waste of resources. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> zend_shared_alloc_lock(TSRMLS_C); <span class="hljs-comment"><span class="hljs-comment">/* ,       ( ,     *  .      *  ) */</span></span> bucket = zend_accel_hash_find_entry(&amp;ZCSG(hash), new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bucket) { zend_persistent_script *existing_persistent_script = (zend_persistent_script *)bucket-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!existing_persistent_script-&gt;corrupted) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ZCG(accel_directives).revalidate_path &amp;&amp; (!ZCG(accel_directives).validate_timestamps || (new_persistent_script-&gt;timestamp == existing_persistent_script-&gt;timestamp))) { zend_accel_add_key(key, key_length, bucket TSRMLS_CC); } zend_shared_alloc_unlock(TSRMLS_C); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_persistent_script; } }</code> </pre><br>  You need to disconnect the server from external traffic, deploy a new code, and pull the heaviest URLs with curl so that the curl requests gradually fill up the shared memory.  When you are done with most of your scripts, you can send traffic to the server, and then active reading from shared memory will begin, and this does not lead to blocking.  Of course, there may remain small scripts that have not been compiled yet, but since there are not many of them, this will have little effect on blocking the recording. <br><br>  Avoid while writing PHP files and then using them.  The reason is the same: when you write a new file to the root folder of a production server, then use it, then there is a chance that thousands of workflows will try to compile and cache it into shared memory.  And then there will be a lock.   PHP-      OPCache   INI- <i>opcache.blacklist-filename</i> (   (glob pattern)). <br><br>      ,      Unix ‚Äî     <code>fcntl()</code> : <br><br><pre> <code class="php hljs">void zend_shared_alloc_lock(TSRMLS_D) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fcntl(lock_file, F_SETLKW, &amp;mem_write_lock) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EINTR) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } zend_accel_error(ACCEL_LOG_ERROR, <span class="hljs-string"><span class="hljs-string">"Cannot create lock - %s (%d)"</span></span>, strerror(errno), errno); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ZCG(locked) = <span class="hljs-number"><span class="hljs-number">1</span></span>; zend_hash_init(&amp;xlat_table, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>     ,     :      ,         ,        . <br><br>      ,   :  .    . <br><br><h3>   OPCache </h3><br>   : <br><br><ul><li>   PHP (   PHP-FPM) OPCache      ,    . </li><li>     OPCache    .     . </li><li> OPCache      . </li><li>    : <br><br><ol><li>    ,    . </li><li>      . </li><li>  -  . </li><li>      OPCache. </li></ol></li></ul><br>     ,  OPCache         (     ,  INI- <i>opcache.revalidate_freq</i> )  ,   .   :    ,   .   PHP    OPCache,  PHP   ( <code>stat()</code> ) :  OPCache    ,        ¬´¬ª  <code>stat()</code>  . <br><br>       (timestamp)  <i>opcache.validate_timestamps</i>  <i>opcache.revalidate_freq</i> ,      ,  OPCache              ¬´wasted¬ª. <b>OPCache                 INI- <i>opcache.max_wasted_percentage</i> INI.    .</b>  There are no other options. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> memory_used = zend_accel_script_persist_calc(new_persistent_script, key, key_length TSRMLS_CC); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ZCG(mem) = zend_shared_alloc(memory_used); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ZCG(mem)) { zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_OOM TSRMLS_CC); zend_shared_alloc_unlock(TSRMLS_C); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_persistent_script; }</code> </pre><br><img src="https://habrastorage.org/files/fcb/025/366/fcb0253665ae4d47a23a16cac5c039f4.png"><br><br>   ,         ,    .      ¬´¬ª,  OPCache   .              . <br><br>       ,  . OPCache   ,     .      ,    :      ,     . -      .   ,   ,    .      . <br><br> <b>      .</b> <br><br>  ,        production-,       (  ,    :  OPCache       persistent-,     ).       : <br><br><ul><li>     (  ). </li><li>  OPCache ( <code>opcache_reset()</code> )    FPM (  ,    ‚Äî )). </li><li>     . </li><li>   FPM,  ,        curl-     . </li><li>     . </li></ul><br>       shell-  50 .       ,         <code>lsof</code>  <code>kill</code> .   Unix ;-) <br><br>             GUI-  OPCache.     <code>opcache_get_status()</code> : <br><br><img src="https://habrastorage.org/files/17f/4f4/7bd/17f4f47bd53c4ab4b15af0dd370fb972.png"><br><br>      .      <b>  (cache keys)</b> . <br><br>  OPCache      ,      -,       .   - OPCache   .  ?          . <br><br>  OPCache     .   ,     <a href="http://jpauli.github.io/2014/06/30/realpath-cache.html">realpath_cache</a> ,     .        ,   <i>opcache.revalidate_path</i>  1   realpath cache (    ,       ,   ). <br><br> , OPCache     ,   <b>        realpath</b> . ,   INI- <i>opcache.revalidate_path</i>  1.    ,  OPCache       <b>unresolved </b> .      ,    ,        ,  OPCache     -   unresolved    ,      (    ). <br><br>   <i>opcache.use_cwd</i>  1,  OPCache   <code>cwd</code>    .     <i> </i>   ,  <code>require_once "./foo.php";</code>  .      ,        PHP   (   ),      <i>opcache.use_cwd</i>  1.  ,    ,     <i>opcache.revalidate_path</i> .          <a href="http://jpauli.github.io/2014/06/30/realpath-cache.html">realpath-</a> .     www-   , OPCache   ,        <code>opcache_reset()</code> . <br><br> - realpath-             .  <i>opcache.use_cwd</i>  <i>opcache.revalidate_path</i>  1,          .       realpath  OPCache, PHP   ,    <code>realpath_cache</code> . <br><br>        ,          documentroot.      ,    FPM-   FastCGI,        .   ,       Lighttpd  Nginx: <br><br><ul><li>     (  ). </li><li>  FPM,     PHP (   OPCache).     ,     realpath-,      .      FPM.   ,   ,     . </li><li>     . </li><li>  FPM-.         curl-     . </li><li>     . </li></ul><br>        ,    ,    : <br><br><ul><li>       ,  PHP-      FPM-   production-. </li><li>    FPM-,   .          production-. </li><li>      FPM-:  ,   . </li><li>   documentroot-    ,        FPM-. </li></ul><br>   -    ,   ,   ,       ,      .      ,    documentroot- (      realpath-),    .     ,       production-.   shell-   80. <br><br>    ,     OPCache     .     :         .    OPCache   ,      ,         :      . <br><br>       ,     . <br> OPCache       <code>opcache_get_status()</code> ‚Äî ,     GUI ‚Äî    <i>num_cached_keys</i> .  :       INI- <i>opcache.max_accelerated_files</i> .       ,    OPCache .   ,       .       .      <code>require_once</code> ,  OPCache    .     ,     <code>include_once</code>   ,   . <br><br>   OPCache    -    persistent-,      .  - ,    .     . <br><br>   <i>num_cached_scripts</i>    <i>num_cached_keys</i> ,     OPache.    <i>num_cached_keys</i> .    <i>max_cached_keys</i> ,      . <br><br>  ,   ,  ,      OPache (INI- <i>opcache.log_verbosity_level</i> ).   ,   ,  ,  OOM-  (OutOfMemory):      -. <br><br><img src="https://habrastorage.org/files/712/4c8/d67/7124c8d67de5476999f8de3e5fdde639.png"><br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void zend_accel_add_key(char *key, unsigned int key_length, zend_accel_hash_entry *bucket TSRMLS_DC) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!zend_accel_hash_find(&amp;ZCSG(hash), key, key_length + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_accel_hash_is_full(&amp;ZCSG(hash))) { zend_accel_error(ACCEL_LOG_DEBUG, <span class="hljs-string"><span class="hljs-string">"No more entries in hash table!"</span></span>); ZSMMG(memory_exhausted) = <span class="hljs-number"><span class="hljs-number">1</span></span>; zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_HASH TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { char *new_key = zend_shared_alloc(key_length + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_key) { memcpy(new_key, key, key_length + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_accel_hash_update(&amp;ZCSG(hash), new_key, key_length + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, bucket)) { zend_accel_error(ACCEL_LOG_INFO, <span class="hljs-string"><span class="hljs-string">"Added key '%s'"</span></span>, new_key); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_OOM TSRMLS_CC); } } } }</code> </pre><br>    : <br><br><img src="https://habrastorage.org/files/bb4/7b4/f49/bb47b4f4977047009791d5e2dabac51e.png"><br><br>   PHP   OPCache,    <i>opcache.memory_consumption</i>    (shm).          ( <i>opcache.interned_strings_buffer</i> ).     -    persistent-   .      <i>opcache.max_accelerated_files</i> . <br><br>        OPCache,          .            OPCache (    ).       ¬´¬ª,      OPCache,       (). <br><br>  It might look like this: <br><br><img src="https://habrastorage.org/files/8e0/131/38c/8e013138cfde495d880aa4999c6a8f3d.png"><br><br>  - persistent-  ,     ,  OPCache   (     ). <br><br><h3>  OPCache </h3><br>       , , Symfony,    : <br><br><ul><li>   production    ( <i>opcache.validate_timestamps</i>  0) </li><li>  ,    runtime .          Symfony. </li><li>    : <br><br><ol><li> <i>opcache.memory_consumption</i> .   . </li><li> <i>opcache.interned_strings_buffer</i> .           .  :    OPCache  ,    ,   ¬´¬ª PHP ( <i>opcache.save_comments = 1</i> ),    ,  ,       . </li><li> <i>opcache.max_accelerated_files</i> .    .  ,        . </li></ol></li><li>  <i>opcache.opcache.revalidate_path</i>  <i>opcache.use_cwd</i> .      . </li><li>  <i>opcache.enable_file_override</i> ,   . </li><li>   <i>opcache.blacklist_filename</i>  ,       runtime.          . </li><li>  <i>opcache.consistency_checks</i> ,  ,     ,  . </li></ul><br>          ¬´¬ª.        <i>then opcache.max_wasted_percentage</i> .          FPM.      FPM,    ,     . <br><br>     . <br><br><h3>   OPCache </h3><br><h4>  Introduction </h4><br> ,           .     OPCache      .    ,    , <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">     Zend</a> .        ,      <a href="https://msdn.microsoft.com/en-us/magazine/dn904673.aspx">,   </a> .        ¬´ <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580%25D1%258B:_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF%25D1%258B,_%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25B8_%25D0%25B8_%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D1%258B"> </a> ¬ª.   ,         . <br><br>  ,     OPArray,   ,     .      <b>  </b> ,        ,    ¬´ PHP¬ª.    ,      <i>IS_VAR</i>  <i>IS_CV</i> ,     <i>IS_CONST</i>   ‚Äî <i>IS_TMP_VAR</i> .           ,       runtime,      . <br><br>  OPCache      <i>IS_CONST</i> .        (  runtime);   CGF- (  )       .               .          PHP:     ,       .        - ,   OPCache       OPArray (  OPArray  ),    . PHP       -   ‚Äî  ,       :                 .        ,    , ,       ,    .      Java  ++,   ¬´¬ª      - . PHP   . <br><br>  PHP               .     ,   ,   .       - . <br><br>  OPCache      -  .    INI- <i>opcache.optimization_level</i> .          : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* zend_optimizer.h */</span></span> <span class="hljs-comment"><span class="hljs-comment">#define ZEND_OPTIMIZER_PASS_1 (1&lt;&lt;0) /* CSE,  STRING */ #define ZEND_OPTIMIZER_PASS_2 (1&lt;&lt;1) /*     */ #define ZEND_OPTIMIZER_PASS_3 (1&lt;&lt;2) /* ++, +=,   */ #define ZEND_OPTIMIZER_PASS_4 (1&lt;&lt;3) /* INIT_FCALL_BY_NAME -&gt; DO_FCALL */ #define ZEND_OPTIMIZER_PASS_5 (1&lt;&lt;4) /*    CFG */ #define ZEND_OPTIMIZER_PASS_6 (1&lt;&lt;5) #define ZEND_OPTIMIZER_PASS_7 (1&lt;&lt;6) #define ZEND_OPTIMIZER_PASS_8 (1&lt;&lt;7) #define ZEND_OPTIMIZER_PASS_9 (1&lt;&lt;8) /*  TMP VAR */ #define ZEND_OPTIMIZER_PASS_10 (1&lt;&lt;9) /*  NOP */ #define ZEND_OPTIMIZER_PASS_11 (1&lt;&lt;10) /*    */ #define ZEND_OPTIMIZER_PASS_12 (1&lt;&lt;11) /*    */ #define ZEND_OPTIMIZER_PASS_13 (1&lt;&lt;12) #define ZEND_OPTIMIZER_PASS_14 (1&lt;&lt;13) #define ZEND_OPTIMIZER_PASS_15 (1&lt;&lt;14) /*   */ #define ZEND_OPTIMIZER_ALL_PASSES 0xFFFFFFFF #define DEFAULT_OPTIMIZATION_LEVEL "0xFFFFBFFF"</span></span></code> </pre><br><h4>       </h4><br>  ,   PHP 5   ,    ,   ,  OPCache.   PHP 7    . <br><br>  Example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; }</code> </pre><br>    : <br><br><img src="https://habrastorage.org/files/ea3/2d2/ad2/ea32d2ad28bf4ff2a87f583ad9f2ca0c.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/48d/649/cc4/48d649cc4b8647eea907459d544fd004.png"><br><br>  ,     <code>if(false)</code>  ,     Zend    <code>ZEND_ECHO</code> .    ,      . ,        runtime. <br><br> ,         ,       (    ).       <i>IS_CONST</i>  <i>IS_CV</i> ,      : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/*   ,    $a ? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($a) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; }</code> </pre><br>   ,     PHP 5  PHP 7: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> == <span class="hljs-string"><span class="hljs-string">'/tmp'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; }</code> </pre><br>  PHP 7     <code>__DIR__</code>     ,   OPCache.            OPCache.  PHP 5.6     <code>__DIR__</code> ,     .    OPCache. <br><br>  .    PHP 5.6  PHP 7    OPCache,       .      ,    PHP 5.6    ,   PHP 7,    PHP 5.6    ,      PHP 7     (   OPCache). <br><br><h4>   - </h4><br> OPCache    <i>IS_TMP_VAR</i>  <i>IS_CONST</i> .  ,          .  -       ,     .     : <br><br><ul><li> <code>function_exists()</code>  <code>is_callable()</code> ,    . </li><li> <code>extension_loaded()</code> ,      <code>dl()</code> . </li><li> <code>defined()</code>  <code>constant()</code> ,    . </li><li> <code>dirname()</code>    . </li><li> <code>strlen()</code>  <code>dirname()</code>  - (  PHP 7). </li></ul><br>  Take a look at an example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (function_exists(<span class="hljs-string"><span class="hljs-string">'array_merge'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>; }</code> </pre><br>   ,       runtime: <br><br><img src="https://habrastorage.org/files/bd1/50b/bdd/bd150bbddf0040e09e4babe1765b2ecf.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/afc/19a/2e8/afc19a2e8f1447ac8f63408cf7684cc8.png"><br><br>  ,        .  , : <br><br> <code>if function_exists('my_custom_function')) { }</code> <br> <br>  ,          '__'.  ,   PHP   OPCache   .     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_custom_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> function_exists(<span class="hljs-string"><span class="hljs-string">'my_custom_function'</span></span>)) { }</code> </pre> <br>     ,     ,       <i></i>  (   ). <br><br>    <code>dirname()</code> (  PHP 7): <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dirname(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>) == <span class="hljs-string"><span class="hljs-string">'/tmp'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'yo'</span></span>; }</code> </pre><br>  : <br><br><img src="https://habrastorage.org/files/cc8/053/d01/cc8053d0103f444fa86bcd741208e0e7.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/afc/19a/2e8/afc19a2e8f1447ac8f63408cf7684cc8.png"><br><br> <code>strlen()</code>  PHP 7 .      ,      .  For example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strlen(dirname(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)) == <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"yes"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"no"</span></span>; }</code> </pre><br>  : <br><br><img src="https://habrastorage.org/files/a7e/66b/80d/a7e66b80da7f418c9f463c45e1ee5edf.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/450/a16/170/450a161702bc42048fb138287231765f.png"><br><br>      ,        /,    OPCache   ¬´¬ª  (,   ¬´¬ª ). <br><br><h4>  (Transtyping) </h4><br>  OPCache      <i>IS_CONST</i> ,  ,       .        runtime: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">8</span></span>; $c = $a + <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $c;</code> </pre> <br>  : <br><br><img src="https://habrastorage.org/files/f43/84f/155/f4384f15590f4f94b95ec9f962175f8a.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/e81/ae9/f32/e81ae9f3233d4ac9ad82967188eadcad.png"><br><br>     true-  <code>ZEND_ADD</code> :       .        <code>ADD</code> .      ,    runtime    , ,   ,   .        . <br><br>    OPCache,    : <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZEND_OPTIMIZER_PASS_2 &amp; OPTIMIZATION_LEVEL) { zend_op *opline; zend_op *end = op_array-&gt;opcodes + op_array-&gt;last; opline = op_array-&gt;opcodes; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (opline &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (opline-&gt;opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ADD: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_SUB: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_MUL: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_DIV: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZEND_OP1_TYPE(opline) == IS_CONST) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZEND_OP1_LITERAL(opline).type == IS_STRING) { convert_scalar_to_number(&amp;ZEND_OP1_LITERAL(opline) TSRMLS_CC); } } <span class="hljs-comment"><span class="hljs-comment">/* break missing *intentionally* -      op2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ASSIGN_ADD: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ASSIGN_SUB: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ASSIGN_MUL: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_ASSIGN_DIV: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opline-&gt;extended_value != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*       ‚Äì   ! */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZEND_OP2_TYPE(opline) == IS_CONST) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ZEND_OP2_LITERAL(opline).type == IS_STRING) { convert_scalar_to_number(&amp;ZEND_OP2_LITERAL(opline) TSRMLS_CC); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span></code> </pre><br>     ,        PHP 7.  ,   PHP 7        OPCache (  ),     ,     PHP 5. <br><br>     <i>IS_CONST</i> ,        .  PHP 5      ,   OPCache: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-string"><span class="hljs-string">"33"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a;</code> </pre><br>  : <br><br><img src="https://habrastorage.org/files/f18/1d1/223/f181d1223f044dc8815a27b8c3d41599.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/b71/c87/4dc/b71c874dcfc547e4a47cb9c4cc0f77e2.png"><br><br>    <code>4 + 33</code>    <code>ZEND_ADD</code> ,    .         runtime,          . :  PHP 7   ,   PHP 5   OPCache. <br><br><h4>    </h4><br>     .       , . <br><br><pre> <code class="php hljs">$i = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; $i = $i + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $i;</code> </pre> <br>  : <br><br><img src="https://habrastorage.org/files/178/b43/e8c/178b43e8c67342689d19a8e71c9f9367.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/9d2/0d1/a57/9d20d1a578224e88a9c7edafeeb75d54.png"><br><br>     Zend VM    <code>ZEND_ASSIGN_ADD</code>  <code>ZEND_ADD</code>  <code>ZEND_ASSIGN</code> .       <code>$i+=3;</code>  . <code>ZEND_ASSIGN_ADD</code>  ,      (  ,   ) <br><br>    : <br><br><pre> <code class="php hljs">$j = <span class="hljs-number"><span class="hljs-number">4</span></span>; $j++; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $j;</code> </pre> <br>  : <br><br><img src="https://habrastorage.org/files/11b/d72/a95/11bd72a95a9b45bc8c752d0d18acccda.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/e18/588/4ad/e185884ad7dd4613967e01406a7d490c.png"><br><br>   OPCache   <code>++$i</code>  <code>$i++</code> ,           . <code>ZEND_POST_INC</code> ‚Äî    ,      ,    ,      ,  <code>ZEND_PRE_INC</code>   : ,    (       ).   ,  <code>ZEND_POST_INC</code> ,     ,           <code>ZEND_FREE</code> .  OPCache    <code>ZEND_PRE_INC</code>    <code>ZEND_FREE</code> :    runtime. <br><br><h4>      </h4><br>    PHP-?   ,    .   ,   ,      .  Let's look at an example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FOO = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> FOO;</code> </pre> <br><img src="https://habrastorage.org/files/2f0/b90/2f1/2f0b902f14134e5d99808f4689eac105.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/4f1/d58/178/4f1d581784944e8c862add3b045316de.png"><br><br>     .  ,   ,       ,    runtime     . <br><br>   <code>define()</code>     <code>const</code> ,     : <br><br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> FOO;</code> </pre> <br>          : <br><br><img src="https://habrastorage.org/files/dca/a99/246/dcaa992463184414933b5f93782ef698.png"><br><br>  : <br><br><img src="https://habrastorage.org/files/4f1/d58/178/4f1d581784944e8c862add3b045316de.png"><br><br> <code>define()</code> ,    ,      runtime,   ( <code>define()</code>  ).  This is very bad.   <code>const</code>     <code>DECLARE_CONST</code> .        <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">    Zend</a> . <br><br><h4>     (Multiple jump target resolution) </h4><br>    ,     .        (  ).  ,      ,          .  ‚Äî   ,      .  PHP-  . <code>if</code> , <code>switch</code> , <code>while</code> , <code>try</code> , <code>foreach</code> , <code>?</code> : ‚Äî     .    true,      ,    ‚Äî   . <br><br>    ,      .  landing-     ,   landing-.       ,         ¬´¬ª. <br><br>  For example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($a) { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"no"</span></span>; } a: <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span>;</code> </pre> <br>        : <br><br><img src="https://habrastorage.org/files/3b4/914/437/3b49144373f74ce387942dd3aa17c316.png"><br><br>  (   ): ¬´  $a  0,     3,   ¬´no¬ª.         4,   ¬´a¬ª¬ª. <br><br>  -  ¬´  3,     4¬ª.     ¬´  4¬ª?    : <br><br><img src="https://habrastorage.org/files/3e1/e46/50e/3e1e4650e3dc49c59cfdf23a04543eac.png"><br><br>     ¬´   $a   ,    2   ¬´a¬ª,     ¬´no¬ª¬ª.  , ?         ,      . , <code>while</code>  <code>if</code> ,    <code>goto</code> ,   <code>switch</code> ,  <code>try-catches</code> ,  ..    OPArray    .     ,       .        (  )      .        runtime. <br><br><h4>  Conclusion </h4><br>      . ,         ¬´ ¬ª (early returns).       try-catch  switch-break.       PHP,     . <br><br>       ,       ,      .    OPCache      ,    ,  PHP    ,  ,       ‚Ä¶  ,    ,     .   . <br><br>   OPCache  ,           PHP.      PHP 7,          .     PHP 7     (   )    PHP 5 (  PHP 5    ). <br><br> ,  ,        .   ,         .   ,  ,    ,    .        ,  ,    OPCache.       :      ,        .          (      runtime). <br><br><h3>  the end </h3><br>  ,  OPCache -       .   ,      ,      .  OPCache         PHP,        .    PHP-   ,      ,   .        ,           ‚Äî   PHP-FPM SAPI. </div><p>Source: <a href="https://habr.com/ru/post/310054/">https://habr.com/ru/post/310054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310044/index.html">Fonts on the web, a review from 2016</a></li>
<li><a href="../310046/index.html">How to manage the giants Vol.3: the full life cycle of the project</a></li>
<li><a href="../310048/index.html">How much conflict developers - infographics on the results of the survey on "My Circle"</a></li>
<li><a href="../310050/index.html">Tired of silencing: the truth about working in a technical support service for an IT company</a></li>
<li><a href="../310052/index.html">Animated QR codes</a></li>
<li><a href="../310056/index.html">Launch Linux on FPGA: Hello, World</a></li>
<li><a href="../310058/index.html">How to stop being afraid and fall in love with mbed [Part 3]</a></li>
<li><a href="../310060/index.html">Cycle of articles "NetRack Guards: guarding the client IT infrastructure": the story of a man who knows everything</a></li>
<li><a href="../310062/index.html">Pitfalls of conditional formatting in MS Access</a></li>
<li><a href="../310064/index.html">How to avoid mistakes using modern C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>