<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code Optimization: Memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most programmers represent the computing system as a processor that executes instructions, and a memory that stores instructions and data for the proc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code Optimization: Memory</h1><div class="post__text post__text-html js-mediator-article">  Most programmers represent the computing system as a processor that executes instructions, and a memory that stores instructions and data for the processor.  In this simple model, the memory is represented by a linear array of bytes and the processor can access any place in memory for a constant time.  Although it is an effective model for most situations, it does not reflect how modern systems actually work. <br><br>  In fact, the memory system forms a <i>hierarchy of storage devices</i> with different capacities, cost, and access time.  Processor registers store the most frequently used data.  Small fast caches, located close to the processor, serve as buffer zones that store a small amount of data located in relatively slow RAM.  RAM serves as a buffer for slow local disks.  And local disks serve as a buffer for data from remote machines connected by a network. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/a12/f8f/f00a12f8fe4d34d46718de21b3e2edd0.jpg" alt="image"></div><br>  The memory hierarchy works because well-written programs tend to access storage at a particular level more often than storage at a lower level.  So storage at a lower level may be slower, larger and cheaper.  As a result, we get a large amount of memory, which has the cost of storage at the very bottom of the hierarchy, but delivers data to the program at a speed of fast storage at the very top of the hierarchy. <br><a name="habracut"></a><br>  As a programmer, you need to understand the memory hierarchy, because it greatly affects the performance of your programs.  If you understand how the system moves data up and down the hierarchy, you can write programs that place their data higher in the hierarchy, so that the processor can access it faster. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, we explore how storage devices are organized into a hierarchy.  We especially focus on the cache memory, which serves as a buffer zone between the processor and the operational memory.  It has the greatest impact on program performance.  We will introduce the important concept of <i>locality</i> , learn how to analyze programs for locality, and also study techniques that will help increase the locality of your programs. <br><br>  I was inspired to write this article by the sixth chapter from <i>Computer Systems: A Programmer's Perspective</i> .  In another article in this series, <a href="https://habrahabr.ru/post/309796/">‚ÄúCode Optimization: The Processor,‚Äù</a> we are also fighting for processor clock speeds. <br><br><h3>  Memory matters too </h3><br>  Consider two functions that summarize the elements of a matrix.  They are almost the same, only the first function bypasses the elements of the matrix line by line, and the second - in columns. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matrixsum1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M[][size])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; size; j++) { sum += M[i][j]; <span class="hljs-comment"><span class="hljs-comment">//   } } return sum; } int matrixsum2(int size, int M[][size]) { int sum = 0; for (int i = 0; i &lt; size; i++) { for (int j = 0; j &lt; size; j++) { sum += M[j][i]; //    } } return sum; }</span></span></code> </pre> <br><br>  Both functions perform the same number of processor instructions.  But on a machine with a <i>Core i7 Haswell, the</i> first function is performed <b>25 times faster</b> for large matrices.  This example well demonstrates that <i>memory matters too</i> .  If you evaluate the effectiveness of programs only in terms of the number of instructions to be executed, you can write very slow programs. <br><br>  Data has an important property that we call <i>locality</i> .  When we work on the data, it is desirable that they are in the memory next.  Traversing the matrix in columns has poor locality, because the matrix is ‚Äã‚Äãstored in memory line by line.  We'll talk about locality below. <br><br><h3>  Memory hierarchy </h3><br>  The modern memory system forms a hierarchy from fast types of memory of small size to slow types of memory of large size.  We say that a particular hierarchy level <i>caches</i> or is a <i>cache</i> for data located at a lower level.  This means that it contains copies of data from a lower level.  When the processor wants to get some data, it first searches for it at the fastest high levels.  And goes down to the lower, if you can not find. <br><br>  At the top of the hierarchy are the processor registers.  Access to them takes 0 cycles, but there are only a few of them.  Next comes a few kilobytes of first-level cache, access to which takes about 4 clock cycles.  Then comes a couple of hundred kilobytes of a slower second-level cache.  Then a few megabytes of third-level cache.  It is much slower, but still faster than RAM.  Next is a relatively slow RAM. <br><br>  RAM can be considered as a cache for a local disk.  Disks are workhorses among storage devices.  They are big, slow and cheap.  The computer loads files from disk into RAM when it is going to work on them.  The gap in access time between the RAM and the disk is enormous.  The disk is tens of thousands of times slower than RAM, and millions of times slower than the first level cache.  It is more profitable to turn several thousand times to RAM than once to a disk.  This knowledge is supported by data structures such as <i>B-trees</i> , which try to place more information in the RAM, trying to avoid accessing the disk at any cost. <br><br>  The local disk itself can be considered as a cache for data located on remote servers.  When you visit a website, your browser saves images from a web page to disk, so that when you visit them again you don‚Äôt need to download them.  There are lower memory hierarchies.  Large data centers, such as Google, store large amounts of data on tape media that is stored somewhere in warehouses and, when needed, must be attached manually or by a robot. <br><br>  The modern system has approximately the following characteristics: <br><table><tbody><tr><th>  Cache type </th><th>  Access time (cycles) </th><th>  Cache size </th></tr><tr><td>  Registers </td><td>  0 </td><td>  dozens of pieces </td></tr><tr><td>  L1 cache </td><td>  four </td><td>  32 KB </td></tr><tr><td>  L2 cache </td><td>  ten </td><td>  256 KB </td></tr><tr><td>  L3 cache </td><td>  50 </td><td>  8 MB </td></tr><tr><td>  RAM </td><td>  200 </td><td>  8 GB </td></tr><tr><td>  Disk buffer </td><td>  100'000 </td><td>  64 MB </td></tr><tr><td>  Local disk </td><td>  10'000'000 </td><td>  1000 GB </td></tr><tr><td>  Remote servers </td><td>  1'000'000'000 </td><td>  ‚àû </td></tr></tbody></table><br>  Fast memory is very expensive, and slow is very cheap.  This is the great idea of ‚Äã‚Äãsystem architects to combine large sizes of slow and cheap memory with small sizes fast and expensive.  Thus, the system can operate at fast memory speeds and have a slow cost.  Let's see how this works out. <br><br>  Suppose your computer has 8 GB of RAM and a 1000 GB disk.  But think that you do not work with all the data on the disk at one time.  You load the operating system, open a web browser, text editor, a couple of other applications, and work with them for several hours.  All these applications are placed in RAM, so your system does not need to access the disk.  Then, of course, you close one application and open another, which you have to load from disk into RAM.  But it takes a couple of seconds, after which you work with this application for several hours without accessing the disk.  You do not particularly notice the slow disk, because at one moment you are working only with a small amount of data that is cached in RAM.  It makes no sense for you to spend huge amounts of money on installing 1024 GB of RAM into which you could load the contents of the entire disk.  If you had done this, you would have hardly noticed any difference in the work, it would be ‚Äúmoney down the drain.‚Äù <br><br>  The same is true for small processor caches.  Suppose you need to perform calculations on an array that contains 1000 elements of type <i>int</i> .  Such an array occupies 4 KB and is completely placed in the cache of the first level with a size of 32 KB.  The system understands that you started working with a certain piece of RAM.  It copies this piece into the cache, and the processor quickly performs actions on this array, enjoying the speed of the cache.  Then the modified array from the cache is copied back into RAM.  Increasing the speed of the RAM to the speed of the cache would not give a tangible increase in performance, but would increase the cost of the system hundreds and thousands of times.  But all this is true only if the programs have good locality. <br><br><h3>  Locality </h3><br>  <i>Locality</i> is the main concept of this article.  As a rule, programs with good locality run faster than programs with poor locality.  Locality is of two types.  When we refer to the same place in memory many times, it is <i>temporary locality</i> .  When we access data, and then we access other data that are located in memory next to the original data, this is <i>spatial locality</i> . <br><br>  Consider a program that summarizes the elements of an array: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) sum += A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  In this program, the call to the variables <i>sum</i> and <i>i</i> occurs at each iteration of the loop.  They have good temporal locality and will be located in fast processor registers.  Elements of array <i>A</i> have a bad temporal locality, because we refer to each element only once.  But then they have good spatial locality - by touching one element, we then touch the elements next to it.  All data in this program have either good temporal locality or good spatial locality, so we say that the program generally has good locality. <br><br>  When the processor reads data from memory, it copies it to its cache, while deleting other data from the cache.  What kind of data he chooses to delete the topic is difficult.  But the result is that if you frequently access some data, they are more likely to remain in the cache.  This is a benefit from temporal locality.  It is better for the program to work with fewer variables and access them more often. <br><br>  Data movement between levels of hierarchy is performed by blocks of a certain size.  For example, the <i>Core i7 Haswell processor</i> moves data between its caches in blocks of 64 bytes.  Consider a specific example.  We run the program on a machine with the above processor.  We have an array of <i>v</i> containing 8-byte elements of type <i>long</i> .  And we sequentially go around the elements of this array in a loop.  When we read <i>v [0]</i> , it is not in the cache, the processor reads it from RAM to the cache with a block of 64 bytes in size.  That is, elements <i>v [0]</i> - <i>v [7] are</i> sent to the cache.  Next we go around the elements <i>v [1]</i> , <i>v [2]</i> , ..., <i>v [7]</i> .  All of them will be in the cache and we will get access to them quickly.  Then we read the element <i>v [8]</i> , which is not in the cache.  The processor copies the elements <i>v [8]</i> - <i>v [15]</i> into the cache.  We quickly go around these elements, but do not find the element <i>v</i> in the cache <i>[16]</i> .  And so on. <br><br>  Therefore, if you read some bytes from memory, and then read the bytes next to them, they will most likely be in the cache.  This is a benefit of spatial locality.  It is necessary to strive at each stage of the calculation to work with the data that are located in the memory nearby. <br><br>  It is advisable to bypass the array sequentially by reading its elements one by one.  If you need to bypass the elements of the matrix, it is better to bypass the matrix line by line, rather than in columns.  This gives a good spatial locality.  Now you can understand why the <i>matrixsum2</i> function was slower than the <i>matrixsum1</i> function.  The two-dimensional array is located in memory line by line: first the first line is located, immediately after it comes the second one and so on.  The first function read the elements of the matrix line by line and moved sequentially from memory, as if bypassing one large one-dimensional array.  This function basically read the data from the cache.  The second function went from line to line, reading one element at a time.  She seemed to leap from memory from left to right, then return to the beginning and again start jumping from left to right.  At the end of each iteration, she clogged the cache with the last lines, so she did not find the first lines at the beginning of the next iteration.  This function basically read data from RAM. <br><br><h3>  Cache-friendly code </h3><br>  As programmers, you should try to write code that is <i>cache-friendly</i> .  As a rule, the main volume of calculations is performed only in a few places of the program.  Usually these are several key functions and loops.  If there are nested loops, then attention should be focused on the innermost of the loops, because the code is executed there most often.  These places of the program also need to be optimized, trying to improve their locality. <br><br>  Matrix calculations are very important in signal analysis and scientific computing applications.  If programmers have the task to write the matrix multiplication function, then 99.9% of them will write it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matrixmult1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A[][size], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B[][size], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C[][size])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; size; j++) { sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; size; k++) sum += A[i][k]*B[k][j]; C[i][j] = sum; } }</code> </pre><br>  This code literally repeats the mathematical definition of matrix multiplication.  We go around all the elements of the final matrix line by line, calculating each of them one by one.  There is one inefficiency in the code; this is the expression <i>B [k] [j]</i> in the innermost loop.  We go around matrix <i>B</i> by columns.  It would seem that nothing can be done about it and will have to accept.  But there is a way out.  You can rewrite the same calculation differently: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matrixmult2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A[][size], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B[][size], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C[][size])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> r; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; size; k++) { r = A[i][k]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; size; j++) C[i][j] += r*B[k][j]; } }</code> </pre><br>  Now the function looks very strange.  But she does absolutely the same thing.  Only we do not compute each element of the final matrix at a time; we sort of calculate the elements partly at each iteration.  But the key feature of this code is that in the internal loop we go around both matrices line by line.  On the machine with the <i>Core i7 Haswell, the</i> second function works <b>12 times faster</b> for large matrices.  You need to be a really wise programmer to organize the code in this way. <br><br><h3>  Blocking </h3><br>  There is a technique called <i>blocking</i> .  Suppose you need to perform a calculation on a large amount of data that does not all fit in the high-level cache.  You break this data into smaller blocks, each of which is cached.  Perform calculations on these blocks separately and then combine the result. <br><br>  You can demonstrate this by example.  Suppose you have a directed graph presented in the form of an adjacency matrix.  This is such a square matrix of zeros and ones, so that if the element of the matrix with the index <i>(i, j)</i> is equal to one, then there is a face from the vertex of the graph <i>i</i> to the vertex <i>j</i> .  You want to turn this directed graph into undirected.  That is, if there is a face <i>(i, j)</i> , then the opposite face <i>(j, i)</i> should appear.  Note that if the matrix is ‚Äã‚Äãrepresented visually, then the elements <i>(i, j)</i> and <i>(j, i)</i> are symmetric with respect to the diagonal.  This transformation is easy to implement in the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> G[][size])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; size; j++) G[i][j] = G[i][j] | G[j][i]; }</code> </pre><br><br>  Blocking appears naturally.  Imagine a large square matrix in front of you.  Now excise this matrix with horizontal and vertical lines to split it into, say, 16 equal blocks (four rows and four columns).  Select any two symmetric blocks.  Please note that all elements in one block have their own symmetrical elements in another block.  This suggests that the same operation can be performed on these blocks in turn.  In this case, at each stage we will work only with two blocks.  If the blocks are made small enough, they will fit in the high level cache.  Express this idea in code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> G[][size])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> block_size = size / <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   12*12  // ,     for (int ii = 0; ii &lt; size; ii += block_size) { for (int jj = 0; jj &lt; size; jj += block_size) { int i_start = ii; //  i     [ii, ii + block_size) int i_end = ii + block_size; int j_start = jj; //  j     [jj, jj + block_size) int j_end = jj + block_size; //   for (int i = i_start; i &lt; i_end; i++) for (int j = j_start; j &lt; j_end; j++) G[i][j] = G[i][j] | G[j][i]; } } }</span></span></code> </pre><br>  It should be noted that blocking does not improve performance on systems with powerful processors that do a good prefetch.  On systems that do not prefetch, blocking can greatly increase performance. <br><br>  On a machine with a <i>Core i7 Haswell processor, the</i> second function does not run faster.  On a machine with a simpler <i>Pentium 2117U processor, the</i> second function is performed <b>2 times faster</b> .  On machines that do not prefetch, performance would improve even more. <br><br><h3>  What algorithms are faster </h3><br>  Everyone knows from the courses on algorithms that you need to choose <i>good</i> algorithms with the least complexity and avoid <i>bad</i> algorithms with high complexity.  But these difficulties evaluate the execution of the algorithm on a theoretical machine created by our thought.  On real machines, a theoretically bad algorithm can run faster than a theoretically good one.  Remember that getting data from RAM takes 200 ticks, and 4 ticks from the first level cache is 50 times faster.  If a good algorithm often touches memory, and a bad algorithm places its data in the cache, a good algorithm can run slower than a bad one.  Also, a good algorithm can run worse on a processor than a bad one.  For example, a good algorithm introduces data dependency and cannot load a processor pipeline.  A bad algorithm is deprived of this problem and sends a new instruction to the pipeline on every clock cycle.  In other words, the complexity of the algorithm is not all.  How the algorithm will run on a specific machine with specific data matters. <br><br>  Imagine that you need to implement a queue of integers, and new elements can be added to any position in the queue.  You choose between two implementations: an array and a linked list.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To add an element to the middle of the array, you need to move half the array to the right, which takes linear time. To add an element to the middle of the list, you need to go through the list to the middle, which also takes linear time. You think that since they have the same complexity, it is better to choose a list. Moreover, the list has one good property. The list can grow without limit, and the array will have to expand when it is full.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we have implemented a queue with a length of 1000 elements in both ways. And we need to insert an item in the middle of the queue. The elements of the list are randomly scattered in memory, so to get around 500 elements, we need 500 * 200 = 100'000 cycles. The array is located in memory sequentially, which allows us to enjoy the first-level cache speed. Using several optimizations, we can move the elements of the array, spending 1-4 clocks per element. We will move half of the array to a maximum of 500 * 4 = 2000 cycles. That is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50 times</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> faster </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If in the previous example all the additions were to the top of the queue, the implementation with a linked list would be more efficient. If a fraction of the additions would be somewhere in the middle of the queue, implementing as an array could be the best choice. We would spend tacts on some operations and save tacts on others. And in the end, you could have won.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The memory system is organized as a hierarchy of storage devices with small and fast devices at the top of the hierarchy and large and slow devices at the bottom. </font><font style="vertical-align: inherit;">Programs with good locality work with data from processor caches. </font><font style="vertical-align: inherit;">Programs with poor locality work with data from relatively slow RAM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmers who understand the nature of the memory hierarchy can structure their programs so that the data is located as high as possible in the hierarchy and the processor receives them faster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, the following techniques are recommended:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concentrate your attention on internal cycles. </font><font style="vertical-align: inherit;">This is where the largest amount of computations and memory accesses occurs.</font></font></li><li>    ,     ,   ,      . </li><li>    ,        ,      . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/312078/">https://habr.com/ru/post/312078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312064/index.html">Microsoft StorSimple - automatic disaster recovery</a></li>
<li><a href="../312066/index.html">DBGlass - Open-Source cross-platform PostgreSQL GUI client.</a></li>
<li><a href="../312068/index.html">Live text broadcast from the conference ISDEF-2016. Second day</a></li>
<li><a href="../312070/index.html">3CX for Linux: DIY cloud-based PBX</a></li>
<li><a href="../312072/index.html">Quantum hashing. Lecture in Yandex</a></li>
<li><a href="../312080/index.html">Why I, as a developer, hate iOS</a></li>
<li><a href="../312084/index.html">DIY Password Manager</a></li>
<li><a href="../312086/index.html">Easy way to lose customers or why not use Google CDN</a></li>
<li><a href="../312088/index.html">ES6 const is not about immunity</a></li>
<li><a href="../312090/index.html">PostgreSQL integration with MS SQL Server for those who want quicker and deeper</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>