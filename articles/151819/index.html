<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Japanese Crossword Solving</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Japanese crossword puzzle is a puzzle in which you need to recreate the original black and white image by a set of numbers. Each row and each column o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Japanese Crossword Solving</h1><div class="post__text post__text-html js-mediator-article">  Japanese crossword puzzle is a puzzle in which you need to recreate the original black and white image by a set of numbers.  Each row and each column of pixels corresponds to its own set, each number in which, in turn, corresponds to the length of a block of consecutive black pixels.  There must be at least one white pixel between such blocks, but their exact number is unknown.  Magazines devoted entirely to these puzzles are in most newsstands, so I think almost everyone has met them at least once, and therefore a <a href="http://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25BF%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D1%2580%25D0%25BE%25D1%2581%25D1%2581%25D0%25B2%25D0%25BE%25D1%2580%25D0%25B4">more detailed description</a> can be <a href="http://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25BF%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D1%2580%25D0%25BE%25D1%2581%25D1%2581%25D0%25B2%25D0%25BE%25D1%2580%25D0%25B4">omitted</a> here. <br><br>  At some point I wanted to ‚Äúteach a computer‚Äù to solve Japanese crosswords in the way I solve them myself.  No high end, just for fun.  Later, methods were added that I myself cannot use due to the limited capabilities of the human brain, but, in fairness, the program copes with all the crossword puzzles from the journals without them. <br><br>  So, the task is simple: solve a crossword puzzle, and if there are many solutions, then find them all.  The solution is written in Haskell, and, although the code rather substantially complements the verbal description, even without knowledge of the language, the general essence can be understood.  If you want to feel the result live, on <a href="http://code.google.com/p/jc-solver/">the project page</a> you can download the source code (I did not post binary builds).  Solutions are exported to Binary PBM, and conditions can be extracted from it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/c55/d43/65a/c55d4365aac6ddfd8c0fa6a31b6ca7df.png"><br><br>  Despite the fact that I tried to write as clearly as possible, I did not fully succeed.  There are a lot of letters and code under the cut and almost no pictures. <br><a name="habracut"></a><br><h4>  Bitmask </h4><br>  The basis of the entire program is your bike for a bit mask.  It is not too fast, but it has a property that was important to me during the debugging process: it drops during operations that have no meaning, namely, during any operation on masks of different lengths.  I will give here only the signatures of functions and a picture explaining the principle of their work;  the implementation is very primitive and has no direct relation to the solution. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bmCreate</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmLength :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> bmSize :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> bmIsEmpty :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> bmNot :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmAnd :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmOr :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmIntersection :: [<span class="hljs-type"><span class="hljs-type">BitMask</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmUnion :: [<span class="hljs-type"><span class="hljs-type">BitMask</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmSplit :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BitMask</span></span>] bmByOne :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BitMask</span></span>] bmExpand :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmFillGaps :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmLeftIncursion :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmRightIncursion :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> bmTranspose :: [<span class="hljs-type"><span class="hljs-type">BitMask</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">BitMask</span></span>]</code> </pre> <br><img src="https://habrastorage.org/storage2/1f7/b60/f89/1f7b60f89600b809f7e72583e4ff4128.png"><br><br>  I think that such a graphic description is exhaustive for all functions, except, perhaps, <code>bmLeftIncursion</code> and <code>bmRightIncursion</code> .  Why they are needed, it will be clear later, the principle of their work is the following: <code>bmLeftIncursion</code> finds the leftmost filled bit and creates a mask in which all the bits before it are filled, as well as so many bits since it, as specified when calling the function;  the second function works the same way. <br><br><h4>  Structure </h4><br>  Since the solution of a crossword puzzle is along lines, the type corresponding to the entire field is a set of all horizontal and vertical lines, although this leads to the duplication of all cells of the crossword puzzle. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flHorLines</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Line</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flVerLines</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Line</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span></span></code> </pre><br>  Each line stores information about cells and blocks (the block corresponds to the number in the condition). <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Line</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Line</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lnMask</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LineMask</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lnBlocks</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span></span></code> </pre><br>  Information about cells is stored in the form of two bit masks of the same length, representing filled and blocked cells. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LineMask</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LineMask</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lmFilledMask</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BitMask</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lmBlockedMask</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BitMask</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span></span></code> </pre><br>  The block, in addition to the number itself, contains a mask that corresponds to the area of ‚Äã‚Äãthe line in which this block may be located. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blScopeMask</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BitMask</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blNumber</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span></span></code> </pre><br>  At the beginning of the solution, the masks of painted and blocked cells are empty, and the block mask, on the contrary, is completely filled.  This means that all cells are empty, and each block can be in any part of the line.  The solution process is to narrow the area of ‚Äã‚Äãeach block to a size equal to its number, and fill the masks accordingly. <br><br><h5>  Completion and synchronization </h5><br>  All of the above types (except <code>BitMask</code> ) are instances of two classes: <code>Completable</code> and <code>Syncable</code> . <br><br>  The only function of the <code>Completable</code> class is showing the "completeness" of an object.  A field is considered complete if all its lines are completed.  A line is completed if all its blocks are completed;  the completeness of the mask is unnecessary to demand (it follows from the completeness of the blocks; why, again, it will be clear a little later).  To complete a block, as mentioned above, it is necessary that the size of its area coincides with its number. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Completable</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> clIsCompleted :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Completable</span></span> <span class="hljs-type"><span class="hljs-type">Field</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> clIsCompleted fl = all clIsCompleted (flHorLines fl) &amp;&amp; all clIsCompleted (flVerLines fl) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Completable</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> clIsCompleted ln = all clIsCompleted (lnBlocks ln) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Completable</span></span> <span class="hljs-type"><span class="hljs-type">Block</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> clIsCompleted bl = bmSize (blScopeMask bl) == blNumber bl</code> </pre><br>  The <code>Syncable</code> class provides functions that allow you to bring together different solution branches.  <code>snAverage</code> distinguishes from two branches only the general, and <code>snSync</code> - that manifested itself in at least one branch (we can consider them as generalizations of the <code>bmAnd</code> and <code>bmOr</code> respectively).  <code>snAverageAll</code> and <code>snSyncAll</code> do exactly the same thing, but they work not with two objects, but with lists of objects. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Syncable</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> snSync :: a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a sn1 `snSync` sn2 = snSyncAll [sn1, sn2] snAverage :: a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a sn1 `snAverage` sn2 = snAverageAll [sn1, sn2] snSyncAll :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a snSyncAll [] = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> snSyncAll sns = foldr1 (wrap snSync) (map return sns) snAverageAll :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a snAverageAll [] = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> snAverageAll sns = foldr1 (wrap snAverage) (map return sns) wrap :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; (a -&gt; b -&gt; mc) -&gt; ma -&gt; mb -&gt; mc wrap f mx my = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- mx y &lt;- my fxy</code> </pre><br><h5>  Consistency </h5><br>  From the description of the functions of the <code>Syncable</code> class <code>Syncable</code> clear that their result is an object wrapped in the <code>Maybe</code> monad.  In fact, this is how the important concept of consistency manifests itself, which is also defined for all the above types, but not in a separate class for reasons of encapsulation.  As an example, the same cell cannot be simultaneously painted over and blocked;  if any operation can lead to such a situation, then it is labeled with the <code>Maybe</code> monad (usually has the type <code>type TransformFunction a = a -&gt; Maybe a</code> ), and if it leads to this situation, then the result is <code>Nothing</code> , because no object in the program can exist in an inconsistent state.  Since <code>Nothing</code> , in turn, cannot be a component of other objects, the entire field will become inconsistent, which will mean the absence of solutions. <br><br>  The consistency of the field is provided by the synchronization of horizontal and vertical lines.  Thus, if a cell is in some state (painted over, blocked or empty) in a horizontal line, then it is in exactly the same state in a corresponding vertical line, and vice versa. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">flEnsureConsistency</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Field</span></span> flEnsureConsistency fl = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lnsHor = flHorLines fl <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lnsVer = flVerLines fl lnsHor' &lt;- zipWithM lnSyncWithLineMask (lmTranspose $ map lnMask lnsVer) lnsHor lnsVer' &lt;- zipWithM lnSyncWithLineMask (lmTranspose $ map lnMask lnsHor) lnsVer return $ <span class="hljs-type"><span class="hljs-type">Field</span></span> lnsHor' lnsVer' lnSyncWithLineMask :: <span class="hljs-type"><span class="hljs-type">LineMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> lnSyncWithLineMask lm ln = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lm' &lt;- lm `snSync` lnMask ln return ln { lnMask = lm' }</code> </pre><br>  We will talk about consistency of the line later, as it is directly related to the decision process. <br><br>  The consistency of the block is provided nontrivially: for it, it is necessary to exclude those continuous parts that cannot accommodate it from the block area.  Thus, if from a block area with the number 3 and the source area <img src="http://habrastorage.org/storage2/cae/e3b/63b/caee3b63b5eda7a1ad90c514755b38a9.png">  exclude mask <img src="http://habrastorage.org/storage2/a64/187/654/a64187654ef577efbb96485da625386e.png">  (for example, due to the fact that this cell was blocked), then the final result of this operation will be a block with <img src="http://habrastorage.org/storage2/5a7/27e/c5b/5a727ec5b5fe71d58e366aa65f16974c.png">  and not at all <img src="http://habrastorage.org/storage2/c2b/5ba/f48/c2b5baf481b133a241b94dbfdf711f2e.png">  . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">blEnsureConsistency</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Block</span></span> blEnsureConsistency bl = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bms = filter ((blNumber bl &lt;=) . bmSize) $ bmSplit $ blScopeMask bl guard $ not $ null bms return bl { blScopeMask = bmUnion bms }</code> </pre><br>  For a mask, consistency is obvious and has already been described above: you cannot simultaneously paint over and block the same cell. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lmEnsureConsistency</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">LineMask</span></span> lmEnsureConsistency lm = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> guard $ bmIsEmpty $ lmFilledMask lm `bmAnd` lmBlockedMask lm return lm</code> </pre><br><h5>  Transformations </h5><br>  The transformation operations of masks and blocks are very limited, because in the process of solving the cells you can only paint over and block (you can not change your mind, take an eraser and erase it), and you can only narrow the area of ‚Äã‚Äãthe block. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lmFill</span></span> :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">LineMask</span></span> lmFill bm lm = lmEnsureConsistency lm { lmFilledMask = lmFilledMask lm `bmOr` bm } lmBlock :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">LineMask</span></span> lmBlock bm lm = lmEnsureConsistency lm { lmBlockedMask = lmBlockedMask lm `bmOr` bm } blExclude :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Block</span></span> blExclude bm bl = blEnsureConsistency $ bl { blScopeMask = blScopeMask bl `bmAnd` bmNot bm } blKeep :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Block</span></span> blKeep bm bl = blEnsureConsistency $ bl { blScopeMask = blScopeMask bl `bmAnd` bm }</code> </pre><br><h4>  Decision </h4><br>  The decision process will be considered in separate parts, until they finally develop into the big picture. <br><br><h5>  Line consistency </h5><br>  To begin, restore the gap left in the section on consistency, and declare that the line is considered consistent if its mask is filled in accordance with its blocks.  Behind this phrase are two points.  First, those cells that do not fall into the area of ‚Äã‚Äãany block should be blocked (if the line does not contain a single block, then all cells are, respectively). <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnUpdateBlocked</span></span> :: [<span class="hljs-type"><span class="hljs-type">Block</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">LineMask</span></span> lnUpdateBlocked [] lm = lmBlock (bmNot $ lmBlockedMask lm) lm lnUpdateBlocked bls lm = lmBlock (bmNot $ bmUnion $ map blScopeMask bls) lm</code> </pre><br>  Secondly, for each block, using the <code>blToFillMask</code> function, <code>blToFillMask</code> can get a mask that you need to paint over.  It is the intersection of two masks, obtained by ‚Äúdriving‚Äù the block into the leftmost and rightmost parts of its area. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">blMinimumLeftMask</span></span> :: <span class="hljs-type"><span class="hljs-type">Block</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> blMinimumLeftMask bl = bmLeftIncursion (blNumber bl) (blScopeMask bl) blMinimumRightMask :: <span class="hljs-type"><span class="hljs-type">Block</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> blMinimumRightMask bl = bmRightIncursion (blNumber bl) (blScopeMask bl) blToFillMask :: <span class="hljs-type"><span class="hljs-type">Block</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">BitMask</span></span> blToFillMask bl = blMinimumLeftMask bl `bmAnd` blMinimumRightMask bl lnUpdateFilled :: [<span class="hljs-type"><span class="hljs-type">Block</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">LineMask</span></span> lnUpdateFilled [] = return lnUpdateFilled bls = lmFill (bmUnion $ map blToFillMask bls)</code> </pre><br>  <i>(Note: here we finally used the <code>bmLeftIncursion</code> and <code>bmRightIncursion</code> . Strictly speaking, if they were used only for this purpose, then most likely they would have looked a little different, namely they would not fill the bit mask to the very first bit the original mask.)</i> <br><br>  Thus, as mentioned earlier, the consistency condition for a line guarantees that its mask will always be completed if all its blocks are completed. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnEnsureConsistency</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> lnEnsureConsistency ln = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bls = lnBlocks ln lm &lt;- lnUpdateBlocked bls &gt;=&gt; lnUpdateFilled bls $ lnMask ln return $ ln { lnMask = lm }</code> </pre><br><h5>  Simple line conversion </h5><br>  The solution within the line is essentially reduced to two transformations. <br><br>  The first transformation, in fact, is inverse to the consistency condition: it guarantees that the blocks will be completed if the mask is completed.  Three actions are used for this. <br><br><ol><li>  All blocked cells must be excluded from the areas of all blocks. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnRemoveBlocked</span></span> :: <span class="hljs-type"><span class="hljs-type">LineMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> [<span class="hljs-type"><span class="hljs-type">Block</span></span>] lnRemoveBlocked = mapM . blExclude . lmBlockedMask</code> </pre><br></li><li>  If the block cannot accommodate any continuous shaded part of the mask (that is, if it crawls out of the block area or has a size larger than its number), then it should be excluded from the block area. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnRemoveFilled</span></span> :: <span class="hljs-type"><span class="hljs-type">LineMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> [<span class="hljs-type"><span class="hljs-type">Block</span></span>] lnRemoveFilled lm = mapM (\ bl -&gt; foldM f bl $ bmSplit $ lmFilledMask lm) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f bl bm = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> blCanContainMask bm bl <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> return bl <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> blExclude (bmExpand bm) bl blCanContainMask :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Block</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> blCanContainMask bm bl = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bm' = bmFillGaps bm <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bmSize bm' &lt;= blNumber bl &amp;&amp; bmIsEmpty (bm' `bmAnd` bmNot (blScopeMask bl))</code> </pre><br></li><li>  <code>blMinimumLeftMask</code> its left neighbor and <code>blMinimumRightMask</code> right neighbor should be excluded from the area of ‚Äã‚Äãeach block (here they are needed exactly in the form described above).  To be precise, these masks are expanded by one cell, since there must be at least one empty cell between the blocks. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnExcludeNeighbours</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> [<span class="hljs-type"><span class="hljs-type">Block</span></span>] lnExcludeNeighbours bls = sequence $ scanr1 (flip $ wrap $ blExclude . bmExpand . blMinimumRightMask) $ scanl1 (wrap $ blExclude . bmExpand . blMinimumLeftMask) $ map return bls</code> </pre><br></li></ol>  Together, these actions form the following function (the <code>slLoop</code> function will be described later): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnSimpleTransform</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> lnSimpleTransform ln = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lm = lnMask ln bls &lt;- lnRemoveBlocked lm &gt;=&gt; slLoop (lnRemoveFilled lm &gt;=&gt; lnExcludeNeighbours) $ lnBlocks ln lnEnsureConsistency ln { lnBlocks = bls }</code> </pre><br><h5>  Second line transform </h5><br>  If we take the leftmost of all blocks, which in principle can contain some shaded part of the mask, then its extreme right position will be limited to this mask itself, because if it moves further to the right, then there will be no one to ‚Äúgive‚Äù this shaded area.  The same considerations are true for the rightmost of such blocks. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnExtremeOwners</span></span> :: <span class="hljs-type"><span class="hljs-type">BitMask</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> [<span class="hljs-type"><span class="hljs-type">Block</span></span>] lnExtremeOwners bm bls = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> bls' &lt;- fmap reverse $ maybe (return bls) (f bmLeftIncursion bls) (h bls) fmap reverse $ maybe (return bls') (f bmRightIncursion bls') (h bls') <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fg = varyNth (\ bl -&gt; blKeep (g (blNumber bl) bm) bl) h = findIndex (blCanContainMask bm) varyNth :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; (a -&gt; ma) -&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; m [a] varyNth f xs idx = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (xs1, x : xs2) = splitAt idx xs x' &lt;- fx return $ xs1 ++ x' : xs2</code> </pre><br>  Applying this reasoning to each continuous part of the mask, we obtain the second transformation of the line: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnTransformByExtremeOwners</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> lnTransformByExtremeOwners ln = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> bls &lt;- foldM (flip lnExtremeOwners) (lnBlocks ln) $ bmSplit $ lmFilledMask $ lnMask ln lnEnsureConsistency ln { lnBlocks = bls }</code> </pre><br><h5>  Field conversion </h5><br>  The field has no special transformations of its own, the only option for it is to take some ready-made transformation and apply it to all its lines. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">flTransformByLines</span></span> :: <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> <span class="hljs-type"><span class="hljs-type">Field</span></span> flTransformByLines f fl = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lnsHor &lt;- mapM f (flHorLines fl) fl' &lt;- flEnsureConsistency fl { flHorLines = lnsHor } lnsVer &lt;- mapM f (flVerLines fl') flEnsureConsistency fl' { flVerLines = lnsVer }</code> </pre><br><h5>  Branching </h5><br>  Since the solution of Japanese crosswords is an NP-complete problem, it will not be possible to do without branching.  A branch is defined by a function of type <code>type ForkFunction a = a -&gt; [[a]]</code> , where the internal list includes mutually exclusive options, and the external list contains various ways to produce these options. <br><br>  The simplest way is branching into cells: each empty cell spawns one element of the external list, which in turn is a list of two elements, in one of which this cell is filled and in the other one is blocked. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnForkByCells</span></span> :: <span class="hljs-type"><span class="hljs-type">ForkFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> lnForkByCells ln = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lm = lnMask ln bm &lt;- bmByOne $ lmEmptyMask lm return $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> lm' &lt;- [fromJust $ lmBlock bm lm, fromJust $ lmFill bm lm] maybeToList $ lnEnsureConsistency ln { lnMask = lm' } flForkByCells :: <span class="hljs-type"><span class="hljs-type">ForkFunction</span></span> <span class="hljs-type"><span class="hljs-type">Field</span></span> flForkByCells fl = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lnsHor = flHorLines fl <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lnsVer = flVerLines fl idx &lt;- findIndices (not . clIsCompleted) lnsHor <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (lns1, ln : lns2) = splitAt idx lnsHor lns &lt;- lnForkByCells ln return $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ln' &lt;- lns maybeToList $ flEnsureConsistency $ <span class="hljs-type"><span class="hljs-type">Field</span></span> (lns1 ++ ln' : lns2) lnsVer</code> </pre><br>  For the line, another branching method is also available: for each continuous shaded part of the mask (external list), we can consider a set of blocks that can contain it (internal list) as options defining branches. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lnForkByOwners</span></span> :: <span class="hljs-type"><span class="hljs-type">ForkFunction</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> lnForkByOwners ln = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bls = lnBlocks ln bm &lt;- bmSplit $ lmFilledMask $ lnMask ln <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> findIndices (blCanContainMask bm) bls <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [_] -&gt; [] idxs -&gt; return $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> idx &lt;- idxs maybeToList $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> bls' &lt;- varyNth (g bm) bls idx lnEnsureConsistency ln { lnBlocks = bls' } <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> g bm bl = blKeep ((bmAnd `on` ($ bm) . ($ blNumber bl)) bmLeftIncursion bmRightIncursion) bl</code> </pre><br><h5>  Generalized functions </h5><br>  Most of the changes it makes sense to apply iteratively.  In this case, you can simply apply the transformation as long as it changes at least something, but it is possible (in the case when an extra application can take a considerable amount of time) to preliminarily check the object for completeness. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">slLoop</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a slLoop fx = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x' &lt;- fx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == x' <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> return x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> slLoop fx' slSmartLoop :: (<span class="hljs-type"><span class="hljs-type">Completable</span></span> a, <span class="hljs-type"><span class="hljs-type">Eq</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a slSmartLoop fx | clIsCompleted x = return x | otherwise = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x' &lt;- fx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == x' <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> return x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> slLoop fx'</code> </pre><br>  The results of the branch can be processed regardless of the specific data type and branching method.  To do this, applying a certain branching method, and then applying any transformation to each resulting object, for each set of mutually exclusive branches, it is necessary to take an average value, and then synchronize these averaged objects obtained by different branch points.  I will not describe in detail, but an optimized version is also available for this operation, which is related to completeness testing. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">slForkAndSyncAll</span></span> :: (<span class="hljs-type"><span class="hljs-type">Syncable</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">ForkFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a slForkAndSyncAll fgx = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> xs &lt;- mapM (snAverageAll . mapMaybe g) $ fx snSyncAll (x : xs) slForkAndSmartSync :: (<span class="hljs-type"><span class="hljs-type">Syncable</span></span> a, <span class="hljs-type"><span class="hljs-type">Completable</span></span> a, <span class="hljs-type"><span class="hljs-type">Eq</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">ForkFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a slForkAndSmartSync fgx = foldr h (return x) (fx) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> h xs mx = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x' &lt;- mx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clIsCompleted x' <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> mx <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> mapMaybe (snSync x') xs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> xs' -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> filter (/= x') xs' <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; return x' xs'' -&gt; snAverageAll . mapMaybe g $ xs''</code> </pre><br>  Finally, if nothing else helps, you can go into recursion.  Only in this way you can get all the solutions, if there are several. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">slAllSolutions</span></span> :: (<span class="hljs-type"><span class="hljs-type">Completable</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">ForkFunction</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TransformFunction</span></span> a -&gt; a -&gt; [a] slAllSolutions fgx = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x' &lt;- maybeToList $ gx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clIsCompleted x' <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> return x' <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> fx' <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> (xs : _) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x'' &lt;- xs slAllSolutions fg x'' [] -&gt; []</code> </pre><br><h5>  Fina venko </h5><br>  Everything.  The tools available are enough to get a solver in a few simple steps. <br><br><ol><li>  Combine the two line transformations. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lineTransform</span></span> = slSmartLoop $ lnSimpleTransform &gt;=&gt; lnTransformByExtremeOwners</code> </pre><br></li><li>  Process line-specific branching. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lineTransform'</span></span> = slForkAndSyncAll lnForkByOwners lineTransform</code> </pre><br></li><li>  We compose a field transform from these two transformations. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fieldTransform</span></span> = slSmartLoop $ slSmartLoop (flTransformByLines lineTransform) &gt;=&gt; flTransformByLines lineTransform'</code> </pre><br></li><li>  We process the results of the field branching in the cells. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fieldTransform'</span></span> = slForkAndSmartSync flForkByCells fieldTransform</code> </pre><br></li><li>  Combine the previous two conversions. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fieldTransform''</span></span> = slSmartLoop $ fieldTransform &gt;=&gt; fieldTransform'</code> </pre><br></li><li>  And finally, add recursion. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">solve</span></span> = slAllSolutions flForkByCells fieldTransform''</code> </pre><br></li></ol><h4>  Afterword </h4><br>  The program works fairly quickly on crosswords that have the only solution: approximately out of the thousands of crosswords I have on my laptop, only two (including the preface) are solved for more than a minute, almost all fit in 10 seconds, and none required recursion. <br><br>  Theoretically, with some refinement, the program can be used to automatically assess the complexity of crossword puzzles (since the solution methods are generally similar to those used by humans) and proof of the uniqueness of the solution;  There is an export to LaTeX, and it may even appear soon in SVN.  So if you wish, you can organize a home issue of magazines :) </div><p>Source: <a href="https://habr.com/ru/post/151819/">https://habr.com/ru/post/151819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151813/index.html">Office, which make holidays!</a></li>
<li><a href="../151814/index.html">Practical tips for efficient code inspection</a></li>
<li><a href="../151815/index.html">Application Cache API - new features and problems</a></li>
<li><a href="../151816/index.html">Such a dangerous Internet Explorer ...</a></li>
<li><a href="../151818/index.html">How to restore data in Storelab</a></li>
<li><a href="../15182/index.html">Hip-hip, hurray!</a></li>
<li><a href="../151820/index.html">Indie Gala 9</a></li>
<li><a href="../151821/index.html">Million particle. Part 1</a></li>
<li><a href="../151822/index.html">New edition of the changes in the Civil Code: open licenses, providers responsibility and other interesting points</a></li>
<li><a href="../151826/index.html">How do NFC payments work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>