<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the development of web-applications on PSGI / Plack. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the permission of the author and chief editor of the magazine PragmaticPerl.com, I continue to publish a series of articles. 
 The original artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the development of web-applications on PSGI / Plack. Part 2</h1><div class="post__text post__text-html js-mediator-article">  With the permission of the author and chief editor of the magazine PragmaticPerl.com, I continue to publish a series of articles. <br>  <a href="http://pragmaticperl.com/issues/03/pragmaticperl-03-%25D0%25B2%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25B2-%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D1%2583-web-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-%25D0%25BD%25D0%25B0-psgiplack.-%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-2..html">The original article is here.</a> <br>  <i>Continuing the article on PSGI / Plack.</i>  <i>Plack :: Builder, as well as Plack :: Middleware are considered in more detail.</i> <br><br>  In the last article, we looked at the PSGI specification, how it came out, why it should be used.  We considered Plack - the implementation of PSGI, its main components and wrote the simplest API that performed the tasks assigned to it, briefly examined the main PSGI server. <br><br>  In the second part of the article we will consider the following points: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Plack :: Builder is a powerful router and not only. </li><li>  Plack :: Middleware - we expand our capabilities with the help of "layers". </li></ul><br><a name="habracut"></a><br>  We still use Starman, which is a preforking server (uses a model of pre-running processes). <br><br><h2>  A closer look at Plack :: Builder </h2><br>  In the previous article, we briefly reviewed Plack :: Builder.  Now it's time to look at it in more detail.  The decision to consider Plack :: Builder with Plack :: Middleware is quite logical, because they are very closely interconnected.  Considering these two components in different articles, both articles would contain cross-references to each other, which is not very convenient in a journal format. <br><br>  The basic Plack :: Builder construction looks like this: <br><br><pre><code class="perl hljs">builder { mount <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> =&gt; builder { $bar }; }</code> </pre> <br><br>  This construction tells us that the PSGI application ($ bar) will be located at / foo.  What we wrapped in the builder must be a reference to the function, otherwise we may get an error of the following form: <br><br>  Can not use the string ("stupid string") as a subroutine ref while "strict refs" in use at /usr/local/share/perl/5.14.2/Plack/App/URLMap.pm line 71. <br><br><br>  Routes can be nested, for example: <br><br><pre> <code class="perl hljs">builder { mount <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> =&gt; builder { mount <span class="hljs-string"><span class="hljs-string">'/bar'</span></span> =&gt; builder { $bar; }; mount <span class="hljs-string"><span class="hljs-string">'/baz'</span></span> =&gt; builder { $baz; }; mount <span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; builder { $foo; }; }; };</code> </pre><br><br>  This entry means that the $ foo application will be located at the / foo address, the $ bar application at the / foo / bar address, and the $ baz application at the / foo / baz address, respectively. <br><br>  However, no one bothers to write the previous entry in the following form: <br><br><pre> <code class="perl hljs">builder { mount <span class="hljs-string"><span class="hljs-string">'/foo/bar'</span></span> =&gt; builder { $bar }; mount <span class="hljs-string"><span class="hljs-string">'/foo/baz'</span></span> =&gt; builder { $baz }; mount <span class="hljs-string"><span class="hljs-string">'/foo/'</span></span> =&gt; builder { $foo }; };</code> </pre><br><br>  Both entries are equivalent and perform the same task, but the first one looks simpler and clearer.  Plack :: Builder can be used in object-oriented style, but I personally find it more convenient to use it in a procedural form.  Using Plack :: Builder in an object-oriented form looks like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $builder = Plack::Builder-&gt;new; $builder-&gt;mount(<span class="hljs-string"><span class="hljs-string">'/foo'</span></span> =&gt; $foo_app); $builder-&gt;mount(<span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; $root_app); $builder-&gt;to_app;</code> </pre><br><br>  This entry is equivalent to: <br><br><pre> <code class="perl hljs">builder { mount <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> =&gt; builder { $app; }; mount <span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; builder { $app2; }; };</code> </pre><br><br>  Which of the ways to use is a purely individual matter.  We will return to reviewing Plack :: Builder after becoming familiar with Plack :: Middleware. <br><br><h2>  Plack :: Middleware </h2><br>  Plack :: Middleware is the base class for writing, as CPAN tells us, ‚Äúeasy-to-use PSGI layers‚Äù.  What is it for?  Consider the example of the implementation of a certain API. <br><br>  Imagine that our application code looks like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $api_app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string} &amp;&amp; $params-&gt;{string} eq <span class="hljs-string"><span class="hljs-string">'data'</span></span>) { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'not ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $api_app }; }</code> </pre><br>  This application works fine, but now imagine that all you need to do is receive data only if it is transmitted using the POST method. <br><br>  A trivial solution is to bring our application to the following form: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $api_app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'POST'</span></span>) { $res-&gt;status(<span class="hljs-number"><span class="hljs-number">403</span></span>); $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string} &amp;&amp; $params-&gt;{string} eq <span class="hljs-string"><span class="hljs-string">'data'</span></span>) { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'not ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); };</code> </pre><br><br>  It took only 4 lines to solve the problem.  And now let's imagine that it was necessary to make another application, which should also accept data sent only by the POST method.  What do we do?  Write in each of this condition?  This is not an option for several reasons: <br><br><ul><li>  The amount of code increases, and as a result its entropy (simple is better than complex). </li><li>  More likely to make a mistake (human factor). </li><li>  If we transfer the project to another programmer, he may forget and do something wrong (human factor). </li></ul><br>  So, we formulate the problem.  We cannot make all our applications simultaneously acquire certain properties without changing their code.  Or can we? <br><br>  The Middleware mechanism is great for providing end-to-end functionality to the entire application.  It is, of course, necessary to feel the measure and add only the code really necessary for the whole program. <br><br>  In order to build your Middleware (your layer, in other words), you must achieve the following conditions: <br><br><ul><li>  Be in the package Plack :: Middleware :: MYCOOLMIDDLEWARE, where MYCOOLMIDDLEWARE is the name of your Middleware. </li><li>  Extend the base class Plack :: Middleware (use parent qw / Plack :: Middleware /;). </li><li>  Implement the method (function) call. </li></ul><br><br>  So, we implement the simplest Middleware considering all of the above: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Plack::Middleware::PostOnly; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> parent <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/Plack::Middleware/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Response; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $env) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'POST'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">405</span></span>); $new_res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $new_res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $self-&gt;app-&gt;($env); }</code> </pre><br>  Let's take a closer look at what happened.  There is a code that is in the Plack :: Middleware package (1 point), which inherits the base class Plack :: Middleware (2 point), implements the call method (3 point). <br><br>  The presented call implementation does the following: <br><br><ul><li>  Takes an instance of Plack :: Middleware and env (my ($ self, $ env) = @_;) as parameters. </li><li>  Creates a request that the application accepts (creation is similar to that used in the previous examples). </li><li>  Checks if the POST request method is not, if it is, then Middleware skips processing the request further. </li></ul><br><br>  Consider what happens if the request method is not POST. <br><br>  If the method is not POST, a new Plack :: Response object is created and immediately returned without invoking the application. <br><br>  In general, the call function in Middleware can do exactly 2 actions.  It: <br><br><ul><li>  Processing env BEFORE executing an application. </li><li>  Processing result AFTER the application is executed. </li></ul><br><br>  This will be illustrated at the end of the article, when we summarize and understand the nuances. <br><br><h2>  Sharing Plack :: Middleware and Plack :: Builder </h2><br>  There is a ready Plack :: Middleware :: PostOnly layer, we have a PSGI application, we have a problem.  I remind you that the problem looks like this: ‚ÄúAt the moment we cannot globally influence the behavior of applications‚Äù.  Now we can.  Consider the most important point of Plack :: Builder - the enable keyword. <br><br>  The enable keyword allows you to connect Plack :: Middleware to an application.  This is done as follows: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { enable <span class="hljs-string"><span class="hljs-string">"PostOnly"</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $api_app; }; }</code> </pre><br>  This is a very simple and very powerful mechanism at the same time.  Combine all the code in one place and look at the result. <br><br>  PSGI application: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Middleware::PostOnly; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $api_app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'WORKS'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string} &amp;&amp; $params-&gt;{string} eq <span class="hljs-string"><span class="hljs-string">'data'</span></span>) { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'not ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { enable <span class="hljs-string"><span class="hljs-string">"PostOnly"</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $api_app }; }</code> </pre><br>  Middleware: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Plack::Middleware::PostOnly; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> parent <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/Plack::Middleware/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Response; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $env) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'POST'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">405</span></span>); $new_res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $new_res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $self-&gt;app-&gt;($env); }</code> </pre><br>  The application is launched by the following command: <br><br><pre> <code class="bash hljs">/usr/bin/starman --port 8080 app.psgi</code> </pre><br><br>  The code used to enable ‚ÄúPostOnly‚Äù because Plack :: Builder automatically substitutes for the name of the Plack :: Middleware package.  It is written to enable ‚ÄúPostOnly‚Äù, meaning ‚ÄúPlack :: Middleware :: PostOnly‚Äù (refer to the full path to your class using the prefix +, for example, enable "+ MyApp :: Middleware :: PostOnly"; - approx. editor). <br><br>  Now, if you contact the address <a href="http://localhost/">localhost</a> : 8080 / with the help of the GET method, you will receive a message that Method not allowed with the response code 405, whereas if you use the POST method, everything will be fine. <br><br>  Not for nothing in the application code there is a warn string "WORKS".  It confirms the lack of execution of the application, if the method is not POST.  Try sending GET, you will not see this message in STDERR starman. <br><br>  PSGI servers still have quite a few interesting features of behavior, they will definitely be discussed in the following articles. <br><br>  Let us consider some more useful points of Plack :: Middleware, namely: <br><br><ul><li>  Processing of the results AFTER the execution of the application. </li><li>  Passing parameters to Middleware. </li></ul><br><br>  Suppose there are two PSGI applications and you need to make sure that one works through POST, and the other only through GET.  You can solve the problem in the forehead by writing another Middleware, which will respond only to the GET method, for example, like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Plack::Middleware::GetOnly; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> parent <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/Plack::Middleware/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Response; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $env) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'GET'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">405</span></span>); $new_res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $new_res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $self-&gt;app-&gt;($env); }</code> </pre><br><br>  The problem is solved, however, a lot of duplication remains. <br><br>  The solution to this problem is the best way to deal with the following things: <br><ul><li>  Mechanisms for transferring variables to Middleware. </li><li>  Connecting Middleware for applications individually. </li></ul><br><br>  The solution to the problem is to pass the desired method as a variable.  Let us return to the consideration of enable from Plack :: Builder.  It turns out that enable can accept variables.  It looks like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { enable <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, <span class="hljs-string"><span class="hljs-string">one =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'two'</span></span>, <span class="hljs-string"><span class="hljs-string">three =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'four'</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $api_app }; }</code> </pre><br>  In Middleware itself, these variables can be accessed directly via $ self.  For example, in order to get the value passed to the one variable, you need to refer to $ self -&gt; {one} in the Middleware code.  We continue to change PostOnly. <br><br>  Example: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Plack::Middleware::GetOnly; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> parent <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/Plack::Middleware/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Response; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $env) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> $self-&gt;{one} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $self-&gt;{one}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'GET'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">405</span></span>); $new_res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $new_res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $self-&gt;app-&gt;($env); }</code> </pre><br>  Restart the starman, make a request to localhost: 8080, in STDERR we see the following: <br><br><pre> <code class="bash hljs">two at /home/noxx/perl/lib/Plack/Middleware/PostOnly.pm line 12.</code> </pre><br>  This is how variables are passed to Plack :: Middleware. <br><br>  Using this mechanism, we write Middleware, which will now be called Only. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Plack::Middleware::Only; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> parent <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/Plack::Middleware/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Response; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $env) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $method = $self-&gt;{method}; $method ||= <span class="hljs-string"><span class="hljs-string">'ANY'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($method <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'ANY'</span></span> &amp;&amp; $req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> $method) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">405</span></span>); $new_res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $new_res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $self-&gt;app-&gt;($env); } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Now Middleware can only respond to the request method passed in the parameters.  A slightly different connection looks like this: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { enable <span class="hljs-string"><span class="hljs-string">"Only"</span></span>, <span class="hljs-string"><span class="hljs-string">method =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'POST'</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $api_app }; };</code> </pre><br>  In this case, the application will be executed only if the request method was POST. <br><br>  Consider processing results AFTER application execution.  Suppose that if the method is allowed, the word ‚ÄúALLOWED‚Äù should be added to the response body. <br><br>  That is, if the application should give ok, it will return ok ALLOWED, if, of course, the request is executed with a valid method. <br><br>  Let's bring Only.pm to the following form: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Plack::Middleware::Only; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> parent <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/Plack::Middleware/; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Response; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $env) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $method = $self-&gt;{method}; $method ||= <span class="hljs-string"><span class="hljs-string">'ANY'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($method <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'ANY'</span></span> &amp;&amp; $req-&gt;method() <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> $method) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $new_res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">405</span></span>); $new_res-&gt;body(<span class="hljs-string"><span class="hljs-string">'Method not allowed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $new_res-&gt;finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $plack_res = $self-&gt;app-&gt;($env); $plack_res-&gt;[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;[<span class="hljs-number"><span class="hljs-number">0</span></span>] .= <span class="hljs-string"><span class="hljs-string">'ALLOWED'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $plack_res; } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  $ self-&gt; app -&gt; ($ env) returns a reference to an array of three elements (PSGI-specification), whose body is modified and given as an answer. <br><br>  You can make sure that everything works and works as it should, passing the variable string = data and string = data1 by the allowed method.  In the first case, if the method is allowed, the answer will look ‚ÄúokALLOWED‚Äù, in the second ‚Äúnot okALLOWED‚Äù. <br><br>  And in conclusion, let us consider exactly how you can combine all of the above in one Plack-application.  We return to the original problem.  It is necessary to develop a simple API that accepts the string variable and if string = data answer ok, otherwise not ok, and also observe the following rules: <br><br>  When contacting / responding to any method. <br>  When contacting the / post address, respond only to the POST method. <br>  When contacting / get, respond only to the GET method. <br>  In fact, you need exactly one application that is written - $ api_app and a slightly modified builder. <br><br>  As a result, using all of the above, you should get an application of the following form: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Middleware::PostOnly; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Middleware::Only; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $api_app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $params = $req-&gt;parameters(); <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'RUN!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($params-&gt;{string} &amp;&amp; $params-&gt;{string} eq <span class="hljs-string"><span class="hljs-string">'data'</span></span>) { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $res-&gt;body(<span class="hljs-string"><span class="hljs-string">'not ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { mount <span class="hljs-string"><span class="hljs-string">"/post"</span></span> =&gt; builder { enable <span class="hljs-string"><span class="hljs-string">"Only"</span></span>, <span class="hljs-string"><span class="hljs-string">method =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'POST'</span></span>; $api_app; }; mount <span class="hljs-string"><span class="hljs-string">"/get"</span></span> =&gt; builder { enable <span class="hljs-string"><span class="hljs-string">"Only"</span></span>, <span class="hljs-string"><span class="hljs-string">method =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'GET'</span></span>; $api_app; }; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $api_app; }; }; };</code> </pre><br>  Thus, the Middleware connection works in nested Plack :: Builder routes.  It is worth paying attention to the simplicity and logic of the code. <br><br>  The delayed response will be discussed in one of the articles devoted to asynchronous servers (Twiggy, Corona, Feersum). </div><p>Source: <a href="https://habr.com/ru/post/247733/">https://habr.com/ru/post/247733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247721/index.html">How to sell to large companies: 16 tips. Part 1</a></li>
<li><a href="../247723/index.html">Ethical hacking and penetration testing courses. New set</a></li>
<li><a href="../247725/index.html">Speeding Selenium Autotest on Ruby</a></li>
<li><a href="../247727/index.html">A simple task manager with a web interface, on GO for Unix systems, including Android</a></li>
<li><a href="../247731/index.html">Draw an animated scene using css</a></li>
<li><a href="../247735/index.html">Io.js 1.0.0 is coming</a></li>
<li><a href="../247737/index.html">Mobile traffic is being stolen from Adwords (redirecting to some recseek)</a></li>
<li><a href="../247741/index.html">Yii 2.0.2</a></li>
<li><a href="../247749/index.html">Microsoft Azure raises prices in Russia by 44%</a></li>
<li><a href="../247751/index.html">Introduction to machine learning using Python and Scikit-Learn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>