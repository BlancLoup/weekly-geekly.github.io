<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some details about templates or fork-bomb compilation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I became interested in instantiating plus templates. The term code bloat is used on the Internet . For c ++, this can mean an uncontrolled in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some details about templates or fork-bomb compilation</h1><div class="post__text post__text-html js-mediator-article">  Recently I became interested in instantiating plus templates.  The term <a href="http://www.daniweb.com/software-development/cpp/threads/346683/template-code-bloat">code bloat is used on the Internet</a> .  For c ++, this can mean an <s>uncontrolled</s> increase in the code generated by the compiler.  The code is increased due to the fact that the instantiation of a new function has a higher priority than the conversion of arguments to a more convenient type.  Those.  template T foo (T a);  for int and char, these are two different functions.  You can get one function either by rejecting templates, or using explicit type conversion. <br>  But let's turn the problem inside out and try to get the executable file of the maximum possible size from a minimum of lines of code. <br>  The result was not very impressive - I only got 53Mb of 60 lines of code.  And then only for one of the three tested compilers and at the cost of several hours of compilation.  The maximum volume / line ratio is 2.3MB / line for a 14MB volume. <br>  How and why it happened - under the cut. <br><a name="habracut"></a><br><h4>  Resources </h4>  One laptop with 4GB of memory, <br>  Intel¬Æ Core (TM) i3-2330M CPU @ 2.20GHz processor <br>  Linux OS 3.7.3-101.fc17.x86_64 <br>  and disabled swap partition. <br>  The swap had to be turned off for the same reason that a fork bomb appeared in the title of the post.  With a sufficiently large volume of tasks, the compiler left all the memory and began to actively exchange with the disk, which tightly and permanently hung up the machine. <br><br>  Compiler Versions: <br><ul><li>  g ++ (GCC) 4.7.2 20120921 (Red Hat 4.7.2-2) <br></li><li>  Intel¬Æ C ++ Intel¬Æ 64 Compiler for Applications running on Intel¬Æ 64, Version 13.1.1.163 Build 20130313 <br></li><li>  clang version 3.3 (trunk 179304) <br></li></ul><br><br><h4>  Long arrays </h4>  The easiest way is to organize an array of the commerce step and string functions on it.  Like this: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{nop&lt;n<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;();<span class="hljs-keyword"><span class="hljs-keyword">asm</span></span>(<span class="hljs-string"><span class="hljs-string">"nop"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> nop&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;() {<span class="hljs-keyword"><span class="hljs-keyword">asm</span></span>(<span class="hljs-string"><span class="hljs-string">"nop"</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ** argv)</span></span></span><span class="hljs-function"> </span></span>{ nop&lt;LVL&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  As a result, the main () function should be filled with empty <s>useless</s> <b>nop</b> operations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The size of the nop sequence is theoretically determined by the depth of the recursion.  The g ++ mane states that the maximum depth is 17 and 1024 for c ++ 11. <br><div class="spoiler">  <b class="spoiler_title">Quote from mana</b> <div class="spoiler_text">  -ftemplate-depth = n <br>  Set the maximum depth depth for the template classes to n.  Depth limit is needed <br>  to detect endless recursions during template class instantiation.  <b>ANSI / ISO C ++ conforming</b> programs must not rely on a <br>  maximum depth greater than 17 (changed to 1024 in C ++ 11).  The default value is 900, as the compiler can run out of <br>  stack space before hitting 1024 in some situations. <br></div></div>  In the standards of specific numbers, I did not find.  There was only a point that the maximum depth of recursion is determined by the implementation: <br>  4.7.1.14 for c ++ 03 <br>  4.7.1.15 for c ++ 11 <br>  Which was confirmed by experience.  For a sufficiently large LVL compilers crashed.  I was surprised by clang ++ which crashed to 2 <sup>13</sup> , in contrast to g ++ and icpc reaching 2 <sup>17</sup> . <br><br>  The assembly was carried out by the teams: <br><pre> <code class="bash hljs"> clang++ -DLVL=$(( 2**<span class="hljs-variable"><span class="hljs-variable">$n</span></span>)) -o list<span class="hljs-variable"><span class="hljs-variable">$n</span></span> ./list.cc -ftemplate-depth=3000000 -O<span class="hljs-variable"><span class="hljs-variable">$x</span></span> g++ -DLVL=$(( 2**<span class="hljs-variable"><span class="hljs-variable">$n</span></span>)) -o list<span class="hljs-variable"><span class="hljs-variable">$n</span></span> ./list.cc -ftemplate-depth=3000000 -O<span class="hljs-variable"><span class="hljs-variable">$x</span></span> icpc -DLVL=$(( 2**<span class="hljs-variable"><span class="hljs-variable">$n</span></span>)) -o list<span class="hljs-variable"><span class="hljs-variable">$n</span></span> ./list.cc -O<span class="hljs-variable"><span class="hljs-variable">$x</span></span></code> </pre>  within <div class="spoiler">  <b class="spoiler_title">build script</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#/bin/bash MIN=0 MAX=19 for i in 2; do mkdir -p attempt$i cd attempt$i for CXX in clang++ g++ icpc do mkdir -p $CXX cd $CXX for O in O0 O1 O2 O3 Os do mkdir -p $O cd $O (while :;do free -m |grep Mem|awk '{print $3}' &gt;&gt; ./memory;sleep 1;done)&amp; TIME=$! for i in $(seq $MIN $MAX) do # CMD="$CXX -$O ../../../fbomb.cc -DLVL=$i -o fbomb$i" #-save-temps=obj " CMD="$CXX -$O ../../../list.cc -DLVL=$(( 2 ** $i)) -o list$i -ftemplate-depth=3000000" #-save-temps=obj " echo $CMD $CMD sleep 5 sleep 5 done kill -9 $TIME cd .. done cd .. done cd .. done</span></span></code> </pre><br></div></div>  Binaries were collected consistently and for a long time.  For each compiler, for each level of optimization.  Assembly results are shown as graphs.  Four columns of images: <br><ol><li>  The dependence of memory on time.  These graphs are given for reference only, because  at compile time, the X server and the browser worked, but the main trends are visible. </li><li>  The size of the binary file.  Maximum turned out - 14MB </li><li>  Characters.  The inline keyword is only recommending to the compiler, so for large N. The Nops are grouped into normal functions.  They are calculated as follows: <pre> <code class="bash hljs">nm --demangle ./list<span class="hljs-variable"><span class="hljs-variable">$i</span></span>|grep nop|wc -l</code> </pre> </li><li>  The number of honest nop-s.  Calculated from the disassembler: <pre> <code class="bash hljs">objdump -d ./list<span class="hljs-variable"><span class="hljs-variable">$i</span></span>|grep <span class="hljs-string"><span class="hljs-string">'nop$'</span></span>|wc -l</code> </pre> </li></ol><br>  <b>It looks like the images are scaled correctly only in chrome.</b> <br>  For other browsers <div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/1c7/71d/227/1c771d227db7b9e3b4be95b50790562a.png"></div></div>  and a link to the <a href="http://www.filedropper.com/allpicturestar">archive</a> with all the images <br><div class="spoiler">  <b class="spoiler_title">Pictures</b> <div class="spoiler_text"><h5>  Comparison of different levels of optimization for the same compilers </h5><br><table><tbody><tr><th>  Memory consumption at compile time <br></th><th>  Executable file size <br></th><th>  The number of characters in the executable file <br></th><th>  Number of nop operations <br></th></tr><tr><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/b40/8d2/3bf/b408d23bf406db55dcec51d1f413f9fd.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/138/bf2/615/138bf2615b888a4aa18cd5b9e8f7d7e5.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/353/13e/270/35313e27065450f12b2f0994e3d06483.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/093/3fd/573/0933fd573838fb130bb1c536ed8202c8.png"><br></td></tr><tr><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/fb9/66b/fc6/fb966bfc642c96b88b1954a9d7fa87ed.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/eb8/d19/856/eb8d198562cf70f191d4d35390519cfd.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/c65/c77/31a/c65c7731ae120f3fd663c2f7cf2d89e3.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/94e/530/7cc/94e5307cca6a03aa182bb0089ee5ef5b.png"><br></td></tr><tr><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/990/55b/865/99055b86593c76816633db98fc40799c.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/e0f/35a/29f/e0f35a29ff935d2b90763c6254b2d155.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/664/611/733/6646117336ef5772e42b3522bfd5d1c3.png"><br></td><td><img width="20%" height="20%" src="https://habrastorage.org/storage2/565/203/3df/5652033df7c356cbb82fe3d857347a76.png"><br></td></tr></tbody></table><br><br><h5>  Comparing different compilers with different levels of optimization </h5><br><table><tbody><tr><th>  Memory consumption at compile time <br></th><th>  Executable file size <br></th><th>  The number of characters in the executable file <br></th><th>  Number of nop operations <br></th></tr><tr><td><img src="https://habrastorage.org/storage2/c75/50f/59c/c7550f59c2bd13c1d5321edb9eec0dca.png"><br></td><td><img src="https://habrastorage.org/storage2/212/93e/a15/21293ea15548ad2a8037d0316885b119.png"><br></td><td><img src="https://habrastorage.org/storage2/ba0/238/720/ba02387200c630c661a9e5444b07f480.png"><br></td><td><img src="https://habrastorage.org/storage2/b26/9c9/045/b269c904554eff24d2983b852fd26196.png"><br></td></tr><tr><td><img src="https://habrastorage.org/storage2/53e/2ec/d76/53e2ecd7674a680ce1553d88fea096f1.png"><br></td><td><img src="https://habrastorage.org/storage2/b8c/e73/123/b8ce73123f8b1a871a27e92b908342ea.png"><br></td><td><img src="https://habrastorage.org/storage2/cdb/ec6/a09/cdbec6a09b2eabfddb5e6af3fd8a5c12.png"><br></td><td><img src="https://habrastorage.org/storage2/ab0/150/9ab/ab01509ab64b396271ac05e6ef0767cc.png"><br></td></tr><tr><td><img src="https://habrastorage.org/storage2/99b/5b2/475/99b5b24752d39b2822c505163b5ceeef.png"><br></td><td><img src="https://habrastorage.org/storage2/5bc/d71/bb0/5bcd71bb029b496af0e22e6d7599d008.png"><br></td><td><img src="https://habrastorage.org/storage2/d0b/acd/d30/d0bacdd30aeb099e968a82cc4c909cb0.png"><br></td><td><img src="https://habrastorage.org/storage2/2cf/007/bd7/2cf007bd7fd50768ad98eb8ecac92338.png"><br></td></tr><tr><td><img src="https://habrastorage.org/storage2/0d9/f45/bfc/0d9f45bfc9c87e9d0c8c14a8506f0ac5.png"><br></td><td><img src="https://habrastorage.org/storage2/f6a/694/fd8/f6a694fd8f7e412cab0b6399aa66ac1f.png"><br></td><td><img src="https://habrastorage.org/storage2/cc2/c19/300/cc2c19300a47ba874e165c4fcc399ce8.png"><br></td><td><img src="https://habrastorage.org/storage2/470/189/9d6/4701899d65c3830d3a1477a9179129e3.png"><br></td></tr><tr><td><img src="https://habrastorage.org/storage2/c91/bda/963/c91bda9637da2bb8560b3eabbfb4763b.png"><br></td><td><img src="https://habrastorage.org/storage2/ce9/35c/18c/ce935c18c4a731dccd807c999cb7e835.png"><br></td><td><img src="https://habrastorage.org/storage2/f62/307/959/f62307959aeb5ecd6fd51edc01a328e6.png"><br></td><td><img src="https://habrastorage.org/storage2/800/d4c/338/800d4c338de81850dbc95b3ee482ec59.png"><br></td></tr></tbody></table></div></div>  The maximum file size is 14MB for 2 <sup>17</sup> icpc compilers.  For g ++ - 12 MB.  Both at O0.  The O0 optimization level does not perform inline substitution, so the number of nop &lt;long&gt; characters is the same as the number of nop operations. <br><br><h4>  Tall trees </h4>  For a linear data structure, the size of the generated file is limited by at least the maximum recursion depth of the default (256 for clang ++, 900 for g ++).  To get around it, you can try to create a tree.  The maximum theoretical depth of the compilation tree is (sizeof (long) -1) == 63. A 2 <sup>64</sup> bytes will overflow any disk.  The practical limit is much less. <br>  Using a tree, we do not go beyond the maximum depth of recursion. <br>  The source code takes 19 lines and looks like this: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LVL # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LVL 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> long x = 0; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int N=LVL, long I=0&gt; struct foo{ inline static double bar(double m) {x++;return foo&lt;N-1,I&gt;::bar(m) + foo&lt;N-1,((1&lt;&lt;(LVL-N))|I)&gt;::bar(m) + I;}; }; template&lt;long I&gt; struct foo&lt;0,I&gt;{ inline static double bar(double m) {x++; return m;} }; #include &lt;iostream&gt; int main(int argc, char **argv){ double ret = foo&lt;&gt;::bar(argc); std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; ret &lt;&lt; std::endl; return int(ret); }</span></span></span></span></code> </pre><br>  The result is a tree, each node of which has its own type.  Each type is characterized by a pair of numbers: <br><ul><li>  N is the level number; </li><li>  I - node number level. </li></ul><br>  Each node within the same level is numbered from 0 to N. <br><br>  I did not bother with the nop-s here, I used addition.  Global long x - used to control the correctness of the assembly.  As a result, returns 2 <sup>LVL + 1</sup> . <br><br>  The assembly was carried out by the teams: <br><pre> <code class="bash hljs"> clang++ -DLVL=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> -o fbomb<span class="hljs-variable"><span class="hljs-variable">$n</span></span> ./fbomb.cc -O<span class="hljs-variable"><span class="hljs-variable">$x</span></span> g++ -DLVL=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> -o fbomb<span class="hljs-variable"><span class="hljs-variable">$n</span></span> ./fbomb.cc -O<span class="hljs-variable"><span class="hljs-variable">$x</span></span> icpc -DLVL=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> -o fbomb<span class="hljs-variable"><span class="hljs-variable">$n</span></span> ./fbomb.cc -O<span class="hljs-variable"><span class="hljs-variable">$x</span></span></code> </pre>  in the same scenario as above. <br>  The maximum LVL turned out to be 18 for clang ++.  For g ++ and icpc - 16, and regardless of whether the option - std = c ++ 11 was specified or not.  The compilers did not have enough memory. <br><br>  <b>It looks like the images are scaled correctly only in chrome.</b> <br>  For other browsers <div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/cbf/a94/81d/cbfa9481d9c11c83d238f7b6d7efc688.png"></div></div>  and a link to the <a href="http://www.filedropper.com/allpicturestar">archive</a> with all the images <br><div class="spoiler">  <b class="spoiler_title">Pictures for the tree</b> <div class="spoiler_text"><table><tbody><tr><th>  Memory consumption at compile time <br></th><th>  Executable file size <br></th><th>  The number of characters in the executable file <br></th></tr><tr><td><img src="http://habrastorage.org/storage2/4d1/5f6/fc8/4d15f6fc85a2a8628177c02dc28b0eed.png"><br></td><td><img src="http://habrastorage.org/storage2/2f1/8dd/684/2f18dd68496113cd7e67b11927848bd5.png"><br></td><td><img src="http://habrastorage.org/storage2/35b/375/e6e/35b375e6ed4bdf98b75caecae44f21f1.png"><br></td></tr><tr><td><img src="http://habrastorage.org/storage2/9f9/267/110/9f9267110c187ab47c8e108006260421.png"><br></td><td><img src="http://habrastorage.org/storage2/1ad/5df/2cc/1ad5df2cc8159b40400a92f500d9820a.png"><br></td><td><img src="http://habrastorage.org/storage2/8ef/c53/e91/8efc53e9139936bbf18f69fa7e3680c6.png"><br></td></tr><tr><td><img src="http://habrastorage.org/storage2/4d5/019/9d6/4d50199d6df321a3a363851555943e4f.png"><br></td><td><img src="http://habrastorage.org/storage2/fbe/b1a/28e/fbeb1a28e4ac32061c51f3ebb63f7b15.png"><br></td><td><img src="http://habrastorage.org/storage2/7ca/13b/93e/7ca13b93e951e92337d40a3cda088aa4.png"><br></td></tr></tbody></table><table><tbody><tr><th>  Memory consumption at compile time <br></th><th>  Executable file size <br></th><th>  The number of characters in the executable file <br></th></tr><tr><td><img src="http://habrastorage.org/storage2/4d2/d27/c7e/4d2d27c7e075ca689625f55a9b74ff5f.png"><br></td><td><img src="http://habrastorage.org/storage2/1cb/6d9/025/1cb6d9025abe46044f234450406351f6.png"><br></td><td><img src="http://habrastorage.org/storage2/83e/cec/0c1/83ecec0c1af8dc24edb00aecf2fd5745.png"><br></td></tr><tr><td><img src="http://habrastorage.org/storage2/b61/284/ec5/b61284ec5234aefb365e54d311b087ec.png"><br></td><td><img src="http://habrastorage.org/storage2/144/350/893/144350893d11d375518a85df366c1282.png"><br></td><td><img src="http://habrastorage.org/storage2/600/2b5/32c/6002b532c0237bcf362145b24be90696.png"><br></td></tr><tr><td><img src="http://habrastorage.org/storage2/b28/c33/38c/b28c3338c65dca138bf3d59ab8242c7a.png"><br></td><td><img src="http://habrastorage.org/storage2/e10/29a/c73/e1029ac73f7609aeff4a57c01c8caca5.png"><br></td><td><img src="http://habrastorage.org/storage2/e26/0b3/dfb/e260b3dfbdfe7e6976ba0b971ff8892f.png"><br></td></tr><tr><td><img src="http://habrastorage.org/storage2/11d/061/2e5/11d0612e59a9abd06646b490e47e96f7.png"><br></td><td><img src="http://habrastorage.org/storage2/143/61f/4a3/14361f4a3f96f1e3fe683790b6d412c7.png"><br></td><td><img src="http://habrastorage.org/storage2/4e1/dc9/d11/4e1dc9d117dd126d586cea0e072ac18f.png"><br></td></tr><tr><td><img src="http://habrastorage.org/storage2/b8d/454/811/b8d454811c5906a219e3012790f443fe.png"><br></td><td><img src="http://habrastorage.org/storage2/086/dc3/503/086dc350396272908ab10d0f83d34cee.png"><br></td><td><img src="http://habrastorage.org/storage2/827/d59/1af/827d591afbd745bcd34896caf0e39e50.png"><br></td></tr></tbody></table><br></div></div><br>  Maximum file size: <br><ul><li>  43MB for icpc -O0 -DLVL = 17; <br></li><li>  42MB for clang ++ -O0 -DLVL = 17; <br></li><li>  22MB for g ++ -O0 -DLVL = 16. <br></li></ul><br><br><h4>  Explicit instantiation </h4>  43MB is not so little, but is it possible to make the file even more with a given amount of RAM?  It turned out possible, but only one compiler out of three - icpc.  To do this, use external templates and explicit instantiation. <br>  We modify the source code a little so that all template parameters are specified when describing it.  We divide the source code into three files ‚Äî the template description, the main function, and the partial instantiation of the subtrees: <br><div class="spoiler">  <b class="spoiler_title">fbomb.hh</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L=LVL, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N=L, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> I=<span class="hljs-number"><span class="hljs-number">0</span></span>&gt; struct foo{ <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> bar(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> m) {x++;<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo&lt;L,N<span class="hljs-number"><span class="hljs-number">-1</span></span>,I&gt;::bar(m) + foo&lt;L,N<span class="hljs-number"><span class="hljs-number">-1</span></span>,((<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;(LN))|I)&gt;::bar(m) + I;}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> I&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">&lt;L,0,I&gt;{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m)</span></span></span><span class="hljs-function"> </span></span>{x++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m;} };</code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">main.cc</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fbomb.hh"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//for i in $(seq 0 13);do echo "extern template struct foo&lt;LVL,L,$i&gt;;";done #define L (LVL-5) extern template struct foo&lt;LVL,L,0&gt;; extern template struct foo&lt;LVL,L,1&gt;; extern template struct foo&lt;LVL,L,2&gt;; extern template struct foo&lt;LVL,L,3&gt;; ... extern template struct foo&lt;LVL,L,30&gt;; extern template struct foo&lt;LVL,L,31&gt;; #include &lt;iostream&gt; long x = 0; int main(int argc, char **argv){ double ret = foo&lt;LVL&gt;::bar(argc); std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; ret &lt;&lt; std::endl; return int(ret); }</span></span></span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">part.cc</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">&lt;LVL, _L, _I&gt;;</span></span></code> </pre><br></div></div>  It turned out that g ++ -c main.cc -DLVL = 21 crashes due to lack of memory as well as with full instantiation, regardless of the version of the standard.  The same situation for clang ++.  Icpc compiles main.cc in less than a second.  However, the compilation of subtrees took more than 4 hours: <pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq 0 31);<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">:"</span></span>;date; icpc -O2 -c ./part.cc -o part21_16_<span class="hljs-variable"><span class="hljs-variable">$io</span></span> -DLVL=21 -D_L=16 -D_I=<span class="hljs-variable"><span class="hljs-variable">$i</span></span>;sleep 10; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Memory consumption during subtree compilation</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/5bf/b44/248/5bfb44248763866ba30b5d87ad9f0d44.png"><br></div></div>  Linker took less than a minute.  The result is a 53MB file.  This file was built with -O2.  -O0 would give a larger size, but I didn‚Äôt reassemble it several times because of the time <s>and meaninglessness of the</s> result. <br><br>  The largest volume / number of lines = 2.3Mb / string was obtained for the array from the first part (icpc -O0 list.cc) <br>  Metric is of course funny, but funny.  2.3 - the maximum that happened.  I would be glad to know if someone gets more relevant. <br><br>  Good luck to us all. <br><br>  <b>Upd</b> : Strip did not, but it would be necessary.  I thought there was a couple of kilobytes - but it turned out to be a percentage of the size, and quite large.  After strip, the maximum size dropped to 37MB (from 53).  and 8.6MB (p 14).  Accordingly, the ratio is 1.43MB / string. </div><p>Source: <a href="https://habr.com/ru/post/179137/">https://habr.com/ru/post/179137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../179115/index.html">Linux / Cdorked.A: Web servers running Lighttpd and nginx at risk</a></li>
<li><a href="../179119/index.html">The evolution of SVP. Directions free</a></li>
<li><a href="../179123/index.html">What is dangerous rebase, or how it happened that 2 * 3 = 5</a></li>
<li><a href="../179131/index.html">How in the application to get a list of files transferred from Explorer using Drag-and-Drop</a></li>
<li><a href="../179135/index.html">India launches tracking system for all calls, SMS and Internet activity</a></li>
<li><a href="../17914/index.html">Search Blog from Yandex</a></li>
<li><a href="../179141/index.html">Why is the work not an apartment?</a></li>
<li><a href="../179143/index.html">Away Builder. Or our proud Varyag does not surrender to the enemy.</a></li>
<li><a href="../179145/index.html">Boris is a small but reliable REPL for php</a></li>
<li><a href="../179149/index.html">MikroTik - quick setup of the access point</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>