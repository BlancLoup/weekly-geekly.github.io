<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop worrying and start working?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time when we talked about the work of our team, many were interested in the details of organizing the work of the developers themselves, which we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop worrying and start working?</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/agile/105008/">Last time</a> when we talked about the work of <a href="http://www.e-kontur.ru/">our</a> team, many were interested in the details of organizing the work of the developers themselves, which we will now tell about.  One should not expect ‚Äúbreaks in covers‚Äù and discoveries, because everything that developers do has been described and discussed more than once, but what we do together in real large projects is not done very often (to be honest, I don‚Äôt saw).  That is, you should not expect something, but ‚Äúcover breaks‚Äù will occur :) <br><br>  The reality is that Agile without the correct engineering practices will end very quickly.  If you do not make efforts that guarantee a high level of development quality and the state of the system as a whole, then as the project becomes more complex, control will be quickly lost.  As a result, you will not be able to do everything planned in the iteration, and you will only dream about a significant release (meaningful means with some kind of functionality that will be available to users, and not just refactoring) that stabilizing an important release will take much more than a month. <br><br>  With the right approach, the development of new functionality can occur quite quickly and the trick here is how not to break what was done before or quickly understand exactly what you broke and fix it quickly.  Each time it is very long and inefficient to test all the details and nuances manually, because in the Elbe today there are already more than 400 ‚Äúscreens‚Äù.  And the problem is not only that testers have to check all this manually - a lot of time is spent on the script ‚Äútester added a bug - the developer fixed the bug - the tester checked and closed / rediscovered the bug‚Äù.  One can argue for a long time about how difficult it is to keep a fast-growing system in a stable state, why the code turns into a shit, why it's scary to make corrections, and no one takes the liberty to tell the release date even to the nearest month (because it would be irresponsible), but It is much more interesting to learn how to make it good. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><h4>  Tests, tests, tests </h4><br>  I wrote the word "tests" 3 times, not because repeating words three times is fun, but because we use 3 types of tests: <br><ol><li>  Modular tests of business logic.  Elbe is a set of several services interacting with each other (web, data storage, reference service, print service, etc.) All these services and the server part of the web are written in TDD style.  About TDD said and written a lot.  I believe that the main advantage of this methodology is the creation of a situation in which writing tests is not a routine or boring job.  Gradually build up the tests and fanatically write the code just enough for the current set of unit tests to pass, but not a single line more is a lot of fun, it's such a mental game, like chess.  In addition, honestly covering each line of your code with unit tests, you get a more perfect code.  Fanaticism is appropriate here: if a code has arisen that can be erased and not a single test has fallen, this code should be erased immediately, for educational purposes.  It is worth saying that the idea of ‚Äã‚Äãa good code is different for everyone: students consider the code to be compiled perfect, and some developers any code that works.  Fortunately, one can not argue about this.  The finest man <a href="http://butunclebob.com/">Uncle Bob</a> long ago summarized everything that should be summarized in the field of the formal characteristics of good code and wrote a series of articles about it.  We in Elba consider the code that satisfies the principles of <a href="http://ru.wikipedia.org/wiki/SOLID_%2528%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%2529">SOLID to</a> be good.  If you still do not know that this is not a Haskell developer, then there is a chance that you are living in the wrong way or in vain :) The code covered with modular tests is easy to build and modify: tests guarantee the immutability of the old business logic, and SOLIDITY allows you to make important changes purely locally (you do not have copy-paste and 3 classes that do the same thing?) - you achieve the stated goal, the development speed is not reduced and everything happens with the specified quality. <br><br></li><li>  Unit Tests for client javascript.  Server-side business logic is fine, but end users see the web application.  And they do not want to just watch the dull pages, everything should fly and explode.  Therefore, we write a lot of client logic.  There is nothing new in comparison with server-side business logic: the code should be SOLID and covered with tests, just another language.  In this way, we test general-purpose classes and controls (for example, client validators). <br><br></li><li>  Functional tests of the web application.  All unit tests can pass, but this does not guarantee that the user does not have any problems with a particular page.  We do not test with unit tests for filling in the fields of each form and processing these fields on the server.  To fix the correct behavior of the end pages, we use functional tests.  In fact, we repeat the user's behavior: we click on the link, we expect the page to load with a certain set of fields, fill these fields, check the validation of validation, click on the ‚Äúsave‚Äù button and make sure that exactly what was written in the fields is settled in our repository.  Even if on the page, depending on some conditions, some small inscription changes - there is a test for it.  If the developer says that it is impossible to test all the conditions for which he wrote the code, then he wrote this code drunk or lying (we are talking about the usual business logic, and not about <a href="http://habrahabr.ru/blogs/development/92038/">scientific applications</a> , for example).  This is how a test can look like: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeEmailWithGoodPassword</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> newEmail = <span class="hljs-string"><span class="hljs-string">"hello_habr@gmail.com"</span></span>; Prepare(); emailSettingsPage.Email.TypeValueAndWait(newEmail); emailSettingsPage.Password.TypeValueAndWait(<span class="hljs-string"><span class="hljs-string">"superpassword"</span></span>); emailSettingsPage.SaveButton.Click(); emailSettingsPage.WaitSaveSucceded(); emailSettingsPage = emailSettingsPage.Refresh(); emailSettingsPage.Email.WaitValue(newEmail); }</code> </pre> <br>  But what happens when you run the test: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/2n6OtEWcTuo%3Ffeature%3Doembed&amp;xid=17259,15700002,15700021,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhi1W_7dzDJo4PK-j_Vja-ItMEWlkA" frameborder="0" allowfullscreen=""></iframe><br><br>  To write such clear tests, we build abstractions for them over pages and controls, thanks to which the complexity of their support is greatly reduced, the readability is increased, and even the ability to write TDD functional tests appears! </li></ol><br><h4>  Running tests </h4><br>  Tests are written in order to run them, so it is very important that tests run easily (with one button!), Start instantly and work out quickly.  Then the developers will actually run them.  Our unit tests are exactly the way they behave, 1700 tests work out in 2 minutes.  With functional tests, things are not so simple, because each test involves loading the page (often several) with subsequent verification.  It takes from a few to tens of seconds.  But taking into account the fact that we have more than 2000 functional tests in total, it takes about 7 hours to run all the tests on one machine.  Obviously, there has not yet been born such a developer who has enough patience to wait for all the functional tests to pass.  Therefore, the developer runs either the tests just written, or those that test the modified pages.  After that, the developer makes a commit, and a build server comes into play, which, communicating with the version control system, realizes that something new has appeared and adds the commit to the queue.  The queue is raked by agents ‚Äî physical or virtual machines, the purpose of which is to run the entire set of tests for each commit.  We use 20 agents in order to verify the correctness of work in all browsers relevant to us.  You can easily see the list of fallen tests and start raising them.  At the same time, we have several branches in the version control system (stable and branches in which we make new features).  And for every major branch, we let in agents. <br><br><img src="https://habrastorage.org/storage1/3c59827a/14f8bec0/872cb4d0/eab34703.png"><br><br>  Special mention should be given to the time when we raise the tests.  It is impossible to delay here.  I heard that in some teams at Microsoft, all work stops and does not resume as long as there is at least one dropped test.  To be honest, we didn‚Äôt try and do tests every day (the engineer on duty does it), and before each release, during stabilization (in severe cases, the whole team). <br><br>  As a result, the test code in the lines is approximately equal to the system code.  We managed to build a serious infrastructure for launch.  What motivates us to do this?  We have long understood that without tests for long periods of time, we will spend more time on development.  Many of you probably more than once participated in discussions of what the next big commit could break, and then night after fire corrected what they didn‚Äôt think about and what was not found by the testers.  Or you came to the conclusion that important refactoring, which will speed up the work or make the code better, you cannot afford at all, because identifying the problems that have arisen will take unpredictable time.  It is very pleasant to feel control over what is happening and to understand that any change in the system is real.  Writing complex systems is not an easy task, and writing systems that always work well, often changing, but resistant to change, are an order of magnitude more difficult. <br><br><h4>  Pair programming </h4><br>  We write almost all the code in pairs and strive for general ownership of the code.  That is, we have no separation: server programmer, client or, say, a database developer.  Any team member can take on any task.  It is clear that the competence and involvement in the project or in some of its areas is different for everyone, so we use pairs to spread knowledge.  And even together much more fun.  Fair.  And the most important thing is that it is not slower at all - when working in a pair, developers are not at all distracted by outside affairs. <br><br><h4>  Pre-commit code review </h4><br>  In a situation of common ownership of the code, it is quite reasonable to show that the couple is going to commit to another member of the team most immersed in this topic.  First, explaining to the reviewer what they have just written, the couple eventually understands this completely.  Secondly, the reviewer very quickly sees some very stupid problems and points to them.  Thirdly, the information is distributed from a couple to another developer - this is also great. <br><br><h4>  Planning </h4><br>  This, of course, cannot be called engineering practice in its pure form, just planning is such an important part of the life of the development team that it is absolutely impossible not to talk about it.  Everything I wrote about above was related to quality, but quality cannot be the only goal.  Good code, lots of tests and releases that are very stable, but occur every six months or less, will quickly lead the project to a dead end.  This can work in a custom development, if you have a client who understands what he wants, is ready to pay for it well and is waiting for just a qualitative realization of his desires.  In all other cases, more frequent releases are needed in order to be able to verify the correctness of their ideas and correct them.  In the end, you need to understand what the team will be able to do in the next few weeks with a high degree of confidence.  A pair of programming and general knowledge of the code requires that all developers understand the tasks in the same way before starting work.  We provide this with the help of planning poker - a well-known practice of teams using flexible development methodologies.  The classic approach is that the team recruits several tasks in the next iteration of development (we use two-week iterations) and votes how many ‚Äúideal‚Äù hours each task will take.  Our know-how consists in an innovative form of presenting voting results, we use the following mindmap: <br><br><img src="https://habrastorage.org/storage1/90c5e175/fbc5f8d5/967c6377/7616a59a.jpg"><br><br>  The letters are the name of the task, and the numbers are the hours that resulted from the game of poker.  But the great thing is that we overestimate the situation every day.  For each task is determined by the progress - how much has already been done.  As a result, at a very early stage, we can respond to any force majeure, so we don‚Äôt need to wait until the end of the iteration to understand that the team does not have time, or, on the contrary, is ready to take on additional tasks in the iteration. <br><br><h4>  Bugs </h4><br>  There are no bugs only where the developer‚Äôs foot has not gone.  And if we consider that we have the desire to make a meaningful release once a month, that is, there is every chance to drown in bugs, because there is no time to fix them.  Still it is necessary to take into account that usually fixing bugs is a rather unplanned occupation.  When the number of bugs reaches a critical mass, you have to feverishly fix them, which can destroy all plans. <br><br>  We face this problem and found a way out that seems to be working - the days of bugs.  At first we had one day of bugs in the iteration, but the number of bugs continued to grow anyway.  Therefore, we have introduced another day of bugs, which is held in the second week of the iteration.  Thus, we always know that we have two days in the iteration set aside for bugs, and we take this into account when planning.  It should be noted that this situation arose not immediately, but relatively recently.  At first, we somehow managed without it. <br><br><h4>  Refactoring </h4><br>  What <s>Russian</s> programmer does not like refactoring?  Despite the fact that the presence of tests makes it possible to fairly easily perform any refactoring, it is still not always possible to devote enough time to it for the same reason that the number of bugs grows - release once a month.  If a bug can be closed (or not closed), without losing anything (and not even demotivating), then getting involved in refactoring, it is sometimes impossible and no place to retreat.  To solve this problem, another day in the iteration is allocated under the "day of free creativity", in which you can do anything: refactor, do some magical things.  And someone on this day, paradoxically as it may seem, has fixed bugs at will! <br><br><h4>  Duty engineer </h4><br>  It is not always possible to postpone the correction of a bug until the day specially allotted for corrections.  And technical support, call center and analysts every day there are various questions and requests to the developers.  In order not to distract the whole team, at each iteration we choose a victim - an engineer on duty.  The meaning of its existence is to answer all the questions and fulfill all the requests of the Elbe-people who are not developers. <br><br><h4>  Release Engineer </h4><br>  We have a somewhat unconventional view of this role.  For each release we assign a release engineer from the developers.  Its goal is to ensure that all functional tests pass, the patches are prepared and tested, and no one has any questions about the release at all.  This does not mean that the release engineer himself raises all the tests, as long as he raises the right questions and motivated everyone to get answers.  And of course, he is necessarily present at the release, and is ready to solve any problem that has arisen. <br><br>  In fact, as a rule, the duty engineer and release engineer are one person. <br><br><h4>  Result </h4><br>  Acting in this way, we have managed for almost 2 years to make 1 significant release per month.  The system is developing very dynamically, but we are not afraid to make several updates a week (not everything can be planned: the legislation is changing too rapidly and the growth of users in the last six months has been very significant), our engineering practices make the development very manageable and predictable. <br>  Technical details <br>  IDE: Microsoft VisualStudio + <a href="http://www.jetbrains.com/resharper/">JetBrains ReSharper</a> <br>  Continuous Integration Server: <a href="http://www.jetbrains.com/teamcity/">JetBrains TeamCity</a> <br>  Bagtracker: <a href="http://www.jetbrains.com/youtrack/">JetBrains YouTrack</a> <br>  Functional tests: <a href="http://seleniumhq.org/">Selenium</a> <br>  VCS: Mercurial <br>  Web server: Microsoft IIS + nginx <br>  DB: MS SQL Server <br><br>  PS Maybe it is not obvious from the text, but we have a tester.  He is busy all the time and works very well :) <br>  PPS Thank you warmly our beloved <a href="http://www.jetbrains.com/">JetBrines</a> for great tools :) </div><p>Source: <a href="https://habr.com/ru/post/128427/">https://habr.com/ru/post/128427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128422/index.html">Twitter bot on C #</a></li>
<li><a href="../128423/index.html">Simple synthesizer for Arduino</a></li>
<li><a href="../128424/index.html">Evernote extension for Chrome improved copying articles</a></li>
<li><a href="../128425/index.html">Itanium Poulson: what's new</a></li>
<li><a href="../128426/index.html">Master Part Chart with Highcharts and jQuery UI</a></li>
<li><a href="../128428/index.html">6 sad squids cuddle tenderly</a></li>
<li><a href="../128429/index.html">Extreme data recovery from degraded 5th raid</a></li>
<li><a href="../128431/index.html">Daemon for remote control of a computer via e-mail</a></li>
<li><a href="../128432/index.html">The dark side of programming for beginners, including php</a></li>
<li><a href="../128433/index.html">Hidden in the foliage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>