<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LAMP + Nginx on VPS is stable and without any extra headache</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task is to deploy hosting of several non-loaded sites on minimal VPS resources. Do it quickly and conveniently with minimal problems in the future...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LAMP + Nginx on VPS is stable and without any extra headache</h1><div class="post__text post__text-html js-mediator-article">  The task is to deploy hosting of several non-loaded sites on minimal VPS resources.  Do it quickly and conveniently with minimal problems in the future and do not fall on peak loads. <br><br><h5>  Basic principles: </h5><br>  1. OS - Centos-6 86_x64 because it is stable, convenient and easy to upgrade. <br>  2. No self-software.  And as they say, ‚Äúwith the command make &amp;&amp; make install, any distribution will turn into Slackware.‚Äù <br><a name="habracut"></a><br>  A small clarification, at the moment I use the v256 tariff plan of the hosting provider flynet.pro (256MB of RAM) and do not count on a large load, so most of it refers to that amount of RAM, but in general the solutions are easily portable to virtually all tariff plans different hosting providers. <br>  And one more clarification - hosting is done ‚Äúfor oneself‚Äù.  There are insufficiently described points that should be taken into account if you give access to the administration of sites to outsiders. <br><br>  Go. <br>  1. Check for updates. <br>  The installation image of the hosting provider may not be particularly fresh. <br> <code>[root@test ~]# yum update <br></code> <br>  There is something to update - update.  No - rejoice. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. Connect the EPEL repository (http://fedoraproject.org/wiki/EPEL) from which we will install the missing software. <br> <code><a href=""></a> [root@test ~]# rpm -ihv download.fedora.redhat.com/pub/epel/6/x86_64/epel-release-6-5.noarch.rpm <br></code> <br><br>  3. We put the software we need <br> <code>[root@test ~]# yum install httpd mysql-server php vsftpd mc phpMyAdmin php-eaccelerator sysstat crontabs tmpwatch <br></code> <br><br>  Briefly about the software: <br>  httpd - Apache standard version for Centos-6 - 2.2.15 <br>  mysql-server - Mysql 5.1.52 <br>  php - PHP 5.3.2 <br>  vsftpd - pretty convenient FTP server vsftpd 2.2.2 <br>  mc - some things are more convenient to do in mc than on the command line. <br>  phpMyAdmin - similar to mc.  Manage mysql databases in phpMyAdmin is certainly more convenient. <br>  php-eaccelerator - accelerator for PHP.  Significantly increases the speed of scripts and reduces the load on the processor.  Yes, and in memory. <br>  sysstat - in case we want to see how the system is doing. <br>  crontabs - to perform tasks on a schedule. <br>  tmpwatch - utility to remove obsolete files. <br><br>  In fact, several more packages will be installed, to those packages that we asked to install everything necessary for their operation will be added. <br>  The result is: <br> <code>Install 44 Package(s) <br> Upgrade 0 Package(s) <br> <br> Total download size: 37 M <br> Installed size: 118 M <br></code> <br><br>  4. With the free command, we look at whether we have a swap and, if not, then create it and connect it.  If there is - rejoice and skip this item. <br>  Here an important point - the active use of the swap - is very bad.  If there is an active swap, it means you need to optimize or cut something.  If you can‚Äôt optimize and cut back, you‚Äôll have to switch to a more expensive tariff plan.  Another thing to keep in mind is that the hosting provider may be offended by too active use of the swap. <br>  But completely without a swap is also not very good - oom killer is a terrible thing.  It can inadvertently kill mysqld and instead of just slowing down your sites will completely lie. <br>  Note - you do not need to swap more available RAM.  There will be no benefit from him, but he is eating a place. <br><br>  Create a swap as follows: <br> <code>[root@test /]# dd if=/dev/zero of=/swap bs=1M count=256 <br> [root@test /]# mkswap /swap <br></code> <br><br>  connect <br> <code>[root@test /]# swapon /swap <br></code> <br>  Well, in order for it to be connected automatically we write this command to /etc/rc.local <br>  You can check the availability and use of a swap using the top or free commands. <br><br>  5. Turn on and run daemons. <br> <code>[root@test /]# chkconfig httpd on <br> [root@test /]# chkconfig mysqld on <br> [root@test /]# chkconfig crond on <br> <br> [root@test /]# service httpd restart <br> [root@test /]# service mysqld restart <br> [root@test /]# service crond restart <br></code> <br><br>  6. Create users for sites.  I prefer the username to be similar to the site domain. <br> <code>[root@test /]# adduser testsite.ru <br> [root@test /]# adduser mysite.ru <br> [root@test /]# adduser cfg.testsite.ru <br></code> <br>  Next, create additional in user directories.  html (in which there will be the main content of the sites) and log in which logs will be written for this site and set permissions.  Permissions set: user - full access, group apache reading and listing of directories, the rest - ficus. <br>  You can set your rights with your hands, or you can use a small script: <br> <code>cd /home <br> for dir in `ls -1 `; do <br> mkdir /home/$dir/log <br> mkdir /home/$dir/html <br> chown -R $dir:apache $dir <br> chmod ug+rX $dir <br> done; <br></code> <br><br>  7. Configure the web server.  Rule /etc/httpd/conf/httpd.conf <br>  From the really needing a change, we set up the prefork module so that it initially ate less memory and limited its appetites. <br>  The fact is that Apache is initially configured to run up to 256 of its workflows, while one workflow easily takes 20-40MB (256 * 20 = 5GB) this can easily lead to problems, especially on modest VPS where there is only 256MB of RAM. <br>  Therefore, we limit their number to reasonable numbers based on the available RAM.  For example, 5 Apache processes with an average size of 30 MB will take about 150 MB - which is already tolerable. <br>  It was: <br> <code>&lt;IfModule prefork.c&gt; <br> StartServers 8 <br> MinSpareServers 5 <br> MaxSpareServers 20 <br> ServerLimit 256 <br> MaxClients 256 <br> MaxRequestsPerChild 4000 <br></code> <br><br>  It became: <br> <code>&lt;IfModule prefork.c&gt; <br> StartServers 2 <br> MinSpareServers 2 <br> MaxSpareServers 3 <br> ServerLimit 5 <br> MaxClients 5 <br> MaxRequestsPerChild 1000 <br></code> <br><br>  Such a setting will not allow the Apache to breed beyond measure and eat all the RAM.  Depending on the actual load, the parameters may need to be revised. <br>  Well, uncomment the line <br> <code>NameVirtualHost *:80 <br></code> <br>  In order to have many sites on one ip address. <br><br>  Next, go to the /etc/httpd/conf.d/ directory and configure our sites. <br>  There you can delete welcome.conf which turns off the indexes and issues the ‚ÄúApache 2 Test Page‚Äù page instead. <br>  It should be noted that virtual host configs in this directory are used in turn in alphabetical order. <br>  In order that a user logging on to an IP address on any of our sites does not get to a completely different one (which will be the first in the list) in the conf.d directory, you should put a file with a name, for example, 000-default.conf and such content: <br> <code>&lt;VirtualHost *:80&gt; <br> ServerName localhost.local <br> DocumentRoot "/var/www/html" <br></code> <br><br>  and put in the directory / var / www / html / index.html file with the wishes. <br><br>  Next, for each of our virtual hosts we create a config file using a pattern like this: <br> <code><a href="http://www.testsite.ru/"></a> &lt;VirtualHost *:80&gt; <br> <br> ServerName testsite.ru <br> ServerAlias www.testsite.ru <br> ServerAdmin webmaster@testsite.ru <br> ErrorLog /home/testsite.ru/log/error.log <br> CustomLog /home/testsite.ru/log/access.log combined <br> DocumentRoot /home/testsite.ru/html/ <br> <br> &lt;Directory "/home/testsite.ru/html"&gt; <br> Order allow,deny <br> Allow from all <br></code> <br><br><br><br>  In the same files, to taste, you can add individual settings of any modules. <br><br>  Restart apache and see if everything works. <br> <code>[root@test /]# service httpd restart <br></code> <br><br>  apache should start normally.  In the directories log sites should create 2 log files. <br>  When accessing the server by IP address, the file you put in / var / www / html / should be displayed, and when accessing the site names you should see the contents of the html directory (empty most likely) and entries in the access.log file of the corresponding site. <br><br>  8. Configure mysql.  First we delete the test database and set the root user password to mysql <br> <code>[root@test /]# mysql <br></code> <br><br> <code>mysql&gt; DROP DATABASE test; <br> mysql&gt; USE mysql; <br> mysql&gt; UPDATE user SET Password=PASSWORD('MyMysqlPassword') WHERE user='root'; <br> mysql&gt; FLUSH PRIVILEGES; <br> mysql&gt; quit <br></code> <br><br>  With MySql, the problem is about the same as with Apache - the demands on the RAM which is very expensive on the VPS. <br>  To reduce the amount of memory used by the sql server, we correct /etc/my.cnf as follows: <br>  Add the following to the [mysqld] section: <br> <code>key_buffer = 16M <br> max_allowed_packet = 10M <br> table_cache = 400 <br> sort_buffer_size = 1M <br> read_buffer_size = 4M <br> read_rnd_buffer_size = 2M <br> net_buffer_length = 20K <br> thread_stack = 640K <br> tmp_table_size = 10M <br> query_cache_limit = 1M <br> query_cache_size = 32M <br> skip-locking <br> skip-innodb <br> skip-networking <br></code> <br><br>  and add these lines to the end of the file: <br> <code>[mysqldump] <br> quick <br> max_allowed_packet = 16M <br> <br> [mysql] <br> no-auto-rehash <br> <br> [isamchk] <br> key_buffer = 8M <br> sort_buffer_size = 8M <br> <br> [myisamchk] <br> key_buffer = 8M <br> sort_buffer_size = 8M <br> <br> [mysqlhotcopy] <br> interactive-timeout <br></code> <br><br>  restart mysqld to make sure everything is fine: <br> <code>[root@test ]# service mysqld restart <br></code> <br><br>  It is also necessary to replace that the option ‚Äúskip-networking‚Äù makes it possible to access the server only from the local machine via a socket.  If network access is required, this option does not need to be enabled. <br>  Such settings will minimize the memory used by the mysql process and work normally on an unloaded site.  But of course you need to look at the statistics of the mysql operation and, depending on your needs, increase the limits here. <br><br>  Further administration of mysql is more convenient for making through phpMyAdmin. <br>  Now one caveat - by default, phpMyAdmin is available along the / phpMyAdmin path on all of our sites. <br>  To prevent this, we create a specialized site for management (for example, cfg.testsite.ru) and set it up just like the rest. <br>  Then we transfer the entire contents of the /etc/httpd/conf.d/phpMyAdmin.conf file to the configuration of this site, and the phpMyAdmin.conf file is deleted or moved somewhere from the conf.d directory. <br>  After such actions, phpMyAdmin will be available on the path / phpMyAdmin / only on a dedicated site. <br>  Well, in order to be able to enter it in the site configuration file we change <br> <code>&lt;Directory /usr/share/phpMyAdmin/&gt; <br> Order Deny,Allow <br> Deny from All <br> Allow from 127.0.0.1 <br> Allow from ::1 <br></code> <br><br>  &lt;Directory / usr / share / phpMyAdmin / setup /&gt; <br>  Order Deny, Allow <br>  Deny from All <br>  Allow from 127.0.0.1 <br>  Allow from :: 1 <br><br><br>  on <br> <code>&lt;Directory /usr/share/phpMyAdmin/&gt; <br> Order Deny,Allow <br> Deny from All <br> Allow from 127.0.0.1 <br> Allow from ... <br> Allow from ::1 <br></code> <br><br>  &lt;Directory / usr / share / phpMyAdmin / setup /&gt; <br>  Order Deny, Allow <br>  Deny from All <br>  Allow from 127.0.0.1 <br>  Allow from your.add. <br>  Allow from :: 1 <br><br><br>  After that, phpMyAdmin will be available from your ip address. <br><br>  Log in as a root user with the password that was installed. <br>  To create a user, go to "Privilege" - "Add a new user" <br>  username is arbitrary, I prefer to use the site name to reduce confusion. <br>  Host is local (do we make it for a site that will spin right there?) <br>  Password - generate.  (do not forget to copy the password) <br>  Put a tick - ‚ÄúCreate a database with the name of the user in the name and grant full privileges to it‚Äù <br>  Apply. <br>  As a result, we obtain a user with the name, password and database of the same name chosen by you. <br><br>  9. It is often more convenient to upload files to the hosting via FTP.  for this we have installed vsftpd <br>  edit its config /etc/vsftpd/vsftpd.conf <br>  turn off anonymous login, change <br> <code>anonymous_enable=YES <br></code> <br>  on <br> <code>anonymous_enable=NO <br></code> <br><br>  and uncomment <br> <code>chroot_local_user=YES <br></code> <br><br>  Now, in order to be able to log in to the FTP of a specific site, the corresponding user must set a password <br> <code>[root@test /]# passwd testsite.ru <br></code> <br><br>  And do not forget that by default this user with a password can log in via SSH.  To disable this feature, the easiest way is to change the user shell. <br> <code>[root@test etc]# chsh -s /sbin/nologin testsite.ru <br></code> <br><br>  Enable and run vsftpd <br> <code>[root@test /]# chkconfig vsftpd on <br> [root@test /]# service vsftpd start <br></code> <br><br>  Check if everything works. <br><br>  And lastly, a very simple ‚Äúoperational backup‚Äù.  By the principle of "backups do not happen much." <br>  It would be better to use something more correct, but a bad backup is still better than a complete absence. <br>  Such a backup can be a good addition to the full backup of a virtual machine from a hosting provider.  But, by no means replacing it. <br>  We backup the contents of sites and databases, as well as settings in the / etc / directory. <br>  Create a directory / backup / and set it to the right "700" <br><br> <code>[root@test /]# mkdir /backup/ <br> [root@test /]# chmod 700 /backup/ <br></code> <br><br>  In the /etc/cron.daily/ directory, create the backup.sh file and also set the ‚Äú700‚Äù rights to it. <br> <code>[root@test /]# touch /etc/cron.daily/backup.sh <br> [root@test /]# chmod 700 /etc/cron.daily/backup.sh <br></code> <br><br>  The file has the following contents: <br><br> <code>#!/bin/sh <br> <br> #   html   <br> tar -cf - /home/*/html/ | gzip &gt; /backup/sites-`date +%Y-%m-%d`.tar.gz <br> <br> #       <br> mysqldump -u root --password=MyMysqlPassword --all-databases | gzip &gt; /backup/mysql-`date +%Y-%m-%d`.dump.gz <br> <br> #   <br> tar -cf - /etc/ | gzip &gt; /backup/etc-`date +%Y-%m-%d`.tar.gz <br> <br> #    7  <br> tmpwatch -t -m 7d /backup/ <br></code> <br><br>  In principle, instead of just backup in one heap, it may be better to backup everything separately, but then there is an opportunity to forget to set up backup of something and regret it when it is needed. <br>  Well, or a backup option "separately" requiring that the username of the site and the database name match: <br><br> <code>#!/bin/sh <br> for dir in `ls -1 /home/ `; do <br> tar -cf - /home/$dir/html/ | gzip &gt; /backup/sites-$dir-`date +%Y-%m-%d`.tar.gz <br> mysqldump -u root --password=MyMysqlPassword $dir | gzip &gt; /backup/mysql-$dir-`date +%Y-%m-%d`.dump.gz <br> done; <br> <br> #   <br> tar -cf - /etc/ | gzip &gt; /backup/etc-`date +%Y-%m-%d`.tar.gz <br> <br> #    7  <br> tmpwatch -t -m 7d /backup/ <br></code> <br><br>  10. Updates. <br>  Do not forget to update the system from time to time. <br> <code>[root@test ~]# yum update <br></code> <br>  Due to the policy of RHEL / Centos in relation to the software version of the software after the upgrade will remain the same and inadvertently put the server due to the fact that in the config something has changed very little chance. <br>  The truth is that there is a minus in this approach - in three years Centos-6 will have the same version of software as now.  But if our goal is stability - this suits us. <br><br>  11. Testing. <br>  I highly recommend conducting a site testing after setup. <br>  The first test item is to reboot the server and check that all the required demons start and everything works as expected.  I would generally recommend not to chase uptime and reboot after installing or changing the versions of any server software that starts up automatically. <br>  It is better to know that Apache does not start in autorun after a handwritten planned reboot than to find out that the hoster had problems and as a result of your virtual machine's reboot, the sites on it do not work for half a day. <br>  Next is load testing using the ab utility (Apache HTTP server benchmarking tool). <br>  In this testing, we are not so much interested in the number of parrots as the behavior of the server under load.  It should not have dying processes and active swapping. <br>  For testing, we need a website hosted on this server in working condition.  And the ‚Äútypical‚Äù page from this site.  Well, or you can use not the typical, but the most difficult. <br><br>  For example, I am testing on freshly installed Drupal 7.9 <br><br>  Of all the ab command line ab, we need only 2 parameters -n - the number of http requests -c - the number of simultaneous requests (streams). <br>  During the execution of the test in the second ssh session using top, we observe how the server is doing. <br><br>  100 requests in 2 threads. <br><br> <code><a href="http://testsite.ru/"></a> [root@test ~]# ab -n 100 -c 2 testsite.ru <br></code> <br><br>  From ab output, I am particularly interested in ‚ÄúRequests per second‚Äù, ‚ÄúTime per request‚Äù and ‚ÄúFailed requests‚Äù, which give a general idea of ‚Äã‚Äãserver performance. <br><br> <code>Failed requests: 0 <br> Requests per second: 6.20 [#/sec] (mean) <br> Time per request: 322.788 [ms] (mean) <br></code> <br><br>  It can be seen that the server processes 6 kopecks per second requests and spends 322 milliseconds to generate one page. <br><br>  From the top output, the memory allocation and CPU usage are interesting. <br><br> <code>Tasks: 62 total, 3 running, 59 sleeping, 0 stopped, 0 zombie <br> Cpu(s): 19.9%us, 5.3%sy, 0.0%ni, 0.0%id, 0.0%wa, 0.0%hi, 0.4%si, 74.5%st <br> Mem: 244856k total, 151624k used, 93232k free, 3752k buffers <br> Swap: 262136k total, 0k used, 262136k free, 76604k cached <br></code> <br><br>  Swap: 0k used - sooo good. <br>  93232k free + 76604k cached - actually 170 megabytes of free memory. <br><br>  100 requests 5 threads. <br><br> <code><a href="http://testsite.ru/"></a> [root@test ~]# ab -n 100 -c 5 testsite.ru <br></code> <br><br> <code>Failed requests: 0 <br> Requests per second: 6.21 [#/sec] (mean) <br> Time per request: 804.513 [ms] (mean) <br> <br> Tasks: 63 total, 5 running, 58 sleeping, 0 stopped, 0 zombie <br> Cpu(s): 17.5%us, 6.2%sy, 0.0%ni, 0.0%id, 0.0%wa, 0.0%hi, 0.0%si, 76.3%st <br> Mem: 244856k total, 159756k used, 85100k free, 3812k buffers <br> Swap: 262136k total, 0k used, 262136k free, 76660k cached <br></code> <br><br>  The number of requests per second remains the same, but the generation time has increased by more than 2 times - rested on the processor. <br><br>  And finally, habraeffekt or something close :-) <br><br> <code><a href="http://testsite.ru/"></a> [root@test ~]# ab -n 500 -c 50 testsite.ru <br></code> <br><br> <code>Failed requests: 0 <br> Requests per second: 6.45 [#/sec] (mean) <br> Time per request: 7749.972 [ms] (mean) <br> <br> Tasks: 63 total, 6 running, 57 sleeping, 0 stopped, 0 zombie <br> Cpu(s): 19.1%us, 5.3%sy, 0.0%ni, 0.0%id, 0.0%wa, 0.0%hi, 0.0%si, 75.6%st <br> Mem: 244856k total, 162740k used, 82116k free, 3884k buffers <br> Swap: 262136k total, 0k used, 262136k free, 76672k cached <br></code> <br><br>  Again, the number of requests per second is relatively stable, but the generation time has become completely sad.  But at the same time, Failed requests are zero.  Which means that even though slowly, but everything works. <br>  Well, about the memory - at the moment Swap: 0k used, 82116k free, 76672k cached - consumption almost did not grow and, in principle, you can increase some of the limits, but I don‚Äôt think it‚Äôs worthy of filling up the site at the moment.  But later it is worth running out the tests on the completed site and, depending on the results, already adjust the settings. <br><br>  12. Installing nginx as a frontend. <br><br>  Why is this necessary. <br>  The main problem lies in how apache handles incoming connections.  For each incoming connection, a new process is created or one of the running ones is taken and the connection is transferred to it for maintenance.  Until the connection is closed, this process only deals with them. <br>  In principle, everything looks good as long as we have a lot of RAM and / or very fast clients (ab running one of these options from localhost), but things get much sadder if the client is on a slow channel or just not in a hurry.  In such a case, it actually blocks one of the processes that are being shut down from the server operation at the time of the request retrieval. <br>  Thus, in theory, having a server on a 100 Mbps channel and one persistent client on a dialup with a reboot, we can get something like DOS - a client in several threads will block virtually all our apache processes, which we have in our memory a very small amount. <br>  This problem is solved by installing some lightweight http server as a frontend.  If there is a frontend, all incoming connections are accepted by it, then the request is transmitted to apache and a response is quickly received thereby freeing the apache process for new requests.  The frontend, slowly and without wasting extra resources, gives the answer to the client who has already asked him. <br>  As an additional bonus, the front-end can give static content by itself - for example, images, css, etc.  unloading heavy apache. <br><br> <code><a href=""></a> [root@test ~]# rpm -ihv centos.alt.ru/pub/repository/centos/6/x86_64/centalt-release-6-1.noarch.rpm <br> [root@test ~]# yum install mod_realip2 nginx-stable <br></code> <br><br>  In order for apache and our scripts in requests to see the real ip address of the client and not the frontend address, we will have mod_realip2 installed. <br>  edit /etc/httpd/conf.d/mod_realip2.conf, uncomment <br> <code>RealIP On <br> RealIPProxy 127.0.0.1 <br> RealIPHeader X-Real-IP <br></code> <br><br>  edit httpd.conf and files in /etc/httpd/conf.d/ <br>  we change all instructions on port 80 to port 8080 <br>  Just need to change three directives: <br> <code>Listen 127.0.0.1:8080 <br> NameVirtualHost *:8080 <br> &lt;VirtualHost *:8080&gt; <br></code> <br><br>  edit /etc/nginx/nginx.conf <br> <code>user apache; <br> worker_processes 2; <br></code> <br><br>  I use the launch of nginx from under the apache user since initially we gave all rights with the expectation of it. <br>  It is also useful to comment out the access_log directive in nginx.conf in order to avoid double logging. <br>  It is better not to touch error_log - Apache has errors and nginx is different after all. <br><br>  In the server section, edit the listen directive and set: <br> <code>listen 80 default <br></code> <br><br>  change: <br> <code>location / { <br> root /usr/share/nginx/html; <br> index index.html index.htm; <br> } <br></code> <br>  on <br> <code><a href="http://127.0.0.1/"></a> location / { <br> proxy_pass 127.0.0.1:8080/; <br> } <br></code> <br><br>  In the /etc/nginx/conf.d/ directory create the proxy.conf file with the following content <br> <code>proxy_redirect off; <br> proxy_set_header Host $host; <br> proxy_set_header X-Real-IP $remote_addr; <br> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; <br> client_max_body_size 10m; <br> client_body_buffer_size 128k; <br> proxy_connect_timeout 90; <br> proxy_send_timeout 90; <br> proxy_read_timeout 90; <br> proxy_buffer_size 4k; <br> proxy_buffers 4 32k; <br> proxy_busy_buffers_size 64k; <br> proxy_temp_file_write_size 64k; <br></code> <br><br>  restart apache and nginx <br> <code>service httpd restart <br> service nginx restart <br></code> <br>  and check if everything works. <br><br>  In general, everything.  Now nginx is front-end, accepts all incoming connections and proxies them to the Apache who processes them and quickly sends the response back to nginx, freeing the process for new requests. <br><br>  The next step to increase performance and reduce resource consumption will be the return of static content directly through nginx. <br><br>  In addition to the apache virtual hosts, it will be necessary to start virtual nginx hosts and specify what to distribute. <br>  To do this, in the /etc/nginx/conf.d/ directory, create a file with the name of our site and a .conf extension with the following contents: <br> <code><a href=""></a> <a href="http://127.0.0.1/"></a> server { <br> listen 80; <br> server_name testsite.ru www.testsite.ru; <br> location / { <br> proxy_pass 127.0.0.1:8080/; <br> } <br> <br> location ~ /\.ht { <br> deny all; <br> } <br> <br> location /sites/default/files { <br> root /home/testsite.ru/html; <br> access_log /home/testsite.ru/log/access_static.log combined; <br> } <br> } <br></code> <br><br>  In this example, for a site on CMS Drupal, the static content of the / sites / default / files directory is distributed via nginx, and for everything else we are already heading to Apache. <br>  Another option is to replace the location directive with: <br> <code>location ~ \.(jpg|gif|png|css|js|ico)$ { <br> root /home/testsite.ru/html; <br> access_log /home/testsite.ru/log/access_static.log combined; <br> } <br></code> <br>  In this case, all files with the appropriate extensions will be given to nginx.  But in this variant there is a small minus - nginx does not know how to work with .htaccess files, so if you have any content there that is not viewable by .htaccess - you should refrain from using this option. <br><br>  It is also worth noting that in this situation we get two logs to one site.  Separately, the log of requests for which Apache worked and separately the log of the content of the given nginx. <br>  Alternatively, transfer the access_log directive from the location section to the server section and disable access_log in the virtual host Apache.  In this case, only nginx will log. <br>  But to see "how it works," a double log may be interesting - they immediately show what part of the burden on anyone. <br><br>  For further optimization, it is worthwhile to read the manuals for optimizing specific components and to do it with an eye to the current situation. <br><br>  <b>UPD:</b> Fixed some typos <br>  <b>UPD:</b> Fixed connection swap, thanks <a href="https://habrahabr.ru/users/angryanonymous/" class="user_link">AngryAnonymous</a> <br>  <b>UPD:</b> Added description of the installation and configuration of nginx, thanks to <a href="https://habrahabr.ru/users/masterbo/" class="user_link">masterbo</a> for the kick in the right direction. <br>  Another version of the backup script from <a href="https://habrahabr.ru/users/odmin4eg/" class="user_link">odmin4eg</a> : <a href="http://habrahabr.ru/blogs/s_admin/132302/">habrahabr.ru/blogs/s_admin/132302/#comment_4391784</a> <br><br>  Waiting for critics. </div><p>Source: <a href="https://habr.com/ru/post/132302/">https://habr.com/ru/post/132302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132293/index.html">Benefits and compensations or drying and buns</a></li>
<li><a href="../132295/index.html">"Heart" of an electronic device based on Silicon Labs C8051F320</a></li>
<li><a href="../132296/index.html">Dmitry Medvedev signed up VKontakte</a></li>
<li><a href="../132297/index.html">Win a ticket to participate in the INTERNET LIFE 2011 conference</a></li>
<li><a href="../132301/index.html">Another story of war with spam on the forum</a></li>
<li><a href="../132306/index.html">Seven reasons why your colleagues do not trust you</a></li>
<li><a href="../132307/index.html">Russian rock in the Android Market</a></li>
<li><a href="../132308/index.html">Implementing the DEEP IDLE power saving mode in the Linux kernel</a></li>
<li><a href="../132309/index.html">TELESAR V - robot for telebeeting</a></li>
<li><a href="../132312/index.html">About unnecessary Spanning Tree</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>