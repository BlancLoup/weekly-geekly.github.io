<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A small review of SIMD in .NET / C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We offer you a small overview of the capabilities of the vectorization of algorithms in the .NET Framework and .NETCORE. The purpose of the article is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A small review of SIMD in .NET / C #</h1><div class="post__text post__text-html js-mediator-article"><p>  We offer you a small overview of the capabilities of the vectorization of algorithms in the .NET Framework and .NETCORE.  The purpose of the article is to introduce those techniques to those who did not know them at all and to show that .NET is not far behind the "real, compiled" languages ‚Äã‚Äãfor the native <br>  development. </p><a name="habracut"></a><br><p>  I'm just starting to learn the techniques of vectorization, so if someone from the community points out the obvious jamb, or offers improved versions of the algorithms described below, I will be wildly happy. </p><br><h2 id="nemnogo-istorii">  A bit of history </h2><br><p>  In .NET, SIMD first appeared in 2015 with the release of the .NET Framework 4.6.  Then the types Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3 and Vector4 were added, which allowed vectorized calculations.  Later, the Vector &lt;T&gt; type was added, which provided more opportunities for vectorization of algorithms.  But many programmers were still unhappy, because  The types described above limited the flow of programmer's thoughts and did not allow using the full power of SIMD instructions of modern processors.  Already in our time, in the .NET Core 3.0 Preview, the System.Runtime.Intrinsics namespace has appeared, which provides much more freedom in choosing instructions.  To get the best results in speed, you need to use RyuJit and you need to either build under x64, or disable Prefer 32-bit and build under AnyCPU.  I ran all the benchmarks on a computer with an Intel Core i7-6700 CPU 3.40GHz (Skylake). </p><br><h2 id="summiruem-elementy-massiva">  Sum the array elements </h2><br><p>  I decided to start with the classic problem, which is often written first when it comes to vectorization.  This is the task of finding the sum of the elements of the array.  Let's write four implementations of this task, we will summarize the elements of the Array array: </p><br><p>  Most obvious </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Using LINQ </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Using vectors from System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Using code from the System.Runtime.Intrinsics space: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  I launched a benchmark on these 4 methods on my computer and got the following result: </p><br><table><thead><tr><th>  Method </th><th>  Itemscount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naive </td><td>  ten </td><td>  75.12 ns </td></tr><tr><td>  LINQ </td><td>  ten </td><td>  1 186.85 ns </td></tr><tr><td>  Vectors </td><td>  ten </td><td>  60.09 ns </td></tr><tr><td>  Intrinsics </td><td>  ten </td><td>  255.40 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  100 </td><td>  360.56 ns </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  2 719.24 ns </td></tr><tr><td>  Vectors </td><td>  100 </td><td>  60.09 ns </td></tr><tr><td>  Intrinsics </td><td>  100 </td><td>  345.54 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  1000 </td><td>  1,847.88 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 033.78 ns </td></tr><tr><td>  Vectors </td><td>  1000 </td><td>  240.38 ns </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  630.98 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  10,000 </td><td>  18 403.72 ns </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  102 489.96 ns </td></tr><tr><td>  Vectors </td><td>  10,000 </td><td>  7 316.42 ns </td></tr><tr><td>  Intrinsics </td><td>  10,000 </td><td>  3 365.25 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  100,000 </td><td>  176 630.67 ns </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  975 998.24 ns </td></tr><tr><td>  Vectors </td><td>  100,000 </td><td>  78 828.03 ns </td></tr><tr><td>  Intrinsics </td><td>  100,000 </td><td>  41 269.41 ns </td></tr></tbody></table><br><p>  It can be seen that the solutions with Vectors and Intrinsics greatly benefit in speed compared with the obvious solution and with LINQ.  Now we need to understand what is happening in these two methods. </p><br><p>  Let us consider the Vectors method in more detail: </p><br><div class="spoiler">  <b class="spoiler_title">Vectors</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vector &lt;int&gt; .Count;  - this is how many 4 byte numbers we can put in the vector.  If hardware acceleration is used, this value indicates how many 4-byte numbers can be placed in one SIMD register.  In fact, it shows how many elements of this type can be performed in parallel; </li><li>  accVector is the vector in which the result of the function will accumulate; <br>  var v = new Vector &lt;int&gt; (array, i);  - the data is loaded into the new vector v, from the array, starting at index i.  It will load exactly vectorSize data. </li><li>  accVector = Vector.Add (accVector, v);  - two vectors are added. <br>  For example, Array stores 8 numbers: {0, 1, 2, 3, 4, 5, 6, 7} and vectorSize == 4, then: <br>  In the first iteration of the cycle accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3}, after adding in accVector will be: {0, 0, 0, 0} + {0, 1, 2 , 3} = {0, 1, 2, 3}. <br>  In the second iteration, v = {4, 5, 6, 7} and after addition, accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  It remains only to somehow get the sum of all the elements of the vector, for this you can apply scalar multiplication by a vector filled with units: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Then we get: {4, 6, 8, 10} <em>{1, 1, 1, 1} = 4</em> 1 + 6 <em>1 + 8</em> 1 + 10 * 1 = 28. </li><li>  In the end, if required, numbers that do not fit in the last vector are added up. </li></ul><br><p>  If you look at the code for the Intrinsics method: </p><br><div class="spoiler">  <b class="spoiler_title">Intrinsics</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  You can see that it is very similar to Vectors with some exceptions: </p><br><ul><li>  vectorSize is a constant.  This happens because Avx2 instructions that operate on 256-bit registers are explicitly used in this method.  In a real application, there should be a check to see if the current Avx2 processor supports the instructions and, if not supported, call another code.  It looks like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector is declared as a 256 bit vector filled with zeros. </li><li>  fixed (int * ptr = Array) - the pointer to the array is entered into ptr. </li><li>  Further operations are the same as in Vectors: loading data into a vector and adding two vectors. </li><li>  For summing up the elements of the vector, the following method was used: <br><ul><li>  an array is created on the stack: var temp = stackalloc int [vectorSize]; </li><li>  the vector is loaded into this array: Avx2.Store (temp, accVector); </li><li>  the loop summarizes the elements of the array. </li></ul></li><li>  then the elements of the array that do not fit in the last vector are reached. </li></ul><br><h2 id="sravnivaem-dva-massiva">  Compare two arrays </h2><br><p>  It is necessary to compare two byte arrays.  Actually this is the task because of which I began to study SIMD in .NET.  Let us write again several methods for benchmark, we will compare two arrays: ArrayA and ArrayB: </p><br><p>  The most obvious solution: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Solution through LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  Solution via MemCmp function: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Using vectors from System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Using Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  The result of the benchmark on my computer: </p><br><table><thead><tr><th>  Method </th><th>  Itemscount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naive </td><td>  10,000 </td><td>  66 719.1 ns </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  71 211.1 ns </td></tr><tr><td>  Vectors </td><td>  10,000 </td><td>  3,695.8 ns </td></tr><tr><td>  Memcmp </td><td>  10,000 </td><td>  600.9 ns </td></tr><tr><td>  Intrinsics </td><td>  10,000 </td><td>  1,607.5 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  100,000 </td><td>  588 633.7 ns </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  651 191.3 ns </td></tr><tr><td>  Vectors </td><td>  100,000 </td><td>  34 659.1 ns </td></tr><tr><td>  Memcmp </td><td>  100,000 </td><td>  5 513.6 ns </td></tr><tr><td>  Intrinsics </td><td>  100,000 </td><td>  12,078.9 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  1,000,000 </td><td>  5,637,293.1 ns </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6,622,666.0 ns </td></tr><tr><td>  Vectors </td><td>  1,000,000 </td><td>  777 974.2 ns </td></tr><tr><td>  Memcmp </td><td>  1,000,000 </td><td>  361 704.5 ns </td></tr><tr><td>  Intrinsics </td><td>  1,000,000 </td><td>  434 252.7 ns </td></tr></tbody></table><br><p>  I think the whole code of these methods is understandable, with the exception of two lines in Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  In the first two vectors are compared for equality and the result is stored in the areEqual vector, in which the bits in the element at a particular position are set to 1 if the corresponding elements in va and vb are equal.  It turns out that if the vectors from bytes va and vb are completely equal, then in areEquals all elements must be equal to 255 (11111111b).  Since  Avx2.CompareEqual is a wrapper over _mm256_cmpeq_epi8, then <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">on the Intel website</a> you can see the pseudo-code of this operation: <br>  The MoveMask method from a vector makes a 32-bit number.  The bit values ‚Äã‚Äãare the high-order bits of each of the 32 single-byte elements of the vector.  Pseudocode can be viewed <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">here</a> . </p><br><p>  Thus, if some bytes in va and vb do not match, then the corresponding bytes in areEqual will be equal to 0, therefore the high bits of these bytes will also be equal to 0, and therefore the corresponding bits in the Avx2 response. MovoveMask will also be equal to 0 and the comparison with equalsMask will not work. </p><br><p>  Let us analyze a small example, assuming that the vector length is 8 bytes (so that writing was less): </p><br><ul><li>  Let va = {100, 10, 20, 30, 100, 40, 50, 100}, and vb = {100, 20, 10, 30, 100, 40, 80, 90}; </li><li>  Then are Equal will be equal to {255, 0, 0, 255, 255, 255, 0, 0}; </li><li>  The MoveMask method will return 10011100b, which will need to be compared with the mask 11111111b, since  Since these masks are unequal, it turns out that both the vectors va and vb are unequal. </li></ul><br><h2 id="podschityvaem-skolko-raz-element-vstrechaetsya-v-kollekcii">  Counting the number of times an item is found in a collection. </h2><br><p>  Sometimes it is necessary to count how many times a particular element is found in a collection, for example, ints, this algorithm can also be accelerated.  Let's write several methods for comparison, we will look for the Item element in the Array array. </p><br><p>  The most obvious: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  using LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  using vectors from System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Using Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//var mask = Avx2.SetAllVector256(Item); //var mask = Avx2.SetVector256(Item, Item, Item, Item, Item, Item, Item, Item); var temp = stackalloc int[vectorSize]; for (int j = 0; j &lt; vectorSize; j++) { temp[j] = Item; } var mask = Avx2.LoadVector256(temp); var accVector = Vector256&lt;int&gt;.Zero; int i; var array = Array; fixed (int* ptr = array) { for (i = 0; i &lt; array.Length - vectorSize; i += vectorSize) { var v = Avx2.LoadVector256(ptr + i); var areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } int result = 0; Avx2.Store(temp, accVector); for(int j = 0; j &lt; vectorSize; j++) { result += temp[j]; } for(; i &lt; array.Length; i++) { if (array[i] == Item) { result++; } } return result; }</span></span></code> </pre> <br><p>  The result of the benchmark on my computer: </p><br><table><thead><tr><th>  Method </th><th>  Itemscount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naive </td><td>  1000 </td><td>  2 824.41 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 138.95 ns </td></tr><tr><td>  Vectors </td><td>  1000 </td><td>  961.50 ns </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  691.08 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  10,000 </td><td>  27 072.25 ns </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  113 967.87 ns </td></tr><tr><td>  Vectors </td><td>  10,000 </td><td>  7 571.82 ns </td></tr><tr><td>  Intrinsics </td><td>  10,000 </td><td>  4,296.71 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  100,000 </td><td>  361 028.46 ns </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  1,091,994.28 ns </td></tr><tr><td>  Vectors </td><td>  100,000 </td><td>  82 839.29 ns </td></tr><tr><td>  Intrinsics </td><td>  100,000 </td><td>  40 307.91 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naive </td><td>  1,000,000 </td><td>  1,634 175.46 ns </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6 194 257.38 ns </td></tr><tr><td>  Vectors </td><td>  1,000,000 </td><td>  583 901.29 ns </td></tr><tr><td>  Intrinsics </td><td>  1,000,000 </td><td>  413 520.38 ns </td></tr></tbody></table><br><p>  Methods Vectors and Intrinsics completely coincide in logic, the differences are only in the implementation of specific operations.  The whole idea is: </p><br><ul><li>  creates a vector mask, in which the desired number is stored in each element; </li><li>  A part of the array is loaded into the vector v and compared with the mask, then all bits will be set in equal elements in equal elements, since  areEqual is a vector from ints, then, if you set all the bits of one element, we get -1 in this element ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  the areEqual vector is subtracted from accVector and then in accVector there will be the sum of how many times the item element is encountered in all vectors v for each position (minus gives minutes plus). </li></ul><br><p>  All the code from the article can be found on <a href="https://github.com/tdkkdt/SIMDArticle">GitHub</a> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I considered only a very small part of the possibilities that .NET provides for vectorization of computations.  For a complete and current list of available intrinsik in .NETCORE under x86, you can refer to the <a href="https://github.com/dotnet/corefx/tree/master/src/Common/src/CoreLib/System/Runtime/Intrinsics/X86">source code</a> .  Conveniently, there in C # files in the summary of each intrinsic is its own name from the world of C, which simplifies both the understanding of the purpose of this intrinsic and the translation of already existing C ++ / C algorithms to .NET.  Documentation on System.Numerics.Vector is available on <a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector">msdn</a> . </p><br><p>  In my opinion, .NET has a big advantage over C ++, since  JIT compilation occurs already on the client machine, the compiler can optimize the code for a specific client processor, providing maximum performance.  In this case, a programmer for writing fast code can remain within the framework of one language and technology. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435840/">https://habr.com/ru/post/435840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435828/index.html">The math in Gamedev is simple. Curves and Ripples for the effect of rain in Unity</a></li>
<li><a href="../435830/index.html">OMEGA - Automation of counting time at sporting events</a></li>
<li><a href="../435834/index.html">EXAM - State-of-the-art text classification method</a></li>
<li><a href="../435836/index.html">The largest Wall Street firms have agreed to launch a new exchange to compete with the Nasdaq and the NYSE.</a></li>
<li><a href="../435838/index.html">Lazy functions in javascript</a></li>
<li><a href="../435842/index.html">Creating gaming 3D models for the poor: the indie way</a></li>
<li><a href="../435846/index.html">Conferences and hackathons for schoolchildren and students: 11 thematic events</a></li>
<li><a href="../435848/index.html">New devices and technologies from CES 2019 from Microsoft and partners</a></li>
<li><a href="../435854/index.html">Notes phytochemist. Radio banana</a></li>
<li><a href="../435856/index.html">What antiviruses are used in modern firewalls</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>