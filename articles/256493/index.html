<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CAN-USB adapter from stm32vldiscovery</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing devices with a CAN interface, it is desirable to have a handy tool for tracking messages on the network. For RS232 / 485 there are a l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CAN-USB adapter from stm32vldiscovery</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b5b/3c0/722/b5b3c07223dc47a59835f709714c639f.jpg"><br><br>  When developing devices with a CAN interface, it is desirable to have a handy tool for tracking messages on the network.  For RS232 / 485 there are a lot of budget USB adapters and a lot of various software, but for CAN I did not manage to find an inexpensive ready-made solution. <br><br>  At the same time on the sites of motorists there were home-made devices for connecting to the CAN bus of the car.  One of the finished projects were USB &lt;&gt; CAN Bus Interface (CAN Hacker), implemented on the Atmega + SJA1000 and the project STM32-CAN-Busadapter, implemented on the STM32F105.  They work with the program CAN Hacker, which looks comfortable enough to work.  A cursory analysis of the protocol of commands via USB showed that these devices are represented by a COM port, and further communication takes place in the form of transmission of commands from ASCII characters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the bins was found board STM32VLDiscovery, which became the object of the test.  On it we will repeat the “STM32-CAN-Busadapter”. <br><a name="habracut"></a><br>  The first step is to replace the STM32F100 microcontroller installed on STM32VLDiscovery.  The fact is that simultaneous operation of CAN and USB in the F1 series is possible only in STM32F105 / 107 microcontrollers.  It is good that the STM has pin-to-pin compatibility of microcontrollers of various series, but made in the same package. <br><br>  The local store purchased: <br>  1. STM32F105RBT6 297 rubles. <br>  2. PCA82C250T 115 rub. <br>  3. TJA1055T 138 rubles. <br>  4. PBS-40, 2pcs.  114 rub. <br>  The development board “with holes 2.54” has been waiting for its time for a long time. <br><br><h4>  Attempt to do everything quickly </h4><br>  We erase dust from STM32VLDiscovery, check that it still works by downloading the Demo project.  We rewire the controller, check that the transfer was successful by downloading the same project. <br><br>  From the site of the project STM32-CAN-Busadapter we download <i>(registration is required) the</i> binary firmware file and sew it into our controller using the “STM32 ST-LINK Utility”. <br><br>  A simplified diagram looks like this.  More detailed - on the site of the project STM32-CAN-Busadapter. <br><br><img src="https://habrastorage.org/files/2c3/56d/de6/2c356dde6be64e898e4d492e463ec9ca.jpg"><br><br>  We solder USB D +, D-, Vbus in accordance with the scheme.  Add a jumper / switch on PA2, the author has a name “Bootloader”. <br><br>  Turn on and ...., <i><b>nothing works</b></i> , the device via USB is not detected at all.  In all positions "Bootloader". <br><br>  We recall that in order to determine the USB connection, it is necessary to pull the D + line to 5V through a 1.5KΩ resistor.  After that, our device begins to be defined as an “unknown device” with vid / pid 0000. <br><br>  Then there were several hours of trying to figure out what was happening, and it was decided to write a test firmware to check the USB connection. <br><br><h4>  We write a test firmware to check the USB </h4><br>  To write a test firmware, we use STM32CubeMX, which will allow us to quickly concoct a test firmware.  According to ST and distributors, the use of CubeMX is “fashionable, stylish, youthful”, you must try to deal with this Cub. <br><br>  From STMicroelectronic we download STM32CubeMX.  The version is updated periodically, I have v4.7.0. <br><br>  In the installed Cube, we enter “Help” -&gt; “Install New Libraries” and install “Firmware Package for Family STM32F1” (I have V1.0.0). <br><br>  In “Help” -&gt; “Updater Settings” you can see “Repository Folder” - the place where our “Firmware Package” has downloaded, there are also examples with source codes for various debugging boards. <br><br><h4>  Create a new project in Cube </h4><br>  MCU - STM32F105RBTx. <br>  In “Configuration” -&gt; “Peripheals” -&gt; “RCC” we select clocking from external quartz resonator, HSE is set in “Crystal / Ceramic Resonator”. <br>  In “Configuration” -&gt; “Peripheals” -&gt; “USB_OTG_FS”, select the “Device_Only” mode, and set the “Activate_VBUS” checkbox to automatically determine when to connect to USB.  After that, we automatically assign PA9, PA11 and PA12 legs to work with USB. <br>  In “Configuration” -&gt; “MiddleWares” -&gt; “USB_DEVICE” -&gt; “Class For FS IP” select “Communication Device Class (Virtual Port Com)”. <br><br><img src="https://habrastorage.org/files/53e/546/09f/53e54609f5794fcf93493cef6744e524.jpg"><br><br>  Next on the tab "Clock Configuration" configure the clock system for our microcontroller.  You can see the finished values ​​of the PLL and Prescaler coefficients in the examples by looking at the SystemClock_Config procedure.  We should have this “picture”: <br><br><img src="https://habrastorage.org/files/45a/ed0/120/45aed0120a8244dea72191cdb553f642.jpg"><br><br>  Now you can generate a project to compile. <br><br>  Before the first generation, it will ask you to enter the name, storage location of the project and the IDE for which the project will be formed.  I chose Keil 4 as more familiar.  The options are Keil5, Keil4, IAR, TrueStudio, SW4STM32.  After generation, click "Open Project" and our development environment opens.  Without changing anything we compile and load. <br>  And ... <b>it works</b> .  The device was determined, the drivers were found on the <a href="http://www.st.com/web/en/catalog/tools/PF257938">ST</a> site.  Now in the "Device Manager" see "STMicroelectronics Virtual COM Port (COM4)". <br><br>  Further, it took some time to understand why the iron works, but there is no foreign firmware.  As a result, it was noticed that binary files look different. <br><br>  I remember that at the beginning of the program there are interrupt vectors and in our firmware we see something similar, and in the downloaded firmware the data is not at all similar to the commands to go to addresses. <br><br><img src="https://habrastorage.org/files/74d/10b/4ce/74d10b4ced3949a2b0952a97e13eb938.jpg"><br><br>  Moreover, Google suggested that the first 4 bytes of the firmware are the stack address, the next 4 bytes are the address of the first program command. <br><br>  I wrote to the author STM32-CAN-Busadapter.  Described that the firmware is "broken", does not work, that the first bytes are not the same as they should be.  Andreas answered me.  I wrote that the firmware is working, but it requires its proprietary loader.  Attached to the letter was a .hex file “personally version only for you”. <br><br><h4>  OK, look how it works </h4><br>  We solder the CAN transceiver chips, we get just such a “beauty”.  Pull-up resistor to D + USB line can be removed, it is inside the microcontroller. <br><br><img src="https://habrastorage.org/files/fbd/fd1/441/fbdfd1441b8a46fb96c211e00e95ee99.jpg"><br><br><img src="https://habrastorage.org/files/e7a/cf5/76b/e7acf576be3347a0877f9d3c7e06f96e.jpg"><br><br>  We are stitching, launching CAN Hacker, studying.  Here we need to connect to some CAN network.  I had this openmcu board with an STM32F107 controller, which issued CAN packages.  Having played with the “CAN Hacker” program, I realized that the piece was suitable, there are monitor and tracer modes - the messages are displayed either in the table or in the list as they are received. <br><br>  Here is a short video, not mine. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/jUuncLav0v8%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgW08iqsLk8aSOlELhPhOaglEx0cQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Now you can try to write your own firmware for the adapter.  Moreover, we already have a firmware package. <br><br>  <b>We are writing our firmware ...</b> <br>  Open in our IDE project, generated by Cube and append the missing pieces of code. <br>  The basic rule is to write between <br>  / * USER CODE BEGIN ... * / <br>  and <br>  / * USER CODE END ... * / <br>  Otherwise, everything that is written outside of such specially designated places will be mercilessly overwritten by Cub in the next generation of the project. <br><br>  <b>To begin, let's make an echo</b> : everything that was sent to our virtual COM port we get back. <br>  When receiving data via USB, the <b>CDC_Receive_FS</b> procedure <b>(uint8_t * Buf, uint32_t * Len)</b> is <i>called</i> in the file " <i>usbd_cdc_if.c</i> ". <br><br>  Let's add sending back all that received. <br><br><div class="spoiler">  <b class="spoiler_title">Echo</b> <div class="spoiler_text">  static int8_t CDC_Receive_FS (uint8_t * Buf, uint32_t * Len) <br>  { <br>  / * USER CODE BEGIN 6 * / <br><br>  CDC_Transmit_FS (Buf, * Len);  // send everything we received <br><br>  USBD_CDC_SetRxBuffer (hUsbDevice_0, &amp; UserRxBufferFS [0]); <br>  USBD_CDC_ReceivePacket (hUsbDevice_0);  // allow reception of the next packet <br><br>  return (USBD_OK); <br>  / * USER CODE END 6 * / <br>  } <br><br></div></div><br>  Compile, load.  We open our virtual COM port with any terminal program.  Port parameters (speed, parity) can be any.  Make sure that the echo works. <br><br><h4>  Adjusting to CAN Hacker </h4><br>  Now we will start the implementation of the protocol for working with the program “CAN Hacker”.  The protocol itself can be viewed on the USB &lt;&gt; CAN Bus Interface (CAN Hacker) project page, in the “description” file, or searched on the Internet by the name of “Lawicel Protokol”. <br><br>  The USBTrace program oversaw the adapter initialization process. <br><br>  You must answer the command "version request", for all other requests simply answer "OK" (0x0D). <br><br><div class="spoiler">  <b class="spoiler_title">Change the procedure CDC_Receive_FS</b> <div class="spoiler_text">  static int8_t CDC_Receive_FS (uint8_t * Buf, uint32_t * Len) <br>  { <br>  / * USER CODE BEGIN 6 * / <br><br>  uint32_t num_bytes; <br>  uint8_t res; <br>  uint8_t tmp_byte; <br><br>  HAL_GPIO_TogglePin (GPIOC, GPIO_PIN_9); <br><br>  switch (Buf [0]) <br>  { <br>  case 'v': <br>  num_bytes = sprintf ((char *) UserTxBufferFS, "V0101 \ r"); <br>  break; <br><br>  case 'v': <br>  num_bytes = sprintf ((char *) UserTxBufferFS, "vSTM32 \ r"); <br>  break; <br><br>  default: <br>  num_bytes = sprintf ((char *) UserTxBufferFS, "\ r"); <br>  break; <br>  } <br><br>  USBD_CDC_SetTxBuffer (hUsbDevice_0, (uint8_t *) &amp; UserTxBufferFS [0], num_bytes); <br>  USBD_CDC_TransmitPacket (hUsbDevice_0); <br><br><br>  // CDC_Transmit_FS (Buf, * Len); <br><br>  USBD_CDC_SetRxBuffer (hUsbDevice_0, &amp; UserRxBufferFS [0]); <br>  USBD_CDC_ReceivePacket (hUsbDevice_0); <br><br>  return (USBD_OK); <br>  / * USER CODE END 6 * / <br>  } <br></div></div><br>  After this, the program “CAN Hacker” will be able to “see” our adapter. <br><br><h4>  Add CAN interface to our project. </h4><br>  In Cube, set the “Configuration” -&gt; “Peripheals” -&gt; “CAN1” tick “Master mode”.  On the “Configuration” tab “CAN1” we set the speed and enable the interrupt by reception: <br><br><img src="https://habrastorage.org/files/f68/454/361/f684543610ba4de0a6e27d04318e8bbe.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">The exchange rate for CAN is obtained configured at 500 Kbps.</b> <div class="spoiler_text">  The clocking frequency of the CAN module from the APB1 bus is 36 MHz, we divide it by 6, we get the time of one quantum. <br>  One byte is transmitted 1 + 6 + 5 quanta, and it turns out 36/6 / (1 + 6 + 5) = 0.5 MHz, or 500 Kbps. <br>  By changing the “Prescaler (for Time Quantum)” divider, we can get standard speeds of 125,250,500,1000 Kbps. <br><img src="https://habrastorage.org/files/614/314/8f5/6143148f584845aca774ca489afd8362.jpg"><br></div></div><br>  We generate the project in Cube, we open in IDE. <br><br>  In “main.c”, you need to add buffers for CAN, configure an incoming message filter and add the procedure <b>HAL_CAN_RxCpltCallback</b> .  This procedure will be called from the CAN interrupt.  The name, of course, can only be so, because  it is written in the “depths” of the project generated by Cub.  All that was received by CAN will be sent to USB, in accordance with the protocol.  For example, by CAN, from the address 0x123, we received 8 bytes of data 0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88, we pack this into the “t12381122334455667788” USB package and add the 0x0D symbol to the end and send it to our virtual COM port on the PC. <br><br><div class="spoiler">  <b class="spoiler_title">Add CAN reception parcels</b> <div class="spoiler_text">  receive / transmit buffers <br>  / * USER CODE BEGIN PV * / <br>  static CanTxMsgTypeDef can1TxMessage; <br>  static CanRxMsgTypeDef can1RxMessage; <br>  / * USER CODE END PV * / <br><br>  procedure called upon receiving the parcel <br>  / * USER CODE BEGIN 0 * / <br>  void HAL_CAN_RxCpltCallback (CAN_HandleTypeDef * CanHandle) <br>  { <br>  uint32_t num_bytes; <br>  uint8_t buf [200]; <br><br>  num_bytes = sprintf ((char *) buf, "t% 3.3X% 1.1X% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 4.4x \ r", \ <br>  CanHandle-&gt; pRxMsg-&gt; StdId, \ <br>  CanHandle-&gt; pRxMsg-&gt; DLC, \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [0], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [1], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [2], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [3], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [4], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [5], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [6], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [7] \ <br>  ); <br>  CDC_Transmit_FS (buf, num_bytes);  // send to USB what we received via CAN <br><br>  HAL_CAN_Receive_IT (&amp; hcan1, CAN_FIFO0);  // waiting for the next package <br>  } <br>  / * USER CODE END 0 * / <br><br>  To use the external function CDC_Transmit_FS, we include the .h file <br>  / * USER CODE BEGIN Includes * / <br>  #include "usbd_cdc_if.h" <br>  / * USER CODE END Includes * / <br><br>  in the main main loop, add initialization of buffers and configure the receive filter <br>  / * USER CODE BEGIN 2 * / <br>  hcan1.pTxMsg = &amp; can1TxMessage; <br>  hcan1.pRxMsg = &amp; can1RxMessage; <br>  / * USER CODE END 2 * / <br><br>  // set up the filter - receive all parcels <br>  CAN_FilterConfTypeDef canFilterConfig; <br>  canFilterConfig.FilterNumber = 0; <br>  canFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK; <br>  canFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT; <br>  canFilterConfig.FilterIdHigh = 0x0000; <br>  canFilterConfig.FilterIdLow = 0x0000; <br>  canFilterConfig.FilterMaskIdHigh = 0x0000 &lt;&lt; 5; <br>  canFilterConfig.FilterMaskIdLow = 0x0000; <br>  canFilterConfig.FilterFIFOAssignment = 0; <br>  canFilterConfig.FilterActivation = ENABLE; <br>  canFilterConfig. BankNumber = 1; <br>  HAL_CAN_ConfigFilter (&amp; hcan1, &amp; canFilterConfig); <br><br>  HAL_CAN_Receive_IT (&amp; hcan1, CAN_FIFO0);  // allow receiving parcels <br>  / * USER CODE END 2 * / <br><br>  resize USB buffers additionally <br>  #define APP_RX_DATA_SIZE 1000 // was 4 <br>  #define APP_TX_DATA_SIZE 1000 // was 4 <br></div></div><br>  It is also important not to forget that the CAN transceiver has an input for switching to Standby mode. <br><br>  In Cube, assign PB7 to exit.  The default output will be 0. <br><br>  We compile, load, check.  In principle, it works.  In CAN Hacker we can see from CAN, but if the time between CAN packets is less than 1 ms, then messages are skipped, they come through one. <br><br>  Picture for example.  Every millisecond two parcels arrive, in CAN Hacker we see only one. <br><br><img src="https://habrastorage.org/files/f10/4f4/ec2/f104f4ec2f3f46839b479bbc6c069bc9.jpg"><br><br>  channel 1 - CAN RX, accept to controller <br>  channel 2 - CAN TX, you can see confirmation from our controller <br>  channel 3.4 -USB D +, D- <br><br>  In addition, if there is an intensive exchange on the CAN bus, then our adapter is not detected via USB, an “unknown device” writes. <br><br>  You have to first connect the USB, run CAN Hacker, then connect the CAN. <br><br><h4>  Add a ring buffer to receive CAN parcels </h4><br>  Obviously, while we are building and sending a parcel from CAN to USB, at this time the next parcel has time to slip into CAN, and it remains unprocessed.  Therefore, when receiving a CAN parcel, we will quickly add everything to the buffer, and somewhere else in the other place we will scoop this buffer and send it to USB. <br><br>  We will write to the buffer byte-by-byte, so it is easy to follow the “looping” - the transition from the end of the array in memory to the beginning. <br><br>  Send from the buffer will be the USBD_CDC_SetTxBuffer and USBD_CDC_TransmitPacket procedures, indicating the beginning of the data to be sent and their number.  If during sending you need to “make a ring”, then we send it in two stages, first the data until the end of the array in memory, then the remainder. <br><br><img src="https://habrastorage.org/files/f9f/8fc/388/f9f8fc3886d4404e8b646c495c787742.jpg"><br><div class="spoiler">  <b class="spoiler_title">Ring Buffer Implementation</b> <div class="spoiler_text">  the buffer for sending USB is already defined <br>  uint8_t UserTxBufferFS [APP_TX_DATA_SIZE]; <br><br>  in "usb_cdc_if.c" we define pointers to this buffer <br>  uint32_t ptrWriteUserTxBufferFS = 0;  // write to buffer when receiving from CAN <br>  uint32_t ptrReadUserTxBufferFS = 0;  // read from buffer, send to USB <br>  / * USER CODE END 1 * / <br><br>  we describe the procedures for adding data to the buffer and sending from the buffer <br>  Unfortunately, there was no normal place in “usb_cdc_if.c”, so I had to shove it into the “USBD_CDC_Private_Macros” section <br>  / * USER CODE BEGIN 2 * / <br>  extern uint8_t UserRxBufferFS [APP_RX_DATA_SIZE]; <br>  extern uint8_t UserTxBufferFS [APP_TX_DATA_SIZE]; <br>  extern uint8_t interface_state; <br>  extern USBD_HandleTypeDef * hUsbDevice_0; <br><br>  // ------------------------------------------------ -------------------------------------------------- -------------------------------------------------- ------------- <br>  uint8_t CDC_add_buf_to_transmit (uint8_t * Buf, uint16_t Len) // add to transfer buffer <br>  { <br>  uint16_t _cnt = Len; <br><br>  while (_cnt) <br>  { <br>  UserTxBufferFS [ptrWriteUserTxBufferFS] = * Buf; <br>  ptrWriteUserTxBufferFS ++; <br>  Buf ++; <br>  ptrWriteUserTxBufferFS% = APP_TX_DATA_SIZE;  // loopback <br>  _cnt--; <br>  } <br>  return (0); <br>  } <br><br>  // ------------------------------------------------ -------------------------------------------------- -------------------------------------------------- ------------- <br>  uint8_t CDC_periodic_callback (void) // periodically check if there is data to transmit <br>  { <br>  uint32_t buffptr; <br>  uint32_t buffsize; <br><br>  if (ptrReadUserTxBufferFS! = ptrWriteUserTxBufferFS) <br>  { <br>  __disable_irq (); // with intensive exchange via CAN without this, everything “falls apart” <br>  if (ptrReadUserTxBufferFS&gt; ptrWriteUserTxBufferFS) // make a ring? <br>  { <br>  buffsize = APP_TX_DATA_SIZE - ptrReadUserTxBufferFS;  // stage 1, byte to the end of the array <br>  } <br>  else <br>  { <br>  buffsize = ptrWriteUserTxBufferFS - ptrReadUserTxBufferFS;  // all data at once <br>  } <br>  __enable_irq (); <br><br>  buffptr = ptrReadUserTxBufferFS; <br><br>  if (interface_state! = 1) return (1);  // if the interface is not configured, we will not send <br><br>  USBD_CDC_SetTxBuffer (hUsbDevice_0, (uint8_t *) &amp; UserTxBufferFS [buffptr], buffsize); <br><br>  if (USBD_CDC_TransmitPacket (hUsbDevice_0) == USBD_OK) <br>  { <br>  ptrReadUserTxBufferFS + = buffsize; <br>  if (ptrReadUserTxBufferFS == APP_TX_DATA_SIZE) <br>  { <br>  ptrReadUserTxBufferFS = 0;  // loopback <br>  } <br>  } <br>  } <br>  return (0); <br>  } <br>  / * USER CODE END 2 * / <br><br>  in the "main.c" add variable <br>  uint8_t interface_state = 0; <br>  until the command “O” comes from CAN Hacker - the transition to the operating mode from the setup mode, we will not send anything to USB, since  we consider that the interface is not yet configured <br><br>  replace in CAN interrupt direct send to USB to add to send buffer <br>  CDC_Transmit_FS on CDC_add_buf_to_transmit <br><br>  and add periodic polling buffer to send <br>  while (1) <br>  { <br>  / * USER CODE END WHILE * / <br><br>  / * USER CODE BEGIN 3 * / <br>  CDC_periodic_callback (); <br>  } <br>  / * USER CODE END 3 * / <br><br></div></div><br>  Compile, load.  We see that now in CAN Hacker all messages are displayed, without gaps. <br><br><h4>  Add Timestamp </h4><br>  The CAN Hacker protocol provides “time stamps” for each message.  The range of values ​​is 0..60000 ms. <br>  Use for this TIM1. <br>  In Cub, in “Configuration” -&gt; “Peripheals” -&gt; “TIM1” select “Clock source” = “Internal Clock”. <br>  For setting the clocking frequency of the timer 1000 Hz (1ms).  We'll have to lower the clocking frequency of the APB2. <br>  We are convinced that nothing important in speed is clocked by APB2. <br>  From the “reference manual” on “STM32F1”: <br><br><img src="https://habrastorage.org/files/c22/ecb/8d2/c22ecb8d2918456e9cd5892e7fa185f5.jpg"><br><img src="https://habrastorage.org/files/c05/2b1/8c5/c052b18c513b406e9b95868fa35b559b.jpg"><br><br>  We see that timer1, I / O ports, ADC, SPI, USART are clocked from APB2, and we can safely lower the frequency of APB2. <br><br>  In Cub, on the tab “Clock Configuration” set “APB2 Prescaler” equal to 8, we get the clock frequency of the timer 18 MHz. <br><br><img src="https://habrastorage.org/files/1a6/1aa/593/1a61aa5937e744feb39d8cc75a8ffcaa.jpg"><br><br>  On the tab "Configuration" -&gt; "TIM1" set <br>  Prescaler (PSC - 16 bit value) = 18000 <br>  Counter period (AutoReload Register) = 60000 <br><br><img src="https://habrastorage.org/files/fdd/584/e4d/fdd584e4d62243f7a4de793366c74021.jpg"><br><br>  We generate the code, open it in the IDE. <br><br><div class="spoiler">  <b class="spoiler_title">We add in start of the timer</b> <div class="spoiler_text">  / * USER CODE BEGIN 2 * / <br>  HAL_TIM_Base_Start (&amp; htim1); <br></div></div><div class="spoiler">  <b class="spoiler_title">add timestamp to CAN message to USB</b> <div class="spoiler_text">  void HAL_CAN_RxCpltCallback (CAN_HandleTypeDef * CanHandle) <br>  { <br>  uint32_t num_bytes; <br>  uint8_t buf [200]; <br>  static uint32_t time; <br><br>  time = __HAL_TIM_GetCounter (&amp; htim1); <br><br>  num_bytes = sprintf ((char *) buf, "t% 3.3X% 1.1X% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 4.4x \ r", \ <br>  CanHandle-&gt; pRxMsg-&gt; StdId, \ <br>  CanHandle-&gt; pRxMsg-&gt; DLC, \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [0], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [1], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [2], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [3], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [4], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [5], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [6], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [7], \ <br>  time <br>  ); <br>  if (interface_state == 1) CDC_add_buf_to_transmit (buf, num_bytes); <br><br>  HAL_CAN_Receive_IT (&amp; hcan1, CAN_FIFO0); <br>  } <br></div></div><br>  Again, it seems to work, but with an intensive exchange in CAN, the USB exchange “shuts up”. <br>  This time the sprintf procedure is to blame, which takes a long time to complete the interrupt CAN <br><br>  Let's rewrite the formation of a parcel from CAN to USB without using sprintf. <br><br><div class="spoiler">  <b class="spoiler_title">Procedures for converting four bits to HEX ASCII character and vice versa</b> <div class="spoiler_text">  uint8_t halfbyte_to_hexascii (uint8_t _halfbyte) <br>  { <br>  _halfbyte &amp; = 0x0F; <br>  if (_halfbyte&gt; = 10) return ('A' + _halfbyte - 10); <br>  else return ('0' + _halfbyte); <br>  } <br><br>  uint8_t hexascii_to_halfbyte (uint8_t _ascii) <br>  { <br>  if ((_ ascii&gt; = '0') &amp;&amp; (_ascii &lt;= '9')) return (_ascii - '0'); <br>  if ((_ ascii&gt; = 'a') &amp;&amp; (_ascii &lt;= 'f')) return (_ascii - 'a'); <br>  if ((_ ascii&gt; = 'A') &amp;&amp; (_ascii &lt;= 'F')) return (_ascii - 'A'); <br>  return (0xFF); <br>  } <br></div></div><div class="spoiler">  <b class="spoiler_title">change the procedure HAL_CAN_RxCpltCallback</b> <div class="spoiler_text">  void HAL_CAN_RxCpltCallback (CAN_HandleTypeDef * CanHandle) <br>  { <br>  uint32_t num_bytes; <br>  uint8_t buf [200]; <br>  static uint32_t time; <br><br>  time = __HAL_TIM_GetCounter (&amp; htim1); <br>  / * <br>  num_bytes = sprintf ((char *) buf, "t% 3.3X% 1.1X% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 2.2x% 4.4x \ r", \ <br>  CanHandle-&gt; pRxMsg-&gt; StdId, \ <br>  CanHandle-&gt; pRxMsg-&gt; DLC, \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [0], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [1], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [2], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [3], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [4], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [5], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [6], \ <br>  CanHandle-&gt; pRxMsg-&gt; Data [7], \ <br>  time <br>  ); <br>  * / <br>  num_bytes = 0; <br>  buf [num_bytes ++] = 't'; <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; StdId) &gt;&gt; 8); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; StdId) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; StdId)); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; DLC)); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [0]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [0])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [1]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [1])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [2]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [2])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [3]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [3])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [4]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [4])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [5]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [5])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [6]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [6])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [7]) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((CanHandle-&gt; pRxMsg-&gt; Data [7])); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((time) &gt;&gt; 12); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((time) &gt;&gt; 8); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((time) &gt;&gt; 4); <br>  buf [num_bytes ++] = halfbyte_to_hexascii ((time) &gt;&gt; 0); <br>  buf [num_bytes ++] = '\ r'; <br><br>  if (interface_state == 1) CDC_add_buf_to_transmit (buf, num_bytes); <br><br>  HAL_CAN_Receive_IT (&amp; hcan1, CAN_FIFO0); <br>  } <br></div></div><br><br>  Some experiments on the speed of reception: in the CAN we form 1000000 parcels from the address 0x321 and in CAN Hacker we see how many of them we accept. <br><br>  Speed ​​500 Kbps, sending without interruption, loss of 0.2%: <br><br><img src="https://habrastorage.org/files/87d/276/e63/87d276e633f84f848f4d0f34505fa843.jpg"><br><br>  Speed ​​1 Mbit / s, sending without interruption, loss of 50%: <br><br><img src="https://habrastorage.org/files/e86/9f5/7fb/e869f57fbee74da3a69a94037b9a3769.jpg"><br><br>  The speed is 1 Mbit / s, two parcels every 1 ms, the loss is 0%: <br><br><img src="https://habrastorage.org/files/c56/966/10a/c5696610ae454a6cbcbc1659c6ab1fee.jpg"><br><br>  In my opinion a good result. <br><br><h4>  Add the ability to send messages to CAN </h4><br>  In the file “usbd_cdc_if.c”, in the USB procedure CDC_Receive_FS we add: <br><br><div class="spoiler">  <b class="spoiler_title">send to CAN</b> <div class="spoiler_text">  case 't': <br>  i = 1; <br><br>  hcan1.pTxMsg-&gt; StdId = hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; StdId = (hcan1.pTxMsg-&gt; StdId &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; StdId = (hcan1.pTxMsg-&gt; StdId &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; DLC = hexascii_to_halfbyte (Buf [i ++]); <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [0] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [1] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [2] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [3] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [4] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [5] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [6] = tmp_byte; <br>  tmp_byte = hexascii_to_halfbyte (Buf [i ++]);  tmp_byte = (tmp_byte &lt;&lt; 4) + hexascii_to_halfbyte (Buf [i ++]); <br>  hcan1.pTxMsg-&gt; Data [7] = tmp_byte; <br>  HAL_CAN_Transmit (&amp; hcan1, 10); <br><br>  num_bytes = sprintf ((char *) UserTxBufferFS, "\ r"); <br>  break; <br></div></div>  We compile, load, check, work. <br><br><h4>  Conclusion </h4><br>  On this, perhaps, you can stop.  The rubric for “do it yourself” is called.  If anyone wants, he can independently add support for different CAN speeds, work with 29 bit extended identifiers, message filters, remote frames. <br><br>  I want to say that I liked the principle of working through the ASCII command.  In the future I plan to implement USB-SPI, USB-I2C functionality.  For example, we configure our virtual COM port to 115200 baud - we work with CAN, we tune to 57600 - we work with I2C, we tune to 9600 - we work with SPI.  Of course, when working with SPI or I2C, “CAN Hacker” can no longer be used and you have to invent some kind of protocol. <br><br>  The finished draft for this article can be downloaded <a href="https://drive.google.com/file/d/0BwcHtbof8_8wV01EUlZLT0tOQ1E/view%3Fusp%3Dsharing">here</a> . <br><br><h4>  Used materials </h4><br>  1. <a href="http://www.carhelp.info/forums/showthread.php%3Ft%3D97740">USB &lt;&gt; CAN Bus Interface (CAN Hacker)</a> <br>  2. <a href="http://www.elektronik-keller.de/index.php/projekte/stm32/stm32-can">STM32-CAN-Busadapter</a> <br>  3. <a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/CD00267113.pdf">Description and scheme of STM32VLDISCOVERY</a> <br>  4. <a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/reference_manual/CD00171190.pdf">STM32F105 Reference Manual</a> </div><p>Source: <a href="https://habr.com/ru/post/256493/">https://habr.com/ru/post/256493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256483/index.html">Installing the free GPL site control panel VestaCP</a></li>
<li><a href="../256485/index.html">How we organized a mini-provider in the village</a></li>
<li><a href="../256487/index.html">Google will invest another $ 1 billion in its data center in the Council Bluffs</a></li>
<li><a href="../256489/index.html">Video reports from MoscowJS Meetup</a></li>
<li><a href="../256491/index.html">Cloud infrastructure: 7 interesting services and technologies (and their analogues)</a></li>
<li><a href="../256495/index.html">Designing a Web API in 7 steps</a></li>
<li><a href="../256497/index.html">Monitoring-as-a-service for infrastructures on the example of the Anturis service</a></li>
<li><a href="../256501/index.html">Apple Watch: how to make an application under the clock and not screw it up</a></li>
<li><a href="../256503/index.html">Write under that, I don’t know what: development features for Apple Watch using Mail.Ru Mail as an example</a></li>
<li><a href="../256505/index.html">Webix. The first acquaintance with the JavaScript framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>