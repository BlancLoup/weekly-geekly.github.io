<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Text version of the report "Actors vs CSP vs Tasks ..." with C ++ CoreHard Autumn 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In early November, another C ++ CoreHard Autumn 2018 conference dedicated to C ++ language was held in Minsk. The captain of the report ‚ÄúActors vs CSP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Text version of the report "Actors vs CSP vs Tasks ..." with C ++ CoreHard Autumn 2018</h1><div class="post__text post__text-html js-mediator-article">  In early November, another C ++ CoreHard Autumn 2018 conference dedicated to C ++ language was held in Minsk. The <a href="https://www.youtube.com/watch%3Fv%3DGihdujm6EWU">captain of the report ‚ÄúActors vs CSP vs Tasks ...‚Äù was</a> presented at it, where they talked about how a higher-level application than ‚Äú bare multithreading ‚Äù, competitive programming models.  Under the cut is converted into an article version of this report.  Brushed, in places corrected, in places supplemented. <br><br>  Taking this opportunity, I would like to thank the <a href="https://corehard.by/">CoreHard</a> community for organizing the next big conference in Minsk and for the opportunity to speak.  And also for the rapid publication of <a href="https://www.youtube.com/watch%3Fv%3DsrhdfL_ytwc%26list%3DPLgsLnJ-wgYTbaNXfp3mjf-eOb62Md9-33">video reports on YouTube</a> . <br><br>  So let's move on to the main topic of conversation.  Namely, we can use what approaches to simplify multithreaded programming in C ++, how the code will look at using some of these approaches, what features are inherent in specific approaches, what is common between them, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Note: in the original presentation of the report errors and typos were found, so the article will use slides from an updated and edited version, which can be found in <a href="https://docs.google.com/presentation/d/1C8-xbxPL4yosDEpUjhrwkIxkrbp8iKUZQ-ZfES8yYk4/edit%3Fusp%3Dsharing">Google Slides</a> or on <a href="https://www.slideshare.net/YauheniAkhotnikau/c-corehard-autumn-2018-actors-vs-csp-vs-task">SlideShare</a> . <br><br><h1>  ‚ÄúNaked multi-threading‚Äù is evil! </h1><br>  We need to start with the repeated banality, which, nevertheless, still remains relevant: <br><blockquote>  Multithreaded programming in C ++ by means of bare threads, mutexes, and condition variables are <b>sweat</b> , <b>pain,</b> and <b>blood</b> . </blockquote><a name="habracut"></a><br>  A good example was recently described here in this article here on Habr√©: "The <a href="https://habr.com/company/pixonic/blog/426875/">architecture of the meta-server mobile online shooter Tacticool</a> ."  In it, the guys talked about how they managed to collect, apparently, the full range of rakes associated with the development of multi-threaded code in C and C ++.  There were ‚Äúpassages‚Äù from memory as a result of races, and low productivity due to unsuccessful parallelization. <br><br>  As a result, it all ended quite naturally: <br><blockquote>  After a couple of weeks spent searching for and fixing the most critical bugs, we decided that it was <u>easier to rewrite everything from scratch</u> than to try to fix all the shortcomings of the current solution. </blockquote><br>  People ate C / C ++ while working on the first version of their server and rewrote the server in another language. <br><br>  A great demonstration of how in the real world, outside of our cozy C ++ community, developers refuse to use C ++ even where the use of C ++ is still appropriate and justified. <br><br><h2>  But why? </h2><br>  But why, if it has been said many times that ‚Äúbare multithreading‚Äù in C ++ is evil, people continue to use it with a stubbornness worthy of better use?  What is to blame: <br><br><ul><li>  ignorance? </li><li>  laziness? </li><li>  NIH syndrome? </li></ul><br>  After all, there is not a single time-tested approach and many projects.  In particular: <br><br><ul><li>  actors </li><li>  communicating sequential processes (CSP) </li><li>  tasks (async, promises, futures, ...) </li><li>  data flows </li><li>  reactive programming </li><li>  ... </li></ul><br>  It remains to hope that the main reason is still ignorance.  This is hardly taught in universities.  So young professionals, coming into the profession, use the little that they already know.  And if then the knowledge base is then not replenished, then people continue to use bare threads, mutexes, and condition_variables. <br><br>  Today we will talk about the first three approaches from this list.  And let's talk not abstract, but on the example of one simple little problem.  Let's try to show how the code solving this problem will look using Actors, CSP processes and channels, as well as using Tasks. <br><br><h1>  Task for experiments </h1><br>  You need to implement an HTTP server that: <br><br><ul><li>  accepts the request (picture ID, user ID); </li><li>  gives a picture with "watermarks", unique to this user. </li></ul><br>  For example, such a server may require some paid service, distributing content by subscription.  If a picture from this service then ‚Äúpops up‚Äù somewhere, then by ‚Äúwatermarks‚Äù on it it will be possible to understand who needs to ‚Äúturn off the oxygen‚Äù. <br><br>  The task is abstract, it was formulated specifically for this report under the influence of our Shrimp demo project (we have already told about it: <a href="https://habr.com/post/416387/">‚Ññ1</a> , <a href="https://habr.com/post/420353/">‚Ññ2</a> , <a href="https://habr.com/post/420353/">‚Ññ3</a> ). <br><br>  This our HTTP server will work as follows: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Having received a request from a client, we turn to two external services: <br><br><ul><li>  The first returns us information about the user.  Including from there we get a picture with "watermarks"; </li><li>  the second returns us the original image </li></ul><br>  Both of these services operate independently and we can access them both at the same time. <br><br>  Since the processing of requests can be done independently of each other, and even some actions when processing a single request can be done in parallel, the use of contention arises.  The simplest thing that comes to mind is to create a separate thread for each incoming request: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  But the ‚Äúone-request = one-worker-flow‚Äù model is too expensive and does not scale well.  We do not need it. <br><br>  Even if it is wasteful to approach the number of workflows, we still need a small number of them: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Here we need a separate stream for receiving incoming HTTP requests, a separate stream for our own outgoing HTTP requests, a separate stream for coordinating the processing of received HTTP requests.  As well as a pool of workflows for performing operations on images (since the manipulation of images is well parallel, then processing the image is not just a few streams, we reduce its processing time). <br><br>  Therefore, our goal is to process a large number of concurrent incoming requests on a small number of worker threads.  Let's take a look at how we will achieve this through various approaches. <br><br><h2>  Several important disclaimers </h2><br>  Before moving on to the main story and parsing code samples, you need to make a few notes. <br><br>  Firstly, all the following examples are not tied to any particular framework or library.  Any matches in API call names are random and unintended. <br><br>  Secondly, in the examples below, there is no error handling.  This was done deliberately, so that the slides turned out to be compact and observable.  And also to fit the material in the time allotted for the report. <br><br>  Thirdly, the examples use a certain entity, execution_context, which contains information about what else exists inside the program.  The content of this entity depends on the approach.  With the case of the actors in the execution_context there will be links to other actors.  In the case of CSP, in the execution_context there will be CSP-channels for communication with other CSP-processes.  Etc. <br><br><h1>  Approach # 1: Actors </h1><br><h2>  Pro Model Actors in a nutshell </h2><br>  When using the Model of Actors, the decision will be built from separate objects-actors, each of which has its own private state and this state is inaccessible to anyone except the actor. <br><br>  Actors interact with each other through asynchronous messages.  Each actor has its own unique mailbox (message queue) to which messages sent to the actor are saved and from where they are retrieved for further processing. <br><br>  Actors work on very simple principles: <br><br><ul><li>  an actor is an entity with behavior; </li><li>  actors respond to incoming messages; </li><li>  having received the message the actor can: <br><ul><li>  send some (finite) number of messages to other actors; </li><li>  create a certain (finite) number of new actors; </li><li>  define for yourself a new behavior for processing subsequent messages. </li></ul></li></ul><br>  Inside the application, actors can be implemented in different ways: <br><br><ul><li>  Each actor can be represented as a separate OS thread (this happens, for example, in C ++ library Just :: Thread Pro Actor Edition); </li><li>  each actor can be represented as stackful coroutine; </li><li>  Each actor can be represented as an object in which someone calls callback methods. </li></ul><br>  In our decision, we will use the actors as objects with callbacks, and leave the coroutines for the CSP approach. <br><br><h2>  Solution model based on Model Actors </h2><br>  On the basis of the actors, the general scheme for solving our problem will be as follows: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  We will have actors that are created at the start of the HTTP server and exist all the time while the HTTP server is running.  These are such actors as: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  When we receive a new incoming HTTP request, we create a new instance of the RequestHandler actor, which will be destroyed after issuing a response to an incoming HTTP request. <br><br><h2>  Actor code RequestHandler </h2><br>  The implementation of the request_handler actor, which coordinates the processing of an incoming HTTP request, can have the following form: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Let's break this code down. <br><br>  We have a class in the attributes of which we store or are going to store what we need to process the request.  Also in this class there is a set of callbacks that will be called at one time or another. <br><br>  First, when the actor is just created, the on_start () callback is called.  In it, we send two messages to other actors.  The first is the check_user message to verify the client ID.  The second is the download_image message for downloading the original image. <br><br>  In each of the sent messages, we pass a link to ourselves (calling the self () method returns a link to the actor for which you called self ()).  This is necessary so that our actor can send a message in response.  If we do not send the link to our actor, for example, in the check_user message, the UserChecker actor will not know who to send information about the user to. <br><br>  When a user_info message is sent to us with information about the user, the on_user_info () callback is called.  And when an image_loaded message is sent to us, our actor is called by the on_image_loaded () callback.  And inside these two callbacks we see a feature inherent in the Actor Model: we do not know exactly in which order the response messages will come to us.  Therefore, we must write our code so as not to depend on the order of receipt of messages.  Therefore, in each of the processors, we first store the received information in the corresponding attribute, and then we check, can we already have all the information we need?  If so, then we can move on.  If not, we will wait further. <br><br>  That is why we have if-s in on_user_info () and on_image_loaded (), when executed, send_mix_images_request () is called. <br><br><blockquote>  In principle, in implementations of Model Actors there can be mechanisms like selective receive from Erlang or stashing from Akka, by means of which you can manipulate the order of processing incoming messages, but we will not talk about this today, so as not to delve into the jungle of details of various implementations Actors. </blockquote><br>  So, if all the information we need from UserChecker and ImageDownloader is received, the send_mix_images_request () method is called, in which the mix_images message is sent to the ImageMixer actor.  The on_mixed_image () callback is called when we receive a response message with the resulting image.  Here we send this image to the HttpSrv actor and wait for HttpSrv to generate an HTTP response and destroy the RequestHandler that became unnecessary (although, in principle, nothing prevents the RequestHandler actor from destroying itself in the on_mixed_image () callback. <br><br>  That's all. <br><br>  The implementation of the RequestHandler actor is quite voluminous.  But this is due to the fact that we needed to describe a class with attributes and callbacks, and then also implement callbacks.  But the logic of RequestHandler‚Äôs operation is rather trivial and it‚Äôs easy to understand it, despite the amount of code in the request_handler class. <br><br><h2>  Features inherent in actors </h2><br>  Now we can say a few words about the features of the Model Actors. <br><br><h3>  Actors are reactive </h3><br>  As a rule, actors respond only to incoming messages.  There are messages - the actor handles them.  No messages - the actor does nothing. <br><br>  This is especially true for those implementations of the Actor Model, in which actors are represented as objects with callbacks.  The framework pulls the callback from the actor and if the actor does not return control from the callback, then the framework cannot serve other actors in the same context. <br><br><h3>  Actors are subject to overloads </h3><br>  On actors, we can very easily make the actor-producer generate messages for the actor-consumer with a much higher rate than the actor-consumer will be able to process. <br><br>  This will lead to the fact that the queue of incoming messages for the consumer actor will constantly grow.  Queue growth, i.e.  The growth of memory consumption in the application will reduce the speed of the application.  This will lead to an even faster queue growth and, as a result, the application may degrade to complete inoperability. <br><br>  All this is a direct consequence of the asynchronous interaction of actors.  Since the send operation is usually non-blocking.  And to make it blocking is not easy, because  an actor can send to itself.  And if the queue for the actor is full, then on the send-ae, the actor itself will be blocked and this will stop its work. <br><br>  So when working with actors you need to pay serious attention to the problem of overload. <br><br><h3>  Many actors are not always the solution. </h3><br>  As a rule, actors are lightweight entities and there is a temptation to create them in large quantities in your application.  You can create ten thousand actors, one hundred thousand and a million.  And even one hundred million actors, if iron allows you. <br><br>  But the problem is that the behavior of a very large number of actors is difficult to track.  Those.  you may have some actors that obviously work correctly.  Part of the actors who either obviously work incorrectly or do not work at all and you know about it for sure.  But there can be a large number of actors about whom you do not know anything: they work at all, whether they work correctly or incorrectly.  And all because when you have a hundred million autonomous entities with your own logic of behavior in your program, it‚Äôs very difficult to follow all of this. <br><br>  Therefore, it may happen that by creating a large number of actors in the application, we do not solve our application problem, but we get another problem.  And, therefore, it may be advantageous for us to abandon the simple actors who solve a single task in favor of more complex and heavy actors who perform several tasks.  But then there will be fewer such ‚Äúheavy‚Äù actors in our application and it will be easier for us to follow them. <br><br><h2>  Where to look, what to take? </h2><br>  If someone wanted to try to work with the actors in C ++, then it makes no sense to build your own bikes, there are several ready-made solutions, in particular: <br><br><ul><li>  <a href="https://stiffstream.com/en/products/sobjectizer.html">SObjectizer</a> (support domestic producer!) </li><li>  <a href="http://actor-framework.org/">C ++ Actor Framework (CAF)</a> </li><li>  <a href="https://www.state-machine.com/qpcpp/">QP / C ++</a> </li></ul><br>  These three options are live, developing, cross-platform, documented.  And you can try them for free.  Plus a few more options of varying degrees of [not] freshness can be found <a href="https://en.wikipedia.org/wiki/Actor_model">on the list in Wikipedia</a> . <br><br>  SObjectizer and CAF are intended for use in sufficiently high-level tasks where exceptions and dynamic memory can be applied.  And the QP / C ++ framework may be of interest to those involved in embedded development, since  it is precisely under this niche that he is ‚Äúimprisoned.‚Äù <br><br><h1>  Approach # 2: CSP (communicating sequential processes) </h1><br><h2>  CSP on fingers and no matane </h2><br>  The CSP model is very similar to the Actor Model.  We also build our solution from a set of autonomous entities, each of which has its own private state and interacts with other entities only through asynchronous messages. <br><br>  Only these entities in the CSP model are called ‚Äúprocesses‚Äù. <br><br>  Processes in CSP are lightweight, without any parallelization of their work inside.  If we need to parallelize something, then we simply run several CSP processes, within which there is no parallelization. <br><br>  CSP-shny processes interact with each other through asynchronous messages, but messages are not sent to mailboxes, as in the Actor Model, but into channels.  Channels can be thought of as message queues, usually of fixed size. <br><br>  Unlike the Actor Model, where a mailbox is automatically created for each actor, the channels in the CSP must be created explicitly.  And if we need the two processes to interact with each other, then we have to create the channel ourselves, and then tell the first process "you will write here", and the second process must say: "you will read here from here." <br><br>  In this case, the channels have at least two operations that need to be called explicitly.  The first is the write (send) operation to write a message to the channel. <br><br>  Secondly, it is the operation read (receive) to read the message from the channel.  And the need to explicitly call read / receive distinguishes the CSP from the Actor Model, since  in the case of actors, the read / receive operation can be generally hidden from the actor.  Those.  the actor framework can retrieve messages from the actor's queue and call the handler (callback) for the retrieved message. <br><br>  While the CSP-shny process itself must choose the time to call read / receive, then the CSP-shny process must determine what message it received and process the extracted message. <br><br>  Inside our ‚Äúbig‚Äù application, CSP processes can be implemented in different ways: <br><br><ul><li>  CSP-shny process can be implemented as a separate OS thread.  It turns out an expensive solution, but with preemptive multitasking; </li><li>  CSP-shny process can be implemented coroutine (stackful coroutine, fiber, green thread, ...).  It is much cheaper, but multitasking is only cooperative. </li></ul><br>  Further, we will assume that CSP-shny processes are presented in the form of stackful coroutines (although the code shown below may well be implemented on OS threads). <br><br><h2>  CSP based solution </h2><br>  The solution scheme based on the CSP model will very strongly resemble a similar scheme for the Actor Model (and this is no accident): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  There will also be entities that are started at the start of the HTTP server and run all the time - these are the CSP processes HttpSrv, UserChecker, ImageDownloader and ImageMixer.  For each new incoming request, a new RequestHandler CSP process will be created.  This process sends and receives the same messages as when using the Actor Model. <br><br><h2>  Code of CSP-shny process RequestHandler </h2><br>  This is how the code of the function implementing the RequestHandler CSP-process may look like: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Here everything is rather trivial and the same pattern repeats regularly: <br><br><ul><li>  First we create a channel for receiving response messages.  This is necessary because  a CSP process has no mailbox by default, like actors.  Therefore, if the CSP-shny process wants to get something, then it should be puzzled by the creation of a channel where this ‚Äúsomething‚Äù will be recorded; </li><li>  then we send our message to the CSP process executable.  And in this message we indicate the channel for the response message; </li><li>  then we perform a read operation from the channel to which we must send a response message. </li></ul><br>  This is clearly seen in the example of communication with the ImageMixer CSP-shny process: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  But separately it is worthwhile to focus attention on this fragment: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Here we see another major difference from the Model Actors.  In the case of CSP, we can receive response messages in the order that suits us. <br><br>  Want to wait for user_info first?  No problem, we fall asleep on the read-e until user_info appears.  If by this time image_loaded has already been sent to us, then it will just wait in its channel until we read it. <br><br>  That is, in fact, everything that can be used to accompany the code shown above.  The code based on CSP turned out to be more compact than its counterpart on the basis of actors.  What is not surprising, since  here we did not have to describe a separate class with callback methods.  Yes, and part of the state of our RequestHandler CSP process is implicitly present in the form of ctx and req arguments. <br><br><h2>  CSP Features </h2><br><h3>  Reactivity and proactivity of CSP-shny processes </h3><br>  Unlike actors, CSP-shny processes can be both reactive, and proactive, both.  Say, the CSP-shny process checked its incoming messages, if they were, it processed them.  And then, seeing that there were no incoming messages, he undertook to multiply the matrices. <br><br>  After some time, the CSP-shnomu process matrix multiply tired and he once again checked for incoming messages.  No new ones?  Well, okay, let's go multiply the matrices further. <br><br>  And this ability of CSP processes to perform some work, even in the absence of incoming messages, strongly distinguishes the CSP model from the Actors Model. <br><br><h3>  Native overload protection mechanisms </h3><br>  Since, as a rule, channels are queues of messages of a limited size and the attempt to write a message to the filled channel suspends the sender, we have a built-in overload protection mechanism in the CSP. <br><br>  Indeed, if we have a smart process-producer and a slow process-consumer, then the producer-process will quickly fill the channel and it will be suspended for the next send operation.  And the producer-process will sleep until the consumer-process releases space in the channel for new messages.  As soon as a place appears, the producer-process will wake up and add new messages to the channel. <br><br>  Thus, when using CSP, we can worry less about the problem of overload than in the case of the Actor Model.  The truth is that there is a pitfall, which we will talk about later. <br><br><h3>  How are CSP processes implemented? </h3><br>  We need to decide how our CSP processes will be implemented. <br><br>  It can be done so that each CSP-shny process will be represented by a separate OS thread.  It turns out expensive and not scalable solution.  But on the other hand, we get preemptive multitasking: if our CSP-shny process starts multiplying matrices or makes some kind of blocking call, then the OS will eventually push it out of the computational core and allow other CSP-processes to work. <br><br>  You can make each CSP-shny process be represented by a coroutine (stackful coroutine).  This is a much cheaper and scalable solution.  But here we will only have cooperative multitasking.  Therefore, if suddenly the CSP-shny process is engaged in the multiplication of matrices, then the working thread with this CSP-shny process and other CSP-shny processes that are attached to it will be blocked. <br><br>  There may be another trick.  Suppose we use a third-party library, on the inside of which we can not influence.  And inside the library, TLS variables are used (i.e. thread-local-storage).  We make one call to the library function and the library sets the value of some TLS variable.  Then our coroutine "moves" to another working thread, and this is possible, because  in principle, coroutines can migrate from one working thread to another.  We make the next call to the library function and the library is trying to read the value of the TLS variable.  But there may already be another value!  And to search for such a bug will be very difficult. <br><br>  Therefore, it is necessary to carefully consider the choice of the method of implementing CSP-shnyh processes.  Each option has its strengths and weaknesses. <br><br><h3>  Many processes are not always a solution. </h3><br>  Just as with actors, the ability to create many CSP processes in their program is not always a solution to an applied problem, but the creation of additional problems for oneself. <br><br>  Moreover, the poor visibility of what is happening inside the program is only one part of the problem.  I want to focus on another pitfall. <br><br>  The fact is that on the CSP-shnyh channels you can easily get an analogue of the deadlock.  Process A attempts to write the message to the full channel C1 and process A is suspended.  From channel C1 must read process B, which he tried to write to channel C2, which is full and, therefore, process B was suspended.  And from channel C2 I had to read process A. Everything, we got deadlock. <br><br>  If we have only two CSP processes, then we can find a similar deadlock during the debugging process or even during the code review procedure.  But if we have millions of processes in the program, they actively communicate with each other, then the probability of the occurrence of such deadlocks increases significantly. <br><br><h2>  Where to look, what to take? </h2><br>  If someone wants to work with CSP in C ++, then the choice here, unfortunately, is not as big as for the actors.  Well, or I do not know where to look and how to search.  In this case, I hope, in the comments will share other links. <br><br>  But, if we want to use CSP in our home, then first of all we need to look in the direction of <a href="https://www.boost.org/doc/libs/1_68_0/libs/fiber/doc/html/index.html">Boost.Fiber</a> .  There are fiber-s (i.e. coroutines), and channels, and even such low-level primitives as mutex, condition_variable, barrier.  All this can be taken and used. <br><br>  If you are satisfied with the CSP-shny processes in the form of threads, then you can look at the <a href="https://stiffstream.com/en/products/sobjectizer.html">SObjectizer</a> .  There are also analogs of CSP shny channels and complex multi-threaded applications on SObjectizer, you can write without any actors at all. <br><br><h1>  Actors vs CSP </h1><br>  Actors and CSP processes are very similar to each other.  It has been repeatedly found that the two models are equivalent to each other.  Those.  what can be done on actors can almost be repeated 1-in-1 on CSP processes and vice versa.  They say that it is even proven mathematically.  But here I do not understand anything, so I can not say anything.  But from his own thoughts somewhere at the level of common sense, it all looks quite plausible.  In some cases, indeed, actors can be replaced by CSP processes, and CSP processes by actors. <br><br>  However, the actors and CSP have several differences that can help determine where it is advantageous or unprofitable to use each of these models. <br><br><h2>  Channels vs mailbox </h2><br>  The actor has a single ‚Äúchannel‚Äù for receiving incoming messages - this is its mailbox, which is automatically created for each actor.  And the actor retrieves messages from there sequentially, exactly in the order in which the messages got into the mailbox. <br><br>  And this is quite a serious question.  Suppose there are now three messages in the actor's mailbox: M1, M2 and M3.  Actor is currently only interested in M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But before you get to the M3, the actor will extract first M1, then M2. </font><font style="vertical-align: inherit;">And what will he do with them?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Again, within the framework of this conversation, we will not touch upon selective receive mechanisms from Erlang and stashing from Akka. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While the CSP-shny process has the ability to select the channel from which he currently wants to read messages. </font><font style="vertical-align: inherit;">So, a CSP process can have three channels: C1, C2 and C3. </font><font style="vertical-align: inherit;">Currently, the CSP process is only interested in messages from C3. </font><font style="vertical-align: inherit;">This is the channel process and reads. </font><font style="vertical-align: inherit;">And to the contents of channels C1 and C2, he will return when he is interested in this.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reactivity and proactivity </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a rule, actors are reactive and work only when they have incoming messages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While CSP processes can do some work even in the absence of incoming messages. </font><font style="vertical-align: inherit;">In some scenarios, this difference may play an important role.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> State machines </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In essence, actors are finite automata (SV). </font><font style="vertical-align: inherit;">Therefore, if there are many finite automata in your subject area, and even if these are complex, hierarchical finite automata, then it can be much easier to implement them on the basis of the model of actors than by adding the implementation of a spacecraft to the CSP process.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In C ++, there is no native CSP support yet. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The experience of the Go language shows how easy and convenient it is to use the CSP model when its support is implemented at the level of a programming language and its standard library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go, it is easy to create ‚ÄúCSP processes‚Äù (aka goroutines), it is easy to create and work with channels, there is a built-in syntax for working with several channels at once (Go-shny select, which works not only for reading but also for writing) The standard library knows about the Goroutines and can switch them when Goroutin makes a blocking call from stdlib. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++, there is no stackful coroutines support yet (at the language level). </font><font style="vertical-align: inherit;">Therefore, working with CSP in C ++ can look, in places, if not a crutch, then ... Then surely it requires much more attention to itself than in the case of the same Go.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Approach # 3: Tasks (async, future, wait_all, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About Task-based approach with the most common words </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The meaning of the Task-based approach is that if we have a complicated operation, then we divide this operation into separate steps-tasks, where each task (it‚Äôs a task) performs some one sub-operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start these tasks with a special async operation. </font><font style="vertical-align: inherit;">The async operation returns a future object, in which, after the task is completed, the value returned by the task will be placed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After we run N tasks and get N objects of the future, we need to somehow knit it all into a chain. </font><font style="vertical-align: inherit;">It seems that when tasks No. 1 and No. 2 are completed, the values ‚Äã‚Äãreturned by them should fall into task No. 3. </font><font style="vertical-align: inherit;">And when task No. 3 is completed, the returned value should be transferred to tasks No. 4, No. 5, and No. 6. </font><font style="vertical-align: inherit;">Etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For such "provings" special means are used. </font><font style="vertical-align: inherit;">Such, for example, as the .then () method of the future object, as well as the wait_all (), wait_any () functions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This explanation on the fingers may not be very clear, so let's move on to the code. </font><font style="vertical-align: inherit;">Maybe in a conversation about a specific code, the situation will be clarified (but not a fact).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Request_handler code for the Task-based approach </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The code for processing an incoming HTTP request based on tasks can look like this: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to figure out what's going on here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we create a task that should start in the context of our own HTTP client and which requests information about the user. The returned future object is stored in the user_info_ft variable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we create a similar task, which should also run on the context of our own HTTP client and which loads the original image. The returned future object is stored in the variable original_image_ft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we need to wait for the first two tasks. </font><font style="vertical-align: inherit;">What we directly write: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">When both future objects get their values, then we will run another task. </font><font style="vertical-align: inherit;">This task will take a bitmask with watermarks and the original image and run another task in the context of ImageMixer. </font><font style="vertical-align: inherit;">This task mixes the images, and when it completes, another task will start in the context of the HTTP server, which will generate an HTTP response. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probably this explanation of what is happening in the code is not much clarified. </font><font style="vertical-align: inherit;">Therefore, let's enumerate our tasks:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And look at the dependencies between them (from which the order in which tasks are carried out): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And if we now impose this image on our source code, then I hope it will become clearer: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Features of the task-based approach </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibility </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first feature that should already become apparent is the visibility of the code on the Task. </font><font style="vertical-align: inherit;">She's not doing well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can mention such a thing as callback hell. </font><font style="vertical-align: inherit;">Node.js programmers are very familiar with it. </font><font style="vertical-align: inherit;">But C ++ nicknames, which work closely with Task, also dip into this very callback hell.</font></font><br><br><h3>  Error processing </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another interesting feature is error handling. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, in the case of async and future, delivering error information to the interested party can be even easier than in the case of actors or CSP. </font><font style="vertical-align: inherit;">After all, if in CSP, process A sends a request to process B and waits for a response message, then when an error occurs in B when executing the request, we need to decide how to deliver an error to process A:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or we will make a separate message type and channel to receive it; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or we give the result in a single message, in which the std :: variant will be for a normal and erroneous result. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the case of the future, everything is simpler: we extract either a normal result from the future, or we are thrown an exception. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, on the other hand, we can easily run into a cascade of errors. </font><font style="vertical-align: inherit;">For example, an exception occurred in task # 1; this exception fell into the future object, which was passed to task # 2. </font><font style="vertical-align: inherit;">In problem number 2, we tried to take the value from the future, but received an exception. </font><font style="vertical-align: inherit;">And, most likely, we will throw out the same exception. </font><font style="vertical-align: inherit;">Accordingly, it will fall into the next future, which will go to the task number 3. </font><font style="vertical-align: inherit;">There will also be an exception, which, quite possibly, will also be released outside.</font></font> Etc. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If our exceptions are logged, then in the log we will be able to see the repeated repetition of the same exception, which is transferred from one task in the chain to another task. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cancel Task and Timers / Timeouts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And another very interesting feature of the Task-based hike is the cancellation of tasks if something went wrong. </font><font style="vertical-align: inherit;">In fact, let's say we created 150 tasks, completed the first 10 of them, and realized that everything further work does not make sense to continue. </font><font style="vertical-align: inherit;">How do we cancel 140 remaining? </font><font style="vertical-align: inherit;">This is a very, very good question :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another similar question is how to make friends tasks with timers and timeouts. </font><font style="vertical-align: inherit;">Suppose we are accessing some kind of external system and want to limit the waiting time to 50 milliseconds. </font><font style="vertical-align: inherit;">How do we set the timer, how to react to the expiration of the timeout, how to interrupt the task chain if the timeout has expired? </font><font style="vertical-align: inherit;">Again, asking is easier than answering :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cheating </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, more to the conversation about the features of the Task-based approach. </font><font style="vertical-align: inherit;">In the example shown, a small cheating was applied:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I sent two tasks to the context of our own HTTP server, each of which performs a blocking operation inside. </font><font style="vertical-align: inherit;">In fact, in order to be able to handle two requests to third-party services in parallel, here it was necessary to create their own chains of asynchronous tasks. </font><font style="vertical-align: inherit;">But I did not do this in order to make the decision more or less observable and fit on the slide of the presentation.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actors / CSP vs Tasks </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We looked at three approaches and saw that if the actors and CSP processes are similar to each other, then the Task-based approach is not similar to any of them. And it may seem that Actors / CSP should be opposed to Task. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But personally, I like a different point of view. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we talk about the Model Actors and CSP, we are talking about the decomposition of its task. In our task we single out separate independent entities and describe the interfaces of these entities: which messages they send, which ones receive, through which channels the messages go.</font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">working with actors and CSP we are talking about interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, let's say, we split the task into separate actors and CSP-processes. How exactly do they do their work? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we take on the Task-based approach, we start talking about implementation. How the concrete work is performed, what sub-operations are performed, in what order, how these sub-operations are connected by data, etc.</font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">working with Task we are talking about implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consequently, Actors / CSP and Tasks do not so much confront each other as complement each other. </font><font style="vertical-align: inherit;">Actors / CSPs can be used to decompose a task and define interfaces between components. </font><font style="vertical-align: inherit;">And Tasks can then be used to implement specific components. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, when using Actors, we have an entity such as ImageMixer, which needs to be manipulated with images on a pool of worker threads. </font><font style="vertical-align: inherit;">In general, nothing prevents us from using the Task-based approach in the implementation of the ImageMixer actor.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Where to look, what to take? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you wanted to work with Task-s in C ++, then you can look towards the standard library of the upcoming C ++ 20. They have already added the .then () method to the future, as well as the free wait_all () and wait_any functions. For details, refer </font></font><a href="https://en.cppreference.com/w/cpp/experimental/concurrency"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to cppreference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, there is no longer a new </font></font><a href="https://github.com/Amanieu/asyncplusplus"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async ++ library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In which, in principle, has everything you need, just a little under a different sauce. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there is another older </font></font><a href="https://msdn.microsoft.com/en-us/library/dd492427.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PPL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">. Which also gives everything that is needed, but under its own sauce.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate addition about the Intel TBB library. </font><font style="vertical-align: inherit;">It was not mentioned in the story about the Task-based approach because, in my opinion, task graphs from TBB are already a data flow approach. </font><font style="vertical-align: inherit;">And, if this report gets its continuation, then the speech about Intel TBB is sure to go, but in the context of the story about data flow.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Another interesting </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recently here, on Habr√©, there was an article by Anton Polukhin: " </font></font><a href="https://habr.com/company/yandex/blog/420861/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparing for C ++ 20. Coroutines TS with a real example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It talks about combining the Task-based approach with stackless coroutines from C ++ 20. </font><font style="vertical-align: inherit;">And it turned out that the code on the basis of Task readability approached the readability of the code on CSP processes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So if someone is interested in the Task-based approach, then it makes sense to read this article.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, it's time to move on to the results, the benefit of them is not so much. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main thing that I want to say is that in the modern world bare multithreading you may need unless you are developing some kind of framework or solving some specific and low-level task. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you are writing application code, then you hardly need bare threads, low-level synchronization primitives, or some lock-free algorithms with lock-free containers. </font><font style="vertical-align: inherit;">For a long time there are approaches that have been tested by time and have proven themselves well:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actors </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> communicating sequential processes (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tasks (async, promises, futures, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data flows </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reactive programming </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And most importantly, for them in C ++ there are ready-made tools. </font><font style="vertical-align: inherit;">You do not need to ride a bike, you can take it, try it and, if you like it, put it into operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So simple: take, try and start up in operation.</font></font></div><p>Source: <a href="https://habr.com/ru/post/430672/">https://habr.com/ru/post/430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430662/index.html">Monitoring Windows servers on pure MS SQL, and how I secretly implemented it</a></li>
<li><a href="../430664/index.html">The role of team leader in recruiting</a></li>
<li><a href="../430666/index.html">How to evaluate the effectiveness of the team</a></li>
<li><a href="../430668/index.html">There is safety in numbers. The path to effective teamwork</a></li>
<li><a href="../430670/index.html">Contract Management</a></li>
<li><a href="../430674/index.html">The logic of building universal work schedules</a></li>
<li><a href="../430676/index.html">Antiquities: shshsh, sssssss, VOIP, BBS and other modem friends</a></li>
<li><a href="../430678/index.html">Test ten dimmers with LED lamps</a></li>
<li><a href="../430680/index.html">Writing a simple processor and environment for it</a></li>
<li><a href="../430682/index.html">Three years of the lunar microsatellite project: stages of maturation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>