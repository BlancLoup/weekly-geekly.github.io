<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trello Clone on Phoenix and React. Parts 6-7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (current material is highlighted) 

1. Introduction and selection of technology stack 
2. Initial setup of the Phoenix Framework pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trello Clone on Phoenix and React. Parts 6-7</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/243/e80/106/243e801065424d89b26bf7d322e36c0a.png"></div><br><p><br></p><br><div class="spoiler">  <b class="spoiler_title">Table of Contents (current material is highlighted)</b> <div class="spoiler_text"><ol><li>  <a href="https://habrahabr.ru/post/308056/">Introduction and selection of technology stack</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">Initial setup of the Phoenix Framework project</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">User Model and JWT Authentication</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Front-end for registration on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Initial database population and controller to enter the application</a> </li><li>  <strong>Front-end authentication on React and Redux</strong> </li><li>  <strong>We configure sockets and channels</strong> </li><li>  <a href="https://habrahabr.ru/post/308382/">We display the list and create new boards</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">Add new board users</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We trace the connected users of boards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">Add lists and cards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We spread the project on Heroku</a> </li></ol></div></div><br><p>  Now that the <a href="https://habrahabr.ru/post/308100/">back-end is ready to</a> serve authentication requests, let's go to the front-end and see how to create and send these requests and how to use the returned data to allow the user access to personal sections. </p><a name="habracut"></a><br><h3 id="fayly-marshrutov">  Route Files </h3><br><p>  Before continuing, let's look again at the React routes file: </p><br><pre><code class="hljs pgsql">// web/static/js/routes/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IndexRoute, Route } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MainLayout <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../layouts/main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AuthenticatedContainer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../containers/authenticated'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HomeIndexView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/home'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RegistrationsNew <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/registrations/new'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SessionsNew <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/sessions/new'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BoardsShowView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/boards/show'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CardsShowView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/cards/show'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ( &lt;Route component={MainLayout}&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/sign_up" component={RegistrationsNew} /&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/sign_in" component={SessionsNew} /&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/" component={AuthenticatedContainer}&gt; &lt;IndexRoute component={HomeIndexView} /&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/boards/:id" component={BoardsShowView}&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="cards/:id" component={CardsShowView}/&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Route&gt; );</code> </pre> <br><p>  As we saw in the <a href="https://habrahabr.ru/post/308100/">fourth part</a> , the <code>AuthenticatedContainer</code> prohibit users from accessing the board screens, except when the <strong>jwt-</strong> token resulting from the authentication process is present and correct. </p><br><h3 id="komponent-predstavleniya-view-component">  View component </h3><br><p>  Now you need to create the <code>SessionNew</code> component, which will draw the application login form: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {PropTypes} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Link } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { setDocumentTitle } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../utils'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/sessions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SessionsNew extends React.Component { componentDidMount() { setDocumentTitle(<span class="hljs-string"><span class="hljs-string">'Sign in'</span></span>); } _handleSubmit(e) { e.preventDefault(); const { email, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> } = this.refs; const { dispatch } = this.props; dispatch(Actions.signIn(email.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } _renderError() { const { error } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="error"&gt; {error} &lt;/div&gt; ); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className=<span class="hljs-string"><span class="hljs-string">'view-container sessions new'</span></span>&gt; &lt;main&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>&gt; &lt;div className="logo" /&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>&gt; &lt;form onSubmit={::this._handleSubmit}&gt; {::this._renderError()} &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="email" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="Email" placeholder="Email" required="true" defaultValue="john@phoenix-trello.com"/&gt; &lt;/div&gt; &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="password" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="password" placeholder="Password" required="true" defaultValue="12345678"/&gt; &lt;/div&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit"&gt;Sign <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>&lt;/button&gt; &lt;/form&gt; &lt;Link <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>="/sign_up"&gt;<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> account&lt;/Link&gt; &lt;/main&gt; &lt;/div&gt; ); } } const mapStateToProps = (state) =&gt; ( state.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span> ); export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(mapStateToProps)(SessionsNew);</code> </pre> <br><p>  In general, this component draws the form and calls the constructor of the <code>signIn</code> action when sending it last.  It will also be connected to the repository in order to have access to its properties, which will be updated using the session converter;  as a result, we will be able to show the user data verification errors. </p><br><h3 id="konstruktor-deystviya-action-creator">  Action Creator </h3><br><p>  Following the direction of user actions, we will create a session action constructor: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web<span class="hljs-regexp"><span class="hljs-regexp">/static/js/actions/sessions.js import { routeActions } from 'redux-simple-router'; import Constants from '../constants'; import { Socket } from 'phoenix'; import { httpGet, httpPost, httpDelete } from '../utils'; function setCurrentUser(dispatch, user) { dispatch({ type: Constants.CURRENT_USER, currentUser: user, }); /</span></span>/ ... }; const Actions = { signIn: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email, password)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { const data = { session: { email: email, password: password, }, }; httpPost(<span class="hljs-string"><span class="hljs-string">'/api/v1/sessions'</span></span>, data) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>, data.jwt); setCurrentUser(dispatch, data.user); dispatch(routeActions.push(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)); }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { error.response.json() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errorJSON)</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ type: Constants.SESSIONS_ERROR, error: errorJSON.error, }); }); }); }; }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Actions;</code> </pre> <br><p>  The <code>signIn</code> function will create a POST request that transmits the email and password specified by the user.  If the authentication to the back-end is successful, the function saves the received jwt-token to <code>localStorage</code> and sends the <code>localStorage</code> JSON structure to the repository.  If for some reason the authentication results in errors, instead, the function will redirect them, and we will be able to show them in the login form of the application. </p><br><h3 id="preobrazovatel-reducer">  Converter (reducer) </h3><br><p>  Create a <code>session</code> converter: </p><br><pre> <code class="hljs lua">// web/static/js/reducers/session.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { currentUser: null, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: null, }; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = initialState, action = {})</span></span></span></span> { switch (action.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case Constants.CURRENT_USER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, currentUser: action.currentUser, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: null }; case Constants.SESSIONS_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: action.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span> }; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  There is little that can be added, since everything is obvious from the code, so we change the <code>authenticated</code> container so that it can handle the new state: </p><br><h3 id="konteyner-authenticated">  Container authenticated </h3><br><pre> <code class="hljs pgsql">// web/static/js/containers/authenticated.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../actions/sessions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { routeActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-simple-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../layouts/header'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AuthenticatedContainer extends React.Component { componentDidMount() { const { dispatch, currentUser } = this.props; const phoenixAuthToken = localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phoenixAuthToken &amp;&amp; !currentUser) { dispatch(Actions.currentUser()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phoenixAuthToken) { dispatch(routeActions.push(<span class="hljs-string"><span class="hljs-string">'/sign_in'</span></span>)); } } render() { const { currentUser, dispatch } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentUser) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="application-container"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> currentUser={currentUser} dispatch={dispatch}/&gt; &lt;div className="main-container"&gt; {this.props.children} &lt;/div&gt; &lt;/div&gt; ); } } const mapStateToProps = (state) =&gt; ({ currentUser: state.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.currentUser, }); export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(mapStateToProps)(AuthenticatedContainer);</code> </pre> <br><p>  If when connecting this component the authentication token already exists, but there is no <code>currentUser</code> in the storage, the component will call the <code>currentUser</code> action <code>currentUser</code> to get user data from the back-end.  Add it: </p><br><pre> <code class="hljs lua">// web/static/js/actions/sessions.js // ... const Actions = { // ... currentUser: () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { httpGet(<span class="hljs-string"><span class="hljs-string">'/api/v1/current_user'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> { setCurrentUser(dispatch, data); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>); dispatch(routeActions.push(<span class="hljs-string"><span class="hljs-string">'/sign_in'</span></span>)); }); }; }, // ... } // ...</code> </pre> <br><p>  This will close us when the user refreshes the browser page or goes to the root URL again, without having previously logged off.  Following what has already been said, after the user is authenticated and the <code>currentUser</code> transferred to the (state) state, this component will start the normal drawing, showing the header component and its own nested child routes. </p><br><h3 id="komponent-zagolovka">  Header component </h3><br><p>  This component will <a href="https://ru.gravatar.com/">draw the gravatar</a> and user name along with a link to the boards and an exit button. </p><br><pre> <code class="hljs pgsql">// web/static/js/layouts/<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Link } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../actions/sessions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactGravatar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-gravatar'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> extends React.Component { constructor() { super(); } _renderCurrentUser() { const { currentUser } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentUser) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } const fullName = [currentUser.first_name, currentUser.last_name].<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;a className="current-user"&gt; &lt;ReactGravatar email={currentUser.email} https /&gt; {fullName} &lt;/a&gt; ); } _renderSignOutLink() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!this.props.currentUser) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;a href="#" onClick={::this._handleSignOutClick}&gt;&lt;i className="fa fa-sign-out"/&gt; Sign <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>&lt;/a&gt; ); } _handleSignOutClick(e) { e.preventDefault(); this.props.dispatch(Actions.signOut()); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span> className="main-header"&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>="/"&gt;&lt;i className="fa fa-columns"/&gt; Boards&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Link <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>=<span class="hljs-string"><span class="hljs-string">'/'</span></span>&gt; &lt;span className=<span class="hljs-string"><span class="hljs-string">'logo'</span></span>/&gt; &lt;/Link&gt; &lt;nav className="right"&gt; &lt;ul&gt; &lt;li&gt; {this._renderCurrentUser()} &lt;/li&gt; &lt;li&gt; {this._renderSignOutLink()} &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>&gt; ); } }</code> </pre> <br><p>  When a user <code>singOut</code> exit button, the <code>singOut</code> method of the <code>session</code> action constructor is called.  Add this method: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web<span class="hljs-regexp"><span class="hljs-regexp">/static/js/actions/sessions.js /</span></span>/ ... const Actions = { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... signOut: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { httpDelete(<span class="hljs-string"><span class="hljs-string">'/api/v1/sessions'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { localStorage.removeItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>); dispatch({ type: Constants.USER_SIGNED_OUT, }); dispatch(routeActions.push(<span class="hljs-string"><span class="hljs-string">'/sign_in'</span></span>)); }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(function(error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }); }; }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br><p>  It will send a <code>DELETE</code> request to the back-end and, if successful, will remove the <code>phoenixAuthToken</code> from <code>localStorage</code> , and also send an <code>USER_SIGNED_OUT</code> action that <code>currentUser</code> in the (state) state using the previously described session converter: </p><br><pre> <code class="hljs lua">// web/static/js/reducers/session.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { currentUser: null, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: null, }; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = initialState, action = {})</span></span></span></span> { switch (action.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { // ... case Constants.USER_SIGNED_OUT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initialState; // ... } }</code> </pre> <br><h3 id="eschyo-koe-chto">  Something else </h3><br><p>  Although we are done with the process of authenticating and logging the user into the application, we have not yet implemented the key functionality that will become the basis of all the future features that we will program: <strong>user sockets and channels</strong> .  This moment is so important that I would rather prefer to leave it for the next part, where we will see what the <code>userSocket</code> looks like and how to connect to it, so that we have bi-directional channels between the front-end and back-end, showing the changes in real time . </p><br><a name="7"></a><br><h2 id="sokety-i-kanaly">  Sockets and channels </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-7">Original</a> </p><br><p>  In the previous section, we completed the authentication process and are now ready to start the fun.  From now on, to connect the front-end and back-end, we will largely rely on Phoenix's real-time capabilities.  Users will be notified of any events affecting their whiteboards, and the changes will be automatically displayed on the screen. </p><br><p>  We can represent channels (channels) as a whole as controllers.  But unlike processing the request and returning the result in one connection, they handle bidirectional events on a given topic that can be transmitted to several connected recipients.  To configure them, Phoenix uses socket handlers (socket handlers), which authenticate and identify the connection to the socket, as well as describe the routes of the channels that determine which channel processes the corresponding request. </p><br><h3 id="polzovatelskiy-soket-user-socket">  User socket </h3><br><p>  When creating a new Phoenix application, it automatically creates for us the initial configuration of the socket: </p><br><pre> <code class="hljs vbscript"># lib/phoenix_trello/endpoint.ex defmodule PhoenixTrello.Endpoint <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Phoenix.Endpoint, otp_app: :phoenix_trello socket <span class="hljs-string"><span class="hljs-string">"/socket"</span></span>, PhoenixTrello.UserSocket # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  <code>UserSocket</code> is also <code>UserSocket</code> , but we will need to make some changes to it in order to process the necessary messages: </p><br><pre> <code class="hljs vbscript"># web/channels/user_socket.ex defmodule PhoenixTrello.UserSocket <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Phoenix.Socket alias PhoenixTrello.{Repo, User} # Channels channel <span class="hljs-string"><span class="hljs-string">"users:*"</span></span>, PhoenixTrello.UserChannel channel <span class="hljs-string"><span class="hljs-string">"boards:*"</span></span>, PhoenixTrello.BoardChannel # Transports transport :websocket, Phoenix.Transports.WebSocket transport :longpoll, Phoenix.Transports.LongPoll # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In fact, we will have two different channels: </p><br><ul><li>  <code>UserChannel</code> will process messages on any topic starting with `" users: ", and we will use it to inform users about events related to them, for example, if they were invited to join the board. </li><li>  <code>BoardChannel</code> will have the main functionality, processing messages for managing boards, lists and cards, informing any user viewing the board directly at the moment about any changes. </li></ul><br><p>  We also need to implement the <code>connect</code> and <code>id</code> functions, which will look like this: </p><br><pre> <code class="hljs vbscript"># web/channels/user_socket.ex defmodule PhoenixTrello.UserSocket <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... def connect(%{<span class="hljs-string"><span class="hljs-string">"token"</span></span> =&gt; token}, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Guardian.decode_and_verify(token) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, claims} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GuardianSerializer.from_token(claims[<span class="hljs-string"><span class="hljs-string">"sub"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, user} -&gt; {:ok, assign(socket, :current_user, user)} {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, _reason} -&gt; :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, _reason} -&gt; :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def connect(_params, _socket), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span> def id(socket), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-string"><span class="hljs-string">"users_socket:#{socket.assigns.current_user.id}"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  When you call the <code>connect</code> function ( <em>which happens automatically when you connect to the socket - approx. Translator</em> ) with <code>token</code> as a parameter, it will check the token, retrieve user data from the token using the <code>GuardianSerializer</code> we created in <a href="https://habrahabr.ru/post/308056/">Part 3</a> , and store this data in the socket, that they will, if necessary, be available in the channel.  Moreover, it also prohibits unauthenticated users from connecting to the socket. </p><br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">translator</b> <div class="spoiler_text"><p>  <em>Note the two descriptions of the connect function: <code>def connect(%{"token" =&gt; token}, socket) do ... end</code> and <code>def connect(_params, _socket), do: :error</code> .</em>  <em>Thanks to the pattern matching <a href="http://elixir-lang.org/getting-started/pattern-matching.html">mechanism, the</a> first option will be called if the associative array passed the first parameter has the key "token" (and the value associated with this key will be in a variable called token), and the second - in any other cases.</em>  <em>The <code>connect</code> function is called by the framework automatically when connected to a socket.</em> </p><br><p>  <em>The <code>id</code> function is used to identify the current connection to the socket and can be used, for example, to terminate all active channels and sockets for a given user.</em>  <em>If desired, this can be done from any part of the application by sending a <code>"disconnect"</code> message by calling <code>PhoenixTrello.Endpoint.broadcast("users_socket:#{user.id}", "disconnect", %{})</code></em> </p><br><p>  <em>By the way, using <code>&lt;AppName&gt;.Endpoint.broadcast(topic, message, payload)</code> you can send a message not only about disconnecting the user, but generally any message to all users who subscribe to the corresponding topic.</em>  <em>In this case, the <code>topic</code> is a string with a theme (for example, <code>"boards:877"</code> ), <code>message</code> is a string with a message (for example, <code>"boards:update"</code> ), and <code>payload</code> is an associative data array that will be converted to json before being sent. .</em>  <em>For example, you can send users who are online, any changes made using REST api, directly from the controller or from any other process.</em> </p></div></div><br><h3 id="kanal-user">  User channel </h3><br><p>  After we set up the socket, let's move to the <code>UserChannel</code> , which is very simple: </p><br><pre> <code class="hljs pgsql"># web/channels/user_channel.ex defmodule PhoenixTrello.UserChannel <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :channel def <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>("users:" &lt;&gt; user_id, _params, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  This channel will allow us to transmit any message associated with the user, from anywhere, processing it on the front-end.  In our particular case, we will use it to transfer data about the board to which the user was added as a participant, so that we can place this new board on this user‚Äôs list.  We can also use the channel to display notifications about other boards that the user owns and for anything else that comes to your head. </p><br><h3 id="podklyuchenie-k-soketu-i-kanalu">  Connection to socket and channel </h3><br><p>  Before proceeding, recall what we did in the previous section ... after authenticating the user, regardless of whether the login form was used or the previously saved <code>phoenixAuthToken</code> , we need to get the <code>currentUser</code> data to forward them to the Redux store and be able to show avatar and username in title.  This looks like a good place to connect to the socket and the channel as well, so let's do some refactoring: </p><br><pre> <code class="hljs lua">// web/static/js/actions/sessions.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; import { Socket } from <span class="hljs-string"><span class="hljs-string">'phoenix'</span></span>; // ... export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatch, user)</span></span></span></span> { dispatch({ <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Constants.CURRENT_USER, currentUser: user, }); const socket = new Socket(<span class="hljs-string"><span class="hljs-string">'/socket'</span></span>, { params: { token: localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>) }, }); socket.connect(); const channel = socket.channel(`users:${user.id}`); channel.join().receive(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>, () =&gt; { dispatch({ <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Constants.SOCKET_CONNECTED, socket: socket, channel: channel, }); }); }; // ...</code> </pre> <br><p>  After the user data is redirected, we create a new <code>Socket</code> object from the <code>Phoenix</code> JavaScript library, passing in the <code>phoenixAuthToken</code> parameter, which is required to establish the connection, and then call the <code>connect</code> function.  We continue to create a new user <code>channel</code> (user <code>channel</code> ) and join it.  When we <code>SOCKET_CONNECTED</code> <code>ok</code> message in response to the <code>join</code> , we direct the <code>SOCKET_CONNECTED</code> action to save both the socket and the channel in the repository: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web/static/js/reducers/session.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { currentUser: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, socket: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, channel: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, error: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> function reducer(state = initialState, action = {}) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { case Constants.CURRENT_USER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, currentUser: action.currentUser, error: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; case Constants.USER_SIGNED_OUT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initialState; case Constants.SOCKET_CONNECTED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, socket: action.socket, channel: action.channel }; case Constants.SESSIONS_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, error: action.error }; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  The main reason for storing these objects is that we need them in many places, so storing in a state makes their components accessible via properties ( <code>props</code> ). </p><br><p>  After authenticating the user, connecting to the socket and joining the channel, the <code>AuthenticatedContainer</code> will <code>HomeIndexView</code> , where we will show all the boards owned by the user, as well as those to which he was invited as a participant.  In the next section, we will reveal how to create a new board and invite existing users, using channels to transfer the resulting data to the involved users. </p><br><p>  In the meantime, do not forget to take a look at the <a href="https://phoenix-trello.herokuapp.com/">live demo</a> and <a href="https://github.com/bigardone/phoenix-trello">source code of the</a> final result. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308248/">https://habr.com/ru/post/308248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308234/index.html">What is lead</a></li>
<li><a href="../308236/index.html">Linux Vulnerability Audit with Vulners.com</a></li>
<li><a href="../308240/index.html">Arrays in PHP 7: Hash Tables</a></li>
<li><a href="../308242/index.html">We break garbage collection and deserialization in PHP</a></li>
<li><a href="../308246/index.html">OpenStreetView launch</a></li>
<li><a href="../308254/index.html">Choosing an html-parser for Apache.JMeter</a></li>
<li><a href="../308256/index.html">The creation of the game "Words from the Word"</a></li>
<li><a href="../308258/index.html">Why do you need SSL security certificates in 3CX Phone System</a></li>
<li><a href="../308260/index.html">Data backup in virtualization systems for small and medium-sized companies</a></li>
<li><a href="../308264/index.html">Symmetric difference in Swift and Objective-C capabilities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>