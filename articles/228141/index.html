<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mojolicious Documentation: Lost Chapters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a continuation of a series of articles about the Perl web framework - Mojolicious: the first part . 

 This series of articles assumes that th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mojolicious Documentation: Lost Chapters</h1><div class="post__text post__text-html js-mediator-article">  This is a continuation of a series of articles about the Perl web framework - Mojolicious: the <a href="http://habrahabr.ru/post/227493/">first part</a> . <br><br>  This series of articles assumes that the reader is already superficially familiar with the framework, and he has a need to understand the details that are either not described in the documentation or described in insufficient detail and understandable.  <a href="http://mojolicio.us/perldoc">Official documentation is</a> <i>ideal</i> for initial familiarization (in English). <br><br><h4>  Asynchronous: sync using Mojo :: IOLoop :: Delay </h4><br>  <a href="https://metacpan.org/pod/Mojo::IOLoop::Delay">Mojo :: IOLoop :: Delay</a> provides a mechanism for providing asynchronously executed callbacks: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  description of successive operations without the "noodles" of callbacks </li><li>  transferring the results from the current callback (s) to the next </li><li>  general data for callbacks combined into one task </li><li>  callback group synchronization </li><li>  interception and exception handling in callback </li></ul><br>  Terms used: <br><br><ul><li>  <b>The (asynchronous) operation</b> is usually a call to an asynchronous function, such as a timer or deflating the url, to which a callback must be passed. </li><li>  <b>step</b> - callback, which analyzes the data received from the previous step (if this is not the first step), and starts one or several new operations, or returns the final result (if this is the last step) </li><li>  <b>task</b> - a list of steps that should be performed sequentially (i.e. the next step is called only after all operations started in the previous step are completed) </li></ul><br><h5>  Alternative Promises </h5><br>  This is an alternative approach to a problem usually solved with <a href="https://metacpan.org/pod/Promises">Promise / Deferred</a> or <a href="https://metacpan.org/pod/Future">Future</a> .  Here is a rough comparison with <a href="https://promises-aplus.github.io/promises-spec/">the Promises / A + specification</a> : <a name="habracut"></a><br><br><ul><li> Instead of the chain <code>-&gt;then(\&amp;cb1)-&gt;then(\&amp;cb2)-&gt;‚Ä¶</code> one call <code>-&gt;steps(\&amp;cb1, \&amp;cb2, ‚Ä¶)</code> used <code>-&gt;steps(\&amp;cb1, \&amp;cb2, ‚Ä¶)</code> . </li><li>  Instead of passing the error handler to the second parameter in <code>-&gt;then()</code> it is set via <code>-&gt;catch()</code> .  <i>Consequence: there can be only one error handler for all steps of this task.</i> </li><li>  The result is returned via <code>-&gt;pass()</code> , but unlike <code>-&gt;resolve()</code> in most cases it is called implicitly - the result of the call to the anonymous function generator is transferred to the asynchronous operation <code>-&gt;begin</code> , and the function returned by it automatically does <code>-&gt;pass()</code> , passing a slice of its parameters (ie, the result of the operation of an asynchronous operation) to the next step.  <i>Corollary: it is not necessary to write for each asynchronous callback function, which will convert the result returned by it to <code>-&gt;resolve()</code> and <code>-&gt;reject()</code> .</i> </li><li>  Errors are returned only through exceptions, there is no analogue <code>-&gt;reject()</code> . </li><li>  There is an additional step performed at the very end <code>-&gt;on(finish=&gt;\&amp;cb)</code> , which can also be accessed from the error handler. </li><li>  There is support for groups of asynchronous operations: if several operations are run in the current step, the next step will be called when all of them are completed. </li><li>  There is a user data storage available for all steps of the current task. </li></ul><br>  These differences show a typical approach for Mojo: everything that can be simplified and convenient ‚Äúsloths‚Äù for typical tasks are provided. <br><br><h5>  What's left overs </h5><br>  I will not describe the work <code>-&gt;wait</code> , everything is simple and clear from the official documentation. <br><br>  In addition, there are synonyms / alternatives: <br><br><pre> <code class="perl hljs">Mojo::IOLoop-&gt;delay(@params) <span class="hljs-comment"><span class="hljs-comment">#     : Mojo::IOLoop::Delay-&gt;new-&gt;steps(@params)</span></span></code> </pre> <br><pre> <code class="perl hljs">$delay-&gt;catch(\&amp;cb) <span class="hljs-comment"><span class="hljs-comment">#    (..  $delay,   \&amp;cb, #     ) : $delay-&gt;on(error=&gt;\&amp;cb)</span></span></code> </pre> <br><h5>  $ delay ‚Üí begin </h5><br>  This is a key function; without it, using Mojo :: IOLoop :: Delay will fail.  Each call <code>-&gt;begin</code> <b>increases the counter of</b> running (usually asynchronous) operations and <b>returns a reference to a new anonymous function</b> .  This returned function must be called once upon completion of the operation - it <b>will reduce the counter of</b> running operations and allow you <b>to transfer the results of the</b> operation to the next step (which will be started when the counter reaches zero). <br><br>  There are two ways to use <code>-&gt;begin</code> : manually and automatically. <br><br>  In the first variant, the function returned <code>-&gt;begin</code> remembered in a temporary variable and upon completion of the operation it is called manually: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $delay = Mojo::IOLoop-&gt;delay; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $i (<span class="hljs-number"><span class="hljs-number">1</span></span> .. <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $end = $delay-&gt;begin; Mojo::IOLoop-&gt;timer($i =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> - $i; $end-&gt;(); }); }</code> </pre> <br>  In the second variant, the function returned <code>-&gt;begin</code> used as the callback for the operation: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $delay = Mojo::IOLoop-&gt;delay; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $i (<span class="hljs-number"><span class="hljs-number">1</span></span> .. <span class="hljs-number"><span class="hljs-number">10</span></span>) { Mojo::IOLoop-&gt;timer($i =&gt; $delay-&gt;begin); }</code> </pre> <br>  In both cases, if the next step is defined for <code>$delay</code> (in this case, it is the first and only) step, then it will be called after all 10 operations are completed: <br><br><pre> <code class="perl hljs">$delay-&gt;steps(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> <span class="hljs-string"><span class="hljs-string">"all timers done"</span></span> });</code> </pre> <br>  In this example, there is a problem: in the second variant, <code>say 10 - $i</code> not executed.  the timer does not pass any parameters to its callback, and we cannot find out the value of <code>$i</code> in the callback unless we shut it down as in the first version.  But even if the timer passed <code>$i</code> parameter to the callback, it wouldn't help you much anyway, because  a chance to fulfill all ten <code>say 10 - $i</code> we would get only in the next step, and it will start only after all the timers are completed - i.e.  the countdown effect will disappear when <code>say</code> performed once a second. <br><br>  In such rare situations it is necessary to use the first ‚Äúmanual‚Äù version of working with <code>-&gt;begin</code> .  But <b>in all others it is</b> much better to use the second option: this will eliminate the time variable, the ‚Äúnoodles‚Äù of callbacks, and will make it possible to use (more precisely, intercept) exceptions in callbacks (the exception in the usual callback is not a ‚Äústep‚Äù - will fall not into <code>$delay-&gt;catch</code> but into the event loop exception handler and, by default, will be ignored). <br><br>  Functions <code>-&gt;begin</code> you can pass the parameters, and at first glance (in the official documentation) they may not look very clear.  The bottom line is that when the function <i>returned</i> <code>-&gt;begin</code> used not in the manual version (when you call it yourself and control with what parameters it will be called), but as a direct callback for the operation, it will be called with the parameters with which it will cause this operation.  And you will receive <b>all these parameters</b> as a result of this operation in the parameters of the next step. <br><br>  For example, <code>$ua-&gt;get($url,\&amp;cb)</code> sends two parameters to the callback: <code>($ua,$tx)</code> , and if you start pumping out 3 url in one step, the next step will receive 6 parameters (each step gets the first required parameter is $ delay, and why in this example I use <code>-&gt;begin(0)</code> I will explain soon): <br><br><pre> <code class="perl hljs">Mojo::IOLoop-&gt;delay( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay) = @_; $ua-&gt;get($url1, $delay-&gt;begin(<span class="hljs-number"><span class="hljs-number">0</span></span>)); $ua-&gt;get($url2, $delay-&gt;begin(<span class="hljs-number"><span class="hljs-number">0</span></span>)); $ua-&gt;get($url3, $delay-&gt;begin(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay, $ua1,$tx1, $ua2,$tx2, $ua3,$tx3) = @_; }, );</code> </pre> <br>  In this case, all three <code>$ua</code> obtained by the second step will be the same.  Since this is a typical situation, <code>-&gt;begin</code> gives you the ability to control which of the parameters passed by the operation should be passed on to the next step.  To do this, it takes two parameters: the index of the first parameter and their number in order to pass the slice to the next step.  By default <code>-&gt;begin</code> works like <code>-&gt;begin(1)</code> - i.e.  passes to the next step all parameters passed by the operation except the first: <br><br><pre> <code class="perl hljs">Mojo::IOLoop-&gt;delay( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay) = @_; $ua-&gt;get($url1, $delay-&gt;begin); $ua-&gt;get($url2, $delay-&gt;begin); $ua-&gt;get($url3, $delay-&gt;begin); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay, $tx1, $tx2, $tx3) = @_; }, );</code> </pre> <br><h5>  $ delay ‚Üí data </h5><br>  In principle, with <code>-&gt;data</code> everything is trivial: a hash accessible to all steps is an alternative to transferring data from one step to another through parameters. <br><br><pre> <code class="perl hljs">Mojo::IOLoop-&gt;delay( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay) = @_; $delay-&gt;data-&gt;{key} = <span class="hljs-string"><span class="hljs-string">'value'</span></span>; ... }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay) = @_; <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $delay-&gt;data-&gt;{key}; }, );</code> </pre> <br>  The alternative is to use a clozure that looks more lazy, familiar and readable: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_task</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $key; Mojo::IOLoop-&gt;delay( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'value'</span></span>; ... }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">say</span></span> $key; }, ); }</code> </pre> <br>  But here you will find an unpleasant surprise.  Clocks live while someone refers to them.  And as you complete the steps, Mojo <b>deletes them from memory</b> .  Thus, when the last step, referring to the set variable, is executed, it will also be deleted.  This leads to an unpleasant effect if this variable was, for example, a Mojo :: UserAgent object: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_task</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $ua = Mojo::UserAgent-&gt;new-&gt;max_redirects(<span class="hljs-number"><span class="hljs-number">5</span></span>); Mojo::IOLoop-&gt;delay( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay) = @_; $ua-&gt;get($url1, $delay-&gt;begin); $ua-&gt;get($url2, $delay-&gt;begin); $ua-&gt;get($url3, $delay-&gt;begin); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay, $tx1, $tx2, $tx3) = @_; <span class="hljs-comment"><span class="hljs-comment">#  $tx    " " }, ); }</span></span></code> </pre> <br>  As soon as the first step starts non-blocking pumping operations, the url is completed, and will be removed from memory - the <code>$ua</code> variable will be deleted as well.  no more steps that refer to it.  And as soon as <code>$ua</code> is removed, all open connections related to it will be broken and their callback will be called with an error in the <code>$tx</code> parameter. <br><br>  One of the solutions to this problem is to use <code>-&gt;data</code> to guarantee the lifetime of the closet no less than the execution time of the entire task: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_task</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $ua = Mojo::UserAgent-&gt;new-&gt;max_redirects(<span class="hljs-number"><span class="hljs-number">5</span></span>); Mojo::IOLoop-&gt;delay-&gt;data(<span class="hljs-string"><span class="hljs-string">ua=&gt;</span></span>$ua)-&gt;steps( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay) = @_; $ua-&gt;get($url1, $delay-&gt;begin); $ua-&gt;get($url2, $delay-&gt;begin); $ua-&gt;get($url3, $delay-&gt;begin); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($delay, $tx1, $tx2, $tx3) = @_; <span class="hljs-comment"><span class="hljs-comment">#  $tx    }, ); }</span></span></code> </pre> <br><h5>  finish </h5><br>  It is not necessary to set the ‚Äúfinish‚Äù event handler, but in many cases it is very convenient to specify the last step not after the remaining steps, but by the ‚Äúfinish‚Äù event handler.  This will give you the following features: <br><br><ul><li>  If an exception handler is used <code>-&gt;catch</code> , and there are no fatal errors, after which it still makes sense to finish the current task on a regular basis by completing the last step - the exception handler can transfer control to the ‚Äúfinish‚Äù handler via <code>-&gt;emit("finish",@results)</code> but can not the usual step. </li><li>  If the final result is obtained at an intermediate step, then to transfer it to the last step, you need to implement a manual ‚Äúthrowing‚Äù the finished result through all the steps between them - but if the ‚Äúfinish‚Äù handler is used instead of the last step, you can immediately call it through <code>-&gt;remaining([])-&gt;pass(@result)</code> . <ul><li>  It is also necessary to take into account that if this step managed to start some operations before transferring the results to ‚Äúfinish‚Äù, then the ‚Äúfinish‚Äù handler will be launched only after these operations are completed, and it will receive not only the above-mentioned <code>@result</code> parameters, but and all that will return operations. </li></ul><br></li></ul><br>  <b>ATTENTION!</b>  You can do <code>-&gt;emit("finish")</code> only inside the exception handler, but you cannot do it in a normal step.  At the same time, in the usual step this is done through <code>-&gt;remaining([])-&gt;pass(@result)</code> , but this will not work in the exception handler. <br><br><h5>  $ delay ‚Üí pass </h5><br>  Very often, a step starts operations conditionally - inside an <code>if</code> or in a loop that can have 0 iterations.  In this case, as a rule, it is necessary that this step (usually at the very beginning or end) triggers: <br><br><pre> <code class="perl hljs">$delay-&gt;pass;</code> </pre> <br>  This command stimulates the launch of a single operation, which immediately ended and returned an empty list as a result.  Since she returned an empty list, this her ‚Äúlaunch‚Äù will not affect the parameters that the next step will receive. <br><br>  The fact is that if a step does not launch <b>a single</b> operation at all, then it will be considered the last step (which is logical - the next step has nothing to ‚Äúexpect‚Äù so that the meaning disappears in it).  Sometimes this way to complete the task is suitable, but if you install the handler ‚Äúfinish‚Äù, it will be called after this step, and you will receive the parameters of this step with the parameters - which, as a rule, is not what you wanted. <br><br><h5>  Complex parser example </h5><br>  Let's look at an example that uses almost all of the above.  Suppose we need to download data from the site.  First you need to login ( <code>$url_login</code> ), then go to the page with the list of necessary entries ( <code>$url_list</code> ), for some entries there may be a link to the page with details, and on the page with details there may be links to several files attached to this entry that need to be downloaded. <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_site</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($user, $pass) = @_; <span class="hljs-comment"><span class="hljs-comment">#       : # @records = ( # { # key1 =&gt; "value1", # ‚Ä¶ # attaches =&gt; [ "content of file1", ‚Ä¶ ], # }, # ‚Ä¶ # ); my @records; #      $ua, ..   #      $user/$pass,   #   $ua      my $ua = Mojo::UserAgent-&gt;new-&gt;max_redirects(5); #  ,  $ua    Mojo::IOLoop-&gt;delay-&gt;data(ua=&gt;$ua)-&gt;steps( sub { $ua-&gt;post($url_login, form=&gt;{user=&gt;$user,pass=&gt;$pass}, shift-&gt;begin); }, sub { my ($delay, $tx) = @_; die $tx-&gt;error-&gt;{message} if $tx-&gt;error; #    if (!$tx-&gt;res-&gt;dom-&gt;at('#logout')) { die 'failed to login: bad user/pass'; } #   ,    $ua-&gt;get($url_list, $delay-&gt;begin); }, sub { my ($delay, $tx) = @_; die $tx-&gt;error-&gt;{message} if $tx-&gt;error; #          #      -     $delay-&gt;pass; #    for ($tx-&gt;res-&gt;dom('.record')-&gt;each) { #      my $record = { key1 =&gt; $_-&gt;at('.key1')-&gt;text, # ‚Ä¶ }; #       push @records, $record; #      -  if (my $a = $_-&gt;at('.details a')) { #         #     -   # ,     ..  #       #        #  (      #  $record       #       # ) -      #     ,   #       #        #   Mojo::IOLoop-&gt;delay( sub { $ua-&gt;get($a-&gt;{href}, shift-&gt;begin); }, sub { my ($delay, $tx) = @_; die $tx-&gt;error-&gt;{message} if $tx-&gt;error; #     -   . $delay-&gt;pass; #  0     $tx-&gt;res-&gt;dom('.file a')-&gt;each(sub{ $ua-&gt;get($_-&gt;{href}, $delay-&gt;begin); }); }, sub { my ($delay, @tx) = @_; die $_-&gt;error-&gt;{message} for grep {$_-&gt;error} @tx; #      for my $tx (@tx) { push @{ $record-&gt;{attaches} }, $tx-&gt;body; } #    finish   # ,     @tx, : $delay-&gt;pass; }, )-&gt;catch( sub { my ($delay, $err) = @_; warn $err; #     $delay-&gt;emit(finish =&gt; 'failed to get details'); } )-&gt;on(finish =&gt; $delay-&gt;begin); } ### if .details } ### for .record }, )-&gt;catch( sub { my ($delay, $err) = @_; warn $err; #  ,    $delay-&gt;emit(finish =&gt; 'failed to get records'); } )-&gt;on(finish =&gt; sub { my ($delay, @err) = @_; if (!@err) { process_records(@records); } } ); }</span></span></code> </pre> <br>  A slightly non-obvious point is the error handling method.  Since the results of the work are not required to be transferred between steps (they are accumulated in the locked <code>@records</code> ), an empty list is transmitted to the next step (through <code>$delay-&gt;pass;</code> ), and an error text is sent to the next step.  Thus, if the last step in the finish handler receives some parameters, it means there was an error (s) somewhere in the process of pumping out or parsing.  The error itself has already been intercepted and processed (through <code>warn</code> ) in the handlers <code>-&gt;catch</code> - in fact, this is exactly what provided the transfer of the error with the parameter to the finish handler. <br><br>  If someone knows how to solve such a problem as simply and / or as clearly as possible, write.  An example of a similar decision on Promises would also be useful. <br><br>  ______________________ <br><h6>  Text converted using <a href="https://github.com/powerman/asciidoc-habrahabr-backend">habrahabr backend</a> for <a href="http://asciidoc.org/">AsciiDoc</a> . </h6></div><p>Source: <a href="https://habr.com/ru/post/228141/">https://habr.com/ru/post/228141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228125/index.html">Reactive programming for Android</a></li>
<li><a href="../228131/index.html">The infrastructure processing queues in the social network My World</a></li>
<li><a href="../228135/index.html">Ribs.js - nested attributes, computed fields and binding for Backbone.js</a></li>
<li><a href="../228137/index.html">Charles Herzfield: Director of DARPA and the Godfather of ARPANET</a></li>
<li><a href="../228139/index.html">How we stopped being afraid of Ogre and started making a game on it</a></li>
<li><a href="../228145/index.html">Bare Fridays # 1</a></li>
<li><a href="../228147/index.html">How to make money on an indie game</a></li>
<li><a href="../228149/index.html">Office 365 Cloud Business Apps</a></li>
<li><a href="../228151/index.html">My implementation of "smart home"</a></li>
<li><a href="../228157/index.html">Functional and economic comparison of Russian cloud service providers. Version 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>