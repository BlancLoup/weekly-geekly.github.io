<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java and Linux - features of operation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java is a very common platform, they write very different things on it, starting from Big Data, ending with microservices, monoliths, enterprise and s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java and Linux - features of operation</h1><div class="post__text post__text-html js-mediator-article">  Java is a very common platform, they write very different things on it, starting from Big Data, ending with microservices, monoliths, enterprise and so on.  And, as a rule, all this is deployed on Linux servers.  At the same time, accordingly, those people who write in Java often do it on completely different operating systems.  They are there: <br><br><ul><li>  write code; <br></li><li>  debug, test; <br></li><li>  then packaged in a jar; <br></li><li>  send to linux and it works. <br></li></ul><br>  The fact that it works, there is no special magic.  But this leads to the fact that such developers "suck up" a bit in their world of cross-platform and do not really want to understand, but <strong>how it actually works in a real operating system</strong> . <br><br><img src="https://habrastorage.org/webt/gi/6a/i3/gi6ai3rendya9mvepngiritaluk.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the other hand, there are those who administer servers, install JVMs on their servers, send jar and war files, and from the point of view of the Linux world, all this: <br><br><ul><li>  alien; <br></li><li>  proprietary; <br></li><li>  not going from source; <br></li><li>  supplied by some jar archives; <br></li><li>  "Eats away" all the memory on the server; <br></li><li>  in general, does not behave humanly. <br></li></ul><br>  The purpose of the report by <strong>Alexey Ragozin</strong> on <a href="http://www.highload.ru/">Highload ++</a> , the decoding of which goes further, was to tell <strong>Java</strong> features <strong>for Linux users</strong> and, accordingly, <strong>Linux to Java developers</strong> . <br><a name="habracut"></a><br>  The report will not be debriefing, because there are a lot of problems, they are all interesting, and the projectile twice does not get into the same funnel.  Therefore, plugging the already known "holes" is a defeatist position.  Instead, let's talk about: <br><br><ul><li>  JVM implementation features <br></li><li>  Linux implementation features: <br></li><li>  how can they not dock. <br></li></ul><br><img src="https://habrastorage.org/webt/yu/iq/an/yuiqanrkovefbjtgdl3hg-mykm4.jpeg"><br><br>  Java has a virtual machine, and Linux, like any other modern operating system, in fact, is also a virtual machine.  Both Java and Linux have <strong>memory management</strong> , <strong>threads</strong> , <strong>APIs</strong> . <br><br>  Words are similar, but in fact completely different things are often hidden under them.  Actually, on these points we will go through, paying the most attention to the memory. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HVVsjyVxcJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Java memory <br></h2><br>  I‚Äôll immediately note that I‚Äôll only talk about the implementation of the <strong>JVM HotSpot,</strong> this is the Open JDK and Oracle JDK.  That is, for sure IBM J9 has some features of its own, but unfortunately I don‚Äôt know about them.  If we are talking about HotSpot JVM, then the picture of the world is as follows.  First of all, in Java there is an area where java-objects live - the so-called Heap or, in Russian, a bunch of where the garbage collector works.  This memory area usually takes up most of the process space.  The heap is in turn divided into a young and old space (Young Gen / Old Gen).  Without going into the JVM Siding Derby, the important thing is that the JVM has a ‚Äú-Xmx‚Äù parameter that defines the maximum size to which the heap space can grow. <br><br><img src="https://habrastorage.org/webt/vb/rb/wu/vbrbwuw4ml48etuo7f7pjwxbeky.jpeg"><br><br>  And then there are many options: <br><br><ul><li>  you can control the size of the young space separately; <br></li><li>  you can immediately set the maximum heap size; <br></li><li>  or allow it to grow gradually. <br></li></ul><br>  There are too many details - it is important that there is a limit.  And, in principle, this is a general approach to all areas that use the JVM.  That is, almost all areas listed in the picture above have a certain limit.  The JVM <strong>immediately reserves the</strong> <strong>address space</strong> , based on the limit, and then <strong>as necessary, asks for real memory resources</strong> in this range.  It is important to understand. <br><br>  In addition to the heap, there are other memory consumers.  The most important of these are the memory areas for the stacks of threads.  Threads in Java are regular linux threads, they have a stack for which a certain amount of memory is reserved.  The more threads you have, the more stacks are allocated in the process memory.  Since the number of threads in Java can be measured in hundreds and thousands, sometimes this figure can become quite significant, especially if you have some kind of stateless microservice, in which a heap of 200 MB and a ThreadPool of 50-100 threads. <br><br>  In addition, there are still so-called <strong>NIO</strong> <strong>Direct</strong> <strong>Buffers</strong> - these are special objects in Java that allow you <strong>to work with memory outside the heap</strong> .  They are usually used to work with I / O, because it is a memory that can be directly accessed by both C and Java code.  Accordingly, this area is accessible through the API, and it also has a maximum limit. <br><br>  The rest is metadata, some kind of generated code, the memory for them usually does not grow to large values, but it exists. <br><br>  In addition to these special areas, we must not forget that the JVM is written in C ++, respectively, there is <br><br><ul><li>  malloc and normal memory allocation; <br></li><li>  libraries that are loaded into the JVM (statically or dynamically linked, which can also use memory). <br></li></ul><br>  And this memory is not classified according to our scheme, but is simply a memory allocated by standard C Runtime tools.  C, too, sometimes there are problems, and on a fairly level ground. <br><br>  For example, here we have java code distributed in the jar form.  Jar is a zip-archive, zlib library is used to work with it.  In order to unzip something, zlib must allocate a buffer that will be used for decompression and, of course, it requires memory.  All anything, but now there is a fashion for the so-called uber-jar, when one hefty jar is created, and there are nuances. <br><br>  When attempting to start from such a jar file, too many zlib threads are opened at the same time for unpacking.  And from the point of view of Java, everything is fine: the heap is small, all areas are small, but the memory consumption of the process is growing.  This is, of course, a ‚Äúclinical‚Äù case, but such needs of the JVM must be taken into account.  For example, if you set -Xmx to 1 GB, put Java in the Docker container and set the memory limit on the container to 1 GB too, then the <strong>JVM will not fit in it</strong> .  We still need to throw a little bit, but how much exactly - depends on many factors, including the number of threads and exactly what your code does. <br><br>  So this is how the JVM works with memory. <br><br>  Now, so to speak, for another part of the audience. <br><br><h2>  Linux Memory <br></h2><br>  There is no <strong>garbage collector</strong> in Linux.  His work in terms of <strong>memory is</strong> completely different.  He has a <strong>physical memory</strong> that is <strong>paginated</strong> ;  There are <strong>processes</strong> that have their own <strong>address space</strong> .  It needs the resources of this memory in the form of pages to be somehow divided between processes, so that they work in their virtual address space and do their work. <br><br><img src="https://habrastorage.org/webt/_k/vi/sq/_kvisq1el3d07ltv1t9u6ahv7ti.jpeg"><br><br>  The page size is usually 4 kilobytes.  In fact, this is not the case; in x86 architecture, there is support for large pages for a very long time.  In Linux, it appeared relatively recently, and with it a little bit incomprehensible situation.  When support for large pages (Transparent Huge Tables) appeared in Linux, many people stepped on the rake related to performance degradation due to some of the nuances of serving large pages in Linux.  And soon the Internet was filled with recommendations to turn them off out of harm's way.  After that, some bugs related to the work of large pages in Linux were repaired, but the sediment remained. <br><br>  But at the moment there is no clear understanding, for example, from which version support for large pages can be enabled by default and do not worry. <br><br><blockquote>  So be careful.  If suddenly on your Linux server suddenly out of the blue will increase the consumption of resources by the kernel, then the problem may be that you have large pages included, and now they are included by default in most distributions. <br></blockquote><br>  So from the kernel‚Äôs point of view, Linux has <strong>many pages</strong> to manage.  From a process point of view, there is an address space in which it reserves address ranges.  <strong>The reserved address space is nothing, not a resource, there is nothing in it</strong> .  If you contact this address, you will receive a segfault, because there is nothing there. <br><br>  In order for a page to appear in the address space, a slightly different syscall is needed, and then the process says to the operating system: "I need 1 GB of memory in these addresses."  But even in this case, the memory appears there, too, not immediately and with his tricks. <br><br><img src="https://habrastorage.org/webt/s5/44/to/s544topgpsvi31mwfs-74cukibs.jpeg"><br><br>  From the point of view of the kernel, the classification of pages looks like this, there are pages: <br><br>  a) <strong>private</strong> , that is, it means that they belong to one process and are available in the address space of only one process; <br><br>  b) <strong>anonymous</strong> - this is ordinary memory, not bound in files; <br><br>  c) <strong>memory mapped files</strong> - mapping files to memory; <br><br>  d) <strong>shared</strong> , which may be either: <br><br><ul><li>  <strong>Copy-On-Write</strong> , that is, when a process is branching out, the memory becomes available to both processes until it is written and the pages become private; <br></li><li>  through the <strong>Shared</strong> file, i.e., if several processes map the same file into memory, then the pages can be shared. <br></li></ul><br>  In general, from the point of view of <strong>the</strong> operating system <strong>kernel,</strong> everything is quite simple. <br><br><img src="https://habrastorage.org/webt/k3/xi/2y/k3xi2yn3u8rb6udspewkcfqhsq0.jpeg"><br><br>  Simple, but not quite. <br><br>  When we want to understand what is happening on the server in terms of memory, we go to the top and see some numbers there.  In particular, there is <strong>used memory</strong> and <strong>free memory</strong> .  There are different opinions about how much free memory should be on the server.  Someone thinks that this is 5%, but, in fact, <strong>0% of physical memory is also the norm</strong> , because what we see as a free memory counter is not really all free memory.  It is actually much more, but it is usually hidden in the page cache. <br><br>  In terms of the <strong>process,</strong> top shows three interesting columns: <br><br><ol><li>  <strong>virtual memory</strong> ; <br></li><li>  <strong>resident memory</strong> ; <br></li><li>  <strong>shared memory</strong> . <br></li></ol><br>  The last memory in the list is just those pages that are shared.  But with <strong>resident memory,</strong> everything is a little trickier.  Let us dwell in more detail on these metrics. <br><br><img src="https://habrastorage.org/webt/_2/_y/ni/_2_yninflff1w2ab9l3rownwmca.jpeg"><br><br>  As I have already said, used and free memory are quite useless metrics.  The server still has memory, which has never been used, because the operating system has a <strong>file cache</strong> , and all modern OSs use all free memory for it, since the file cache page can always be cleared and used for more important tasks.  Therefore, <strong>all free memory gradually goes to the cache and does not come back</strong> . <br><br>  The <strong>virtual memory</strong> metric is not a resource at all in terms of the operating system.  You can easily allocate 100 terabytes of address space, that's all.  We have done this and can be proud that space from the address X to the address Y is reserved, but no more.  Therefore, to look at it as a resource and, for example, to set an alert that the virtual size of the process has exceeded a certain threshold, rather pointless. <br><br>  Back to Java, it reserves all of its special areas in advance, because the JVM code expects these areas to be contiguous in terms of address space.  So the address must be staked in advance.  In this regard, by starting the process with a 256 MB heap, you can suddenly see that it has more than two gigabytes of virtual size.  Not because these gigabytes are needed and that the JVM is capable of ever recycling them, but simply defaulting.  From him neither cold nor hot, at least so thought those who wrote the JVM.  This, however, does not always correspond to the opinion of those who then engaged in server support. <br><br>  <strong>Residence size</strong> - the metric closest to reality - is the number of memory pages used by a process that is in memory, not in a swap.  But it is also a little peculiar. <br><br><img src="https://habrastorage.org/webt/vg/gb/sa/vggbsawn1wo9qzua-tsssqvqzca.jpeg"><br><br><h3>  Cache <br></h3><br>  Returning to the cache.  As I said, the cache is, in principle, <strong>free memory</strong> , but sometimes there are exceptions.  Because the pages in the cache are clean and dirty (containing not saved changes).  If the page in the cache is modified, then before it can be used for another purpose, it must first be written to disk.  And this is another story.  For example, the JVM writes a big-big heap dump.  She does it slowly, the process is as follows: <br><br><ul><li>  JVM quickly writes in memory; <br></li><li>  the operating system gives it all the free memory that it has, under write behind cache, all this memory is ‚Äúdirty‚Äù; <br></li><li>  There is a slow write to the disk. <br></li></ul><br>  If the size of this dump is comparable to the size of the server's physical memory, a situation may arise that there will simply not be free memory for all other processes. <br><br>  That is, we, for example, open a new ssh session - to start the shell process, you need to allocate memory.  The process follows memory, and the core tells him: ‚ÄúWait, please, now I will find something.‚Äù  Finds, but before it manages to give this page to SSHD, Java manages to ‚Äúblot out‚Äù a few more pages, because it also ‚Äúhangs‚Äù in Page Fault and, as soon as a free page appears, it quickly manages to grab this memory sooner than what other processes.  In practice, such a situation led, for example, to the fact that the monitoring system simply decided that this server was not ‚Äúlive‚Äù once it was impossible to access it via ssh.  But this, of course, an extreme case. <br><br>  Another process in Linux, in addition to virtual size and resident size, has a <strong>committed</strong> <strong>size</strong> ‚Äî this is the memory that the process is actually going to use, that is, the address space, when accessing which you do not get a segfault, and when accessing which, the kernel must provide you with a physical memory page. . <br><br><img src="https://habrastorage.org/webt/-a/vq/7m/-avq7ms8pnar5nmheygc0x7qwua.jpeg"><br><br>  In an ideal situation, <strong>committed and</strong> <strong>re</strong> <strong>sident should have been the same</strong> .  But, first, the pages can "swap." <br><br>  Secondly, Linux memory is always lazy. <br><br><ul><li>  You say to him: "Give me, please, 10 GB."  He says: "Take it please." <br></li><li>  Another process: ‚ÄúGive me 10 GB too‚Äù - ‚ÄúTake it please‚Äù. <br></li><li>  The third process: ‚ÄúGive me 10 GB too‚Äù - ‚ÄúTake it please‚Äù. <br></li></ul><br>  Then it turns out that there are only 16 physical memories, and he distributed everything to 10. And it starts ‚Äúwho took the first one, that and slippers, and who was not lucky, OMKiller will come after that‚Äù.  These are Linux memory management features. <br><br><h2>  <strong>JVM</strong> Important Facts <br></h2><br>  First, the <strong>JVM really dislikes swapping</strong> .  If I complain that the java-application for some reason slows down, then the first thing that I do is look at whether there is a swap on the server.  Because there are two factors that make Java very intolerant to swapping: <br><br><ol><li>  Garbage collection in Java constantly runs through the pages, and if it ‚Äúmisses‚Äù past the resident pages, it causes page shifting from disk to memory and back. <br></li><li>  If the JVM has at least one stream ‚Äústepped on‚Äù a page that does not exist in memory, then this can freeze <strong>all the</strong> threads of this JVM. <br></li></ol><br>  There is a <strong>safe-point</strong> mechanism that is used in JVM for all black magic like recompiling code on the fly, garbage collection, and so on.  If one thread hit the Page Fault and waits, then the JVM cannot normally enter the safe-point state, because it does not receive confirmation from the stream that is waiting for the memory page to ‚Äúarrive‚Äù.  And all the other streams have already stopped and are also waiting.  All stand, waiting for this one unfortunate stream.  Therefore, as soon as your paging starts, a very significant degradation of performance can begin. <br><br>  Second, <strong>Java never gives away memory to the operating system</strong> .  She will use as much as you have allowed, even if she doesn‚Äôt really need these resources now, she will not give them back.  There are garbage collectors who are technically able to do this, but do not expect that they will do it. <br><br>  <strong>The garbage collector has this logic: it either uses more</strong> <br>  <strong>CPU, or more memory.</strong>  If you allowed him to use 10 GB, then he reasonably assumes that you can save CPU resources, and wait 10 GB with garbage, while the CPU is doing something useful, instead of cleaning the memory, which does not go beyond the limit. <br><br><blockquote>  In this regard, it is important to correctly and reasonably set the size of the <strong>JVM</strong> .  And if you have several processes within the same container, it is reasonable to allocate memory resources between them. <br></blockquote><br>  Otherwise, everything that is in this container will suffer. <br><br><h2>  When memory runs out <br></h2><br>  This is another of those situations that are perceived very differently by ‚Äújavistami‚Äù and ‚Äúlinuxoids‚Äù. <br><br><img src="https://habrastorage.org/webt/it/jw/pb/itjwpbjqsttp1b9vgcqv0vff3qy.jpeg"><br><br>  In Java, this happens as follows: there is a new operator that allocates an object (on the slide this is a large array), if there is not enough space on the heap to allocate memory for this large array, we get Out of Memory error. <br><br><img src="https://habrastorage.org/webt/xf/rf/bd/xfrfbdhda_u4svl4mbs51orui5o.jpeg"><br><br>  Linux is different.  As we remember, Linux can easily promise more memory than it actually is, and you start working with it (the above conditional code).  And unlike JVM, you will receive not an error, but the crash of the process chosen by OMKiller or the death of the entire container if it is a question of exceeding the cgroups quota. <br><br><h3>  When memory runs out in JVM <br></h3><br>  Now, we will understand a little more.  In Java, we have a so-called area of ‚Äã‚Äãyoung objects and an area of ‚Äã‚Äãold ones.  When we call the new operator, an object is allocated in the space of young objects.  If the space in the space of young objects is over, either <strong>young</strong> or <strong>complete garbage collection occurs</strong> , if the young assembly is not enough.  The bottom line is that, firstly, if we do not have enough memory, garbage collection occurs.  And before the Out of Memory error occurs, at least one complete build will take place, i.e.  Such a slow through all our ten-gigabyte heap.  In some cases, it will also be in one thread, because full GC is a special case. <br><br><img src="https://habrastorage.org/webt/ea/yh/g1/eayhg1nlpt7dbw162ad8nklkkzu.jpeg"><br><br>  At the same time, the garbage collector will probably scrap something.  But if this is anything <strong>less than 5% of the heap size</strong> , an error will still be thrown out, because this is already ‚Äúnot life, but sheer torture‚Äù.  But if this Out of Memory error occurs in a stream, the author of the code of which decided that his stream should work, regardless of any errors, he can prolong this agony by intercepting exceptions. <br><br>  In general, after shooting Out of Memory error, the JVM can no longer be considered alive.  The internal state may already be destroyed, and there is such an option ( <code>-XX:OnOutOfMemoryError="kill -9 %p"</code> ), which allows you to immediately kill this process.  Again, there are nuances.  If your JVM size is comparable to the size of physical memory of a box, then when you call this command, you will have a fork, which.  will cause the JVM image to be duplicated.  Accordingly, from the point of view of Linux, the memory for the JVM may slightly exceed the limit of the maximum memory that it is ready to allocate and this command will not work.  Such a problem is typical for Hadoop servers, for example, when a large node tries to start Python through the shell.  Naturally, this child process does not need as much memory, just fork makes a copy of everything, and only then frees unnecessary memory.  Only ‚Äúlater‚Äù does not always occur. <br><br>  There may be another situation, it is possible that the <strong>heap is not yet the maximum size</strong> (less than -Xmx), but the garbage collection did not collect enough memory, and the JVM decided that it was necessary to <strong>increase the heap</strong> .  Went to the operating system, says: "give me more memory," and the OS says: "no."  True, as I said, Linux does not say that, but other systems say so.  Any error in allocating the operating system memory from the point of view of the JVM is a crash, no questions, no exceptions, no logs, just a standard crash dump, and the process is terminated immediately. <br><br>  There is also a second type of Out of Memory, which is associated with the so-called direct memory buffers.  These are special objects in Java that reference off-heap memory.  Accordingly, they also allocate it, manage the life cycle of this memory, that is, there is still a certain collection of garbage there.  To prevent such buffers from taking up an infinitely large amount of memory, they have a limit that the JVM exposes to itself.  Sometimes it becomes necessary to correct it, for which, naturally, there is a magic -XX option, for example, <code>-XX:MaxDirectMemorySize=16g</code> .  Unlike the normal Out of Memory, this Out of Memory is recoverable, because it occurs in a certain place and can be distinguished from another type of error. <br><br><h2>  Allocate memory in java </h2><br>  As I said, the JVM at the start is important to know how much you allow it to use memory, because based on this, all <strong>the garbage collector heuristics</strong> are built. <br><br>  How much to allocate memory "in grams" is a difficult question, but here are the main points: <br><br><ol><li>  You must understand how many useful objects must be permanently in memory ( <strong>Live</strong> <strong>set</strong> ).  It is more correct to measure empirically, that is, it is necessary: <br><br><ul><li>  produce tests; </li><li>  do <strong>heap dump;</strong> </li><li>  see what the heap is made of and how it will grow as the number of requests or the amount of data increases. </li></ul><br></li><li>  <strong>The younger generation is</strong> either taken as a default as a percentage of the heap, or is dynamically set.  For example, the feature of the <strong>G1 collector</strong> is that he himself is able to correctly choose the size of the young space.  For the rest of the garbage collectors, it is better to place them in the hands, again on the basis of empirical considerations. <br></li><li>  The garbage collector necessarily needs a <strong>reserve</strong> , because in order to collect garbage, it must be somewhere in memory.  The more memory you have for garbage, the less CPU will be spent on 1 GB of free memory.  This balance can never "unscrew to zero."  The size of the reserve depends on the characteristics of your application and the garbage collector used, as a rule, it is <strong>30-50%.</strong> <br></li><li>  Total, the total size of your heap (-Xmx) consists of: <br><br><ul><li>  the size of a young generation; <br></li><li>  live set size; <br></li><li>  reserve. <br></li></ul><br></li></ol><br>  In addition to the heap, there are also direct buffers, some kind of reserve of the JVM, which must also be determined empirically. <br><blockquote>  Thus, the footprint of the process as a whole will always be more than -Xmx, and this is not just a percentage, but a combination of various factors like the number of threads. </blockquote><h2>  Allocate memory in linux </h2><br>  Moving on, in Linux there is such a thing as <strong>ulimit</strong> - this is such a strange construction, in my opinion, javista.  For a process, there is a set of quotas that the operating system specifies.  There are different quotas for the number of open files, which is logical, and for some other things. <br><br><img src="https://habrastorage.org/webt/xq/vs/xc/xqvsxcwozkljn8faznijrvmgofw.jpeg"><br><br>  It is for managing the resources that the ulimits do not work very well - in order to limit the resource of the container, another tool is used.  In ulimits there is a maximum memory size that does not work on Linux, but there is also a <strong>maximum virtual memory size.</strong>  This is such an interesting thing, because, as I said, virtual memory is not a resource.  In principle, from the fact that I reserve 100 TB of address space, the operating system is neither cold nor hot.  But the OS most likely will not let me do this until I have become the corresponding ulimit for my process. <br><br>  By default, this limit is there and <strong>may prevent your JVM from running</strong> , especially again if the size of the JVM is comparable to the physical memory, because the default value is often considered just the size of the physical memory.  This causes some confusion when, for example, I have 500 GB on my server, I try to launch a 400 GB JVM, and it just crashes at the start with some kind of incomprehensible errors.  Then it turns out that at the start, the JVM allocates all these address spaces to itself, and at some point the OS says: ‚ÄúNo, you break a lot of address space, I feel sorry.‚Äù  And, as I said, in this case, the JVM simply "dies."  Therefore, sometimes this parameters need not forget to configure. <br><br>  There are other clinical situations where, for some reason, people decide that if they have 20 GB allocated for the JVM on the server, then the size of the virtual address space should also be set to 20 GB.  This is a problem, because some of the memory that the JVM reserves will never be used, and there are quite a lot of them.  Thus, you are much more limited memory resources of this process than you might think. <br><blockquote>  Therefore, I appeal to linuksoidam, please do not do so, have pity on your javista. <br></blockquote><h2>  A few words about Docker </h2><br>  That is, not about Docker itself, but about resource management in the container.  In Docker, resource management for containers works through the <strong>cgroups</strong> mechanism.  This is a kernel mechanism that allows the process tree to limit all kinds of resources, such as CPU and memory.  Including memory, you can limit the size of the resident memory occupied by the entire container, the number of swap, the number of pages, etc. These limits, in contrast to the ulimits, are normal limits on the entire container;  if a process forks some child processes, then they fall into the same group of resource limits. <br><br>  What is important: <br><br><ol><li>  If you run Java in the docker container, it looks at how much physical memory is on the host, and based on <strong>how much physical memory is actually on the host, and not in the container, it</strong> considers the default constraints.  And she dies very quickly, because she is not given so much.  <strong>Therefore -Xmx is necessary - without this, it will not take off.</strong> <br></li><li>  Always <strong>under the container you need to give a little more memory than under the</strong> <strong>JVM</strong> .  Suppose you make a 2 GB container, start the JVM with the <code>-Xmx2048m</code> parameter, it somehow starts to work, because the memory is allocated lazily.  But little by little, all these pages somehow start to be used, and at first your container starts to go to a local swap, and then just dies.  And he dies in the best traditions - <strong>just disappears</strong> . <br></li></ol><br>  If it just started, it still does not mean anything, because resources are really lazy. <br><br><h2>  Streams in java </h2><br>  About threads in Java, it is important to know that they are <strong>normal threads of the operating system</strong> .  Sometime in the first JVM, the so-called green threads were implemented - green threads, when in fact the java-stream stack somehow lived its own life, and one thread of the operating system executed one java-stream, then another.  This all developed until normal multithreading appeared in the operating systems.  After that, everyone forgot the ‚Äúgreen‚Äù streams as a bad dream, because the code works better with native streams. <br><br>  This means that the stack trace on the floor of a thousand frames really lies in the stack space allocated by the operating system.  If you call some native Java code, this code will use the same stack as the java code.  This means that you can use the diagnostic toolkit, which is in Linux, to work with java-streams as well. <br><br><h3>  How to find java <strong>-</strong> streams <br></h3><br><img src="https://habrastorage.org/webt/kd/5f/0p/kd5f0p_ljwtcdwqasdg0wxq68lo.jpeg"><br><br>  If we use the <strong>ps</strong> command for the JVM, we will see such an incomprehensible picture, because all the threads are called the same.  But in practice, there are going in turn: <br><br><ul><li>  garbage collector streams; <br></li><li>  the so-called operational thread JVM; <br></li><li>  application flows <br></li></ul><br>  but it is at random. <br><br><img src="https://habrastorage.org/webt/ux/wo/27/uxwo27nnfo6mdmoj77nsmlcjpoe.jpeg"><br><br>  In fact?  if you remove the thread dump from the JVM with the <strong>jstack command</strong> , there will be a hexadecimal number <strong>‚ÄúTID‚Äù - this is the real Linux flow identifier</strong> .  That is, you can understand which java-threads correspond to which threads of the operating system and decrypt ps. <br><br>  The only thing is, if you already see how to write a perl script that will do this, do <strong>not call jstack in a loop</strong> , rather vice versa.  Because every time you call jstack, you cause a global pause for all the threads of the JVM.  Under normal circumstances, this is fast, less than half a millisecond, but if you do this 20 times per second, then this may already have a noticeable effect on performance. <br><br>  You can also pull this information out of the JVM itself, which has its own diagnostic interface.  In particular, you can use <a href="https://github.com/aragozin/jvm-tools">my tool</a> , which pulls out this information from there and just prints the top by stream for the <strong>JVM</strong> .  In addition to <strong>CPU usa</strong> <strong>ge,</strong> he also knows how to print the intensity of allocations of heap memory in Java streams. <br><br><h3>  Total flows <br></h3><br><img src="https://habrastorage.org/webt/xs/uy/uo/xsuyuo6rvih4brsbnytpt-p4xlk.jpeg"><br><br>  Java threads are normal operating system threads.  In modern versions of the JVM, there is a <code>PreserveFramePointer</code> key, which is a JIT compiler option that allows perf-type tools to correctly parse the stack of Java threads. <br><br>  There is also a <a href="https://github.com/jvm-profiling-tools/perf-map-agent">project</a> on GitHub that allows you to export symbols for compiled java-code "on the fly", and using the same perf to get a quite readable stack of calls. <br><br>  And a small reminder that we still have garbage collector threads. <br><br><blockquote>  If you have a container in which you have allocated two CPUs, then the number of parallel threads of the garbage collector should also be made two, because by default there will be more of them, and they will only interfere with each other. <br></blockquote><br>  On the other hand, while the garbage collector is running, all other threads do nothing.  Therefore, you can allocate 100% of the container resources that you are going to allocate for Java as a garbage collector. <br><br><h2>  IO and Networking <br></h2><br>  <strong>Linux network stack needs tuning</strong> .  Those who deal with front-end servers, for example, with Nginx, remember this very well, but it would be nice to do the same thing on application and back-end servers - they sometimes forget about it.  And everything works fine until your system becomes geo-distributed and data transfer across the Atlantic begins.  And, it turns out, it was necessary to increase the limit on buffers. <br><br><img src="https://habrastorage.org/webt/ni/dh/zx/nidhzxghyzqeaxs65g9374kmn9w.jpeg"><br><br>  If you use UDP communication, this also requires separate configuration at the operating system level.  There are options that the code itself must expose via the API on sockets, but they must be enabled at the operating system's limit level.  Otherwise they simply do not work. <br><br>  The second interesting point is related to the peculiarities of working with resources in the <strong>JVM</strong> . <br><br>  We have a limited resource - a limit on the number of files, where sockets, etc., fall in for the process.  If we have this limit exceeded, we can not: <br><br><ul><li>  open connection; <br></li><li>  open files; <br></li><li>  accept connections, etc. <br></li></ul><br>  In Java, all of these objects have methods for explicitly closing them and, accordingly, freeing Linux descriptors. <br><br><img src="https://habrastorage.org/webt/y8/ci/5_/y8ci5_vter_1mkpkekpa5bezbre.jpeg"><br><br>  But if a lazy javist did not do this, then the garbage collector will come and still close everything for him.  And everything would be fine if this garbage collector arrived on a schedule, but it comes when it sees fit.  If you have a whole heap crammed with unclosed sockets, then from the heap point of view it is a penny, because there are only the metadata of this socket and the descriptor number from the operating system.  Therefore, if you have such a combination of external resources that are referenced by java-code, then the garbage collector can sometimes behave not very adequately in this regard. <br><br><blockquote>  Connections and files should always be closed by hand. <br></blockquote><br>  Even if you have an error on the socket, it‚Äôs all the same, after you catch an exception, you need to close the socket.  Because from the point of view of the operating system, the fact that it returned the error code to you, and you received an exception in Java, does not mean that the socket is closed.  From the point of view of the operating system, it will <strong>continue to be considered open</strong> , and the operating system will honestly be ready to return the error code again when checking the next call to it.  Accordingly, if we have incorrectly configured something, and the sockets are not closed properly, after some time the limit on the files will end, and the application will become very bad. <br><br>  There are a couple of resources in the <strong>JVM</strong> that cannot be explicitly released: <br><br><ul><li>  memory map files; <br></li><li>  NIO direct buffers. <br></li></ul><br>  Therefore, we must work with them carefully, and it is advisable not to throw it away, but to reuse it.  In terms of diagnostics, we have a heap dump from which all this information can be pulled out. <br><br>  And, finally, last parting words. <br><br><img src="https://habrastorage.org/webt/z7/sk/bi/z7skbiypuniqwyyfjgt3loxzpoc.jpeg"><br><br>  Expose the correct JVM size.  The JVM itself does not know how much memory it needs to take. <br><br>  Learn to use tools, in Linux there are tools that work quite well with Java, in the JDK there are tools that allow you to get a lot of information through the command line.  Java has JMX (Java Management Extensions) diagnostic interface, but in order to work with it, you need another java-process, which is not always convenient. <br><br>  In particular, do not forget about the combination of tools.  For example, if you have a Linux core dump JVM, then you can use the JDK tools to pull the heap dump for Java out of it and see it as a normal Java analyzer instead of doing this heap dump directly from the live process. <br><br>  And finally, several links to various topics. <br><br>  Java Memory Tuning and Diagnostic: <br><br><ul><li>  <a href="http://blog.ragozin.info/2016/10/hotspot-jvm-garbage-collection-options.html">http://blog.ragozin.info/2016/10/hotspot-jvm-garbage-collection-options.html</a> </li><li>  <a href="https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html</a> </li><li>  Using JDK tools with Linux core dumps <br>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/bugreports004.html">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/bugreports004.html#CHDHDCJD</a> </li></ul><br>  Linux Transparent Huge Pages reading: <br><br><ul><li>  <a href="https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/">https://www.perforce.com/blog/tales-field-taming-transparent-huge-pages-linux</a> </li><li>  <a href="https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/">https://tobert.github.io/tldr/cassandra-java-huge-pages.html</a> </li><li>  <a href="https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/">https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/</a> </li></ul><br>  Profiling and performance monitoring: <br><br><ul><li>  <a href="https://github.com/jvm-profiling-tools/perf-map-agent">https://github.com/jvm-profiling-tools/perf-map-agent</a> </li><li>  <a href="https://github.com/aragozin/jvm-tools">https://github.com/aragozin/jvm-tools</a> </li></ul><br>  Contacts: <br><br><ul><li>  <a href="https://blog.ragozin.info/">https://blog.ragozin.info</a> <br></li><li>  <a href="https://github.com/aragozin">https://github.com/aragozin</a> <br></li></ul><br>  If you have any questions, you can skip to the appropriate <a href="https://www.youtube.com/watch%3Fv%3DHVVsjyVxcJ8%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D2987">part.</a> <a href="https://www.youtube.com/watch%3Fv%3DHVVsjyVxcJ8%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D2987"><br></a>  report, maybe someone has already clarified. <br><br><blockquote>  Short epilogue <br><br>  <a href="http://ritfest.ru/moscow/2018/">RIT ++ is</a> already on May 28 and 29, the schedule is here, and this is a direct <a href="https://conf.ontico.ru/conference/join/rit2018.html">link</a> to purchase tickets. <br><br>  Before <a href="http://www.highload.ru/siberia/2018/">Highload ++ Siberia a</a> little more time, it will take place on June 25 and 26.  But the <a href="http://www.highload.ru/siberia/2018/abstracts">program is</a> already being actively formed, you can <a href="http://www.highload.ru/siberia/2018">subscribe</a> to the newsletter and be aware of updates. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/358520/">https://habr.com/ru/post/358520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358510/index.html">Task life cycle</a></li>
<li><a href="../358512/index.html">Carrot models, bottlenecks and speech recognition: the absence of dictionaries in the field of artificial intelligence</a></li>
<li><a href="../358514/index.html">Release Rust 1.26</a></li>
<li><a href="../358516/index.html">Terminal server for AutoCAD</a></li>
<li><a href="../358518/index.html">VimpelCom subscribers will pay 13 rubles per month for the Spring Law</a></li>
<li><a href="../358522/index.html">Go: we accelerate sampling of large tables from MySQL</a></li>
<li><a href="../358524/index.html">We will again be counted: National biometric platform and ‚Äúpass-through identifier‚Äù</a></li>
<li><a href="../358526/index.html">Number all real numbers on the interval [0,1]</a></li>
<li><a href="../358528/index.html">REST-API automatic documentation system in Laravel projects</a></li>
<li><a href="../358530/index.html">Introduction to Data Engineering. ETL, star schema and airflow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>