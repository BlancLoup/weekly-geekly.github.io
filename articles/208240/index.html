<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Logic function recovery</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article you can find a ready-made implementation and description of an algorithm for the reconstruction of logical functions using the black b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Logic function recovery</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce8/2f1/f60/ce82f1f60ca48fa0d02314bad9fa3e8c.jpg" alt="image"></div><br><br>  In this article you can find a ready-made implementation and description of an algorithm for the reconstruction of logical functions using the <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D1%2591%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D1%2589%25D0%25B8%25D0%25BA">black box</a> method.  By a logical function, I mean a function that takes a set of Boolean values ‚Äã‚Äãas arguments and returns one, respectively.  Example: <br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customlogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br>  At the end of the article the algorithm is checked on data obtained from the real world. <br><a name="habracut"></a><br>  In my opinion, this task is closely related to neurophysiology and as you might have guessed, I was inspired by the work of <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD">neurons</a> , so the analogies associated with the work and structure of this type of cells will be used.  In particular, the desire for something came after reading an article about the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B8%25D1%2582">structure</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B8%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">functioning of</a> dendrites.  Although I did not learn most of the material, but I made some analogies. <br><ul><li>  Dendritic trees perform a logical AND operation, since the potentials coming from the branches are summed, and if there is no signal from one or several branches, then most likely the potential will not reach the soma. </li><li>  A cat performs OR, generating an action potential if at least one tree delivers a signal. </li><li>  Inhibitory (inhibitory) bonds are NOT equivalent.  The truth is there is a bug, from the point of view of logic: NOT False = False, since the absence of a signal from the decelerating connection is not in itself capable of causing an action potential.  What narrows the range of possible functions, to those that, for all inactive parameters (False), do not generate True.  Consequently, a single neuron cannot simulate logical negation, but is fully capable of making XOR.  Although this behavior is ‚Äústrange‚Äù, it brings some benefits.  This approach is quite energy efficient, because if you keep the neuron on when all dendrites are not active, it means wasting energy.  Of course there are exceptions, neurons that periodically turn on without stimulating dendrites.  Roughly speaking, you can simulate AND NOT, but OR NOT </li></ul><br>  I think enough lyrics, let's get down to business. <br><div class="spoiler">  <b class="spoiler_title">Class source code and sample</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogicReconstructer</span></span></span><span class="hljs-class">:</span></span> groups=[] threshold = <span class="hljs-number"><span class="hljs-number">0.99</span></span> maxmem = <span class="hljs-number"><span class="hljs-number">10</span></span> numparams = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,numparams,threshold = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.99</span></span></span></span><span class="hljs-function"><span class="hljs-params">, totalmem = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.numparams=numparams self.threshold=threshold self.maxmem=totalmem <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getactive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,params)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(params)!=self.numparams: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"LogicReconstructer: numparams mismatch"</span></span>) active=[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.numparams): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> params[x]: active.append(x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> active <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extractgroups</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,params,result)</span></span></span><span class="hljs-function">:</span></span> active=self.getactive(params) exist = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> ignore = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> active: ind=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ind&lt;len(self.groups): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(active)&gt;len(self.groups[ind][<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.issublist(self.groups[ind][<span class="hljs-number"><span class="hljs-number">0</span></span>],active): ignore=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(active)==len(self.groups[ind][<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.issublist(active,self.groups[ind][<span class="hljs-number"><span class="hljs-number">0</span></span>]): exist=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(active)&lt;len(self.groups[ind][<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.issublist(active,self.groups[ind][<span class="hljs-number"><span class="hljs-number">0</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> self.groups[ind] ind-=<span class="hljs-number"><span class="hljs-number">1</span></span> ind+=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ignore: self.groups.append([active,[<span class="hljs-number"><span class="hljs-number">0</span></span>]*self.numparams,<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extractinhibitors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,params,result)</span></span></span><span class="hljs-function">:</span></span> active=self.getactive(params) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result: count=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _,grp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.groups): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.issublist(grp[<span class="hljs-number"><span class="hljs-number">0</span></span>],active): count+=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> count&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _,grp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.groups): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> grp[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.issublist(grp[<span class="hljs-number"><span class="hljs-number">0</span></span>],active): neg=[] negvalue=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.numparams): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> grp[<span class="hljs-number"><span class="hljs-number">1</span></span>][y]&lt;=-self.threshold: neg.append(y) negvalue|=params[y] <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> grp[<span class="hljs-number"><span class="hljs-number">1</span></span>][y]&gt;=self.threshold: grp[<span class="hljs-number"><span class="hljs-number">2</span></span>]=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.numparams): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> params[y]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> neg <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> negvalue: grp[<span class="hljs-number"><span class="hljs-number">1</span></span>][y] = self.counting(grp[<span class="hljs-number"><span class="hljs-number">1</span></span>][y],self.maxmem,result) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,prc,total,item)</span></span></span><span class="hljs-function">:</span></span> result=prc-prc/total <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> item: result-=<span class="hljs-number"><span class="hljs-number">1</span></span>/total <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result+=<span class="hljs-number"><span class="hljs-number">1</span></span>/total <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">issublist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,a,b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ind,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(a): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> b: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getsublist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,a,b)</span></span></span><span class="hljs-function">:</span></span> result=[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ind,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(a): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> b: result.append(item) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simulate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,params)</span></span></span><span class="hljs-function">:</span></span> result=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ind,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.groups): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">2</span></span>]: locres=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(item[<span class="hljs-number"><span class="hljs-number">0</span></span>])): locres&amp;=params[item[<span class="hljs-number"><span class="hljs-number">0</span></span>][x]] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(item[<span class="hljs-number"><span class="hljs-number">1</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">1</span></span>][x]&lt;=-self.threshold: locres=locres&amp;~params[x] result|=locres <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getlogicfunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,guess=False)</span></span></span><span class="hljs-function">:</span></span> result=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ind,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.groups): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> guess: locres=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(item[<span class="hljs-number"><span class="hljs-number">0</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x!=<span class="hljs-number"><span class="hljs-number">0</span></span>: locres+=<span class="hljs-string"><span class="hljs-string">" and "</span></span> locres+=str(item[<span class="hljs-number"><span class="hljs-number">0</span></span>][x]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(item[<span class="hljs-number"><span class="hljs-number">1</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">1</span></span>][x]&lt;=-self.threshold: locres+=<span class="hljs-string"><span class="hljs-string">" and not "</span></span>+str(x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ind!=<span class="hljs-number"><span class="hljs-number">0</span></span>: result+=<span class="hljs-string"><span class="hljs-string">" or "</span></span> result+=locres <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randparams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(self.numparams): result.append(random.choice([<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> result=bool(self.groups) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ind,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.groups): result&amp;=item[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getlogicstuct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.groups): grp=[] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">2</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(item[<span class="hljs-number"><span class="hljs-number">0</span></span>])): grp.append([item[<span class="hljs-number"><span class="hljs-number">0</span></span>][x],<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(item[<span class="hljs-number"><span class="hljs-number">1</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">1</span></span>][x]&lt;=-self.threshold: grp.append([x,<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> grp: result.append(grp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simulatebystruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,params,grps)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(grps): locres=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _,param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(item): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> param[<span class="hljs-number"><span class="hljs-number">1</span></span>]: locres&amp;=params[param[<span class="hljs-number"><span class="hljs-number">0</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: locres&amp;=~params[param[<span class="hljs-number"><span class="hljs-number">0</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> locres: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> locres: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customlogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">3</span></span>] \ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newme</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> numparams = <span class="hljs-number"><span class="hljs-number">12</span></span> neuron=LogicReconstructer(numparams) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> neuron.isready(): params=neuron.randparams() funcresult=customlogic(params) neuron.extractgroups(params,funcresult) neuron.extractinhibitors(params,funcresult) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000</span></span>): params=neuron.randparams() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> neuron.simulate(params)!=customlogic(params): print(<span class="hljs-string"><span class="hljs-string">"Simulate is wrong."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> print(neuron.getlogicfunc()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: newme()</code> </pre><br></div></div><br>  So, we have a set of input parameters, and some of them may not affect the performance of the implementation, so the first thing you need to understand what parameters are important.  It is better to start with the collection of independent activation groups, in other words, if the result of the function is True, then we write the numbers of active parameters in the database, with some reservations, which you can see in the <b>extractgroups</b> method.  Thus, we will find the parameters associated with the logical AND operator.  This stage can be compared with growing dendrites. <br><br>  Now let's move on to setting up synapses and, first of all, we need to distinguish inhibitory connections.  Since groups are conditionally independent of inhibitory connections, it means that <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%2591%25D0%25B0%25D0%25B9%25D0%25B5%25D1%2581%25D0%25B0">Bayes theorem</a> can be used.  In other words, if the activation group worked, then we calculate the effect of the other parameters on the result.  If the parameter negatively affects the result, i.e.  when activated, the result in most cases was False, then it is inhibiting (AND NOT).  See the <b>extractinhibitors</b> method for details. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The operation of the algorithm is considered complete when all groups received confirmation that all inhibitory links were found.  The confirmation is that the Bayesian probability of one of the parameters has stepped over the <b>threshold</b> . <br><br>  But let us assume that we lack some important parameters with which the function works, how can we determine this?  For example: <br><pre> <code class="python hljs">params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> params[<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> random.choice([<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>])</code> </pre><br>  We know about 4 parameters, but do not take into account the fifth.  In this particular case, the activation group, which consists only of parameter 3, does not cross the threshold.  But if we still took him into account, he would be in the same group with the 3rd.  As you understand, groups are separated by the logical OR operator. <br><br>  But if you lack the whole group: <br><pre> <code class="python hljs">params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> params[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> params[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> random.choice([<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> random.choice([<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>])</code> </pre>  then the groups (sorry for the tautology) in the analysis are divided into single parameters and each parameter will become activation, which is a sign. <br><br>  Try to play with <b>customlogic</b> in order to make sure that the algorithm works.  For example, I noticed that with a large number of braking links in a group, it may not be defined. <br><div class="spoiler">  <b class="spoiler_title">Bonus C ++ Bed Sheet</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// neuro.cpp:      . // #include "stdafx.h" #include &lt;vector&gt; #include &lt;map&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;iostream&gt; using namespace std; class Bool { public: Bool(): m_value(){} Bool( bool value ) : m_value(value){} operator bool() const { return m_value;} bool* operator&amp; () { return &amp;m_value; } const bool * const operator&amp; () const { return &amp;m_value; } private: bool m_value; }; class neuron { public: double threshold; int synapticmem; int numparams; map&lt;int,vector&lt;char&gt;&gt; groups; map&lt;int,vector&lt;double&gt;&gt; bayesian; map&lt;int,map&lt;char,bool&gt;&gt; grouplogic; int maxid; neuron(int numparams, double threshold = 0.99, int synapticmem = 10) { this-&gt;numparams=numparams; this-&gt;threshold=threshold; this-&gt;synapticmem=synapticmem; maxid=0; srand ( time(NULL) ); } ~neuron() { } vector&lt;char&gt; getactive(vector&lt;Bool&gt;&amp; params) { if (params.size()!=numparams) throw 1;// numparams mismatch vector&lt;char&gt; active; for (int i=0;i&lt;this-&gt;numparams;i++) if (params[i]) active.push_back((char)i); return active; } void extractgroups(vector&lt;Bool&gt;&amp; params, bool result) { vector&lt;char&gt; active= this-&gt;getactive(params); bool ignore = false; bool exist = false; if (result &amp;&amp; active.size()&gt;0) { map&lt;int,vector&lt;char&gt;&gt;::iterator i=this-&gt;groups.begin(); while (i!=this-&gt;groups.end()) { if (active.size()&gt;i-&gt;second.size()&amp;&amp;this-&gt;issublist(i-&gt;second,active)) { ignore=true; break; } else if (active.size()==i-&gt;second.size()&amp;&amp;this-&gt;issublist(active,i-&gt;second)) { exist=true; break; } else if (active.size()&lt;i-&gt;second.size()&amp;&amp;this-&gt;issublist(active,i-&gt;second)) { this-&gt;bayesian.erase(i-&gt;first); this-&gt;grouplogic.erase(i-&gt;first); i=this-&gt;groups.erase(i); } else i++; } if (!exist &amp;&amp; !ignore) { this-&gt;groups[this-&gt;maxid]=active; this-&gt;bayesian[this-&gt;maxid]=*new vector&lt;double&gt;(numparams,0); this-&gt;maxid++; } } } template&lt; class T &gt; bool issublist(vector&lt;T&gt;&amp; sublist, vector&lt;T&gt;&amp; fulllist) { for (int i=0;i&lt;sublist.size();i++) { bool match = false; for (int n=0;n&lt;fulllist.size();n++) if (sublist[i]==fulllist[n]) { match=true; break; } if (!match) return false; } return true; } template&lt;class InputIterator, class T&gt; InputIterator find (InputIterator first, InputIterator last, const T&amp; val) { while (first!=last) { if (*first==val) return first; ++first; } return last; } void extractinhibitors(vector&lt;Bool&gt;&amp; params, bool result) { vector&lt;char&gt; active= this-&gt;getactive(params); if (result) { bool count = false; for (map&lt;int,vector&lt;char&gt;&gt;::iterator i=this-&gt;groups.begin();i!=this-&gt;groups.end();++i) if(this-&gt;issublist(i-&gt;second,active)) if (!count) count=true; else return; } for (map&lt;int,vector&lt;char&gt;&gt;::iterator i=this-&gt;groups.begin();i!=this-&gt;groups.end();++i) if (grouplogic.count(i-&gt;first)==0) if (this-&gt;issublist(i-&gt;second,active)) { vector&lt;char&gt; neg; bool negvalue = false; for (int n=0;n&lt;this-&gt;numparams;n++) if (this-&gt;bayesian[i-&gt;first][n]&lt;=-1*this-&gt;threshold) { neg.push_back((char)n); negvalue|=params[n]; } else if (this-&gt;bayesian[i-&gt;first][n]&gt;=this-&gt;threshold) if (grouplogic.count(i-&gt;first)==0) this-&gt;build_grouplogic(i-&gt;first); for (int n=0;n&lt;this-&gt;numparams;n++) if (params[n]) if (!negvalue || this-&gt;find(neg.begin(), neg.end(), n) != neg.end()) this-&gt;bayesian[i-&gt;first][n]=counting(this-&gt;bayesian[i-&gt;first][n],result); } } double counting(double prc, bool result) { double oneless = prc - prc/this-&gt;synapticmem; if (result) oneless+=1.0/this-&gt;synapticmem; else oneless-=1.0/this-&gt;synapticmem; return oneless; } void build_grouplogic(int indgroup) { for (int i=0;i&lt;this-&gt;groups[indgroup].size();i++) this-&gt;grouplogic[indgroup][(char)groups[indgroup][i]]=true; for (int i=0;i&lt;numparams;i++) if (this-&gt;bayesian[indgroup][i]&lt;=-1*threshold) this-&gt;grouplogic[indgroup][(char)i]=false; } bool isready() { int count = 0; for (map&lt;int,vector&lt;char&gt;&gt;::iterator i=this-&gt;groups.begin();i!=this-&gt;groups.end();++i) if (grouplogic.count(i-&gt;first)!=0) count++; if (count==groups.size()&amp;&amp;groups.size()&gt;0) return true; return false; } bool randomBool() { return rand() % 2 == 1; } void randparams(vector&lt;Bool&gt;&amp; params) { for (int i=0;i&lt;this-&gt;numparams;i++) params[i]=this-&gt;randomBool(); } string getfunction() { string result=""; bool maincount=false; for (map&lt;int,map&lt;char,bool&gt;&gt;::iterator i=this-&gt;grouplogic.begin();i!=this-&gt;grouplogic.end();++i) { if (maincount) result+=" or "; string locres=""; bool count = false; for (map&lt;char,bool&gt;::reverse_iterator n=i-&gt;second.rbegin();n!=i-&gt;second.rend();++n) { if (count) locres+=" and "; if (!n-&gt;second) locres+="not "; locres+=(char)(((int)'0')+(int)n-&gt;first); count=true; } result+=locres; maincount=true; } return result; } bool simulate(vector&lt;Bool&gt;&amp; params) { bool result=false; for (map&lt;int,map&lt;char,bool&gt;&gt;::iterator i=this-&gt;grouplogic.begin();i!=this-&gt;grouplogic.end();++i) { bool locres=true; bool count = false; for (map&lt;char,bool&gt;::iterator n=i-&gt;second.begin();n!=i-&gt;second.end();++n) { if (n-&gt;second) locres&amp;=params[(int)n-&gt;first]; else locres&amp;=!params[(int)n-&gt;first]; } result|=locres; } return result; } }; bool customlogic(vector&lt;Bool&gt;&amp; params) { return params[0] &amp;&amp; params[1] &amp;&amp; !params[2] || params[3] &amp;&amp; !params[1] || params[5] &amp;&amp; !params[0] &amp;&amp; params[1]; } int _tmain(int argc, _TCHAR* argv[]) { int numparams = 6; clock_t start = clock() ; neuron* nine=new neuron(numparams); while (!nine-&gt;isready()) { vector&lt;Bool&gt; params(numparams, false); nine-&gt;randparams(params); bool result = customlogic(params); nine-&gt;extractgroups(params,result); nine-&gt;extractinhibitors(params,result); } clock_t end = clock(); double elapsed_time = (end-start)/(double)CLOCKS_PER_SEC; for (int i=0;i&lt;1000;i++) { vector&lt;Bool&gt; params(numparams, false); nine-&gt;randparams(params); if (nine-&gt;simulate(params)!=customlogic(params)) { printf("Simulate is wrong"); return 0; } } printf("%s\n%.3f sec\n",nine-&gt;getfunction().c_str(),elapsed_time); getchar(); return 0; }</span></span></code> </pre><br></div></div><br><h4>  Experiment </h4><br>  Of course it is good that the algorithm works, but can it cope with data from the real world?  I decided to check it on a single data set taken <a href="http://archive.ics.uci.edu/ml/datasets/banknote%2Bauthentication">from here</a> .  The task is to classify fake banknotes from the present in four parameters of type float.  I must say I did not understand what they mean.  But this is only on hand to the purity of the experiment, because the machine should be trained, not me. <br><div class="spoiler">  <b class="spoiler_title">That's what happened</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getbinary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num,max,min =</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function">:</span></span> result=[] binnums=int(math.ceil(math.log(abs(min-max),<span class="hljs-number"><span class="hljs-number">2</span></span>))) binstr=(<span class="hljs-string"><span class="hljs-string">'{0:0'</span></span>+str(binnums)+<span class="hljs-string"><span class="hljs-string">'b}'</span></span>).format(-min+num) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _,item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binstr): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item==<span class="hljs-string"><span class="hljs-string">'1'</span></span>: result.append(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">banknotes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> file = open(<span class="hljs-string"><span class="hljs-string">'C:/bankdata.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>)<span class="hljs-comment"><span class="hljs-comment"># http://archive.ics.uci.edu/ml/datasets/banknote+authentication lines = file.readlines() file.close() data = [] for i in range(len(lines)): data.append(lines[i].strip().split(",")) lines.clear() numdata = [] paramsmax=[0,0,0,0] paramsmin=[0,0,0,0] for i in range(len(data)): tmp=[] for x in range(len(data[i])): if x!=4: tmp.append(int(round(float(data[i][x])))) paramsmax[x]=max(paramsmax[x],int(round(float(data[i][x])))) paramsmin[x]=min(paramsmin[x],int(round(float(data[i][x])))) else: if data[i][x]=='0': tmp.append(False) else: tmp.append(True) numdata.append(tmp) data.clear() bindata=[] for i in range(len(numdata)): tmp=[] for x in range(len(numdata[i])): if x!=4: tmp.extend(getbinary(numdata[i][x],paramsmax[x],paramsmin[x])) else: tmp.extend([numdata[i][x]]) bindata.append(tmp) numdata.clear() neuron = LogicReconstructer(len(bindata[0])-1,totalmem=7, threshold=0.98) for _,item in enumerate(bindata): neuron.extractgroups(item[:-1],item[-1:][0]) ready=False while not neuron.isready(): rnd=random.randint(0,len(bindata)-1) neuron.extractinhibitors(bindata[rnd][:-1],bindata[rnd][-1:][0]) logicstruct=neuron.getlogicstuct() print(logicstruct) falsepositive = 0 falsenegative = 0 for _,item in enumerate(bindata): res = neuron.simulatebystruct(item[:-1],logicstruct) if res!=item[-1:][0]: if res: falsepositive+=1 else: falsenegative+=1 print(falsenegative/len(bindata),falsepositive/len(bindata))</span></span></code> </pre><br></div></div><br>  Since the algorithm only accepts binary data, I had to round numbers to integers and convert them to binary form <b>using the getbinary</b> function.  After training, I got this structure consisting of 134 logical groups: <br><div class="spoiler">  <b class="spoiler_title">logicstruct</b> <div class="spoiler_text"><pre> <code class="python hljs"> logicstr=<span class="hljs-string"><span class="hljs-string">"[[[2, True], [3, True], [6, True], [7, True], [10, True], [11, True], [12, True], [13, True], [14, True], [16, True]], [[1, True], [3, True], [4, True], [8, True], [12, True], [15, True], [16, True], [17, True]], [[1, True], [3, True], [5, True], [10, True], [12, True], [14, True], [16, True], [6, False], [7, False], [8, False], [11, False]], [[1, True], [2, True], [5, True], [6, True], [7, True], [11, True], [13, True], [14, True], [16, True], [10, False]], [[1, True], [2, True], [5, True], [6, True], [11, True], [12, True], [13, True], [14, True], [16, True]], [[2, True], [3, True], [8, True], [9, True], [12, True], [15, True], [16, True]], [[1, True], [2, True], [3, True], [4, True], [8, True], [15, True], [17, True], [6, False], [7, False], [11, False]], [[1, True], [4, True], [7, True], [8, True], [11, True], [15, True], [2, False], [6, False]], [[1, True], [6, True], [10, True], [11, True], [12, True], [15, True], [16, True], [17, True]], [[0, True], [5, True], [6, True], [7, True], [8, True], [12, True], [14, True], [17, True], [10, False], [11, False], [13, False]], [[0, True], [4, True], [7, True], [15, True], [17, True], [6, False], [16, False]], [[1, True], [3, True], [5, True], [10, True], [12, True], [14, True], [17, True], [2, False], [6, False], [7, False]], [[0, True], [5, True], [6, True], [7, True], [12, True], [13, True], [14, True], [16, True], [2, False], [11, False]], [[0, True], [4, True], [7, True], [8, True], [16, True], [17, True], [6, False], [15, False]], [[1, True], [4, True], [8, True], [11, True], [13, True], [14, True], [2, False]], [[0, True], [4, True], [12, True], [14, True], [17, True], [6, False], [11, False], [13, False]], [[2, True], [3, True], [4, True], [8, True], [11, True], [15, True], [17, True], [1, False], [6, False], [7, False]], [[1, True], [3, True], [5, True], [6, True], [7, True], [11, True], [14, True], [2, False], [10, False], [12, False]], [[1, True], [2, True], [4, True], [12, True], [14, True], [11, False]], [[1, True], [6, True], [7, True], [8, True], [9, True], [14, True]], [[2, True], [5, True], [9, True], [14, True]], [[1, True], [4, True], [7, True], [11, True], [13, True], [14, True], [2, False], [3, False], [8, False], [12, False], [17, False]], [[1, True], [3, True], [5, True], [8, True], [10, True], [11, True], [14, True], [17, True], [6, False]], [[2, True], [3, True], [6, True], [7, True], [9, True], [13, True], [14, True]], [[1, True], [5, True], [6, True], [8, True], [11, True], [12, True], [13, True], [14, True], [16, True], [0, False], [7, False]], [[2, True], [3, True], [7, True], [9, True], [11, True], [14, True]], [[1, True], [5, True], [6, True], [7, True], [11, True], [12, True], [14, True], [16, True], [0, False], [8, False]], [[1, True], [3, True], [4, True], [8, True], [12, True], [13, True], [15, True], [16, True], [2, False], [5, False], [6, False], [11, False]], [[1, True], [6, True], [8, True], [10, True], [11, True], [12, True], [14, True]], [[1, True], [2, True], [4, True], [8, True], [13, True], [15, True], [16, True], [6, False]], [[1, True], [2, True], [5, True], [6, True], [10, True], [14, True], [16, True], [11, False], [13, False]], [[2, True], [3, True], [4, True], [7, True], [8, True], [11, True], [15, True], [1, False], [6, False], [17, False]], [[1, True], [6, True], [10, True], [11, True], [13, True], [15, True], [16, True], [17, True]], [[1, True], [2, True], [5, True], [7, True], [11, True], [12, True], [13, True], [14, True], [16, True]], [[2, True], [4, True], [6, True], [8, True], [11, True], [13, True], [16, True], [0, False], [15, False]], [[1, True], [5, True], [6, True], [7, True], [10, True], [14, True], [17, True], [2, False], [8, False], [11, False], [12, False]], [[1, True], [5, True], [10, True], [12, True], [13, True], [14, True], [16, True]], [[0, True], [4, True], [7, True], [15, True], [16, True], [6, False], [17, False]], [[1, True], [2, True], [3, True], [4, True], [7, True], [8, True], [16, True], [17, True], [6, False]], [[1, True], [2, True], [5, True], [6, True], [11, True], [14, True], [17, True], [10, False], [12, False]], [[1, True], [2, True], [4, True], [8, True], [12, True], [15, True], [16, True]], [[1, True], [4, True], [11, True], [13, True], [15, True], [16, True], [17, True], [5, False], [6, False], [7, False], [8, False]], [[2, True], [3, True], [5, True], [10, True], [11, True], [12, True], [13, True], [14, True]], [[2, True], [5, True], [8, True], [10, True], [11, True], [12, True], [13, True], [14, True]], [[1, True], [2, True], [5, True], [6, True], [7, True], [8, True], [11, True], [14, True], [3, False], [10, False], [12, False], [16, False], [17, False]], [[1, True], [7, True], [9, True], [13, True], [15, True], [16, True]], [[1, True], [2, True], [5, True], [10, True], [13, True], [14, True], [17, True], [3, False], [6, False], [11, False]], [[0, True], [5, True], [6, True], [7, True], [8, True], [11, True], [14, True], [17, True], [12, False], [16, False]], [[1, True], [3, True], [6, True], [7, True], [10, True], [11, True], [14, True], [5, False]], [[0, True], [5, True], [7, True], [8, True], [11, True], [12, True], [13, True], [14, True], [16, True], [2, False], [6, False]], [[2, True], [3, True], [4, True], [6, True], [11, True], [13, True], [16, True], [17, True], [1, False], [7, False], [8, False], [15, False]], [[1, True], [5, True], [6, True], [8, True], [10, True], [14, True], [17, True], [11, False]], [[1, True], [2, True], [5, True], [8, True], [10, True], [14, True], [17, True], [3, False], [6, False], [11, False]], [[2, True], [4, True], [6, True], [7, True], [11, True], [13, True], [15, True], [1, False], [16, False], [17, False]], [[1, True], [4, True], [11, True], [12, True], [14, True], [17, True], [2, False], [3, False], [13, False]], [[1, True], [2, True], [3, True], [5, True], [6, True], [7, True], [8, True], [12, True], [13, True], [14, True]], [[1, True], [2, True], [5, True], [6, True], [10, True], [12, True], [14, True], [17, True], [3, False], [7, False]], [[1, True], [6, True], [7, True], [9, True], [13, True], [14, True]], [[1, True], [9, True], [11, True], [12, True], [13, True], [15, True], [16, True], [17, True]], [[1, True], [7, True], [9, True], [12, True], [13, True], [14, True]], [[1, True], [2, True], [5, True], [10, True], [12, True], [14, True], [16, True]], [[3, True], [4, True], [6, True], [11, True], [12, True], [16, True], [0, False]], [[1, True], [8, True], [9, True], [12, True], [15, True], [16, True]], [[2, True], [4, True], [6, True], [7, True], [11, True], [13, True], [17, True], [15, False]], [[1, True], [2, True], [6, True], [7, True], [8, True], [10, True], [12, True], [14, True], [17, True]], [[2, True], [3, True], [4, True], [8, True], [11, True], [13, True], [14, True], [1, False], [12, False]], [[0, True], [4, True], [8, True], [13, True], [14, True], [2, False], [11, False], [12, False], [16, False], [17, False]], [[2, True], [3, True], [4, True], [8, True], [11, True], [15, True], [16, True], [1, False], [6, False], [7, False], [17, False]], [[2, True], [4, True], [8, True], [11, True], [12, True], [14, True], [0, False], [3, False]], [[1, True], [5, True], [6, True], [7, True], [11, True], [13, True], [14, True], [17, True], [0, False]], [[2, True], [3, True], [6, True], [8, True], [9, True], [13, True], [14, True]], [[1, True], [5, True], [6, True], [8, True], [10, True], [14, True], [16, True], [11, False]], [[1, True], [2, True], [6, True], [7, True], [10, True], [11, True], [14, True], [17, True]], [[1, True], [3, True], [6, True], [10, True], [11, True], [13, True], [14, True], [5, False]], [[1, True], [2, True], [3, True], [5, True], [7, True], [8, True], [11, True], [12, True], [14, True], [16, True]], [[2, True], [3, True], [4, True], [6, True], [11, True], [12, True], [15, True], [1, False], [7, False]], [[1, True], [2, True], [5, True], [10, True], [13, True], [14, True], [16, True], [6, False], [11, False]], [[1, True], [2, True], [3, True], [5, True], [6, True], [8, True], [11, True], [14, True], [16, True]], [[1, True], [2, True], [5, True], [6, True], [7, True], [8, True], [12, True], [13, True], [14, True], [17, True]], [[1, True], [3, True], [5, True], [6, True], [10, True], [13, True], [14, True], [17, True], [2, False], [11, False]], [[2, True], [3, True], [9, True], [11, True], [12, True], [13, True], [15, True], [16, True]], [[2, True], [3, True], [6, True], [7, True], [8, True], [9, True], [14, True], [17, True]], [[1, True], [8, True], [9, True], [11, True], [13, True], [14, True]], [[1, True], [2, True], [6, True], [7, True], [10, True], [11, True], [14, True], [16, True], [5, False], [13, False]], [[1, True], [3, True], [6, True], [10, True], [11, True], [12, True], [14, True], [17, True]], [[1, True], [2, True], [7, True], [8, True], [10, True], [11, True], [12, True], [13, True], [14, True]], [[0, True], [5, True], [6, True], [7, True], [11, True], [14, True], [16, True], [8, False], [12, False], [13, False]], [[1, True], [4, True], [7, True], [11, True], [15, True], [17, True], [2, False], [6, False]], [[0, True], [5, True], [7, True], [11, True], [12, True], [13, True], [14, True], [16, True], [17, True], [2, False], [6, False]], [[3, True], [4, True], [6, True], [7, True], [11, True], [13, True], [15, True], [0, False], [17, False]], [[1, True], [3, True], [5, True], [6, True], [11, True], [12, True], [13, True], [14, True], [16, True]], [[1, True], [3, True], [5, True], [10, True], [11, True], [13, True], [14, True], [17, True], [2, False], [6, False]], [[1, True], [6, True], [7, True], [10, True], [11, True], [12, True], [13, True], [14, True], [16, True]], [[1, True], [3, True], [4, True], [8, True], [12, True], [13, True], [15, True], [17, True], [2, False], [6, False], [7, False], [11, False]], [[4, True], [6, True], [8, True], [11, True], [12, True], [17, True], [0, False], [15, False]], [[1, True], [7, True], [8, True], [10, True], [11, True], [12, True], [15, True], [16, True], [17, True]], [[1, True], [5, True], [10, True], [12, True], [13, True], [14, True], [17, True]], [[1, True], [3, True], [6, True], [7, True], [8, True], [10, True], [12, True], [14, True]], [[0, True], [5, True], [6, True], [7, True], [12, True], [13, True], [14, True], [17, True], [3, False], [8, False], [11, False]], [[3, True], [4, True], [6, True], [7, True], [8, True], [11, True], [13, True], [16, True], [15, False]], [[2, True], [3, True], [4, True], [11, True], [12, True], [14, True], [0, False], [1, False], [8, False]], [[4, True], [6, True], [7, True], [8, True], [11, True], [13, True], [15, True], [1, False], [2, False], [3, False]], [[1, True], [2, True], [4, True], [11, True], [14, True], [3, False], [6, False], [10, False]], [[2, True], [3, True], [6, True], [7, True], [9, True], [12, True], [15, True], [16, True], [17, True]], [[1, True], [3, True], [4, True], [7, True], [11, True], [15, True], [16, True], [2, False], [6, False]], [[2, True], [3, True], [8, True], [9, True], [11, True], [13, True], [15, True], [16, True], [17, True]], [[2, True], [3, True], [6, True], [7, True], [10, True], [11, True], [12, True], [13, True], [14, True], [17, True]], [[1, True], [3, True], [4, True], [7, True], [12, True], [13, True], [15, True], [17, True], [6, False]], [[1, True], [4, True], [8, True], [11, True], [15, True], [16, True], [2, False], [13, False]], [[1, True], [6, True], [7, True], [8, True], [10, True], [12, True], [13, True], [14, True]], [[1, True], [2, True], [5, True], [7, True], [11, True], [12, True], [13, True], [14, True], [17, True]], [[2, True], [4, True], [6, True], [8, True], [11, True], [13, True], [17, True], [0, False], [15, False]], [[1, True], [2, True], [3, True], [5, True], [6, True], [7, True], [12, True], [13, True], [14, True], [17, True]], [[4, True], [5, True], [11, True], [13, True], [16, True], [1, False], [15, False]], [[1, True], [2, True], [4, True], [8, True], [12, True], [15, True], [17, True], [11, False]], [[2, True], [3, True], [4, True], [7, True], [11, True], [15, True], [17, True], [1, False], [6, False]], [[2, True], [4, True], [7, True], [11, True], [12, True], [14, True], [0, False], [3, False]], [[2, True], [3, True], [5, True], [6, True], [7, True], [11, True], [12, True], [14, True], [17, True], [0, False], [8, False], [16, False]], [[1, True], [3, True], [4, True], [11, True], [14, True], [2, False], [6, False], [16, False]], [[2, True], [3, True], [6, True], [7, True], [9, True], [13, True], [15, True], [16, True], [17, True]], [[2, True], [8, True], [9, True], [11, True], [14, True]], [[1, True], [2, True], [3, True], [4, True], [7, True], [15, True], [17, True], [6, False], [11, False]], [[1, True], [6, True], [7, True], [8, True], [10, True], [11, True], [14, True], [5, False]], [[1, True], [2, True], [3, True], [5, True], [6, True], [7, True], [12, True], [13, True], [14, True], [16, True]], [[1, True], [5, True], [6, True], [11, True], [12, True], [14, True], [17, True], [2, False]], [[2, True], [3, True], [4, True], [11, True], [13, True], [15, True], [16, True], [1, False]], [[2, True], [8, True], [9, True], [11, True], [12, True], [15, True], [16, True]], [[0, True], [5, True], [6, True], [7, True], [11, True], [13, True], [14, True], [17, True], [1, False], [2, False], [8, False], [12, False]], [[1, True], [2, True], [6, True], [10, True], [11, True], [12, True], [14, True], [17, True]], [[0, True], [4, True], [8, True], [13, True], [15, True], [17, True], [2, False], [3, False], [5, False], [6, False]], [[1, True], [3, True], [7, True], [8, True], [10, True], [11, True], [12, True], [14, True], [5, False], [6, False], [16, False]], [[1, True], [2, True], [3, True], [5, True], [8, True], [11, True], [12, True], [13, True], [14, True], [16, True]], [[1, True], [2, True], [3, True], [5, True], [6, True], [11, True], [13, True], [14, True], [16, True], [10, False]], [[1, True], [4, True], [8, True], [11, True], [15, True], [17, True], [2, False], [12, False]]]"</span></span> logicstruct=literal_eval(logicstr)</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which gives 2.8% false negative and 0.6% false positive responses. </font><font style="vertical-align: inherit;">These 134 groups summarized about 700 positive examples. </font><font style="vertical-align: inherit;">There were a total of 1,372 entries. </font><font style="vertical-align: inherit;">Each launch can generate a new structure. </font><font style="vertical-align: inherit;">I also ask you to note that I did not divide the data into training and verification samples and criticism in the plan: ‚ÄúYes, the algorithm simply remembered everything and will be covered with new data‚Äù is quite appropriate.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/b06/516/22eb0651604967ac578c2893a1bf19b5.gif" alt="image"></div></div><p>Source: <a href="https://habr.com/ru/post/208240/">https://habr.com/ru/post/208240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208224/index.html">Monologue incognito with one IT conference</a></li>
<li><a href="../208226/index.html">How can an IT specialist save his finances?</a></li>
<li><a href="../208230/index.html">Nvidia announced the processor Tegra K1 (Tegra 5) with 192 cores</a></li>
<li><a href="../208232/index.html">Olympiad FUPM MIPT for schoolchildren</a></li>
<li><a href="../208236/index.html">Sphinx for ASP.NET via jTemplates</a></li>
<li><a href="../208244/index.html">Parallel and distributed computing. Lectures from Yandex for those who want to spend the holidays with benefit</a></li>
<li><a href="../208246/index.html">New Google API for site verification</a></li>
<li><a href="../208250/index.html">Wi-Fi trap from the NSA can work up to 8 miles</a></li>
<li><a href="../208252/index.html">Voltage relay overview with control of current DigiTop VA-protector 63A</a></li>
<li><a href="../208256/index.html">The evolution of garbage collection in Ruby. Rgenc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>