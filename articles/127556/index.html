<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another Monad Guide (part 1: basics)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By mike vanier 

 In the Haskell community, it‚Äôs a joke that every Haskell programmer should write one or more monad tutorials during his training. An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another Monad Guide (part 1: basics)</h1><div class="post__text post__text-html js-mediator-article">  By mike vanier <br><br>  In the Haskell community, it‚Äôs a joke that every Haskell programmer should write one or more monad tutorials during his training.  And I am no exception.  But I know that there are so many manuals on this topic, many of them are good - so why should I write Another One?  Two reasons: <br><ol><li>  I think I can explain some aspects of monads better than many other guides that I have seen. </li><li>  I began to understand monads much better than I now want to share as much as possible. </li></ol><br><br><h5>  Prerequisites </h5><br>  Since I will be writing Haskell examples, it would be useful for you, the reader, to know it, including sections such as polymorphism and type classes.  Without this knowledge, the material will be difficult to understand.  Dozens of Haskell introductory tutorials have already been written that are worth reading to an unprepared reader, and then return to a series of these articles. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But to know the theory of categories, a very abstract branch of mathematics, I do not demand, even though it describes the theory of monads (in terms of this article).  Of course, knowledge of the theory of categories does not harm, but it is not necessary to understand the presented material.  I do not believe those who say that you need a theory of categories before learning monads in application to programming languages ‚Äã‚Äã- this is not so.  If you studied it, it's good, but I see no advantage in using terminology from there. <br><a name="habracut"></a><br><br><h5>  Waiver of ... </h5><br>  I am not going to teach you everything that is in the world of monads for two reasons.  First: it would be very long, and the second: I do not know everything and, probably, I will never know.  I want to give you an understanding of monads at a pure conceptual level, and why they are useful, how to work with them, and which common monads are most often used.  By clicking the links at the end of this series of articles, you can explore the monads in more depth. <br><br>  Do not wait for tons of code that you can immediately use in your daily work.  This is not a "book of ready-made recipes!"  I really believe that you need to understand what happens when you program using monads, and this manual was written to explain them in detail.  With it, you can read other manuals (see links) to find the best monadic solutions to practical problems, and my goal is to outline the big picture and help you really understand the monads and their work. <br><br>  Finally, I notify you that I will repeat and repeat the main thoughts until they smack me dead, because I want you to fully understand what I am trying to say.  I hope it will not be boring - although it will be long, because the monads cannot be explained in several sentences.  Make a cup of coffee and make sure your chair is comfortable - understanding will take time. <br><br><h5>  Motivation: why should you think about monads? </h5><br>  As far as I know, the first monads were used in Haskell, based on the works of Eugenio Moggi and Philip Wadler (two giants with whom I can not compare).  Since then, they have appeared in other languages, especially in functional languages.  But why should you, the reader (presumably a programmer who has not tried a functional programming drug), worry about monads? <br><br>  The main idea of ‚Äã‚Äãfunctional programming is to use <i>pure</i> functions as widely as possible.  The net function is the black box.  All it does is take one or more arguments, calculate something and return the result.  It <i>does not operate with</i> any side effects.  No reads-entries to files and files, no printing to the console, no changes to global variables, no exception handling, and so on.  The advantage here is that the behavior of a pure function is strictly defined: it <i>always</i> returns the same value to the same arguments.  Pure function is more predictable, easier to test, and less error prone.  ({1}) For comparison, an unclean function (which has side effects) will not necessarily calculate the same result with several identical calls.  For example, the answer may be different if the value of the global variable changes, or if the contents of the readable file are different.  Unclean functions are harder to test, prone to many errors, and there are many situations where functions fail.  For these reasons, functional programming languages ‚Äã‚Äãencourage you to write pure functions whenever possible. <br><br>  However, programs in pure functions are too limited.  There are cases when programs are written easier using side effects, although they can be written (with torment) only in pure functions.  And in some other cases it is impossible to do without side effects at all.  For example, a program that copies a file from one folder to another interacts with the file system and modifies it;  if your pure functions are not allowed to read and write files (and these are side effects), then they will not be able to solve this problem.  So we <i>need</i> ways to work with side effects even in functional languages. <br><br>  Functional languages ‚Äã‚Äãare of two kinds: clean and unclean.  Impure FWs (Scheme, OCaml) do not care about this problem: they simply allow you to write any functions with side effects, although programmers of unclean FWs usually avoid this without special need.  Pure FWs (such as Haskell) are more hardcore: they generally prohibit writing directly functions with side effects (you will soon find out why I wrote ‚Äúdirectly‚Äù).  Therefore, as you can imagine, the topic of side effects in pure programming languages ‚Äã‚Äãhas been one of the main research areas for a long time. <br><br>  Monads were the key to solving this problem.  (More precisely, one of the keys; in some other FWs, other approaches were invented; ‚ÄúClean's uniqueness type‚Äù as an option.) With the help of monads, you can use calculations with side effects without disturbing the purity of the language.  Monads and type systems allow us to separate calculations with side effects from other calculations, and they will not interfere with each other.  We get all the advantages of the code without side effects, and this is guaranteed by the type system.  At the same time, we can perform side effects as needed.  And this is a very powerful concept. <br><br>  And as if that were not enough, it turned out that monads have many other uses, not just curbing side effects.  Monads are a very versatile tool with which you can organize various types of calculations with transparent behavior.  Some programs are greatly simplified.  In many cases, the monadic code is shorter and clearer than its non-adic analogue;  we will examine examples of this phenomenon.  In general, monads are also useful outside of side effects in functional languages. <br><br>  Monads are one of the amazing ideas in the theory of programming languages, and they are worth exploring. <br><br><h5>  Definition: what are monads? </h5><br><blockquote>  Monads are a generalization over functions, over the application of functions and over the composition of a function, with the help of which the very concept of computation is abstracted in comparison with standard functions. </blockquote><br><br>  In the process, I hope to explain to you not only the monads themselves and how they work, but also why they discourage programmers who have not met them before.  (Hint: it's not because programmers aren't smart enough or don't know category theory.) <br><br><h5>  Concept of computing </h5><br>  Well, let's begin the analysis of my definition with the expression ‚Äúthe concept of calculations‚Äù. <br><br>  The simplest and most predictable calculation is ordinary (pure) functions (that is, the mathematical definition of functions).  For simplicity, I will consider functions that map one input argument to one output.  (It is possible to reduce a multi-argument function to a function with a single argument using the <i>currying</i> procedure, and I will have to tell more about this - but later. Now just take my words for granted.) As I said earlier, the rule for a pure function should be : it should <i>always</i> return the same results for the same input parameter.  In strongly typed languages ‚Äã‚Äãlike Haskell, a function has a type definition, which always means that for types a and b, the function maps the value of type a to the value of type b.  Here‚Äôs what it looks like in Haskell: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> b </blockquote><br><br>  Here the double colon "::" means "has the following type."  Thus, the function f has the functional type a -&gt; b, and this means that the function takes a value of type a and returns a value of type b.  In practice, instead of a and b, there are usually specific types: Int, Float, String ..., but in Haskell, functions can also work regardless of the types of arguments.  ({3}) <br><br>  So, pure functions are the simplest ‚Äúnotion of computation‚Äù.  And what calculations still exist?  There are many of them, and you know many of them;  This includes calculations that: <br><ul><li>  work with input / output (files, console); </li><li>  cause exceptions; </li><li>  change some general state (global, local); </li><li>  can sometimes fail; </li><li>  returns many results at once; </li><li>  and many others. </li></ul><br><br>  Note: I used the phrase ‚ÄúInput / Output‚Äù, or abbreviated I / O, to denote input / output when working with a file or console.  It is known that I / O operations carry side effects.  Do not confuse the input / output operation with the input and output value of the function. <br><br>  Think for a second about how you would work with these calculations in ordinary programming languages ‚Äã‚Äã- in C or Java.  Calculations with I / O operations?  No problems!  <i>Any</i> C and Java function can.  What about calling exceptions?  In C, this is a little difficult, since there is no language support for exceptions, but you can return an error code in the event of a failure.  (Or you can handle errors in general with setjmp / longjmp if you are a hard-core low-level programmer.) In Java, you simply throw an exception in the hope that it is being processed somewhere.  In addition to exceptions, there is still a state - how to work with it?  Yes, in general, simple: in C, and in Java, you can read and write variables, global and local, in different ways.  And calculations that can fail?  They can be considered as a degenerate case of exceptions, so again no problems.  Finally, what about computations that return many values?  Here, under the set of values, I mean not one object that contains a bunch of results - not a C structure or a Java object - I‚Äôm talking about functions that can return several separate results "in parallel".  It's not entirely clear how to do this in C or Java.  ({four}) <br><br>  It is important to note the following: in all cases we are no longer talking about the traditional concept of computing, since besides the usual mapping of the input parameter to the output ‚Äúsomewhere else‚Äù, ‚Äúsomething else‚Äù happens.  In addition, there are other kinds of ‚Äúsomething else,‚Äù with their own concepts of computation.  We usually don‚Äôt worry about it when we write programs;  we simply understand that our ‚Äúfunctions‚Äù are not exactly the same as functions in the mathematical sense.  After all, they have side effects of input / output, exceptions, changes in global variables, and so on.  For most programmers, this is not important - until they grab an unpleasant mistake, because of what turns out to be a changed global variable, or until the program suddenly stops with an exception, or until some other problem occurs due to the non-functional nature of all these "Functions".  Thus, we would like to use pure functions as much as possible.  We would like to, but there are cases when it is impossible, and we have to do ‚Äúsomething else‚Äù, that is, calculations with side effects. <br><br>  Only one conclusion: we want to sit on two chairs.  ({5}) We would like to write code in pure functions wherever possible, getting all the benefits of this: easier debugging, verification ... But also we would like to work with that very ‚Äúsomething else‚Äù in a <i>controlled</i> way, because there is no exit or so better in a particular situation.  And that is what monads allow us to do. <br><br>  BUT!  The key phrase of the last paragraph is ‚Äúin a controlled way‚Äù.  If this mechanism worked the same way as in C or Java, we would, of course, solve our problems with the help of many of these non-functional calculations, however, we would also lose the benefits of functional programming.  After all, we would have no guarantees that the functions are clean, even type checking would not help here.  Some kind of systematic approach is needed to work with other notions of calculations, which would not violate the purity of the code. <br><br>  Now we will consider the useful concepts of (pure) functions, (pure) use of functions and (pure) composition of functions, and then compare it with the monadic method that implements the same goals. <br><br><h5>  Functions, application (application) of functions and composition of functions </h5><br>  Earlier, I mentioned that Haskell uses a special entry to determine the types of input and output parameters of functions.  For the function f, whose input type is a and output type b, the entry will look like this: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> b </blockquote><br><br>  Thus, f is of type a -&gt; b (reads ‚Äúfrom a to b‚Äù).  Here is a more specific example of a function that doubles the input value: <br><br><blockquote>  f <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <br>  f x <font color="#339933">=</font> <font>2</font> <font color="#339933">*</font> x </blockquote><br><br>  f is of type Int -&gt; Int, because it takes an integer, multiplies it by two, and returns another integer. <br><br>  To execute a function is simple, for this we apply it to the argument (we assume that it has one argument).  This is usually done by putting an argument to a function: <br><br><blockquote>  f <font>2</font> <font color="#5d478b">- the function "f 2" value = 4.</font> </blockquote><br><br>  Note that in Haskell the arguments are not wrapped in parentheses, as in many other programming languages. <br><br><blockquote>  <b>Currying</b> <br><br>  In practice, single-argument functions are insufficient for many problems.  How do we define a two-argument function?  How do we, for example, write the function q, which takes two integer arguments and returns the sum of their squares?  The body of the function is easy to write: <br><br><blockquote>  q x y <font color="#339933">=</font> x <font color="#339933">*</font> x <font color="#339933">+</font> y <font color="#339933">*</font> y </blockquote><br><br>  Function type signature omitted.  Perhaps you are expecting some such option: <br><br><blockquote>  q <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> </blockquote><br><br>  or perhaps this: <br><br><blockquote>  q <font color="#339933">::</font> <font>(</font> <font color="#cccc00">Int</font> <font color="#339933">,</font> <font color="#cccc00">Int</font> <font>)</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> </blockquote><br><br>  In fact, the type of this function looks like this: <br><br><blockquote>  q <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> </blockquote><br><br>  The arrow "-&gt;" is right associative, so the entry means the following: <br><br><blockquote>  q <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font>(</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <font>)</font> </blockquote><br><br>  Now it looks interesting.  The function of two arguments, which in Haskell becomes a function of one argument (x in our case), returns another function of one argument, which in turn takes the next argument (y) and returns the result.  And this is correct, because in Haskell, as in other FFs, functions can be returned as values ‚Äã‚Äãof other functions.  (In other words, functions are just another type of data in the FN.) This way of representing multi-argument functions as one-argument functions is called currying (after Haskell Curry, whose name also calls Haskell. Currying is independently open to scientist Scheinfinkle, so you can call this procedure and so, if you want).  For clarification, take the function r with four integer arguments w, x, y, and z, which returns an integer. <br><br><blockquote>  r <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <br>  r w x y z <font color="#339933">=</font> <font color="#339933">...</font> <font color="#5d478b">is some function of w, x, y, and z</font> </blockquote><br><br>  Right associative arrow gives: <br><br><blockquote>  r <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font>(</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font>(</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font>(</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <font>)</font> <font>)</font> <font>)</font> <br>  r w x y z <font color="#339933">=</font> <font color="#339933">...</font> <font color="#5d478b">is some function of w, x, y, and z</font> </blockquote><br><br>  where r is a function of one integer argument w, which returns a function of type (Int -&gt; (Int -&gt; (Int -&gt; Int))).  That function, when applied to an integer (x in our example), returns a function of type (Int -&gt; (Int -&gt; Int)).  The next function, when applied to the integer (y in the example), returns a function of the type (Int -&gt; Int), which, in turn, when applied to another integer (z), returns an integer - the result of the call (rwxyz), which , in fact, ((((rw) x) y) z).  And this is called currying.  Haskell automatically curries functions.  Carring is very convenient, because you can pass arguments one by one and not all at once, and these partially applied functions are often quite useful in their own right.  And also currying is conceptually useful to us by the fact that from now on it is enough for us to think about the functions of one argument, and nothing more.  Perfectly! </blockquote><br><br>  In Haskell, there is a special operator $, it is an application function operator.  He has the following type: <br><br><blockquote>  <font>(</font> <font color="#339933">$</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> a <font color="#339933">-&gt;</font> b </blockquote><br><br>  (In Haskell, character infix operators are equivalent to functions with the same name, enclosed in parentheses. So, writing f $ 2 is equivalent to writing ($) f 2. Operators are usually defined in their functional form - for convenience. Refer to the introductory materials on the language, if you want to know more. We will often use operators here.) <br><br>  Writing means that for any types a and b, this operator takes a function from a to b as the first argument, applies it to the second argument of type a, and returns the result of type b.  In functional languages, it is considered common to pass functions as arguments to other functions, so there are no problems here.  The following conclusions can be drawn: <br><br><blockquote>  f <font>2</font> <font color="#339933">-&gt;</font> returns <font>4</font> <br>  f <font color="#339933">$</font> <font>2</font> <font color="#339933">-&gt;</font> will also return <font>4</font> <br>  <font>(</font> <font color="#339933">$</font> <font>)</font> f <font>2</font> <font color="#339933">-&gt;</font> and here returns <font>4</font> </blockquote><br><br>  You see just three different ways to write the same thing. <br><br>  The $ operator is not really needed here, because it is technically easier to substitute an argument to a function in order to execute it.  But for the sake of interest, we can specify an operator of ‚Äúreverse application‚Äù, let's call it&gt; $&gt;, and let it take the same arguments in reverse order: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt; $&gt;</font> <font>)</font> <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> b <br>  x <font color="#339933">&gt; $&gt;</font> f <font color="#339933">=</font> f x <font color="#5d478b">- = the same as f $ x</font> </blockquote><br><br>  We can read this as "the operator takes the value of x, applies the function to it and returns the result."  If you are familiar with UNIX systems, you may have noticed that the unix conveyor (pipe, |) works in a similar way.  You give him some data, and he applies the following program to them.  We can work with operators of using functions when it is convenient, although usually we don‚Äôt use them at all, just substitute arguments to functions. <br><br>  Now that we have talked about the use of functions, the next important topic is the composition of functions.  And this <i>is a really</i> important topic.  Suppose that we have two functions f and g, as well as the x value of the following form: <br><br><blockquote>  x <font color="#339933">::</font> a <br>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> b <br>  g <font color="#339933">::</font> b <font color="#339933">-&gt;</font> c </blockquote><br><br>  where a, b, c are some types.  You could do the following with these x, f, and g: take x, apply the function f to it (get a value of type b), and then apply the function g to the result.  A value x of type a would be converted to a value of type b, and then what happened would be converted to a value of type c.  Writing to Haskell is easier than saying: <br><br><blockquote>  g <font>(</font> f x <font>)</font> </blockquote><br><br>  But it will work only if the types f and g are compatible, that is, if the result of the function f has the same type as the argument of the function g (in our case it is type b).  Applying one function to another can be interpreted in another way: we take two functions of f and g types, respectively, a -&gt; b and b -&gt; c, and create a third function of type a -&gt; c.  Applying it to the argument x, we get a result of type c.  This idea of ‚Äã‚Äãcombining two functions into a third is called a composition of functions.  Haskell even defines a simple function composition operator: <br><br><blockquote>  <font>(</font> <font color="#339933">.</font> <font>)</font> <font color="#339933">::</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  g <font color="#339933">.</font>  f <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> g <font>(</font> f x <font>)</font> </blockquote><br><br>  Here, the entry "\ x -&gt; ..." is used, which denotes a lambda expression (or, the same, an anonymous function) with one argument x.  This is how the composition operator takes two functions as arguments and returns a third.  And again: in function functions as arguments and as returned values, this is quite a common phenomenon that occurs at every step. <br><br>  Sometimes there is a nuisance with the composition operator when functions follow the wrong order.  But we can write a ‚Äúreverse composition operator‚Äù&gt;.&gt;: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;.&gt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  f <font color="#339933">&gt;.&gt;</font> g <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> g <font>(</font> f x <font>)</font> </blockquote><br><br>  We can even express it through the inverse operator of the function&gt; $&gt;: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;.&gt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  f <font color="#339933">&gt;.&gt;</font> g <font color="#339933">=</font> \ x <font color="#339933">-&gt;</font> x <font color="#339933">&gt; $&gt;</font> f <font color="#339933">&gt; $&gt;</font> g </blockquote><br><br>  Or even easier - through the composition operator: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;.&gt;</font> <font>)</font> <font color="#339933">::</font> <font>(</font> a <font color="#339933">-&gt;</font> b <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> b <font color="#339933">-&gt;</font> c <font>)</font> <font color="#339933">-&gt;</font> <font>(</font> a <font color="#339933">-&gt;</font> c <font>)</font> <br>  f <font color="#339933">&gt;.&gt;</font> g <font color="#339933">=</font> g <font color="#339933">.</font>  f </blockquote><br><br>  The operator signature&gt;.&gt; Is slightly clearer and shows what happens when functions are composited.  You take the functions f and g and calculate the new function.  Let it be called h.  By applying h to the value, you will get the same thing if you apply f to the value first and then g to the result.  This is what the composition of a function is - a way to make others from one function. <br><br>  Let's look at an example: <br><br><blockquote>  f <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <br>  f x <font color="#339933">=</font> <font>2</font> <font color="#339933">*</font> x <br><br>  g <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <br>  g y <font color="#339933">=</font> <font>3</font> <font color="#339933">+</font> y <br><br>  h <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <br>  h <font color="#339933">=</font> g <font color="#339933">.</font>  f <font color="#5d478b">- or the same: f&gt;.&gt; g</font> </blockquote><br><br>  What does the h function do here?  It takes an integer, multiplies it by 2 and adds 3. That is, it is equivalent to the following option: <br><br><blockquote>  h <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> <font color="#cccc00">Int</font> <br>  h x <font color="#339933">=</font> <font>3</font> <font color="#339933">+</font> <font>2</font> <font color="#339933">*</font> x </blockquote><br><br>  Composition of functions may not seem such a great thing - in reality, this is one of the main points of functional programming.  Composition allows you to associate existing functions in more complex functions, omitting manual work with arguments.  And instead of saying ‚Äúh is a function that is obtained by first calculating the function y = f (x) and then calculating the function h = g (y)‚Äù, we simply say ‚Äúh is the function that we get by first applying f and then g ".  Without intermediate entities, the code becomes shorter and higher level.  Imagine that you needed to call ten functions one by one.  If you were recording intermediate results, it would have resulted in something like this: <br><br><blockquote>  f11 x <font color="#339933">=</font> <br>  <font>let</font> <br>  x2 <font color="#339933">=</font> f1 x <br>  x3 <font color="#339933">=</font> f2 x2 <br>  x4 <font color="#339933">=</font> f3 x3 <br>  x5 <font color="#339933">=</font> f4 x4 <br>  x6 <font color="#339933">=</font> f5 x5 <br>  x7 <font color="#339933">=</font> f6 x6 <br>  x8 <font color="#339933">=</font> f7 x7 <br>  x9 <font color="#339933">=</font> f8 x8 <br>  x10 <font color="#339933">=</font> f9 x9 <br>  x11 <font color="#339933">=</font> f10 x10 <br>  <font>in</font> <br>  x11 </blockquote><br><br>  Very tiring, right?  And now let's look at the composition of functions: <br><br><blockquote>  f11 <font color="#339933">=</font> f10 <font color="#339933">.</font>  f9 <font color="#339933">.</font>  f8 <font color="#339933">.</font>  f7 <font color="#339933">.</font>  f6 <font color="#339933">.</font>  f5 <font color="#339933">.</font>  f4 <font color="#339933">.</font>  f3 <font color="#339933">.</font>  f2 <font color="#339933">.</font>  f1 </blockquote><br><br>  or, the same: <br><br><blockquote>  f11 <font color="#339933">=</font> f1 <font color="#339933">&gt;.&gt;</font> f2 <font color="#339933">&gt;.&gt;</font> f3 <font color="#339933">&gt;.&gt;</font> f4 <font color="#339933">&gt;.&gt;</font> f5 <font color="#339933">&gt;.&gt;</font> f6 <font color="#339933">&gt;.&gt;</font> f7 <font color="#339933">&gt;.&gt;</font> f8 <font color="#339933">&gt;.&gt;</font> f9 <font color="#339933">&gt;.&gt;</font> f10 </blockquote><br><br>  It is not only shorter, but also more intuitive.  (‚ÄúApplying f1, then f2, then f3, and so on, we get f11‚Äù).  By the way, this way of writing functions using composition and without arguments is called ‚Äúpointless style‚Äù.  The irony is that the ‚Äúdot‚Äù (.) Operator is very much used in the ‚Äúpointless‚Äù style - stronger than in the usual code.  It would be more correct to say ‚Äúargumentless style‚Äù rather than ‚Äúpointless‚Äù, since we omit the arguments of the functions. <br><br>  Topics of thinking, fixing the material: <br><ul><li>  Functions, application (application) of functions, composition of functions as fundamental concepts of functional programming. </li><li>  Operators for applying functions, for composition of functions, taking arguments in any order we want. </li></ul><br><br><h5>  Monadic functions, monadic values </h5><br>  So far everything that I have said, I hope, was pretty simple.  Now we turn to more complex things. <br><br>  Earlier, I said that the essence of monads is to generalize the concept of composition and the use of functions in the form of calculations, which are different from those in pure functions, and we even looked at some examples of ‚Äúimpurity‚Äù.  From the definition of monads, it follows that we get some "extended functions" that do something else besides simple calculations on the input value.  In a schematic pseudo-Haskell language, we could write these ‚Äúextended functions‚Äù like this: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [something else] -&gt; b</font> </blockquote><br><br>  where f is an extended function, a is the type of the argument, b is the type of the result, and ‚Äúsomething else‚Äù is specific to different computational concepts.  In Haskell, behind the words "concept of computation" lie, in particular, monads.  (We still do not know what it is, so for now take my word for it.) We can understand ‚Äúextended functions‚Äù as ‚Äúmonadic functions‚Äù.  This is not standard terminology, I call them so as to distinguish them from ordinary pure functions. <br><br>  Of course, the "- [something else] -&gt;" entry is invalid in Haskell;  we will see how it actually looks a bit later, and I hope it will be clear.  And now we will stick to these notations in order to compare the concepts of calculation described above;  we give each notion of computations names corresponding to the monads in Haskell. <br><br><ol><li>  Functions that perform input / output operations in the console or file.  The I / O operations correspond to the monad IO, so we write it this way: <br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [IO] -&gt; b</font> </blockquote>  (By the way, the IO monad has other uses, as we will see later.) </li><li>  Functions that can generate exceptions.  They correspond to several types of monads: <br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [error] -&gt; b</font> </blockquote></li><li>  Functions that interact with the global or local state.  This is the State monad: <br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [State s] -&gt; b</font> </blockquote></li><li>  Functions that can fail.  We are talking about the Maybe monad: <br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [Maybe] -&gt; b</font> </blockquote></li><li>  Functions that return multiple values ‚Äã‚Äãsimultaneously.  Monad list (list): <br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [list] -&gt; b</font> </blockquote></li></ol><br><br>  I wrote the word "list" with a small letter, because the lists in Haskell look a little different due to syntactic sugar, so we do not need a separate word for them. <br><br>  Later I will give examples for all these monads, and now consider the functions that perform input / output operations, that is, functions related to the IO monad.  We have a pseudo-record: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#5d478b">- [IO] -&gt; b</font> </blockquote><br><br>  One could say that f is a function from a to b, acting in the IO monad.  As I mentioned above, this is an invalid syntax.  In Haskell, you must wrap the monadic function of a monadic function in a type, surrounding it with an input or output parameter.  In principle, there would be two options for writing a monad function, like this: <br><br><blockquote>  f <font color="#339933">::</font> <font color="#cccc00">IO</font> a <font color="#339933">-&gt;</font> b </blockquote><br><br>  or <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> b </blockquote><br><br>  It turns out that Haskell uses the second form of writing for monadic functions: <br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m b </blockquote><br><br>  for any monad m;  for IO, for example.  (For hardcore players, I note that there is a notion of comonads, where each function has the form f :: ca -&gt; b for some comonad c. Let us leave this question for future articles.) <br><br>  Well, well, what really lies behind the entry "f :: a -&gt; mb"?  The record means that there is some ordinary (pure) function f, which takes a value of type a and returns a value of type mb (whatever they may be).  So, in Haskell, monad functions are <i>pure</i> functions with the monadic type of the return parameter.  In other words, a pure function takes the usual value and returns a monad.  And what does this mean? <br><br>  The ‚Äúmb‚Äù entry needs clarification.  b - This is some type.  m represents some monad.  However, what <i>exactly</i> is meant by m in Haskell?  In Haskell, ‚Äúm‚Äù must be <i>a type constructor</i> ‚Äî a special function on types: it takes an argument and returns a type.  This is not as strange as it may seem.  Consider the concept of a ‚Äúlist of integers,‚Äù the type of which in Haskell looks like [Int].  The ‚Äúlist of something‚Äù part can be understood as a type constructor that takes a certain type (Int) and returns another type (the list of integers, [Int]).  Square brackets are hard-wired in Haskell for labeling lists, but you can define your own type constructors.  Also, any polymorphic type has its own constructor.  One of the simplest polymorphic types is Maybe, defined as <br><br><blockquote>  <font>data</font> <font color="#cccc00">Maybe</font> a <font color="#339933">=</font> Nothing <font color="#339933">|</font>  Just a </blockquote><br><br>  It says here that Maybe is a type constructor that takes a type (called a) and produces a new type as an output value.  If we substitute a type Int, we get a new type Maybe Int, which is written as: <br><br><blockquote>  <font>data</font> <font color="#cccc00">Maybe</font> <font color="#cccc00">Int</font> <font color="#339933">=</font> Nothing <font color="#339933">|</font>  Just <font color="#cccc00">int</font> </blockquote><br><br>  Thus, Maybe is a function on types that maps one type to another. <br><br>  The monads, as they are in Haskell, are type constructors that wrap around the old type.  And the IO monad, in fact, is the type constructor with which types such as IO Bool, IO Int, IO Float, IO Char, IO String, and so on are produced.  These are all valid types in Haskell.  Similarly, the Maybe types Bool, Maybe Int, ... are constructed for the Maybe monad.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will call the types created by the monad constructor ‚Äúmonad types‚Äù. </font><font style="vertical-align: inherit;">IO Bool, Maybe Int, and so on are all monad types.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marginal notes: all monads in Haskell must be type constructors, but not all type constructors are monads. </font><font style="vertical-align: inherit;">As we will see, monads are required to be type constructors. </font><font style="vertical-align: inherit;">For monads, special operations must be defined, and they must satisfy several ‚Äúmonadic laws‚Äù.</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We come to a very important question: what do the values ‚Äã‚Äãrepresenting the monadic type do? </font><font style="vertical-align: inherit;">I call them monadic values. </font><font style="vertical-align: inherit;">For example, what is a value of type Maybe Int? </font><font style="vertical-align: inherit;">And IO Float - what is it? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have just come across what makes monads seem "difficult to understand." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's recap.</font></font><br><br><ol><li>     ¬´ ¬ª,    ,    ,             (  ,   ). </li><li>    ,   -       .  ¬´- ¬ª   /    ,  ,      ,        ,     .      ,     ¬´ ¬ª.       ,        ,    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Haskell, monadic functions are pure functions that convert an input value of some type into an output value of a special monadic type. </font><font style="vertical-align: inherit;">I call these values ‚Äã‚Äã"monadic."</font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let us reformulate the question: what can we say about the essence of ‚Äúmonadic meanings‚Äù? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The answer is: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They do not represent </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anything</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> really intuitive!</font></font></b>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intuitively, the concept of a monadic </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (one that does something else besides converting one data into another). The concept of "monadic </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at </font><i><font style="vertical-align: inherit;">all</font></i><font style="vertical-align: inherit;"> intuitive. Just in Haskell, it is customary to denote output values ‚Äã‚Äãof monadic functions. You will waste your time if you try to understand the monads through what </font><font style="vertical-align: inherit;">these monadic values </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are. Do not bother!</font></font> Not worth it! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, in the Haskell literature you can find two general ways to explain monadic values ‚Äã‚Äã(well, a bunch of silly ways that many guides sin): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. A monadic value of type ma (for some monad m) is a special kind of "action", which does something and returns a value of type a. The essence of the action depends on each particular monad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. A monadic value of type ma (for some monad m) is a container in which a value of type a is stored.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Studying monads through reflections on monadic values ‚Äã‚Äãis the wrong approach, and the right one is through reflections on monadic functions. </font><font style="vertical-align: inherit;">I will try to convince you that definition (1) even has some meaning. </font><font style="vertical-align: inherit;">But the definition (2), as we will see later, is the wrong way to study monads. </font><font style="vertical-align: inherit;">Most monads are not containers at all, although some may behave like containers too. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take our function, hopefully reasonably clear, as a starting point:</font></font><br><br><blockquote>  f <font color="#339933">::</font> a <font color="#339933">-&gt;</font> m b </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then the function fx, where x of type a, will be of type mb: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fx </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mb</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fx is now a ‚Äúmonadic value‚Äù, which is not entirely intuitive. </font><font style="vertical-align: inherit;">Consider another function:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt; </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt;</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gx </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g literally does the following: it takes a value of any type a and wraps it in a function, so you can get a result by passing an empty value to g. </font><font style="vertical-align: inherit;">({6}) An empty type and value are written to Haskell equally as parentheses (), and this is just a type / value that is not important to us. </font><font style="vertical-align: inherit;">(The word ‚Äúempty‚Äù means that this value is of no interest to us.) Let us give an example:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></font> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> h </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#5d478b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the number 10 will be calculated</font></font></font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, what do we get by inventing the function g (fx)? </font><font style="vertical-align: inherit;">Let's look at the types:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fx </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mb </font></font><font color="#5d478b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- see above</font></font></font> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt; </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt;</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fx </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt;</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mb</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the function g (fx) is of type () -&gt; m b. </font><font style="vertical-align: inherit;">In other words, it takes an empty value and returns a monadic value. </font><font style="vertical-align: inherit;">And if you look at it from the other side, it is a monadic function that converts an empty value (no matter which one) into a value of type b, while at the same time performing ‚Äúsomething else‚Äù. </font><font style="vertical-align: inherit;">(‚ÄúSomething else‚Äù depends on which monad is used.) There is some meaning to this.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is my thought. If you think that you need to understand what a monadic value is (type mb), it is best to consider it a monadic function of type () -&gt; mb, that is, a function that not only maps an empty value to a value of type b, but also does something something else. As if a value of type mb is a function of type () -&gt; mb, only written in a different way. Monadic values, so to speak, are ‚Äúsecret functions.‚Äù That is why they are often called ‚Äúactions‚Äù, and are associated with functions, and not quite functions. (Sometimes we even say ‚Äúperform an action‚Äù, which is similar to the use of a function.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few examples now do not hurt. I will use two Haskell I / O functions:</font></font><br><br><blockquote>  <font>getLine</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> <font color="#cccc00">String</font> <br>  <font>putStrLn</font> <font color="#339933">::</font> <font color="#cccc00">String</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLine is a ‚Äúfunction‚Äù (actually, a monadic value, also known as a ‚Äúmonadic action‚Äù), which reads a line of text from the console and somehow returns it. </font><font style="vertical-align: inherit;">putStrLn is a function (this time is really a function), which takes a string as an argument and prints it to the console, adding the end-of-line character. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think for a second about how the types of these functions look in traditional languages. </font><font style="vertical-align: inherit;">You can assume something like this:</font></font><br><br><blockquote> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLine </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt; </font></font></font> <font color="#cccc00"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String </font></font></font> <font color="#5d478b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- not in Haskell </font></font></font> <br> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putStrLn </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: </font></font></font> <font color="#cccc00"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-&gt; </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <font color="#5d478b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- not in Haskell</font></font></font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The getLine function is simple to understand: it takes an empty value (no matter what), somehow interacts with the console, fishes a string from there, and returns this line. </font><font style="vertical-align: inherit;">putStrLn takes a string as an argument, somehow interacts with the console (typing the string), and returns an empty value (no matter what). </font><font style="vertical-align: inherit;">Please note that the meaning of empty values ‚Äã‚Äãhas been reduced to ensure that functions are really functions, that is, they have an input and an output value. </font><font style="vertical-align: inherit;">Having got rid of (), we would have stayed with:</font></font><br><br><blockquote> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLine </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: </font></font></font> <font color="#cccc00"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String </font></font></font> <br> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putStrLn </font></font></font> <font color="#339933"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: </font></font></font> <font color="#cccc00"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String</font></font></font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and this is not true: getLine is not just a line; it must be called with an argument to return a string. Similarly, putStrLn is not just a string; because it needs a string argument, although it returns no matter what. In each case, empty values ‚Äã‚Äãare needed only to substitute the input or output value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But back to Haskell. We have:</font></font><br><br><blockquote>  <font>getLine</font> <font color="#339933">::</font> <font color="#cccc00">IO</font> <font color="#cccc00">String</font> <br>  <font>putStrLn</font> <font color="#339933">::</font> <font color="#cccc00">String</font> <font color="#339933">-&gt;</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function type putStrLn is not hard to understand. This is simply a monadic function inside the IO monad. The implication is that it takes a string to print, returns an empty value (no matter what), and does "something else." (In this case, it interacts with the console to print a line, which is what the IO monad allows you to do.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function type getLine is more difficult to understand. getLine - monadic value. But it's easier for us to think of it as a monadic function of the type () -&gt; IO String. Then it makes sense: it is a function that takes no matter what value and returns a string, interacting with the console in the process (that is, waiting for what you type in the console).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, in Haskell for this function there is no such type as () -&gt; IO String, but there is a type IO String. </font><font style="vertical-align: inherit;">It turns out that a monadic value is a monadic function with an implicit input argument of type (). </font><font style="vertical-align: inherit;">Many Haskell experts perceive it as an ‚Äúaction‚Äù. </font><font style="vertical-align: inherit;">When they say getLine is an ‚Äúaction‚Äù that performs some kind of I / O operation, they mean a monadic function. </font><font style="vertical-align: inherit;">When in the following articles we will discuss state monads, you are more aware of how something that looks like value can act as a function. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next article we will talk about two fundamental monadic operations: where they come from and what lies behind them.</font></font><br><br><h5>  Content </h5><br>  <a href="http://habrahabr.ru/blogs/Haskell/127556/">Part 1: The Basics</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128070/">Part 2: functions &gt;&gt; = and return</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128538/">Part 3: Monad Laws</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/129909/">Part 4: Maybe Monad and List Monad</a> <br><br><h5>  Notes </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> {1} In the original ‚Äúerror prone‚Äù - ‚Äúprone to bugs‚Äù, which could be translated somewhat differently. </font></font> ;) <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{3} This is called ‚Äúparametric polymorphism‚Äù. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{4} The author has in mind a set of objects of the same type as a result of functions. The problem, in his opinion, is that functions can return a different number of objects: from zero to n, - that is, the number of objects is not known in advance. In both C and Java, this problem is effectively solved by dynamic data types. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{5} In the original - a steady expression: "have our cake and eat it too." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{6} In the original - ‚Äúsingle‚Äù value, unit.</font></font><br><br><h5>  From translator </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links to other materials from the author, I have not found yet. </font><font style="vertical-align: inherit;">I will give my own. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. </font></font><a href="http://www.haskell.org/haskellwiki/Tutorials"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskell Tutorials</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The most comprehensive collection of links to manuals and articles on Haskell in English. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><a href="http://xgu.ru/wiki/Haskell"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskell on xgu.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - many useful links. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. </font></font><a href="http://fprog.ru/planet/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Russian Lambda Planet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - an excellent source of information on AF in Russian. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><a href="http://planet.haskell.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskell Planet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an even more excellent source of information on Haskell and OP, in English.</font></font></div><p>Source: <a href="https://habr.com/ru/post/127556/">https://habr.com/ru/post/127556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127548/index.html">A very, very, very, very secret project</a></li>
<li><a href="../127552/index.html">Build custom firmware OpenWRT</a></li>
<li><a href="../127553/index.html">Qt SDK v1.1.3 release</a></li>
<li><a href="../127554/index.html">Freedom Day in Omsk</a></li>
<li><a href="../127555/index.html">Qt Creator 2.3.0 Release</a></li>
<li><a href="../127557/index.html">Helios Kernel (convenient include in Javascript)</a></li>
<li><a href="../127558/index.html">Launch Skype without the annoying Main Page</a></li>
<li><a href="../127560/index.html">IFA 2011, day 2: Samsung Galaxy Note, NX200, MV800 and Lenovo U300s</a></li>
<li><a href="../127561/index.html">Jquery 1.6.3 released</a></li>
<li><a href="../127562/index.html">phpBB Constructor - its own phpBB build for everyone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>