<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Painless inoculation of object thinking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Or as simple as possible about the basic principles of OOP in Lazarus and FreePascal 
 Part I 


 There are two ways to study OOP (object-oriented pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Painless inoculation of object thinking</h1><div class="post__text post__text-html js-mediator-article"><h3>  Or as simple as possible about the basic principles of OOP in Lazarus and FreePascal </h3><br><h4>  Part I </h4><br><p>  There are two ways to study OOP (object-oriented programming): either read a hundred books that give a naked theory about class structure and principles of inheritance, polymorphism, encapsulation, but never learn anything, or stop worrying and try to learn new techniques in practice , by reworking, for example, ready-made codes, and better from scratch having made something simple, but beautiful. </p><br><p>  In all the books devoted to Pascal, delphi and lazarus (I found as many as two about the latter), a very similar part devoted to the PLO.  With these books, you can learn a lot about how much steeper the PLO of an outdated structural approach is, but you can never get enough skills to apply this in practice.  Of course, any programmer using visual IDEs already uses OOP by default, since all components and structural elements of a visual application are objects, but it is very difficult to transfer your own structures and abstractions to the OOP paradigm.  To understand all the charm and evaluate the opening prospects, I decided to make a small application that eventually turned into a simple screensaver.  At the same time he remembered the existence of trigonometry. <br><br>  The application will draw on the screen in random places fifty polar roses with different characteristics: size, color, number of petals.  Then they overwrite and draw new ones, etc.  Using the principles of structured programming, you can, of course, make an ordinary multidimensional array with a volume of 50 and keep all unique characteristics in it.  However, it is worth remembering that Pascal implies strong data typing, and, therefore, an array cannot consist of elements with different types.  It is possible to make an array of records (record), but why is it trivial, from recording to class is one step.  Here we will make it. </p><a name="habracut"></a><br><p>  An important principle of OOP is encapsulation.  This means that the class must hide within itself the entire logic of its work.  Our class, let's call it TPetal, has fields with different data types that define unique characteristics (center coordinates, size, coefficients for the polar rose equation, color), and methods of work.  All other elements of the program should only call these methods, without delving into the details of their implementation.  For now, the class should be able to draw and erase itself.  For a start, enough: </p><br><pre><code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TPetal }</span></span> TPetal = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> R, phi: double; X, Y, CX, CY: integer; Scale, RColor, PetalI: integer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean = FALSE)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  The class constructor has two parameters ‚Äî these are the boundaries of the canvas on which drawing will occur.  The implementation of the constructor is as follows: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; CX:=Random(Xmax); CY:=Random(Ymax); RColor:=<span class="hljs-number"><span class="hljs-number">1</span></span>+Random($FFFFFF); Scale:=<span class="hljs-number"><span class="hljs-number">2</span></span>+Random(<span class="hljs-number"><span class="hljs-number">12</span></span>); PetalI:=<span class="hljs-number"><span class="hljs-number">2</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  Any man-made class in Delphi / Lazarus is a direct or indirect descendant of the TObject class, and when creating objects of its class, it is necessary to call the parent's constructor so that the object is created correctly and the computer memory is allocated for it.  Therefore, at the beginning of our constructor, we call the parent constructor.  Then we randomly generate the unique characteristics of our polar rose: the coordinates of the center, the color, the scale factor and the coefficient determining the number of petals. </p><br><p>  Next is the drawing method.  As you can see, to draw or erase an object, I wrote a single method in which there is a second parameter and by default it is FALSE.  This is due to the fact that the draw and erase - the same operation, only the object is drawn in a random color, and erased - black.  When calling a method from a program without using the second parameter, the object is drawn, and when using the Erase parameter, the object is erased: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> phi:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Erase <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RColor:=clBlack; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Canvas <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> phi &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>*pi <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> R:=<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(PetalI*phi); X:=CX+Trunc(Scale*R*cos(phi)); Y:=CY-Trunc(Scale*R*sin(phi)); Pixels[X,Y]:=RColor; phi+=pi/<span class="hljs-number"><span class="hljs-number">1800</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  To draw petals, use <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25B7%25D0%25B0_(%25D0%25BF%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F)">the polar rose function</a> in the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582">polar coordinate system</a> : <br><br><img src="http://savepic.ru/13356628.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  where œÅ defines the radial coordinate, and œÜ - angular.  Œ± is the coefficient determining the length of the petals.  In our formula, the coefficient is immediately equal to 10, so that the roses do not turn out too small.  The angular coordinate of us runs from 0 to 2œÄ to capture all 360 degrees (while loop).  And after obtaining the radial coordinate, we calculate the Cartesian: x and y to draw this point on the canvas (once again marvel at how quickly modern computers perform calculations: inside the method there is a long cycle in which trigonometric calculations; remember how ‚Äúquickly‚Äù drew a similar Zx-spectrum).  The coefficient k in the formula (in the program - PetalI) determines the number of petals.  For the sake of simplicity, we use only whole numbers, so all the roses are hypotrochoid with non-overlapping petals. </p><br>  So, our class is implemented and it has all the necessary skills.  It's time to use.  In the main module of the application, first of all we need to declare an array of 50 objects of the TPetal class, then we throw Image and Timer onto the form, stretch the image to the entire form (Client), and set the response time to 100 milliseconds for the timer.  The timer method will be as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Form1: TForm1; Marg: boolean; Petals: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">49</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPetal; CurPetal: smallint; <span class="hljs-comment"><span class="hljs-comment">//----------------------------------------------------------------------------------- procedure TForm1.Timer1Timer(Sender: TObject); begin if not Marg then begin Petals[CurPetal]:=TPetal.Create(img.Width,img.Height); Petals[CurPetal].Draw(img.Canvas); CurPetal+=1; if CurPetal=50 then Marg:=TRUE; end else begin Petals[50-CurPetal].Draw(img.Canvas,TRUE); Petals[50-CurPetal].Free; CurPetal-=1; if CurPetal=0 then Marg:=FALSE; end; img.Canvas.TextOut(10,10,IntToStr(CurPetal)+' '); end;</span></span></code> </pre><br><p>  As you can see, I used a couple of global variables: CurPetal is an object counter, takes values ‚Äã‚Äãfrom 0 to 50 and back;  Marg is a counter boundary indicator, but everything should be very clear from the logic of the method. </p><br><p>  If we used the structured programming paradigm, then inside the timer handler we would have to independently initialize all the characteristics of the unique rose, draw it, and then erase it.  The method would have grown and would not be visual.  But now we have a class that does everything on its own - the class constructor immediately initializes all the characteristics, and the class method DrawPetal encapsulates all the computation and drawing logic, for which it only receives a pointer to the necessary object that has the Canvas property (and this is any form and almost any component).  The result is such a pretty screensaver: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6LyQOwH56uk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Exploring the next principle of OOP - inheritance, in the future it is possible to generate a descendant from the class TPetal, for example TOverlappingPetal, in which the polar rose will have overlapping petals.  To do this (for universalization purposes) in the ancestor class, you need to change the type of the PetalI field to a real number, and reload the constructor of the descendant so that this field can be initialized with a random fractional number according to the appropriate rules. </p><br><p>  I saved the files of the project in my <a href="https://bitbucket.org/java73/oop_test">bitbucket repository</a> , and for each stage I created a separate branch.  The example above can be found in the <a href="https://bitbucket.org/java73/oop_test/src/53dce9f459e91053e839b6173f04a9e0e57ff773%3Fat%3Dlesson1">lesson1 branch.</a> </p><br><h4>  Part II </h4><br><p>  Now I propose to do what we have stopped at.  So, we have a class TPetal, which is able to draw a polar rose with the number of petals from 3 to 16. However, all the objects we get with non-overlapping petals.  Meanwhile, if you look at the tablet below, we will see that there are more varieties of them.  The form is determined by the coefficient equal to n / d: </p><br><div style="text-align:center;"><img src="http://savepic.ru/13307479.png" alt="image"></div><br><p>  We breed a descendant of class TPetal: </p><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">{ TPetal }</span></span> TPetal = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> R, phi, PetalI: double; X, Y, CX, CY: integer; Scale, RColor: integer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean = FALSE)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TOverlappedPetal }</span></span> <span class="hljs-title"><span class="hljs-title">TOverlappedPetal</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> (TPetal) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean = FALSE)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  In the TOverlappedPetal class, we add our own constructor, which will act together with the ancestor's constructor, as well as the overloaded DrawPetal method (in fact, we will do without it at the end, but at the moment it is a good way to demonstrate method overloading in class heirs).  Here is the implementation: </p><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TOverlappedPetal }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TOverlappedPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create (Xmax,Ymax); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> PetalI=Round(PetalI) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> PetalI:=(<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>))/(<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TOverlappedPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> phi:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Erase <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RColor:=clBlack; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Canvas <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> phi &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>*pi <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> R:=<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(PetalI*phi); X:=CX+Trunc(Scale*R*cos(phi)); Y:=CY-Trunc(Scale*R*sin(phi)); Pixels[X,Y]:=RColor; phi+=pi/<span class="hljs-number"><span class="hljs-number">1800</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  It can be seen that the constructor of the TOverlappedPetal class uses the inherited method (inherited), but then changes the value of the PetalI field, which is used to set the coefficient that influences the shape of the rose.  When calculating the field, we exclude integers in order not to duplicate the forms already available to the ancestor of TPetal. </p><br><p>  Files of this example can be found in the <a href="https://bitbucket.org/java73/oop_test/src/7fda9abb76f4d1788806109cf437161c0fc97493%3Fat%3Dlesson2">lesson2</a> branch of the repository. </p><br>  Now, if you take a closer look, it becomes clear that even though we are programmers with OO-thinking, we still lack the capacity for tru programmers, since the implementation of DrawPetal methods in ancestor and descendant is almost identical, but this is the first in the degree caused by butthurt any refactoring guru is a repeating <s>cat</s> code. <br><br><img src="http://savepic.ru/13356630.jpg" alt="image"><br><br><p>  The difference of realizations is only in the coefficient multiplied by the number œÄ (2 or 12).  We take out this coefficient in a separate field of the ancestor TPetal (field K), remove the overload of the DrawPetal method now unnecessary and get the following structure of our classes: </p><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">{ TPetal }</span></span> TPetal = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> R, phi, PetalI: double; X, Y, K, CX, CY: integer; Scale, RColor: integer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean = FALSE)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TOverlappedPetal }</span></span> <span class="hljs-title"><span class="hljs-title">TOverlappedPetal</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> (TPetal) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  Although the descendant of TOverlappedPetal is now different from the ancestor of TPetal only by its constructor, we clearly and fully demonstrated all the principles of object-oriented programming: <br><br>  - <b>encapsulation</b> (all the work of the class is inside itself, external communication with the class - only a couple of methods and the transfer of the required minimum parameters); <br>  - <b>inheritance</b> (we have generated from a class of roses with non-overlapping petals a class of roses with overlapping petals); <br>  - minimally, <b>polymorphism</b> (we demonstrated overloading of methods - one name, but different implementation, but I plan to demonstrate the real power of polymorphism later). </p><br><p>  Here is the implementation of the classes as a result: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TOverlappedPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create (Xmax,Ymax); K:=<span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> PetalI=Round(PetalI) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> PetalI:=(<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>))/(<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TPetal }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; CX:=Random(Xmax); CY:=Random(Ymax); K:=<span class="hljs-number"><span class="hljs-number">2</span></span>; RColor:=<span class="hljs-number"><span class="hljs-number">1</span></span>+Random($FFFFF0); Scale:=<span class="hljs-number"><span class="hljs-number">2</span></span>+Random(<span class="hljs-number"><span class="hljs-number">12</span></span>); PetalI:=<span class="hljs-number"><span class="hljs-number">2</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> phi:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Erase <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RColor:=clBlack; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Canvas <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> phi &lt; K*pi <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> R:=<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(PetalI*phi); X:=CX+Trunc(Scale*R*cos(phi)); Y:=CY-Trunc(Scale*R*sin(phi)); Pixels[X,Y]:=RColor; phi+=pi/<span class="hljs-number"><span class="hljs-number">1800</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  I used new constructions like this: I supplemented the program with a second array of 50 objects of the TOverlappedPatel class, the second timer with a trigger period of 166 milliseconds added a second code to its handler, I wrote about the same code as the first timer.  Due to the delay between the timers, the screensaver visually even began to work a little nicer: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lXKgAi0MZVA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  How can I improve the program?  Just with the help of the third whale OOP - polymorphism.  Now our program does double work, and the processor is drenched in sweat, continuously making trigonometric calculations (well, someone like, probably).  Is it possible to create a single array of objects, but of different classes?  This will be the next part, and the code from the example above will be in the <a href="https://bitbucket.org/java73/oop_test/src/4aa222a3c905996558ef13756414435fe8ac2ee3%3Fat%3Dlesson2-1">lesson2-1</a> branch. </p><br><h4>  Part III </h4><br><p>  Usually in books on pascal, delphi and lazarus, a couple of pages are given to the description of polymorphism (at best), not counting code listings (not counting, because an understanding of these listings does not come from a couple of pages of text).  And since books on pascal are traditionally written for students, all the examples migrate from one publication to another and are associated with the description of the abstract class Man and his two heirs Student and Teacher.  Since I am neither one nor the other, I never managed to learn from these books about polymorphism.  Where it would be possible to put into practice the classes of Students and Teachers, in order to understand the essence of polymorphism, I did not invent it, so I had to comprehend everything again at random. <br><br>  I would call a very significant shortcoming of all these books that in the chapters on polymorphism the main question is ‚Äúhow‚Äù, although the primary question is ‚Äúwhy‚Äù, because the answer absorbs 99% of the whole essence of polymorphism.  I found this answer in the wonderful <a href="http://blogs.embarcadero.com/vsevolodleonov/2010/12/24/delphipoly-2/">article by Vsevolod Leonov</a> in the Embarcadero blogs (the current name of the owner is delphi).  And in general, polymorphism is represented, for example, as follows: there is a basic abstract class Feline, from which numerous heirs are spawned - Kotyk, Leopardik, Tigra, Lev, etc.  They all have similar properties, but the methods of their existence are different.  The meow method, for example, will be different for cat and tigers.  The base class ‚Äúplay‚Äù method at the cat is overlapped with the ‚Äúrub it on the legs‚Äù implementation, but at the left it is blocked by the ‚Äúdevour the hand‚Äù implementation.  However, all specific cats will be objects of the Feline class, and an inexperienced child will persistently call the "play" method in all felines without realizing the difference. <br><br>  Let us return to our practice of drawing <s>strange circles of</s> polar roses.  We stopped at the fact that complicated the work of the program, in parallel, creating two arrays of 50 objects of different classes and two timers with different response period, which have almost identical handlers: <br><br></p><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer1Timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Marg <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Petals[CurPetal]:=TPetal.Create(img.Width,img.Height); Petals[CurPetal].Draw(img.Canvas); CurPetal+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurPetal=<span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Marg:=TRUE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Petals[<span class="hljs-number"><span class="hljs-number">50</span></span>-CurPetal].Draw(img.Canvas,TRUE); Petals[<span class="hljs-number"><span class="hljs-number">50</span></span>-CurPetal].Free; CurPetal-=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurPetal=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Marg:=FALSE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; img.Canvas.TextOut(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,IntToStr(CurPetal)+<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> MargO <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OPetals[CurOPetal]:=TOverlappedPetal.Create(img.Width,img.Height); OPetals[CurOPetal].Draw(img.Canvas); CurOPetal+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurOPetal=<span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MargO:=TRUE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OPetals[<span class="hljs-number"><span class="hljs-number">50</span></span>-CurOPetal].Draw(img.Canvas,TRUE); OPetals[<span class="hljs-number"><span class="hljs-number">50</span></span>-CurOPetal].Free; CurOPetal-=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurOPetal=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MargO:=FALSE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; img.Canvas.TextOut(<span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,IntToStr(CurOPetal)+<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  Agree, the labor coder himself would have devoured the hand that wrote such a code "with a smell."  Since we decided to evolve into real programmers, we will solve the problem of getting rid of duplicate code and facilitating the work of the program. </p><br><p>  We now have two classes: TPetal and its descendant TOverlappedPetal.  However, this is a bit wrong and now we will correct the situation.  A polar rose with overlapping petals and a polar rose with non-overlapping petals should be classes of the same level, since from the point of view of the class theory they are equivalent.  Rising to a higher level of abstraction, we understand that the base class of the polar rose should be introduced, but from it we should generate the above two.  All that was in the two previous classes, we transfer to the base, so two descendants will differ only in the most necessary: </p><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">{ TCustomPetal }</span></span> TCustomPetal = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> R, phi, PetalI: double; X, Y, K, CX, CY: integer; Scale, RColor: integer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas: TCanvas; Erase: boolean = FALSE)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TPetal }</span></span> <span class="hljs-title"><span class="hljs-title">TPetal</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> (TCustomPetal) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TOverlappedPetal }</span></span> <span class="hljs-title"><span class="hljs-title">TOverlappedPetal</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> (TCustomPetal) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  Polymorphism is expressed in the fact that the implementation of descendants overlaps the constructor of the base class (the legend goes around the world that in the ancient versions of object pascal it was impossible to overlap class constructors, but I do not believe in it).  This technique is implemented using the reserved <b>virtual</b> and <b>override directives</b> .  By declaring the base class's create method virtual, we thereby make it clear that the implementation of the constructor can (but not necessarily) be overlapped in the children.  If we added (which is quite possible in our case, but it will complicate the code) to the <b>virtual</b> directive to the <b>abstract</b> directive, then this would mean that there will be no constructor implementation in the base class, but descendants are required to have such an implementation.  We will not make the base class constructor abstract, since its implementation has common features for posterity: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCustomPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; CX:=Random(Xmax); CY:=Random(Ymax); RColor:=<span class="hljs-number"><span class="hljs-number">1</span></span>+Random($FFFFF0); Scale:=<span class="hljs-number"><span class="hljs-number">2</span></span>+Random(<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TOverlappedPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create (Xmax,Ymax); K:=<span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> PetalI=Round(PetalI) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> PetalI:=(<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>))/(<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">6</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPetal</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Xmax, Ymax: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create (Xmax,Ymax); K:=<span class="hljs-number"><span class="hljs-number">2</span></span>; PetalI:=<span class="hljs-number"><span class="hljs-number">1</span></span>+Random(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  So, the constructor of the base class initializes the fields common to the descendants - the coordinates of the center, color and scale.  But the constructors of the descendants first call the constructor of the base class, and then carry out various initialization of the remaining fields - the coefficient for the angular coordinate and the coefficient determining the shape of the polar rose. </p><br><p>  Now look at how the main program code is simplified.  Instead of two arrays with fifty objects of different classes, we declare one array with objects of the TCustomPetal class, and rewrite the event handler in the timer as follows: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer1Timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Marg <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Random(<span class="hljs-number"><span class="hljs-number">2</span></span>)=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Petals[CurPetal]:=TPetal.Create(img.Width,img.Height) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Petals[CurPetal]:=TOverlappedPetal.Create(img.Width,img.Height); Petals[CurPetal].Draw(img.Canvas); CurPetal+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurPetal=<span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Marg:=TRUE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Petals[<span class="hljs-number"><span class="hljs-number">50</span></span>-CurPetal].Draw(img.Canvas,TRUE); Petals[<span class="hljs-number"><span class="hljs-number">50</span></span>-CurPetal].Free; CurPetal-=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurPetal=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Marg:=FALSE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; img.Canvas.TextOut(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,IntToStr(CurPetal)+<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  Work logic: a random number from 0 to 3 is taken and if it is 1, then the constructor of the descendant class TPetal is called for the next object from the CustomPetal array, otherwise the constructor of the descendant class TOverlappedPetal is called.  This is where polymorphism manifests itself: in spite of the fact that we have an array of objects of the same type of TCustomPetal, in fact objects are created with the type of descendant.  Since they have the same fields, the same methods - working with them is no different for a program.  We call the same DrawPetal method, but it behaves differently depending on the type of object.  You must admit that the program code has become much simpler and more visual (for those who, nevertheless, have tasted the OOP paradigm). </p><br><p>  A fresh example with changes is in the <a href="https://bitbucket.org/java73/oop_test/src/768f1013701a027e5c7ec234b017579ee87263ec%3Fat%3Dlesson3">lersson3</a> branch. </p><br><p>  How else can you improve the work?  For my taste, the more attractive is the option where 50 roses are not consistently drawn and rubbed, and when this happens continuously.  To do this, change the timer handler slightly, it is no longer associated with the PLO, but makes you wiggle your brains: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer1Timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned (Petals[CurPetal]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Petals[CurPetal].Draw(img.Canvas,TRUE); Petals[CurPetal].Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Random(<span class="hljs-number"><span class="hljs-number">2</span></span>)=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Petals[CurPetal]:=TPetal.Create(img.Width,img.Height) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Petals[CurPetal]:=TOverlappedPetal.Create(img.Width,img.Height); Petals[CurPetal].Draw(img.Canvas); CurPetal+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurPetal=PetalC <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CurPetal:=<span class="hljs-number"><span class="hljs-number">0</span></span>; img.Canvas.TextOut(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,IntToStr(CurPetal)+<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><p>  In order to further improve the program, I made the array of roses dynamic (Petals: array of TCustomPetal), and in the event handler when creating the form it is set to size - increased to 70, because 50 roses on the screen look too thin.  The logic of the timer handler has changed and at the same time simplified: CurPetal is our pointer to the current number of roses in the array, and it runs infinitely from 0 to 70 (since dynamic arrays always start numbering from zero).  First, it is checked whether the element of the Rose array with the CurPetal number was created earlier, and if so, it is overwritten and destroyed.  Then the same element with the same number is created in a random way.  The pointer to the array number is incremented, and if it becomes larger than the array boundary, it is reset (in our case, the last existing element of the array will be element number 69, since numbering, I recall, comes from zero).  The final view of the screensaver (at the top for clarity - the counter): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XCxXT4d9Oak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  The final project is in the <a href="https://bitbucket.org/java73/oop_test/src/426950d273c968438dc6396d3faaab5c5ec5c5c7%3Fat%3Dlesson3-1">lesson3-1</a> branch. </p><br><p>  <i>In the most recent version, the amount of computer memory used during operation was reduced to 7 with a small MB, whereas at the beginning the application was merry with 30 MB.</i>  <i>Using OOP, code refactoring and knowledge of mathematics allow you to make a beautiful and effective code, remember this always.</i> </p><br><br>  <b>PS update</b> <br>  In connection with practical comments, I corrected inaccuracies and glitches, and also transferred the work of the painter to the class TPetals (TQPEtals in another version), which ‚Äústeers‚Äù the whole process using the list of objects (TObjectList) or the queue of objects (TObjectQueue).  Now the timer method looks succinctly: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer1Timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> P.DrawNext; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  And also in the Draw method, the check when deleting a rose is turned on - whether other roses will not be ‚Äúspoiled‚Äù by black dots.  The latest project code is <a href="https://bitbucket.org/java73/oop_test/src/53b49463d9d5bb0c4a20d0b89bfaa98610849d30%3Fat%3Dlesson4-1">in the lesson4-1 (list)</a> and <a href="https://bitbucket.org/java73/oop_test/src/a32b2a6a41f6%3Fat%3Dlesson4-2">lesson 4-2 (queue)</a> <a href="https://bitbucket.org/java73/oop_test/src/53b49463d9d5bb0c4a20d0b89bfaa98610849d30%3Fat%3Dlesson4-1">branches</a> . <p></p></div><p>Source: <a href="https://habr.com/ru/post/325010/">https://habr.com/ru/post/325010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324996/index.html">Relevant connection - specific and universal attributes</a></li>
<li><a href="../324998/index.html">Clustering text documents according to semantic features (part two: model description)</a></li>
<li><a href="../325000/index.html">What you need to know to take cheaper tours: how it all works (and how to get a hotel in Sochi for 1116 rubles for 5 nights)</a></li>
<li><a href="../325006/index.html">15 VoIP Providers and 8 CRM: Compatibility Overview</a></li>
<li><a href="../325008/index.html">We try to do web-frontend on Rust (WebAssembly)</a></li>
<li><a href="../325012/index.html">Managing CST MWS with Matlab</a></li>
<li><a href="../325014/index.html">The company has more similar jobs</a></li>
<li><a href="../325016/index.html">Little tricks DirectX and HLSL</a></li>
<li><a href="../325018/index.html">‚ÄúSim-Sim, open!‚Äù, Or how to open a link via RemoteApp</a></li>
<li><a href="../325022/index.html">The new chip from Applied Micro is ready to contend with Intel Xeon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>