<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchrony: back to the future</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asynchrony ... Having heard this word, programmers start to shine eyes, breathing becomes shallow, hands begin to shake, voice stutters, the brain beg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchrony: back to the future</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/9e6/382/3979e63829a5f92aff5605016ff37596.jpg"></div><br clear="all">  Asynchrony ... Having heard this word, programmers start to shine eyes, breathing becomes shallow, hands begin to shake, voice stutters, the brain begins to draw numerous levels of abstraction ... Managers have eyes rounded, sounds become inarticulate, hands go into fists, and voice switches to overtone ... The only thing that unites them is a quick pulse.  Only the reasons for this are different: programmers rush into battle, and managers try to look into the crystal ball and realize the risks, start frantically thinking up the reasons for the increase in terms at times ... And only then, when most of the code is written, programmers begin to realize and learn all the bitterness of asynchrony, conducting endless nights in the debugger, desperately trying to figure out what is going on ... <br><br>  It is this picture that draws my inflamed imagination with the word ‚Äúasynchrony‚Äù.  Of course, all this is too emotional and not always true.  Is that so? .. Options are possible.  Some will say that ‚Äúwith the right approach, everything will work well‚Äù.  However, this can be said always and everywhere at every convenient and not convenient occasion.  But this does not get any better, bugs are not corrected, and insomnia does not go away. <br><br>  So what is asynchrony?  Why is she so attractive?  And most importantly: what is wrong with her? <br><a name="habracut"></a><br><h3>  Introduction </h3>  Asynchrony is currently quite a popular topic.  Enough to view the latest articles on Habr√© to see this.  Here you have an overview of various libraries, and the use of the Go language, and all sorts of asynchronous frameworks on JS, and much more. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Typically, asynchronous is used for network programming: all sorts of socketed sockets, reader-writers and other acceptors.  But there are still funny and interesting events, especially in the UI.  Here I will only consider networking.  However, as will be shown in the next article, the approach can be expanded and deepened into unknown distances. <br><br>  To be very specific, we will write a simple HTTP server, which sends a standard response to any request.  This is not to write a parser, because  He has exactly the same attitude to the topic of asynchrony, as the position of the stars to the character of a person (see astrology). <br><br><h3>  Synchronous single-threaded server </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/688/f49/134/688f4913476148d4276eda6579208143.jpg"></div><br clear="all">  Hm  Synchronous?  And what‚Äôs the point of being synchronous, the attentive reader will ask, opening an article about asynchrony.  Well, first of all, you need to start somewhere.  From something simple.  And secondly ... In short, I am the author, so it will be so.  And then you will find out why. <br><br>  In order not to write low-level platform-specific code, for all our purposes I will use a powerful asynchronous library called <abbr title="Portable networking, including sockets, timers, hostname resolution and socket iostreams.">boost.asio</abbr> .  Fortunately, the articles have already been written about her enough to be at least a little bit in the subject. <br><br>  Again, for better visibility and ‚Äúproduction‚Äù of the code, I will make wrappers for calling the appropriate functions from the <abbr title="Portable networking, including sockets, timers, hostname resolution and socket iostreams.">boost.asio</abbr> library.  Of course, someone might like wrappers like <code>boost::asio::ip::tcp::socket</code> or <code>boost::asio::ip::udp::resolver::iterator</code> , but the clarity and readability of the code is significantly reduced. <br><br>  So, the description of the socket and acceptor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Buffer; <span class="hljs-comment"><span class="hljs-comment">// forward declaration struct Acceptor; struct Socket { friend struct Acceptor; Socket(); Socket(Socket&amp;&amp; s); //     void read(Buffer&amp;); //    ,     void readSome(Buffer&amp;); //      until int readUntil(Buffer&amp;, const Buffer&amp; until); //     void write(const Buffer&amp;); //   void close(); private: boost::asio::ip::tcp::socket socket; }; struct Acceptor { //      explicit Acceptor(int port); //      void accept(Socket&amp; socket); private: boost::asio::ip::tcp::acceptor acceptor; };</span></span></code> </pre><br>  Nothing extra, just a server.  <code>Socket</code> allows you to write and read, including up to certain characters ( <code>readUntil</code> ).  <code>Acceptor</code> listens to the specified port and accepts connections. <br><br>  The implementation of this whole farm is shown below: <br><br><pre> <code class="cpp hljs">boost::asio::<span class="hljs-function"><span class="hljs-function">io_service&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> single&lt;boost::asio::io_service&gt;(); } Socket::Socket() : socket(service()) { } Socket::Socket(Socket&amp;&amp; s) : socket(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(s.socket)) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::read(Buffer&amp; buffer) { boost::asio::read(socket, boost::asio::buffer(&amp;buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], buffer.size())); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::readSome(Buffer&amp; buffer) { buffer.resize(socket.read_some(boost::asio::buffer(&amp;buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], buffer.size()))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> posEnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer&amp; b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer&amp; end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> posEnd &gt;= end.size() &amp;&amp; b.rfind(end, posEnd - end.size()) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Socket::readUntil(Buffer&amp; buffer, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Buffer&amp; until) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes = socket.read_some(boost::asio::buffer(&amp;buffer[offset], buffer.size() - offset)); offset += bytes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasEnd(offset, buffer, until)) { buffer.resize(offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset == buffer.size()) { LOG(<span class="hljs-string"><span class="hljs-string">"not enough size: "</span></span> &lt;&lt; buffer.size()); buffer.resize(buffer.size() * <span class="hljs-number"><span class="hljs-number">2</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::write(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Buffer&amp; buffer) { boost::asio::write(socket, boost::asio::buffer(&amp;buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], buffer.size())); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::close() { socket.close(); } Acceptor::Acceptor(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port) : acceptor(service(), boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Acceptor::accept(Socket&amp; socket) { acceptor.accept(socket.socket); }</code> </pre><br>  Here I used a singleton for <code>io_service</code> in order not to pass it to the socket each time explicitly in the input parameters.  And how can the user know that there should be some <code>io_service</code> ?  Therefore, I hid it away so that my eyes would not be cornered.  The rest, I believe, is quite understandable, with the exception, perhaps, of the <code>readUntil</code> function.  But its essence is simple: read the Baitik until a cherished ending is encountered.  This is needed just for HTTP, because  in advance, we, alas, cannot specify the size.  It is necessary to resize. <br><br>  Let's now write the long-awaited server.  Here he is: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HTTP_DELIM </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\r\n"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HTTP_DELIM_BODY HTTP_DELIM HTTP_DELIM </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   Buffer httpContent(const Buffer&amp; body) { std::ostringstream o; o &lt;&lt; "HTTP/1.1 200 Ok" HTTP_DELIM "Content-Type: text/html" HTTP_DELIM "Content-Length: " &lt;&lt; body.size() &lt;&lt; HTTP_DELIM_BODY &lt;&lt; body; return o.str(); } //  8800  ( 80 ?) Acceptor acceptor(8800); LOG("accepting"); while (true) { Socket socket; acceptor.accept(socket); try { LOG("accepted"); Buffer buffer(4000, 0); socket.readUntil(buffer, HTTP_DELIM_BODY); socket.write(httpContent("&lt;h1&gt;Hello sync singlethread!&lt;/h1&gt;")); socket.close(); } catch (std::exception&amp; e) { LOG("error: " &lt;&lt; e.what()); } }</span></span></span></span></code> </pre><br>  The server is ready! <br><br><h3>  Synchronous multithreaded server </h3>  The disadvantages of the previous server are obvious: <br><ol><li>  Unable to handle multiple connections at the same time. </li><li>  The client can reuse the connection for more efficient interaction, and we always close it. </li></ol><br>  Therefore, an idea appears to process the connections in another thread, while continuing to accept the following connections.  To do this, we need the function to create a new thread, which I suddenly call <code>go</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ()&gt; Handler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ LOG(<span class="hljs-string"><span class="hljs-string">"sync::go"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread([handler] { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { LOG(<span class="hljs-string"><span class="hljs-string">"new thread had been created"</span></span>); handler(); LOG(<span class="hljs-string"><span class="hljs-string">"thread was ended successfully"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { LOG(<span class="hljs-string"><span class="hljs-string">"thread was ended with error: "</span></span> &lt;&lt; e.what()); } }).detach(); }</code> </pre><br>  It is worth noting one funny thing: if you remove <code>detach()</code> , then guess what the program will do? <br><br><div class="spoiler">  <b class="spoiler_title">Answer:</b> <div class="spoiler_text">  Stupidly complete without any messages.  Thanks to the developers of the standard, keep it up! </div></div><br>  Now you can write the server: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8800</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"accepting"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Socket* toAccept = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Socket; acceptor.accept(*toAccept); LOG(<span class="hljs-string"><span class="hljs-string">"accepted"</span></span>); go([toAccept] { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Socket socket = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(*toAccept); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> toAccept; Buffer buffer; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { buffer.resize(<span class="hljs-number"><span class="hljs-number">4000</span></span>); socket.readUntil(buffer, HTTP_DELIM_BODY); socket.write(httpContent(<span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hello sync multithread!&lt;/h1&gt;"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { LOG(<span class="hljs-string"><span class="hljs-string">"error: "</span></span> &lt;&lt; e.what()); } }); }</code> </pre><br>  It would seem that all is well, but it was not there: on real tasks under load, this case falls quickly and then it is not wrung out.  Therefore, smart guys thought, thought, and decided to use asynchrony. <br><br><h3>  Asynchronous server </h3>  What is the problem with the previous approach?  And the fact that the threads instead of real work most of the time waiting for events from the network, otzhiraya resources.  I would like to somehow more efficiently use threads to perform useful work. <br><br>  Therefore, now I will implement similar functions, but asynchronously, using the proactor model.  What does this mean?  This means that we call the function for all operations and pass the callback, which will automatically be called at the end of the operation.  Those.  they will call us as soon as the operation is completed.  This differs from the reactor model when we have to call the necessary handlers ourselves, observing the state of operations.  A typical example of a reactor is epoll, kqueue, and various selects.  Example of proactor: <abbr title="I / O Completion Ports">IOCP</abbr> on Windows.  I will use a cross-platform proactor <abbr title="Portable networking, including sockets, timers, hostname resolution and socket iostreams.">boost.asio</abbr> . <br><br>  Asynchronous interfaces: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::system::error_code Error; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp;)&gt; IoHandler; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Acceptor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Socket</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Acceptor</span></span></span><span class="hljs-class">;</span></span> Socket(); Socket(Socket&amp;&amp;); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Buffer&amp;, IoHandler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Buffer&amp;, IoHandler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readUntil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Buffer&amp;, Buffer until, IoHandler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer&amp;, IoHandler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::asio::ip::tcp::socket socket; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Acceptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket&amp;, IoHandler)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::asio::ip::tcp::acceptor acceptor; };</code> </pre><br>  It is worth looking at some things: <br><ol><li>  Error handling is now significantly different.  In the case of a synchronous approach, we have 2 options: the return of the error code or the generation of an exception (this method was used at the beginning of the article).  In the case of an asynchronous call, there is exactly one way: passing the error through the handler.  Those.  not even through the result, but as the input parameter of the handler.  And if you want, you do not want - be kind enough to handle errors like in the good old days, when there were no exceptions: for every check.  But the most interesting, of course, is not that;  interesting is when an error occurred in the handler and must be processed.  Context recall is a favorite asynchronous programming task! </li><li>  For a uniform approach, I used <code>IoHandler</code> , which makes the code simpler and more versatile. </li></ol><br>  If you look closely, the only difference from synchronous functions is that asynchronous ones contain an additional handler as an input parameter. <br><br>  Well, it seems there is nothing terrible yet. <br><br>  Implementation: <br><br><pre> <code class="cpp hljs">Socket::Socket() : socket(service()) { } Socket::Socket(Socket&amp;&amp; s) : socket(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(s.socket)) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::read(Buffer&amp; buffer, IoHandler handler) { boost::asio::async_read(socket, boost::asio::buffer(&amp;buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], buffer.size()), [&amp;buffer, handler](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) { handler(error); }); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::readSome(Buffer&amp; buffer, IoHandler handler) { socket.async_read_some(boost::asio::buffer(&amp;buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], buffer.size()), [&amp;buffer, handler](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { buffer.resize(bytes); handler(error); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> posEnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer&amp; b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Buffer&amp; end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> posEnd &gt;= end.size() &amp;&amp; b.rfind(end, posEnd - end.size()) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::readUntil(Buffer&amp; buffer, Buffer until, IoHandler handler) { VERIFY(buffer.size() &gt;= until.size(), <span class="hljs-string"><span class="hljs-string">"Buffer size is smaller than expected"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntilHandler</span></span></span><span class="hljs-class"> {</span></span> UntilHandler(Socket&amp; socket_, Buffer&amp; buffer_, Buffer until_, IoHandler handler_) : offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), socket(socket_), buffer(buffer_), until(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(until_)), handler(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler_)) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LOG(<span class="hljs-string"><span class="hljs-string">"read at offset: "</span></span> &lt;&lt; offset); socket.socket.async_read_some(boost::asio::buffer(&amp;buffer[offset], buffer.size() - offset), *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Error&amp; error)</span></span></span><span class="hljs-function"> </span></span>{ handler(error); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Error&amp; error, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> complete(error); } offset += bytes; VERIFY(offset &lt;= buffer.size(), <span class="hljs-string"><span class="hljs-string">"Offset outside buffer size"</span></span>); LOG(<span class="hljs-string"><span class="hljs-string">"buffer: '"</span></span> &lt;&lt; buffer.substr(<span class="hljs-number"><span class="hljs-number">0</span></span>, offset) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"'"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasEnd(offset, buffer, until)) { <span class="hljs-comment"><span class="hljs-comment">// found end buffer.resize(offset); return complete(error); } if (offset == buffer.size()) { LOG("not enough size: " &lt;&lt; buffer.size()); buffer.resize(buffer.size() * 2); } read(); } private: size_t offset; Socket&amp; socket; Buffer&amp; buffer; Buffer until; IoHandler handler; }; UntilHandler(*this, buffer, std::move(until), std::move(handler)).read(); } void Socket::write(const Buffer&amp; buffer, IoHandler handler) { boost::asio::async_write(socket, boost::asio::buffer(&amp;buffer[0], buffer.size()), [&amp;buffer, handler](const Error&amp; error, std::size_t) { handler(error); }); } void Socket::close() { socket.close(); } Acceptor::Acceptor(int port) : acceptor(service(), boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)) { } void Acceptor::accept(Socket&amp; socket, IoHandler handler) { acceptor.async_accept(socket.socket, handler); }</span></span></code> </pre><br>  Here everything should be clear, except for the <code>readUntil</code> method.  In order to call asynchronous read on a socket several times, it is necessary to save the state.  For this purpose, a special class is <code>UntilHandler</code> , which saves the current state of the asynchronous operation.  A similar implementation can be found in <abbr title="Portable networking, including sockets, timers, hostname resolution and socket iostreams.">boost.asio</abbr> for various functions (for example, <code>boost::asio::read</code> ), which require several calls for simpler (but no less asynchronous) operations. <br><br>  In addition, you need to write an analogue <code>go</code> and dispatch: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadCount = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  Here you specify the handler that will be launched asynchronously in the thread pool and, in fact, the creation of a thread pool with subsequent dispatching. <br><br>  Here is the implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ LOG(<span class="hljs-string"><span class="hljs-string">"async::go"</span></span>); service().post(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ service().run(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threads = threadCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? threadCount : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency()); RLOG(<span class="hljs-string"><span class="hljs-string">"Threads: "</span></span> &lt;&lt; threads); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; threads; ++ i) sync::go(run); run(); }</code> </pre><br>  Here we use <code>sync::go</code> to create threads from the synchronous approach. <br><br>  Server implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8800</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"accepting"</span></span>); Handler accepting = [&amp;acceptor, &amp;accepting] { struct Connection { Buffer buffer; Socket socket; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ buffer.resize(<span class="hljs-number"><span class="hljs-number">4000</span></span>); socket.readUntil(buffer, HTTP_DELIM_BODY, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!error) { LOG(<span class="hljs-string"><span class="hljs-string">"error on reading: "</span></span> &lt;&lt; error.message()); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } LOG(<span class="hljs-string"><span class="hljs-string">"read"</span></span>); buffer = httpContent(<span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hello async!&lt;/h1&gt;"</span></span>); socket.write(buffer, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!error) { LOG(<span class="hljs-string"><span class="hljs-string">"error on writing: "</span></span> &lt;&lt; error.message()); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } LOG(<span class="hljs-string"><span class="hljs-string">"written"</span></span>); handling(); }); }); } }; Connection* conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Connection; acceptor.accept(conn-&gt;socket, [conn, &amp;accepting](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!error) { LOG(<span class="hljs-string"><span class="hljs-string">"error on accepting: "</span></span> &lt;&lt; error.message()); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> conn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } LOG(<span class="hljs-string"><span class="hljs-string">"accepted"</span></span>); conn-&gt;handling(); accepting(); }); }; accepting(); dispatch();</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8f/44f/577/b8f44f577ce67324882dc94800a19ad8.jpg"></div><br clear="all">  Here is a sheet.  With each new challenge, nesting lambda grows.  Usually, of course, they do not write this through lambdas, since  there are difficulties with looping: it is necessary to forward oneself in lambda in order to call oneself within oneself.  But nevertheless, the readability of the code will be about the same, i.e.  equally bad when compared with synchronous code. <br><br>  So, let's discuss the pros and cons of the asynchronous approach: <br><ol><li>  The undoubted advantage (and this, in fact, for the sake of which all these torments) is productivity.  And it is not just much higher, it is higher by orders of magnitude! </li><li>  Well, now the cons.  There is only one minus - complicated and complicated code, which is also difficult to debug. </li></ol><br>  Well, of course, if everything is written correctly and it immediately worked and without bugs.  But if this is not so ... In general, happy debugging, as they say in such cases.  And I have also considered a fairly simple example where you can track the sequence of calls.  With a slight complication of the processing scheme (for example, simultaneous reading and writing to sockets), the complexity of the code increases like a yeast, and the number of bugs starts to grow almost exponentially. <br><br>  So is the game worth the candle?  Is it worth doing asynchrony?  In fact, there is a solution - coroutines or <abbr title="Wikipedia: a program component that generalizes the concept of a subroutine, which additionally supports multiple input points (rather than one as a subroutine) and stop and continue execution while maintaining a certain position.">coroutines</abbr> . <br><br><h3>  Coroutines </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18a/ad4/dda/18aad4dda99815fc1ba476de911ccc73.jpg"></div><br clear="all">  So, what do we all want?  <s>Happiness, health, money bag.</s>  And you want a simple one: to use the advantages of asynchronous and synchronous approaches at the same time, i.e.  so that both the performance was asynchronous, and the simplicity as synchronous. <br><br>  It sounds great on paper.  Is it possible?  To answer the question we need a small introduction to coroutines. <br><br>  What are the usual procedures?  We are, therefore, in some place of performance, and here again, and called the procedure.  To call, the current place to return is first remembered, then the procedure is called, it is executed, completed and returns to the place from which it was called.  A coroutine is the same, only something else: it also returns control to the place from which it was called, but it <b>does not end</b> , but stops at a certain place from which it continues to work further when it is restarted.  Those.  it turns out a kind of ping-pong: the caller throws the ball, the coroutine catches it, runs to another place, throws it back, the caller also does something (crosses) and again throws the coroutines back to the previous place.  And this happens until the coroutine is completed.  In general, we can say that the procedure is a special case of the coroutine. <br><br>  How can this be used now for our asynchronous tasks?  Well here it suggests that the coroutine retains a certain execution context, which is extremely important for asynchrony.  This is what I will use: if the coroutine needs to perform an asynchronous operation, then I will simply call the asynchronous method and exit the coroutine.  And the handler upon completion of the asynchronous operation will simply continue execution of our coroutine from the place of the last call of that same asynchronous operation.  Those.  all the dirty work of preserving the context falls on the shoulders of the coroutine implementation. <br><br>  And this is where the problems begin.  The fact is that coroutine support on the side of languages ‚Äã‚Äãand processors is a matter of bygone days.  To implement the execution context switching, today it is necessary to do a lot of operations: save register states, switch the stack, and fill in some service fields for the execution environment to work correctly (for example, for exceptions, <abbr title="Thread local storage">TLS</abbr> , etc.).  Moreover, the implementation depends not only on the processor architecture, but also on the compiler and the operating system.  It sounds like the last nail in the coffin lid ... <br><br>  Fortunately, there is <abbr title="Context switching library.">boost.context</abbr> , which implements everything that is needed to support a specific platform.  Everything is written in assembler, in the best traditions.  You can, of course, use <abbr title="Coroutine library.">boost.coroutine</abbr> , but why, when there is <abbr title="Context switching library.">boost.context</abbr> ?  More hell and bane! <br><br><h4>  Implementation of coroutines </h4>  So, for our purposes, we write our coroutines.  The interface will be: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    void yield(); //  ,      bool isInsideCoro(); //  struct Coro { //   ,   friend void yield(); Coro(); //     Coro(Handler); //   ~Coro(); //   void start(Handler); //   (    yield) void resume(); //  ,     bool isStarted() const; private: ... };</span></span></code> </pre><br>  Here is a simple interface.  Well, immediately use option: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'2'</span></span>; yield(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'4'</span></span>; }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-function"><span class="hljs-function">Coro </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coro)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'3'</span></span>; c.resume(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'5'</span></span>;</code> </pre><br>  Must display on screen: <br><br><blockquote><pre> 12345
</pre></blockquote><br>  Let's start with the <code>start</code> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Coro::start(Handler handler) { VERIFY(!isStarted(), <span class="hljs-string"><span class="hljs-string">"Trying to start already started coro"</span></span>); context = boost::context::make_fcontext(&amp;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.back(), <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.size(), &amp;starterWrapper0); jump0(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;(&amp;handler)); }</code> </pre><br>  Here, <code>boost::context::make_fcontext</code> creates a context for us and passes the <code>starterWrapper0</code> static method as a starting function: <br><br><pre> <code class="cpp hljs">TLS Coro* t_coro; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Coro::starterWrapper0(<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> p) { t_coro-&gt;starter0(p); }</code> </pre><br>  which simply redirects to the <code>starter0</code> method, retrieving the current <code>Coro</code> instance from <abbr title="Thread local storage">TLS</abbr> .  All the magic of context switching is in the private <code>jump0</code> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Coro::jump0(<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> p) { Coro* old = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(old, t_coro); running = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; boost::context::jump_fcontext(&amp;savedContext, context, p); running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(old, t_coro); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exc != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception_ptr()) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::rethrow_exception(exc); }</code> </pre><br>  Here we replace the old <abbr title="Thread local storage">TLS</abbr> <code>t_coro</code> value <code>t_coro</code> a new one (needed for recursive switching between several coroutines), set all sorts of flags and switch the context using <code>boost::context::jump_fcontext</code> .  After completion, we restore the old values ‚Äã‚Äãand throw exceptions into the calling function. <br><br>  Now we look at the private method <code>starter0</code> , which starts the necessary handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Coro::starter0(<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> p) { started = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Handler handler = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;Handler*&gt;(p)); handler(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { exc = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::current_exception(); } started = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; yield0(); }</code> </pre><br>  I will note one interesting point: if you do not save the handler inside the coroutine (before calling it), then the next time you return the program can safely fall.  This is due to the fact that, generally speaking, the handler stores in itself some state that can be destroyed at some point. <br><br>  Now it remains to consider the remaining functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     void yield() { VERIFY(isInsideCoro(), "yield() outside coro"); t_coro-&gt;yield0(); } //  ,      bool isInsideCoro() { return t_coro != nullptr; } //    yield void Coro::resume() { VERIFY(started, "Cannot resume: not started"); VERIFY(!running, "Cannot resume: in running state"); jump0(); } //  ,      bool Coro::isStarted() const { return started || running; } //     void Coro::yield0() { boost::context::jump_fcontext(context, &amp;savedContext, 0); }</span></span></code> </pre><br><h3>  Synca: async vice versa </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/c6a/39a/c08c6a39a51298efba0ab76b5fe4339a.jpg"></div><br clear="all">  Now it is the turn to realize asynchrony on coroutines.  A trivial implementation is shown in the following diagram: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d36/5b1/c48/d365b1c48d016e5ca4445e0e9f9a7cb1.png"></div><br clear="all">  Here, a coroutine is created, then the coroutine starts an asynchronous operation and completes its work using the <code>yield()</code> function.  Upon completion of the operation, the coroutine continues its work by calling the <code>resume()</code> method. <br><br>  And everything would be fine if it were not for the notorious multithreading.  As always happens, it introduces some turbulence, so the above approach will not work properly, as the following diagram illustrates: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72b/e36/f04/72be36f049acef168f4ba9eccd3df250.png"></div><br clear="all">  Those.  immediately after the operation sheduling, a handler can be called who will continue execution until exit from the coroutine.  This, of course, was not part of our plans.  Therefore it is necessary to complicate the sequence: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c29/d89/176/c29d891763e7a61c151597acaf8f11d1.png"></div><br clear="all">  The difference lies in the fact that we do not start scheduling in the coroutine, but outside it, which excludes the possibility described above.  At the same time, the continuation of the coroutine can occur in another thread, which is quite normal behavior. For this, the coroutines are designed to be able to hang around to and fro while keeping the execution context. <br><br><div class="spoiler">  <b class="spoiler_title">Small note</b> <div class="spoiler_text"> ,   <abbr title="Portable networking, including sockets, timers, hostname resolution and socket iostreams.">boost.asio</abbr>    .       <code>io_service::strand</code> ,     .      - , ‚Ä¶      ,   ,   . </div></div><br><h4>  Implementation </h4>     <code>go</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ LOG(<span class="hljs-string"><span class="hljs-string">"synca::go"</span></span>); async::go([handler] { coro::Coro* coro = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> coro::Coro(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)); onCoroComplete(coro); }); }</code> </pre><br>              .      <code>onCoroComplete</code> ,  ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(coro::Coro*)&gt; CoroHandler; TLS CoroHandler* t_deferHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCoroComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coro::Coro* coro)</span></span></span><span class="hljs-function"> </span></span>{ VERIFY(!coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"Complete inside coro"</span></span>); VERIFY(coro-&gt;isStarted() == (t_deferHandler != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), <span class="hljs-string"><span class="hljs-string">"Unexpected condition in defer/started state"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_deferHandler != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { LOG(<span class="hljs-string"><span class="hljs-string">"invoking defer handler"</span></span>); (*t_deferHandler)(coro); t_deferHandler = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"completed defer handler"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LOG(<span class="hljs-string"><span class="hljs-string">"nothing to do, deleting coro"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> coro; } }</code> </pre><br>  : ,   -  .   ‚Äî  ,  ‚Äî         . <br><br>  :    <code>t_deferHandler</code> ?   : <br><br><pre> <code class="cpp hljs">TLS <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error* t_error; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_error) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> boost::system::system_error(*t_error, <span class="hljs-string"><span class="hljs-string">"synca"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CoroHandler handler)</span></span></span><span class="hljs-function"> </span></span>{ VERIFY(coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"defer() outside coro"</span></span>); VERIFY(t_deferHandler == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"There is unexecuted defer handler"</span></span>); t_deferHandler = &amp;handler; coro::yield(); handleError(); }</code> </pre><br>      .    ,     , ..  .   ,        ( <code>coro::yield</code> ),     <code>onCoroComplete</code> ,     <i></i> .     <code>defer</code>   <code>Socket::accept</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coro::Coro* coro, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Error&amp; error)</span></span></span><span class="hljs-function"> </span></span>{ LOG(<span class="hljs-string"><span class="hljs-string">"async completed, coro: "</span></span> &lt;&lt; coro &lt;&lt; <span class="hljs-string"><span class="hljs-string">", error: "</span></span> &lt;&lt; error.message()); VERIFY(coro != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"Coro is null"</span></span>); VERIFY(!coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"Completion inside coro"</span></span>); t_error = error ? &amp;error : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; coro-&gt;resume(); LOG(<span class="hljs-string"><span class="hljs-string">"after resume"</span></span>); onCoroComplete(coro); } async::<span class="hljs-function"><span class="hljs-function">IoHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleteHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coro::Coro* coro)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [coro](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error) { onComplete(coro, error); }; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Acceptor::accept(Socket&amp; socket) { VERIFY(coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"accept must be called inside coro"</span></span>); defer([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;socket](coro::Coro* coro) { VERIFY(!coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"accept completion must be called outside coro"</span></span>); acceptor.accept(socket.socket, onCompleteHandler(coro)); LOG(<span class="hljs-string"><span class="hljs-string">"accept scheduled"</span></span>); }); }</code> </pre><br> <code>onCompleteHandler</code>   ,     .      <code>t_error</code> ,          (.  <code>handleError</code>  <code>defer</code> ),      <code>coro-&gt;resume()</code> , ..    <code>defer</code>    <code>yield()</code> .         : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65e/762/4c4/65e7624c4f0785557becf70836190df2.png"></div><br clear="all">    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::readSome(Buffer&amp; buffer) { VERIFY(coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"readSome must be called inside coro"</span></span>); defer([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;buffer](coro::Coro* coro) { VERIFY(!coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"readSome completion must be called outside coro"</span></span>); socket.readSome(buffer, onCompleteHandler(coro)); LOG(<span class="hljs-string"><span class="hljs-string">"readSome scheduled"</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::readUntil(Buffer&amp; buffer, Buffer until) { VERIFY(coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"readUntil must be called inside coro"</span></span>); defer([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;buffer, until](coro::Coro* coro) { VERIFY(!coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"readUntil completion must be called outside coro"</span></span>); socket.readUntil(buffer, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(until), onCompleteHandler(coro)); LOG(<span class="hljs-string"><span class="hljs-string">"readUntil scheduled"</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Socket::write(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Buffer&amp; buffer) { VERIFY(coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"write must be called inside coro"</span></span>); defer([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;buffer](coro::Coro* coro) { VERIFY(!coro::isInsideCoro(), <span class="hljs-string"><span class="hljs-string">"write completion must be called outside coro"</span></span>); socket.write(buffer, onCompleteHandler(coro)); LOG(<span class="hljs-string"><span class="hljs-string">"write scheduled"</span></span>); }); }</code> </pre><br>         <code>async::Socket</code>  <code>async::Acceptor</code> ,     . <br><br><h4>  Using </h4>     .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8800</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"accepting"</span></span>); go([&amp;acceptor] { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Socket* toAccept = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Socket; acceptor.accept(*toAccept); LOG(<span class="hljs-string"><span class="hljs-string">"accepted"</span></span>); go([toAccept] { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Socket socket = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(*toAccept); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> toAccept; Buffer buffer; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { buffer.resize(<span class="hljs-number"><span class="hljs-number">4000</span></span>); socket.readUntil(buffer, HTTP_DELIM_BODY); socket.write(httpContent(<span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hello synca!&lt;/h1&gt;"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { LOG(<span class="hljs-string"><span class="hljs-string">"error: "</span></span> &lt;&lt; e.what()); } }); } }); dispatch();</code> </pre><br>   - ‚Ä¶ !      : <br><table><tbody><tr><th> <code>sync</code> </th> <th> <code>synca</code> </th> </tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8800</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"accepting"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Socket* toAccept = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Socket; acceptor.accept(*toAccept); LOG(<span class="hljs-string"><span class="hljs-string">"accepted"</span></span>); go([toAccept] { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Socket socket = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(*toAccept); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> toAccept; Buffer buffer; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { buffer.resize(<span class="hljs-number"><span class="hljs-number">4000</span></span>); socket.readUntil(buffer, HTTP_DELIM_BODY); socket.write(httpContent( <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hello sync multithread!&lt;/h1&gt;"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { LOG(<span class="hljs-string"><span class="hljs-string">"error: "</span></span> &lt;&lt; e.what()); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8800</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"accepting"</span></span>); go([&amp;acceptor] { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Socket* toAccept = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Socket; acceptor.accept(*toAccept); LOG(<span class="hljs-string"><span class="hljs-string">"accepted"</span></span>); go([toAccept] { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Socket socket = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(*toAccept); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> toAccept; Buffer buffer; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { buffer.resize(<span class="hljs-number"><span class="hljs-number">4000</span></span>); socket.readUntil(buffer, HTTP_DELIM_BODY); socket.write(httpContent( <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hello synca!&lt;/h1&gt;"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { LOG(<span class="hljs-string"><span class="hljs-string">"error: "</span></span> &lt;&lt; e.what()); } }); } }); dispatch();</code> </pre></td></tr></tbody></table>    :         ,    <code>dispatch</code> . ,   ,        :            ,  <code>go</code> ,   <code>dispatch</code>       . <br><br>       :      ,       .      :      ,     , ..     . <br><br><h4>  </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/aaf/fae/e76aaffaef4e682ce6f2ab5ea65e37ea.jpg"></div><br clear="all">       . ,     : ,  ,   ,         .     <code>goAccept</code> : <br><br><pre> <code class="cpp hljs">async::<span class="hljs-function"><span class="hljs-function">IoHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleteGoHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(coro::Coro* coro, Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [coro, handler](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Error&amp; error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) go(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)); onComplete(coro, error); }; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Acceptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Socket&amp;)&gt; Handler; <span class="hljs-comment"><span class="hljs-comment">// ... }; void Acceptor::goAccept(Handler handler) { VERIFY(coro::isInsideCoro(), "goAccept must be called inside coro"); defer([this, handler](coro::Coro* coro) { VERIFY(!coro::isInsideCoro(), "goAccept completion must be called outside coro"); Socket* socket = new Socket; acceptor.accept(socket-&gt;socket, onCompleteGoHandler(coro, [socket, handler] { Socket s = std::move(*socket); delete socket; handler(s); })); LOG("accept scheduled"); }); }</span></span></code> </pre><br>       : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8800</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; LOG(<span class="hljs-string"><span class="hljs-string">"accepting"</span></span>); go([&amp;acceptor] { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { acceptor.goAccept([](Socket&amp; socket) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Buffer buffer; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { buffer.resize(<span class="hljs-number"><span class="hljs-number">4000</span></span>); socket.readUntil(buffer, HTTP_DELIM_BODY); socket.write(httpContent(<span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hello synca!&lt;/h1&gt;"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { LOG(<span class="hljs-string"><span class="hljs-string">"error: "</span></span> &lt;&lt; e.what()); } }); } }); dispatch();</code> </pre><br>       . <br><br><h3>  1.    ? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/3e8/2c1/56f3e82c1426375a52319a6855b85529.jpg"></div><br clear="all"> ,       ,        /    . <br><br>       ,   ,     (!!!)     ,  .     : <br><ol><li>      30K RPS (.. 30    ). </li><li>       <code>async</code>  <code>synca</code> . </li></ol><br>    : <br><table><tbody><tr><th>  Method </th><th>     </th><th>   </th><th>    </th></tr><tr><td>  async </td><td>  30,000 </td><td>  one </td><td> 75¬±5% </td></tr><tr><td> synca </td><td>  30,000 </td><td>  one </td><td> 80¬±5% </td></tr></tbody></table> ,            .          . <br><br>    ,        ,        (      , ..     )    .     ,     HTTP ,   ,          -   ,    ,  <b>     </b> . <br><br><h3>  2.  .          ? </h3><br><h4> .        . </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c98/f48/fca/c98f48fca9f4db9509980974baa0703c.jpg"></div><br clear="all"> <b>.</b> <br>   ,    .      , ..     .   -      .       : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    async(..., handler); //   </span></span></code> </pre><br>  ,       : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    async(..., handler);</span></span></code> </pre><br>        : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    synca(...); handler();</span></span></code> </pre><br>  Those.  <code>synca</code>      <code>async</code> ,         ,     <code>handler()</code> .      . <br><br>      ,        .   : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    go { async(..., handler); } //   </span></span></code> </pre><br>  ,         <code>async</code>  <code>go</code> , : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    go { synca(...); handler(); } //   </span></span></code> </pre><br>  Those.      .                  . <b>...</b> <br><br><h3>  findings </h3>        . ,     ,          . ,         :        . <br><br>         ,       ! <br><br>     ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/0a4/386/5270a4386ae4ca3c3594e4f4db8476bf.jpg"></div><br clear="all"> PS     : <a href="https://bitbucket.org/gridem/synca">bitbucket:gridem/synca</a> </div><p>Source: <a href="https://habr.com/ru/post/201826/">https://habr.com/ru/post/201826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201814/index.html">Implementation of corporate Linux in PrivatBank</a></li>
<li><a href="../201816/index.html">Automatic secondary DNS is no longer a problem</a></li>
<li><a href="../201818/index.html">All domestic projects on Kickstarter in one post. //Part 2</a></li>
<li><a href="../201820/index.html">Ciklum Speakers' Corner with Ahmed Sidki for the first time in Kiev on November 27</a></li>
<li><a href="../201824/index.html">Ciklum Kiev Java Saturday with guests from England and unusual completion of the presentation program</a></li>
<li><a href="../201828/index.html">jor1k: Linux in a web-enabled browser</a></li>
<li><a href="../201830/index.html">Power of Community: New Attack Scenarios for PCS or Choo Choo PWN in Korea</a></li>
<li><a href="../201832/index.html">Make your AngularJS: Part 1 - Scope and Digest</a></li>
<li><a href="../201834/index.html">A Tale of the Present PRINTRBOT (Part 3: Trial by Fire)</a></li>
<li><a href="../201836/index.html">PDF generation from a WPF application ‚Äúfor everyone, for nothing, and let no one leave offended‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>