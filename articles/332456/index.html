<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Running AMP applications on Cyclone V SoC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you read my previous article , you are probably interested in this topic and you want to learn more. In this article we will consider a very privat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Running AMP applications on Cyclone V SoC</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b16/26b/e30/b1626be30781282607cfeae2e21d121d.jpg" alt="image"><br>  If you read my previous <a href="https://habrahabr.ru/post/330974/">article</a> , you are probably interested in this topic and you want to learn more.  In this article we will consider a very private, not simple, but no less necessary task of running two different Baremetal applications on different SoC Cyclone V cores. In fact, such systems are called AMP - asyncronus multi-processing.  I almost forgot to say that in Russian you will not find another more correct and detailed guide to the creation of such systems, so read! <a name="habracut"></a><br><br><h2>  Introduction </h2><br>  It is understood that the reader is already familiar with the standard libraries of Altera HW Manager and SoCAL.  But still say a few words about them.  SoC Abstraction Layer (SoCAL) contains low-level functions for easy setting / reading of bits, bytes, words for direct control of HPS registers.  Hardware Manager (HW Manager) is a set of more complex functions for writing baremetal applications, drivers, BPS and others.  Be sure to read the documentation at this address / ip / altera / hps / altera_hps / doc / or in .h files. <br><br><h2>  Download program </h2><br>  First you need to remember how the program loads, in my first article, not much was said about it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  The HPS download process has several stages, try to understand them ... <br><br>  Immediately after switching on, the code located directly on the Flash memory Cortex-A9 called BootRom is executed.  You cannot change it or even view its content.  It serves for the initial initialization and in the next stage transfers the boot process to the SSBL (Second Stage Boot Loader called Preloader for short).  What you need to know to understand the process is that the BootRom code, in the first place, selects the Preloader boot source, is guided by the BSEL external physical pins ... <br><br>  And so, after the BootRom code has been executed, the Preloader, which is required to configure Clock, SDRAM and other things, starts loading.  After the program starts to run ... </blockquote><br>  Let's take a closer look at what happens after downloading the Preloader  Actually after this, the program starts to run, but not immediately from the main function main ().  Before it, the _main () function is executed, the main task of which is the application mapping to the addresses in memory specified in the scatter file.  This means that the application's entry point is not at the beginning of the main () function code we are writing, but in the _main () service function, invisible when writing code, that appears before main () during the compilation process.  Perhaps everyone already knows this, but at that time it was a revelation for me, I thought that the entry point is at the beginning of main (). <br><br><h2>  Core work </h2><br>  All described processes are always performed on the first cpu0 core, the second core is always in a reset state.  To start the second core, you need to reset the corresponding bit of the MPUMODRST register in the RSTMGR group.  Well, set the starting address of the PC in the register CPU1STARTADDR in the group SYSMGR.  However, after turning on the PC, cpu1 is 0x0.  After running Preloader at address 0x0, there is nothing useful, so before running cpu1 you need to place the BootROM code in 0x0.  I spent a lot of time to find out that only from the BootROM code is reading the register CPU1STARTADDR, after which the PC is set to the desired value.  As it turned out, placing this code is not as trivial as it seems at first glance.  For this, we need the alt_addr_space_remap function from the HW manager, from the alt_address_space.h file. <br><br><pre><code class="hljs lisp">alt_addr_space_remap(<span class="hljs-name"><span class="hljs-name">ALT_ADDR_SPACE_MPU_ZERO_AT_BOOTROM</span></span>, ALT_ADDR_SPACE_NONMPU_ZERO_AT_SDRAM, ALT_ADDR_SPACE_H2F_ACCESSIBLE, ALT_ADDR_SPACE_LWH2F_ACCESSIBLE)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Do not rush to rejoice, this is not enough for the BootROM to be at 0x0.  You must configure the L2 cache address filter.  In the description of the alt_addr_space_remap function, it is said if you need to locate the BootROM at 0x0, then configure this filter as follows, placing the code after the function. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr_filt_start; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr_filt_end; alt_l2_addr_filter_cfg_get(&amp;addr_filt_start, &amp;addr_filt_end); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr_filt_start != L2_CACHE_ADDR_FILTERING_START_RESET) { alt_l2_addr_filter_cfg_set(L2_CACHE_ADDR_FILTERING_START_RESET, addr_filt_end); }</code> </pre> <br>  Only after that we set the starting address and we can start the kernel. <br><br><pre> <code class="hljs sql">alt_write_word(ALT_SYSMGR_ROMCODE_CPU1STARTADDR_ADDR, ALT_SYSMGR_ROMCODE_CPU1STARTADDR_VALUE_SET(0x100000)); //<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> PC <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> cpu1 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">0x00100000</span></span> alt_write_word(ALT_RSTMGR_MPUMODRST_ADDR, alt_read_byte(ALT_RSTMGR_MPUMODRST_ADDR) &amp; ALT_RSTMGR_MPUMODRST_CPU1_CLR_MSK);</code> </pre> <br>  So what's next?  And then you need a little bit to understand the structure of the project. <br><br><img src="https://habrastorage.org/web/0e8/a10/f21/0e8a10f21af34544a1d1ca9073684e1c.JPG"><br><br>  This structure for AMP projects is the most optimal.  The Vectors block sets the interrupt vectors and makes branching for different processors.  Interrupt vectors are common to each processor.  Unfortunately, this block can only be written in assembler, but fortunately we will not write it from scratch but just edit the HW lib library file alt_interrupt_armcc.s.  It declares the necessary interrupt vector, interrupt stack, support for VFP \ NEON FPU.  We add the necessary splitter. <br><br><div class="spoiler">  <b class="spoiler_title">alt_interrupt_armcc.s before editing</b> <div class="spoiler_text"><pre> <code class="hljs delphi"> PRESERVE8 AREA VECTORS, CODE, READONLY ENTRY <span class="hljs-keyword"><span class="hljs-keyword">EXPORT</span></span> alt_interrupt_vector IMPORT __main <span class="hljs-keyword"><span class="hljs-keyword">EXPORT</span></span> alt_int_handler_irq [WEAK] alt_interrupt_vector Vectors LDR PC, alt_reset_addr LDR PC, alt_undef_addr LDR PC, alt_svc_addr LDR PC, alt_prefetch_addr LDR PC, alt_abort_addr LDR PC, alt_reserved_addr LDR PC, alt_irq_addr LDR PC, alt_fiq_addr alt_reset_addr DCD alt_int_handler_reset alt_undef_addr DCD alt_int_handler_undef alt_svc_addr DCD alt_int_handler_svc alt_prefetch_addr DCD alt_int_handler_prefetch alt_abort_addr DCD alt_int_handler_abort alt_reserved_addr DCD alt_int_handler_reserve alt_irq_addr DCD alt_int_handler_irq alt_fiq_addr DCD alt_int_handler_fiq alt_int_handler_reset B alt_premain alt_int_handler_undef B alt_int_handler_undef alt_int_handler_svc B alt_int_handler_svc alt_int_handler_prefetch B alt_int_handler_prefetch alt_int_handler_abort B alt_int_handler_abort alt_int_handler_reserve B alt_int_handler_reserve alt_int_handler_irq B alt_int_handler_irq alt_int_handler_fiq B alt_int_handler_fiq ;===== AREA ALT_INTERRUPT_ARMCC, CODE, READONLY alt_premain <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span></span></span><span class="hljs-function"> ;</span></span> Enable VFP / NEON. MRC p15, <span class="hljs-number"><span class="hljs-number">0</span></span>, r0, c1, c0, <span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> CP Access <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> ORR r0, r0, <span class="hljs-string"><span class="hljs-string">#0</span></span>x00f00000 ; Enable full access <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> NEON/VFP (Coprocessors <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>) MCR p15, <span class="hljs-number"><span class="hljs-number">0</span></span>, r0, c1, c0, <span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span> CP Access <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> ISB MOV r0, <span class="hljs-string"><span class="hljs-string">#0</span></span>x40000000 ; Switch <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the VFP <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> NEON hardware VMSR fpexc, r0 ; <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> EN bit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> FPEXC B __main ENDFUNC ;===== AREA ALT_INTERRUPT_ARMCC, CODE, READONLY <span class="hljs-keyword"><span class="hljs-keyword">EXPORT</span></span> alt_int_fixup_irq_stack ; void alt_int_fixup_irq_stack(uint32_t stack_irq); ; This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the same <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> GNU but <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ARMCC. alt_int_fixup_irq_stack <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span></span></span><span class="hljs-function"> ;</span></span> r4: stack_sys MRS r3, CPSR MSR CPSR_c, #(<span class="hljs-number"><span class="hljs-number">0</span></span>x12 :<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>x80 :<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>x40) MOV sp, r0 MSR CPSR_c, r3 BX lr ENDFUNC <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">alt_interrupt_armcc.s after editing</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> PRESERVE8 PRESERVE8 AREA VECTORS, CODE, READONLY ENTRY EXPORT alt_interrupt_vector <span class="hljs-keyword"><span class="hljs-keyword">IMPORT</span></span> __main EXPORT alt_int_handler_irq [WEAK] <span class="hljs-keyword"><span class="hljs-keyword">IMPORT</span></span> secondaryCPUsInit alt_interrupt_vector Vectors LDR PC, alt_reset_addr LDR PC, alt_undef_addr LDR PC, alt_svc_addr LDR PC, alt_prefetch_addr LDR PC, alt_abort_addr LDR PC, alt_reserved_addr LDR PC, alt_irq_addr LDR PC, alt_fiq_addr alt_reset_addr DCD alt_int_handler_reset alt_undef_addr DCD alt_int_handler_undef alt_svc_addr DCD alt_int_handler_svc alt_prefetch_addr DCD alt_int_handler_prefetch alt_abort_addr DCD alt_int_handler_abort alt_reserved_addr DCD alt_int_handler_reserve alt_irq_addr DCD alt_int_handler_irq alt_fiq_addr DCD alt_int_handler_fiq alt_int_handler_reset B alt_premain alt_int_handler_undef B alt_int_handler_undef alt_int_handler_svc B alt_int_handler_svc alt_int_handler_prefetch B alt_int_handler_prefetch alt_int_handler_abort B alt_int_handler_abort alt_int_handler_reserve B alt_int_handler_reserve alt_int_handler_irq B alt_int_handler_irq alt_int_handler_fiq B alt_int_handler_fiq ;===== AREA ALT_INTERRUPT_ARMCC, CODE, READONLY alt_premain <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> {TARGET_FEATURE_NEON} || {TARGET_FPU_VFP} ; <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> VFP / NEON. MRC p15, <span class="hljs-number"><span class="hljs-number">0</span></span>, r0, c1, c0, <span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> CP <span class="hljs-keyword"><span class="hljs-keyword">Access</span></span> register ORR r0, r0, #<span class="hljs-number"><span class="hljs-number">0x00f00000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> NEON/VFP (Coprocessors <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>) MCR p15, <span class="hljs-number"><span class="hljs-number">0</span></span>, r0, c1, c0, <span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span> CP <span class="hljs-keyword"><span class="hljs-keyword">Access</span></span> register ISB MOV r0, #<span class="hljs-number"><span class="hljs-number">0x40000000</span></span> ; Switch <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the VFP <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> NEON hardware VMSR fpexc, r0 ; <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> EN <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> FPEXC ENDIF MRC p15, <span class="hljs-number"><span class="hljs-number">0</span></span>, r0, c0, c0, <span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> CPU ID register ANDS r0, r0, #<span class="hljs-number"><span class="hljs-number">0x03</span></span> ; Mask <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, leaving the CPU ID field BEQ primaryCPUInit ; jump <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> cpu0 code init BNE secondaryCPUsInit ; jump <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> cpu1 code init primaryCPUInit ;jump <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> main() B __main ENDFUNC ;===== AREA ALT_INTERRUPT_ARMCC, CODE, READONLY EXPORT alt_int_fixup_irq_stack ; <span class="hljs-type"><span class="hljs-type">void</span></span> alt_int_fixup_irq_stack(uint32_t stack_irq); ; This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the same implementation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> GNU but <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ARMCC. alt_int_fixup_irq_stack <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> ; r4: stack_sys MRS r3, CPSR MSR CPSR_c, #(<span class="hljs-number"><span class="hljs-number">0x12</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>: <span class="hljs-number"><span class="hljs-number">0x80</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>: <span class="hljs-number"><span class="hljs-number">0x40</span></span>) MOV sp, r0 MSR CPSR_c, r3 BX lr ENDFUNC <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre></div></div><br>  Of course now you need to add the function secondaryCPUsInit in another file <br><br><div class="spoiler">  <b class="spoiler_title">start_cpu1.s</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> PRESERVE8 AREA CPU1, CODE, READONLY ENTRY <span class="hljs-keyword"><span class="hljs-keyword">IMPORT</span></span> eth <span class="hljs-keyword"><span class="hljs-keyword">IMPORT</span></span> ||Image$$<span class="ruby"><span class="ruby">ARM_LIB_STACKHEAP$$</span></span>ZI$$<span class="ruby"><span class="ruby">Base</span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> IMPORT </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby">Image$$</span></span>ARM_LIB_STACKHEAP$$<span class="ruby"><span class="ruby">ZI$$</span></span>Length|| <span class="hljs-keyword"><span class="hljs-keyword">IMPORT</span></span> ||Image$$<span class="ruby"><span class="ruby">ARM_LIB_STACKHEAP$$</span></span>ZI$$<span class="ruby"><span class="ruby">Limit</span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> cpu1_stackheap_base DCD </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby">Image$$</span></span>ARM_LIB_STACKHEAP$$<span class="ruby"><span class="ruby">ZI$$</span></span>Base|| cpu1_stackheap_lenth DCD ||Image$$<span class="ruby"><span class="ruby">ARM_LIB_STACKHEAP$$</span></span>ZI$$<span class="ruby"><span class="ruby">Length</span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> cpu1_stackheap_limit DCD </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby">Image$$</span></span>ARM_LIB_STACKHEAP$$<span class="ruby"><span class="ruby">ZI$$</span></span><span class="hljs-keyword"><span class="hljs-keyword">Limit</span></span>|| Mode_USR EQU <span class="hljs-number"><span class="hljs-number">0x10</span></span> Mode_FIQ EQU <span class="hljs-number"><span class="hljs-number">0x11</span></span> Mode_IRQ EQU <span class="hljs-number"><span class="hljs-number">0x12</span></span> Mode_SVC EQU <span class="hljs-number"><span class="hljs-number">0x13</span></span> Mode_ABT EQU <span class="hljs-number"><span class="hljs-number">0x17</span></span> Mode_UNDEF EQU <span class="hljs-number"><span class="hljs-number">0x1B</span></span> Mode_SYS EQU <span class="hljs-number"><span class="hljs-number">0x1F</span></span> Len_FIQ_Stack EQU <span class="hljs-number"><span class="hljs-number">0x1000</span></span> Len_IRQ_Stack EQU <span class="hljs-number"><span class="hljs-number">0x1000</span></span> I_Bit EQU <span class="hljs-number"><span class="hljs-number">0x80</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> I <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>, IRQ <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> disabled F_Bit EQU <span class="hljs-number"><span class="hljs-number">0x40</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> F <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>, FIQ <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> disabled EXPORT secondaryCPUsInit secondaryCPUsInit <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> ; stack_base could be defined above, <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> located <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a scatter file LDR R0, cpu1_stackheap_limit MRC p15, <span class="hljs-number"><span class="hljs-number">0</span></span>, r1, c0, c0, <span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> CPU ID register ANDS r1, r1, #<span class="hljs-number"><span class="hljs-number">0x03</span></span> ; Mask <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, leaving the CPU ID field SUB r0, r0, r1, LSL #<span class="hljs-number"><span class="hljs-number">14</span></span> ; Stack <span class="hljs-number"><span class="hljs-number">-0x4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cpu1 ; Enter <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> mode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> turn <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up the stack pointer MSR CPSR_c, #Mode_FIQ:<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>:I_Bit:<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>:F_Bit ; Interrupts disabled MOV sp, R0 SUB R0, R0, #Len_FIQ_Stack MSR CPSR_c, #Mode_IRQ:<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>:I_Bit:<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>:F_Bit ; Interrupts disabled MOV sp, R0 SUB R0, R0, #Len_IRQ_Stack MSR CPSR_c, #Mode_SVC:<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>:I_Bit:<span class="hljs-keyword"><span class="hljs-keyword">OR</span></span>:F_Bit ; Interrupts disabled MOV sp, R0 ; Leave processor <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SVC mode ; Enables the SCU MRC p15, <span class="hljs-number"><span class="hljs-number">4</span></span>, r0, c15, c0, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> periph base address LDR r1, [r0, #<span class="hljs-number"><span class="hljs-number">0x0</span></span>] ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> the SCU Control Register ORR r1, r1, #<span class="hljs-number"><span class="hljs-number">0x1</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> (The <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span>) STR r1, [r0, #<span class="hljs-number"><span class="hljs-number">0x0</span></span>] ; <span class="hljs-keyword"><span class="hljs-keyword">Write</span></span> back modifed <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ; ; <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> SMP ; <span class="hljs-comment"><span class="hljs-comment">--------- MRC p15, 0, r0, c0, c0, 5 ; Read CPU ID register ANDS r0, r0, #0x03 ; Mask off, leaving the CPU ID field MOV r1, #0xF ; Move 0xF (represents all four ways) into r1 ;secureSCUInvalidate AND r0, r0, #0x03 ; Mask off unused bits of CPU ID MOV r0, r0, LSL #2 ; Convert into bit offset (four bits per core) AND r1, r1, #0x0F ; Mask off unused bits of ways MOV r1, r1, LSL r0 ; Shift ways into the correct CPU field MRC p15, 4, r2, c15, c0, 0 ; Read periph base address STR r1, [r2, #0x0C] ; Write to SCU Invalidate All in Secure State ;joinSMP ; SMP status is controlled by bit 6 of the CP15 Aux Ctrl Reg MRC p15, 0, r0, c1, c0, 1 ; Read ACTLR MOV r1, r0 ORR r0, r0, #0x040 ; Set bit 6 CMP r0, r1 MCRNE p15, 0, r0, c1, c0, 1 ; Write ACTLR ;enableMaintenanceBroadcast MRC p15, 0, r0, c1, c0, 1 ; Read Aux Ctrl register MOV r1, r0 ORR r0, r0, #0x01 ; Set the FW bit (bit 0) CMP r0, r1 MCRNE p15, 0, r0, c1, c0, 1 ; Write Aux Ctrl register B main_cpu1 ENDFUNC END</span></span></code> </pre></div></div><br>  I admit, I just added this code, and I took the original from the examples in the DS-5 folder.  I wrote only the stack configuration, and at the end <code>B main_cpu1</code> to go to the function.  Well, it seems like SCU is needed, I left it, and the rest did not touch. It is necessary to disassemble the scatter file in order to better understand what is happening. <br><br><div class="spoiler">  <b class="spoiler_title">scatter file</b> <div class="spoiler_text"> <code>LD_SDRAM 0x00100000 0x80000000 ;SDRAM_load region for MPU from 1 Mb to 3 Gb. DE1-SoC has 2 Gb of DDR memory <br> { <br> VECTORS +0 <br> { <br> * (VECTORS, +FIRST) <br> } <br> <br> APP_CODE +0 <br> { <br> * (+RO, +RW, +ZI) <br> } <br> <br> ;Application heap and stack cpu0 <br> ARM_LIB_STACKHEAP +0 EMPTY 8000 <br> { } <br> <br> CPU1_CODE 0x00200000 FIXED 0x00100000 <br> { <br> start_cpu1.o(CPU1, +FIRST) <br> main_sc.o(+RO, +RW, +ZI) <br> } <br> <br> }</code> </div> </div><br>  VECTORS is located at the beginning of the SDRAM at 0x00100000 (written in alt_interrupt_armcc.s), at 0x0 you can‚Äôt put it, so look at the <a href="https://www.altera.com/documentation/sfo1410143707420.html">Cyclone V Hard Processor</a> .  In the APP_CODE area, all the code (main () of the first kernel and other external functions) is located, except for the main () function for the second kernel. <br><br>  ARM_LIB_STACKHEAP is a reserved word for stack and heap, and is 8000 bytes in size, a large number, taken with a margin.  This line allows you to configure the stack automatically in the _main () function.  For the second kernel, we do it ourselves in the start_cpu1.s file.  From the lower bound of the STACKHEAP we fall back up 4000 bytes, overlapping the stacks should not arise.  Not yet invented a way to select the optimal stack size. <br><br>  The CPU1_CODE area starts at 0x00200000 and has a size of 1 MB.  Before the main_cpu1 () function, written in a separate main_sc.c file, the assembler code of our file is located to start the second kernel start_cpu1.s.  In the scatter file, you must specify the .o extension if you want to separately place the code of the files at the desired addresses. <br><br>  Thus, in one project we actually have two different programs.  In debugger settings you should change Target to Debug Cortex-A9x2 SMP, then you can switch between two cores in the process. <br><br><h2>  Bonus </h2><br>  If you had to solve the problem of running two different programs on two cores, then it will be useful for you to know how to enable MMU and Cache for both cores.  Without this, any program that is more difficult than a blinking LED will be extremely slow. <br><br><img src="https://habrastorage.org/web/026/ce9/930/026ce993042f4151bc151c5a1cb348b8.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">MMU and Cache for the first kernel</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"alt_cache.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"alt_mmu.h"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MMU Page table - 16KB aligned at 16KB boundary */</span></span> #define ARRAY_SIZE(array) (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(array) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(array[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uint32_t __attribute__ ((aligned (<span class="hljs-number"><span class="hljs-number">0x4000</span></span>))) alt_pt_storage[<span class="hljs-number"><span class="hljs-number">4096</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void *alt_pt_alloc(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size_t size, void *context) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void mmu_init(void) { uint32_t *ttb1 = NULL; <span class="hljs-comment"><span class="hljs-comment">// Populate the page table with sections (1 MiB regions). ALT_MMU_MEM_REGION_t regions[] = { // Memory area: 4 mb { .va = (void *)0x00000000, .pa = (void *)0x00000000, .size = 0x00400000, .access = ALT_MMU_AP_PRIV_ACCESS, .attributes = ALT_MMU_ATTR_WBA, .shareable = ALT_MMU_TTB_S_SHAREABLE, .execute = ALT_MMU_TTB_XN_DISABLE, .security = ALT_MMU_TTB_NS_SECURE }, // Device area: Everything else { .va = (void *)0x00400000, .pa = (void *)0x00400000, .size = 0xffc00000, .access = ALT_MMU_AP_PRIV_ACCESS, .attributes = ALT_MMU_ATTR_DEVICE_NS, .shareable = ALT_MMU_TTB_S_NON_SHAREABLE, .execute = ALT_MMU_TTB_XN_ENABLE, .security = ALT_MMU_TTB_NS_SECURE } }; alt_mmu_init(); alt_mmu_va_space_storage_required(regions, ARRAY_SIZE(regions)); alt_mmu_va_space_create(&amp;ttb1, regions, ARRAY_SIZE(regions), alt_pt_alloc, alt_pt_storage); alt_mmu_va_space_enable(ttb1); } int main() { mmu_init(); alt_cache_system_enable(); }</span></span></code> </pre></div></div><br>  This is part of the code for the first kernel  Since the MMU and the data cache and instructions for each core are different, in the code for the second core you need to write a similar initialization function of the MMU and enable only the corresponding caches, since L2 has already been initialized by the first core. <br><br><div class="spoiler">  <b class="spoiler_title">MMU and Cache for the second core</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main_cpu1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { mmu_init2(); alt_cache_l1_enable_all(); }</code> </pre></div></div><br>  This configuration works exactly. <br><br>  It should say a few words about interruptions.  Everything is trivial here, first we turn on the GIC (this is enough to do only on the first core once), then in each core it is necessary to initialize separately and enable the interrupt purely for the CPU.  For this function <br><br><pre> <code class="hljs lisp">alt_int_global_init()<span class="hljs-comment"><span class="hljs-comment">; alt_int_global_enable(); alt_int_cpu_init(); alt_int_cpu_enable();</span></span></code> </pre> <br>  When an interrupt occurs, the counter must go to the desired vector, which can be declared only once.  It is for this reason that the initialization of the second kernel also begins from the VECTORS area, and then goes through the condition to the start_cpu1 file.  Because otherwise we would have to re-declare the same vectors with the same names, but this cannot be done in one project. <br><br>  In general, I even tried to make an extreme "perversion".  Created and compiled two completely different projects, but placed the code in different places so that there was no overlap.  Converted .axf to .bin.  In the first kernel code, I set the counter address exactly to the main () location of the second kernel code.  Then, through Hex, the editor stitched two files into one, with the correct placement of the code at the address.  Everything worked, but somehow it sucks.  Yes, and debugging such a miracle is not at all convenient.  I suspected this was a bad idea, but it was just fun to check.  At this I have everything, thanks to everyone who read! <br><br><h2>  Literature </h2><br><ol><li>  In general, all the detailed information about the scatter syntax is found in the documents of the version of <a href="http://infocenter.arm.com/help/index.jsp">ARM Compiler armlink User Guide</a> you need. </li><li>  About assembler in <a href="http://infocenter.arm.com/help/index.jsp">ARM Compiler armasm User Guide</a> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/332456/">https://habr.com/ru/post/332456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332438/index.html">‚ÄúUltimate‚Äù blockchain digest: useful materials on Habr√© and other sources on the topic</a></li>
<li><a href="../332442/index.html">ML Grid - Apache Ignite machine learning library</a></li>
<li><a href="../332444/index.html">Doctor Web: MEDoc contains a backdoor giving attackers access to a computer</a></li>
<li><a href="../332448/index.html">Delivery of billions of messages strictly once</a></li>
<li><a href="../332450/index.html">Moby / Docker in production. Failure history</a></li>
<li><a href="../332458/index.html">Broadcast HPE Digitize: talk about our new products and solutions</a></li>
<li><a href="../332460/index.html">Why do I need your permanent collections? They are slow</a></li>
<li><a href="../332462/index.html">What if throwing all the excess out of the database into a distributed cache is our experience using Hazelcast</a></li>
<li><a href="../332464/index.html">Color segmentation for dummies</a></li>
<li><a href="../332466/index.html">The market of detection and recognition systems: Emotions and "emotional calculations"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>