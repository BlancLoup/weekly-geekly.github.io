<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How the kernel manages memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier we saw how the virtual memory of the process is organized. Now consider the mechanisms by which the kernel manages memory. Refer to our progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How the kernel manages memory</h1><div class="post__text post__text-html js-mediator-article">  Earlier we saw how the virtual memory of the process is organized.  Now consider the mechanisms by which the kernel manages memory.  Refer to our program: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2e/e3e/e95/b2ee3ee9581bb9ddc737a45beedc4c07.jpg" alt="image"><a name="habracut"></a><br><br>  In Linux, processes are implemented as a task_struct struct object, which is essentially a process descriptor.  The mm field of the task_struct object contains a pointer to a so-called.  A ‚Äúprocess memory handle‚Äù is a mm_struct struct object that contains comprehensive information about the memory usage of this process.  The process memory descriptor stores information about the initial and final address of the process segments, as shown in the figure above, the number of page frames (physical pages in RAM) used by the process (this is RSS or the so-called ‚Äúresident page set‚Äù), the number virtual memory allocated to the process, and another little thing.  The process memory descriptor also indicates the location of the VMA (virtual memory area) descriptors and the set of page-tables for the process.  The last two data structures are a kind of workhorse, since  they are involved in most memory management operations.  The virtual memory areas for our program are shown in the figure: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e5a/50f/d9a/e5a50fd9a644ba418131658087064ef3.jpg" alt="image"><br><br>  A virtual memory area (VMA) is a continuous range of virtual addresses;  areas never overlap.  An instance of the vm_area_struct struct object exhaustively describes one VMA, including the starting and ending virtual address of the area, flags, rights and other features of access to the area, the vm_file field with information about the file mapped to this area (if any).  The area of ‚Äã‚Äãvirtual memory that is not associated with any file is called anonymous.  Each of the program segments in the above figure (heap, stack, etc.) has its own VMA;  The exception in this respect is only so-called.  ‚ÄúSegment for mapping‚Äù (memory mapping segment).  This state of affairs is not a requirement or something predetermined, but in the case of the x86 platform this is in most cases exactly the case.  The virtual memory area does not care which segment to match. <br><br>  The VMA set for this process is described in two ways at once.  First, in the process memory descriptor (the mm_struct struct object) there is a mmap pointer to the VMA descriptors linked list (the order of the descriptors in the list corresponds to the order of the VMA in the virtual address space).  Secondly, everything in the same memory descriptor has a mm_rb pointer to the structure, which is a red-black tree.  An RB tree allows the kernel to quickly determine whether a virtual address is located within a particular virtual area.  If you look at the contents of the / proc / pid_of_process / maps file in the proc file system, then it will be nothing more than information obtained by the kernel as a result of passing through the linked list of VMA descriptors. <br><br>  In Windows, the EPROCESS block is, roughly speaking, something in between the task_struct and mm_struct structures.  The analogue of the virtual memory area descriptor is the Virtual Address Descriptor or VAD.  Information about VAD descriptors is stored in the AVL tree.  Do you know what is funny when comparing Windows and Linux?  This is the fact that there are not so many differences. <br><br>  The 4-gigabyte virtual address space is represented as a series of pages.  32-bit x86 processors support page sizes of 4 KB, 2 MB, and 4 MB.  Linux and Windows use 4-kilobyte pages for the user space-part of the virtual address space.  Bytes 0-4095 fall into page # 0, bytes 4096-8191 fall into page # 1, etc.  The size of the VMA must be a multiple of the page size.  This is what a 3-gigabyte user space looks like, organized using 4-kilobyte pages: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f40/847/1ed/f408471ed845712ed6b796ba24a66739.jpg" alt="image"><br><br>  The processor consults page-tables in order to convert a virtual address to a physical one.  Each process has its own set of such page-tables;  as soon as the process switch (context switch) occurs, the page tables for the user space-part of the virtual address space also change.  In Linux, a pointer to the process page-table is stored in the pgd field of the process memory handle.  Each virtual page corresponds to one entry in a page-table, and, in the case of a classic x86 paging, this is a simple 4-byte entry shown in the following figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f95/105/b1e/f95105b1e3e6dbf39fd211387f276af5.jpg" alt="image"><br><br>  In the Linux kernel, there are functions that allow you to score or reset any flag in the page table entry.  The ‚ÄúP‚Äù flag indicates whether the page is in RAM or not.  When this flag is set to 0, access to the corresponding page will cause page fault.  It should be noted that if this flag is set to 0, then the kernel can use the remaining bits in the page table entry.  The ‚ÄúR / W‚Äù flag means ‚Äúwrite / read‚Äù;  if the flag is not set, then only read access to the page is possible.  The ‚ÄúU / S‚Äù flag means ‚Äúuser / supervisor‚Äù;  if the flag is not set, only code running with privilege level 0 (i.e., the kernel) can access this page.  Thus, these flags are used to implement the concept of an write-only address space and a space that is available only to the kernel. <br><br>  Flags ‚ÄúD‚Äù and ‚ÄúA‚Äù mean ‚Äúdirty‚Äù and ‚Äúaccessed‚Äù.  The ‚Äúdirty page‚Äù is the one that was recently written to, and the ‚Äúaccessed‚Äù page is the page that was accessed (read or written).  Both flags are sticky, the processor can install them, but it will not reset them - the kernel must do this.  Finally, the page table entry stores the initial physical address of the page in memory;  The address will always be a multiple of 4K.  This seemingly harmless field is the cause of many problems, since  it actually limits the size of addressable physical memory to 4 gigabytes.  Other fields page table entries look at some other time, as well as the Physical Address Extension mechanism. <br><br>  Memory protection is carried out on a per page basis, since the page is the smallest "piece" of memory for which you can set the flags "U / S" and "R / W".  However, it should be borne in mind that theoretically, two different virtual pages having a different set of flags can correspond to the same physical page.  Note that in the page table format entries are not provided for flags related to the prohibition on code execution.  In other words, the classic x86-paging does not prevent the execution of code in the stack.  That is why it is possible to exploit vulnerabilities based on buffer overflow in the stack (non-executable stacks are still subject to vulnerabilities; in this case, use the return-to-libc technique and other techniques).  The lack of a no-execute flag also indicates another important aspect: the access flags contained in the VMA descriptor do not always have direct matches in the protection system implemented by the processor, and correspond to this system only to a greater or lesser extent.  Figuratively speaking, the kernel does everything in its power, but ultimately the processor architecture imposes its own limitations on what is possible to implement. <br><br>  Of course, virtual memory itself does not store anything.  Virtual address space is just an abstraction, but it is in a certain way matched to physical memory.  The way the address bus of the processor works, generally speaking, the thing is quite non-trivial, but we can now abstract from it.  We assume that the processor operates with a range of consecutive addresses from zero to the maximum address available in the system (depending on the amount of RAM) and can, if necessary, refer to any byte in this range.  The physical address space is considered by the processor as a sequence of physical pages (they are also called page-frames).  The processor has little to do with page frames, but for the kernel they are very important, since  A page frame is a unit of accounting and management of physical memory, which is performed by the kernel.  32-bit versions of Linux and Windows use 4-kilobyte page frames;  Here is an example of a machine with 2 GB of RAM: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/828/aa5/569/828aa5569755c738f1d0f1c66719f5a5.jpg" alt="image"><br><br>  The Linux kernel keeps track of each page frame using a special descriptor and several flags.  Taken together, these descriptors describe all of the computer‚Äôs RAM;  at each moment in time, the exact state of any page-frame is known.  Physical memory management is based on the Buddy memory allocation algorithm.  Thus, a page frame is considered free if it is available for selection from the point of view of the Buddy algorithm.  Dedicated for using a page-frame can be ‚Äúanonymous‚Äù (in this case it contains program data) or it can be located in a so-called.  "Page cache" (page cache) and store a portion of the data from some file or block device.  There are other, more exotic options for using page-frames, but let's not touch them now.  Windows also has a similar structure for accounting for page-frames, and it is called the Page Frame Number database. <br><br>  And now, let's put together all these concepts ‚Äî virtual memory areas (VMA), page table entries and page frames ‚Äî and see how it all works together.  The following is an example of a heap in the user space of the program area: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/637/0d2/9b1/6370d29b1ae4263100df0b0ff0aeac15.jpg" alt="image"><br><br>  Rectangles with a blue background represent virtual pages that are within the VMA.  Arrows denote page table entries by which virtual pages are ‚Äúmapped‚Äù into page frames (physical pages).  Some virtual pages do not have arrows;  This means that the presence flag is set to 0 in the corresponding page table entries. The reason for this may be that these virtual pages may or may not have been used up yet or because the corresponding physical pages were unloaded into a swap.  In any case, an attempt to access these pages will result in a page fault, even though the virtual pages are within a certain VMA.  It may seem strange that there is a similar misunderstanding - the pages within the VMA and yet access to them is invalid - but it really happens often. <br><br>  VMA is a kind of ‚Äúcontract‚Äù between the program and the core.  You ask the kernel to do something (for example, allocate memory or file the file), the kernel says ‚Äúno problem‚Äù and creates a new one or updates an existing VMA.  But the core is not in a hurry to perform these actions themselves;  instead, it will postpone the immediate execution of the requested action until the page fault occurs.  It turns out that the kernel is a sort of "lazy deceiver", and this is the fundamental principle of managing virtual memory.  This principle applies in most situations - some of them may be quite familiar, some unexpected, but the general rule is that the VMA only records what was agreed on, while the page and table entries reflect what was directly done. lazy core.  These two structures together participate in the program's memory management;  both structures play a certain role in processing page fault, freeing memory, unloading pages into a swap, etc.  Consider a simple case of memory allocation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f08/b28/64a/f08b2864a50c9782e6eeb22d0ffb6ec3.jpg" alt="image"><br><br>  When a program requests the allocation of additional memory through the brk () system call, the kernel simply simply updates the information in the VMA descriptor and considers its task accomplished.  At this time, neither new page frames are allocated, nor they are placed in RAM.  However, as soon as the program tries to access the virtual page, the processor will catch the page fault and the do_page_fault () handler will be called.  This function will search for the VMA, within which there is an address that the page fault caused.  If such a VMA exists, then a check is made for consistency between the access rights to the VMA and the type of access to be made (read or write access).  If there is no suitable VMA, then there is no ‚Äúcontract‚Äù that would provide for the possibility of accessing the memory.  In the latter case, a Segmentation Fault signal is sent to the process, and it terminates. <br><br>  Suppose VMA is still found.  Further processing of the page fault is as follows - the kernel looks at the contents of the page table entry and the VMA type.  In our example, the page table entry indicates that there is no page in memory.  Moreover, our entry is completely empty (it consists of only zeros), and in Linux this means that the corresponding virtual page has never been tagged at all.  Since we are dealing with an ‚Äúanonymous‚Äù VMA, all further actions will be associated only with RAM, and the do_anonymous_page () function is called to handle this situation.  This function selects the page frame and maps a virtual page into it by entering the necessary data into the page table entry. <br><br>  The case could be otherwise.  A page table entry for a swapped page, for example, has a presence flag set to 0, but the rest of the entry is non-empty.  The remaining bits store information about whether the page is in a swap.  The do_swap_page () function reads the contents of this page from disk and loads the page into RAM.  This kind of page fault is called a major fault. <br><br>  This concludes the first part of our excursion into how the kernel manages memory.  In the next article we will complicate the picture by adding it to working with files ‚Äî in this way we will get a more complete picture of the basic concepts of memory management, including some aspects of performance. <br><br>  The material was prepared by employees of the company Smart-Soft.  Translation of the article <a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/">How the Kernel Manages Your Memory by Gustavo Duarte</a> <br>  <a href="http://www.smart-soft.ru/ru/">smart-soft.ru</a> </div><p>Source: <a href="https://habr.com/ru/post/226315/">https://habr.com/ru/post/226315/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226305/index.html">Libraries that may still be useful</a></li>
<li><a href="../226307/index.html">We color icons from Google</a></li>
<li><a href="../226309/index.html">Declarative data binding in WinJS</a></li>
<li><a href="../226311/index.html">Steel printer</a></li>
<li><a href="../226313/index.html">The use of a homemade thermal imager based on the Arduino in the study of energy saving</a></li>
<li><a href="../226317/index.html">Small network single board computer for 20 USD</a></li>
<li><a href="../226321/index.html">Speedran on 13 vulnerabilities on sites. Basic concepts and means of protection</a></li>
<li><a href="../226323/index.html">Waterfall and Agile: and yet, where does the effect come from?</a></li>
<li><a href="../226325/index.html">An interesting task for the interview, currying and partial application of the function</a></li>
<li><a href="../226327/index.html">What should "PHP Junior Developer without experience" know?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>