<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We manage asynchrony in PHP: from promises to corints</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is asynchrony? In short, asynchronous means the execution of several tasks within a certain period of time. PHP runs in one thread, which means t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We manage asynchrony in PHP: from promises to corints</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  What is asynchrony?  In short, asynchronous means the execution of several tasks within a certain period of time.  PHP runs in one thread, which means that only one piece of PHP code can be executed at a time.  This may seem a restriction, but in fact gives us more freedom.  As a result, we don‚Äôt have to deal with all the complexity associated with multithreaded programming.  But on the other hand, there is a set of problems.  We have to deal with asynchrony.  We need to somehow manage it and coordinate it. </p><br><p>  <em>We present the translation of an article from the Skyeng developer Skyeng blog by Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  For example, when we execute two parallel HTTP requests, we say that they are ‚Äúexecuted in parallel‚Äù.  This is usually easy and simple to do, but problems arise when we need to streamline the responses of these requests, for example, when one request requires data received from another request.  Thus, it is in the control of asynchrony that the greatest difficulty lies.  There are several different ways to solve this problem. </p><br><blockquote>  Currently, PHP does not have built-in support for high-level abstractions to control asynchrony, and we have to use third-party libraries, such as ReactPHP and Amp.  In the examples of this article, I use ReactPHP. </blockquote><br><h3>  Promises </h3><br><p>  To better understand the idea of ‚Äã‚Äãpromises, we need a real life example.  Imagine that you are at McDonald's and you want to place an order.  You pay money for it and thus start a transaction.  In response to this transaction, you expect to receive a hamburger and fries.  But the cashier does not immediately return your food.  Instead, you get a check with the order number.  Consider this check as a promise for a future order.  Now you can take this check and start thinking about your delicious dinner.  The expected hamburger and french fries are not ready yet, so you stand and wait until your order is completed.  As soon as his number appears on the screen, you exchange the check for your order.  These are promises: </p><br><blockquote>  <i>Substitute for future value.</i> </blockquote><p>  A promis is a representation for a future value, a time-independent wrapper that we wrap around a value.  We don't care if the value is already here or not yet.  We continue to think about it the same way.  Imagine that we have three asynchronous HTTP requests that are executed "in parallel", so that they will be completed at about the same time.  But we want to somehow coordinate and streamline their responses.  For example, we want to output these answers as soon as they are received, but with one small limitation: do not print the second answer until the first one is received.  Here I mean that if <b>$ promise1</b> is executed, then we print it.  But if <b>$ promise2</b> is executed first, we do not print it, because <b>$ promise1 is</b> still in progress.  Imagine that we are trying to adapt three competitive queries in such a way that they look to the end user as one quick request. </p><br><p>  So, how can we solve this problem with promises?  First of all, we need a function that returns a promise.  We can put together three such promises, and then put them together.  Here is some fake code for this: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Here I have two functions: <br>  <b>fakeResponse (string $ url, callable $ callback)</b> contains a hard-coded response and allows the specified callback with this answer; <br>  <b>makeRequest (string $ url)</b> returns a promise that uses <b>fakeResponse ()</b> to indicate that the request has been completed. </p><br><p>  From the client code, we simply call the function <b>makeRequest ()</b> and get promises: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  It was easy, but now we need to sort these answers somehow.  Once again, we want the answer from the second promise to be printed only after the first one is completed.  To solve this problem, you can build a chain of promises: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  In the code above, we start with <b>$ promise1</b> .  As soon as it is executed, we print its value.  We don't care how long it takes: less than a second or an hour.  As soon as the promise is completed, we will print its value.  And then we wait for <b>$ promise2</b> .  And here we can have two scenarios: </p><br><p>  <b>$ promise2 is</b> already completed, and we immediately print its value; <br>  <b>$ promise2 is</b> still running, and we are waiting. </p><br><p>  Thanks to the alignment of the promises in the chain, we no longer need to worry about whether some promise is fulfilled or not.  Promis does not depend on time, and thus it hides its states from us (in the process, already completed or canceled). </p><br><p>  This is how you can control asynchrony with promises.  And it looks great, the chain of promises is much prettier and clearer than a bunch of nested callbacks. </p><br><h3>  Generators </h3><br><p>  In PHP, generators are built-in language support for functions that can be suspended and then resumed.  When the execution of the code inside such a generator stops, it looks like a small blocked program.  But outside of this program, outside the generator, everything else continues to work.  This is all the magic and power of generators. </p><br><p>  We can literally locally suspend the generator to wait for the promise to be completed.  The basic idea is to use promises and generators together.  Asynchronous control they completely take over, and we simply call yield when we need to pause the generator.  Here is the same program, but now we connect generators and promises: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>For this code, I use the <a href="https://github.com/recoilphp/recoil">recoilphp / recoil library</a> , which allows you to call <b>ReactKernel :: start ()</b> .</i>  <i>Recoil makes it possible to use PHP generators to perform ReactPHP asynchronous promises.</i> </blockquote><p>  Here, we still ‚Äúparallel‚Äù execute three requests, but now we order the answers using the <b>yield</b> keyword.  And again we display the results at the end of each promise, but only after the previous one has been completed. </p><br><h3>  Korutiny </h3><br><p>  Korutiny is a way of splitting an operation or process into chunks, with some execution inside each such chunk.  The result is that instead of performing the entire operation at a time (which can lead to a noticeable hang of the application), it will be performed gradually until all the necessary work has been completed. </p><br><p>  Now that we have intermittent and renewable generators, we can use them to write asynchronous code with promises in a more familiar synchronous form.  With the help of PHP generators and promises, you can completely get rid of callbacks.  The idea is that when we give a promise (using the yield call), the quortina subscribes to it.  Korutina pauses and waits until the promise is completed (completed or canceled).  As soon as the promise is completed, the quorutine will continue its execution.  If promise is successful, corutin sends the resulting value back to the generator context using the call <b>Generator :: send ($ value)</b> .  If the promise fails, then Korutin throws an exception through the generator, using the call <b>Generator :: throw ()</b> .  In the absence of callbacks, we can write asynchronous code that looks almost like our usual synchronous. </p><br><p>  <b>Sequential execution</b> </p><br><p>  When using Coroutin, the order of execution in asynchronous code now matters.  The code runs exactly to the point where the yield keyword is invoked and then paused until the promise is completed.  Consider the following code: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Promise1:</b> will be displayed <b>here</b> , then execution pauses and waits.  As soon as the promise from <b>makeRequest ('url1')</b> is completed, we output its result and proceed to the next line of code. </p><br><p>  <b>Error processing</b> </p><br><p>  The <a href="https://promisesaplus.com/">Promises / A +</a> promise standard says that each promise contains the <b>then () and catch ()</b> methods.  Such an interface allows you to build chains of promises and optionally catch errors.  Consider this code: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Here we have a chain of promises, transmitting the result of each previous promise to the next.  But there is no <b>catch ()</b> block in this chain, there is no error handling.  When any promise in the chain fails, the execution of the code goes to the error handler nearest in the chain.  In our case, this means that the unfulfilled promise will be ignored, and any errors thrown away will disappear forever.  With Corutin error handling comes to the fore.  If any asynchronous operation fails, an exception will be thrown: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Making asynchronous code readable </h3><br><p>  Generators have a really important side effect that we can use to control asynchrony and which allows us to solve the problem of readability of asynchronous code.  It's hard for us to understand how asynchronous code will be executed because the execution flow constantly switches between different parts of the program.  However, our brain basically works synchronously and in a single thread.  For example, we plan our day very consistently: do one thing, then another, and so on.  But the asynchronous code does not work the way our brain is used to thinking.  Even a simple chain of promises may not look very readable: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  You have to mentally disassemble it in order to understand what is happening there.  Thus, we need another pattern to control asynchrony.  And in short, generators provide a way to write asynchronous code so that it looks synchronous. </p><br><p>  Promises and generators combine the best of both worlds: we get asynchronous code with high performance, but at the same time it looks like synchronous, linear and sequential.  Korutiny allow you to hide the asynchrony, which is becoming part of the implementation.  And our code at the same time looks like our brain used to think - linearly and consistently. </p><br><p>  If we are talking about <a href="https://github.com/recoilphp">ReactPHP</a> , then you can use the RecoilPHP library to record promises in the form of corutin.  In <a href="https://amphp.org/">Amp,</a> korutiny available immediately out of the box. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/453296/">https://habr.com/ru/post/453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453280/index.html">Technical duty</a></li>
<li><a href="../453286/index.html">The most expensive mistake in my life: in detail about the attack on the port of the SIM card</a></li>
<li><a href="../453290/index.html">Data Science Digest (May 2019)</a></li>
<li><a href="../453292/index.html">"A little book about black holes"</a></li>
<li><a href="../453294/index.html">React. Lazy loading</a></li>
<li><a href="../453298/index.html">Summer: upgrade time ... yourself</a></li>
<li><a href="../4533/index.html">Stayed a month before the SEC (Russia) Programmer Conference</a></li>
<li><a href="../453302/index.html">The first hour of life with Yandex.Modul</a></li>
<li><a href="../453304/index.html">Main Benefits of Zextras PowerStore</a></li>
<li><a href="../453306/index.html">Kubernetes will take over the world. When and how?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>