<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web Scrolling: Primer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By Nolan Lawson, Microsoft Edge Project Manager 

 Scrolling is one of the most ancient interactions on the web. Long before the advent of the pull-to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web Scrolling: Primer</h1><div class="post__text post__text-html js-mediator-article">  <font color="gray"><i>By Nolan Lawson, Microsoft Edge Project Manager</i></font> <br><br>  Scrolling is one of the most ancient interactions on the web.  Long before the advent of the pull-to-refresh methods and endless download lists, the modest scroll bar solved the initial scaling problem on the web: how to interact with content that extends beyond the available viewing area? <br><img src="https://habrastorage.org/getpro/habr/post_images/fba/b5e/496/fbab5e4962080aa361740e1c4fe53d65.png"><br>  Today, scrolling is still the most fundamental interaction on the Web, and perhaps the most misunderstood.  For example, do you know the difference between the following scenarios? <br><br><ul><li>  User scrolls the page with two fingers on the touchpad </li><li>  User scrolls with one finger on the touchscreen </li><li>  User scrolls the mouse wheel </li><li>  User clicks the scroll bar and pulls it down and up </li><li>  The user presses the up, down, PageUp, PageDown and space bar on the keyboard </li></ul><br>  If you ask the average Internet user (or even the average web developer!), They can tell you that these actions are equivalent.  The truth is much more interesting. <br><a name="habracut"></a><br>  As it turns out, these five input methods have very different characteristics, especially in terms of performance and cross-browser compatibility.  Some of them (like scrolling on the touchscreen) are likely to be smooth even on a page using heavy javascript, while from others (like scrolling from the keyboard) the same page will lag and become insensitive.  Moreover, some types of scrolling can be slowed down by DOM event handlers, while others cannot.  What's going on here? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To answer this question and understand how to implement the smoothest scrolling for your site, let's step back to understand and see how browsers deal with multithreading and input. <br><br><h1>  Multithreaded web </h1><br>  Conceptually, the web is a single-threaded environment.  JavaScript blocks DOM, and DOM blocks JavaScript, because both are fighting for the same thread, often called the ‚Äúmain thread‚Äù or the ‚ÄúUI thread‚Äù. <br><br>  For example, if you add this (horrible) JavaScript snippet to a page, you will immediately notice a deterioration in performance: <br><br><pre><code class="javascript hljs">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - start &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>) {<span class="hljs-comment"><span class="hljs-comment">/* wheeeee! */</span></span>} }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  While this JavaScript is spinning in an infinite loop, the buttons do not work, the elements of the forms do not react and even the animated GIFs slow down - in all senses and relationships, the page is frozen.  You can study the effect in action in a <a href="http://bl.ocks.org/nolanlawson/raw/053d34c55b4f56abdf87b49946a8a2c9/">simple demo</a> . <br><br><img src="https://habrastorage.org/files/446/f6e/a19/446f6ea198e54118a33cfe44eea8a375.gif"><br><br>  Moreover, if you try to scroll the page with the "up" and "down" keys on the keyboard, the page is predictably stuck until JavaScript stops running.  All this is clear evidence of our presentation of the web as a single-threaded environment. <br><br>  There is a funny anomaly: if you try to scroll through the touchscreen, the page scrolls up and down perfectly, although JavaScript blocks everything else on the page.  The same applies to scrolling from the touchpad, mouse wheel and scrolling after the page is captured with the click-and-drag cursor (depending on the browser). <br><br>  Somehow, some scrolling actions can change the state of the page, while everything else ‚Äî buttons, data entry fields, GIFs ‚Äî is completely frozen.  How can we combine this with our single-threaded web theory? <br><br><img src="https://habrastorage.org/files/047/88d/8b4/04788d8b4a9b45569047ed8ef8665960.png"><br><br><h1>  The history of two threads </h1><br>  As it turns out, in general, the thesis ‚Äúsingle-threaded browsers‚Äù is true, but there are important exceptions.  Scrolling, in all its diversity, is one such exception. <br><br>  Over the years, browser developers have realized that unloading auxiliary work into background threads can provide significant benefits in terms of smoothness and sensitivity.  Scrolling is so important for a key browser experience that this task was quickly chosen for this optimization.  Nowadays, all the major browser engines (Blink, EdgeHTML, Gecko, WebKit) support scrolling beyond the main thread of execution to one degree or another (Firefox was the last to join the club, <a href="https://hacks.mozilla.org/2016/02/smoother-scrolling-in-firefox-46-with-apz/">from Firefox version 46</a> ). <br><br>  With background scrolling, even a cluttered page will scroll smoothly, because all scrolling is performed in a separate thread.  Only if you try to interact with the page through some extraneous mechanism that is not related to scrolling - press a key, enter data in the input field, click on the link - then the facade is reset and the essence of the salon stunt fully reveals itself.  (Considering how well it works, this is a great trick!) <br><br>  True, asynchronous scrolling has a common side effect, which is called <a href="http://www.masonchang.com/blog/2014/3/2/wow-such-checkerboard">the checkerboard effect</a> .  It first appeared on the Safari for iOS in the form of gray and white cells, as if from a chessboard.  In most modern browsers, the effect appears as empty space on the screen if you scroll faster than the browser can render the page.  This is not ideal, but it is an acceptable compromise compared to a locked, jerking or non-replicable scrolling. <br><br><img src="https://habrastorage.org/files/48e/483/635/48e4836357d7400b855c2714afc23295.gif"><br><br>  Unfortunately, it is not always easy to transfer scrolling to a background thread.  Browsers can do this only if the operating system allows simultaneous input, and this may vary from device to device.  In particular, keyboard input is not as optimized as mouse or touch device input, which ultimately leads to more significant lags when typing from the keyboard in all browsers. <br><br>  There will be an instructive little story.  When operating systems like Windows and macOS first came out, they allowed only one thread of execution, and very few people foresaw the need to provide for simultaneous input.  It was only when multi-core machines appeared that the operating systems began to build parallelism into their architecture. <br><br>  Just as the rudimentary organs of animals make their evolutionary history understand, the single-threaded origin of operating systems manifests itself when looking at how to scroll on the web.  Only if the operating system allows parallel input ‚Äî from a mouse, keyboard, or other device ‚Äî can browsers effectively optimize scrolling so that it is not affected by the lengthy execution of JavaScript that has trapped the main thread of execution. <br><br>  However, in the Microsoft Edge development team, we are making progress to ensure smooth and responsive scrolling, regardless of its method.  In EdgeHTML 14 (which is included with Windows 10 Anniversary Update), we support background scrolling for the following methods: <br><br><ul><li>  One finger, touchscreen </li><li>  Two fingers, touchpad </li><li>  Mouse wheel </li><li>  Scroll bar </li></ul><br>  If you compare Edge with other desktop browsers, you'll notice that only it supports asynchronous scrolling using the scroll bar, i.e., holding and moving the scroll slider with the mouse, clicking on the scroll bar or arrows.  (Actually, we presented this feature without the announcement back in the Anniversary Update!) <br><br>  According to the test results in Windows 10 (14393, Surface Book) and macOS Sierra (10.12, MacBook Air), we got the following results: <br><br><table width="624"><tbody><tr><th width="104"></th><th width="104">  Two finger touchpad </th><th width="104">  Tach </th><th width="104">  Mouse wheel </th><th width="104">  Scroll bar </th><th width="104">  Keyboard </th></tr><tr><td width="104">  Edge 14 (Windows) </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  Not </td></tr><tr><td width="104">  Chrome 56 (Windows) </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Firefox 51 (Windows) </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Chrome 56 (MacOS) </td><td width="104">  there is </td><td width="104">  N / A </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Firefox 51 (MacOS) </td><td width="104">  there is </td><td width="104">  N / A </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Safari 10.1 (MacOS) </td><td width="104">  there is </td><td width="104">  N / A </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td></tr></tbody></table><br>  As this table demonstrates <a href="https://habr.com/ru/post/325028/">*</a> , scrolling behavior can dramatically change from browser to browser, and even from one OS to another.  If you test one method of scrolling in only one browser, you will get very incomplete results of the performance of your site, compared to how users actually work with it! <br><br>  In general, it should be clear that scrolling has a special place on the web and browsers work very hard to make it fast and responsive.  However, there are subtle ways that a web developer can inadvertently disable browser optimizations.  Let's look at how web developers can influence the scrolling in the browser, in an amicable and bad way. <br><br><img src="https://habrastorage.org/files/b9a/6df/1e0/b9a6df1e03a84081b3080c888a4fdf66.png"><br><br><h1>  How listening processes interfere with scrolling </h1><br>  Background scrolling gives a tangible increase in efficiency - scrolling and JavaScript are completely separate, allowing them to work in parallel without interfering with each other. <br><br>  But everyone who has developed a little web page knows how to establish a connection between JavaScript and scrolling: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(‚Äúwheel‚Äù, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ e.preventDefault(); <span class="hljs-comment"><span class="hljs-comment">// oh no you don't! });</span></span></code> </pre> <br>  When we add the <i>wheel's</i> listening process, which calls <code>event.preventDefault()</code> , it blocks scrolling 100% for both the mouse wheel and the touchpad.  And obviously, if scrolling is blocked, then background scrolling is also blocked. <br><br>  The effect of such an example is less obvious: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(‚Äúwheel‚Äù, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'wheel!'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// innocent listener, not calling preventDefault() });</span></span></code> </pre> <br>  You may naively think that if a function does not call <code>preventDefault()</code> , then it cannot block scrolling at all or, in the worst case, blocks it only for the duration of the function itself.  However, the truth is that even an empty listening process completely blocks scrolling until <i>all</i> the JavaScript processes on this page are finished, which you can check out in <a href="http://bl.ocks.org/nolanlawson/raw/dc026a93b91cb448401bb0f1cb3ebad2/">this demo</a> . <br><br>  Listening to the mouse wheel does not interact with our large blocking JavaScript operation, but they have a common event loop, so the background thread must wait for the longer JavaScript operation to complete before it receives a response from the event listening function. <br><br>  Why should he wait?  Well, JavaScript is a dynamic programming language, and the browser cannot know for sure that <code>preventDefault()</code> will never be called.  Even if it‚Äôs obvious to the developer that the function is simply recording <code>console.log()</code> , browser developers prefer not to leave chances.  In fact, even an empty <code>function() {}</code> will cause the same effect. <br><br>  Please note that this applies not only to the mouse wheel: on touch devices, scrolling can also be blocked by listening to <i>touchstart</i> or <i>touchmove processes</i> . <br><br>  You need to be careful when adding listening events to the page, because they affect performance! <br><br>  There are several javascript APIs associated with scrolling, however they do not block scrolling.  The <i>scroll</i> event, although this is somewhat illogical, cannot block the scrolling, because it starts <i>after</i> scrolling, and therefore is irreducible.  Also, the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events">Pointer Events API</a> , introduced in IE and Microsoft Edge, and which has recently begun to be implemented in Chrome and Firefox, was originally designed to avoid inadvertently blocking scrolling. <br><br>  Even in cases when we really need to listen to <i>wheel</i> or <i>touchstart events</i> , there are certain tricks on how web developers can guarantee the scrolling operation with maximum quality.  Look at some of these tricks. <br><br><img src="https://habrastorage.org/files/d78/355/91f/d7835591fb444da8bc1856124975de95.png"><br><br><h1>  Global and local listening processes </h1><br>  In the previous example, we saw a case of a global listening process (that is, attached to a <i>window</i> or <i>document</i> ).  But what about listening processes for individual scrolling elements? <br><br>  In other words, imagine the page for which scrolling works, but on the page there is a separate area with its own independent scrolling.  Does the browser block scrolling for the entire page if you add a listening process only in this area? <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'scrollableDiv'</span></span>) .addEventListener(‚Äúwheel‚Äù, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// In theory, I can only block scrolling on the div itself! });</span></span></code> </pre> <br>  If you check on a <a href="http://bl.ocks.org/nolanlawson/raw/4079c1b7dff33fddfb8cf4cbe2c79b98/">simple demo page</a> , you will notice that Microsoft Edge and Safari will leave a smooth scrolling for the whole document if the listening process for scrolling is in a div with independent scrolling. <br><br>  Here is a table of browsers and their behavior: <br><br><table width="624"><tbody><tr><th width="104"></th><th width="104">  Two finger touchpad </th><th width="104">  Tach </th><th width="104">  Mouse wheel </th><th width="104">  Click-and-drag </th><th width="104">  Keyboard </th></tr><tr><td width="104">  Desktop Edge 14 (Windows) </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  there is </td><td width="104">  Not </td></tr><tr><td width="104">  Desktop Chrome 56 (Windows) </td><td width="104">  Not </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Desktop Firefox 51 (Windows) </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Desktop Chrome 56 (MacOS) </td><td width="104">  Not </td><td width="104">  N / A </td><td width="104">  Not </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Desktop Firefox 51 (MacOS) </td><td width="104">  there is </td><td width="104">  N / A </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td></tr><tr><td width="104">  Safari 10.1 (MacOS) </td><td width="104">  there is </td><td width="104">  N / A </td><td width="104">  there is </td><td width="104">  Not </td><td width="104">  Not </td></tr></tbody></table><br>  The results show <a href="https://habr.com/ru/post/325028/">*</a> that there are optimizations available for web developers to benefit from these browser features.  Instead of using wheel / touch listening processes for the entire document, it is preferable to add listening processes to a <i>specific subsection of the document</i> , so the scrolling will remain smooth for all other parts of the page.  In other words, instead of delegating wheel / touchstart listening processes to the highest possible level, it is best to isolate them for the element where it is needed. <br><br>  Unfortunately, not all JavaScript frameworks allow this practice - in particular, React, as a rule, adds a global listening process to the entire document, even if it should apply only to part of the page.  However, there is <a href="https://github.com/facebook/react/issues/1254">an open ticket</a> specifically for this problem, and the React guys said that they will gladly accept a pull request.  (Respect the guys from React, who so quickly responded to <a href="https://github.com/facebook/react/issues/1254">our proposal</a> ) <br><br><img src="https://habrastorage.org/files/543/322/18d/54332218d21a48e49f5509dcb9272f6f.png"><br><br><h1>  Passive listening process </h1><br>  Avoiding global wheel / touchstart listening processes is a good practice, but sometimes this is simply not possible, depending on the effect you are trying to achieve.  And in some ways it looks silly that simply listening to events causes the browser to stop the whole world, simply because there is a hypothetical probability of calling <code>PreventDefault()</code> , and it is waiting for it. <br><br>  Fortunately, a new feature began to appear in browsers when web developers can explicitly mark the listening process as ‚Äúpassive‚Äù and therefore avoid waiting: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(‚Äúwheel‚Äù, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Not calling preventDefault()! }, { passive: true } // I pinkie-swear I won't call preventDefault() );</span></span></code> </pre> <br>  With this approach, the browser will handle the scrolling as if the <i>wheel</i> listening process is completely absent.  This feature is <a href="http://caniuse.com/">already available</a> in the latest versions of Chrome, Firefox and Safari, and <a href="https://developer.microsoft.com/microsoft-edge/platform/status/passiveeventlisteners/">should soon appear in the future release of Microsoft Edge</a> .  (Please note that you need to use <a href="">feature detection</a> to support browsers that do not recognize passive listening processes). <br><br>  For some events (including <i>touchstart</i> and <i>touchmove</i> ), Chrome from version 56 decided to interfere and made them <a href="https://www.chromestatus.com/features/5093566007214080">passive by default</a> .  Keep in mind this slight difference between browsers when adding listening processes! <br><br><img src="https://habrastorage.org/files/e05/0db/8b6/e050db8b6ec849c2bd6f52db4301e32c.png"><br><br><h1>  Conclusion </h1><br>  As we have seen, scrolling on the web is a fantastically complex process, and all browsers are at different stages of improving their performance.  But in general, we can formulate some clear tips for web developers. <br><br>  First, it is better not to add the <i>wheel</i> or <i>touch</i> listening processes to the global <i>document</i> or <i>window</i> objects, but instead to add them to smaller elements with individual scrolling.  Developers should also use passive listening processes, wherever possible, using <a href="">feature detection</a> to avoid compatibility issues.  Using Pointer Events (there is a <a href="https://github.com/jquery/PEP">polyfill there</a> ) and <i>scroll</i> listening events are also a sure way to avoid inadvertently blocking scrolling. <br><br>  I hope this article has provided some useful tips for web developers and allowed a glimpse of what browsers have under the hood.  Without a doubt, as browsers develop and the web grows, the scrolling mechanics will become even more complex and sophisticated. <br><br>  Our Microsoft Edge team will continue to innovate in this area to ensure smooth scrolling for more sites and users.  Let's say this for a modest scrollbar - the oldest and ambiguous interaction on the web! <br><br> <font color="gray"><a name="1"></a></font>  <font color="gray">* Results are obtained on the latest version of each browser in February 2017.</font>  <font color="gray">Since then, Firefox 52 has updated support for scrolling, and now matches the behavior of Edge 14 in all tests, with the exception of scrolling by the scroll bar.</font>  <font color="gray">Hopefully, other browsers will also make scrolling improvements and make the web faster and more responsive!</font> </div><p>Source: <a href="https://habr.com/ru/post/325028/">https://habr.com/ru/post/325028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325014/index.html">The company has more similar jobs</a></li>
<li><a href="../325016/index.html">Little tricks DirectX and HLSL</a></li>
<li><a href="../325018/index.html">‚ÄúSim-Sim, open!‚Äù, Or how to open a link via RemoteApp</a></li>
<li><a href="../325022/index.html">The new chip from Applied Micro is ready to contend with Intel Xeon</a></li>
<li><a href="../325026/index.html">Infrastructure organization with the help of Kubernetes and Helm. Video recordings of reports from Kubernetes meetup March 22, 2017</a></li>
<li><a href="../325030/index.html">7 questions that you ask at the interview for the position of UX designer</a></li>
<li><a href="../325032/index.html">How shops lure customers: electronic price tags</a></li>
<li><a href="../325034/index.html">IL2CPP: Garbage Collector Integration</a></li>
<li><a href="../325036/index.html">Regular expression search with suffix array</a></li>
<li><a href="../325040/index.html">Good trigger, bad trigger: how we monitor hundreds of servers around the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>