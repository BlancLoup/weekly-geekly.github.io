<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebGL-wind and GPU programming. Lecture on FrontTalks 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To draw complex graphics on web pages, there is a Web Graphics Library, abbreviated WebGL. Interface developer Dmitry Vasilyev spoke about programming...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebGL-wind and GPU programming. Lecture on FrontTalks 2018</h1><div class="post__text post__text-html js-mediator-article">  To draw complex graphics on web pages, there is a Web Graphics Library, abbreviated WebGL.  Interface developer Dmitry Vasilyev spoke about programming the GPU from the point of view of the layout designer, what WebGL is and how this technology solved the problem of visualizing large weather data. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-yvY4-ovavo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - I am developing interfaces in the Ekaterinburg office of Yandex.  I started in the group Sport.  We were developing sports special projects, when there were the World Championships in hockey, football, the Olympics, the Paralympics and other cool events.  I also worked on the development of a special search results, which was dedicated to the new Sochi highway. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/5p/l2/e_/5pl2e_nhpyefyjt0q3wfspflpyc.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/qw/zy/xd/qwzyxdlvu0jukewd-9prrerk-a8.jpeg"><br><br><img src="https://habrastorage.org/webt/uy/7b/mp/uy7bmpkufgne4mck5yiawv3mj1o.jpeg"><br><br><img src="https://habrastorage.org/webt/q6/cu/kw/q6cukwvmpmwru6iew_ranhk7mwo.jpeg"><br><h5>  <sub><sup><a href="http://api.weather.yandex.ru/">Link from the slide</a></sup></sub> </h5><br>  In addition, in one and a half helmets, we restarted the service Work on the bugs.  And then work began in Weather, where I was engaged in supporting the API functionality, its development, writing the infrastructure around this API, and writing node binding to the trained machine learning formulas. <br><br><img src="https://habrastorage.org/webt/sz/xs/zy/szxszynumbssi9qyhkxwalfmsdy.jpeg"><br><br>  Then the work began more interesting.  He participated in the redesign of our weather services.  Desktop, tachi. <br><br><img src="https://habrastorage.org/webt/io/q4/cw/ioq4cwweh1vbjyqonlto5yuo_1e.jpeg"><br><br><img src="https://habrastorage.org/webt/ij/er/w6/ijerw62hpfkj2kvph4wvuag_www.jpeg"><br><br>  After we brought the standard projections in order, we decided to make one that no one has.  This forecast was a forecast of the movement of precipitation in the territories. <br><br><img src="https://habrastorage.org/webt/xc/n_/cf/xcn_cfakd_xnyoxaazxgc4bvmso.jpeg"><br><br>  There are special meteorological radars that detect precipitation within a radius of 2,000 km, they know their density and distance to them. <br><br><img src="https://habrastorage.org/webt/as/ea/av/aseaavvwl0v3lqhex1kx_dvsr1w.jpeg"><br><br>  Using this data and predicting their further movement using machine learning, we made <a href="https://habr.com/company/yandex/blog/317626/">such visualization</a> on the map.  You can move back and forth. <br><br><img src="https://habrastorage.org/webt/jt/qo/fj/jtqofjz8eo8wrjybcydczpxse0a.jpeg"><br><h5>  <sub><sup><a href="https://pikabu.ru/tag/%25D0%25AF%25D0%25BD%25D0%25B4%25D0%25B5%25D0%25BA%25D1%2581%2520%25D0%25BF%25D0%25BE%25D0%25B3%25D0%25BE%25D0%25B4%25D0%25B0">Link from the slide</a></sup></sub> </h5><br>  We looked at the reviews of people.  People liked it.  All kinds of memesics began to appear, and there were cool pictures when Moscow was flooded. <br><br>  Since everyone liked the format, we decided to move on and devote the next forecast to the wind. <br><br><img src="https://habrastorage.org/webt/kl/mc/_f/klmc_fqnedxn-okos6d6bhmlszs.jpeg"><br><br>  Services that show the forecast of the wind, is already there.  This is a pair of cool, particularly prominent. <br><br><img src="https://habrastorage.org/webt/vo/vc/4k/vovc4kev5lhxvyph9t46z4uhei8.jpeg"><br><br>  Looking at them, we realized that we wanted to do the same - or, at least, not worse. <br><br>  Therefore, we decided to visualize particles that smoothly move around the map, depending on the wind speed, and leave some trail behind them so that they can be seen, the wind path can be seen. <br><br>  Since we already did a great job and made a cool rainfall map using 2D canvas, we decided to do the same with particles. <br><br><img src="https://habrastorage.org/webt/hz/jd/yi/hzjdyivbulbjmfod7n2-nix8uca.jpeg"><br><br>  After consulting with the designer, we realized that we need approximately 6% of the screen to be filled with particles in order to have a cool effect. <br><br>  To draw such a number of particles with a standard approach, we have a minimum timing of 5 ms. <br><br><img src="https://habrastorage.org/webt/yu/l1/7n/yul17ngn7dfm6cadtcy2dpkf6zu.jpeg"><br><br>  If we think that we still need to move the particles and impose some kind of beauty like drawing the tail of the particles, we can assume that we will fall out for a minimum timeout of 40 ms to show a smooth animation to produce at least 25 frames per second. <br><br>  The problem is that here each particle would be processed sequentially.  But what if you process them in parallel? <br><br>  A visual difference in the work of the central and graphic processor was shown by the ‚ÄúDestroyers of Legends‚Äù at one of the conferences.  They rolled out a typewriter on which a paintball marker was installed, the task of which was to draw a smiley with one color.  In about 10 seconds, he drew such a picture.  ( <a href="https://youtu.be/-P28LKWTzrI">Link to video</a> - Ed.) <br><br><img src="https://habrastorage.org/webt/kk/pi/cw/kkpicwfdskxnicbu0jb7sowhgfq.jpeg"><br><br><img src="https://habrastorage.org/webt/zd/ka/3a/zdka3al72tgfcavb5yvww_qx2ug.jpeg"><br><br><img src="https://habrastorage.org/webt/i9/tm/kh/i9tmkhykoiz8vkim-vzftxjjl44.jpeg"><br><br>  Then the guys rolled out the canoe, which is a GPU, and a couple of spits drew Mona Lisa.  Approximately the speed of computing CPU and GPU is different. <br><br><img src="https://habrastorage.org/webt/dm/x-/hc/dmx-hckqzdlztdat2wm-j88cj-k.jpeg"><br><br><img src="https://habrastorage.org/webt/zg/pa/3m/zgpa3m281vzirvjqotbuoqnmms8.jpeg"><br><br><img src="https://habrastorage.org/webt/hq/lf/uj/hqlfujoqgr4mhgxucjpx7xnmedu.jpeg"><br><br><img src="https://habrastorage.org/webt/qb/zo/xz/qbzoxzq0tywqxi0pc2xifdnvnds.jpeg"><br><br><img src="https://habrastorage.org/webt/d6/z5/kq/d6z5kq5c23fjmb2uzfx4aqqj3ec.jpeg"><br><br>  To take advantage of such features in the browser, the technology WebGL was invented. <br><br>  What it is?  With this question I got into the Internet.  Having added a couple of words with particle animation and wind, I found a couple of articles. <br><br><img src="https://habrastorage.org/webt/ob/d-/w_/obd-w_edp80lvmzlh3xmh437itw.jpeg"><br><h5>  <sub><sup>Links from the slide: <a href="https://blog.mapbox.com/how-i-built-awind-map-with-webgl-b63022b5537f">first</a> , <a href="https://nullprogram.com/blog/2014/06/29/">second</a></sup></sub> </h5><br>  One of them is a demo of Vladimir Agafonkin, an engineer from Mapbox, who made the wind on WebGL and referred to the blog of Chris Wellas who talked about how to move and store the state of particles on the GPU. <br><br>  We take and copy.  We expect this result.  Here the particles move smoothly. <br><br><img src="https://habrastorage.org/webt/s6/5t/7-/s65t7-020jphv-fvyzbk5vpkmoq.jpeg"><br><br>  We get do not understand what. <br><br><img src="https://habrastorage.org/webt/7n/8i/t1/7n8it1gwmfklms2akt9nydmgima.jpeg"><br><br>  We are trying to deal with the code.  We improve, again we get an unsatisfactory result.  We climb even deeper - we get rain instead of wind. <br><br><img src="https://habrastorage.org/webt/n4/bd/b1/n4bdb1-ar38mb8lokfjfgjqbrue.jpeg"><br><br>  Okay, we decide to do it yourself. <br><br><img src="https://habrastorage.org/webt/lw/ue/kv/lwuekvj_c1996sjj2q1c2fl4pyk.jpeg"><br><br>  To work with WebGL, there are frameworks.  Almost all of them are aimed at working with 3D-objects.  We do not need these 3D features.  We only need to draw a particle and move it.  Therefore, we decide to do everything by hand. <br><br><img src="https://habrastorage.org/webt/rt/db/4z/rtdb4zokw74ivcedzljp4t3fu_g.jpeg"><br><br>  There are currently two versions of the WebGL technology.  The second version, which is cool, has a high modern version of the programming language in which the program runs in the graphics adapter, can perform straightforward computations, and not just rendering.  But it has poor compatibility. <br><br><img src="https://habrastorage.org/webt/yk/gr/ty/ykgrtypkwclnix0f4pat1retheu.jpeg"><br><br>  Well, we decide to use the old proven WebGL 1, which has good support, except Opera Mini, which nobody needs. <br><br><img src="https://habrastorage.org/webt/sr/1q/xr/sr1qxr_ch7enl9z1rjwuv1hshpg.jpeg"><br><br>  WebGL is a two-piece thing.  This is JS, which executes the state of the programs that run on the graphics card.  And there are components that run right on the graphics card. <br><br>  Let's start with JS.  WebGL is just the appropriate context for the canvas element.  Moreover, upon receiving this context, it is not just a specific object that is allocated, iron resources are allocated.  And if we run something beautiful on WebGL in the browser, and then decide to play Quake, then it is quite possible that these resources will be lost, and the context may be lost, and your entire program will break. <br><br><img src="https://habrastorage.org/webt/y3/bm/p0/y3bmp0fddy1vkxkktxantfrfcdw.jpeg"><br><br>  Therefore, when working with WebGL, you also need to listen to the loss of context and be able to restore it.  Therefore, I stressed that init is. <br><br><img src="https://habrastorage.org/webt/aj/iu/zk/ajiuzkpsukwyhrhvte4oduqivri.jpeg"><br><br>  Then all the work of JS is to assemble programs that run on the GPU, send them a graphic card, set some parameters and say ‚Äúdraw‚Äù. <br><br><img src="https://habrastorage.org/webt/3k/2m/zd/3k2mzdhdejzpaxjrx_upik6fdeu.jpeg"><br><br>  In WebGL, if you look at the context element itself, you see a bunch of constants.  These constants mean references to addresses in memory.  They are not really constants in the process of the program.  Because if the context is lost and restored again, another address pool can be allocated, and these constants will be different for the current context.  Therefore, almost all operations in WebGL on the JS side are performed through utilities.  Nobody wants to do the routine work of searching for addresses and other garbage. <br><br><img src="https://habrastorage.org/webt/ii/o7/sa/iio7sahs5z0gt5bccxesgiict44.jpeg"><br><br>  We proceed to what is performed on the video card itself - a program consisting of two sets of instructions written in C-like language GLSL.  These instructions are called the vertex shader and the fragment shader.  A program is created from their pair. <br><br><img src="https://habrastorage.org/webt/qg/fu/lb/qgfulbs6almqwpkmutcsxv38-cm.jpeg"><br><br>  What is the difference between these shaders?  The vertex shader sets the surface on which something should be drawn.  After the primitive is set, which needs to be painted over, a fragment shader is called that falls into this range. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br><img src="https://habrastorage.org/webt/u7/vi/qb/u7viqbviwm76x4ovlvion5mm2o8.jpeg"><br><br>  In the code, it looks like this.  In the shader there is a section for declaring variables that are set outside, from JS, their type and name are determined.  And also the main section, which executes the code needed for this iteration. <br><br>  The vertex shader is in most cases expected to set the gl_Position variable to some coordinate in four-dimensional space.  This is x, y, z and the width of the space, which is not really necessary to know at the moment. <br><br>  The fragment shader waits for a particular pixel to be set to color. <br><br>  In this example, our pixel color is selected from the attached texture. <br><br><img src="https://habrastorage.org/webt/y8/nw/1y/y8nw1y1gnwstkv2rgqxatduyuni.jpeg"><br><br>  To transfer it to JS, it is enough to wrap the source code of the shaders in variables. <br><br><img src="https://habrastorage.org/webt/ax/fz/ou/axfzouj0xwui47sftwgdhlcadd0.jpeg"><br><br>  Further, these variables are converted to shaders.  This is a WebGL context, we create shaders from source codes, in parallel we create a program, we tie a pair of shaders on the program.  We get a workable program. <br><br>  Along the way, we check that the shader compilation was successful, that the program was successfully assembled.  We say that you need to use this program, because there may be several programs for different drawing values. <br><br>  We configure it, and we say to draw.  It turns out some kind of picture. <br><br><img src="https://habrastorage.org/webt/oz/py/ri/ozpyrifyoft_invjrawmmz-_fjg.jpeg"><br><br>  Crawled deeper.  In the vertex shader, all calculations are performed in a space from -1 to 1, regardless of how large your output point is.  For example, a space from -1 to 1 can occupy the entire screen of 1920x1080. To draw a triangle in the center of the screen, you need to draw a surface that covers the coordinate 0, 0. <br><br><img src="https://habrastorage.org/webt/4q/yp/ex/4qypexiothorcvzkrk9y_p5v9tk.jpeg"><br><br>  The fragment shader works in the space from 0 to 1, and the colors here are given out by four components: R, G, B, Alpha. <br><br>  On the example of CSS, you might encounter a similar color record if you use percentages. <br><br><img src="https://habrastorage.org/webt/ys/cn/kn/yscnkn-8x_yg0bl_zknm-42l17q.jpeg"><br><br>  To draw something, you need to say what data you need to draw.  Specifically for a triangle, we define a typed array of three vertices, each consisting of three components, x, y, and sufficient. <br><br>  For such a case, the vertex shader looks like getting the current pair of points, coordinates, as well as setting this coordinate on the screen.  Here, as it is, without transformations, we put a full stop on the screen. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br>  The fragment shader can color out the constants passed from JS, also without additional calculations.  Moreover, if some variables in the fragment shader are transmitted from the outside or from the previous shader, then you need to specify the accuracy.  In this case, the average accuracy is enough, and almost always it is enough. <br><br><img src="https://habrastorage.org/webt/dx/9v/jb/dx9vjbxuiz_swlbl1hlmlb5hmys.jpeg"><br><br>  Go to JS.  We assign the same shaders to variables and declare the function that will create these shaders.  That is, a shader is created, the source is poured into it, and then compiled. <br><br><img src="https://habrastorage.org/webt/jf/x3/eg/jfx3eg-hhqsdbmpc378peyi6tym.jpeg"><br><br>  Make two shaders, vertex and fragment. <br><br><img src="https://habrastorage.org/webt/jh/pb/um/jhpbumsovp4-rkstmx9dldtg7ug.jpeg"><br><br>  After that, we create a program, upload already compiled shaders.  We link the program, because shaders can exchange variables between each other.  And at this stage, the correspondence of the types of variables that these shaders exchange is checked. <br><br>  We say that use this program. <br><br><img src="https://habrastorage.org/webt/7i/hm/rc/7ihmrctum2gyy9cuybn5pr6hcbu.jpeg"><br><br>  Next we create a list of vertices that we want to visualize.  There is an interesting feature in WebGL for some variables.  To change a specific data type, you need to set a global context for editing array_buffer, and then upload something to this address.  There is no explicit assignment of any data to a variable.  Here everything is done through the inclusion of some context. <br><br>  You must also set the rules for reading from this buffer.  It can be seen that we specified an array of six elements, but the program needs to be explained that each vertex consists of two components, the type of which is float, this is done in the last line. <br><br><img src="https://habrastorage.org/webt/js/_j/qe/js_jqevmwlq0fmo_n6-vbdwsr-k.jpeg"><br><br>  To set the color, the program searches for the address for the variable u_color and sets the value for this variable.  We set the color, red 255, 0.8 from green, 0 blue and completely opaque pixel - it turns yellow.  And we say to execute this program using triangle primitives, in WebGL you can draw points, lines, triangles, triangles of complex shape, and so on.  And make three peaks. <br><br><img src="https://habrastorage.org/webt/lk/pz/xe/lkpzxe_tur-bgozsoj47kohstty.jpeg"><br><br>  You can also specify that the array, on which we perform the drawing, should be considered from the very beginning. <br><br><img src="https://habrastorage.org/webt/p4/1f/_k/p41f_kioprwkxx7ommkzz7tcclw.jpeg"><br><h5>  <sub><sup><a href="https://vaseker.github.io/whatever/webgl-colorwheel.html">Link from the slide</a></sup></sub> </h5><br>  If you slightly complicate the example, you can add color dependence on the position of the cursor.  At the same time fps rolls over. <br><br><img src="https://habrastorage.org/webt/sl/eu/zl/sleuzlnxn8s1tlflhawo5obsrg8.jpeg"><br><br>  To draw particles all over the world, you need to know the wind speed at every point of this world. <br><br>  To increase and somehow move the map, you need to create containers that correspond to the current position of the map. <br><br>  To move the particles themselves, you need to come up with a data format that could be updated using a graphics processor.  Make drawing and loop drawing itself. <br><br><img src="https://habrastorage.org/webt/2o/vf/o_/2ovfo_hqaimoyygbbcpkbupf_cu.jpeg"><br><br>  All the data we do through teksturku.  We use 22 channels to determine horizontal and vertical speeds, where zero wind speed corresponds to the middle of the color range.  This is about 128.  Since the speed can be negative and positive, we set the color relative to the middle of the range. <br><br>  It turns out this picture. <br><br><img src="https://habrastorage.org/webt/3-/qu/i8/3-qui8mkzufp6hucltuzpampili.jpeg"><br><br>  To load it on the map, we need to cut it.  To connect the image to the map, we use the standard Yandex.Map Layer tool, in which we determine the address from which to get the cut tiles, and add this layer to the map. <br><br><img src="https://habrastorage.org/webt/jo/zj/a8/jozja8duysio2wljyezgjnhfn64.jpeg"><br><h5>  <sub><sup><a href="https://tech.yandex.ru/maps/doc/jsapi/2.1/ref/reference/Layer-docpage/">Link from the slide</a></sup></sub> </h5><br>  We get a picture where the unpleasant green color is the coded wind speed. <br><br><img src="https://habrastorage.org/webt/uh/nk/jh/uhnkjh1e8sxzgzp-myix3xxyjn4.jpeg"><br><br>  Next you need to get a place in which we will draw the animation itself, while this place must correspond to the coordinates of the map, its movements and other actions. <br><br>  By default, we can assume that we would use the Layer, but the card Layer creates a canvas, from which it immediately captures the 2D context, which it turns out to capture.  But if we try to take from the canvas, which already has a context of another type, and take the GL context from it, we will end up with null.  If you turn to it, the program crashes. <br><br><img src="https://habrastorage.org/webt/lg/9a/mn/lg9amncxtx9ndmnc7bjqkzcs_lw.jpeg"><br><h5>  <sub><sup><a href="https://tech.yandex.ru/maps/doc/jsapi/2.1/ref/reference/pane.MovablePane-docpage/">Link from the slide</a></sup></sub> </h5><br>  Therefore, we used Pane, these are containers for layers, and added our canvas there, from which we have already taken the context we need. <br><br><img src="https://habrastorage.org/webt/v9/on/pb/v9onpb5gnorqq05kg0og8bd6wvq.jpeg"><br><br>  In order to somehow place the particles on the screen and be able to move them, the format of the position of the particles in the texture was used. <br><br>  How it works?  It creates a square texture for optimization, and here the size of its side is known. <br><br><img src="https://habrastorage.org/webt/ov/hm/qg/ovhmqgdfgbzg3k5wua7se3l-scm.jpeg"><br><br>  By drawing the particles in order and knowing the sequence number of the particles and the size of the texture in which they are stored, you can calculate the specific pixel in which the position is encoded on the real screen. <br><br><img src="https://habrastorage.org/webt/xw/6c/ly/xw6clysjjqrtppxzih0cm4q3sis.jpeg"><br><br><img src="https://habrastorage.org/webt/a_/jt/9m/a_jt9ml9jdjn0vxxk7riv9sbkw8.jpeg"><br><br>  In the shader itself, it looks like reading a rendered index, a texture with the current position of the particles and the size of the side.  Next, we determine the x, y coordinates for this particle, read this value, and decode it.  What is this magic: rg / 255 + ba? <br><br>  For the position of the particles we use 20 double channels.  The color channel has a value from 0 to 255, and for a 1080 screen for some we cannot put particles at any position on the screen, because we can put a maximum of a particle at 255 pixels.  Therefore, in one channel we store the knowledge of how many times a particle has passed 255 pixels, and in the second channel we store the exact value of how much it has passed after. <br><br>  Next, the vertex shader must convert these values ‚Äã‚Äãto its work space, that is, from -1 to 1, and set this point on the display. <br><br><img src="https://habrastorage.org/webt/g2/ht/g_/g2htg_vqu8k5fdnn_zx6xtl82fs.jpeg"><br><br>  To just look at our particles, it is enough to paint them in white.  There is such a sugar in GLSL that if we define the type of a variable and pass it into a constant, then this constant will be distributed over all four components, for example. <br><br><img src="https://habrastorage.org/webt/ee/h-/hz/eeh-hzn9oaitmm7k7gwfpzin8rq.jpeg"><br><br>  Having drawn such a program, we see a set of identical squares.  Let's try to add them beauty. <br><br><img src="https://habrastorage.org/webt/-r/ud/i1/-rudi16ytlwsw-_fvafdhqmqync.jpeg"><br><br>  First, add the dependence of these squares on the current wind speed.  We simply read the current speed and the corresponding textures for each particle.  We obtain the length of the vector, which corresponds to the absolute velocity at a point, and add this velocity to the particle size. <br><br><img src="https://habrastorage.org/webt/or/v-/qs/orv-qs0vwvlrcxadmlpvbywokdw.jpeg"><br><br>  Further, in order not to draw the squares, in the fragment shader, we cut off all the pixels that fall outside the radius, which are not included in the radius of the inscribed circle.  That is, our shader turns into such a thing. <br><br><img src="https://habrastorage.org/webt/t4/rx/ah/t4rxahmunedzb3k0jamjxiikvia.jpeg"><br><br>  Calculate the distance to draw the pixel from the center.  If it exceeds half the space, then we do not show it. <br><br><img src="https://habrastorage.org/webt/nr/do/ma/nrdomaus-zdhgroynefo3qacxck.jpeg"><br><br>  We get a more diverse picture. <br><br>  Next you need to somehow move these things.  Since WebGL 1 does not know how to calculate something, work directly with data, we will use the possibilities of drawing programs into special components, frame buffers. <br><br>  Frame buffers can bind, for example, textures that can be updated.  If the frame buffer is not declared, then the default drawing is performed on the screen. <br><br>  By switching the output from one position texture to another, we can update them one by one and then use them for drawing. <br><br><img src="https://habrastorage.org/webt/j7/-j/tn/j7-jtnjwzj-8pav52t-ngiolwji.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/me/ey/8ymeey1havzw-wavn5x8ztr87em.jpeg"><br><br>  The very procedure of updating the position looks like this: read the current position, add up with the current velocity vector and fold, encode in a new color. <br><br><img src="https://habrastorage.org/webt/t7/up/wj/t7upwjpzr8ubgig0cwr1_hn7npa.jpeg"><br><br>  In the code, it looks like reading the current position, decoding, reading the current speed, bringing the speed to a normal form, folding the two components, encoding in color. <br><br><img src="https://habrastorage.org/webt/uo/cc/qo/uoccqo8i2fubmgay3oi90teclzw.jpeg"><br><br>  It turns out this picture.  We are constantly changing the state of the particles, and there is some kind of animation. <br><br>  If such an animation is run for 5‚Äì10 minutes, it will be seen that all particles will arrive at their final destination.  They all slide into the funnel.  It turns out this picture. <br><br><img src="https://habrastorage.org/webt/be/m0/bx/bem0bxbrxar_it9lgdjdc2fk91y.jpeg"><br><br>  To avoid this, we introduce the particle permutation factor in a random place. <br><br>  It depends on the current wind speed, on the current position of the particle and the random number that we transmit from JS - because in the first version of WebGL there is no randomization function built in and some noise-functions. <br><br><img src="https://habrastorage.org/webt/zt/ur/_b/ztur_bhp_epcyqk1kzaz9b1r0a0.jpeg"><br><br>  In this example, we calculate the predicted position of the particle, the random position, and choose either one or the other, depending on the reset factor. <br><br><img src="https://habrastorage.org/webt/6o/qq/m8/6oqqm8iswgovcsguseunzhwxauc.jpeg"><br><h5>  <sub><sup>Links from the slide: <a href="https://webglfundamentals.org/">first</a> , <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/index.php">second</a> , <a href="https://nullprogram.com/blog/2014/06/29/">third</a> , <a href="https://blog.mapbox.com/how-i-built-a-wind-map-with-webgl-b63022b5537f">fourth</a></sup></sub> </h5><br>  To understand what was on the last slide, you can read these articles.  The first provides a huge boost in understanding what WebGL gives, what it consists of and how not to err in it.  At Khronos, this is the group that develops the standard, there is a description of all the functions. <br><br><img src="https://habrastorage.org/webt/5u/qi/st/5uqistm5t05pqha9xfm1oqdnxfu.jpeg"><br><br>  The last point of our task is to draw a trace from the particles.  To do this, we will record the current position on the screen in two textures, and display the current position on the screen, slightly increasing its transparency, overlay the new position of the particles, then increase the transparency of this image and more impose a new position on top. <br><br><img src="https://habrastorage.org/webt/es/-8/oa/es-8oakhvm9ds8uh-e7teuivgnk.jpeg"><br><br>  We get this animation plume. <br><br><img src="https://habrastorage.org/webt/qv/2s/hi/qv2shigmfokikarpx9kzdx0vsck.jpeg"><br><br><img src="https://habrastorage.org/webt/mu/3s/x2/mu3sx2aovopotm_gnyln8to95rm.jpeg"><br><br>  If you compare the full cycle of drawing WebGL with the output of some points on the screen using 2D canvas, you can see a big gap in speed.  To draw 64 thousand points on 2D canvas, it takes an average of 25 ms, while WebGL blocks the main stream for 0.3 ms.  This is a difference of a hundred times. <br><br>  Thus, the use of WebGL allows you to less block the flow of the foundation, and this is especially important when working with the card when the high responsiveness of the card itself is important. <br><br>  Initially, all developers are probably used to using the browser console to put some break points, console logs and see what is going on inside.  WebGL is a black box. <br><br><img src="https://habrastorage.org/webt/6l/ke/u_/6lkeu_xuquuzt8pjc1uj8ckv1fa.jpeg"><br><br>  But there are some tools that allow you to work with him.  For example, Firefox has a built-in ‚Äúshaders‚Äù tab, where you can find WebGL banners on the fly, extract programs from them, extract shaders from them, and change values ‚Äã‚Äãon the fly.  For example, here on the fly the color of dots from white turns to blue. <br><br><img src="https://habrastorage.org/webt/w1/0j/vs/w10jvskiqvyvfrvhqwr4mpnu2uk.jpeg"><br><br>  The second tool that makes life a lot easier is the Spector.js browser extension.  It also captures the canvas from the WebGL context and allows you to see all the operations performed on this canvas, timings, and passed variables. <br><br><img src="https://habrastorage.org/webt/o-/gm/sa/o-gmsa_uu9gddh7qzrept9418ne.jpeg"><br><br>  Total for the week of work we got a <a href="https://yandex.ru/pogoda/moscow/maps/wind%3Ffrom%3Dhome">ready-made solution</a> to the wind from scratch.  Hopefully, I was able to tell what kind of technology it is, WebGL, what it consists of, and give a real example of its use in sales.  That's all. </div><p>Source: <a href="https://habr.com/ru/post/433278/">https://habr.com/ru/post/433278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433268/index.html">Telegram client in PHP (and receiving messages using MadelineProto)</a></li>
<li><a href="../433270/index.html">MapStruct problem solution with ManyToMany</a></li>
<li><a href="../433272/index.html">Interview with David Gobel</a></li>
<li><a href="../433274/index.html">Oleg Dokuka on reactive development on jug.msk.ru</a></li>
<li><a href="../433276/index.html">About the advantages of embedding CSS in JS</a></li>
<li><a href="../433280/index.html">Conference DEFCON 18. Troll reverse engineering using mathematics</a></li>
<li><a href="../433282/index.html">Gateway industrial exchange protocols on Linux. Gather yourself</a></li>
<li><a href="../433286/index.html">10 nearest IT meetings and hackathons in Moscow</a></li>
<li><a href="../433288/index.html">Web Security: an introduction to HTTP</a></li>
<li><a href="../433292/index.html">The digest of interesting materials for the mobile developer # 279 (December 10 - 16)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>