<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why you should use pathlib</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: Hi, habr! I present to you the translation of the article Why you should be using pathlib and its continuation, No really, pathli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why you should use pathlib</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>From the translator: Hi, habr!</em>  <em>I present to you the translation of the article <a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/">Why you should be using pathlib</a> and its continuation, <a href="https://treyhunner.com/2019/01/no-really-pathlib-is-great/">No really, pathlib is great</a> .</em>  <em>Much attention is now paid to such Python features as asyncio, the operator: =, and optional typing.</em>  <em>At the same time, the risk of passing through the radar is not so significant (although,: = a language is not turned serious), but very useful innovations in the language.</em>  <em>In particular, I did not find articles on sabzh in Habr√© (except for one paragraph <a href="https://habr.com/ru/company/ruvds/blog/452564/">here</a> ), so I decided to correct the situation.</em> </p><br><p> When I discovered the then new <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> module a few years ago, I decided, by the simplicity of my soul, that this is just a slightly awkward object-oriented version of the <code>os.path</code> module.  I was wrong.  <code>pathlib</code> is really <a href="https://jefftriplett.com/2017/pathlib-is-wonderful/">wonderful</a> ! </p><br><p>  In this article I will try to make you fall in love with the <code>pathlib</code> .  I hope that this article will inspire you to <strong>use <code>pathlib</code> in any situation related to working with files in Python</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://habr.com/ru/post/453862/">Part 1.</a> <br><ul><li>  <a href="https://habr.com/ru/post/453862/"><code>os.path</code> clumsy</a> </li><li>  <a href="https://habr.com/ru/post/453862/"><code>os</code> overloaded</a> </li><li> <a href="https://habr.com/ru/post/453862/"><code>   glob</code></a> </li> <li>  <a href="https://habr.com/ru/post/453862/"><code>pathlib</code> makes simple things even easier</a> </li><li>  <a href="https://habr.com/ru/post/453862/">Path objects make your code more obvious.</a> </li><li>  <a href="https://habr.com/ru/post/453862/"><code>    pathlib</code> ?</a> </li><li>  <a href="https://habr.com/ru/post/453862/"><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/453862/">Part 2. Answers to questions.</a> <br><ul><li>  <a href="https://habr.com/ru/post/453862/"><code> os.path</code> and <code>pathlib</code> to fair</a> </li><li>  <a href="https://habr.com/ru/post/453862/">You do not have to worry about normalizing the paths.</a> </li><li>  <a href="https://habr.com/ru/post/453862/"><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://habr.com/ru/post/453862/">But in my favorite library there is a Path better than the standard one!</a> </li><li>  <a href="https://habr.com/ru/post/453862/"><code>  pathlib.Path</code> and <code>str</code> don't mix, right?</a> </li><li>  <a href="https://habr.com/ru/post/453862/"><code>pathlib</code> too slow</a> </li><li>  <a href="https://habr.com/ru/post/453862/">Improved readability</a> </li><li> <a href="https://habr.com/ru/post/453862/"><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Part 1. </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> clumsy </h3><br><p>  The <code>os.path</code> module <code>os.path</code> always been what we used when talking about paths in Python.  In principle, there is everything that you need, but often it does not look very elegant. </p><br><p>  Is it worth it to import it? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Or so? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Maybe the <code>join</code> function has a very general name, and we should do something like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  To me, all the options above do not seem too comfortable.  We pass strings to functions that return strings, which we pass to the following functions that work with strings.  It just so happens that they all contain paths, but they are still just strings. </p><br><p>  Using strings for input and output in <code>os.path</code> functions <code>os.path</code> very inconvenient because the code has to be read from the inside to the outside.  I would like to convert these calls from nested to sequential.  This is exactly what <code>pathlib</code> can do! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  The <code>os.path</code> module requires nested function calls, but <code>pathlib</code> <strong>allows us to create chains of successive calls to methods and attributes of the <code>Path</code> class</strong> with an equivalent result. </p><br><p>  I know what you think: stop, these <code>Path</code> objects are not the same as they were before, we no longer operate with strings of paths!  We will return to this question later (hint: in almost any situation, these two approaches are interchangeable). </p><br><h3 id="os-peregruzhen">  <code>os</code> overloaded </h3><br><p>  The classic <code>os.path</code> module <code>os.path</code> designed to work with paths.  But after you want to <em>do something</em> with the path (for example, create a directory), you will need to access another module, often <code>os</code> . </p><br><p>  <code>os</code> contains a bunch of utilities for working with files and directories: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>rename</code> , <code>rmdir</code> .  Also <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>renames</code> , <code>removedirs</code> , <code>unlink</code> , <code>symlink</code> .  And a bunch of other things that are not related to file systems at all: <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>environ</code> , <code>getlogin</code> , <code>system</code> , ... A few more dozen things that I will not mention here. </p><br><p>  <strong>The <code>os</code> module is designed for a wide range of tasks;</strong>  <strong>This is such a box with everything related to the operating system.</strong>  There are many utilities in <code>os</code> , but it is not always easy to navigate in it: it is often necessary to dig a little in the module before you find what you need. </p><br><p>  <code>pathlib</code> transfers most of the file system functions to <code>Path</code> objects. </p><br><p>  Here is the code that creates the <code>src/__pypackages__</code> and renames our <code>.editorconfig</code> file to <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Here is a similar code using <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Notice that the second sample code is much easier to read, because it is organized from left to right - this is all due to the chains of methods. </p><br><h3 id="ne-zabyvayte-pro-glob">  Don't forget <code>glob</code> </h3><br><p>  Not only <code>os</code> and <code>os.path</code> contain file system related methods.  It is also worth mentioning the <code>glob</code> , which can not be called useless. </p><br><p>  We can use the <code>glob.glob</code> function to search for files with a specific pattern: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  The <code>pathlib</code> module also provides similar methods: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  After switching to the <code>pathlib</code> module, the <strong>need for the <code>glob</code> disappears completely</strong> : everything necessary is already a part of the <code>Path</code> objects. </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> makes simple things even easier </h3><br><p>  <code>pathlib</code> simplifies many complex situations, but beyond that <strong>makes some simple code snippets even easier</strong> . </p><br><p>  Want to read all the text in one or more files? </p><br><p>  You can open the file, read the contents, and close the file using the <code>with</code> block: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  Or you can use the <code>read_text</code> method on <code>Path</code> objects and generate lists to get the same result for a single expression: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  And what if you need to write to a file? </p><br><p>  Here is what it looks like using <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Or you can use the <code>write_text</code> method: </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  If for some reason you need to use <code>open</code> , either as a context manager or by personal preference, <code>Path</code> provides an <code>open</code> method, as an alternative: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Or, starting with Python 3.6, you can pass your <code>Path</code> directly to <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Path objects make your code more obvious. </h3><br><p>  What do the following variables indicate?  What is the meaning of their meanings? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Each variable points to a string.  But each of them has different meanings: the first is JSON, the second is the date, and the third is the file path. </p><br><p>  Such a representation of objects is slightly more useful: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  JSON objects can be deserialized into a dictionary, dates can be natively represented using <code>datetime.date</code> , and <strong>file path objects can be represented as <code>Path</code></strong> </p><br><p>  Using <code>Path</code> objects makes your code more explicit.  If you want to work with dates, you use <code>date</code> .  If you want to work with file paths, use <code>Path</code> . </p><br><p>  I am not a very big supporter of the PLO.  Classes add an extra layer of abstraction, and abstractions sometimes tend to complicate the system rather than simplify it.  At the same time, I believe that <code>pathlib.Path</code> is a <strong>useful abstraction</strong> .  Pretty quickly, it becomes a commonly accepted solution. </p><br><p>  Thanks to <a href="https://www.python.org/dev/peps/pep-0519/">PEP 519</a> , <code>Path</code> are becoming standard for working with paths.  At the time of Python 3.6, most of the <code>os</code> , <code>shutil</code> , <code>os.path</code> work correctly with these objects.  <strong>You can switch to <code>pathlib</code> , transparent to your codebase!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  What is missing in the <code>pathlib</code> ? </h3><br><p>  Although <code>pathlib</code> and cool, but not comprehensive.  There are definitely <strong>several features that I would like to have included in the module</strong> . </p><br><p>  The first thing that comes to mind is the lack of methods in the <code>Path</code> equivalent to <code>shutil</code> .  And although you can pass <code>Path</code> as the <code>shutil</code> parameters for copying / deleting / moving files and directories, it‚Äôs impossible to call them as methods on <code>Path</code> objects. </p><br><p>  So, to copy files, you need to do something like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  There is also no analogue of the <code>os.chdir</code> method.  This means that you need to import it if you need to change the current directory: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  There is also no equivalent of the <code>os.walk</code> function.  Although you can write your own function in the spirit of a <code>walk</code> without too much difficulty. </p><br><p>  I hope that one day the <code>pathlib.Path</code> objects will contain methods for some of the operations mentioned.  But even in this situation, <strong>I consider it much more simple to use the <code>pathlib</code> with something else than to use <code>os.path</code> and everything else</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  Do you always need to use <code>pathlib</code> ? </h3><br><p>  Starting in Python 3.6, <strong>Paths work almost wherever you use strings</strong> .  So I see no reason <em>not to</em> use <code>pathlib</code> if you are using Python 3.6 and higher. </p><br><p>  If you use an earlier version of Python 3, you can at any time wrap the <code>Path</code> object in a <code>str</code> call to get a string if you need to return to the country of lines.  It is not very elegant, but it works: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Part 2. Answers to questions. </h2><br><p>  After the publication of the first part, some people have some questions.  Someone said that I compared the <code>os.path</code> and <code>pathlib</code> dishonestly.  Some said that using <code>os.path</code> so ingrained in the Python community that switching to a new library would take a very long amount of time.  I also saw some performance issues. </p><br><p>  In this part I would like to comment on these questions.  It can be considered both a <code>pathlib</code> protection and a bit of a love letter to <a href="https://www.python.org/dev/peps/pep-0519/">PEP 519</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  Comparing <code>os.path</code> and <code>pathlib</code> to fair </h3><br><p>  In the last part, I compared the following two code fragments: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  This may seem like an unfair comparison, because using the <code>os.path.join</code> in the first example guarantees the use of correct separators on all platforms, which I did not do in the second example.  In fact, everything is in order, because the <strong>Path automatically normalizes the path delimiters</strong> </p><br><p>  We can prove this by looking at converting the <code>Path</code> object to a string on Windows: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  It makes no difference whether we use the <code>joinpath</code> method, <code>'/'</code> in the path string, the <code>/</code> operator (another nice <code>Path</code> chip), or pass individual arguments to the Path constructor, we get the same result: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  The last example caused some confusion from people who suggested that <code>pathlib</code> not smart enough to replace <code>/</code> with <code>\</code> in the path string.  Fortunately, everything is fine! </p><br><p>  With <code>Path</code> objects, you no longer need to worry about the direction of the slashes: define all your paths using <code>/</code> , and the result will be predictable for any platform. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  You do not have to worry about normalizing the paths. </h3><br><p>  If you are working on Linux or Mac, it is very easy to accidentally add bugs to your code that will only affect Windows users.  If you do not follow closely the use of <code>os.path.join</code> and \ or <code>os.path.normcase</code> to convert slashes into suitable ones for the current platform, <strong>you can write code that will not work correctly in Windows</strong> . </p><br><p>  Here is an example of a Windows-specific bug: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  At the same time such code will work correctly everywhere: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Previously, the programmer was responsible for concatenating and normalizing paths, just as in Python 2, the programmer was responsible for deciding where to use unicode instead of bytes.  This is not your task anymore - <code>Path</code> solves all such problems for you. </p><br><p>  I do not use Windows, and I do not have a Windows computer.  But the huge number of people who will use my code will very likely use Windows, and I want everything to work correctly for them. </p><br><p>  <strong>If there is a possibility that your code will run on Windows, you should seriously think about switching to <code>pathlib</code> .</strong> </p><br><p>  <strong>Don't worry about normalization</strong> : use <code>Path</code> anyway when it comes to file paths. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  It sounds cool, but I have a third-party library that does not use <code>pathlib</code> ! </h3><br><p>  You have a large codebase that works with strings as paths.  Why switch to <code>pathlib</code> if it means that everything needs to be rewritten? </p><br><p>  Let's imagine that you have the following function: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  The function takes a directory, and creates a <code>.editorconfig</code> file <code>.editorconfig</code> , like this: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  If you replace the lines with <code>Path</code> , everything will also work: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  But how? </p><br><p>  <code>os.path.join</code> accepts <code>Path</code> objects (starting with Python 3.6).  The same can be said about <code>os.makedirs</code> . <br>  In fact, the built-in <code>open</code> function accepts <code>Path</code> , <code>shutil</code> accepts <code>Path</code> and everything in the standard library used to accept a string should now work with both <code>Path</code> and with strings. </p><br><p>  It‚Äôs worth giving thanks to <a href="https://www.python.org/dev/peps/pep-0519/">PEP 519</a> , who provided the abstract <code>os.PathLike</code> class and announced that all the built-in utilities for working with file paths should now work with both strings and <code>Path</code> . </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  But in my favorite library there is a Path, better than the standard one! </h3><br><p>  You may already be using a third-party library that provides its own implementation of the <code>Path</code> , which is different from the standard one.  Perhaps you like it more. </p><br><p>  For example, <a href="https://github.com/joke2k/django-environ">django-environ</a> , <a href="https://github.com/jaraco/path.py">path.py</a> , <a href="https://github.com/tomerfiliba/plumbum">plumbum</a> , and <a href="https://github.com/saulpw/visidata">visidata</a> contain their own <code>Path</code> objects.  Some of these libraries are older than the <code>pathlib</code> , and decided to inherit from <code>str</code> , so that they could be passed to functions that wait for strings as paths.  Thanks to PEP 519, integrating third-party libraries into your code will be easier without having to inherit from <code>str</code> . </p><br><p>  Let's imagine that you do not want to use <code>pathlib</code> , because <code>Path</code> is immutable objects, and you really really want to change their state.  Thanks to PEP 519, you can create your very best-mutable version of <code>Path</code> .  To do this, simply implement the <code>__fspath__</code> method <code>__fspath__</code> </p><br><p>  Any self-written implementation of the <code>Path</code> can now work natively with built-in Python functions that expect file paths.  <strong>Even if you are not a <code>pathlib</code> , the very fact of its existence is a big plus for third-party libraries with their own <code>Path</code></strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  But <code>pathlib.Path</code> and <code>str</code> don't mix, right? </h3><br><p>  You might be thinking: that‚Äôs all, of course, great, but doesn‚Äôt this approach with sometimes-string-a-sometimes-path add complexity to my code? </p><br><p>  The answer to this question is yes, to some extent.  But this problem has a fairly simple detour. </p><br><p>  PEP 519 added a few more things besides <code>PathLike</code> : firstly, it‚Äôs a way to convert any <code>PathLike</code> to a string, and secondly, it‚Äôs a way to turn any <code>PathLike</code> into a <code>Path</code> . </p><br><p>  Take two objects ‚Äî a string and a <code>Path</code> (or anything with the <strong>fspath</strong> method): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  The <code>os.fspath</code> function normalizes both objects and turns them into strings: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  In this case, <code>Path</code> can take both of these objects into a constructor and convert them to a <code>Path</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  This means that you can convert the result of <code>make_editorconfig</code> back to the <code>Path</code> if necessary: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Although, of course, the best solution would be to rewrite <code>make_editorconfig</code> using <code>pathlib</code> . </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> too slow </h3><br><p>  I have seen several times questions about the performance of <code>pathlib</code> .  This is true - <code>pathlib</code> can be slow.  Creating thousands of <code>Path</code> objects can have a noticeable effect on program behavior. </p><br><p>  I decided to measure the performance of <code>pathlib</code> and <code>os.path</code> on my computer using two different programs that search all <code>.py</code> files in the current directory </p><br><p>  Here is the <code>os.walk</code> version: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  And here is the version with <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Testing the performance of programs that work with the file system is a tricky task, because the runtime can vary quite a lot.  I decided to run each script 10 times and compared the best results for each program. </p><br><p>  Both programs found 97,507 files in the directory in which I ran them.  The first one worked in 1.914 seconds, the second one finished the work in 3.430 seconds. </p><br><p>  When I set the <code>extension=''</code> parameter, these programs find approximately 600,000 files, and the difference increases.  The first program worked in 1.888 seconds, and the second in 7.485 seconds. </p><br><p>  So, <code>pathlib</code> works about <strong>twice as</strong> slowly for files with the <code>.py</code> extension, and <strong>four times slower</strong> when running on my home directory.  The relative performance <code>pathlib</code> and <code>os</code> quite large. </p><br><p>  In my case, this speed changes little.  I searched all the files in my directory and lost 6 seconds.  If I had a task to process 10 million files, I would most likely have copied it.  But as long as there is no such need, you can wait. </p><br><p>  If you have a hot code snippet, and <code>pathlib</code> clearly has a negative effect on its operation, there is nothing wrong with replacing it with an alternative.  <strong>You should not optimize code that is not a bottleneck</strong> - it is a waste of time, which also usually leads to poorly readable code, without much exhaust. </p><br><h3 id="uluchshenie-chitaemosti">  Improved readability </h3><br><p>  I would like to end this thought stream with some examples of refactoring with the help of <code>pathlib</code> .  I took a couple of small code samples that work with files and made them work with <code>pathlib</code> .  I will leave most of the code without comments to your court - decide which version you like more. </p><br><p>  Here is the <code>make_editorconfig</code> function that we saw earlier: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  And here is the version rewritten on <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Here is a console program that takes a string with a directory and prints the contents of the <code>.gitignore</code> file, if it exists: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  The same, but with <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Here is a program that prints all duplicate files in the current folder and subfolders: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  The same, but with <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> ‚Äî .    ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/453862/">https://habr.com/ru/post/453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45385/index.html">HB 778 - clone HTC Touch Diamond</a></li>
<li><a href="../453850/index.html">The Chinese social credit system - is the devil scary?</a></li>
<li><a href="../453852/index.html">Microbiota How to care for intestinal bacteria</a></li>
<li><a href="../45386/index.html">Open Source Multi Theft Auto</a></li>
<li><a href="../453860/index.html">AMD has introduced its new custom 7 nm processors Ryzen third generation</a></li>
<li><a href="../453864/index.html">Using a mouse and keyboard on consoles is cheating?</a></li>
<li><a href="../453866/index.html">API Request with React Hooks, HOC or Render Prop</a></li>
<li><a href="../453868/index.html">Touch mini switch co with glass panel on nRF52832</a></li>
<li><a href="../453870/index.html">We write Reverse socks5 proxy on powershell. Part 1</a></li>
<li><a href="../453872/index.html">We restore photos using neural networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>