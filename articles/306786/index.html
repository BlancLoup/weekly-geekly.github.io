<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Resource allocation in large high performance clusters. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most complex data tasks require a considerable amount of resources. Therefore, almost every data center in the world is not one, but many customers - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Resource allocation in large high performance clusters. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  Most complex data tasks require a considerable amount of resources.  Therefore, almost every data center in the world is not one, but many customers - even if they all act under a common brand.  Companies need power for a variety of services and goals, and in the process of achieving any one of them they have to deal with a whole set of subtasks.  How can a data center deal with the flow of people who want to analyze or calculate something?  Incoming orders for calculations need to be performed in a certain order, trying not to deprive anyone of resources.  This lecture is about the basic methods of distributing real tasks on a large cluster.  The method described by Ignat Kolesnichenko is used to service almost all Yandex services. <br><br>  Ignat is the head of one of the groups in our distributed computing technology service.  He graduated from the Moscow State University and the School of Data Analysis, in Yandex since 2009. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Cg7KrVoEHz8%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgzCu_sNA8ppJ0npabSHLLDpSJCQQ" frameborder="0" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under the cut - a detailed transcript of the lecture and slides. <br><a name="habracut"></a><br>  Good evening everyone.  My name is Ignat Kolesnichenko, I work in Yandex, in the service of distributed technologies and computing.  And today I will try to tell you about one task that I met in very real life.  To begin with, let's talk a little more about what my work consists of, what we do.  And then - a little more detail about the details, and move on to the task as a result, we will understand what it is. <br><br>  What kind of product are we doing?  We make a product for developers and analysts of Yandex.  The challenge is that we build large clusters and software on top of them.  These large clusters and software on top of them allow you to store huge amounts of data, and not only store them, but also process them.  By huge volumes, I mean petabytes, dozens of petabytes.  Petabytes are a thousand times more than terabytes, and tens of thousands of petabytes are more than tens of thousands of times.  The task is to build such a system, in which ordinary developers and analysts of Yandex could come in, run their fairly simple code there, and it would work quickly and distributed across the entire cluster, would get the result.  Then they would build some kind of their schedule, understand that the proportion of Yandex is growing or falling, and would have already made some conclusions, improved their software. <br><img src="https://habrastorage.org/getpro/habr/post_images/417/654/30a/41765430a403af801be9a37070cd2109.jpg" alt="image" width="700"><br>  What is a cluster in our case?  In our case, the cluster is very simplistic as follows.  These are many, many servers called compute nodes.  The server is generally the same as your laptop, only much more powerful, and it costs not somewhere, but in a data center in a shelf.  Typical server features are not like regular laptops with 4-8 cores.  They have 30 cores, 128 GB of memory, in general, many resources that can be used to run tasks. <br><br>  In addition, in order to manage these computational nodes in order to run something there, in order for something to work, to store data, we need some system.  And an important part of the system are two things - the meta information server, which will know where the data is in this cluster and what is happening on it, and the scheduler, who will decide where to run what tasks.  Today we will mostly talk about the planner.  Let's take a closer look at what he can be. <br><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cab/163/ae6cab163a89cf2a8ce9a48c2e504f7b.jpg" width="700"><br>  The scheduler in fact is a server or maybe several servers.  And from the point of view of the interface - how users work with it and how it communicates with the outside world - it has two types of communication.  One view is the start of calculations, when a developer comes in and tells the server to start the program written by him in some form.  Then the scheduler says: ‚ÄúYes, I accepted your program, launched it.  Now here you can see what happens to it when it is executed or not executed. ‚Äù  In addition, it communicates with our computational nodes, with servers.  What does the compute node tell it?  Computing nodes say: ‚ÄúLook, I have so many free resources, I have half CPU not occupied, a lot of free memory, all this is not used.  Give me some task, ‚Äùto which the planner replies,‚Äú Oh!  Keep the new tasks. ‚Äù  And so each node with this one and only scheduler communicates. <br><img src="https://habrastorage.org/getpro/habr/post_images/64c/276/34e/64c27634ede4ac39c44bc75db80c7f24.jpg" width="700"><br>  In more detail, it looks like this.  The scheduler should have some strategy of how it decides which tasks to run, when they come to it, and on which nodes.  The user comes and runs his calculations.  The scheduler remembers: ‚ÄúOh, I have such a calculation‚Äù - and stores them somewhere in its internal data structure.  In addition, he has some strategy of his own.  And when the computational node comes to him, he informs him about the tasks and resources that she is running, our strategy must answer what exactly the node should do with its tasks or what new tasks should be launched.  For example, she might say: ‚ÄúPlease, start me two tasks of my first calculation‚Äù.  He can say: ‚ÄúRun one task of the second calculation, and also cut off one task of the third calculation, because the third calculation does too much.  Stop him doing it. ‚Äù <br><br>  Now a little more detail about the calculations and problems, about the fact that all of this is.  The answer depends on the type of computation, but in the simple case we can say that the user comes with some written code, be it a Python or C ++ binary, says what resources he wants to have on the cluster and somehow describes it .  The strategy somehow remembers and the data that you want to process - and they lie on different nodes - distributes into pieces.  And already on these pieces, the strategy starts the calculation.  We will assume that every computation - also called operations in another way - consists simply of some set of tasks.  A little further we will see what is meant by this. <br><img src="https://habrastorage.org/getpro/habr/post_images/320/901/3dc/3209013dc6920c85406e6d162feaa6ab.jpg" width="700"><br>  I want to tell you about what we called strategy on the previous slide: what it is, what they are, what properties they should have, how they should work. <br><br>  What should the strategy do?  Its important function is to decide which task to run.  She has a lot of different calculations that users ordered, and she needs to understand which of these calculations, which of these operations should be run.  It is also important to understand what users want from the system.  Obviously, users run their calculations and want some kind of guarantee ‚Äî they want the calculation to complete and as soon as possible.  We will talk later about what will be meant by ‚Äúas soon as possible‚Äù.  And the global question - what properties should a strategy have? <br><br>  Before we talk about strategy, we still need to remember about resources.  This is an important constraint on how we will determine what to run, what resources there are.  The two most understandable and basic resources are the RAM available to us on the nodes, and the number of processors.  How do we understand if you can run any task on any node?  When the user starts the calculation, he should tell us how much it is eating up RAM and how much CPU he is going to use.  If he did not report, then we must assume that this is the default value.  If the real task of the user suddenly eats up more than he ordered, you just need to kill her and tell the user: ‚ÄúYou started an invalid calculation.  Don't do that.  Go change your limitations. ‚Äù  But we will assume that the user knows how much his program eats up the CPU, RAM, and based on this we will act. <br><br>  As for the CPU, it is clear that any user program eats one CPU, because if the application is single-threaded ‚Äî and most people write single-threaded applications ‚Äî then this is one CPU.  And about memory is already a more complicated question: it‚Äôs necessary to understand how many different data structures the user‚Äôs program will allocate, how much it will eat of this memory.  And the user's task is to understand how much his program consumes. <br>  There are less popular resources, such as network utilization.  It may happen that the user program goes somewhere on the network and downloads something to itself.  There are user programs that actively torment disks.  If you start to constantly read from random places from your hard disk to a typewriter, then the hard disk will quickly end and you will no longer be responsible for any reasonable time.  So it is also important to consider.  If you run a lot of tasks, all of which want a disk on one machine, then all of them will work very slowly, and the user obviously doesn‚Äôt want it. <br><br>  The user tells us how many different resources each calculation wants.  And about the nodes, we also know how many resources they have.  You can go to some Sysprog and find out how much memory there is, how many free cores there are and how the resources on our computing server are being used. <br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/977/5ae/0fd9775ae5124a90c5e75c33f697ca18.jpg" width="700"><br>  Then we start talking about strategy.  And the first strategy, absolutely simple, about which I will tell you, is the FIFO strategy.  Let me draw how it will be arranged. <br><br>  Our planner will line up our operations.  FIFO stands for first input first output, simply denoting the concept of a queue.  Let's say we had users, they somehow started operations and our scheduler has some queue of operations.  After that, all that our strategy has to solve when our node comes with some of its own resources is the tasks of which of these operations to launch.  Let's now introduce some mundane numbers ‚Äî knowledge about our nodes, our operations ‚Äî and consider a concrete example of how the FIFO strategy works.  Then it will be clear how it works. <br><br>  Let us have 32 CPUs and 63 GB of memory on our node.  Let the first operation consist of 1000 subtasks, and let each subtask eat up 1 CPU and 4 GB of memory.  This is the first task. <br><br>  The second task, let it be completely different - consisting of 500 subtasks, each of which requires, for example, 10 CPUs and 1 GB of memory.  And so on. <br><br>  Users came, started such operations, and our strategy needs to understand which of them to give to this node.  Let's say a free node has come to the strategy, and it needs to decide what to do with it. <br><br>  The FIFO strategy will act in the following simple way.  They are not for nothing drawn one after another.  This means that they are ordered by time.  Who came earlier, launched the operation - she is the first in the queue and got up.  The FIFO strategy will first offer the first operation: ‚ÄúFirst operation, do you have any other task that I can run on the node?‚Äù.  If there is, then he will tell the node to start the task of the first operation.  What does all this lead to? <br><br>  Let's also, moreover, suppose that we have 100 such nodes.  If we have 100 node nodes, how many resources in the cluster do we currently have? <br><br>  - 3200 CPU and 6400 GB, that is, 6 and a half TB. <br><br>  - Yes.  And the strategy will be the first thing to run everything from the first operation.  It is easy to see that at some point in this first operation, she will start everything, and all the resources will not be exhausted yet.  That is, at some point we will come to the conclusion that a thousand of a thousand tasks have already been launched here, but resources have not yet been exhausted, there is something else on the nodes.  At this point, the strategy will go like this: ‚ÄúYeah, I still have free resources.  We need to start something else. ‚Äù  She will go to the next operation, and start running her tasks.  You can even understand how many tasks of the second operation she will be able to run at best. <br><br>  Let's estimate.  Having started the first operation, we will spend 1000 CPU and 4000 GB of memory.  So, we will have 2200 CPU and 2400 GB of memory.  Further to these remaining resources, it will launch the second operation.  Here the main suffering resource will be the CPU, that is, it will be missed, because it wants little memory, and the CPU - a lot.  Therefore, apparently, we will be able to run 220 tasks of the second operation.  And at this stage, the launch of tasks will end until some of the tasks of our operations begin to end.  As soon as the tasks of the first or second operation begin to end, the scheduler will take this into account.  That is, when a node comes to it, it reports, not only what free resources it currently has, but also what is the status of those tasks that were already running on it.  She will report about some tasks that they ended.  Planner like this: ‚ÄúAha, they are over!  You can go there and plan something else. ‚Äù  He will go and try to look at the second operation in order to plan something, on the third operation, in order to plan something. <br><br>  About 220 tasks of the second operation here there is some deception.  Do all see what this deception is?  Why can not always be able to run 220 tasks of the second operation? <br><br>  - In a sense, should get less? <br><br>  - It may in some case be less.  I hope that in principle we will not be able to, because this is contrary to our limitations, but for some reason it may turn out to be less. <br><br>  ‚ÄúBecause the memory goes somewhere else.‚Äù <br><br>  - We have fair restrictions, really we do nothing more and do not spend.  But the problem is that the tasks of the second operation want 10 CPUs, and it may happen that we occupied 25 CPUs with the first task on one node, and it has 7 free, and 7 free ones are obviously not enough, and the scheduler did not has the right to take and run at least one task of the second operation, because there are not enough resources for it.  That is, there are free resources, but these free resources are not enough.  This is a problem of granularity, which we probably will not talk about today, but we need to understand what it is.  Generally speaking, a good planner should take this into account.  If he understands that somewhere because of the granularity he cannot start something, it means that he should try to force something out of the first operation, for example.  It is clear that the first operation is more convenient for him, it is easier to run on other nodes due to running at least one task of the second operation. <br><br>  Let's go further.  I want to understand what we have requirements for a strategy.  Generally speaking, they can write a large list.  Today I will consider the three most basic and important ones.  Let's write in more detail what they mean. <br><img src="https://habrastorage.org/getpro/habr/post_images/1bb/7d1/fe7/1bb7d1fe73dd438e519b41bcd4da398d.jpg" width="700"><br>  Honesty is not an easy requirement.  What is meant by it?  FIFO strategy has this problem.  Imagine that you have a lot of users, they all came, started operations, and someone was lucky who launched the first one.  And someone was very unlucky: he launched, and the first operation turned out to be very long, tedious, and, in fact, perhaps not needed by anyone, and the person mistakenly launched it, for example.  Then all the rest will stand and wait until this first operation is completed, or the user cancels it, or something happens to it.  It‚Äôs clear that the cluster user probably doesn‚Äôt like it so much that your neighbor has come, before you got in line, and he does something for a long time.  And that's all, and you can‚Äôt do anything, but you urgently need to read a report, you have a job because of this, and you want to be guaranteed something. <br><br>  What will this mean?  Suppose we have three users: A, B and C. These users could somehow agree on what share of the cluster belongs to whom.  For example, they could just by their importance or from some other considerations agree that User A was entitled to 20% of the cluster, User B was entitled to 30% of the cluster, User C was 50% of the cluster.  And I want that we could somehow communicate such information to our planner so that he could take this into account in his strategy and distribute the resource so that 20% of the cluster belongs to user A, 30% belongs to user B and 50% belongs to user C. <br><br>  When we talk about it, the naive question arises: if they so divided resources, why not free themselves three separate clusters, and not try to live on one?  There is a reason for this.  The reason is this: I want them to be more profitable to unite than to live separately. <br><br>  Why can this be?  Imagine that user A's tasks for our cluster eat 1 CPU and 4 GB of memory.  User B has 10 CPUs and 1 GB of memory.  I argue that then it is more profitable for them to unite than to live separately. <br><br>  Why is that?  Imagine that User A has its own 20 machines, while User B has 30 machines.  They run all their resources on all their machines.  I draw two columns: the first column is the CPU, the second is the memory.  I want to understand in each of these columns how much they will be filled in terms of total resources for the entire cluster.  At the same time, I remind you that we had 32 CPUs and 64 GB of memory on each machine.  And, let's say, these operations have a lot of their tasks that they run, that is, they can eat all the resources of the cluster. <br><br>  This user A can see, for example, that he will eat the whole memory, and the CPU - by half.  We have a typewriter 64 GB of memory and 32 CPUs.  Then how much can we run on 64 GB of memory?  16 such tasks.  16 tasks - they, of course, half our CPU will not eat. <br><br>  Okay, how is the second user doing?  The opposite way.  He wants a lot of CPU and little memory.  He, apparently, will eat all the CPU and how much memory there is. <br><br>  ,                   CPU,    ‚Äî  ,  ,      -  .       ,    .   ‚Äî     .             ‚Äî       ,    ,    ,       ,    ,   - ,  - .       ,       ,     .  ,    .   ,    ,    . <br><br>     ?     ,     ,   . ,    ,      .  FIFO, ,   ,     ,    ,   ,       ,    .  : ¬´,    .    50  ,    .       50  ,      FIFO   ¬ª.   .  -     fairness. <br><br>   ‚Äî     . -    ,   pareto efficiency.     .   .     ,    ,         . <br><br>   ¬´   ¬ª?     .     ,            ,      ,       .    : ¬´,     - . ,     ¬ª.  Will not work.   ,            -  ,     .    . <br><br>  ,       ‚Äî   . -   strategyproofness.   ,     ,        .    , , ,    1 CPU  4  ,       ‚Äî 1 CPU  5  .   ,    ,           ,       ,    ,        ,    . ,     . ,           , ,    ,       .      - ,   -   -      ÃÅ  .  .    .   ,  ,      - .       ,   . , ,  .   . <br><br>     ,    .    DRF ‚Äî dominant resource fairness.    ,      ,     pareto efficient  strategyproofness. ,  ,      :       ,    ,          ,  - -    ,     .      ,    . <br><img src="https://habrastorage.org/getpro/habr/post_images/76f/a12/731/76fa12731bf8233586474d674433da30.jpg" width="700"><br>    ,   dominant resource fairness,      .   S ‚Äî       .  S=(S <sub>1</sub> ,...,S <sub>r</sub> ).       3200 CPU  6400  . R    .  ,    ,        ‚Äî  -    ,  - , ‚Äî     .      ‚Äî CPU  . <br><br>  ,       .  1,  2  . .    ,    -  .  ,   ,  -  .       :   1,  2   ,  N.      .  .    - ,               . <br><br>     ,     ‚Äî D <sup>k</sup> .    .     1000 * (1, 4). 1 ‚Äî CPU, 4 ‚Äî .    ,     (1000, 4000).      ,          ,  ,  ,      ,     CPU,   . . ,        ,       ,  ,         . <br><br> ,     ,  ( <sup>D <sup>k</sup> <sub>1</sub></sup> / <sub>S <sub>1</sub></sub> , <sup>D <sup>k</sup> <sub>2</sub></sup> / <sub>S <sub>2</sub></sub> ,..., <sup>D <sup>k</sup> <sub>r</sub></sup> / <sub>S <sub>r</sub></sub> ).   ,    - .   ,          .             .   argmax.    argmax       .  ‚Äî    k. <br><br>      3200  6400,     D <sup>1</sup> = 1000 * 1,4.       : <sup>1000</sup> / <sub>3200</sub> , <sup>4000</sup> / <sub>6400</sub> . ,     ,  ,         .        ,    10 CPU  1  ,   , ,     CPU.     ‚Äî   ,       . <br><br>  ,      . - , - ,        ,  usage ‚Äî      .  U <sup>k</sup> ‚Äî      K.        -  ,  U <sup>k</sup>  ,       .     - ,    D <sup>k</sup> ‚Äî        D <sup>k</sup> .        k,    u <sup>k</sup> .     . <br><br>      .    ,   .  dominant resource fairness   ,     ,    .     ,    :           .     ,      . Dominant resource fairness       ,    ,        . S=(S <sub>1</sub> ,...,S <sub>r</sub> ).     usage ratio      . <br><br>    ,         DRF.     . ,   DRF ,     ,   ,               (U <sub>k</sub> ‚â• W <sub>k</sub> ).      20%  , ,   ,         20%  .            ‚Äî    .     .     , ,   DRF ,        ,      . <br><br> ,  -  20%,  20%   ,     : ¬´, .   ¬ª.   ,  ,             20%.  ,  ,  ,      ,      .   ,  .    ,    - ,   :   , , CPU,   ,           ,    W <sub>k</sub> . <br><br>  ,    DRF. ,   ,   ,  ,    ,   ,      ,   .     . <br><br>   ,   ,  ,   .   , ,    ‚Äî  ,     ,  -    20% ,  ,   ,     W <sub>k</sub>   .            CPU  RAM, , ,   - 50%, - 20%, - 30%. ,  -    :       RAM,    - CPU   RAM.   1,   2,    3.     RAM,    CPU.       ,      ‚Äî   U <sub>k</sub> ‚â• W <sub>k</sub> .  ,      :     CPU,      .     RAM.   -  .     ,   ,    . <br><br>      ,   ,     , ‚Äî  , .     ‚Äî      .      ,    ,     .   ,        ,  ,      .      ,    . <br><br>    ?    :  1, 2, 3  . .   .   - .   -  .      ‚Äî W <sub>1</sub> , W <sub>2</sub> , W <sub>3</sub> ‚Äî      .         .    , : ¬´    .   ?¬ª      ,  . <br><br>    .     ,    ,     ,       S=(S <sub>1</sub> ,...,S <sub>r</sub> ).   k,   <sup>U <sub>k</sub></sup> / <sub>W <sub>k</sub></sub> .     ‚Äî   .  -                  .     - ,  U <sub>k</sub>  ,   -  ‚Äî .    ?      ,     ,  : ¬´,        ¬ª.  U <sub>k</sub>  -.     ,     ,    ,  .   ,         ,    .    k. <br><br>    :       ,   U <sub>k</sub> ‚â• W <sub>k</sub> .     ,  ,      ,       ,    U <sub>k</sub>     W <sub>k</sub> ‚Äî           -  . -     .   ,     10 CPU ‚Äî          ‚Äî    ,    ,     10 CPU    .   ,     . <br><br>     ,   ,      .          D <sup>k</sup>  ,   ,    ‚Äî  Œµ*D <sup>k</sup> ,  Œµ  .    ,      -      -  ,        ,    ,       .  ,      ,      . <br><br>  ,   , ,        ,      .        ?       .    .  ,   - ,       .   -    . ,      ,    ,         ,  .         ,      .   ,      ,       .     1000 CPU  ,    ,      CPU. <br><br>   - .     ,      .  ,       demand,    .    ,    , ‚Äî        Œµ. <br><br> ,      .   ,      demand,     -  .  ,    1000 CPU  2000  . ,   ,    ,       .  ,  ,       , ‚Äî  (1, ¬Ω),  , ,    (¬Ω, 1).     :    ,    , ,   ,        , ,  ‚Äî S=(S <sub>1</sub> ,...,S <sub>r</sub> ). :       ?        ,   ?       ?   -,           ,   ? <br><br> ,    .     ,   -  ,  -  ,     ,  .   ,       ,    -,  -       ,  .       .         .   (Œµ, Œµ/2),  ‚Äî (Œµ/2, Œµ),  ,     , ,  : (1 ‚Äì 3Œµ/2, 1 ‚Äì 3Œµ/2).   Œµ  ,    ?      - ?     ?  ,    .       ,      ,    ,     ‚Äî  ,      .   ,     .    ,    (‚Öî, ‚Öì),  , , (‚Öì, ‚Öî). <br><br>        ,   .  ,   W     0,5,    U,   ,   ‚Öî.      .   ,     . <br><br>  ,  ,    .    - .  , , (0,1),   (1,1).     ,  DRF       ?       ,       ?  , -   ?       ,   ,   ‚Äî   .   ,       ,        . <br><br> , .    (¬Ω, ¬Ω), (0, ¬Ω). <br><br> ‚Äî    ,     ? <br><br> ‚Äî      -     ,     -   .     ,  ,   , ‚Äî   .       ,          .             .       ,    ‚Äî  0  1.      ,      .     ,              .        .        ,    . <br><br>    ,    ,     .   ,     .        ,  DRF . <br><br>        .      CPU.       CPU,     .      ,        ‚Äî     ,    ,    .     .     .     ,  ,     .      ,       ¬º.        ¬º,    ,   ,     .      ,    ,       ,       . <br><br>  ,      DRF.     .  ,   ,    .   - ,       .        ? <br><br> ‚Äî   CPU. <br><br> ‚Äî ,       ‚Äî 2,     1,5,     1. ,     ,    .  ,      (¬Ω, 0, 0), (¬Ω, 0, 0).        ¬Ω,    (0, ¬Ω, 0),   ‚Äî (0, ¬º, ¬Ω).     ,     .       ,      ,     .        ,    ,      . <br><br> ‚Äî      ¬Ω? <br><br> ‚Äî   ,     ¬Ω       . <br><br> ‚Äî     . <br><br> ‚Äî ,    ,  .    ‚Äî    ,  .  -   .     ,    .    ,      ,     ,      .        ,    ? <br><br> ‚Äî  . <br><br>  - Yes.   ? <br><br> ‚Äî . <br><br>  - Yes.       .       ,  ,     .  ,    (0, ‚Öî, 0),   ‚Äî (0, ‚Öì, ‚Öî).      ,    ,  ,    ‚Äî           .     , ,   ,       .         ‚Äî ,   ,   ,      ,  .    ¬Ω    .     :   (¬Ω, 0, 0),  (¬Ω, 0, 0),  (0, ‚Öî, 0),  ‚Äî (0, ‚Öì, ‚Öî). <br><br>      .    ¬º,  usage ¬Ω.        ,    .   ¬º, ¬Ω.      ¬º,    ‚Öî,     .      ‚Äî  ¬º,   ‚Öî. ,                .    ?  ,      ,   ,     ,        ,      ,  -    .    ,    ,      ,  .  ,    -  ,      ,    ,   ,       ‚Äî     ,   .    .    . <br><br>      .         ,    . ,      ,  ,    ,    ,   ,     .  (0, ¬Ω, 1).   ,   ,  .       2,      2.    ,      .     ,    ¬Ω,      :  (¬Ω, 0, ¬º), (¬Ω, 0, ¬º), (0, ¬Ω, 0), (0, ¬º, ¬Ω). <br><br>   DRF    ¬Ω ‚Äî  ,    .         .      ‚Äî ,   ,    .   ¬º, ,     .     (0, ¬æ, 0), , , ,  (0, ‚Öî, 0).  ,   :     ,    ,          .   ,     ‚Äî .   :  ,    ‚Äî       DRF ‚Äî ,     .      ,       ,       .       ,      .  ,        ,        .  ,       .      .     ,     ,  ,    ,    . ,    .     ‚Äî      -  ,    .     ‚Äî    .  ,   ,  ‚Äî  - , -  ,    .      ‚Äî    .        ,   , ‚Äî     .    ,       -    . <br><br>       ,   .     ,    ,      DRF        ,     ,       FIFO. ,      : A, B  C.    20%,  30%,  50%.     , ,  ,    .  ,        .  ,   B  C   ,        ,     ,       - ?     ,       B  C   .  ,  ,    .        .         ,        ,           ,        ,   ,   , ,    ,   ‚Äî   .    , ,        .   ‚Äî   ,   - ,    -,   ,    , : ¬´-     .   - ¬ª. <br><br>  ,      .    ,      .     .     .     - ,      ,  ,   .     ,  ,     - .    ‚Äî ,  .    ‚Äî  -  .    -   ,     ,   ,     ,   , ,     .   ,  -   ,      ,   ,  ,       .   ,    ,   , ,   .         , , ,   ¬´¬ª. <br><br>     ,        ,      ‚Äî   ,   - ,       .    ,         . <br><br>   ,      ,    ‚Äî  ,    DRF  HDRF.  ,    . ¬´20% ? ,     .      ,  ,  -¬ª.  ,      ,   . ,   ‚Äî     ‚Äî   30%. 30%,      -   ‚Äî  research-,   production-.   ,  research  ,     ,  20%,  production ‚Äî 80%. , ,    ,   ,     50%.   ,     -  ‚Äî 30%  70%.    ,     ,  ,   scheduler ‚Äî   ‚Äî  - ,   ,    ,      ,   .     - ,    30%,     ,    20%.  ,   ,     ,     30%,          30% * 20%,   6%.  ,      6%    .     . <br><img src="https://habrastorage.org/getpro/habr/post_images/2e9/f0d/fa5/2e9f0dfa5081db8efeab82fed2029a4b.jpg" width="700"><br>    ?   : ¬´       ¬ª.      ,        .    ,  6%,      .     6%, 20%, 15%, 35%, 12%  12%.   :       ,    6%, 20%, 15%, 35%, 12%, 12%.  ,    .      . ,   ,   ,     ,        30%.   ,          30%.    ,   30%  ,         .  ,   ,   CPU,  ‚Äî .   ,     ,   , ,        30% .   .    . <br><br>       ?    DRF   .    ?    ,     ,        ,      ,   , ,   ,  .      .     ,           .     ,      ,       ,      .   ,          ,    usage  ,        ,     - .     ,  ,   ,  . <br><br>  ,    .  ,     ,   na√Øve HDRF.      .      .        ,     ,    .  ,      na√Øve HDRF?     .  , ,    ,     ,    .       (¬Ω, 0),   demand (1, 1),    (¬Ω, ¬Ω),    (¬Ω, 0), (0, ¬Ω).        ,        (0, 1).  ,  .    CPU   ,   ‚Äî   CPU.     .    . ,     ,   :      ,     .   ,   0.   scheduler?    : ¬´     CPU,    .      ,   CPU.     ‚Äî ,   ‚Äî CPU.      CPU   ¬Ω,       1,    ,   ,   . Scheduler        CPU.       ,     (1, 0),  (0, 0),   (0, 1).      ,    ,     ‚Äî .     ,    ,      .  Problem. <br><br> Min satisfaction HDRF ‚Äî      .   .    : ,    ,  ,             ,        . ,    ,  ,   ,  - ,   usage S=(S <sub>1</sub> ,...,S <sub>r</sub> ). ,        ,     .           ,     .       ,     .       ,          . <br><br>      . <br><br>  Conclusion   , ,    , ‚Äî   ,     ,        ,       .   ,  ,   , ‚Äî , -,  .           ,   -      .      ,     ‚Äî   ,     ,      -   ,     ‚Äî    .       -  ,    .  ,       , , ,      .   min satisfaction HDRF ‚Äî  ,     ,     5-10%   .   ,  ,      ,    .  ,       ,    ,   .     .  ,    .  ,  -     -  -    ,      . <br><br>  Everything.  Thanks to all.    . </div><p>Source: <a href="https://habr.com/ru/post/306786/">https://habr.com/ru/post/306786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306774/index.html">Oracle announced the largest transaction in the last 12 years</a></li>
<li><a href="../306776/index.html">Habrahabr visiting Alexander Lyamina, QRATOR</a></li>
<li><a href="../306778/index.html">How we certified our kits "Experiment in a box"</a></li>
<li><a href="../306782/index.html">Churn</a></li>
<li><a href="../306784/index.html">Shannon Communications Model (translation of Great Principles of Computing)</a></li>
<li><a href="../306788/index.html">How to display dynamic unloading from the database on Atlassian Confluence pages?</a></li>
<li><a href="../306790/index.html">Expanded commentary on the articles "Systematization of publications in the web"</a></li>
<li><a href="../306792/index.html">We create stub services for integration testing on Apache Camel (using Scala DSL)</a></li>
<li><a href="../306794/index.html">July update of Microsoft Azure and VNET peering</a></li>
<li><a href="../306796/index.html">Introducing 3CX Phone System v15 SP1 and test the system on a mini PC instead of a server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>