<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pitfalls of HttpClient in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the series of articles on "pitfalls" I can not ignore the System.Net.HttpClient, which is very often used in practice, but it has several s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pitfalls of HttpClient in .NET</h1><div class="post__text post__text-html js-mediator-article">  Continuing the series of articles on "pitfalls" I can not ignore the System.Net.HttpClient, which is very often used in practice, but it has several serious problems that may not be immediately visible. <br><br>  A common problem in programming is that developers are focused only on the functionality of a particular component, and at the same time do not take into account the very important non-functional component that can affect performance, scalability, ease of recovery in case of failures, security, etc.  For example, the same HttpClient seems to be an elementary component, but there are several questions: how many parallel connections it creates to the server, how long they live, how it behaves, if the DNS name that was accessed earlier is switched to a different IP address ?  Let's try to answer these questions in the article. <br><a name="habracut"></a><br><ol><li>  <a href="https://habr.com/ru/post/424873/">Compound leakage</a> </li><li>  <a href="https://habr.com/ru/post/424873/">Limit of simultaneous server connections</a> </li><li>  <a href="https://habr.com/ru/post/424873/">Long-Lived Connections and DNS Caching</a> </li></ol><br><a name="1"></a>  The first problem with HttpClient is the non-obvious <b>leakage of connections</b> .  Quite often I have come across the code where it is created to execute each request: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid textId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">$"http://someservice.com/api/v1/some-text/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{textId}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br>  Unfortunately, this approach leads to a large waste of resources and a high probability of overflowing the list of open connections.  In order to visually show the problem, just run the following code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); } } }</code> </pre><br>  And at the end, view the list of open connections via netstat: <br><br><pre> PS C: \ Development \ Exercises&gt; netstat -n |  select-string -pattern "178.248.237.68"<font></font>
<font></font>
   TCP 192.168.1.13:43684 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43685 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43686 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43687 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43689 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43690 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43691 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43692 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43693 178.248.237.68:443 TIME_WAIT
   TCP 192.168.1.13:43695 178.248.237.68:443 TIME_WAIT
</pre><br>  <i>Here, the ‚Äìn key is used to speed up the output, because otherwise netstat for each IP will look for a domain name, and 178.248.237.68 will have the habr.com IP address at the time of this writing.</i> <br><br>  So, we see that despite the using construct, and even though the program was completely completed, the connections to the server remained ‚Äúhanging‚Äù.  And they will hang for as long as indicated in the registry key HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Services \ Tcpip \ Parameters \ TcpTimedWaitDelay. <br><br>  On the move, the question may arise - how does the .NET Core behave in such cases?  That in Windows, that in Linux, is exactly the same, because similar retention of connections occurs at the system level, and not at the application level.  The TIME_WAIT status is a special state of the socket after it is closed by the application, and this is necessary for processing packets that can still go through the network.  For Linux, the duration of such a state is specified in seconds in / proc / sys / net / ipv4 / tcp_fin_timeout, and, of course, can be changed if necessary. <br><br><a name="2"></a>  The second problem HttpClient is an unobvious <b>limit on simultaneous connections to the server</b> .  Suppose you use the familiar. NET Framework 4.7, with which you develop a high-loaded service, where there are calls to other services via HTTP.  A potential problem with connection leakage has been taken into account, so the same HttpClient instance is used for all requests.  What could be wrong? <br><br>  The problem can easily be seen by running the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  <i>The resource specified in the link allows you to delay the server‚Äôs response for a specified time, in this case 5 seconds.</i> <br><br>  As it is easy to notice after executing the above code, there are only 2 answers every 5 seconds, although 10 simultaneous requests were created.  This is due to the fact that interaction with HTTP in a normal .NET framework, among other things, goes through a special class System.Net.ServicePointManager that controls various aspects of HTTP connections.  This class has a DefaultConnectionLimit property that indicates how many simultaneous connections can be created for each domain.  And so historically, the default value of the property is 2. <br><br>  If the above code example is added at the very beginning <br><br><pre> <code class="cs hljs">ServicePointManager.DefaultConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  then the execution of the example will speed up noticeably, since requests will be executed in batches of 5. <br><br>  And before moving on to how it works in .NET Core, you should say a little more about ServicePointManager.  The above property indicates the number of default connections that will be used for subsequent connections with any domain.  But along with this, it is possible to control the parameters for each domain name individually and this is done through the ServicePoint class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk"</span></span>)); delayServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  After executing this code, any interaction with Habr through the same HttpClient instance will use 5 simultaneous connections, and with the ‚Äúslowwly‚Äù site - 3 connections. <br><br>  There is another interesting nuance here - the limit on the number of connections for local addresses (localhost) is int.MaxValue by default.  Just look at the results of executing this code without first setting the DefaultConnectionLimit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); Console.WriteLine(habrServicePoint.ConnectionLimit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>)); Console.WriteLine(localServicePoint.ConnectionLimit);</code> </pre><br>  Now we‚Äôll move on to .NET Core.  Although ServicePointManager still exists in the System.Net namespace, it does not affect the behavior of the HttpClient in the .NET Core.  Instead, HTTP connection parameters can be controlled using HttpClientHandler (or SocketsHttpHandler, which we will talk about later): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler(); handler.MaxConnectionsPerServer = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  The above example will behave in exactly the same way as the initial example for the usual .NET Framework - to establish only 2 connections at a time.  But if you remove the line with the MaxConnectionsPerServer property set, the number of simultaneous connections will be much higher, since the default value in this .NET Core is int.MaxValue. <br><br><a name="3"></a>  And now we will consider the third non-obvious problem with default settings, which can be no less critical than the previous two - <b>long-lived connections and DNS caching</b> .  When establishing a connection with a remote server, first of all, the domain name is resolved to the corresponding IP address, then the resulting address is placed in the cache for some time in order to speed up subsequent connections.  In addition, to save resources, most often the connection is not closed after each request is executed, but kept open for a long time. <br><br>  Imagine that the system we are developing should work normally without a forced restart if the server with which it interacts has moved to another IP address.  For example, in the case of switching to another data center due to a failure in the current one.  Even if a permanent connection is lost due to a failure in the first data center (which may not be fast enough), the DNS cache will not allow our system to respond quickly to such a change.  The same is true for referring to the address at which load balancing is done via DNS round-robin. <br><br>  In the case of a ‚Äúnormal‚Äù .NET framework, this behavior can be controlled via ServicePointManager and ServicePoint (all the parameters below take values ‚Äã‚Äãin milliseconds): <br><br><ul><li>  ServicePointManager.DnsRefreshTimeout - indicates how long the acquired IP address will be cached for each domain name, the default value is 2 minutes (120000). </li><li>  ServicePoint.ConnectionLeaseTimeout - indicates how long a connection can be kept open.  By default, there is no time limit for connections; any connection can be maintained indefinitely, since this parameter is -1.  Setting it to 0 will cause each connection to close immediately after the request is executed. </li><li>  ServicePoint.MaxIdleTime - specifies how long the inactivity of the connection will be closed.  Inactivity means no data transmission over the connection.  The default value for this parameter is 100 seconds (100,000). </li></ul><br>  Now, to improve the understanding of these parameters, we combine them all in one scenario.  Suppose that DnsRefreshTimeout and MaxIdleTime have not been changed and they are equal to 120 and 100 seconds, respectively.  With this, ConnectionLeaseTimeout was set to 60 seconds.  The application establishes only one connection, through which it sends requests every 10 seconds. <br><br>  With such settings, the connection will be closed every 60 seconds (ConnectionLeaseTimeout), even though it periodically transfers data.  Closing and re-creating will occur in such a way as not to interfere with the correct execution of requests - if the time has expired and the request is still being executed, the connection will be closed after the request is completed.  Each time the connection is re-established, the corresponding IP address will first be taken from the cache, and only if the lifetime of its resolution has expired (120 seconds), the system will send a request to the DNS server. <br><br>  The MaxIdleTime parameter in this scenario will not play a role, since the connection is not inactive for more than 10 seconds. <br><br>  The optimal ratio of these parameters strongly depends on the specific situation and non-functional requirements: <br><br><ul><li>  If transparent switching of IP addresses is not assumed at all behind the domain name that your application accesses, and at the same time it is necessary to minimize the cost of network connections, then the default settings look like a good option. </li><li>  If there is a need to switch between IP addresses in case of failures, then you can set DnsRefreshTimeout to 0, and ConnectionLeaseTimeout to a non-negative value that suits you.  What specifically - very much depends on how quickly you need to switch to another IP.  Obviously, you want to have the fastest possible response to a failure, but here you need to find the optimal value, which, on the one hand, provides the allowable switching time, on the other hand, it does not degrade the throughput and system response time by too frequent re-creation of connections. <br></li><li>  If you need a quicker response to changing the IP address, for example, as in the case of balancing round-robin via DNS, you can try to set DnsRefreshTimeout and ConnectionLeaseTimeout to 0, but this will be extremely wasteful: for each request, the DNS server will be polled first, after which the connection to the target node will be re-established. <br></li><li>  There may be situations where setting the ConnectionLeaseTimeout to 0 with a non-zero DnsRefreshTimeout may be useful, but I cannot go on with the appropriate script.  Logically, this will mean that connections will be created anew for each request, but, at the same time, IP addresses will be taken from the cache whenever possible. </li></ul><br>  Below is an example of the code with which you can observe the behavior of the parameters described above: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ServicePointManager.DnsRefreshTimeout = <span class="hljs-number"><span class="hljs-number">120000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.MaxIdleTime = <span class="hljs-number"><span class="hljs-number">100000</span></span>; habrServicePoint.ConnectionLeaseTimeout = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { client.GetAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); }</code> </pre><br>  <i>While the test program is running, you can run netstat in a loop via PowerShell to monitor the connections it establishes.</i> <br><br>  Here it should be said how to manage the described parameters in .NET Core.  Settings from ServicePointManager, as in the case of ConnectionLimit, will not work.  In Core, there is a special type of HTTP handler that implements two of the three parameters described above - SocketsHttpHandler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketsHttpHandler(); handler.PooledConnectionLifetime = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ConnectionLeaseTimeout handler.PooledConnectionIdleTimeout = TimeSpan.FromSeconds(100); // MaxIdleTime var client = new HttpClient(handler);</span></span></code> </pre><br>  There is no parameter that controls the time to cache DNS records in .NET Core.  Test examples show that caching does not work - when creating a new DNS connection, resolution is performed again, respectively, for normal operation in conditions where the requested domain name can switch between different IP addresses, just set PooledConnectionLifetime to the desired value. <br><br>  On top of that, be sure to say that all these problems could not have been unnoticed by developers from Microsoft, and therefore, starting with .NET Core 2.1, there was a factory of HTTP clients that solved some of them - <a href="http-requests">https://docs.microsoft.com/en- us / dotnet / standard / microservices-architecture / implement-resilient-applications / use-http client-to-implement-resilient-http-requests</a> .  Moreover, in addition to managing the lifetime of connections, a new component provides opportunities for creating typed clients, as well as some other useful things.  This article and links to it contain enough information and examples on using the HttpClientFactory, so in this article I will not consider the details associated with it. </div><p>Source: <a href="https://habr.com/ru/post/424873/">https://habr.com/ru/post/424873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424861/index.html">The snake in the mailbox and what's with F #</a></li>
<li><a href="../424865/index.html">Found elementary design particles</a></li>
<li><a href="../424867/index.html">Developing a hexapod from scratch (part 1) - designing</a></li>
<li><a href="../424869/index.html">As a new feature iOS 12 reminded me that it was time to be treated</a></li>
<li><a href="../424871/index.html">Ilon Musk and Tesla settle legal disputes with the US Securities and Exchange Commission</a></li>
<li><a href="../424875/index.html">Why they didn‚Äôt call me back -2, or where the applicants disappear</a></li>
<li><a href="../424877/index.html">Liquid brake cooling system</a></li>
<li><a href="../424879/index.html">Interface availability. Yandex lecture</a></li>
<li><a href="../424881/index.html">Newtoo - development of a full browser engine from scratch in 2018?</a></li>
<li><a href="../424887/index.html">What Lida is silent about: the beginning of a developer's career. Principles or how to become Middl'om</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>