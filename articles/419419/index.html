<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UI autotests: how to do not</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. My name is Vitaliy Kotov, I work in the testing department of Badoo. I write a lot of UI autotests, but I work even more with those who h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UI autotests: how to do not</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr.  My name is Vitaliy Kotov, I work in the testing department of Badoo.  I write a lot of UI autotests, but I work even more with those who have been doing this not so long ago and have not had time to step on all the rakes. <br><br>  So, adding up my own experience and observing other guys, I decided to prepare for you a collection of ‚Äúhow to write tests is not worth it.‚Äù  I supported each example with a detailed description, code examples and screenshots. <br><br>  The article will be interesting to novice authors of UI-tests, but the old-timers in this topic will surely learn something new, or just smile, remembering themselves ‚Äúin youth‚Äù.  :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Go! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Content </h2><br><ul><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Locators without attributes</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Check for missing item</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Check item appearance</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Random data</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Atomicity of tests (part 1)</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Atomicity of tests (part 2)</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Error clicking on an existing item</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Error text</a> </li><li>  <a href="https://habr.com/ru/company/badoo/blog/419419/">Total</a> </li></ul><a name="locators"></a><br><h2>  Locators without attributes </h2><br>  Let's start with a simple example.  Since we are talking about UI tests, locators play a significant role in them.  A locator is a string composed according to a certain rule and describing one or several XML (in particular, HTML) elements. <br><br>  There are several types of locators.  For example, <a href="https://ru.wikipedia.org/wiki/CSS">css locators</a> are used for cascading style sheets.  <a href="https://ru.wikipedia.org/wiki/XPath">XPath locators</a> are used to work with XML documents.  And so on. <br><br>  A complete list of locator types used in <a href="https://ru.wikipedia.org/wiki/Selenium">Selenium</a> can be found at <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/By.html">seleniumhq.github.io</a> . <br><br>  In UI tests, locators are used to describe the elements with which the driver must interact. <br><br>  Virtually any browser inspector has the ability to select the element of interest to us and copy it to XPath.  It looks like this: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  It turns out such a locator: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  It seems that there is nothing wrong with such a locator.  After all, we can save it in some kind of constant or class field, which by its name will convey the essence of the element: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  And wrap the appropriate error text in case the element is not found: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(‚ÄúCannot find Create Account button.‚Äù) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  This approach has a plus: there is no need to learn XPath. <br><br>  However, there are a number of disadvantages.  First, when changing the layout there is no guarantee that the element on such a locator will remain the same.  It is possible that another will take its place, leading to unforeseen circumstances.  Secondly, the task of autotests is to search for bugs, and not to follow the changes in the layout.  Therefore, adding a wrapper or some other element above the tree should not affect our tests.  Otherwise, it will take us quite a lot of time to update the locators. <br><br>  Conclusion: locators should be created that correctly describe the element and are resistant to changes in the layout outside the tested part of our application.  For example, you can bind to one or more attributes of an element: <br><br> <code>//a[@rel=‚ÄùcreateAccount‚Äù] <br></code> <br>  Such a locator is easier to perceive in the code, and it will break only if the ‚Äúrel‚Äù disappears. <br><br>  Another plus of this locator is the ability to search in the repository of the template with the specified attribute.  And what to look for if the locator looks like in the original example?  :) <br><br>  If, initially, the elements have no attributes in the application or they are set automatically (for example, due to <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2584%25D1%2583%25D1%2581%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5)">obfuscation of</a> classes), it is worth discussing it with the developers.  They should be no less interested in automating product testing and will surely meet you and offer a solution. <br><a name="no_element"></a><br><h2>  Check for missing item </h2><br>  Every Badoo user has his own profile.  It contains information about the user: (name, age, photos) and information about who the user wants to communicate with.  In addition, it is possible to specify your interests. <br><br>  Suppose once we had a bug (although, of course, this is not so :)).  The user in his profile chose interests.  Not finding a suitable interest from the list, he decided to click "More" to update the list. <br><br>  Expected behavior: old interests should disappear, new ones should appear.  But instead, an ‚ÄúUnexpected Error‚Äù popped up: <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  It turned out that there was a problem on the server side, the wrong answer came, and the client processed the case, showing the corresponding notification. <br><br>  Our task is to write an autotest that will check this case. <br><br>  We write about the following script: <br><br><ul><li>  View Profile </li><li>  View interest list </li><li>  Click the "More" button </li><li>  Verify that the error did not appear (for example, there is no div.error element) </li></ul><br>  This is the test we are launching.  However, the following happens: after a few days / months / years, the bug reappears, although the test does not catch anything.  Why? <br><br>  Everything is quite simple: during the successful passing of the test, the element locator for which we searched for the error text has changed.  There was a refactoring of templates and instead of the class ‚Äúerror‚Äù we had a class ‚Äúerror_new‚Äù. <br><br>  During refactoring, the test continued to work as expected.  Element ‚Äúdiv.error‚Äù did not appear, there was no reason for the fall.  But now the ‚Äúdiv.error‚Äù element does not exist at all - therefore, the test will never fall, no matter what happens in the application. <br><br>  Conclusion: it is better to test the performance of the interface with positive checks.  In our example, one would expect the list of interests to change. <br><br>  There are situations when a negative test cannot be replaced by a positive one.  For example, when interacting with an element in a ‚Äúgood‚Äù situation, nothing happens, and in a ‚Äúbad‚Äù situation, an error occurs.  In this case, it is worthwhile to think of a way to simulate a ‚Äúbad‚Äù scenario and write an autotest on it too.  Thus, we will verify that in the negative case an element of error appears, and thus we will monitor the relevance of the locator. <br><a name="element_exists"></a><br><h2>  Check item appearance </h2><br>  How to make sure that the interaction of the test with the interface was successful and everything works?  Most often this can be seen in the changes that have occurred in this interface. <br><br>  Consider an example.  You must make sure that when sending a message it appears in the chat: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  The script looks like this: <br><br><ul><li>  View user profile </li><li>  Open chat with him </li><li>  to write a message </li><li>  To send </li><li>  Wait for the message to appear </li></ul><br>  We describe this scenario in our test.  Suppose a chat message matches a locator: <br><br> <code>p.message_text <br></code> <br>  This is how we verify that the item appeared: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  If our wait works, then everything is fine: messages in the chat are rendered. <br><br>  As you may have guessed, after some time sending messages in the chat breaks down, but our test continues to work without interruption.  Let's figure it out. <br><br>  It turns out that a new element appeared in the chat the day before: some text that invites the user to highlight a message if it suddenly went unnoticed: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  And, funny thing is, it also falls under our locator.  Only he has an additional class that distinguishes him from the sent messages: <br><br> <code>p.message_text.highlight <br></code> <br>  Our test did not break with the appearance of this unit, but the ‚Äúwait for a message‚Äù check has ceased to be relevant.  The element that was an indicator of a successful event is now always there. <br><br>  Conclusion: if the test logic is based on checking the appearance of an element, you should definitely check that there is no such element before our interaction with the UI. <br><br><ul><li>  View user profile </li><li>  Open chat with him </li><li>  <b>Make sure there are no sent messages.</b> </li><li>  to write a message </li><li>  To send </li><li>  Wait for the message to appear </li></ul><br><a name="random_data"></a><h2>  Random data </h2><br>  Quite often, UI tests work with the forms in which they enter certain data.  For example, we have a registration form: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Data for such tests can be stored in configs or hard-coded in the test.  But sometimes the thought comes to mind: why not randomize the data?  This is good, we will cover more cases! <br><br>  My advice: do not.  And now I will tell you why. <br><br>  Suppose our test is registered on Badoo.  We decide that the gender of the user we will choose randomly.  At the time of writing the test, the flow registration for the girl and the boy is no different, so our test passes successfully. <br><br>  Now imagine that after some time the registration flow becomes different.  For example, we give a girl free bonuses immediately after registration, which we notify her with a special overlay. <br><br>  In the test there is no logic to close the overlay, and it, in turn, interferes with any further actions prescribed in the test.  We get a test that falls 50% of the time.  Any automator will confirm that UI tests are inherently not stable.  And this is normal, one has to live with it, constantly tacking between redundant logic ‚Äúfor all occasions‚Äù (which significantly damages the readability of the code and complicates its support) and this very instability. <br><br>  The next time the test falls, we may not have time to deal with it.  We just restart it and see what it is.  We will decide that in our application everything works as it should and the point is in an unstable test.  And calm down. <br><br>  Now let's go further.  What if this overlay breaks?  The test will continue to pass in 50% of cases, which significantly postpones the problem. <br><br>  And this is good when, due to the randomization of data, we create a situation of ‚Äú50 to 50‚Äù.  But it happens in a different way.  For example, before registering, a password of at least three characters was considered acceptable.  We write code that comes up with a random password no shorter than three characters (sometimes there are three and sometimes more characters).  And then the rule changes - and the password must contain at least four characters.  What probability of falling will we get in this case?  And, if our test will catch a real bug, how quickly will we figure this out? <br><br>  It is especially difficult to work with tests where a lot of random data is entered: name, gender, password, and so on ... In this case too many different combinations, and if an error occurs in one of them, it is usually not easy to notice. <br><br>  Conclusion.  As I wrote above, randomizing data is bad.  It is better to cover more cases at the expense of data providers, not forgetting about <a href="http://www.quizful.net/interview/qa/PXNFdeqNEnm8">equivalence classes</a> , by itself.  Passing tests will take more time, but you can fight it.  But we will be sure that if a problem exists, it will be detected. <br><a name="atom_tests_1"></a><br><h2>  Atomicity of tests (part 1) </h2><br>  Let's look at the following example.  We are writing a test that checks the user count in the footer. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  The script is simple: <br><br><ul><li>  Open application </li><li>  Find counter on footer </li><li>  Make sure it's visible </li></ul><br>  We call this test testFooterCounter and run it.  Then it becomes necessary to check that the meter does not show zero.  We add this test to an existing test, why not? <br><br>  But then there is a need to check that there is a link to the project description in the footer (the link ‚ÄúAbout Us‚Äù).  Write a new test or add to an existing one?  In the case of a new test, we will have to re-raise the application, prepare the user (if we check the footer on the authorized page), log in - in general, waste precious time.  In such a situation, renaming the test to testFooterCounterAndLinks seems like a good idea. <br><br>  On the one hand, this approach has advantages: saving time, storing all the checks of some part of our application (in this case, the footer) in one place. <br><br>  But there is a noticeable minus.  If the test fails at the first check, we will not check the rest of the component.  Suppose the test fell in some branch not because of instability, but because of a bug.  What to do?  Return task, describing only this problem?  Then we risk getting the task with fix only this bug, run the test and find that the component is also broken further, in another place.  And there can be many such iterations.  Kicking a ticket back and forth in this case will take a lot of time and will be ineffective. <br><br>  Conclusion: it is worth if possible to atomize the checks.  In this case, even having a problem in one case, we will check all the others.  And, if you have to return the ticket, we can immediately describe all the problem areas. <br><a name="atom_tests_2"></a><br><h2>  Atomicity of tests (part 2) </h2><br>  Consider another example.  We are writing a chat test that checks the following logic.  If the users have a mutual sympathy, the following block appears in the chat: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  The script looks like this: <br><br><ul><li>  Vote by user A for user B </li><li>  Vote by user B for user A </li><li>  User A open chat with user B </li><li>  Confirm that the block is in place </li></ul><br>  For a while the test works successfully, but then the following happens ... No, this time the test does not miss any bug.  :) <br><br>  After some time, we learn that there is another bug not related to our test: if we open the chat, immediately close and open it again, the block disappears.  Not the most obvious case, and in the test we, of course, did not foresee it.  But we decide to cover it too. <br><br>  The same question arises: write another test or insert a test into an existing one?  It seems inexpedient to write a new one, because 99% of the time it will do the same thing as an existing one.  And we decide to add the test to the test that already exists: <br><br><ul><li>  Vote by user A for user B </li><li>  Vote by user B for user A </li><li>  User A open chat with user B </li><li>  Confirm that the block is in place </li><li>  <b>Close chat</b> </li><li>  <b>Open chat</b> </li><li>  Confirm that the block is in place </li></ul><br>  The problem may emerge when, for example, we refactor a test after a long time.  For example, a redesign will happen on a project - and many tests will have to be rewritten. <br><br>  We will open the test and will try to remember what it checks.  For example, the test is called testPromoAfterMutualAttraction.  Will we understand why at the end of the opening and closing of the chat?  Most likely no.  Especially if this test was not written by us.  Will we leave this piece?  Maybe yes, but if there are any problems with it, it is likely that we will simply remove it.  And the test will be lost simply because its meaning will be unclear. <br><br>  I see two solutions here.  First, do the second test and call it testCheckBlockPresentAfterOpenAndCloseChat.  With such a name it will be clear that we are not just doing some kind of set of actions, but doing a conscious check, because there was a negative experience.  The second solution is to write in the code a detailed comment about why we are doing this test in this particular test.  In the comments, it is also desirable to indicate the bug number. <br><a name="click_error"></a><br><h2>  Error clicking on an existing item </h2><br>  The following example threw me a <a href="https://habr.com/users/bbidox/" class="user_link">bbidox</a> , for which he is a big plus in karma! <br><br>  There is a very interesting situation when the test code becomes already ... a framework.  Suppose we have this method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  At some point, something strange begins to happen with this method: the test crashes when you try to click a button.  We open a screenshot taken at the moment the test crashes, and we see that the button on the screenshot is and the waitForButtonToAppear method worked successfully.  Question: what is wrong with a click? <br><br>  The most difficult thing in this situation is that the test can sometimes be successful.  :) <br><br>  Let's figure it out.  Suppose that the button in the example is located on the overlay: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  This is a special overlay through which a user on our site can fill out information about himself.  When you click on the selected overlay button, the next block appears for filling. <br><br>  For fun, let's add an extra OLOLO class for this button: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  After that we click on this button.  Visually, nothing has changed, and the button itself has remained in place: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  What happened?  In fact, when JS redrawn the block to us, the button redrawed it too.  It is still available on the same locator, but this is another button.  This is indicated by the absence of the OLOLO class we added. <br><br>  In the code above, we store the element in the $ element variable.  If during this time the element is regenerated, visually it may not be noticeable, but clicking on it will not work anymore - the click () method will fall with an error. <br><br>  There are several solution options: <br><br><ul><li>  Wrap the click in a try block and in catch reassemble the element </li><li>  Add some attribute to a button to signal that it has changed </li></ul><br><a name="error_message"></a><h2>  Error text </h2><br>  Finally, a simple but equally important point. <br><br>  This example applies not only to UI tests, but also to them very often.  Usually, when you write a test, you are in the context of what is happening: you describe the test for the test and understand their meaning.  And the texts of errors you write in the same context: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  What could be incomprehensible in this code?  The test awaits the appearance of the button and, if it does not exist, naturally falls. <br><br>  Now imagine that the author of the test at the hospital, and his colleague looks after the tests.  And now the testQuestionsOnProfile test fails and writes the following message: ‚ÄúCannot find button‚Äù.  A colleague needs to sort things out as soon as possible, because the release is coming soon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  What will he have to do? <br><br>  It makes no sense to open the page on which the test fell, and check the a.link locator - there is no element.  Therefore, it is necessary to carefully study the test and understand what he is checking. <br><br>  It would be much easier with a more detailed text of the error: ‚ÄúCannot find the button on the questions overlay‚Äù.  With this error, you can immediately open the overlay and see where the button went. <br><br>  Output two.  First, in any method of your test framework it is worth passing the text of the error, with the obligatory parameter so that there is no temptation to forget about it.  Secondly, the text of the error is worth doing detailed.  This does not always mean that it should be long - it is enough to make it clear what went wrong in the test. <br><br>  How to understand that the text of the error is written well?  Very simple.  Imagine that your application is broken and you need to go to the developers and explain what and where it broke.  If you tell them only what is written in the text of the error, they will understand? <br><a name="summary"></a><br><h2>  Total </h2><br>  Writing a test script is often an interesting exercise.  At the same time, we pursue many goals.  Our tests should: <br><br><ul><li>  cover as many cases as possible </li><li>  work as fast as possible </li><li>  to be clear </li><li>  just expand </li><li>  easy to maintain </li><li>  order pizza </li><li>  and so on‚Ä¶ </li></ul><br>  It is especially interesting to work with tests in a constantly evolving and changing project, where they have to be constantly updated: add something and cut something.  That is why it is worthwhile to think over some points in advance and not always rush into decisions.  :) <br><br>  I hope my advice will help you avoid some of the problems and force you to approach to the drafting of cases more thoughtfully.  If the article is liked by the public, I will try to collect some more non-dull examples.  And bye bye! </div><p>Source: <a href="https://habr.com/ru/post/419419/">https://habr.com/ru/post/419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419409/index.html">New Intel NUC based on the Coffee Lake processor</a></li>
<li><a href="../419411/index.html">About a fire in a skyscraper. Cinema and reality</a></li>
<li><a href="../419413/index.html">Chisel - (not quite) new approach to the development of digital logic</a></li>
<li><a href="../419415/index.html">Mattermost and Powershell - a huge force, or small automation on their own</a></li>
<li><a href="../419417/index.html">GDPR: Data mapping or how customers find long-forgotten laptops</a></li>
<li><a href="../419423/index.html">We are promised a real-time video without friezes and twitching.</a></li>
<li><a href="../419425/index.html">Security Week 29. Hacking Reddit, a cryptocurrency wallet and MikroTik routers</a></li>
<li><a href="../419427/index.html">Epson invites everyone to the picnic for geeks 2018</a></li>
<li><a href="../419429/index.html">I'm 57 and I'm a scrum master</a></li>
<li><a href="../419431/index.html">A year with Scrum or how to professional development of developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>